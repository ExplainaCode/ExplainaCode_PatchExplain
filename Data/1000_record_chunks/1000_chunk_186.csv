record_number,buggy_code,fixed_code,code_similarity
185001,"@Override protected void onDialogClosed(boolean positiveResult){
  super.onDialogClosed(positiveResult);
  if (positiveResult) {
    setEnabled(false);
    Context context=getContext();
    if (BrowserSettings.PREF_CLEAR_CACHE.equals(getKey())) {
      BrowserSettings.getInstance().clearCache(context);
      BrowserSettings.getInstance().clearDatabases(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_COOKIES.equals(getKey())) {
      BrowserSettings.getInstance().clearCookies(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_HISTORY.equals(getKey())) {
      BrowserSettings.getInstance().clearHistory(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_FORM_DATA.equals(getKey())) {
      BrowserSettings.getInstance().clearFormData(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_PASSWORDS.equals(getKey())) {
      BrowserSettings.getInstance().clearPasswords(context);
    }
 else     if (BrowserSettings.PREF_EXTRAS_RESET_DEFAULTS.equals(getKey())) {
      BrowserSettings.getInstance().resetDefaultPreferences(context);
      setEnabled(true);
    }
 else     if (BrowserSettings.PREF_CLEAR_LOCATION_ACCESS.equals(getKey())) {
      BrowserSettings.getInstance().clearLocationAccess(context);
    }
  }
}","@Override protected void onDialogClosed(boolean positiveResult){
  super.onDialogClosed(positiveResult);
  if (positiveResult) {
    setEnabled(false);
    Context context=getContext();
    if (BrowserSettings.PREF_CLEAR_CACHE.equals(getKey())) {
      BrowserSettings.getInstance().clearCache(context);
      BrowserSettings.getInstance().clearDatabases(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_COOKIES.equals(getKey())) {
      BrowserSettings.getInstance().clearCookies(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_HISTORY.equals(getKey())) {
      BrowserSettings.getInstance().clearHistory(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_FORM_DATA.equals(getKey())) {
      BrowserSettings.getInstance().clearFormData(context);
    }
 else     if (BrowserSettings.PREF_CLEAR_PASSWORDS.equals(getKey())) {
      BrowserSettings.getInstance().clearPasswords(context);
    }
 else     if (BrowserSettings.PREF_EXTRAS_RESET_DEFAULTS.equals(getKey())) {
      BrowserSettings.getInstance().resetDefaultPreferences(context);
      setEnabled(true);
    }
 else     if (BrowserSettings.PREF_CLEAR_GEOLOCATION_ACCESS.equals(getKey())) {
      BrowserSettings.getInstance().clearLocationAccess(context);
    }
  }
}",0.9987966305655837
185002,"@Override protected void onNewIntent(Intent intent){
  TabControl.Tab current=mTabControl.getCurrentTab();
  if (current == null) {
    current=mTabControl.getTab(0);
    if (current == null) {
      return;
    }
    mTabControl.setCurrentTab(current);
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.setCurrentTab(mTabControl.getTabIndex(current));
    }
    attachTabToContentView(current);
    resetTitleAndIcon(current.getWebView());
  }
  final String action=intent.getAction();
  final int flags=intent.getFlags();
  if (Intent.ACTION_MAIN.equals(action) || (flags & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) != 0) {
    return;
  }
  if (Intent.ACTION_VIEW.equals(action) || Intent.ACTION_SEARCH.equals(action) || MediaStore.INTENT_ACTION_MEDIA_SEARCH.equals(action)|| Intent.ACTION_WEB_SEARCH.equals(action)) {
    if (handleWebSearchIntent(intent)) {
      return;
    }
    UrlData urlData=getUrlDataFromIntent(intent);
    if (urlData.isEmpty()) {
      urlData=new UrlData(mSettings.getHomePage());
    }
    urlData.setPostData(intent.getByteArrayExtra(Browser.EXTRA_POST_DATA));
    final String appId=intent.getStringExtra(Browser.EXTRA_APPLICATION_ID);
    if (Intent.ACTION_VIEW.equals(action) && !getPackageName().equals(appId) && (flags & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != 0) {
      TabControl.Tab appTab=mTabControl.getTabFromId(appId);
      if (appTab != null) {
        Log.i(LOGTAG,""String_Node_Str"" + appId);
        dismissSubWindow(appTab);
        removeTabFromContentView(appTab);
        boolean needsLoad=mTabControl.recreateWebView(appTab,urlData.mUrl);
        if (current != appTab) {
          switchToTab(mTabControl.getTabIndex(appTab));
          if (needsLoad) {
            urlData.loadIn(appTab.getWebView());
          }
        }
 else {
          attachTabToContentView(appTab);
          if (needsLoad) {
            urlData.loadIn(appTab.getWebView());
          }
        }
        return;
      }
 else {
        appTab=mTabControl.findUnusedTabWithUrl(urlData.mUrl);
        if (appTab != null && current != appTab) {
          switchToTab(mTabControl.getTabIndex(appTab));
        }
 else {
          openTabAndShow(urlData,true,appId);
        }
      }
    }
 else {
      if (""String_Node_Str"".equals(urlData.mUrl)) {
        mSettings.toggleDebugSettings();
        return;
      }
      dismissSubWindow(current);
      urlData.loadIn(current.getWebView());
    }
  }
}","@Override protected void onNewIntent(Intent intent){
  TabControl.Tab current=mTabControl.getCurrentTab();
  if (current == null) {
    current=mTabControl.getTab(0);
    if (current == null) {
      return;
    }
    mTabControl.setCurrentTab(current);
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.setCurrentTab(mTabControl.getTabIndex(current));
    }
    attachTabToContentView(current);
    resetTitleAndIcon(current.getWebView());
  }
  final String action=intent.getAction();
  final int flags=intent.getFlags();
  if (Intent.ACTION_MAIN.equals(action) || (flags & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) != 0) {
    return;
  }
  if (Intent.ACTION_VIEW.equals(action) || Intent.ACTION_SEARCH.equals(action) || MediaStore.INTENT_ACTION_MEDIA_SEARCH.equals(action)|| Intent.ACTION_WEB_SEARCH.equals(action)) {
    if (handleWebSearchIntent(intent)) {
      return;
    }
    UrlData urlData=getUrlDataFromIntent(intent);
    if (urlData.isEmpty()) {
      urlData=new UrlData(mSettings.getHomePage());
    }
    urlData.setPostData(intent.getByteArrayExtra(Browser.EXTRA_POST_DATA));
    final String appId=intent.getStringExtra(Browser.EXTRA_APPLICATION_ID);
    if (Intent.ACTION_VIEW.equals(action) && !getPackageName().equals(appId) && (flags & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != 0) {
      TabControl.Tab appTab=mTabControl.getTabFromId(appId);
      if (appTab != null) {
        Log.i(LOGTAG,""String_Node_Str"" + appId);
        dismissSubWindow(appTab);
        removeTabFromContentView(appTab);
        boolean needsLoad=mTabControl.recreateWebView(appTab,urlData.mUrl);
        if (current != appTab) {
          switchToTab(mTabControl.getTabIndex(appTab));
          if (needsLoad) {
            urlData.loadIn(appTab.getWebView());
          }
        }
 else {
          attachTabToContentView(appTab);
          if (needsLoad) {
            urlData.loadIn(appTab.getWebView());
          }
        }
        return;
      }
 else {
        appTab=mTabControl.findUnusedTabWithUrl(urlData.mUrl);
        if (appTab != null) {
          if (current != appTab) {
            switchToTab(mTabControl.getTabIndex(appTab));
          }
        }
 else {
          openTabAndShow(urlData,true,appId);
        }
      }
    }
 else {
      if (""String_Node_Str"".equals(urlData.mUrl)) {
        mSettings.toggleDebugSettings();
        return;
      }
      dismissSubWindow(current);
      urlData.loadIn(current.getWebView());
    }
  }
}",0.9926470588235294
185003,"/** 
 * Switch tabs.  Called by the TitleBarSet when sliding the title bar results in changing tabs.
 */
void switchToTab(int index){
  TabControl.Tab tab=mTabControl.getTab(index);
  TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (tab == null || tab == currentTab) {
    return;
  }
  if (currentTab != null) {
    removeTabFromContentView(currentTab);
  }
  removeTabFromContentView(tab);
  mTabControl.setCurrentTab(tab);
  attachTabToContentView(tab);
}","/** 
 * Switch tabs.  Called by the TitleBarSet when sliding the title bar results in changing tabs.
 * @param index Index of the tab to change to, as defined bymTabControl.getTabIndex(Tab t).
 * @return boolean True if we successfully switched to a different tab.  Ifthe indexth tab is null, or if that tab is the same as the current one, return false.
 */
boolean switchToTab(int index){
  TabControl.Tab tab=mTabControl.getTab(index);
  TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (tab == null || tab == currentTab) {
    return false;
  }
  if (currentTab != null) {
    removeTabFromContentView(currentTab);
  }
  removeTabFromContentView(tab);
  mTabControl.setCurrentTab(tab);
  attachTabToContentView(tab);
  return true;
}",0.7658175842235004
185004,"void bookmarksOrHistoryPicker(boolean startWithHistory){
  WebView current=mTabControl.getCurrentWebView();
  if (current == null) {
    return;
  }
  Intent intent=new Intent(this,CombinedBookmarkHistoryActivity.class);
  String title=current.getTitle();
  String url=current.getUrl();
  if (null == url) {
    url=mLastEnteredUrl;
    if (null == url) {
      url=mSettings.getHomePage();
    }
  }
  if (title == null) {
    title=url;
  }
  intent.putExtra(""String_Node_Str"",title);
  intent.putExtra(""String_Node_Str"",url);
  intent.putExtra(""String_Node_Str"",mTabControl.getTabCount() >= TabControl.MAX_TABS);
  intent.putExtra(""String_Node_Str"",current.getTouchIconUrl());
  if (startWithHistory) {
    intent.putExtra(CombinedBookmarkHistoryActivity.STARTING_TAB,CombinedBookmarkHistoryActivity.HISTORY_TAB);
  }
  startActivityForResult(intent,COMBO_PAGE);
}","/** 
 * Open the Go page.
 * @param startWithHistory If true, open starting on the history tab.Otherwise, start with the bookmarks tab.
 * @param cancelGoPageMeansClose Set to true if this came from a new tab, orfrom the only tab, and canceling means to close the tab (and possibly the browser)
 */
void bookmarksOrHistoryPicker(boolean startWithHistory,boolean cancelGoPageMeansClose){
  WebView current=mTabControl.getCurrentWebView();
  if (current == null) {
    return;
  }
  Intent intent=new Intent(this,CombinedBookmarkHistoryActivity.class);
  String title=current.getTitle();
  String url=current.getUrl();
  if (null == url) {
    url=mLastEnteredUrl;
    if (null == url) {
      url=mSettings.getHomePage();
    }
  }
  if (title == null) {
    title=url;
  }
  intent.putExtra(""String_Node_Str"",title);
  intent.putExtra(""String_Node_Str"",url);
  intent.putExtra(""String_Node_Str"",mTabControl.getTabCount() >= TabControl.MAX_TABS);
  intent.putExtra(""String_Node_Str"",current.getTouchIconUrl());
  if (startWithHistory) {
    intent.putExtra(CombinedBookmarkHistoryActivity.STARTING_TAB,CombinedBookmarkHistoryActivity.HISTORY_TAB);
  }
  mCancelGoPageMeansClose=cancelGoPageMeansClose;
  startActivityForResult(intent,COMBO_PAGE);
}",0.8202459791863765
185005,"void closeCurrentWindow(){
  final int currentIndex=mTabControl.getCurrentIndex();
  final TabControl.Tab current=mTabControl.getCurrentTab();
  final TabControl.Tab parent=current.getParentTab();
  int indexToShow=-1;
  if (parent != null) {
    indexToShow=mTabControl.getTabIndex(parent);
  }
 else {
    indexToShow=mTabControl.getTabCount() - 1;
    if (currentIndex == indexToShow) {
      indexToShow--;
    }
  }
  switchToTab(indexToShow);
  closeTab(current);
}","void closeCurrentWindow(){
  final TabControl.Tab current=mTabControl.getCurrentTab();
  if (mTabControl.getTabCount() == 1) {
    TabControl.Tab newTab=openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
    bookmarksOrHistoryPicker(false,true);
    closeTab(current);
    mTabControl.setCurrentTab(newTab);
    return;
  }
  final TabControl.Tab parent=current.getParentTab();
  int indexToShow=-1;
  if (parent != null) {
    indexToShow=mTabControl.getTabIndex(parent);
  }
 else {
    final int currentIndex=mTabControl.getCurrentIndex();
    indexToShow=currentIndex + 1;
    if (indexToShow > mTabControl.getTabCount() - 1) {
      indexToShow=currentIndex - 1;
    }
  }
  if (switchToTab(indexToShow)) {
    closeTab(current);
  }
}",0.4397046759639048
185006,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent intent){
switch (requestCode) {
case COMBO_PAGE:
    if (resultCode == RESULT_OK && intent != null) {
      String data=intent.getAction();
      Bundle extras=intent.getExtras();
      if (extras != null && extras.getBoolean(""String_Node_Str"",false)) {
        final TabControl.Tab newTab=openTab(data);
        if (mSettings.openInBackground() && newTab != null) {
          mTabControl.populatePickerData(newTab);
          mTabControl.setCurrentTab(newTab);
          int newIndex=mTabControl.getCurrentIndex();
          if (CUSTOM_BROWSER_BAR) {
            mTitleBar.setCurrentTab(newIndex);
          }
        }
      }
 else {
        final TabControl.Tab currentTab=mTabControl.getCurrentTab();
        dismissSubWindow(currentTab);
        if (data != null && data.length() != 0) {
          getTopWindow().loadUrl(data);
        }
      }
    }
  break;
default :
break;
}
getTopWindow().requestFocus();
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent intent){
switch (requestCode) {
case COMBO_PAGE:
    if (resultCode == RESULT_OK && intent != null) {
      String data=intent.getAction();
      Bundle extras=intent.getExtras();
      if (extras != null && extras.getBoolean(""String_Node_Str"",false)) {
        final TabControl.Tab newTab=openTab(data);
        if (mSettings.openInBackground() && newTab != null) {
          mTabControl.populatePickerData(newTab);
          mTabControl.setCurrentTab(newTab);
          int newIndex=mTabControl.getCurrentIndex();
          if (CUSTOM_BROWSER_BAR) {
            mTitleBar.setCurrentTab(newIndex);
          }
        }
      }
 else {
        final TabControl.Tab currentTab=mTabControl.getCurrentTab();
        dismissSubWindow(currentTab);
        if (data != null && data.length() != 0) {
          getTopWindow().loadUrl(data);
        }
      }
    }
 else     if (resultCode == RESULT_CANCELED && mCancelGoPageMeansClose) {
      if (mTabControl.getTabCount() == 1) {
        finish();
        return;
      }
      closeCurrentWindow();
    }
  break;
default :
break;
}
mCancelGoPageMeansClose=false;
if (getTopWindow() != null) {
getTopWindow().requestFocus();
}
}",0.8859298712827341
185007,"@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!mCanChord) {
    return false;
  }
  if (null == getTopWindow()) {
    return false;
  }
  if (mMenuIsDown) {
    mMenuIsDown=false;
  }
switch (item.getItemId()) {
case R.id.goto_menu_id:
    bookmarksOrHistoryPicker(false);
  break;
case R.id.add_bookmark_menu_id:
Intent i=new Intent(BrowserActivity.this,AddBookmarkPage.class);
WebView w=getTopWindow();
i.putExtra(""String_Node_Str"",w.getUrl());
i.putExtra(""String_Node_Str"",w.getTitle());
startActivity(i);
break;
case R.id.stop_reload_menu_id:
if (mInLoad) {
stopLoading();
}
 else {
getTopWindow().reload();
}
break;
case R.id.back_menu_id:
getTopWindow().goBack();
break;
case R.id.forward_menu_id:
getTopWindow().goForward();
break;
case R.id.close_menu_id:
if (mTabControl.getCurrentSubWindow() != null) {
dismissSubWindow(mTabControl.getCurrentTab());
break;
}
closeCurrentWindow();
break;
case R.id.homepage_menu_id:
TabControl.Tab current=mTabControl.getCurrentTab();
if (current != null) {
dismissSubWindow(current);
current.getWebView().loadUrl(mSettings.getHomePage());
}
break;
case R.id.preferences_menu_id:
Intent intent=new Intent(this,BrowserPreferencesPage.class);
startActivityForResult(intent,PREFERENCES_PAGE);
break;
case R.id.find_menu_id:
if (null == mFindDialog) {
mFindDialog=new FindDialog(this);
}
mFindDialog.setWebView(getTopWindow());
mFindDialog.show();
mMenuState=EMPTY_MENU;
break;
case R.id.select_text_id:
getTopWindow().emulateShiftHeld();
break;
case R.id.page_info_menu_id:
showPageInfo(mTabControl.getCurrentTab(),false);
break;
case R.id.classic_history_menu_id:
bookmarksOrHistoryPicker(true);
break;
case R.id.share_page_menu_id:
Browser.sendString(this,getTopWindow().getUrl());
break;
case R.id.dump_nav_menu_id:
getTopWindow().debugDump();
break;
case R.id.zoom_in_menu_id:
getTopWindow().zoomIn();
break;
case R.id.zoom_out_menu_id:
getTopWindow().zoomOut();
break;
case R.id.view_downloads_menu_id:
viewDownloads(null);
break;
case R.id.window_one_menu_id:
case R.id.window_two_menu_id:
case R.id.window_three_menu_id:
case R.id.window_four_menu_id:
case R.id.window_five_menu_id:
case R.id.window_six_menu_id:
case R.id.window_seven_menu_id:
case R.id.window_eight_menu_id:
{
int menuid=item.getItemId();
for (int id=0; id < WINDOW_SHORTCUT_ID_ARRAY.length; id++) {
if (WINDOW_SHORTCUT_ID_ARRAY[id] == menuid) {
TabControl.Tab desiredTab=mTabControl.getTab(id);
if (desiredTab != null && desiredTab != mTabControl.getCurrentTab()) {
switchToTab(id);
mTitleBar.setCurrentTab(id);
}
break;
}
}
}
break;
default :
if (!super.onOptionsItemSelected(item)) {
return false;
}
}
mCanChord=false;
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!mCanChord) {
    return false;
  }
  if (null == getTopWindow()) {
    return false;
  }
  if (mMenuIsDown) {
    mMenuIsDown=false;
  }
switch (item.getItemId()) {
case R.id.goto_menu_id:
    bookmarksOrHistoryPicker(false,false);
  break;
case R.id.add_bookmark_menu_id:
Intent i=new Intent(BrowserActivity.this,AddBookmarkPage.class);
WebView w=getTopWindow();
i.putExtra(""String_Node_Str"",w.getUrl());
i.putExtra(""String_Node_Str"",w.getTitle());
startActivity(i);
break;
case R.id.stop_reload_menu_id:
if (mInLoad) {
stopLoading();
}
 else {
getTopWindow().reload();
}
break;
case R.id.back_menu_id:
getTopWindow().goBack();
break;
case R.id.forward_menu_id:
getTopWindow().goForward();
break;
case R.id.close_menu_id:
if (mTabControl.getCurrentSubWindow() != null) {
dismissSubWindow(mTabControl.getCurrentTab());
break;
}
closeCurrentWindow();
break;
case R.id.homepage_menu_id:
TabControl.Tab current=mTabControl.getCurrentTab();
if (current != null) {
dismissSubWindow(current);
current.getWebView().loadUrl(mSettings.getHomePage());
}
break;
case R.id.preferences_menu_id:
Intent intent=new Intent(this,BrowserPreferencesPage.class);
startActivityForResult(intent,PREFERENCES_PAGE);
break;
case R.id.find_menu_id:
if (null == mFindDialog) {
mFindDialog=new FindDialog(this);
}
mFindDialog.setWebView(getTopWindow());
mFindDialog.show();
mMenuState=EMPTY_MENU;
break;
case R.id.select_text_id:
getTopWindow().emulateShiftHeld();
break;
case R.id.page_info_menu_id:
showPageInfo(mTabControl.getCurrentTab(),false);
break;
case R.id.classic_history_menu_id:
bookmarksOrHistoryPicker(true,false);
break;
case R.id.share_page_menu_id:
Browser.sendString(this,getTopWindow().getUrl());
break;
case R.id.dump_nav_menu_id:
getTopWindow().debugDump();
break;
case R.id.zoom_in_menu_id:
getTopWindow().zoomIn();
break;
case R.id.zoom_out_menu_id:
getTopWindow().zoomOut();
break;
case R.id.view_downloads_menu_id:
viewDownloads(null);
break;
case R.id.window_one_menu_id:
case R.id.window_two_menu_id:
case R.id.window_three_menu_id:
case R.id.window_four_menu_id:
case R.id.window_five_menu_id:
case R.id.window_six_menu_id:
case R.id.window_seven_menu_id:
case R.id.window_eight_menu_id:
{
int menuid=item.getItemId();
for (int id=0; id < WINDOW_SHORTCUT_ID_ARRAY.length; id++) {
if (WINDOW_SHORTCUT_ID_ARRAY[id] == menuid) {
TabControl.Tab desiredTab=mTabControl.getTab(id);
if (desiredTab != null && desiredTab != mTabControl.getCurrentTab()) {
switchToTab(id);
mTitleBar.setCurrentTab(id);
}
break;
}
}
}
break;
default :
if (!super.onOptionsItemSelected(item)) {
return false;
}
}
mCanChord=false;
return true;
}",0.9977620290936218
185008,"public KeyTracker.State onKeyTracker(int keyCode,KeyEvent event,KeyTracker.Stage stage,int duration){
  WebView topWindow=getTopWindow();
  if (topWindow == null && mCustomView == null)   return KeyTracker.State.NOT_TRACKING;
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    if (mCustomView != null) {
      mWebChromeClient.onHideCustomView();
      return KeyTracker.State.DONE_TRACKING;
    }
    if (stage == KeyTracker.Stage.LONG_REPEAT) {
      bookmarksOrHistoryPicker(true);
      return KeyTracker.State.DONE_TRACKING;
    }
 else     if (stage == KeyTracker.Stage.UP) {
      WebView subwindow=mTabControl.getCurrentSubWindow();
      if (subwindow != null) {
        if (subwindow.canGoBack()) {
          subwindow.goBack();
        }
 else {
          dismissSubWindow(mTabControl.getCurrentTab());
        }
      }
 else {
        goBackOnePageOrQuit();
      }
      return KeyTracker.State.DONE_TRACKING;
    }
    return KeyTracker.State.KEEP_TRACKING;
  }
  return KeyTracker.State.NOT_TRACKING;
}","public KeyTracker.State onKeyTracker(int keyCode,KeyEvent event,KeyTracker.Stage stage,int duration){
  WebView topWindow=getTopWindow();
  if (topWindow == null && mCustomView == null)   return KeyTracker.State.NOT_TRACKING;
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    if (mCustomView != null) {
      mWebChromeClient.onHideCustomView();
      return KeyTracker.State.DONE_TRACKING;
    }
    if (stage == KeyTracker.Stage.LONG_REPEAT) {
      bookmarksOrHistoryPicker(true,false);
      return KeyTracker.State.DONE_TRACKING;
    }
 else     if (stage == KeyTracker.Stage.UP) {
      WebView subwindow=mTabControl.getCurrentSubWindow();
      if (subwindow != null) {
        if (subwindow.canGoBack()) {
          subwindow.goBack();
        }
 else {
          dismissSubWindow(mTabControl.getCurrentTab());
        }
      }
 else {
        goBackOnePageOrQuit();
      }
      return KeyTracker.State.DONE_TRACKING;
    }
    return KeyTracker.State.KEEP_TRACKING;
  }
  return KeyTracker.State.NOT_TRACKING;
}",0.9970472440944882
185009,"@Override public void onCreate(Bundle icicle){
  if (LOGV_ENABLED) {
    Log.v(LOGTAG,this + ""String_Node_Str"");
  }
  super.onCreate(icicle);
  if (CUSTOM_BROWSER_BAR) {
    this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  }
 else {
    this.requestWindowFeature(Window.FEATURE_LEFT_ICON);
    this.requestWindowFeature(Window.FEATURE_RIGHT_ICON);
    this.requestWindowFeature(Window.FEATURE_PROGRESS);
    this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  }
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  mResolver=getContentResolver();
  mSecLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_secure);
  mMixLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_partial_secure);
  mGenericFavicon=getResources().getDrawable(R.drawable.app_web_browser_sm);
  FrameLayout frameLayout=(FrameLayout)getWindow().getDecorView().findViewById(com.android.internal.R.id.content);
  if (CUSTOM_BROWSER_BAR) {
    FrameLayout browserFrameLayout=(FrameLayout)LayoutInflater.from(this).inflate(R.layout.custom_screen,null);
    mTitleBar=(TitleBarSet)browserFrameLayout.findViewById(R.id.title_bar);
    mContentView=(FrameLayout)browserFrameLayout.findViewById(R.id.main_content);
    mErrorConsoleContainer=(LinearLayout)browserFrameLayout.findViewById(R.id.error_console);
    mCustomViewContainer=(FrameLayout)browserFrameLayout.findViewById(R.id.fullscreen_custom_content);
    frameLayout.addView(browserFrameLayout,COVER_SCREEN_PARAMS);
  }
 else {
    mCustomViewContainer=new FrameLayout(this);
    mCustomViewContainer.setBackgroundColor(Color.BLACK);
    mContentView=new FrameLayout(this);
    LinearLayout linearLayout=new LinearLayout(this);
    linearLayout.setOrientation(LinearLayout.VERTICAL);
    mErrorConsoleContainer=new LinearLayout(this);
    linearLayout.addView(mErrorConsoleContainer,new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    linearLayout.addView(mContentView,COVER_SCREEN_PARAMS);
    frameLayout.addView(mCustomViewContainer,COVER_SCREEN_PARAMS);
    frameLayout.addView(linearLayout,COVER_SCREEN_PARAMS);
  }
  mTabControl=new TabControl(this);
  retainIconsOnStartup();
  mSettings=BrowserSettings.getInstance();
  mSettings.setTabControl(mTabControl);
  mSettings.loadFromDb(this);
  PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mNetworkStateChangedFilter=new IntentFilter();
  mNetworkStateChangedFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  mNetworkStateIntentReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        boolean down=intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,false);
        onNetworkToggle(!down);
      }
    }
  }
;
  IntentFilter filter=new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
  filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  filter.addDataScheme(""String_Node_Str"");
  mPackageInstallationReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      final String action=intent.getAction();
      final String packageName=intent.getData().getSchemeSpecificPart();
      final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
      if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
        return;
      }
      PackageManager pm=BrowserActivity.this.getPackageManager();
      PackageInfo pkgInfo=null;
      try {
        pkgInfo=pm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
      }
 catch (      PackageManager.NameNotFoundException e) {
        return;
      }
      if (pkgInfo != null) {
        String permissions[]=pkgInfo.requestedPermissions;
        if (permissions == null) {
          return;
        }
        boolean permissionOk=false;
        for (        String permit : permissions) {
          if (PluginManager.PLUGIN_PERMISSION.equals(permit)) {
            permissionOk=true;
            break;
          }
        }
        if (permissionOk) {
          PluginManager.getInstance(BrowserActivity.this).refreshPlugins(Intent.ACTION_PACKAGE_ADDED.equals(action));
        }
      }
    }
  }
;
  registerReceiver(mPackageInstallationReceiver,filter);
  if (handleWebSearchIntent(getIntent())) {
    moveTaskToBack(true);
    return;
  }
  if (!mTabControl.restoreState(icicle)) {
    new ClearThumbnails().execute(mTabControl.getThumbnailDir().listFiles());
    CookieManager.getInstance().removeSessionCookie();
    final Intent intent=getIntent();
    final Bundle extra=intent.getExtras();
    UrlData urlData=getUrlDataFromIntent(intent);
    final TabControl.Tab t=mTabControl.createNewTab(Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null,intent.getStringExtra(Browser.EXTRA_APPLICATION_ID),urlData.mUrl);
    mTabControl.setCurrentTab(t);
    attachTabToContentView(t);
    WebView webView=t.getWebView();
    if (extra != null) {
      int scale=extra.getInt(Browser.INITIAL_ZOOM_LEVEL,0);
      if (scale > 0 && scale <= 1000) {
        webView.setInitialScale(scale);
      }
    }
    if ((extra == null || !extra.getBoolean(""String_Node_Str"")) && !mSettings.isLoginInitialized()) {
      setupHomePage();
    }
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false);
    }
 else {
      if (extra != null) {
        urlData.setPostData(extra.getByteArray(Browser.EXTRA_POST_DATA));
      }
      urlData.loadIn(webView);
    }
  }
 else {
    attachTabToContentView(mTabControl.getCurrentTab());
  }
  if (CUSTOM_BROWSER_BAR) {
    for (int i=0; i < mTabControl.getTabCount(); i++) {
      WebView view=mTabControl.getTab(i).getWebView();
      mTitleBar.addTab(view,false);
    }
    mTitleBar.setBrowserActivity(this);
    mTitleBar.setCurrentTab(mTabControl.getCurrentIndex());
  }
  String jsFlags=mSettings.getJsFlags();
  if (jsFlags.trim().length() != 0) {
    mTabControl.getCurrentWebView().setJsFlags(jsFlags);
  }
}","@Override public void onCreate(Bundle icicle){
  if (LOGV_ENABLED) {
    Log.v(LOGTAG,this + ""String_Node_Str"");
  }
  super.onCreate(icicle);
  if (CUSTOM_BROWSER_BAR) {
    this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  }
 else {
    this.requestWindowFeature(Window.FEATURE_LEFT_ICON);
    this.requestWindowFeature(Window.FEATURE_RIGHT_ICON);
    this.requestWindowFeature(Window.FEATURE_PROGRESS);
    this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  }
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  mResolver=getContentResolver();
  mSecLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_secure);
  mMixLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_partial_secure);
  mGenericFavicon=getResources().getDrawable(R.drawable.app_web_browser_sm);
  FrameLayout frameLayout=(FrameLayout)getWindow().getDecorView().findViewById(com.android.internal.R.id.content);
  if (CUSTOM_BROWSER_BAR) {
    FrameLayout browserFrameLayout=(FrameLayout)LayoutInflater.from(this).inflate(R.layout.custom_screen,null);
    mTitleBar=(TitleBarSet)browserFrameLayout.findViewById(R.id.title_bar);
    mContentView=(FrameLayout)browserFrameLayout.findViewById(R.id.main_content);
    mErrorConsoleContainer=(LinearLayout)browserFrameLayout.findViewById(R.id.error_console);
    mCustomViewContainer=(FrameLayout)browserFrameLayout.findViewById(R.id.fullscreen_custom_content);
    frameLayout.addView(browserFrameLayout,COVER_SCREEN_PARAMS);
  }
 else {
    mCustomViewContainer=new FrameLayout(this);
    mCustomViewContainer.setBackgroundColor(Color.BLACK);
    mContentView=new FrameLayout(this);
    LinearLayout linearLayout=new LinearLayout(this);
    linearLayout.setOrientation(LinearLayout.VERTICAL);
    mErrorConsoleContainer=new LinearLayout(this);
    linearLayout.addView(mErrorConsoleContainer,new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    linearLayout.addView(mContentView,COVER_SCREEN_PARAMS);
    frameLayout.addView(mCustomViewContainer,COVER_SCREEN_PARAMS);
    frameLayout.addView(linearLayout,COVER_SCREEN_PARAMS);
  }
  mTabControl=new TabControl(this);
  retainIconsOnStartup();
  mSettings=BrowserSettings.getInstance();
  mSettings.setTabControl(mTabControl);
  mSettings.loadFromDb(this);
  PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mNetworkStateChangedFilter=new IntentFilter();
  mNetworkStateChangedFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  mNetworkStateIntentReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        boolean down=intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,false);
        onNetworkToggle(!down);
      }
    }
  }
;
  IntentFilter filter=new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
  filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  filter.addDataScheme(""String_Node_Str"");
  mPackageInstallationReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      final String action=intent.getAction();
      final String packageName=intent.getData().getSchemeSpecificPart();
      final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
      if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
        return;
      }
      PackageManager pm=BrowserActivity.this.getPackageManager();
      PackageInfo pkgInfo=null;
      try {
        pkgInfo=pm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
      }
 catch (      PackageManager.NameNotFoundException e) {
        return;
      }
      if (pkgInfo != null) {
        String permissions[]=pkgInfo.requestedPermissions;
        if (permissions == null) {
          return;
        }
        boolean permissionOk=false;
        for (        String permit : permissions) {
          if (PluginManager.PLUGIN_PERMISSION.equals(permit)) {
            permissionOk=true;
            break;
          }
        }
        if (permissionOk) {
          PluginManager.getInstance(BrowserActivity.this).refreshPlugins(Intent.ACTION_PACKAGE_ADDED.equals(action));
        }
      }
    }
  }
;
  registerReceiver(mPackageInstallationReceiver,filter);
  if (handleWebSearchIntent(getIntent())) {
    moveTaskToBack(true);
    return;
  }
  if (!mTabControl.restoreState(icicle)) {
    new ClearThumbnails().execute(mTabControl.getThumbnailDir().listFiles());
    CookieManager.getInstance().removeSessionCookie();
    final Intent intent=getIntent();
    final Bundle extra=intent.getExtras();
    UrlData urlData=getUrlDataFromIntent(intent);
    final TabControl.Tab t=mTabControl.createNewTab(Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null,intent.getStringExtra(Browser.EXTRA_APPLICATION_ID),urlData.mUrl);
    mTabControl.setCurrentTab(t);
    attachTabToContentView(t);
    WebView webView=t.getWebView();
    if (extra != null) {
      int scale=extra.getInt(Browser.INITIAL_ZOOM_LEVEL,0);
      if (scale > 0 && scale <= 1000) {
        webView.setInitialScale(scale);
      }
    }
    if ((extra == null || !extra.getBoolean(""String_Node_Str"")) && !mSettings.isLoginInitialized()) {
      setupHomePage();
    }
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false,true);
    }
 else {
      if (extra != null) {
        urlData.setPostData(extra.getByteArray(Browser.EXTRA_POST_DATA));
      }
      urlData.loadIn(webView);
    }
  }
 else {
    attachTabToContentView(mTabControl.getCurrentTab());
  }
  if (CUSTOM_BROWSER_BAR) {
    for (int i=0; i < mTabControl.getTabCount(); i++) {
      WebView view=mTabControl.getTab(i).getWebView();
      mTitleBar.addTab(view,false);
    }
    mTitleBar.setBrowserActivity(this);
    mTitleBar.setCurrentTab(mTabControl.getCurrentIndex());
  }
  String jsFlags=mSettings.getJsFlags();
  if (jsFlags.trim().length() != 0) {
    mTabControl.getCurrentWebView().setJsFlags(jsFlags);
  }
}",0.9995943863064816
185010,"TabControl.Tab openTabAndShow(UrlData urlData,boolean closeOnExit,String appId){
  final boolean newTab=mTabControl.getTabCount() != TabControl.MAX_TABS;
  final TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (newTab) {
    final TabControl.Tab tab=mTabControl.createNewTab(closeOnExit,appId,urlData.mUrl);
    WebView webview=tab.getWebView();
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.addTab(webview,true);
    }
    removeTabFromContentView(currentTab);
    attachTabToContentView(tab);
    mTabControl.setCurrentTab(tab);
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false);
    }
 else {
      urlData.loadIn(webview);
    }
    return tab;
  }
 else {
    dismissSubWindow(currentTab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(currentTab.getWebView());
    }
 else {
      bookmarksOrHistoryPicker(false);
    }
  }
  return currentTab;
}","TabControl.Tab openTabAndShow(UrlData urlData,boolean closeOnExit,String appId){
  final boolean newTab=mTabControl.getTabCount() != TabControl.MAX_TABS;
  final TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (newTab) {
    final TabControl.Tab tab=mTabControl.createNewTab(closeOnExit,appId,urlData.mUrl);
    WebView webview=tab.getWebView();
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.addTab(webview,true);
    }
    removeTabFromContentView(currentTab);
    attachTabToContentView(tab);
    mTabControl.setCurrentTab(tab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(webview);
    }
    return tab;
  }
 else {
    dismissSubWindow(currentTab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(currentTab.getWebView());
    }
  }
  return currentTab;
}",0.7138572285542891
185011,"public void onClick(View v){
  ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
}","public void onClick(View v){
  ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
  ba.bookmarksOrHistoryPicker(false,true);
}",0.8138528138528138
185012,"/** 
 * Override from AdapterView.  Using simple OnClickListeners overrides the GestureDetector.OnGestureListener, so we handle it here.
 */
public boolean performItemClick(View view,int position,long id){
  if (!(view instanceof TitleBar)) {
    return super.performItemClick(view,position,id);
  }
  if (null == mLastTouchUp) {
    return false;
  }
  TitleBar titleBar=(TitleBar)view;
  if (titleBar != getTitleBarAt(position)) {
    return false;
  }
  if (titleBar.hitRightButton((int)mLastTouchUp.getX() - mScrollX,(int)mLastTouchUp.getY() - mScrollY)) {
    if (titleBar.isInLoad()) {
      WebView webView=titleBar.getWebView();
      if (null == webView) {
        return false;
      }
      webView.stopLoading();
    }
 else {
      mBrowserActivity.closeCurrentWindow();
    }
  }
 else {
    mBrowserActivity.bookmarksOrHistoryPicker(false);
  }
  return true;
}","/** 
 * Override from AdapterView.  Using simple OnClickListeners overrides the GestureDetector.OnGestureListener, so we handle it here.
 */
public boolean performItemClick(View view,int position,long id){
  if (!(view instanceof TitleBar)) {
    return super.performItemClick(view,position,id);
  }
  if (null == mLastTouchUp) {
    return false;
  }
  TitleBar titleBar=(TitleBar)view;
  if (titleBar != getTitleBarAt(position)) {
    return false;
  }
  if (titleBar.hitRightButton((int)mLastTouchUp.getX() - mScrollX,(int)mLastTouchUp.getY() - mScrollY)) {
    if (titleBar.isInLoad()) {
      WebView webView=titleBar.getWebView();
      if (null == webView) {
        return false;
      }
      webView.stopLoading();
    }
 else {
      mBrowserActivity.closeCurrentWindow();
    }
  }
 else {
    mBrowserActivity.bookmarksOrHistoryPicker(false,false);
  }
  return true;
}",0.9965870307167236
185013,"/** 
 * Set the owning BrowserActivity.  Necessary so that we can call methods on it.
 */
void setBrowserActivity(final BrowserActivity ba){
  mBrowserActivity=ba;
  View.OnClickListener listener=new View.OnClickListener(){
    public void onClick(    View v){
      ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
    }
  }
;
  mNewButton.findViewById(R.id.button).setOnClickListener(listener);
}","/** 
 * Set the owning BrowserActivity.  Necessary so that we can call methods on it.
 */
void setBrowserActivity(final BrowserActivity ba){
  mBrowserActivity=ba;
  View.OnClickListener listener=new View.OnClickListener(){
    public void onClick(    View v){
      ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
      ba.bookmarksOrHistoryPicker(false,true);
    }
  }
;
  mNewButton.findViewById(R.id.button).setOnClickListener(listener);
}",0.945914844649022
185014,"/** 
 * Switch tabs.  Called by the TitleBarSet when sliding the title bar results in changing tabs.
 */
void switchToTab(int index){
  TabControl.Tab tab=mTabControl.getTab(index);
  TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (tab == null || tab == currentTab) {
    return;
  }
  if (currentTab != null) {
    removeTabFromContentView(currentTab);
  }
  removeTabFromContentView(tab);
  mTabControl.setCurrentTab(tab);
  attachTabToContentView(tab);
}","/** 
 * Switch tabs.  Called by the TitleBarSet when sliding the title bar results in changing tabs.
 * @param index Index of the tab to change to, as defined bymTabControl.getTabIndex(Tab t).
 * @return boolean True if we successfully switched to a different tab.  Ifthe indexth tab is null, or if that tab is the same as the current one, return false.
 */
boolean switchToTab(int index){
  TabControl.Tab tab=mTabControl.getTab(index);
  TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (tab == null || tab == currentTab) {
    return false;
  }
  if (currentTab != null) {
    removeTabFromContentView(currentTab);
  }
  removeTabFromContentView(tab);
  mTabControl.setCurrentTab(tab);
  attachTabToContentView(tab);
  return true;
}",0.7658175842235004
185015,"void bookmarksOrHistoryPicker(boolean startWithHistory){
  WebView current=mTabControl.getCurrentWebView();
  if (current == null) {
    return;
  }
  Intent intent=new Intent(this,CombinedBookmarkHistoryActivity.class);
  String title=current.getTitle();
  String url=current.getUrl();
  if (null == url) {
    url=mLastEnteredUrl;
    if (null == url) {
      url=mSettings.getHomePage();
    }
  }
  if (title == null) {
    title=url;
  }
  intent.putExtra(""String_Node_Str"",title);
  intent.putExtra(""String_Node_Str"",url);
  intent.putExtra(""String_Node_Str"",mTabControl.getTabCount() >= TabControl.MAX_TABS);
  intent.putExtra(""String_Node_Str"",current.getTouchIconUrl());
  if (startWithHistory) {
    intent.putExtra(CombinedBookmarkHistoryActivity.STARTING_TAB,CombinedBookmarkHistoryActivity.HISTORY_TAB);
  }
  startActivityForResult(intent,COMBO_PAGE);
}","/** 
 * Open the Go page.
 * @param startWithHistory If true, open starting on the history tab.Otherwise, start with the bookmarks tab.
 * @param cancelGoPageMeansClose Set to true if this came from a new tab, orfrom the only tab, and canceling means to close the tab (and possibly the browser)
 */
void bookmarksOrHistoryPicker(boolean startWithHistory,boolean cancelGoPageMeansClose){
  WebView current=mTabControl.getCurrentWebView();
  if (current == null) {
    return;
  }
  Intent intent=new Intent(this,CombinedBookmarkHistoryActivity.class);
  String title=current.getTitle();
  String url=current.getUrl();
  if (null == url) {
    url=mLastEnteredUrl;
    if (null == url) {
      url=mSettings.getHomePage();
    }
  }
  if (title == null) {
    title=url;
  }
  intent.putExtra(""String_Node_Str"",title);
  intent.putExtra(""String_Node_Str"",url);
  intent.putExtra(""String_Node_Str"",mTabControl.getTabCount() >= TabControl.MAX_TABS);
  intent.putExtra(""String_Node_Str"",current.getTouchIconUrl());
  if (startWithHistory) {
    intent.putExtra(CombinedBookmarkHistoryActivity.STARTING_TAB,CombinedBookmarkHistoryActivity.HISTORY_TAB);
  }
  mCancelGoPageMeansClose=cancelGoPageMeansClose;
  startActivityForResult(intent,COMBO_PAGE);
}",0.8202459791863765
185016,"void closeCurrentWindow(){
  final int currentIndex=mTabControl.getCurrentIndex();
  final TabControl.Tab current=mTabControl.getCurrentTab();
  final TabControl.Tab parent=current.getParentTab();
  int indexToShow=-1;
  if (parent != null) {
    indexToShow=mTabControl.getTabIndex(parent);
  }
 else {
    indexToShow=mTabControl.getTabCount() - 1;
    if (currentIndex == indexToShow) {
      indexToShow--;
    }
  }
  switchToTab(indexToShow);
  closeTab(current);
}","void closeCurrentWindow(){
  final TabControl.Tab current=mTabControl.getCurrentTab();
  if (mTabControl.getTabCount() == 1) {
    TabControl.Tab newTab=openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
    bookmarksOrHistoryPicker(false,true);
    closeTab(current);
    mTabControl.setCurrentTab(newTab);
    return;
  }
  final TabControl.Tab parent=current.getParentTab();
  int indexToShow=-1;
  if (parent != null) {
    indexToShow=mTabControl.getTabIndex(parent);
  }
 else {
    final int currentIndex=mTabControl.getCurrentIndex();
    indexToShow=currentIndex + 1;
    if (indexToShow > mTabControl.getTabCount() - 1) {
      indexToShow=currentIndex - 1;
    }
  }
  if (switchToTab(indexToShow)) {
    closeTab(current);
  }
}",0.4397046759639048
185017,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent intent){
switch (requestCode) {
case COMBO_PAGE:
    if (resultCode == RESULT_OK && intent != null) {
      String data=intent.getAction();
      Bundle extras=intent.getExtras();
      if (extras != null && extras.getBoolean(""String_Node_Str"",false)) {
        final TabControl.Tab newTab=openTab(data);
        if (mSettings.openInBackground() && newTab != null) {
          mTabControl.populatePickerData(newTab);
          mTabControl.setCurrentTab(newTab);
          int newIndex=mTabControl.getCurrentIndex();
          if (CUSTOM_BROWSER_BAR) {
            mTitleBar.setCurrentTab(newIndex);
          }
        }
      }
 else {
        final TabControl.Tab currentTab=mTabControl.getCurrentTab();
        dismissSubWindow(currentTab);
        if (data != null && data.length() != 0) {
          getTopWindow().loadUrl(data);
        }
      }
    }
  break;
default :
break;
}
getTopWindow().requestFocus();
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent intent){
switch (requestCode) {
case COMBO_PAGE:
    if (resultCode == RESULT_OK && intent != null) {
      String data=intent.getAction();
      Bundle extras=intent.getExtras();
      if (extras != null && extras.getBoolean(""String_Node_Str"",false)) {
        final TabControl.Tab newTab=openTab(data);
        if (mSettings.openInBackground() && newTab != null) {
          mTabControl.populatePickerData(newTab);
          mTabControl.setCurrentTab(newTab);
          int newIndex=mTabControl.getCurrentIndex();
          if (CUSTOM_BROWSER_BAR) {
            mTitleBar.setCurrentTab(newIndex);
          }
        }
      }
 else {
        final TabControl.Tab currentTab=mTabControl.getCurrentTab();
        dismissSubWindow(currentTab);
        if (data != null && data.length() != 0) {
          getTopWindow().loadUrl(data);
        }
      }
    }
 else     if (resultCode == RESULT_CANCELED && mCancelGoPageMeansClose) {
      if (mTabControl.getTabCount() == 1) {
        finish();
        return;
      }
      closeCurrentWindow();
    }
  break;
default :
break;
}
mCancelGoPageMeansClose=false;
if (getTopWindow() != null) {
getTopWindow().requestFocus();
}
}",0.8859298712827341
185018,"@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!mCanChord) {
    return false;
  }
  if (null == getTopWindow()) {
    return false;
  }
  if (mMenuIsDown) {
    mMenuIsDown=false;
  }
switch (item.getItemId()) {
case R.id.goto_menu_id:
    bookmarksOrHistoryPicker(false);
  break;
case R.id.add_bookmark_menu_id:
Intent i=new Intent(BrowserActivity.this,AddBookmarkPage.class);
WebView w=getTopWindow();
i.putExtra(""String_Node_Str"",w.getUrl());
i.putExtra(""String_Node_Str"",w.getTitle());
startActivity(i);
break;
case R.id.stop_reload_menu_id:
if (mInLoad) {
stopLoading();
}
 else {
getTopWindow().reload();
}
break;
case R.id.back_menu_id:
getTopWindow().goBack();
break;
case R.id.forward_menu_id:
getTopWindow().goForward();
break;
case R.id.close_menu_id:
if (mTabControl.getCurrentSubWindow() != null) {
dismissSubWindow(mTabControl.getCurrentTab());
break;
}
closeCurrentWindow();
break;
case R.id.homepage_menu_id:
TabControl.Tab current=mTabControl.getCurrentTab();
if (current != null) {
dismissSubWindow(current);
current.getWebView().loadUrl(mSettings.getHomePage());
}
break;
case R.id.preferences_menu_id:
Intent intent=new Intent(this,BrowserPreferencesPage.class);
startActivityForResult(intent,PREFERENCES_PAGE);
break;
case R.id.find_menu_id:
if (null == mFindDialog) {
mFindDialog=new FindDialog(this);
}
mFindDialog.setWebView(getTopWindow());
mFindDialog.show();
mMenuState=EMPTY_MENU;
break;
case R.id.select_text_id:
getTopWindow().emulateShiftHeld();
break;
case R.id.page_info_menu_id:
showPageInfo(mTabControl.getCurrentTab(),false);
break;
case R.id.classic_history_menu_id:
bookmarksOrHistoryPicker(true);
break;
case R.id.share_page_menu_id:
Browser.sendString(this,getTopWindow().getUrl());
break;
case R.id.dump_nav_menu_id:
getTopWindow().debugDump();
break;
case R.id.zoom_in_menu_id:
getTopWindow().zoomIn();
break;
case R.id.zoom_out_menu_id:
getTopWindow().zoomOut();
break;
case R.id.view_downloads_menu_id:
viewDownloads(null);
break;
case R.id.window_one_menu_id:
case R.id.window_two_menu_id:
case R.id.window_three_menu_id:
case R.id.window_four_menu_id:
case R.id.window_five_menu_id:
case R.id.window_six_menu_id:
case R.id.window_seven_menu_id:
case R.id.window_eight_menu_id:
{
int menuid=item.getItemId();
for (int id=0; id < WINDOW_SHORTCUT_ID_ARRAY.length; id++) {
if (WINDOW_SHORTCUT_ID_ARRAY[id] == menuid) {
TabControl.Tab desiredTab=mTabControl.getTab(id);
if (desiredTab != null && desiredTab != mTabControl.getCurrentTab()) {
switchToTab(id);
mTitleBar.setCurrentTab(id);
}
break;
}
}
}
break;
default :
if (!super.onOptionsItemSelected(item)) {
return false;
}
}
mCanChord=false;
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!mCanChord) {
    return false;
  }
  if (null == getTopWindow()) {
    return false;
  }
  if (mMenuIsDown) {
    mMenuIsDown=false;
  }
switch (item.getItemId()) {
case R.id.goto_menu_id:
    bookmarksOrHistoryPicker(false,false);
  break;
case R.id.add_bookmark_menu_id:
Intent i=new Intent(BrowserActivity.this,AddBookmarkPage.class);
WebView w=getTopWindow();
i.putExtra(""String_Node_Str"",w.getUrl());
i.putExtra(""String_Node_Str"",w.getTitle());
startActivity(i);
break;
case R.id.stop_reload_menu_id:
if (mInLoad) {
stopLoading();
}
 else {
getTopWindow().reload();
}
break;
case R.id.back_menu_id:
getTopWindow().goBack();
break;
case R.id.forward_menu_id:
getTopWindow().goForward();
break;
case R.id.close_menu_id:
if (mTabControl.getCurrentSubWindow() != null) {
dismissSubWindow(mTabControl.getCurrentTab());
break;
}
closeCurrentWindow();
break;
case R.id.homepage_menu_id:
TabControl.Tab current=mTabControl.getCurrentTab();
if (current != null) {
dismissSubWindow(current);
current.getWebView().loadUrl(mSettings.getHomePage());
}
break;
case R.id.preferences_menu_id:
Intent intent=new Intent(this,BrowserPreferencesPage.class);
startActivityForResult(intent,PREFERENCES_PAGE);
break;
case R.id.find_menu_id:
if (null == mFindDialog) {
mFindDialog=new FindDialog(this);
}
mFindDialog.setWebView(getTopWindow());
mFindDialog.show();
mMenuState=EMPTY_MENU;
break;
case R.id.select_text_id:
getTopWindow().emulateShiftHeld();
break;
case R.id.page_info_menu_id:
showPageInfo(mTabControl.getCurrentTab(),false);
break;
case R.id.classic_history_menu_id:
bookmarksOrHistoryPicker(true,false);
break;
case R.id.share_page_menu_id:
Browser.sendString(this,getTopWindow().getUrl());
break;
case R.id.dump_nav_menu_id:
getTopWindow().debugDump();
break;
case R.id.zoom_in_menu_id:
getTopWindow().zoomIn();
break;
case R.id.zoom_out_menu_id:
getTopWindow().zoomOut();
break;
case R.id.view_downloads_menu_id:
viewDownloads(null);
break;
case R.id.window_one_menu_id:
case R.id.window_two_menu_id:
case R.id.window_three_menu_id:
case R.id.window_four_menu_id:
case R.id.window_five_menu_id:
case R.id.window_six_menu_id:
case R.id.window_seven_menu_id:
case R.id.window_eight_menu_id:
{
int menuid=item.getItemId();
for (int id=0; id < WINDOW_SHORTCUT_ID_ARRAY.length; id++) {
if (WINDOW_SHORTCUT_ID_ARRAY[id] == menuid) {
TabControl.Tab desiredTab=mTabControl.getTab(id);
if (desiredTab != null && desiredTab != mTabControl.getCurrentTab()) {
switchToTab(id);
mTitleBar.setCurrentTab(id);
}
break;
}
}
}
break;
default :
if (!super.onOptionsItemSelected(item)) {
return false;
}
}
mCanChord=false;
return true;
}",0.9977620290936218
185019,"public KeyTracker.State onKeyTracker(int keyCode,KeyEvent event,KeyTracker.Stage stage,int duration){
  WebView topWindow=getTopWindow();
  if (topWindow == null && mCustomView == null)   return KeyTracker.State.NOT_TRACKING;
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    if (mCustomView != null) {
      mWebChromeClient.onHideCustomView();
      return KeyTracker.State.DONE_TRACKING;
    }
    if (stage == KeyTracker.Stage.LONG_REPEAT) {
      bookmarksOrHistoryPicker(true);
      return KeyTracker.State.DONE_TRACKING;
    }
 else     if (stage == KeyTracker.Stage.UP) {
      WebView subwindow=mTabControl.getCurrentSubWindow();
      if (subwindow != null) {
        if (subwindow.canGoBack()) {
          subwindow.goBack();
        }
 else {
          dismissSubWindow(mTabControl.getCurrentTab());
        }
      }
 else {
        goBackOnePageOrQuit();
      }
      return KeyTracker.State.DONE_TRACKING;
    }
    return KeyTracker.State.KEEP_TRACKING;
  }
  return KeyTracker.State.NOT_TRACKING;
}","public KeyTracker.State onKeyTracker(int keyCode,KeyEvent event,KeyTracker.Stage stage,int duration){
  WebView topWindow=getTopWindow();
  if (topWindow == null && mCustomView == null)   return KeyTracker.State.NOT_TRACKING;
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    if (mCustomView != null) {
      mWebChromeClient.onHideCustomView();
      return KeyTracker.State.DONE_TRACKING;
    }
    if (stage == KeyTracker.Stage.LONG_REPEAT) {
      bookmarksOrHistoryPicker(true,false);
      return KeyTracker.State.DONE_TRACKING;
    }
 else     if (stage == KeyTracker.Stage.UP) {
      WebView subwindow=mTabControl.getCurrentSubWindow();
      if (subwindow != null) {
        if (subwindow.canGoBack()) {
          subwindow.goBack();
        }
 else {
          dismissSubWindow(mTabControl.getCurrentTab());
        }
      }
 else {
        goBackOnePageOrQuit();
      }
      return KeyTracker.State.DONE_TRACKING;
    }
    return KeyTracker.State.KEEP_TRACKING;
  }
  return KeyTracker.State.NOT_TRACKING;
}",0.9970472440944882
185020,"@Override public void onCreate(Bundle icicle){
  if (LOGV_ENABLED) {
    Log.v(LOGTAG,this + ""String_Node_Str"");
  }
  super.onCreate(icicle);
  if (CUSTOM_BROWSER_BAR) {
    this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  }
 else {
    this.requestWindowFeature(Window.FEATURE_LEFT_ICON);
    this.requestWindowFeature(Window.FEATURE_RIGHT_ICON);
    this.requestWindowFeature(Window.FEATURE_PROGRESS);
    this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  }
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  mResolver=getContentResolver();
  mSecLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_secure);
  mMixLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_partial_secure);
  mGenericFavicon=getResources().getDrawable(R.drawable.app_web_browser_sm);
  FrameLayout frameLayout=(FrameLayout)getWindow().getDecorView().findViewById(com.android.internal.R.id.content);
  if (CUSTOM_BROWSER_BAR) {
    FrameLayout browserFrameLayout=(FrameLayout)LayoutInflater.from(this).inflate(R.layout.custom_screen,null);
    mTitleBar=(TitleBarSet)browserFrameLayout.findViewById(R.id.title_bar);
    mContentView=(FrameLayout)browserFrameLayout.findViewById(R.id.main_content);
    mErrorConsoleContainer=(LinearLayout)browserFrameLayout.findViewById(R.id.error_console);
    mCustomViewContainer=(FrameLayout)browserFrameLayout.findViewById(R.id.fullscreen_custom_content);
    frameLayout.addView(browserFrameLayout,COVER_SCREEN_PARAMS);
  }
 else {
    mCustomViewContainer=new FrameLayout(this);
    mCustomViewContainer.setBackgroundColor(Color.BLACK);
    mContentView=new FrameLayout(this);
    LinearLayout linearLayout=new LinearLayout(this);
    linearLayout.setOrientation(LinearLayout.VERTICAL);
    mErrorConsoleContainer=new LinearLayout(this);
    linearLayout.addView(mErrorConsoleContainer,new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    linearLayout.addView(mContentView,COVER_SCREEN_PARAMS);
    frameLayout.addView(mCustomViewContainer,COVER_SCREEN_PARAMS);
    frameLayout.addView(linearLayout,COVER_SCREEN_PARAMS);
  }
  mTabControl=new TabControl(this);
  retainIconsOnStartup();
  mSettings=BrowserSettings.getInstance();
  mSettings.setTabControl(mTabControl);
  mSettings.loadFromDb(this);
  PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mNetworkStateChangedFilter=new IntentFilter();
  mNetworkStateChangedFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  mNetworkStateIntentReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        boolean down=intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,false);
        onNetworkToggle(!down);
      }
    }
  }
;
  IntentFilter filter=new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
  filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  filter.addDataScheme(""String_Node_Str"");
  mPackageInstallationReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      final String action=intent.getAction();
      final String packageName=intent.getData().getSchemeSpecificPart();
      final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
      if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
        return;
      }
      PackageManager pm=BrowserActivity.this.getPackageManager();
      PackageInfo pkgInfo=null;
      try {
        pkgInfo=pm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
      }
 catch (      PackageManager.NameNotFoundException e) {
        return;
      }
      if (pkgInfo != null) {
        String permissions[]=pkgInfo.requestedPermissions;
        if (permissions == null) {
          return;
        }
        boolean permissionOk=false;
        for (        String permit : permissions) {
          if (PluginManager.PLUGIN_PERMISSION.equals(permit)) {
            permissionOk=true;
            break;
          }
        }
        if (permissionOk) {
          PluginManager.getInstance(BrowserActivity.this).refreshPlugins(Intent.ACTION_PACKAGE_ADDED.equals(action));
        }
      }
    }
  }
;
  registerReceiver(mPackageInstallationReceiver,filter);
  if (handleWebSearchIntent(getIntent())) {
    moveTaskToBack(true);
    return;
  }
  if (!mTabControl.restoreState(icicle)) {
    new ClearThumbnails().execute(mTabControl.getThumbnailDir().listFiles());
    CookieManager.getInstance().removeSessionCookie();
    final Intent intent=getIntent();
    final Bundle extra=intent.getExtras();
    UrlData urlData=getUrlDataFromIntent(intent);
    final TabControl.Tab t=mTabControl.createNewTab(Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null,intent.getStringExtra(Browser.EXTRA_APPLICATION_ID),urlData.mUrl);
    mTabControl.setCurrentTab(t);
    attachTabToContentView(t);
    WebView webView=t.getWebView();
    if (extra != null) {
      int scale=extra.getInt(Browser.INITIAL_ZOOM_LEVEL,0);
      if (scale > 0 && scale <= 1000) {
        webView.setInitialScale(scale);
      }
    }
    if ((extra == null || !extra.getBoolean(""String_Node_Str"")) && !mSettings.isLoginInitialized()) {
      setupHomePage();
    }
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false);
    }
 else {
      if (extra != null) {
        urlData.setPostData(extra.getByteArray(Browser.EXTRA_POST_DATA));
      }
      urlData.loadIn(webView);
    }
  }
 else {
    attachTabToContentView(mTabControl.getCurrentTab());
  }
  if (CUSTOM_BROWSER_BAR) {
    for (int i=0; i < mTabControl.getTabCount(); i++) {
      WebView view=mTabControl.getTab(i).getWebView();
      mTitleBar.addTab(view,false);
    }
    mTitleBar.setBrowserActivity(this);
    mTitleBar.setCurrentTab(mTabControl.getCurrentIndex());
  }
  String jsFlags=mSettings.getJsFlags();
  if (jsFlags.trim().length() != 0) {
    mTabControl.getCurrentWebView().setJsFlags(jsFlags);
  }
}","@Override public void onCreate(Bundle icicle){
  if (LOGV_ENABLED) {
    Log.v(LOGTAG,this + ""String_Node_Str"");
  }
  super.onCreate(icicle);
  if (CUSTOM_BROWSER_BAR) {
    this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  }
 else {
    this.requestWindowFeature(Window.FEATURE_LEFT_ICON);
    this.requestWindowFeature(Window.FEATURE_RIGHT_ICON);
    this.requestWindowFeature(Window.FEATURE_PROGRESS);
    this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  }
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  mResolver=getContentResolver();
  mSecLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_secure);
  mMixLockIcon=Resources.getSystem().getDrawable(android.R.drawable.ic_partial_secure);
  mGenericFavicon=getResources().getDrawable(R.drawable.app_web_browser_sm);
  FrameLayout frameLayout=(FrameLayout)getWindow().getDecorView().findViewById(com.android.internal.R.id.content);
  if (CUSTOM_BROWSER_BAR) {
    FrameLayout browserFrameLayout=(FrameLayout)LayoutInflater.from(this).inflate(R.layout.custom_screen,null);
    mTitleBar=(TitleBarSet)browserFrameLayout.findViewById(R.id.title_bar);
    mContentView=(FrameLayout)browserFrameLayout.findViewById(R.id.main_content);
    mErrorConsoleContainer=(LinearLayout)browserFrameLayout.findViewById(R.id.error_console);
    mCustomViewContainer=(FrameLayout)browserFrameLayout.findViewById(R.id.fullscreen_custom_content);
    frameLayout.addView(browserFrameLayout,COVER_SCREEN_PARAMS);
  }
 else {
    mCustomViewContainer=new FrameLayout(this);
    mCustomViewContainer.setBackgroundColor(Color.BLACK);
    mContentView=new FrameLayout(this);
    LinearLayout linearLayout=new LinearLayout(this);
    linearLayout.setOrientation(LinearLayout.VERTICAL);
    mErrorConsoleContainer=new LinearLayout(this);
    linearLayout.addView(mErrorConsoleContainer,new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    linearLayout.addView(mContentView,COVER_SCREEN_PARAMS);
    frameLayout.addView(mCustomViewContainer,COVER_SCREEN_PARAMS);
    frameLayout.addView(linearLayout,COVER_SCREEN_PARAMS);
  }
  mTabControl=new TabControl(this);
  retainIconsOnStartup();
  mSettings=BrowserSettings.getInstance();
  mSettings.setTabControl(mTabControl);
  mSettings.loadFromDb(this);
  PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mNetworkStateChangedFilter=new IntentFilter();
  mNetworkStateChangedFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  mNetworkStateIntentReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        boolean down=intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,false);
        onNetworkToggle(!down);
      }
    }
  }
;
  IntentFilter filter=new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
  filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  filter.addDataScheme(""String_Node_Str"");
  mPackageInstallationReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      final String action=intent.getAction();
      final String packageName=intent.getData().getSchemeSpecificPart();
      final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
      if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
        return;
      }
      PackageManager pm=BrowserActivity.this.getPackageManager();
      PackageInfo pkgInfo=null;
      try {
        pkgInfo=pm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
      }
 catch (      PackageManager.NameNotFoundException e) {
        return;
      }
      if (pkgInfo != null) {
        String permissions[]=pkgInfo.requestedPermissions;
        if (permissions == null) {
          return;
        }
        boolean permissionOk=false;
        for (        String permit : permissions) {
          if (PluginManager.PLUGIN_PERMISSION.equals(permit)) {
            permissionOk=true;
            break;
          }
        }
        if (permissionOk) {
          PluginManager.getInstance(BrowserActivity.this).refreshPlugins(Intent.ACTION_PACKAGE_ADDED.equals(action));
        }
      }
    }
  }
;
  registerReceiver(mPackageInstallationReceiver,filter);
  if (handleWebSearchIntent(getIntent())) {
    moveTaskToBack(true);
    return;
  }
  if (!mTabControl.restoreState(icicle)) {
    new ClearThumbnails().execute(mTabControl.getThumbnailDir().listFiles());
    CookieManager.getInstance().removeSessionCookie();
    final Intent intent=getIntent();
    final Bundle extra=intent.getExtras();
    UrlData urlData=getUrlDataFromIntent(intent);
    final TabControl.Tab t=mTabControl.createNewTab(Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null,intent.getStringExtra(Browser.EXTRA_APPLICATION_ID),urlData.mUrl);
    mTabControl.setCurrentTab(t);
    attachTabToContentView(t);
    WebView webView=t.getWebView();
    if (extra != null) {
      int scale=extra.getInt(Browser.INITIAL_ZOOM_LEVEL,0);
      if (scale > 0 && scale <= 1000) {
        webView.setInitialScale(scale);
      }
    }
    if ((extra == null || !extra.getBoolean(""String_Node_Str"")) && !mSettings.isLoginInitialized()) {
      setupHomePage();
    }
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false,true);
    }
 else {
      if (extra != null) {
        urlData.setPostData(extra.getByteArray(Browser.EXTRA_POST_DATA));
      }
      urlData.loadIn(webView);
    }
  }
 else {
    attachTabToContentView(mTabControl.getCurrentTab());
  }
  if (CUSTOM_BROWSER_BAR) {
    for (int i=0; i < mTabControl.getTabCount(); i++) {
      WebView view=mTabControl.getTab(i).getWebView();
      mTitleBar.addTab(view,false);
    }
    mTitleBar.setBrowserActivity(this);
    mTitleBar.setCurrentTab(mTabControl.getCurrentIndex());
  }
  String jsFlags=mSettings.getJsFlags();
  if (jsFlags.trim().length() != 0) {
    mTabControl.getCurrentWebView().setJsFlags(jsFlags);
  }
}",0.9995943863064816
185021,"TabControl.Tab openTabAndShow(UrlData urlData,boolean closeOnExit,String appId){
  final boolean newTab=mTabControl.getTabCount() != TabControl.MAX_TABS;
  final TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (newTab) {
    final TabControl.Tab tab=mTabControl.createNewTab(closeOnExit,appId,urlData.mUrl);
    WebView webview=tab.getWebView();
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.addTab(webview,true);
    }
    removeTabFromContentView(currentTab);
    attachTabToContentView(tab);
    mTabControl.setCurrentTab(tab);
    if (urlData.isEmpty()) {
      bookmarksOrHistoryPicker(false);
    }
 else {
      urlData.loadIn(webview);
    }
    return tab;
  }
 else {
    dismissSubWindow(currentTab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(currentTab.getWebView());
    }
 else {
      bookmarksOrHistoryPicker(false);
    }
  }
  return currentTab;
}","TabControl.Tab openTabAndShow(UrlData urlData,boolean closeOnExit,String appId){
  final boolean newTab=mTabControl.getTabCount() != TabControl.MAX_TABS;
  final TabControl.Tab currentTab=mTabControl.getCurrentTab();
  if (newTab) {
    final TabControl.Tab tab=mTabControl.createNewTab(closeOnExit,appId,urlData.mUrl);
    WebView webview=tab.getWebView();
    if (CUSTOM_BROWSER_BAR) {
      mTitleBar.addTab(webview,true);
    }
    removeTabFromContentView(currentTab);
    attachTabToContentView(tab);
    mTabControl.setCurrentTab(tab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(webview);
    }
    return tab;
  }
 else {
    dismissSubWindow(currentTab);
    if (!urlData.isEmpty()) {
      urlData.loadIn(currentTab.getWebView());
    }
  }
  return currentTab;
}",0.7138572285542891
185022,"public void onClick(View v){
  ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
}","public void onClick(View v){
  ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
  ba.bookmarksOrHistoryPicker(false,true);
}",0.8138528138528138
185023,"/** 
 * Override from AdapterView.  Using simple OnClickListeners overrides the GestureDetector.OnGestureListener, so we handle it here.
 */
public boolean performItemClick(View view,int position,long id){
  if (!(view instanceof TitleBar)) {
    return super.performItemClick(view,position,id);
  }
  if (null == mLastTouchUp) {
    return false;
  }
  TitleBar titleBar=(TitleBar)view;
  if (titleBar != getTitleBarAt(position)) {
    return false;
  }
  if (titleBar.hitRightButton((int)mLastTouchUp.getX() - mScrollX,(int)mLastTouchUp.getY() - mScrollY)) {
    if (titleBar.isInLoad()) {
      WebView webView=titleBar.getWebView();
      if (null == webView) {
        return false;
      }
      webView.stopLoading();
    }
 else {
      mBrowserActivity.closeCurrentWindow();
    }
  }
 else {
    mBrowserActivity.bookmarksOrHistoryPicker(false);
  }
  return true;
}","/** 
 * Override from AdapterView.  Using simple OnClickListeners overrides the GestureDetector.OnGestureListener, so we handle it here.
 */
public boolean performItemClick(View view,int position,long id){
  if (!(view instanceof TitleBar)) {
    return super.performItemClick(view,position,id);
  }
  if (null == mLastTouchUp) {
    return false;
  }
  TitleBar titleBar=(TitleBar)view;
  if (titleBar != getTitleBarAt(position)) {
    return false;
  }
  if (titleBar.hitRightButton((int)mLastTouchUp.getX() - mScrollX,(int)mLastTouchUp.getY() - mScrollY)) {
    if (titleBar.isInLoad()) {
      WebView webView=titleBar.getWebView();
      if (null == webView) {
        return false;
      }
      webView.stopLoading();
    }
 else {
      mBrowserActivity.closeCurrentWindow();
    }
  }
 else {
    mBrowserActivity.bookmarksOrHistoryPicker(false,false);
  }
  return true;
}",0.9965870307167236
185024,"/** 
 * Set the owning BrowserActivity.  Necessary so that we can call methods on it.
 */
void setBrowserActivity(final BrowserActivity ba){
  mBrowserActivity=ba;
  View.OnClickListener listener=new View.OnClickListener(){
    public void onClick(    View v){
      ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
    }
  }
;
  mNewButton.findViewById(R.id.button).setOnClickListener(listener);
}","/** 
 * Set the owning BrowserActivity.  Necessary so that we can call methods on it.
 */
void setBrowserActivity(final BrowserActivity ba){
  mBrowserActivity=ba;
  View.OnClickListener listener=new View.OnClickListener(){
    public void onClick(    View v){
      ba.openTabAndShow(BrowserActivity.EMPTY_URL_DATA,false,null);
      ba.bookmarksOrHistoryPicker(false,true);
    }
  }
;
  mNewButton.findViewById(R.id.button).setOnClickListener(listener);
}",0.945914844649022
185025,"private void goBackOnePageOrQuit(){
  TabControl.Tab current=mTabControl.getCurrentTab();
  if (current == null) {
    moveTaskToBack(true);
  }
  WebView w=current.getWebView();
  if (w.canGoBack()) {
    w.goBack();
  }
 else {
    TabControl.Tab parent=current.getParentTab();
    if (parent != null) {
      switchTabs(mTabControl.getCurrentIndex(),mTabControl.getTabIndex(parent),true);
    }
 else {
      if (current.closeOnExit()) {
        if (mTabControl.getTabCount() == 1) {
          finish();
          return;
        }
        pauseWebView();
        removeTabFromContentView(current);
        mTabControl.removeTab(current);
      }
      moveTaskToBack(true);
    }
  }
}","private void goBackOnePageOrQuit(){
  TabControl.Tab current=mTabControl.getCurrentTab();
  if (current == null) {
    moveTaskToBack(true);
  }
  WebView w=current.getWebView();
  if (w.canGoBack()) {
    w.goBack();
  }
 else {
    TabControl.Tab parent=current.getParentTab();
    if (parent != null) {
      switchTabs(mTabControl.getCurrentIndex(),mTabControl.getTabIndex(parent),true);
    }
 else {
      if (current.closeOnExit()) {
        if (mTabControl.getTabCount() == 1) {
          finish();
          return;
        }
        boolean savedState=mActivityInPause;
        if (savedState) {
          Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
        }
        mActivityInPause=true;
        pauseWebView();
        mActivityInPause=savedState;
        removeTabFromContentView(current);
        mTabControl.removeTab(current);
      }
      moveTaskToBack(true);
    }
  }
}",0.8666666666666667
185026,"public View getView(int position,View convertView,ViewGroup parent){
  View view;
  TextView title;
  TextView subtitle;
  ImageView icon;
  if (convertView == null) {
    view=mInflater.inflate(mResource,parent,false);
  }
 else {
    view=convertView;
  }
  title=(TextView)view.findViewById(R.id.title);
  subtitle=(TextView)view.findViewById(R.id.subtitle);
  icon=(ImageView)view.findViewById(R.id.icon);
  if (mCurrentSite == null) {
    Site site=getItem(position);
    title.setText(site.getPrettyTitle());
    subtitle.setText(site.getPrettyOrigin());
    icon.setVisibility(View.VISIBLE);
    Bitmap bmp=site.getIcon();
    if (bmp == null) {
      bmp=mDefaultIcon;
    }
    icon.setImageBitmap(bmp);
    view.setTag(site);
  }
 else {
    icon.setVisibility(View.GONE);
    String origin=mCurrentSite.getOrigin();
switch (mCurrentSite.getFeatureByIndex(position)) {
case Site.FEATURE_WEB_STORAGE:
      long usageValue=WebStorage.getInstance().getUsageForOrigin(origin);
    String usage=sizeValueToString(usageValue) + ""String_Node_Str"" + sMBStored;
  title.setText(R.string.webstorage_clear_data_title);
subtitle.setText(usage);
break;
case Site.FEATURE_GEOLOCATION:
title.setText(R.string.geolocation_settings_page_title);
boolean allowed=GeolocationPermissions.getInstance().getAllowed(origin);
subtitle.setText(allowed ? R.string.geolocation_settings_page_summary_allowed : R.string.geolocation_settings_page_summary_not_allowed);
break;
}
}
return view;
}","public View getView(int position,View convertView,ViewGroup parent){
  View view;
  TextView title;
  TextView subtitle;
  ImageView icon;
  if (convertView == null) {
    view=mInflater.inflate(mResource,parent,false);
  }
 else {
    view=convertView;
  }
  title=(TextView)view.findViewById(R.id.title);
  subtitle=(TextView)view.findViewById(R.id.subtitle);
  icon=(ImageView)view.findViewById(R.id.icon);
  if (mCurrentSite == null) {
    setTitle(getString(R.string.pref_extras_website_settings));
    Site site=getItem(position);
    title.setText(site.getPrettyTitle());
    subtitle.setText(site.getPrettyOrigin());
    icon.setVisibility(View.VISIBLE);
    Bitmap bmp=site.getIcon();
    if (bmp == null) {
      bmp=mDefaultIcon;
    }
    icon.setImageBitmap(bmp);
    view.setTag(site);
  }
 else {
    setTitle(mCurrentSite.getPrettyTitle());
    icon.setVisibility(View.GONE);
    String origin=mCurrentSite.getOrigin();
switch (mCurrentSite.getFeatureByIndex(position)) {
case Site.FEATURE_WEB_STORAGE:
      long usageValue=WebStorage.getInstance().getUsageForOrigin(origin);
    String usage=sizeValueToString(usageValue) + ""String_Node_Str"" + sMBStored;
  title.setText(R.string.webstorage_clear_data_title);
subtitle.setText(usage);
break;
case Site.FEATURE_GEOLOCATION:
title.setText(R.string.geolocation_settings_page_title);
boolean allowed=GeolocationPermissions.getInstance().getAllowed(origin);
subtitle.setText(allowed ? R.string.geolocation_settings_page_summary_allowed : R.string.geolocation_settings_page_summary_not_allowed);
break;
}
}
return view;
}",0.9643441282302913
185027,"public void populateOrigins(){
  clear();
  HashMap<String,Site> uris=new HashMap<String,Site>();
  Set origins=WebStorage.getInstance().getOrigins();
  if (origins != null) {
    Iterator<String> iter=origins.iterator();
    while (iter.hasNext()) {
      String origin=iter.next();
      Site site=new Site(origin);
      uris.put(Uri.parse(origin).getHost(),site);
    }
  }
  Cursor c=getContext().getContentResolver().query(Browser.BOOKMARKS_URI,new String[]{Browser.BookmarkColumns.URL,Browser.BookmarkColumns.TITLE,Browser.BookmarkColumns.FAVICON},""String_Node_Str"",null,null);
  if ((c != null) && c.moveToFirst()) {
    int urlIndex=c.getColumnIndex(Browser.BookmarkColumns.URL);
    int titleIndex=c.getColumnIndex(Browser.BookmarkColumns.TITLE);
    int faviconIndex=c.getColumnIndex(Browser.BookmarkColumns.FAVICON);
    do {
      String url=c.getString(urlIndex);
      String host=Uri.parse(url).getHost();
      if (uris.containsKey(host)) {
        String title=c.getString(titleIndex);
        Site site=uris.get(host);
        site.setTitle(title);
        byte[] data=c.getBlob(faviconIndex);
        if (data != null) {
          Bitmap bmp=BitmapFactory.decodeByteArray(data,0,data.length);
          if (bmp != null) {
            site.setIcon(bmp);
          }
        }
      }
    }
 while (c.moveToNext());
  }
  Set keys=uris.keySet();
  Iterator iter=keys.iterator();
  while (iter.hasNext()) {
    String origin=(String)iter.next();
    Site site=uris.get(origin);
    add(site);
  }
  if (getCount() == 0) {
    finish();
  }
}","public void populateOrigins(){
  clear();
  Set origins=WebStorage.getInstance().getOrigins();
  Set sites=new HashSet<Site>();
  if (origins != null) {
    Iterator<String> iter=origins.iterator();
    while (iter.hasNext()) {
      String origin=iter.next();
      Site site=new Site(origin);
      sites.add(site);
    }
  }
  HashMap hosts=new HashMap<String,Set<Site>>();
  Iterator<Site> sitesIter=sites.iterator();
  while (sitesIter.hasNext()) {
    Site site=sitesIter.next();
    String host=Uri.parse(site.getOrigin()).getHost();
    Set hostSites=null;
    if (hosts.containsKey(host)) {
      hostSites=(Set)hosts.get(host);
    }
 else {
      hostSites=new HashSet<Site>();
      hosts.put(host,hostSites);
    }
    hostSites.add(site);
  }
  Cursor c=getContext().getContentResolver().query(Browser.BOOKMARKS_URI,new String[]{Browser.BookmarkColumns.URL,Browser.BookmarkColumns.TITLE,Browser.BookmarkColumns.FAVICON},""String_Node_Str"",null,null);
  if ((c != null) && c.moveToFirst()) {
    int urlIndex=c.getColumnIndex(Browser.BookmarkColumns.URL);
    int titleIndex=c.getColumnIndex(Browser.BookmarkColumns.TITLE);
    int faviconIndex=c.getColumnIndex(Browser.BookmarkColumns.FAVICON);
    do {
      String url=c.getString(urlIndex);
      String host=Uri.parse(url).getHost();
      if (hosts.containsKey(host)) {
        String title=c.getString(titleIndex);
        Bitmap bmp=null;
        byte[] data=c.getBlob(faviconIndex);
        if (data != null) {
          bmp=BitmapFactory.decodeByteArray(data,0,data.length);
        }
        Set matchingSites=(Set)hosts.get(host);
        sitesIter=matchingSites.iterator();
        while (sitesIter.hasNext()) {
          Site site=sitesIter.next();
          site.setTitle(title);
          if (bmp != null) {
            site.setIcon(bmp);
          }
        }
      }
    }
 while (c.moveToNext());
  }
  sitesIter=sites.iterator();
  while (sitesIter.hasNext()) {
    Site site=sitesIter.next();
    add(site);
  }
  if (getCount() == 0) {
    finish();
  }
}",0.6110647762023909
185028,"/** 
 * Save the data to the database.  Also, change the view to dialog stating  that the webpage has been saved.
 */
boolean save(){
  String title=mTitle.getText().toString().trim();
  String unfilteredUrl=BrowserActivity.fixUrl(mAddress.getText().toString());
  boolean emptyTitle=title.length() == 0;
  boolean emptyUrl=unfilteredUrl.trim().length() == 0;
  Resources r=getResources();
  if (emptyTitle || emptyUrl) {
    if (emptyTitle) {
      mTitle.setError(r.getText(R.string.bookmark_needs_title));
    }
    if (emptyUrl) {
      mAddress.setError(r.getText(R.string.bookmark_needs_url));
    }
    return false;
  }
  String url=unfilteredUrl;
  if (!(url.startsWith(""String_Node_Str"") || url.startsWith(""String_Node_Str"") || url.startsWith(""String_Node_Str""))) {
    WebAddress address;
    try {
      address=new WebAddress(unfilteredUrl);
    }
 catch (    ParseException e) {
      mAddress.setError(r.getText(R.string.bookmark_url_not_valid));
      return false;
    }
    if (address.mHost.length() == 0) {
      mAddress.setError(r.getText(R.string.bookmark_url_not_valid));
      return false;
    }
    url=address.toString();
  }
  try {
    if (mEditingExisting) {
      mMap.putString(""String_Node_Str"",title);
      mMap.putString(""String_Node_Str"",url);
      setResult(RESULT_OK,(new Intent()).setAction(getIntent().toString()).putExtras(mMap));
    }
 else {
      long creationTime=new Date().getTime();
      boolean secure=false;
      if (url.startsWith(""String_Node_Str"")) {
        url=url.substring(7);
      }
 else       if (url.startsWith(""String_Node_Str"")) {
        url=url.substring(8);
        secure=true;
      }
      if (url.startsWith(""String_Node_Str"")) {
        url=url.substring(4);
      }
      if (secure) {
        SELECTION_ARGS=new String[2];
        SELECTION_ARGS[0]=""String_Node_Str"" + url;
        SELECTION_ARGS[1]=""String_Node_Str"" + url;
      }
 else {
        SELECTION_ARGS=new String[4];
        SELECTION_ARGS[0]=url;
        SELECTION_ARGS[1]=""String_Node_Str"" + url;
        SELECTION_ARGS[2]=""String_Node_Str"" + url;
        SELECTION_ARGS[3]=""String_Node_Str"" + SELECTION_ARGS[1];
      }
      ContentResolver cr=getContentResolver();
      Cursor c=cr.query(Browser.BOOKMARKS_URI,mProjection,secure ? WHERE_CLAUSE_SECURE : WHERE_CLAUSE,SELECTION_ARGS,null);
      ContentValues map=new ContentValues();
      if (c.moveToFirst() && c.getInt(c.getColumnIndexOrThrow(Browser.BookmarkColumns.BOOKMARK)) == 0) {
        map.put(Browser.BookmarkColumns.CREATED,creationTime);
        map.put(Browser.BookmarkColumns.TITLE,title);
        map.put(Browser.BookmarkColumns.BOOKMARK,1);
        cr.update(Browser.BOOKMARKS_URI,map,""String_Node_Str"" + c.getInt(0),null);
      }
 else {
        int count=c.getCount();
        boolean matchedTitle=false;
        for (int i=0; i < count; i++) {
          c.moveToPosition(i);
          if (c.getString(c.getColumnIndexOrThrow(Browser.BookmarkColumns.TITLE)).equals(title)) {
            map.put(Browser.BookmarkColumns.CREATED,creationTime);
            cr.update(Browser.BOOKMARKS_URI,map,""String_Node_Str"" + c.getInt(0),null);
            matchedTitle=true;
            break;
          }
        }
        if (!matchedTitle) {
          map.put(Browser.BookmarkColumns.TITLE,title);
          map.put(Browser.BookmarkColumns.URL,url);
          map.put(Browser.BookmarkColumns.CREATED,creationTime);
          map.put(Browser.BookmarkColumns.BOOKMARK,1);
          map.put(Browser.BookmarkColumns.DATE,0);
          int visits=0;
          if (count > 0) {
            visits=c.getInt(c.getColumnIndexOrThrow(Browser.BookmarkColumns.VISITS));
          }
          map.put(Browser.BookmarkColumns.VISITS,visits + 3);
          cr.insert(Browser.BOOKMARKS_URI,map);
        }
      }
      WebIconDatabase.getInstance().retainIconForPageUrl(url);
      c.deactivate();
      setResult(RESULT_OK);
    }
  }
 catch (  IllegalStateException e) {
    setTitle(r.getText(R.string.no_database));
    return false;
  }
  return true;
}","/** 
 * Save the data to the database.  Also, change the view to dialog stating  that the webpage has been saved.
 */
boolean save(){
  String title=mTitle.getText().toString().trim();
  String unfilteredUrl=BrowserActivity.fixUrl(mAddress.getText().toString());
  boolean emptyTitle=title.length() == 0;
  boolean emptyUrl=unfilteredUrl.trim().length() == 0;
  Resources r=getResources();
  if (emptyTitle || emptyUrl) {
    if (emptyTitle) {
      mTitle.setError(r.getText(R.string.bookmark_needs_title));
    }
    if (emptyUrl) {
      mAddress.setError(r.getText(R.string.bookmark_needs_url));
    }
    return false;
  }
  String url=unfilteredUrl;
  if (!(url.startsWith(""String_Node_Str"") || url.startsWith(""String_Node_Str"") || url.startsWith(""String_Node_Str""))) {
    WebAddress address;
    try {
      address=new WebAddress(unfilteredUrl);
    }
 catch (    ParseException e) {
      mAddress.setError(r.getText(R.string.bookmark_url_not_valid));
      return false;
    }
    if (address.mHost.length() == 0) {
      mAddress.setError(r.getText(R.string.bookmark_url_not_valid));
      return false;
    }
    url=address.toString();
  }
  try {
    if (mEditingExisting) {
      mMap.putString(""String_Node_Str"",title);
      mMap.putString(""String_Node_Str"",url);
      setResult(RESULT_OK,(new Intent()).setAction(getIntent().toString()).putExtras(mMap));
    }
 else {
      long creationTime=new Date().getTime();
      boolean secure=false;
      String compareString=url;
      if (compareString.startsWith(""String_Node_Str"")) {
        compareString=compareString.substring(7);
      }
 else       if (compareString.startsWith(""String_Node_Str"")) {
        compareString=compareString.substring(8);
        secure=true;
      }
      if (compareString.startsWith(""String_Node_Str"")) {
        compareString=compareString.substring(4);
      }
      if (secure) {
        SELECTION_ARGS=new String[2];
        SELECTION_ARGS[0]=""String_Node_Str"" + compareString;
        SELECTION_ARGS[1]=""String_Node_Str"" + compareString;
      }
 else {
        SELECTION_ARGS=new String[4];
        SELECTION_ARGS[0]=compareString;
        SELECTION_ARGS[1]=""String_Node_Str"" + compareString;
        SELECTION_ARGS[2]=""String_Node_Str"" + compareString;
        SELECTION_ARGS[3]=""String_Node_Str"" + SELECTION_ARGS[1];
      }
      ContentResolver cr=getContentResolver();
      Cursor c=cr.query(Browser.BOOKMARKS_URI,mProjection,secure ? WHERE_CLAUSE_SECURE : WHERE_CLAUSE,SELECTION_ARGS,null);
      ContentValues map=new ContentValues();
      if (c.moveToFirst() && c.getInt(c.getColumnIndexOrThrow(Browser.BookmarkColumns.BOOKMARK)) == 0) {
        map.put(Browser.BookmarkColumns.CREATED,creationTime);
        map.put(Browser.BookmarkColumns.TITLE,title);
        map.put(Browser.BookmarkColumns.BOOKMARK,1);
        cr.update(Browser.BOOKMARKS_URI,map,""String_Node_Str"" + c.getInt(0),null);
      }
 else {
        int count=c.getCount();
        boolean matchedTitle=false;
        for (int i=0; i < count; i++) {
          c.moveToPosition(i);
          if (c.getString(c.getColumnIndexOrThrow(Browser.BookmarkColumns.TITLE)).equals(title)) {
            map.put(Browser.BookmarkColumns.CREATED,creationTime);
            cr.update(Browser.BOOKMARKS_URI,map,""String_Node_Str"" + c.getInt(0),null);
            matchedTitle=true;
            break;
          }
        }
        if (!matchedTitle) {
          map.put(Browser.BookmarkColumns.TITLE,title);
          map.put(Browser.BookmarkColumns.URL,url);
          map.put(Browser.BookmarkColumns.CREATED,creationTime);
          map.put(Browser.BookmarkColumns.BOOKMARK,1);
          map.put(Browser.BookmarkColumns.DATE,0);
          int visits=0;
          if (count > 0) {
            visits=c.getInt(c.getColumnIndexOrThrow(Browser.BookmarkColumns.VISITS));
          }
          map.put(Browser.BookmarkColumns.VISITS,visits + 3);
          cr.insert(Browser.BOOKMARKS_URI,map);
        }
      }
      WebIconDatabase.getInstance().retainIconForPageUrl(url);
      c.deactivate();
      setResult(RESULT_OK);
    }
  }
 catch (  IllegalStateException e) {
    setTitle(r.getText(R.string.no_database));
    return false;
  }
  return true;
}",0.9690447400241838
185029,"/** 
 * Attempts to determine whether user input is a URL or search terms.  Anything with a space is passed to search. Converts to lowercase any mistakenly uppercased schema (i.e., ""Http://"" converts to ""http://""
 * @return Original or modified URL
 */
String smartUrlFilter(String url){
  String inUrl=url.trim();
  boolean hasSpace=inUrl.indexOf(' ') != -1;
  Matcher matcher=ACCEPTED_URI_SCHEMA.matcher(inUrl);
  if (matcher.matches()) {
    if (hasSpace) {
      inUrl=inUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    String scheme=matcher.group(1);
    String lcScheme=scheme.toLowerCase();
    if (!lcScheme.equals(scheme)) {
      return lcScheme + matcher.group(2);
    }
    return inUrl;
  }
  if (hasSpace) {
    if (inUrl.length() > 2 && inUrl.charAt(1) == ' ') {
      char char0=inUrl.charAt(0);
      if (char0 == 'g') {
        Browser.addSearchUrl(mResolver,inUrl);
        return composeSearchUrl(inUrl.substring(2));
      }
 else       if (char0 == 'w') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_W,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'd') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_D,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'l') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_L,QUERY_PLACE_HOLDER);
      }
    }
  }
 else {
    if (Regex.WEB_URL_PATTERN.matcher(inUrl).matches()) {
      return URLUtil.guessUrl(inUrl);
    }
  }
  Browser.addSearchUrl(mResolver,inUrl);
  return composeSearchUrl(inUrl);
}","/** 
 * Attempts to determine whether user input is a URL or search terms.  Anything with a space is passed to search. Converts to lowercase any mistakenly uppercased schema (i.e., ""Http://"" converts to ""http://""
 * @return Original or modified URL
 */
String smartUrlFilter(String url){
  String inUrl=url.trim();
  boolean hasSpace=inUrl.indexOf(' ') != -1;
  Matcher matcher=ACCEPTED_URI_SCHEMA.matcher(inUrl);
  if (matcher.matches()) {
    String scheme=matcher.group(1);
    String lcScheme=scheme.toLowerCase();
    if (!lcScheme.equals(scheme)) {
      inUrl=lcScheme + matcher.group(2);
    }
    if (hasSpace) {
      inUrl=inUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return inUrl;
  }
  if (hasSpace) {
    if (inUrl.length() > 2 && inUrl.charAt(1) == ' ') {
      char char0=inUrl.charAt(0);
      if (char0 == 'g') {
        Browser.addSearchUrl(mResolver,inUrl);
        return composeSearchUrl(inUrl.substring(2));
      }
 else       if (char0 == 'w') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_W,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'd') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_D,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'l') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_L,QUERY_PLACE_HOLDER);
      }
    }
  }
 else {
    if (Regex.WEB_URL_PATTERN.matcher(inUrl).matches()) {
      return URLUtil.guessUrl(inUrl);
    }
  }
  Browser.addSearchUrl(mResolver,inUrl);
  return composeSearchUrl(inUrl);
}",0.9049720506031186
185030,"@Override public Cursor query(Uri url,String[] projectionIn,String selection,String[] selectionArgs,String sortOrder) throws IllegalStateException {
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  int match=URI_MATCHER.match(url);
  if (match == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (match == URI_MATCH_SUGGEST || match == URI_MATCH_BOOKMARKS_SUGGEST) {
    String suggestSelection;
    String[] myArgs;
    if (selectionArgs[0] == null || selectionArgs[0].equals(""String_Node_Str"")) {
      suggestSelection=null;
      myArgs=null;
    }
 else {
      String like=selectionArgs[0] + ""String_Node_Str"";
      if (selectionArgs[0].startsWith(""String_Node_Str"") || selectionArgs[0].startsWith(""String_Node_Str"")) {
        myArgs=new String[1];
        myArgs[0]=like;
        suggestSelection=selection;
      }
 else {
        SUGGEST_ARGS[0]=""String_Node_Str"" + like;
        SUGGEST_ARGS[1]=""String_Node_Str"" + like;
        SUGGEST_ARGS[2]=""String_Node_Str"" + like;
        SUGGEST_ARGS[3]=""String_Node_Str"" + like;
        myArgs=SUGGEST_ARGS;
        suggestSelection=SUGGEST_SELECTION;
      }
    }
    Cursor c=db.query(TABLE_NAMES[URI_MATCH_BOOKMARKS],SUGGEST_PROJECTION,suggestSelection,myArgs,null,null,ORDER_BY,(new Integer(MAX_SUGGESTION_LONG_ENTRIES)).toString());
    if (match == URI_MATCH_BOOKMARKS_SUGGEST || Regex.WEB_URL_PATTERN.matcher(selectionArgs[0]).matches()) {
      return new MySuggestionCursor(c,null,""String_Node_Str"");
    }
 else {
      if (myArgs != null && myArgs.length > 1 && c.getCount() < (MAX_SUGGESTION_SHORT_ENTRIES - 1)) {
        ComponentName googleSearchComponent=new ComponentName(""String_Node_Str"",""String_Node_Str"");
        SearchableInfo si=SearchManager.getSearchableInfo(googleSearchComponent,false);
        Cursor sc=SearchManager.getSuggestions(getContext(),si,selectionArgs[0]);
        return new MySuggestionCursor(c,sc,selectionArgs[0]);
      }
      return new MySuggestionCursor(c,null,selectionArgs[0]);
    }
  }
  String[] projection=null;
  if (projectionIn != null && projectionIn.length > 0) {
    projection=new String[projectionIn.length + 1];
    System.arraycopy(projectionIn,0,projection,0,projectionIn.length);
    projection[projectionIn.length]=""String_Node_Str"";
  }
  StringBuilder whereClause=new StringBuilder(256);
  if (match == URI_MATCH_BOOKMARKS_ID || match == URI_MATCH_SEARCHES_ID) {
    whereClause.append(""String_Node_Str"").append(url.getPathSegments().get(1)).append(""String_Node_Str"");
  }
  if (selection != null && selection.length() > 0) {
    if (whereClause.length() > 0) {
      whereClause.append(""String_Node_Str"");
    }
    whereClause.append('(');
    whereClause.append(selection);
    whereClause.append(')');
  }
  Cursor c=db.query(TABLE_NAMES[match % 10],projection,whereClause.toString(),selectionArgs,null,null,sortOrder,null);
  c.setNotificationUri(getContext().getContentResolver(),url);
  return c;
}","@Override public Cursor query(Uri url,String[] projectionIn,String selection,String[] selectionArgs,String sortOrder) throws IllegalStateException {
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  int match=URI_MATCHER.match(url);
  if (match == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (match == URI_MATCH_SUGGEST || match == URI_MATCH_BOOKMARKS_SUGGEST) {
    String suggestSelection;
    String[] myArgs;
    if (selectionArgs[0] == null || selectionArgs[0].equals(""String_Node_Str"")) {
      suggestSelection=null;
      myArgs=null;
    }
 else {
      String like=selectionArgs[0] + ""String_Node_Str"";
      if (selectionArgs[0].startsWith(""String_Node_Str"") || selectionArgs[0].startsWith(""String_Node_Str"")) {
        myArgs=new String[1];
        myArgs[0]=like;
        suggestSelection=selection;
      }
 else {
        SUGGEST_ARGS[0]=""String_Node_Str"" + like;
        SUGGEST_ARGS[1]=""String_Node_Str"" + like;
        SUGGEST_ARGS[2]=""String_Node_Str"" + like;
        SUGGEST_ARGS[3]=""String_Node_Str"" + like;
        myArgs=SUGGEST_ARGS;
        suggestSelection=SUGGEST_SELECTION;
      }
    }
    Cursor c=db.query(TABLE_NAMES[URI_MATCH_BOOKMARKS],SUGGEST_PROJECTION,suggestSelection,myArgs,null,null,ORDER_BY,MAX_SUGGESTION_LONG_ENTRIES_STRING);
    if (match == URI_MATCH_BOOKMARKS_SUGGEST || Regex.WEB_URL_PATTERN.matcher(selectionArgs[0]).matches()) {
      return new MySuggestionCursor(c,null,""String_Node_Str"");
    }
 else {
      if (myArgs != null && myArgs.length > 1 && c.getCount() < (MAX_SUGGESTION_SHORT_ENTRIES - 1)) {
        ComponentName googleSearchComponent=new ComponentName(""String_Node_Str"",""String_Node_Str"");
        SearchableInfo si=SearchManager.getSearchableInfo(googleSearchComponent,false);
        Cursor sc=SearchManager.getSuggestions(getContext(),si,selectionArgs[0]);
        return new MySuggestionCursor(c,sc,selectionArgs[0]);
      }
      return new MySuggestionCursor(c,null,selectionArgs[0]);
    }
  }
  String[] projection=null;
  if (projectionIn != null && projectionIn.length > 0) {
    projection=new String[projectionIn.length + 1];
    System.arraycopy(projectionIn,0,projection,0,projectionIn.length);
    projection[projectionIn.length]=""String_Node_Str"";
  }
  StringBuilder whereClause=new StringBuilder(256);
  if (match == URI_MATCH_BOOKMARKS_ID || match == URI_MATCH_SEARCHES_ID) {
    whereClause.append(""String_Node_Str"").append(url.getPathSegments().get(1)).append(""String_Node_Str"");
  }
  if (selection != null && selection.length() > 0) {
    if (whereClause.length() > 0) {
      whereClause.append(""String_Node_Str"");
    }
    whereClause.append('(');
    whereClause.append(selection);
    whereClause.append(')');
  }
  Cursor c=db.query(TABLE_NAMES[match % 10],projection,whereClause.toString(),selectionArgs,null,null,sortOrder,null);
  c.setNotificationUri(getContext().getContentResolver(),url);
  return c;
}",0.994411515664691
185031,"@Override public String getString(int columnIndex){
  if ((mPos != -1 && mHistoryCursor != null)) {
switch (columnIndex) {
case SUGGEST_COLUMN_INTENT_ACTION_ID:
      if (mHistoryCount > mPos) {
        return Intent.ACTION_VIEW;
      }
 else {
        return Intent.ACTION_SEARCH;
      }
case SUGGEST_COLUMN_INTENT_DATA_ID:
    if (mHistoryCount > mPos) {
      return mHistoryCursor.getString(1);
    }
 else {
      return null;
    }
case SUGGEST_COLUMN_TEXT_1_ID:
  if (mHistoryCount > mPos) {
    return getHistoryTitle();
  }
 else   if (!mBeyondCursor) {
    return mSuggestCursor.getString(1);
  }
 else {
    return mString;
  }
case SUGGEST_COLUMN_TEXT_2_ID:
if (mHistoryCount > mPos) {
  return getHistorySubtitle();
}
 else if (!mBeyondCursor) {
  return mSuggestCursor.getString(2);
}
 else {
  return getContext().getString(R.string.search_the_web);
}
case SUGGEST_COLUMN_ICON_1_ID:
if (mHistoryCount > mPos) {
if (mHistoryCursor.getInt(3) == 1) {
  return new Integer(R.drawable.ic_search_category_bookmark).toString();
}
 else {
  return new Integer(R.drawable.ic_search_category_history).toString();
}
}
 else {
return new Integer(R.drawable.ic_search_category_suggest).toString();
}
case SUGGEST_COLUMN_ICON_2_ID:
return new String(""String_Node_Str"");
case SUGGEST_COLUMN_QUERY_ID:
if (mHistoryCount > mPos) {
return null;
}
 else if (!mBeyondCursor) {
return mSuggestCursor.getString(3);
}
 else {
return mString;
}
case SUGGEST_COLUMN_FORMAT:
return ""String_Node_Str"";
}
}
return null;
}","@Override public String getString(int columnIndex){
  if ((mPos != -1 && mHistoryCursor != null)) {
switch (columnIndex) {
case SUGGEST_COLUMN_INTENT_ACTION_ID:
      if (mHistoryCount > mPos) {
        return Intent.ACTION_VIEW;
      }
 else {
        return Intent.ACTION_SEARCH;
      }
case SUGGEST_COLUMN_INTENT_DATA_ID:
    if (mHistoryCount > mPos) {
      return mHistoryCursor.getString(1);
    }
 else {
      return null;
    }
case SUGGEST_COLUMN_TEXT_1_ID:
  if (mHistoryCount > mPos) {
    return getHistoryTitle();
  }
 else   if (!mBeyondCursor) {
    return mSuggestCursor.getString(1);
  }
 else {
    return mString;
  }
case SUGGEST_COLUMN_TEXT_2_ID:
if (mHistoryCount > mPos) {
  return getHistorySubtitle();
}
 else if (!mBeyondCursor) {
  return mSuggestCursor.getString(2);
}
 else {
  return getContext().getString(R.string.search_the_web);
}
case SUGGEST_COLUMN_ICON_1_ID:
if (mHistoryCount > mPos) {
if (mHistoryCursor.getInt(3) == 1) {
  return Integer.valueOf(R.drawable.ic_search_category_bookmark).toString();
}
 else {
  return Integer.valueOf(R.drawable.ic_search_category_history).toString();
}
}
 else {
return Integer.valueOf(R.drawable.ic_search_category_suggest).toString();
}
case SUGGEST_COLUMN_ICON_2_ID:
return ""String_Node_Str"";
case SUGGEST_COLUMN_QUERY_ID:
if (mHistoryCount > mPos) {
return null;
}
 else if (!mBeyondCursor) {
return mSuggestCursor.getString(3);
}
 else {
return mString;
}
case SUGGEST_COLUMN_FORMAT:
return ""String_Node_Str"";
}
}
return null;
}",0.8973509933774835
185032,"/** 
 * Attempts to determine whether user input is a URL or search terms.  Anything with a space is passed to search. Converts to lowercase any mistakenly uppercased schema (i.e., ""Http://"" converts to ""http://""
 * @return Original or modified URL
 */
String smartUrlFilter(String url){
  String inUrl=url.trim();
  boolean hasSpace=inUrl.indexOf(' ') != -1;
  Matcher matcher=ACCEPTED_URI_SCHEMA.matcher(inUrl);
  if (matcher.matches()) {
    if (hasSpace) {
      inUrl=inUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    String scheme=matcher.group(1);
    String lcScheme=scheme.toLowerCase();
    if (!lcScheme.equals(scheme)) {
      return lcScheme + matcher.group(2);
    }
    return inUrl;
  }
  if (hasSpace) {
    if (inUrl.length() > 2 && inUrl.charAt(1) == ' ') {
      char char0=inUrl.charAt(0);
      if (char0 == 'g') {
        Browser.addSearchUrl(mResolver,inUrl);
        return composeSearchUrl(inUrl.substring(2));
      }
 else       if (char0 == 'w') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_W,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'd') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_D,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'l') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_L,QUERY_PLACE_HOLDER);
      }
    }
  }
 else {
    if (Regex.WEB_URL_PATTERN.matcher(inUrl).matches()) {
      return URLUtil.guessUrl(inUrl);
    }
  }
  Browser.addSearchUrl(mResolver,inUrl);
  return composeSearchUrl(inUrl);
}","/** 
 * Attempts to determine whether user input is a URL or search terms.  Anything with a space is passed to search. Converts to lowercase any mistakenly uppercased schema (i.e., ""Http://"" converts to ""http://""
 * @return Original or modified URL
 */
String smartUrlFilter(String url){
  String inUrl=url.trim();
  boolean hasSpace=inUrl.indexOf(' ') != -1;
  Matcher matcher=ACCEPTED_URI_SCHEMA.matcher(inUrl);
  if (matcher.matches()) {
    String scheme=matcher.group(1);
    String lcScheme=scheme.toLowerCase();
    if (!lcScheme.equals(scheme)) {
      inUrl=lcScheme + matcher.group(2);
    }
    if (hasSpace) {
      inUrl=inUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return inUrl;
  }
  if (hasSpace) {
    if (inUrl.length() > 2 && inUrl.charAt(1) == ' ') {
      char char0=inUrl.charAt(0);
      if (char0 == 'g') {
        Browser.addSearchUrl(mResolver,inUrl);
        return composeSearchUrl(inUrl.substring(2));
      }
 else       if (char0 == 'w') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_W,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'd') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_D,QUERY_PLACE_HOLDER);
      }
 else       if (char0 == 'l') {
        Browser.addSearchUrl(mResolver,inUrl);
        return URLUtil.composeSearchUrl(inUrl.substring(2),QuickSearch_L,QUERY_PLACE_HOLDER);
      }
    }
  }
 else {
    if (Regex.WEB_URL_PATTERN.matcher(inUrl).matches()) {
      return URLUtil.guessUrl(inUrl);
    }
  }
  Browser.addSearchUrl(mResolver,inUrl);
  return composeSearchUrl(inUrl);
}",0.9049720506031186
185033,"public static void parseInput(String filenameIn,String filenameOut) throws Exception {
  BufferedReader r=new BufferedReader(new FileReader(filenameIn));
  PrintWriter w=new PrintWriter(new FileWriter(filenameOut));
  if (r.ready()) {
    String numTestCasesLine=r.readLine();
    int numTestCases=Integer.parseInt(numTestCasesLine);
    for (int testCaseIndex=0; testCaseIndex < numTestCases; testCaseIndex++) {
      String testCaseLine=r.readLine();
      String[] testCaseInput=testCaseLine.split(""String_Node_Str"");
      int lineIndex=0;
      int numCombination=Integer.parseInt(testCaseInput[lineIndex++]);
      char[] combinationLookup=new char[257];
      for (int combinersIndex=0; combinersIndex < numCombination; combinersIndex++) {
        String combination=testCaseInput[lineIndex++];
        char base1=combination.charAt(0);
        char base2=combination.charAt(1);
        char result=combination.charAt(2);
        combinationLookup[baseLookup[base1] + baseLookup[base2]]=result;
      }
      int numOpposing=Integer.parseInt(testCaseInput[lineIndex++]);
      boolean[] opposingLookup=new boolean[257];
      for (int opposingIndex=0; opposingIndex < numOpposing; opposingIndex++) {
        String opossing=testCaseInput[lineIndex++];
        char base1=opossing.charAt(0);
        char base2=opossing.charAt(1);
        opposingLookup[baseLookup[base1] + baseLookup[base2]]=true;
      }
      int numInvokation=Integer.parseInt(testCaseInput[lineIndex++]);
      String invokation=testCaseInput[lineIndex++];
      String result=""String_Node_Str"";
      for (int invokationIndex=0; invokationIndex < numInvokation; invokationIndex++) {
        result+=invokation.charAt(invokationIndex);
        int resultLength=result.length();
        if (resultLength >= 2) {
          int lastElemValue=baseLookup[result.charAt(resultLength - 1)];
          int secondLastElemValue=baseLookup[result.charAt(resultLength - 2)];
          if (combinationLookup[lastElemValue + secondLastElemValue] != 0) {
            result=result.substring(0,resultLength - 2);
            result+=combinationLookup[lastElemValue + secondLastElemValue];
          }
 else {
            for (int resultIndex=0; resultIndex < resultLength; resultIndex++) {
              int currentElemValue=baseLookup[result.charAt(resultIndex)];
              if (currentElemValue != 0 && opposingLookup[lastElemValue + currentElemValue]) {
                result=""String_Node_Str"";
                break;
              }
            }
          }
        }
      }
      String outString=""String_Node_Str"" + (testCaseIndex + 1) + ""String_Node_Str"";
      outString+=""String_Node_Str"";
      int resultLength=result.length();
      for (int resultIndex=0; resultIndex < resultLength; resultIndex++) {
        outString+=result.charAt(resultIndex);
        if (resultIndex < resultLength - 1) {
          outString+=""String_Node_Str"";
        }
      }
      outString+=""String_Node_Str"";
      System.out.println(outString);
      w.println(outString);
    }
  }
  w.flush();
}","public static void parseInput(String filenameIn,String filenameOut) throws Exception {
  BufferedReader r=new BufferedReader(new FileReader(filenameIn));
  PrintWriter w=new PrintWriter(new FileWriter(filenameOut));
  if (r.ready()) {
    String numTestCasesLine=r.readLine();
    int numTestCases=Integer.parseInt(numTestCasesLine);
    for (int testCaseIndex=0; testCaseIndex < numTestCases; testCaseIndex++) {
      String testCaseLine=r.readLine();
      String[] testCaseInput=testCaseLine.split(""String_Node_Str"");
      int lineIndex=0;
      int numCombination=Integer.parseInt(testCaseInput[lineIndex++]);
      char[] combinationLookup=new char[257];
      for (int combinersIndex=0; combinersIndex < numCombination; combinersIndex++) {
        String combination=testCaseInput[lineIndex++];
        char base1=combination.charAt(0);
        char base2=combination.charAt(1);
        char result=combination.charAt(2);
        combinationLookup[baseLookup[base1] + baseLookup[base2]]=result;
      }
      int numOpposing=Integer.parseInt(testCaseInput[lineIndex++]);
      boolean[] opposingLookup=new boolean[257];
      for (int opposingIndex=0; opposingIndex < numOpposing; opposingIndex++) {
        String opossing=testCaseInput[lineIndex++];
        char base1=opossing.charAt(0);
        char base2=opossing.charAt(1);
        opposingLookup[baseLookup[base1] + baseLookup[base2]]=true;
      }
      int numInvokation=Integer.parseInt(testCaseInput[lineIndex++]);
      String invokation=testCaseInput[lineIndex++];
      String result=""String_Node_Str"";
      for (int invokationIndex=0; invokationIndex < numInvokation; invokationIndex++) {
        result+=invokation.charAt(invokationIndex);
        int resultLength=result.length();
        if (resultLength >= 2) {
          int lastElemValue=baseLookup[result.charAt(resultLength - 1)];
          int secondLastElemValue=baseLookup[result.charAt(resultLength - 2)];
          if (lastElemValue != 0 && secondLastElemValue != 0 && combinationLookup[lastElemValue + secondLastElemValue] != 0) {
            result=result.substring(0,resultLength - 2);
            result+=combinationLookup[lastElemValue + secondLastElemValue];
          }
 else {
            for (int resultIndex=0; resultIndex < resultLength; resultIndex++) {
              int currentElemValue=baseLookup[result.charAt(resultIndex)];
              if (currentElemValue != 0 && opposingLookup[lastElemValue + currentElemValue]) {
                result=""String_Node_Str"";
                break;
              }
            }
          }
        }
      }
      String outString=""String_Node_Str"" + (testCaseIndex + 1) + ""String_Node_Str"";
      outString+=""String_Node_Str"";
      int resultLength=result.length();
      for (int resultIndex=0; resultIndex < resultLength; resultIndex++) {
        outString+=result.charAt(resultIndex);
        if (resultIndex < resultLength - 1) {
          outString+=""String_Node_Str"";
        }
      }
      outString+=""String_Node_Str"";
      System.out.println(outString);
      w.println(outString);
    }
  }
  w.flush();
}",0.9918910152448912
185034,"@SuppressWarnings(""String_Node_Str"") public <T>Optional<T> getCachedValue(Class<T> objectType){
  T result=null;
  try {
    if (Integer.class.equals(objectType)) {
      result=(T)integerValue.getValue();
    }
 else     if (String.class.equals(objectType)) {
      result=(T)cachedStringValue.getValue();
    }
 else     if (Boolean.class.equals(objectType)) {
      result=(T)booleanValue.getValue();
    }
 else     if (Float.class.equals(objectType)) {
      result=(T)floatValue.getValue();
    }
 else     if (Double.class.equals(objectType)) {
      result=(T)doubleValue.getValue();
    }
 else     if (Long.class.equals(objectType)) {
      result=(T)longValue.getValue();
    }
 else     if (Class.class.equals(objectType)) {
      result=(T)classValue.getValue();
    }
  }
 catch (  Exception e) {
  }
  if (result == null) {
    return Optional.absent();
  }
 else {
    return Optional.of(result);
  }
}","@SuppressWarnings(""String_Node_Str"") public <T>Optional<T> getCachedValue(Class<T> objectType){
  T result=null;
  try {
    if (Integer.class.equals(objectType)) {
      result=(T)integerValue.getValue();
    }
 else     if (String.class.equals(objectType)) {
      result=(T)cachedStringValue.getValue();
    }
 else     if (Boolean.class.equals(objectType)) {
      result=(T)booleanValue.getValue();
    }
 else     if (Float.class.equals(objectType)) {
      result=(T)floatValue.getValue();
    }
 else     if (Double.class.equals(objectType)) {
      result=(T)doubleValue.getValue();
    }
 else     if (Long.class.equals(objectType)) {
      result=(T)longValue.getValue();
    }
 else     if (Class.class.equals(objectType)) {
      result=(T)classValue.getValue();
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
  if (result == null) {
    return Optional.absent();
  }
 else {
    return Optional.of(result);
  }
}",0.9797225186766276
185035,"synchronized void deleteZkProperty(String key) throws Exception {
  final String path=configRootPath + ""String_Node_Str"" + key;
  try {
    client.delete().forPath(path);
  }
 catch (  NoNodeException exc) {
  }
}","synchronized void deleteZkProperty(String key) throws Exception {
  final String path=configRootPath + ""String_Node_Str"" + key;
  try {
    client.delete().forPath(path);
  }
 catch (  NoNodeException exc) {
    logger.warn(""String_Node_Str"",exc);
  }
}",0.9141630901287554
185036,"public final Map<String,Collection<String>> getDimensions(){
  return dimensions;
}","@JsonProperty(""String_Node_Str"") public final Map<String,Collection<String>> getDimensions(){
  return dimensions;
}",0.8341708542713567
185037,"public final void setDimensions(Map<String,Collection<String>> dimensions){
  this.dimensions=dimensions;
}","@JsonProperty(""String_Node_Str"") public final void setDimensions(Map<String,Collection<String>> dimensions){
  this.dimensions=dimensions;
}",0.8663967611336032
185038,"/** 
 * Load properties from the specified configuration into system wide configuration
 */
public static void loadPropertiesFromConfiguration(AbstractConfiguration config){
  if (instance instanceof AggregatedConfiguration) {
    ((AggregatedConfiguration)instance).addConfiguration(config);
  }
 else {
    Properties props=ConfigurationUtils.getProperties(config);
    ConfigurationUtils.loadProperties(props,instance);
  }
}","/** 
 * Load properties from the specified configuration into system wide configuration
 */
public static void loadPropertiesFromConfiguration(AbstractConfiguration config){
  if (instance == null) {
    instance=getConfigInstance();
  }
  if (instance instanceof AggregatedConfiguration) {
    ((AggregatedConfiguration)instance).addConfiguration(config);
  }
 else {
    Properties props=ConfigurationUtils.getProperties(config);
    ConfigurationUtils.loadProperties(props,instance);
  }
}",0.9304347826086956
185039,"/** 
 * Load the specified properties into system wide configuration
 */
public static void loadProperties(Properties properties){
  ConfigurationUtils.loadProperties(properties,instance);
}","/** 
 * Load the specified properties into system wide configuration
 */
public static void loadProperties(Properties properties){
  if (instance == null) {
    instance=getConfigInstance();
  }
  ConfigurationUtils.loadProperties(properties,instance);
}",0.8558558558558559
185040,"private boolean updateValue(Object newValue){
  String nv=(newValue == null) ? null : newValue.toString();
synchronized (lock) {
    if ((nv == null && stringValue == null) || (nv != null && nv.equals(stringValue))) {
      return false;
    }
    stringValue=nv;
    cachedStringValue.flush();
    booleanValue.flush();
    integerValue.flush();
    floatValue.flush();
    classValue.flush();
    doubleValue.flush();
    longValue.flush();
    changedTime=System.currentTimeMillis();
    return true;
  }
}","boolean updateValue(Object newValue){
  String nv=(newValue == null) ? null : newValue.toString();
synchronized (lock) {
    if ((nv == null && stringValue == null) || (nv != null && nv.equals(stringValue))) {
      return false;
    }
    stringValue=nv;
    cachedStringValue.flush();
    booleanValue.flush();
    integerValue.flush();
    floatValue.flush();
    classValue.flush();
    doubleValue.flush();
    longValue.flush();
    changedTime=System.currentTimeMillis();
    return true;
  }
}",0.992079207920792
185041,"protected PropertyWrapper(String propName,V defaultValue){
  this.prop=DynamicProperty.getInstance(propName);
  this.defaultValue=defaultValue;
  Class c=getClass();
  if (!SUBCLASSES_WITH_NO_CALLBACK.containsKey(c)) {
    this.prop.addCallback(new Runnable(){
      public void run(){
        propertyChanged();
      }
    }
);
    this.prop.addValidator(new PropertyChangeValidator(){
      @Override public void validate(      String newValue){
        PropertyWrapper.this.validate(newValue);
      }
    }
);
  }
}","protected PropertyWrapper(String propName,V defaultValue){
  this.prop=DynamicProperty.getInstance(propName);
  this.defaultValue=defaultValue;
  Class c=getClass();
  if (!SUBCLASSES_WITH_NO_CALLBACK.containsKey(c)) {
    this.prop.addCallback(new Runnable(){
      public void run(){
        propertyChanged();
      }
    }
);
    this.prop.addValidator(new PropertyChangeValidator(){
      @Override public void validate(      String newValue){
        PropertyWrapper.this.validate(newValue);
      }
    }
);
    try {
      if (this.prop.getString() != null) {
        this.validate(this.prop.getString());
      }
    }
 catch (    ValidationException e) {
      logger.warn(""String_Node_Str"",e);
      prop.updateValue(defaultValue);
    }
  }
}",0.8116169544740973
185042,"static File createConfigFile(String prefix) throws Exception {
  configFile=File.createTempFile(prefix,""String_Node_Str"");
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(configFile),""String_Node_Str""));
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.close();
  System.err.println(configFile.getPath() + ""String_Node_Str"");
  return configFile;
}","static File createConfigFile(String prefix) throws Exception {
  configFile=File.createTempFile(prefix,""String_Node_Str"");
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(configFile),""String_Node_Str""));
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.close();
  System.err.println(configFile.getPath() + ""String_Node_Str"");
  return configFile;
}",0.9432404540763674
185043,"/** 
 * Start polling the configuration source with the specified scheduler.
 * @param source PolledConfigurationSource to poll
 * @param scheduler AbstractPollingScheduler whose {@link AbstractPollingScheduler#schedule(Runnable)} will beused to determine the polling schedule
 */
public void startPolling(PolledConfigurationSource source,AbstractPollingScheduler scheduler){
  this.scheduler=scheduler;
  this.source=source;
  init(source,scheduler);
  scheduler.startPolling(source,this);
}","/** 
 * Start polling the configuration source with the specified scheduler.
 * @param source PolledConfigurationSource to poll
 * @param scheduler AbstractPollingScheduler whose {@link AbstractPollingScheduler#schedule(Runnable)} will beused to determine the polling schedule
 */
public synchronized void startPolling(PolledConfigurationSource source,AbstractPollingScheduler scheduler){
  this.scheduler=scheduler;
  this.source=source;
  init(source,scheduler);
  scheduler.startPolling(source,this);
}",0.9869608826479438
185044,"protected DynamicBooleanProperty(String propName,boolean defaultValue){
  super(propName,Boolean.valueOf(defaultValue));
}","public DynamicBooleanProperty(String propName,boolean defaultValue){
  super(propName,Boolean.valueOf(defaultValue));
}",0.9543568464730292
185045,"protected DynamicDoubleProperty(String propName,double defaultValue){
  super(propName,Double.valueOf(defaultValue));
}","public DynamicDoubleProperty(String propName,double defaultValue){
  super(propName,Double.valueOf(defaultValue));
}",0.9531914893617022
185046,"protected DynamicFloatProperty(String propName,float defaultValue){
  super(propName,Float.valueOf(defaultValue));
}","public DynamicFloatProperty(String propName,float defaultValue){
  super(propName,Float.valueOf(defaultValue));
}",0.9519650655021834
185047,"protected DynamicIntProperty(String propName,int defaultValue){
  super(propName,Integer.valueOf(defaultValue));
}","public DynamicIntProperty(String propName,int defaultValue){
  super(propName,Integer.valueOf(defaultValue));
}",0.9511111111111112
185048,"protected void propertyChanged(){
}","/** 
 * A method invoked when the underlying string property is changed. Default implementation does nothing.  Subclass can override this method  to receive callback. 
 */
protected void propertyChanged(){
}",0.2892561983471074
185049,"protected void load(){
  if (delegate.get() == null) {
    return;
  }
  final List<String> strings=Arrays.asList(delegate.get().split(delimiter));
  List<T> list=new ArrayList<T>(strings.size());
  for (  String s : strings) {
    list.add(from(s));
  }
  values=Collections.unmodifiableList(list);
}","protected void load(){
  if (delegate.get() == null) {
    values=defaultValues;
  }
 else {
    values=transform(split(delegate.get()));
  }
}",0.4549549549549549
185050,"public List<T> get(){
  return values;
}","/** 
 * Get the list type from the underlying dynamic string property. If the property is undefined, this method returns the default list value.   
 */
public List<T> get(){
  return values;
}",0.3448275862068966
185051,"public DynamicListProperty(String propName,List<T> defaultValue,String delimiterRegex){
  this(propName,(String)null,delimiterRegex);
  if (values == null && defaultValue != null) {
    values=Collections.unmodifiableList(defaultValue);
  }
}","/** 
 * Create the dynamic list property using the splitter and default list value passed in  from the arguments.
 */
public DynamicListProperty(String propName,List<T> defaultValue,Splitter splitter){
  setup(propName,defaultValue,splitter);
}",0.345679012345679
185052,protected abstract T from(String value);,"/** 
 * Construct the generic type from string.
 */
protected abstract T from(String value);",0.6060606060606061
185053,"/** 
 * Add the callback to be triggered when the value of the property is changed
 * @param callback
 */
public void addCallback(Runnable callback){
  if (callback != null)   delegate.addCallback(callback);
}","/** 
 * Add the callback to be triggered when the value of the property is changed
 */
public void addCallback(Runnable callback){
  if (callback != null)   delegate.addCallback(callback);
}",0.9523809523809524
185054,"protected DynamicLongProperty(String propName,long defaultValue){
  super(propName,Long.valueOf(defaultValue));
}","public DynamicLongProperty(String propName,long defaultValue){
  super(propName,Long.valueOf(defaultValue));
}",0.9506726457399104
185055,"private static String getNextLoad(Configuration propConfig,String... nextLoadPropertyKeys){
  String nextLoadKeyToUse=null;
  for (  String key : nextLoadPropertyKeys) {
    if (propConfig.getProperty(key) != null) {
      nextLoadKeyToUse=key;
      break;
    }
  }
  if (nextLoadKeyToUse == null) {
    return null;
  }
  ConcurrentMapConfiguration config=new ConcurrentMapConfiguration();
  config.setDelimiterParsingDisabled(true);
  copyProperties(ConfigurationManager.getConfigInstance(),config);
  copyProperties(propConfig,config);
  String nextLoad=config.getString(nextLoadKeyToUse);
  propConfig.clearProperty(nextLoadKeyToUse);
  return nextLoad;
}","private static String getNextLoad(Configuration propConfig,String... nextLoadPropertyKeys){
  String nextLoadKeyToUse=null;
  for (  String key : nextLoadPropertyKeys) {
    if (propConfig.getProperty(key) != null) {
      nextLoadKeyToUse=key;
      break;
    }
  }
  if (nextLoadKeyToUse == null) {
    return null;
  }
  ConcurrentMapConfiguration config=new ConcurrentMapConfiguration();
  copyProperties(ConfigurationManager.getConfigInstance(),config);
  copyProperties(propConfig,config);
  List<Object> list=config.getList(nextLoadKeyToUse);
  StringBuilder sb=new StringBuilder();
  for (  Object value : list) {
    sb.append(value).append(""String_Node_Str"");
  }
  String nextLoad=sb.toString();
  propConfig.clearProperty(nextLoadKeyToUse);
  return nextLoad;
}",0.621602787456446
185056,"@Override public String toString(){
  return ""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ prop.getString(defaultValue.toString())+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ prop.getString(String.valueOf(defaultValue))+ ""String_Node_Str"";
}",0.9240121580547112
185057,"/** 
 * Adds a callback to the DynamicProperty to run when the value of the propety is updated.
 */
public void addCallback(Runnable r){
  callbacks.add(r);
}","/** 
 * Adds a callback to the DynamicProperty to run when the value of the propety is updated.
 */
public void addCallback(Runnable r){
  if (r == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  callbacks.add(r);
}",0.8020304568527918
185058,"public DynamoDbConfigurationSource(AmazonDynamoDB dbClient){
  this.dbClient=dbClient;
  String table=tableName.get();
  Map<String,Object> map=load(table,keyAttributeName.get(),valueAttributeName.get());
  log.info(""String_Node_Str"" + table);
}","public DynamoDbConfigurationSource(AmazonDynamoDB dbClient){
  this.dbClient=dbClient;
  String table=tableName.get();
  load(table,keyAttributeName.get(),valueAttributeName.get());
  log.info(""String_Node_Str"" + table);
}",0.9507494646680942
185059,"static void updateValues(AmazonDynamoDB dbClient,String tableName){
  Map<String,AttributeValueUpdate> item1=new HashMap<String,AttributeValueUpdate>(1);
  item1.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item1));
  HashMap<String,AttributeValue> item2=new HashMap<String,AttributeValue>(1);
  item1.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item1));
  HashMap<String,AttributeValue> item3=new HashMap<String,AttributeValue>(1);
  item1.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item1));
}","static void updateValues(AmazonDynamoDB dbClient,String tableName){
  Map<String,AttributeValueUpdate> item1=new HashMap<String,AttributeValueUpdate>(1);
  item1.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item1));
  HashMap<String,AttributeValueUpdate> item2=new HashMap<String,AttributeValueUpdate>(1);
  item2.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item2));
  HashMap<String,AttributeValueUpdate> item3=new HashMap<String,AttributeValueUpdate>(1);
  item3.put(DynamoDbConfigurationSource.defaultValueAttribute,new AttributeValueUpdate().withAction(AttributeAction.PUT).withValue(new AttributeValue().withS(""String_Node_Str"")));
  dbClient.updateItem(new UpdateItemRequest().withTableName(tableName).withKey(new Key().withHashKeyElement(new AttributeValue().withS(""String_Node_Str""))).withAttributeUpdates(item3));
}",0.9887403237156932
185060,"private WordprocessingMLPackage fetchComponents(WordprocessingMLPackage srcPackage,ContentAccessor contentAccessor) throws Docx4JException {
  Map<Integer,CTAltChunk> replacements=new HashMap<Integer,CTAltChunk>();
  Integer index=0;
  justGotAComponent=false;
  LinkedList<Integer> continuousBeforeIndex=new LinkedList<Integer>();
  List<Boolean> continuousBefore=new ArrayList<Boolean>();
  List<Boolean> continuousAfter=new ArrayList<Boolean>();
  for (  Object block : contentAccessor.getContent()) {
    if (block instanceof org.docx4j.wml.SdtBlock) {
      org.docx4j.wml.SdtBlock sdt=(org.docx4j.wml.SdtBlock)block;
      Tag tag=getSdtPr(sdt).getTag();
      if (tag == null) {
        List<Object> newContent=new ArrayList<Object>();
        newContent.add(sdt);
        continue;
      }
      log.info(tag.getVal());
      HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
      String componentId=map.get(BINDING_ROLE_COMPONENT);
      if (componentId == null)       continue;
      String iri=ComponentsPart.getComponentById(components,componentId).getIri();
      log.debug(""String_Node_Str"" + iri);
      if (docxFetcher == null) {
        log.error(""String_Node_Str"");
        return srcPackage;
      }
      AlternativeFormatInputPart afiPart=new AlternativeFormatInputPart(getNewPartName(""String_Node_Str"",""String_Node_Str"",srcPackage.getMainDocumentPart().getRelationshipsPart()));
      afiPart.setBinaryData(docxFetcher.getDocxFromIRI(iri));
      afiPart.setContentType(new ContentType(""String_Node_Str""));
      Relationship altChunkRel=srcPackage.getMainDocumentPart().addTargetPart(afiPart);
      CTAltChunk ac=Context.getWmlObjectFactory().createCTAltChunk();
      ac.setId(altChunkRel.getId());
      replacements.put(index,ac);
      if (map.get(BINDING_ROLE_COMPONENT_BEFORE) != null && map.get(BINDING_ROLE_COMPONENT_BEFORE).equals(""String_Node_Str"")) {
        continuousBefore.add(Boolean.TRUE);
        continuousBeforeIndex.addFirst(index);
        log.info(""String_Node_Str"" + index);
      }
 else {
        continuousBefore.add(Boolean.FALSE);
        continuousBeforeIndex.addFirst(index);
      }
      if (map.get(BINDING_ROLE_COMPONENT_AFTER) != null && map.get(BINDING_ROLE_COMPONENT_AFTER).equals(""String_Node_Str"")) {
        continuousAfter.add(Boolean.TRUE);
      }
 else {
        continuousAfter.add(Boolean.TRUE);
      }
      justGotAComponent=true;
    }
    index++;
  }
  if (!justGotAComponent) {
    return srcPackage;
  }
  for (  Integer key : replacements.keySet()) {
    contentAccessor.getContent().set(key,replacements.get(key));
  }
  List<Object> bodyChildren=contentAccessor.getContent();
  int i=0;
  for (  Integer indexIntoBody : continuousBeforeIndex) {
    if (continuousBefore.get(i)) {
      if (indexIntoBody == 0) {
      }
 else {
        Object block=bodyChildren.get(indexIntoBody.intValue() - 1);
        if (block instanceof P && ((P)block).getPPr() != null && ((P)block).getPPr().getSectPr() != null) {
          makeContinuous(((P)block).getPPr().getSectPr());
        }
 else         if (block instanceof P) {
          PPr ppr=((P)block).getPPr();
          if (ppr == null) {
            ppr=Context.getWmlObjectFactory().createPPr();
            ((P)block).setPPr(ppr);
          }
          SectPr newSectPr=Context.getWmlObjectFactory().createSectPr();
          SectPr.Type type=Context.getWmlObjectFactory().createSectPrType();
          type.setVal(""String_Node_Str"");
          newSectPr.setType(type);
          ppr.setSectPr(newSectPr);
        }
 else {
          P newP=Context.getWmlObjectFactory().createP();
          PPr ppr=Context.getWmlObjectFactory().createPPr();
          newP.setPPr(ppr);
          SectPr newSectPr=Context.getWmlObjectFactory().createSectPr();
          SectPr.Type type=Context.getWmlObjectFactory().createSectPrType();
          type.setVal(""String_Node_Str"");
          newSectPr.setType(type);
          ppr.setSectPr(newSectPr);
          bodyChildren.add(indexIntoBody.intValue(),newP);
        }
      }
    }
    i++;
  }
  try {
    Class<?> documentBuilder=Class.forName(""String_Node_Str"");
    Method[] methods=documentBuilder.getMethods();
    Method processMethod=null;
    for (int j=0; j < methods.length; j++) {
      log.debug(methods[j].getName());
      if (methods[j].getName().equals(""String_Node_Str"") && methods[j].getParameterCount() == 3) {
        processMethod=methods[j];
      }
    }
    if (processMethod == null)     throw new NoSuchMethodException();
    return (WordprocessingMLPackage)processMethod.invoke(null,srcPackage,xpathsMap,conditionsMap);
  }
 catch (  ClassNotFoundException e) {
    extensionMissing(e);
    justGotAComponent=false;
    return srcPackage;
  }
catch (  NoSuchMethodException e) {
    extensionMissing(e);
    justGotAComponent=false;
    return srcPackage;
  }
catch (  Exception e) {
    throw new Docx4JException(""String_Node_Str"",e);
  }
}","private WordprocessingMLPackage fetchComponents(WordprocessingMLPackage srcPackage,ContentAccessor contentAccessor) throws Docx4JException {
  Map<Integer,CTAltChunk> replacements=new HashMap<Integer,CTAltChunk>();
  Integer index=0;
  justGotAComponent=false;
  LinkedList<Integer> continuousBeforeIndex=new LinkedList<Integer>();
  List<Boolean> continuousBefore=new ArrayList<Boolean>();
  List<Boolean> continuousAfter=new ArrayList<Boolean>();
  for (  Object block : contentAccessor.getContent()) {
    if (block instanceof org.docx4j.wml.SdtBlock) {
      org.docx4j.wml.SdtBlock sdt=(org.docx4j.wml.SdtBlock)block;
      Tag tag=getSdtPr(sdt).getTag();
      if (tag == null) {
        List<Object> newContent=new ArrayList<Object>();
        newContent.add(sdt);
        index++;
        continue;
      }
      log.info(tag.getVal());
      HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
      String componentId=map.get(BINDING_ROLE_COMPONENT);
      if (componentId == null) {
        index++;
        continue;
      }
      String iri=ComponentsPart.getComponentById(components,componentId).getIri();
      log.debug(""String_Node_Str"" + iri);
      if (docxFetcher == null) {
        log.error(""String_Node_Str"");
        return srcPackage;
      }
      AlternativeFormatInputPart afiPart=new AlternativeFormatInputPart(getNewPartName(""String_Node_Str"",""String_Node_Str"",srcPackage.getMainDocumentPart().getRelationshipsPart()));
      afiPart.setBinaryData(docxFetcher.getDocxFromIRI(iri));
      afiPart.setContentType(new ContentType(""String_Node_Str""));
      Relationship altChunkRel=srcPackage.getMainDocumentPart().addTargetPart(afiPart);
      CTAltChunk ac=Context.getWmlObjectFactory().createCTAltChunk();
      ac.setId(altChunkRel.getId());
      replacements.put(index,ac);
      if (map.get(BINDING_ROLE_COMPONENT_BEFORE) != null && map.get(BINDING_ROLE_COMPONENT_BEFORE).equals(""String_Node_Str"")) {
        continuousBefore.add(Boolean.TRUE);
        continuousBeforeIndex.addFirst(index);
        log.info(""String_Node_Str"" + index);
      }
 else {
        continuousBefore.add(Boolean.FALSE);
        continuousBeforeIndex.addFirst(index);
      }
      if (map.get(BINDING_ROLE_COMPONENT_AFTER) != null && map.get(BINDING_ROLE_COMPONENT_AFTER).equals(""String_Node_Str"")) {
        continuousAfter.add(Boolean.TRUE);
      }
 else {
        continuousAfter.add(Boolean.TRUE);
      }
      justGotAComponent=true;
    }
    index++;
  }
  if (!justGotAComponent) {
    return srcPackage;
  }
  for (  Integer key : replacements.keySet()) {
    contentAccessor.getContent().set(key,replacements.get(key));
    System.out.println(""String_Node_Str"" + key);
  }
  List<Object> bodyChildren=contentAccessor.getContent();
  int i=0;
  for (  Integer indexIntoBody : continuousBeforeIndex) {
    if (continuousBefore.get(i)) {
      if (indexIntoBody == 0) {
      }
 else {
        Object block=bodyChildren.get(indexIntoBody.intValue() - 1);
        if (block instanceof P && ((P)block).getPPr() != null && ((P)block).getPPr().getSectPr() != null) {
          makeContinuous(((P)block).getPPr().getSectPr());
        }
 else         if (block instanceof P) {
          PPr ppr=((P)block).getPPr();
          if (ppr == null) {
            ppr=Context.getWmlObjectFactory().createPPr();
            ((P)block).setPPr(ppr);
          }
          SectPr newSectPr=Context.getWmlObjectFactory().createSectPr();
          SectPr.Type type=Context.getWmlObjectFactory().createSectPrType();
          type.setVal(""String_Node_Str"");
          newSectPr.setType(type);
          ppr.setSectPr(newSectPr);
        }
 else {
          P newP=Context.getWmlObjectFactory().createP();
          PPr ppr=Context.getWmlObjectFactory().createPPr();
          newP.setPPr(ppr);
          SectPr newSectPr=Context.getWmlObjectFactory().createSectPr();
          SectPr.Type type=Context.getWmlObjectFactory().createSectPrType();
          type.setVal(""String_Node_Str"");
          newSectPr.setType(type);
          ppr.setSectPr(newSectPr);
          bodyChildren.add(indexIntoBody.intValue(),newP);
        }
      }
    }
    i++;
  }
  try {
    Class<?> documentBuilder=Class.forName(""String_Node_Str"");
    Method[] methods=documentBuilder.getMethods();
    Method processMethod=null;
    for (int j=0; j < methods.length; j++) {
      log.debug(methods[j].getName());
      if (methods[j].getName().equals(""String_Node_Str"") && methods[j].getParameterCount() == 3) {
        processMethod=methods[j];
      }
    }
    if (processMethod == null)     throw new NoSuchMethodException();
    return (WordprocessingMLPackage)processMethod.invoke(null,srcPackage,xpathsMap,conditionsMap);
  }
 catch (  ClassNotFoundException e) {
    extensionMissing(e);
    justGotAComponent=false;
    return srcPackage;
  }
catch (  NoSuchMethodException e) {
    extensionMissing(e);
    justGotAComponent=false;
    return srcPackage;
  }
catch (  Exception e) {
    throw new Docx4JException(""String_Node_Str"",e);
  }
}",0.9875137348916192
185061,"public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      if (xpath.contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
      }
 else {
        try {
          if (xo.bool(cachedXPathAPI.getXPathContext())) {
            return ""String_Node_Str"";
          }
 else {
            return ""String_Node_Str"";
          }
        }
 catch (        org.apache.xpath.XPathException e) {
          log.debug(e.getMessage());
        }
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      if (xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
      }
 else {
        try {
          double d=xo.num(cachedXPathAPI.getXPathContext());
          if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
            return ""String_Node_Str"" + Math.round(d);
          }
 else {
            return ""String_Node_Str"" + d;
          }
        }
 catch (        org.apache.xpath.XPathException e) {
          log.debug(e.getMessage());
        }
      }
    }
    try {
      Node result;
      if (log.isDebugEnabled()) {
        NodeIterator ni=xo.nodeset();
        result=ni.nextNode();
        Node nextNode=ni.nextNode();
        if (nextNode != null) {
          log.debug(xpath + ""String_Node_Str"");
        }
      }
 else {
        result=xo.nodeset().nextNode();
      }
      if (result == null) {
        log.debug(xpath + ""String_Node_Str"");
        return ""String_Node_Str"";
      }
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath + ""String_Node_Str""+ e.getMessage());
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath + ""String_Node_Str""+ e.getMessage());
        double d=xo.num(cachedXPathAPI.getXPathContext());
        if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
          return ""String_Node_Str"" + Math.round(d);
        }
 else {
          return ""String_Node_Str"" + d;
        }
      }
 else {
        log.error(e.getMessage());
        log.error(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    log.error(System.getProperty(""String_Node_Str""));
    log.error(System.getProperty(""String_Node_Str""));
    log.error(Locale.getDefault().toString());
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}","public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
    if (Docx4jProperties.getProperty(""String_Node_Str"",true)) {
      String trimmedXPath=xpath.trim();
      if (trimmedXPath.startsWith(""String_Node_Str"") || trimmedXPath.startsWith(""String_Node_Str"")) {
        try {
          if (xo.bool(cachedXPathAPI.getXPathContext())) {
            return ""String_Node_Str"";
          }
 else {
            return ""String_Node_Str"";
          }
        }
 catch (        org.apache.xpath.XPathException e) {
          log.debug(e.getMessage());
        }
      }
 else       if (trimmedXPath.startsWith(""String_Node_Str"")) {
        if (xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"")) {
          log.debug(""String_Node_Str"" + xpath);
        }
 else {
          try {
            double d=xo.num(cachedXPathAPI.getXPathContext());
            if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
              return ""String_Node_Str"" + Math.round(d);
            }
 else {
              return ""String_Node_Str"" + d;
            }
          }
 catch (          org.apache.xpath.XPathException e) {
            log.debug(e.getMessage());
          }
        }
      }
    }
    try {
      Node result;
      if (log.isDebugEnabled()) {
        NodeIterator ni=xo.nodeset();
        result=ni.nextNode();
        Node nextNode=ni.nextNode();
        if (nextNode != null) {
          log.debug(xpath + ""String_Node_Str"");
        }
      }
 else {
        result=xo.nodeset().nextNode();
      }
      if (result == null) {
        log.debug(xpath + ""String_Node_Str"");
        return ""String_Node_Str"";
      }
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath + ""String_Node_Str""+ e.getMessage());
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath + ""String_Node_Str""+ e.getMessage());
        double d=xo.num(cachedXPathAPI.getXPathContext());
        if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
          return ""String_Node_Str"" + Math.round(d);
        }
 else {
          return ""String_Node_Str"" + d;
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath + ""String_Node_Str""+ e.getMessage());
        return xo.xstr(cachedXPathAPI.getXPathContext()).toString();
      }
 else {
        log.error(e.getMessage());
        log.error(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    log.error(System.getProperty(""String_Node_Str""));
    log.error(System.getProperty(""String_Node_Str""));
    log.error(Locale.getDefault().toString());
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}",0.8340266819681538
185062,"public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
      if (xo.bool(cachedXPathAPI.getXPathContext())) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
      double d=xo.num(cachedXPathAPI.getXPathContext());
      return ""String_Node_Str"" + Math.round(d);
    }
    try {
      Node result=selectSingleNode(doc,xpath);
      if (result == null) {
        log.debug(xpath + ""String_Node_Str"");
        return ""String_Node_Str"";
      }
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        double d=xo.num(cachedXPathAPI.getXPathContext());
        return ""String_Node_Str"" + d;
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}","public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      if (xpath.contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
      }
 else {
        try {
          XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
          if (xo.bool(cachedXPathAPI.getXPathContext())) {
            return ""String_Node_Str"";
          }
 else {
            return ""String_Node_Str"";
          }
        }
 catch (        org.apache.xpath.XPathException e) {
          log.debug(e.getMessage());
        }
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      if (xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"") || xpath.contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
      }
 else {
        try {
          XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
          double d=xo.num(cachedXPathAPI.getXPathContext());
          if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
            return ""String_Node_Str"" + Math.round(d);
          }
 else {
            return ""String_Node_Str"" + d;
          }
        }
 catch (        org.apache.xpath.XPathException e) {
          log.debug(e.getMessage());
        }
      }
    }
    try {
      Node result=selectSingleNode(doc,xpath);
      if (result == null) {
        log.debug(xpath + ""String_Node_Str"");
        return ""String_Node_Str"";
      }
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        double d=xo.num(cachedXPathAPI.getXPathContext());
        if (xpath.trim().startsWith(""String_Node_Str"") && d == Math.rint(d)) {
          return ""String_Node_Str"" + Math.round(d);
        }
 else {
          return ""String_Node_Str"" + d;
        }
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}",0.8245479030396307
185063,"/** 
 * Insert an empty placeholder SDT, to facilitate round-tripping (ie ability to convert instance docx back to original template), which you may wish to do if you want to insert updated data, but preserve certain manual edits.
 * @param sdt
 * @return
 */
private List<Object> conditionFalse(Object sdt){
  List<Object> newContent=new ArrayList<Object>();
  newContent.add(sdt);
  SdtPr sdtPr=getSdtPr(sdt);
  CTDataBinding binding=sdtPr.getDataBinding();
  if (binding != null) {
    sdtPr.getRPrOrAliasOrLock().remove(binding);
  }
  Tag tag=sdtPr.getTag();
  final String tagVal=tag.getVal();
  final Pattern stripConditionArgPattern=Pattern.compile(""String_Node_Str"");
  final Matcher stripPatternMatcher=stripConditionArgPattern.matcher(tagVal);
  if (!stripPatternMatcher.matches()) {
    log.error(""String_Node_Str"" + tagVal);
    return newContent;
  }
  final String emptyConditionValue=BINDING_RESULT_CONDITION_FALSE + ""String_Node_Str"" + stripPatternMatcher.group(2)+ stripPatternMatcher.group(3);
  tag.setVal(emptyConditionValue);
  CTLock lock=Context.getWmlObjectFactory().createCTLock();
  lock.setVal(org.docx4j.wml.STLock.SDT_CONTENT_LOCKED);
  JAXBElement<org.docx4j.wml.CTLock> lockWrapped=Context.getWmlObjectFactory().createSdtPrLock(lock);
  sdtPr.getRPrOrAliasOrLock().add(lockWrapped);
  TcFinder tcFinder=new TcFinder();
  new TraversalUtil(((SdtElement)sdt).getSdtContent().getContent(),tcFinder);
  if (tcFinder.tcList.size() > 0) {
    Tc tc=tcFinder.tcList.get(0);
    tc.getContent().clear();
    P p=Context.getWmlObjectFactory().createP();
    tc.getContent().add(p);
    ((SdtElement)sdt).getSdtContent().getContent().clear();
    ((SdtElement)sdt).getSdtContent().getContent().add(tc);
  }
 else {
    ((SdtElement)sdt).getSdtContent().getContent().clear();
  }
  return newContent;
}","/** 
 * Insert an empty placeholder SDT, to facilitate round-tripping (ie ability to convert instance docx back to original template), which you may wish to do if you want to insert updated data, but preserve certain manual edits.
 * @param sdt
 * @return
 */
private List<Object> conditionFalse(Object sdt){
  List<Object> newContent=new ArrayList<Object>();
  newContent.add(sdt);
  SdtPr sdtPr=getSdtPr(sdt);
  CTDataBinding binding=sdtPr.getDataBinding();
  if (binding != null) {
    sdtPr.getRPrOrAliasOrLock().remove(binding);
  }
  Tag tag=sdtPr.getTag();
  final String tagVal=tag.getVal();
  final Pattern stripConditionArgPattern=Pattern.compile(""String_Node_Str"");
  final Matcher stripPatternMatcher=stripConditionArgPattern.matcher(tagVal);
  if (!stripPatternMatcher.matches()) {
    log.error(""String_Node_Str"" + tagVal);
    return newContent;
  }
  final String emptyConditionValue=BINDING_RESULT_CONDITION_FALSE + ""String_Node_Str"" + stripPatternMatcher.group(2)+ stripPatternMatcher.group(3);
  tag.setVal(emptyConditionValue);
  CTLock lock=Context.getWmlObjectFactory().createCTLock();
  lock.setVal(org.docx4j.wml.STLock.SDT_CONTENT_LOCKED);
  JAXBElement<org.docx4j.wml.CTLock> lockWrapped=Context.getWmlObjectFactory().createSdtPrLock(lock);
  sdtPr.getRPrOrAliasOrLock().add(lockWrapped);
  TableObjectFinder tableObjectFinder=new TableObjectFinder();
  new TraversalUtil(((SdtElement)sdt).getSdtContent().getContent(),tableObjectFinder);
  if (tableObjectFinder.result == null) {
    ((SdtElement)sdt).getSdtContent().getContent().clear();
  }
 else   if (tableObjectFinder.result instanceof Tbl) {
    ((SdtElement)sdt).getSdtContent().getContent().clear();
  }
 else   if (tableObjectFinder.result instanceof Tr) {
    ((SdtElement)sdt).getSdtContent().getContent().clear();
  }
 else   if (tableObjectFinder.result instanceof Tc) {
    Tc tc=(Tc)tableObjectFinder.result;
    tc.getContent().clear();
    P p=Context.getWmlObjectFactory().createP();
    tc.getContent().add(p);
    ((SdtElement)sdt).getSdtContent().getContent().clear();
    ((SdtElement)sdt).getSdtContent().getContent().add(tc);
  }
 else {
  }
  return newContent;
}",0.8653797944346954
185064,"/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  try {
    Marshaller marshaller=jc.createMarshaller();
    if (Docx4jProperties.getProperty(""String_Node_Str"",true)) {
      marshaller.setProperty(""String_Node_Str"",true);
    }
    NamespacePrefixMapperUtils.setProperty(marshaller,namespacePrefixMapper);
    log.debug(""String_Node_Str"" + this.getClass().getName());
    getContents();
    setMceIgnorable((McIgnorableNamespaceDeclarator)namespacePrefixMapper);
    if (Docx4jProperties.getProperty(""String_Node_Str"",false)) {
      Document doc=XmlUtils.marshaltoW3CDomDocument(jaxbElement,jc);
      log.debug(""String_Node_Str"" + XmlUtils.w3CDomNodeToString(doc));
      Init.init();
      Canonicalizer c=Canonicalizer.getInstance(CanonicalizationMethod.EXCLUSIVE);
      byte[] bytes=c.canonicalizeSubtree(doc,this.getMceIgnorable());
      IOUtils.write(bytes,os);
    }
 else {
      marshaller.marshal(jaxbElement,os);
    }
    ((McIgnorableNamespaceDeclarator)namespacePrefixMapper).setMcIgnorable(null);
  }
 catch (  Docx4JException e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
catch (  JAXBException e) {
    log.error(e.getMessage(),e);
    throw e;
  }
catch (  Exception e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
}","/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  try {
    Marshaller marshaller=jc.createMarshaller();
    if (Docx4jProperties.getProperty(""String_Node_Str"",true)) {
      marshaller.setProperty(""String_Node_Str"",true);
    }
    NamespacePrefixMapperUtils.setProperty(marshaller,namespacePrefixMapper);
    log.debug(""String_Node_Str"" + this.getClass().getName());
    getContents();
    setMceIgnorable((McIgnorableNamespaceDeclarator)namespacePrefixMapper);
    if (Docx4jProperties.getProperty(""String_Node_Str"",false)) {
      Document doc=XmlUtils.marshaltoW3CDomDocument(jaxbElement,jc);
      NamespacePrefixMapperUtils.declareNamespaces(this.getMceIgnorable(),doc);
      log.warn(""String_Node_Str"" + XmlUtils.w3CDomNodeToString(doc));
      Init.init();
      Canonicalizer c=Canonicalizer.getInstance(CanonicalizationMethod.EXCLUSIVE);
      log.debug(""String_Node_Str"" + this.getMceIgnorable());
      byte[] bytes=c.canonicalizeSubtree(doc,this.getMceIgnorable());
      IOUtils.write(bytes,os);
    }
 else {
      marshaller.marshal(jaxbElement,os);
    }
    ((McIgnorableNamespaceDeclarator)namespacePrefixMapper).setMcIgnorable(null);
  }
 catch (  Docx4JException e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
catch (  JAXBException e) {
    log.error(e.getMessage(),e);
    throw e;
  }
catch (  Exception e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
}",0.9530878859857482
185065,"@Override protected void setMceIgnorable(McIgnorableNamespaceDeclarator namespacePrefixMapper){
  boolean needW14=false;
  if (this.jaxbElement.getDocId14() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getConflictMode() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getDiscardImageEditingData() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getDefaultImageDpi() != null) {
    needW14=true;
  }
  boolean needW15=false;
  if (this.jaxbElement.getChartTrackingRefBased() != null) {
    needW15=true;
  }
 else   if (this.jaxbElement.getDocId15() != null) {
    needW15=true;
  }
  String mceIgnorableVal=""String_Node_Str"";
  if (needW14) {
    mceIgnorableVal=""String_Node_Str"";
  }
  if (needW15) {
    mceIgnorableVal+=""String_Node_Str"";
  }
  log.debug(mceIgnorableVal);
  this.jaxbElement.setIgnorable(mceIgnorableVal);
}","@Override protected void setMceIgnorable(McIgnorableNamespaceDeclarator namespacePrefixMapper){
  boolean needW14=false;
  if (this.jaxbElement.getDocId14() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getConflictMode() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getDiscardImageEditingData() != null) {
    needW14=true;
  }
 else   if (this.jaxbElement.getDefaultImageDpi() != null) {
    needW14=true;
  }
  boolean needW15=false;
  if (this.jaxbElement.getChartTrackingRefBased() != null) {
    needW15=true;
  }
 else   if (this.jaxbElement.getDocId15() != null) {
    needW15=true;
  }
  String mceIgnorableVal=""String_Node_Str"";
  if (needW14) {
    mceIgnorableVal=""String_Node_Str"";
  }
  if (needW15) {
    mceIgnorableVal+=""String_Node_Str"";
  }
  log.debug(mceIgnorableVal);
  namespacePrefixMapper.setMcIgnorable(mceIgnorableVal);
  this.jaxbElement.setIgnorable(mceIgnorableVal);
}",0.9683860232945092
185066,"/** 
 * Example of setting mc:Ignorable=""w15"", which you must do if you add eg w15:collapsed and want Word <=14 to be happy.
 * @throws InvalidFormatException
 * @throws JAXBException
 */
@Test public void testIgnorableSet() throws InvalidFormatException, JAXBException {
  Document document=new Document();
  Body body=new Body();
  document.setBody(body);
  P p=new P();
  PPr ppr=new PPr();
  p.setPPr(ppr);
  body.getContent().add(p);
  ppr.setCollapsed(new BooleanDefaultTrue());
  document.setIgnorable(""String_Node_Str"");
  MainDocumentPart mdp=new MainDocumentPart();
  mdp.setJaxbElement(document);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  mdp.marshal(baos);
  String result=(new String(baos.toByteArray()));
  assertTrue(result.contains(""String_Node_Str""));
}","/** 
 * Example of setting mc:Ignorable=""w15"", which you must do if you add eg w15:collapsed and want Word <=14 to be happy.
 * @throws InvalidFormatException
 * @throws JAXBException
 */
@Test public void testIgnorableSet() throws InvalidFormatException, JAXBException {
  Document document=new Document();
  Body body=new Body();
  document.setBody(body);
  P p=new P();
  PPr ppr=new PPr();
  p.setPPr(ppr);
  body.getContent().add(p);
  ppr.setCollapsed(new BooleanDefaultTrue());
  document.setIgnorable(""String_Node_Str"");
  MainDocumentPart mdp=new MainDocumentPart();
  mdp.setJaxbElement(document);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  mdp.marshal(baos);
  String result=(new String(baos.toByteArray()));
  System.out.println(result);
  assertTrue(result.contains(""String_Node_Str""));
  int startPos=result.indexOf(""String_Node_Str"");
  String startTag=result.substring(startPos,result.indexOf(""String_Node_Str"",startPos));
  assertTrue(startTag.contains(""String_Node_Str""));
}",0.8770172509738453
185067,"public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
    cachedXPathAPI.getXPathContext().setNamespaceContext(getNamespaceContext());
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath);
      if (xo.bool(cachedXPathAPI.getXPathContext())) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath);
      double d=xo.num(cachedXPathAPI.getXPathContext());
      return ""String_Node_Str"" + Math.round(d);
    }
    try {
      Node result=cachedXPathAPI.selectSingleNode(doc,xpath);
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath);
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath);
        double d=xo.num(cachedXPathAPI.getXPathContext());
        return ""String_Node_Str"" + d;
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}","public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
      if (xo.bool(cachedXPathAPI.getXPathContext())) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
      double d=xo.num(cachedXPathAPI.getXPathContext());
      return ""String_Node_Str"" + Math.round(d);
    }
    try {
      Node result=selectSingleNode(doc,xpath);
      if (result == null) {
        log.debug(xpath + ""String_Node_Str"");
        return ""String_Node_Str"";
      }
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath,getNamespaceContext());
        double d=xo.num(cachedXPathAPI.getXPathContext());
        return ""String_Node_Str"" + d;
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}",0.9282296650717704
185068,"/** 
 * Clone this JAXB object
 * @param value
 * @param jc
 * @return
 */
public static <T>T deepCopy(T value,JAXBContext jc){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)value.getClass();
    JAXBElement<T> contentObject=new JAXBElement<T>(new QName(clazz.getSimpleName()),clazz,value);
    JAXBSource source=new JAXBSource(jc,contentObject);
    JAXBElement<T> elem=jc.createUnmarshaller().unmarshal(source,clazz);
    T res;
    if (value instanceof JAXBElement<?>) {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem;
      res=resT;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem.getValue();
      res=resT;
    }
    return res;
  }
 catch (  JAXBException ex) {
    throw new IllegalArgumentException(ex);
  }
}","/** 
 * Clone this JAXB object
 * @param value
 * @param jc
 * @return
 */
public static <T>T deepCopy(T value,JAXBContext jc){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  JAXBElement<T> elem;
  try {
    if (value instanceof JAXBElement<?>) {
      Object wrapped=((JAXBElement)value).getValue();
      @SuppressWarnings(""String_Node_Str"") Class clazz=wrapped.getClass();
      JAXBElement contentObject=new JAXBElement(new QName(clazz.getSimpleName()),clazz,wrapped);
      JAXBSource source=new JAXBSource(jc,contentObject);
      elem=jc.createUnmarshaller().unmarshal(source,clazz);
    }
 else {
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)value.getClass();
      JAXBElement<T> contentObject=new JAXBElement<T>(new QName(clazz.getSimpleName()),clazz,value);
      JAXBSource source=new JAXBSource(jc,contentObject);
      elem=jc.createUnmarshaller().unmarshal(source,clazz);
    }
    T res;
    if (value instanceof JAXBElement<?>) {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem;
      res=resT;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem.getValue();
      res=resT;
    }
    return res;
  }
 catch (  JAXBException ex) {
    throw new IllegalArgumentException(ex);
  }
}",0.6132468735525707
185069,"public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
    cachedXPathAPI.getXPathContext().setNamespaceContext(getNamespaceContext());
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath);
      if (xo.bool(cachedXPathAPI.getXPathContext())) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
    try {
      Node result=cachedXPathAPI.selectSingleNode(doc,xpath);
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath);
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}","public String cachedXPathGetString(String xpath,String prefixMappings) throws Docx4JException {
  if (cachedXPathAPI == null) {
    cachedXPathAPI=new CachedXPathAPI();
    cachedXPathAPI.getXPathContext().setNamespaceContext(getNamespaceContext());
  }
  if (cachedPrefixMappings == null && prefixMappings != null) {
    cachedPrefixMappings=prefixMappings;
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  if (prefixMappings != null && !prefixMappings.equals(cachedPrefixMappings)) {
    getNamespaceContext().registerPrefixMappings(prefixMappings);
  }
  try {
    if (xpath.contains(""String_Node_Str"") || xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath);
      if (xo.bool(cachedXPathAPI.getXPathContext())) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else     if (xpath.trim().startsWith(""String_Node_Str"")) {
      XObject xo=cachedXPathAPI.eval(doc,xpath);
      double d=xo.num(cachedXPathAPI.getXPathContext());
      return ""String_Node_Str"" + Math.round(d);
    }
    try {
      Node result=cachedXPathAPI.selectSingleNode(doc,xpath);
      return result.getTextContent();
    }
 catch (    org.apache.xpath.XPathException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath);
        if (xo.bool(cachedXPathAPI.getXPathContext())) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + xpath);
        XObject xo=cachedXPathAPI.eval(doc,xpath);
        double d=xo.num(cachedXPathAPI.getXPathContext());
        return ""String_Node_Str"" + d;
      }
 else {
        log.warn(""String_Node_Str"" + xpath);
        throw e;
      }
    }
  }
 catch (  TransformerException e) {
    throw new Docx4JException(""String_Node_Str"" + xpath,e);
  }
}",0.6824909243228149
185070,"@Override public void export(CS conversionSettings,OutputStream outputStream) throws Docx4JException {
  PK preprocessedPackage=null;
  ConversionSectionWrappers sectionWrappers=null;
  CC conversionContext=null;
  OutputStream intermediateOutputStream=null;
  long startTime=System.currentTimeMillis();
  long currentTime=startTime;
  Logger log=LocalLog;
  try {
    log.debug(""String_Node_Str"");
    preprocessedPackage=preprocess(conversionSettings);
    if (preprocessedPackage instanceof WordprocessingMLPackage) {
      log.debug(""String_Node_Str"" + ((WordprocessingMLPackage)preprocessedPackage).getMainDocumentPart().getXML());
    }
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    sectionWrappers=createWrappers(conversionSettings,preprocessedPackage);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    conversionContext=createContext(conversionSettings,preprocessedPackage,sectionWrappers);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    intermediateOutputStream=createIntermediateOutputStream(outputStream);
    process(conversionSettings,conversionContext,intermediateOutputStream);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    postprocess(conversionSettings,conversionContext,intermediateOutputStream,outputStream);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    if (conversionSettings.getWmlPackage() != preprocessedPackage) {
      if (preprocessedPackage instanceof WordprocessingMLPackage) {
        FontTablePart ftp=((WordprocessingMLPackage)preprocessedPackage).getMainDocumentPart().getFontTablePart();
        if (ftp != null) {
          ftp.deleteEmbeddedFontTempFiles();
        }
      }
    }
    logDebugStep(log,""String_Node_Str"",startTime);
  }
 catch (  IllegalArgumentException e) {
    if (e.getMessage().contains(""String_Node_Str"")) {
      throw new Docx4JException(""String_Node_Str"",e);
    }
 else {
      throw new Docx4JException(""String_Node_Str"",e);
    }
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new Docx4JException(""String_Node_Str"",e);
  }
 finally {
    try {
      outputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","@Override public void export(CS conversionSettings,OutputStream outputStream) throws Docx4JException {
  PK preprocessedPackage=null;
  ConversionSectionWrappers sectionWrappers=null;
  CC conversionContext=null;
  OutputStream intermediateOutputStream=null;
  long startTime=System.currentTimeMillis();
  long currentTime=startTime;
  Logger log=LocalLog;
  try {
    log.debug(""String_Node_Str"");
    preprocessedPackage=preprocess(conversionSettings);
    if (preprocessedPackage instanceof WordprocessingMLPackage) {
      log.debug(""String_Node_Str"" + ((WordprocessingMLPackage)preprocessedPackage).getMainDocumentPart().getXML());
    }
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    sectionWrappers=createWrappers(conversionSettings,preprocessedPackage);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    conversionContext=createContext(conversionSettings,preprocessedPackage,sectionWrappers);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    intermediateOutputStream=createIntermediateOutputStream(outputStream);
    process(conversionSettings,conversionContext,intermediateOutputStream);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    postprocess(conversionSettings,conversionContext,intermediateOutputStream,outputStream);
    currentTime=logDebugStep(log,""String_Node_Str"",currentTime);
    if (conversionSettings.getWmlPackage() != preprocessedPackage) {
      if (preprocessedPackage instanceof WordprocessingMLPackage) {
        FontTablePart ftp=((WordprocessingMLPackage)preprocessedPackage).getMainDocumentPart().getFontTablePart();
        if (ftp != null) {
          ftp.deleteEmbeddedFontTempFiles();
        }
      }
    }
    logDebugStep(log,""String_Node_Str"",startTime);
  }
 catch (  IllegalArgumentException e) {
    if (e.getMessage().contains(""String_Node_Str"")) {
      throw new Docx4JException(""String_Node_Str"",e);
    }
 else {
      throw new Docx4JException(""String_Node_Str"",e);
    }
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new Docx4JException(""String_Node_Str"",e);
  }
}",0.9723428571428572
185071,"/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  try {
    Marshaller marshaller=jc.createMarshaller();
    if (Docx4jProperties.getProperty(""String_Node_Str"",true)) {
      marshaller.setProperty(""String_Node_Str"",true);
    }
    NamespacePrefixMapperUtils.setProperty(marshaller,namespacePrefixMapper);
    log.debug(""String_Node_Str"" + this.getClass().getName());
    getContents();
    setMceIgnorable((McIgnorableNamespaceDeclarator)namespacePrefixMapper);
    if (false) {
      Document doc=XmlUtils.marshaltoW3CDomDocument(jaxbElement,jc);
      log.debug(""String_Node_Str"" + XmlUtils.w3CDomNodeToString(doc));
      Init.init();
      Canonicalizer c=Canonicalizer.getInstance(CanonicalizationMethod.EXCLUSIVE);
      byte[] bytes=c.canonicalizeSubtree(doc,this.getMceIgnorable());
      IOUtils.write(bytes,os);
    }
 else {
      marshaller.marshal(jaxbElement,os);
    }
  }
 catch (  Docx4JException e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
catch (  JAXBException e) {
    log.error(e.getMessage(),e);
    throw e;
  }
catch (  Exception e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
}","/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  try {
    Marshaller marshaller=jc.createMarshaller();
    if (Docx4jProperties.getProperty(""String_Node_Str"",true)) {
      marshaller.setProperty(""String_Node_Str"",true);
    }
    NamespacePrefixMapperUtils.setProperty(marshaller,namespacePrefixMapper);
    log.debug(""String_Node_Str"" + this.getClass().getName());
    getContents();
    setMceIgnorable((McIgnorableNamespaceDeclarator)namespacePrefixMapper);
    if (false) {
      Document doc=XmlUtils.marshaltoW3CDomDocument(jaxbElement,jc);
      log.debug(""String_Node_Str"" + XmlUtils.w3CDomNodeToString(doc));
      Init.init();
      Canonicalizer c=Canonicalizer.getInstance(CanonicalizationMethod.EXCLUSIVE);
      byte[] bytes=c.canonicalizeSubtree(doc,this.getMceIgnorable());
      IOUtils.write(bytes,os);
    }
 else {
      marshaller.marshal(jaxbElement,os);
    }
    ((McIgnorableNamespaceDeclarator)namespacePrefixMapper).setMcIgnorable(null);
  }
 catch (  Docx4JException e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
catch (  JAXBException e) {
    log.error(e.getMessage(),e);
    throw e;
  }
catch (  Exception e) {
    log.error(e.getMessage(),e);
    throw new JAXBException(e);
  }
}",0.9731147540983608
185072,"public static String getPreferredPrefix(String namespaceUri){
  return NamespacePrefixMappings.getPreferredPrefixStatic(namespaceUri,null,false);
}","/** 
 * Returns a preferred prefix for the given namespace URI. This method is intended to be overrided by a derived class.
 * @param namespaceUri The namespace URI for which the prefix needs to be found. Never be null. """" is used to denote the default namespace.
 * @param suggestion When the content tree has a suggestion for the prefix to the given namespaceUri, that suggestion is passed as a parameter. Typically this value comes from QName.getPrefix() to show the preference of the content tree. This parameter may be null, and this parameter may represent an already occupied prefix. 
 * @param requirePrefix If this method is expected to return non-empty prefix. When this flag is true, it means that the given namespace URI cannot be set as the default namespace.
 * @return null if there's no preferred prefix for the namespace URI. In this case, the system will generate a prefix for you. Otherwise the system will try to use the returned prefix, but generally there's no guarantee if the prefix will be actually used or not. return """" to map this namespace URI to the default namespace. Again, there's no guarantee that this preference will be honored. If this method returns """" when requirePrefix=true, the return value will be ignored and the system will generate one.
 */
public String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){
  return NamespacePrefixMappings.getPreferredPrefixStatic(namespaceUri,suggestion,requirePrefix);
}",0.1572481572481572
185073,"/** 
 * Inject the calculated heights for each header and footer, and adjust the region body margins to fit them.
 * @param layoutMasterSet
 * @param headerBpda
 * @param footerBpda
 */
static void adjustLayoutMasterSet(LayoutMasterSet layoutMasterSet,ConversionSectionWrappers conversionSectionWrappers,Map<String,Integer> headerBpda,Map<String,Integer> footerBpda){
  List<ConversionSectionWrapper> sections=conversionSectionWrappers.getList();
  ConversionSectionWrapper section=null;
  for (  Object o : layoutMasterSet.getSimplePageMasterOrPageSequenceMaster()) {
    if (o instanceof SimplePageMaster) {
      SimplePageMaster spm=((SimplePageMaster)o);
      String simplePageMasterName=spm.getMasterName();
      int index=-1 + Integer.parseInt(simplePageMasterName.substring(1,simplePageMasterName.indexOf(""String_Node_Str"")));
      PageDimensions page=null;
      if (sections.get(index) == null) {
        log.error(""String_Node_Str"" + index + ""String_Node_Str""+ simplePageMasterName);
      }
 else {
        page=sections.get(index).getPageDimensions();
      }
      if (spm.getRegionBefore() != null) {
        Integer hBpdaMilliPts=headerBpda.get(simplePageMasterName);
        if (hBpdaMilliPts == null) {
          log.error(""String_Node_Str"" + simplePageMasterName);
        }
 else {
          float hBpdaPts=hBpdaMilliPts / 1000;
          spm.getRegionBefore().setExtent(hBpdaPts + ""String_Node_Str"");
          spm.getRegionBody().setMarginTop(hBpdaPts + ""String_Node_Str"");
          float totalHeight=(page.getHeaderMargin() / 20) + hBpdaPts;
          float extraMargin=(page.getPgMar().getTop().intValue() / 20) - totalHeight;
          if (extraMargin > 0) {
            float required=(page.getPgMar().getTop().intValue() - page.getHeaderMargin()) / 20;
            spm.getRegionBody().setMarginTop(required + ""String_Node_Str"");
          }
        }
      }
      if (spm.getRegionAfter() != null) {
        Integer fBpdaMilliPts=footerBpda.get(simplePageMasterName);
        if (fBpdaMilliPts == null) {
          log.error(""String_Node_Str"" + simplePageMasterName);
        }
 else {
          float fBpdaPts=fBpdaMilliPts / 1000;
          spm.getRegionAfter().setExtent(fBpdaPts + ""String_Node_Str"");
          spm.getRegionBody().setMarginBottom(fBpdaPts + ""String_Node_Str"");
          float totalHeight=(page.getFooterMargin() / 20) + fBpdaPts;
          float extraMargin=(page.getPgMar().getBottom().intValue() / 20) - totalHeight;
          if (extraMargin > 0) {
            float required=(page.getPgMar().getBottom().intValue() - page.getFooterMargin()) / 20;
            spm.getRegionBody().setMarginBottom(extraMargin + ""String_Node_Str"");
          }
        }
      }
    }
  }
}","/** 
 * Inject the calculated heights for each header and footer, and adjust the region body margins to fit them.
 * @param layoutMasterSet
 * @param headerBpda
 * @param footerBpda
 */
static void adjustLayoutMasterSet(LayoutMasterSet layoutMasterSet,ConversionSectionWrappers conversionSectionWrappers,Map<String,Integer> headerBpda,Map<String,Integer> footerBpda){
  List<ConversionSectionWrapper> sections=conversionSectionWrappers.getList();
  ConversionSectionWrapper section=null;
  for (  Object o : layoutMasterSet.getSimplePageMasterOrPageSequenceMaster()) {
    if (o instanceof SimplePageMaster) {
      SimplePageMaster spm=((SimplePageMaster)o);
      String simplePageMasterName=spm.getMasterName();
      int index=-1 + Integer.parseInt(simplePageMasterName.substring(1,simplePageMasterName.indexOf(""String_Node_Str"")));
      PageDimensions page=null;
      if (sections.get(index) == null) {
        log.error(""String_Node_Str"" + index + ""String_Node_Str""+ simplePageMasterName);
      }
 else {
        page=sections.get(index).getPageDimensions();
      }
      if (spm.getRegionBefore() != null) {
        Integer hBpdaMilliPts=headerBpda.get(simplePageMasterName);
        if (hBpdaMilliPts == null) {
          log.error(""String_Node_Str"" + simplePageMasterName);
        }
 else {
          float hBpdaPts=hBpdaMilliPts / 1000;
          spm.getRegionBefore().setExtent(hBpdaPts + ""String_Node_Str"");
          spm.getRegionBody().setMarginTop(hBpdaPts + ""String_Node_Str"");
          float totalHeight=(page.getHeaderMargin() / 20) + hBpdaPts;
          float extraMargin=(page.getPgMar().getTop().intValue() / 20) - totalHeight;
          if (extraMargin > 0) {
            float required=(page.getPgMar().getTop().intValue() - page.getHeaderMargin()) / 20;
            spm.getRegionBody().setMarginTop(required + ""String_Node_Str"");
          }
        }
      }
      if (spm.getRegionAfter() != null) {
        Integer fBpdaMilliPts=footerBpda.get(simplePageMasterName);
        if (fBpdaMilliPts == null) {
          log.error(""String_Node_Str"" + simplePageMasterName);
        }
 else {
          float fBpdaPts=fBpdaMilliPts / 1000;
          spm.getRegionAfter().setExtent(fBpdaPts + ""String_Node_Str"");
          spm.getRegionBody().setMarginBottom(fBpdaPts + ""String_Node_Str"");
          float totalHeight=(page.getFooterMargin() / 20) + fBpdaPts;
          float extraMargin=(page.getPgMar().getBottom().intValue() / 20) - totalHeight;
          if (extraMargin > 0) {
            float required=(page.getPgMar().getBottom().intValue() - page.getFooterMargin()) / 20;
            spm.getRegionBody().setMarginBottom(required + ""String_Node_Str"");
          }
        }
      }
    }
  }
}",0.9965156794425089
185074,"/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
@Override public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  String xmlString=this.getXML();
  int pos=xmlString.indexOf(""String_Node_Str"");
  xmlString=xmlString.substring(0,pos + 5) + ""String_Node_Str"" + xmlString.substring(pos + 5);
  try {
    IOUtils.write(xmlString,os);
  }
 catch (  IOException e) {
    throw new JAXBException(e.getMessage(),e);
  }
}","/** 
 * Marshal the content tree rooted at <tt>jaxbElement</tt> into an output stream
 * @param os XML will be added to this stream.
 * @param namespacePrefixMapper namespacePrefixMapper
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 */
@Override public void marshal(java.io.OutputStream os,Object namespacePrefixMapper) throws JAXBException {
  String xmlString=XmlUtils.marshaltoString(getJaxbElement(),false,true,jc);
  int pos=xmlString.indexOf(""String_Node_Str"");
  xmlString=xmlString.substring(0,pos + 5) + ""String_Node_Str"" + xmlString.substring(pos + 5);
  try {
    IOUtils.write(xmlString,os,""String_Node_Str"");
  }
 catch (  IOException e) {
    throw new JAXBException(e.getMessage(),e);
  }
}",0.9416725228390724
185075,"private void processDescendantBindings(Object sdt,String xpathBase,int index){
  SdtPr sdtPr=getSdtPr(sdt);
  sdtPr.setId();
  CTDataBinding binding=(CTDataBinding)XmlUtils.unwrap(sdtPr.getDataBinding());
  String thisXPath=null;
  String conditionId=null;
  String repeatId=null;
  String bindingId=null;
  org.opendope.xpaths.Xpaths.Xpath xpathObj=null;
  Tag tag=sdtPr.getTag();
  if (tag == null)   return;
  HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
  if (binding == null) {
    conditionId=map.get(BINDING_ROLE_CONDITIONAL);
    repeatId=map.get(BINDING_ROLE_REPEAT);
    if (conditionId != null) {
      processDescendantCondition(sdt,xpathBase,index,tag);
      return;
    }
 else     if (repeatId != null) {
      xpathObj=XPathsPart.getXPathById(xPaths,repeatId);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else     if (map.containsKey(BINDING_CONTENTTYPE)) {
      xpathObj=XPathsPart.getXPathById(xPaths,map.get(BINDING_ROLE_XPATH));
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else {
      log.warn(""String_Node_Str"");
      return;
    }
  }
 else {
    thisXPath=binding.getXpath();
    bindingId=map.get(BINDING_ROLE_XPATH);
    xpathObj=XPathsPart.getXPathById(xPaths,bindingId);
    if (!thisXPath.equals(xpathObj.getDataBinding().getXpath())) {
      log.error(""String_Node_Str"" + bindingId + ""String_Node_Str""+ thisXPath+ ""String_Node_Str""+ xpathObj.getDataBinding().getXpath());
    }
  }
  final String newPath=enhanceXPath(xpathBase,index + 1,thisXPath);
  if (log.isDebugEnabled() && !thisXPath.equals(newPath)) {
    log.debug(""String_Node_Str"" + thisXPath + ""String_Node_Str""+ newPath);
  }
  if (binding == null) {
    if (repeatId != null) {
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_REPEAT,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
 else     if (map.containsKey(BINDING_CONTENTTYPE)) {
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
  }
 else {
    binding.setXpath(newPath);
    org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
    map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
    tag.setVal(QueryString.create(map));
  }
}","private void processDescendantBindings(Object sdt,String xpathBase,int index){
  SdtPr sdtPr=getSdtPr(sdt);
  sdtPr.setId();
  CTDataBinding binding=(CTDataBinding)XmlUtils.unwrap(sdtPr.getDataBinding());
  String thisXPath=null;
  String conditionId=null;
  String repeatId=null;
  String bindingId=null;
  org.opendope.xpaths.Xpaths.Xpath xpathObj=null;
  Tag tag=sdtPr.getTag();
  if (tag == null)   return;
  HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
  if (binding == null) {
    conditionId=map.get(BINDING_ROLE_CONDITIONAL);
    repeatId=map.get(BINDING_ROLE_REPEAT);
    if (conditionId != null) {
      processDescendantCondition(sdt,xpathBase,index,tag);
      return;
    }
 else     if (repeatId != null) {
      xpathObj=XPathsPart.getXPathById(xPaths,repeatId);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else     if (map.containsKey(BINDING_CONTENTTYPE) || map.containsKey(BINDING_HANDLER) || map.containsKey(BINDING_PROGID)) {
      xpathObj=XPathsPart.getXPathById(xPaths,map.get(BINDING_ROLE_XPATH));
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else {
      log.warn(""String_Node_Str"");
      return;
    }
  }
 else {
    thisXPath=binding.getXpath();
    bindingId=map.get(BINDING_ROLE_XPATH);
    xpathObj=XPathsPart.getXPathById(xPaths,bindingId);
    if (!thisXPath.equals(xpathObj.getDataBinding().getXpath())) {
      log.error(""String_Node_Str"" + bindingId + ""String_Node_Str""+ thisXPath+ ""String_Node_Str""+ xpathObj.getDataBinding().getXpath());
    }
  }
  final String newPath=enhanceXPath(xpathBase,index + 1,thisXPath);
  if (log.isDebugEnabled() && !thisXPath.equals(newPath)) {
    log.debug(""String_Node_Str"" + thisXPath + ""String_Node_Str""+ newPath);
  }
  if (binding == null) {
    if (repeatId != null) {
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_REPEAT,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
 else     if (map.containsKey(BINDING_CONTENTTYPE) || map.containsKey(BINDING_HANDLER) || map.containsKey(BINDING_PROGID)) {
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
  }
 else {
    binding.setXpath(newPath);
    org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
    map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
    tag.setVal(QueryString.create(map));
  }
}",0.9716566866267464
185076,"public Element createElement(Document document){
  Element el=null;
  if (outputType == RunFontActionType.DISCOVERY) {
    return null;
  }
 else   if (outputType == RunFontActionType.XHTML) {
    el=document.createElement(""String_Node_Str"");
  }
 else   if (outputType == RunFontActionType.XSL_FO) {
    el=document.createElementNS(""String_Node_Str"",""String_Node_Str"");
  }
  document.appendChild(el);
  return el;
}","public Element createElement(Document document){
  Element el=null;
  if (outputType == RunFontActionType.DISCOVERY) {
    return null;
  }
 else   if (outputType == RunFontActionType.XHTML) {
    el=document.createElement(""String_Node_Str"");
  }
 else   if (outputType == RunFontActionType.XSL_FO) {
    el=document.createElementNS(""String_Node_Str"",""String_Node_Str"");
  }
  return el;
}",0.9652605459057072
185077,"public Object fontSelector(PPr pPr,RPr rPr,Text wmlText){
  String text=wmlText.getValue();
  spacePreserve=(wmlText.getSpace() != null) && (wmlText.getSpace().equals(""String_Node_Str""));
  PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
  Style pStyle=null;
  RPr pRPr=null;
  if (pPr == null || pPr.getPStyle() == null) {
    pStyle=getDefaultPStyle();
    log.debug(""String_Node_Str"");
    pRPr=pStyle.getRPr();
  }
 else   if (wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false) != null) {
    log.debug(pPr.getPStyle().getVal());
    pRPr=propertyResolver.getEffectiveRPr(pPr.getPStyle().getVal());
  }
  rPr=propertyResolver.getEffectiveRPrUsingPStyleRPr(rPr,pRPr);
  log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(rPr,true,true));
  Document document=getDocument();
  if (rPr == null) {
    log.warn(""String_Node_Str"");
    return nullRPr(document,text);
  }
  RFonts rFonts=rPr.getRFonts();
  if (rFonts == null) {
    return nullRPr(document,text);
  }
  if (rPr.getCs() != null || rPr.getRtl() != null) {
    if (rFonts.getCstheme() != null) {
      String fontName=null;
      if (getThemePart() != null) {
        fontName=getThemePart().getFont(rFonts.getCstheme(),themeFontLang);
      }
      if (fontName == null) {
        fontName=rFonts.getCs();
      }
      if (fontName == null) {
      }
      Element span=createElement(document);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else     if (rFonts.getCs() != null) {
      String fontName=rFonts.getCs();
      Element span=createElement(document);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else {
    }
  }
  String eastAsia=null;
  String ascii=null;
  String hAnsi=null;
  STHint hint=rFonts.getHint();
  if (rFonts.getEastAsiaTheme() != null && getThemePart() != null) {
    eastAsia=getThemePart().getFont(rFonts.getEastAsiaTheme(),themeFontLang);
    if (eastAsia == null) {
      log.info(""String_Node_Str"" + themeFontLang + ""String_Node_Str""+ eastAsia+ ""String_Node_Str"");
      eastAsia=rFonts.getEastAsia();
    }
  }
 else {
    eastAsia=rFonts.getEastAsia();
  }
  if (rFonts.getAsciiTheme() != null && getThemePart() != null) {
    ascii=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
  }
 else {
    ascii=rFonts.getAscii();
  }
  if (rFonts.getHAnsiTheme() != null && getThemePart() != null) {
    hAnsi=getThemePart().getFont(rFonts.getHAnsiTheme(),themeFontLang);
  }
 else {
    hAnsi=rFonts.getHAnsi();
  }
  if ((""String_Node_Str"").equals(eastAsia)) {
    if (ascii != null && ascii.equals(hAnsi)) {
      Element span=createElement(document);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(ascii);
        return null;
      }
      this.setAttribute(span,ascii);
      span.setTextContent(text);
      return result(document);
    }
  }
  if (ascii == null) {
    log.warn(""String_Node_Str"");
    ascii=this.getDefaultFont();
  }
  String langEastAsia=null;
  if (rPr.getLang() != null) {
    langEastAsia=rPr.getLang().getEastAsia();
  }
  vis.setDocument(document);
  return unicodeRangeToFont(text,hint,langEastAsia,eastAsia,ascii,hAnsi);
}","public Object fontSelector(PPr pPr,RPr rPr,Text wmlText){
  String text=wmlText.getValue();
  spacePreserve=(wmlText.getSpace() != null) && (wmlText.getSpace().equals(""String_Node_Str""));
  PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
  Style pStyle=null;
  RPr pRPr=null;
  if (pPr == null || pPr.getPStyle() == null) {
    pStyle=getDefaultPStyle();
    log.debug(""String_Node_Str"");
    pRPr=pStyle.getRPr();
  }
 else   if (wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false) != null) {
    log.debug(pPr.getPStyle().getVal());
    pRPr=propertyResolver.getEffectiveRPr(pPr.getPStyle().getVal());
  }
  rPr=propertyResolver.getEffectiveRPrUsingPStyleRPr(rPr,pRPr);
  log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(rPr,true,true));
  Document document=getDocument();
  if (rPr == null) {
    log.warn(""String_Node_Str"");
    return nullRPr(document,text);
  }
  RFonts rFonts=rPr.getRFonts();
  if (rFonts == null) {
    return nullRPr(document,text);
  }
  if (rPr.getCs() != null || rPr.getRtl() != null) {
    if (rFonts.getCstheme() != null) {
      String fontName=null;
      if (getThemePart() != null) {
        fontName=getThemePart().getFont(rFonts.getCstheme(),themeFontLang);
      }
      if (fontName == null) {
        fontName=rFonts.getCs();
      }
      if (fontName == null) {
      }
      Element span=createElement(document);
      document.appendChild(span);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else     if (rFonts.getCs() != null) {
      String fontName=rFonts.getCs();
      Element span=createElement(document);
      document.appendChild(span);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else {
    }
  }
  String eastAsia=null;
  String ascii=null;
  String hAnsi=null;
  STHint hint=rFonts.getHint();
  if (rFonts.getEastAsiaTheme() != null && getThemePart() != null) {
    eastAsia=getThemePart().getFont(rFonts.getEastAsiaTheme(),themeFontLang);
    if (eastAsia == null) {
      log.info(""String_Node_Str"" + themeFontLang + ""String_Node_Str""+ eastAsia+ ""String_Node_Str"");
      eastAsia=rFonts.getEastAsia();
    }
  }
 else {
    eastAsia=rFonts.getEastAsia();
  }
  if (rFonts.getAsciiTheme() != null && getThemePart() != null) {
    ascii=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
  }
 else {
    ascii=rFonts.getAscii();
  }
  if (rFonts.getHAnsiTheme() != null && getThemePart() != null) {
    hAnsi=getThemePart().getFont(rFonts.getHAnsiTheme(),themeFontLang);
  }
 else {
    hAnsi=rFonts.getHAnsi();
  }
  if ((""String_Node_Str"").equals(eastAsia)) {
    if (ascii != null && ascii.equals(hAnsi)) {
      Element span=createElement(document);
      document.appendChild(span);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(ascii);
        return null;
      }
      this.setAttribute(span,ascii);
      span.setTextContent(text);
      return result(document);
    }
  }
  if (ascii == null) {
    log.warn(""String_Node_Str"");
    ascii=this.getDefaultFont();
  }
  String langEastAsia=null;
  if (rPr.getLang() != null) {
    langEastAsia=rPr.getLang().getEastAsia();
  }
  vis.setDocument(document);
  return unicodeRangeToFont(text,hint,langEastAsia,eastAsia,ascii,hAnsi);
}",0.9855564995751912
185078,"private DocumentFragment nullRPr(Document document,String text){
  if (outputType == RunFontActionType.DISCOVERY) {
    vis.fontAction(getDefaultFont());
    return null;
  }
  Element span=createElement(document);
  this.setAttribute(span,getDefaultFont());
  span.setTextContent(text);
  return result(document);
}","private DocumentFragment nullRPr(Document document,String text){
  if (outputType == RunFontActionType.DISCOVERY) {
    vis.fontAction(getDefaultFont());
    return null;
  }
  Element span=createElement(document);
  document.appendChild(span);
  this.setAttribute(span,getDefaultFont());
  span.setTextContent(text);
  return result(document);
}",0.9546827794561934
185079,"@Override protected Document getSourceDocument(AbstractConversionSettings conversionSettings,AbstractWmlConversionContext conversionContext) throws Docx4JException {
  ConversionSectionWrappers conversionSectionWrappers=conversionContext.getSections();
  Document ret=XmlUtils.marshaltoW3CDomDocument(conversionSectionWrappers.createSections(),Context.jcSectionModel);
  return ret;
}","@Override protected Document getSourceDocument(CS conversionSettings,CC conversionContext) throws Docx4JException {
  ConversionSectionWrappers conversionSectionWrappers=conversionContext.getSections();
  Document ret=XmlUtils.marshaltoW3CDomDocument(conversionSectionWrappers.createSections(),Context.jcSectionModel);
  return ret;
}",0.913649025069638
185080,"public Object fontSelector(PPr pPr,RPr rPr,String text){
  Style pStyle=null;
  if (pPr == null || pPr.getPStyle() == null) {
    pStyle=getDefaultPStyle();
  }
 else   if (wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false) != null) {
    pStyle=wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false).getStyleById(pPr.getPStyle().getVal());
  }
  PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
  rPr=propertyResolver.getEffectiveRPrUsingPStyleRPr(rPr,pStyle.getRPr());
  Document document=getDocument();
  if (rPr == null) {
    log.warn(""String_Node_Str"");
    return nullRPr(document,text);
  }
  System.out.println(XmlUtils.marshaltoString(rPr,true,true));
  RFonts rFonts=rPr.getRFonts();
  if (rFonts == null) {
    return nullRPr(document,text);
  }
  if (rPr.getCs() != null || rPr.getRtl() != null) {
    if (rFonts.getCstheme() != null) {
      String fontName=null;
      if (getThemePart() != null) {
        fontName=getThemePart().getFont(rFonts.getCstheme(),themeFontLang);
      }
      if (fontName == null) {
        fontName=rFonts.getCs();
      }
      if (fontName == null) {
      }
      Element span=createElement(document);
      this.setAttribute(span,getCssProperty(fontName));
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else     if (rFonts.getCs() != null) {
      String fontName=rFonts.getCs();
      Element span=createElement(document);
      this.setAttribute(span,getCssProperty(fontName));
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else {
    }
  }
  String eastAsia=null;
  String ascii=null;
  String hAnsi=null;
  STHint hint=rFonts.getHint();
  if (rFonts.getEastAsiaTheme() != null && getThemePart() != null) {
    eastAsia=getThemePart().getFont(rFonts.getEastAsiaTheme(),themeFontLang);
  }
 else {
    eastAsia=rFonts.getEastAsia();
  }
  if (rFonts.getAsciiTheme() != null && getThemePart() != null) {
    ascii=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
  }
 else {
    ascii=rFonts.getAscii();
  }
  if (rFonts.getHAnsiTheme() != null && getThemePart() != null) {
    hAnsi=getThemePart().getFont(rFonts.getHAnsiTheme(),themeFontLang);
  }
 else {
    hAnsi=rFonts.getHAnsi();
  }
  if ((""String_Node_Str"").equals(eastAsia)) {
    if (ascii != null && ascii.equals(hAnsi)) {
      Element span=createElement(document);
      this.setAttribute(span,getCssProperty(ascii));
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(ascii);
      }
      return result(document);
    }
  }
  String langEastAsia=null;
  if (rPr.getLang() != null) {
    langEastAsia=rPr.getLang().getEastAsia();
  }
  vis.setDocument(document);
  return unicodeRangeToFont(text,hint,langEastAsia,eastAsia,ascii,hAnsi);
}","public Object fontSelector(PPr pPr,RPr rPr,String text){
  Style pStyle=null;
  if (pPr == null || pPr.getPStyle() == null) {
    pStyle=getDefaultPStyle();
  }
 else   if (wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false) != null) {
    pStyle=wordMLPackage.getMainDocumentPart().getStyleDefinitionsPart(false).getStyleById(pPr.getPStyle().getVal());
  }
  PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
  rPr=propertyResolver.getEffectiveRPrUsingPStyleRPr(rPr,pStyle.getRPr());
  Document document=getDocument();
  if (rPr == null) {
    log.warn(""String_Node_Str"");
    return nullRPr(document,text);
  }
  RFonts rFonts=rPr.getRFonts();
  if (rFonts == null) {
    return nullRPr(document,text);
  }
  if (rPr.getCs() != null || rPr.getRtl() != null) {
    if (rFonts.getCstheme() != null) {
      String fontName=null;
      if (getThemePart() != null) {
        fontName=getThemePart().getFont(rFonts.getCstheme(),themeFontLang);
      }
      if (fontName == null) {
        fontName=rFonts.getCs();
      }
      if (fontName == null) {
      }
      Element span=createElement(document);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else     if (rFonts.getCs() != null) {
      String fontName=rFonts.getCs();
      Element span=createElement(document);
      this.setAttribute(span,fontName);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(fontName);
      }
      return result(document);
    }
 else {
    }
  }
  String eastAsia=null;
  String ascii=null;
  String hAnsi=null;
  STHint hint=rFonts.getHint();
  if (rFonts.getEastAsiaTheme() != null && getThemePart() != null) {
    eastAsia=getThemePart().getFont(rFonts.getEastAsiaTheme(),themeFontLang);
  }
 else {
    eastAsia=rFonts.getEastAsia();
  }
  if (rFonts.getAsciiTheme() != null && getThemePart() != null) {
    ascii=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
  }
 else {
    ascii=rFonts.getAscii();
  }
  if (rFonts.getHAnsiTheme() != null && getThemePart() != null) {
    hAnsi=getThemePart().getFont(rFonts.getHAnsiTheme(),themeFontLang);
  }
 else {
    hAnsi=rFonts.getHAnsi();
  }
  if ((""String_Node_Str"").equals(eastAsia)) {
    if (ascii != null && ascii.equals(hAnsi)) {
      Element span=createElement(document);
      this.setAttribute(span,ascii);
      span.setTextContent(text);
      if (outputType == RunFontActionType.DISCOVERY) {
        vis.fontAction(ascii);
      }
      return result(document);
    }
  }
  if (ascii == null) {
    log.warn(""String_Node_Str"");
    ascii=this.getDefaultFont();
  }
  String langEastAsia=null;
  if (rPr.getLang() != null) {
    langEastAsia=rPr.getLang().getEastAsia();
  }
  vis.setDocument(document);
  return unicodeRangeToFont(text,hint,langEastAsia,eastAsia,ascii,hAnsi);
}",0.9647330257086356
185081,"private String getDefaultFont(){
  if (defaultFont == null) {
    PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
    org.docx4j.wml.RFonts rFonts=propertyResolver.getDocumentDefaultRPr().getRFonts();
    if (rFonts == null) {
      log.info(""String_Node_Str"");
      defaultFont=""String_Node_Str"";
    }
 else {
      if (rFonts.getAsciiTheme() == null) {
        if (rFonts.getAscii() == null) {
          log.error(""String_Node_Str"");
          defaultFont=""String_Node_Str"";
        }
 else {
          log.info(""String_Node_Str"" + rFonts.getAscii());
          defaultFont=rFonts.getAscii();
        }
      }
 else {
        if (getThemePart() == null) {
          log.info(""String_Node_Str"");
          defaultFont=""String_Node_Str"";
        }
 else {
          String font=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
          if (font != null) {
            defaultFont=font;
          }
 else {
            log.info(""String_Node_Str"");
            defaultFont=""String_Node_Str"";
          }
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + defaultFont);
  return defaultFont;
}","private String getDefaultFont(){
  if (defaultFont == null) {
    PropertyResolver propertyResolver=wordMLPackage.getMainDocumentPart().getPropertyResolver();
    org.docx4j.wml.RFonts rFonts=propertyResolver.getDocumentDefaultRPr().getRFonts();
    if (rFonts == null) {
      log.info(""String_Node_Str"");
      defaultFont=""String_Node_Str"";
    }
 else {
      if (rFonts.getAsciiTheme() == null) {
        if (rFonts.getAscii() == null) {
          log.error(""String_Node_Str"");
          defaultFont=""String_Node_Str"";
        }
 else {
          log.info(""String_Node_Str"" + rFonts.getAscii());
          defaultFont=rFonts.getAscii();
        }
      }
 else {
        if (getThemePart() == null) {
          log.info(""String_Node_Str"");
          defaultFont=""String_Node_Str"";
        }
 else {
          String font=getThemePart().getFont(rFonts.getAsciiTheme(),themeFontLang);
          if (font != null) {
            defaultFont=font;
          }
 else {
            log.info(""String_Node_Str"");
            defaultFont=""String_Node_Str"";
          }
        }
      }
    }
  }
  return defaultFont;
}",0.975929978118162
185082,"private void handleContent(List<Object> objects,ContentAccessor attachmentPoint){
  for (  Object o : objects) {
    if (o instanceof R) {
      R existingRun=(R)o;
      handleRun(existingRun,attachmentPoint);
    }
 else     if (o instanceof ProofErr) {
    }
 else {
      log.debug(XmlUtils.unwrap(o));
      if (newR.getContent().size() > 0) {
        attachmentPoint.getContent().add(newR);
        newR=Context.getWmlObjectFactory().createR();
      }
      attachmentPoint.getContent().add(o);
    }
  }
}","private void handleContent(List<Object> objects,ContentAccessor attachmentPoint){
  for (  Object o : objects) {
    if (o instanceof R) {
      R existingRun=(R)o;
      handleRun(existingRun,attachmentPoint);
    }
 else     if (o instanceof ProofErr) {
    }
 else {
      log.debug(XmlUtils.unwrap(o));
      attachmentPoint.getContent().add(o);
      newR=Context.getWmlObjectFactory().createR();
    }
  }
}",0.8898488120950324
185083,"/** 
 * nested tables XHTML renderer seems to construct a tree: table/table instead of table/tr/td/table? TODO fix this upstream. TestCase is http://en.wikipedia.org/wiki/Office_Open_XML
 * @param contentContext
 * @param parent
 * @return
 */
private List<Object> nestedTableHierarchyFix(List<Object> contentContext,Box parent){
  if (parent instanceof TableBox || parent.getElement().getNodeName().equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"");
    Tr tr=Context.getWmlObjectFactory().createTr();
    contentContext.add(tr);
    contentContext=tr.getContent();
    Tc tc=Context.getWmlObjectFactory().createTc();
    contentContext.add(tc);
    contentContext=tc.getContent();
  }
  return contentContext;
}","/** 
 * nested tables XHTML renderer seems to construct a tree: table/table instead of table/tr/td/table? TODO fix this upstream. TestCase is http://en.wikipedia.org/wiki/Office_Open_XML
 * @param contentContext
 * @param parent
 * @return
 */
private List<Object> nestedTableHierarchyFix(List<Object> contentContext,Box parent){
  if (parent instanceof TableBox || parent.getElement().getNodeName().equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"");
    P captionP=null;
    Iterator<Object> contentIterator=contentContext.iterator();
    Object next;
    while (contentIterator.hasNext()) {
      next=contentIterator.next();
      if (next instanceof P) {
        captionP=(P)XmlUtils.deepCopy((P)next);
        contentIterator.remove();
        break;
      }
    }
    TblPr tblPr=Context.getWmlObjectFactory().createTblPr();
    TblStyle tblStyle=Context.getWmlObjectFactory().createCTTblPrBaseTblStyle();
    tblStyle.setVal(""String_Node_Str"");
    tblPr.setTblStyle(tblStyle);
    contentContext.add(tblPr);
    Tr tr=Context.getWmlObjectFactory().createTr();
    contentContext.add(tr);
    contentContext=tr.getContent();
    Tc tc=Context.getWmlObjectFactory().createTc();
    contentContext.add(tc);
    contentContext=tc.getContent();
    if (captionP != null) {
      contentContext.add(captionP);
    }
  }
  return contentContext;
}",0.5540086413826212
185084,"private void handleRun(R existingRun,ContentAccessor newAttachPoint){
  for (  Object o2 : existingRun.getContent()) {
    if (isCharType(o2,STFldCharType.BEGIN)) {
      seenSeparate=false;
      depth++;
      if (depth == 1) {
        newR=Context.getWmlObjectFactory().createR();
        newR.getContent().add(o2);
        currentField=new FieldRef();
        fieldRefs.add(currentField);
        currentField.setParent(newAttachPoint);
        currentField.setBeginRun(newR);
      }
    }
 else     if (isCharType(o2,STFldCharType.END)) {
      if (!seenSeparate) {
        R separateR=Context.getWmlObjectFactory().createR();
        FldChar fldChar=Context.getWmlObjectFactory().createFldChar();
        fldChar.setFldCharType(STFldCharType.SEPARATE);
        newR.getContent().add(fldChar);
        newAttachPoint.getContent().add(separateR);
        newR=Context.getWmlObjectFactory().createR();
        currentField.setResultsSlot(newR);
      }
      depth--;
      if (depth == 0) {
        newAttachPoint.getContent().add(newR);
        newR=Context.getWmlObjectFactory().createR();
        newR.getContent().add(o2);
        newAttachPoint.getContent().add(newR);
        currentField.setEndRun(newR);
        newR=Context.getWmlObjectFactory().createR();
      }
 else {
        newR.getContent().add(o2);
      }
    }
 else     if (isCharType(o2,STFldCharType.SEPARATE)) {
      seenSeparate=true;
      newR.getContent().add(o2);
      if (depth == 1) {
        newAttachPoint.getContent().add(newR);
        newR=Context.getWmlObjectFactory().createR();
        newR.setRPr(fieldRPr);
        currentField.setResultsSlot(newR);
      }
    }
 else     if (o2 instanceof JAXBElement && ((JAXBElement)o2).getName().equals(_RInstrText_QNAME)) {
      currentField.setInstrText((JAXBElement<Text>)o2);
      newR.getContent().add(o2);
      fieldRPr=existingRun.getRPr();
      newR.setRPr(fieldRPr);
    }
 else     if (depth == 1 && seenSeparate) {
      System.out.println(""String_Node_Str"" + XmlUtils.marshaltoString(o2,true,true));
    }
 else {
      newR.getContent().add(o2);
      newR.setRPr(existingRun.getRPr());
      newAttachPoint.getContent().add(newR);
      newR=Context.getWmlObjectFactory().createR();
    }
  }
}","private void handleRun(R existingRun,ContentAccessor newAttachPoint){
  log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(existingRun,true,true));
  for (  Object o2 : existingRun.getContent()) {
    if (isCharType(o2,STFldCharType.BEGIN)) {
      seenSeparate=false;
      depth++;
      System.out.println(""String_Node_Str"" + depth);
      if (depth == 1) {
        newR=Context.getWmlObjectFactory().createR();
        newR.setRPr(existingRun.getRPr());
        newR.getContent().add(o2);
        currentField=new FieldRef();
        fieldRefs.add(currentField);
        currentField.setParent(newAttachPoint);
        currentField.setBeginRun(newR);
      }
    }
 else     if (isCharType(o2,STFldCharType.SEPARATE)) {
      seenSeparate=true;
      newR.getContent().add(o2);
      if (depth == 1) {
        newAttachPoint.getContent().add(newR);
        log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(newR,true,true));
        newR.setRPr(existingRun.getRPr());
        newR=Context.getWmlObjectFactory().createR();
        newR.setRPr(existingRun.getRPr());
        currentField.setResultsSlot(newR);
      }
    }
 else     if (isCharType(o2,STFldCharType.END)) {
      log.debug(""String_Node_Str"");
      if (!seenSeparate) {
        log.debug(""String_Node_Str"");
        FldChar fldChar=Context.getWmlObjectFactory().createFldChar();
        fldChar.setFldCharType(STFldCharType.SEPARATE);
        newR.getContent().add(fldChar);
        newAttachPoint.getContent().add(newR);
        log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(newR,true,true));
        newR=Context.getWmlObjectFactory().createR();
        newR.setRPr(existingRun.getRPr());
        currentField.setResultsSlot(newR);
      }
      depth--;
      if (depth == 0) {
        newAttachPoint.getContent().add(newR);
        newR.getContent().add(o2);
        log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(newR,true,true));
        currentField.setEndRun(newR);
        newR=Context.getWmlObjectFactory().createR();
        newR.setRPr(existingRun.getRPr());
      }
 else {
        newR.getContent().add(o2);
      }
    }
 else     if (o2 instanceof JAXBElement && ((JAXBElement)o2).getName().equals(_RInstrText_QNAME)) {
      currentField.setInstrText((JAXBElement<Text>)o2);
      newR.getContent().add(o2);
    }
 else     if (depth == 1 && seenSeparate) {
      System.out.println(""String_Node_Str"" + XmlUtils.marshaltoString(o2,true,true));
    }
 else {
      newR.getContent().add(o2);
      newAttachPoint.getContent().add(newR);
      log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(newR,true,true));
      newR=Context.getWmlObjectFactory().createR();
      newR.setRPr(existingRun.getRPr());
    }
  }
}",0.5028112449799197
185085,"private P canonicaliseInstance(P p){
  P newP=Context.getWmlObjectFactory().createP();
  newP.setPPr(p.getPPr());
  depth=0;
  newR=Context.getWmlObjectFactory().createR();
  fieldRPr=null;
  currentField=null;
  seenSeparate=false;
  handleContent(p.getContent(),newP);
  return newP;
}","private P canonicaliseInstance(P p){
  P newP=Context.getWmlObjectFactory().createP();
  newP.setPPr(p.getPPr());
  depth=0;
  newR=Context.getWmlObjectFactory().createR();
  currentField=null;
  seenSeparate=false;
  handleContent(p.getContent(),newP);
  return newP;
}",0.6750448833034112
185086,"@Override public void setXslFO(Element foElement){
  if (((Color)this.getObject()).getVal() != null) {
    foElement.setAttribute(FO_NAME,""String_Node_Str"" + ((Color)this.getObject()).getVal());
  }
 else {
  }
}","@Override public void setXslFO(Element foElement){
  if (((Color)this.getObject()).getVal() != null) {
    if (((Color)this.getObject()).getVal().equals(""String_Node_Str"")) {
      foElement.setAttribute(FO_NAME,""String_Node_Str"");
    }
 else {
      foElement.setAttribute(FO_NAME,""String_Node_Str"" + ((Color)this.getObject()).getVal());
    }
  }
 else {
  }
}",0.6852173913043478
185087,"public void setInstrText(JAXBElement<Text> instrText){
  this.instrText=instrText;
}","public void setInstrText(JAXBElement<Text> instrTextIn){
  if (this.instrText == null) {
    this.instrText=instrTextIn;
  }
 else {
    String text=this.getInstr() + instrTextIn.getValue().getValue();
    this.instrText.getValue().setValue(text);
  }
}",0.3560830860534125
185088,"public OpcPackage createPackage() throws InvalidFormatException {
  OpcPackage p;
  if (getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT_MACROENABLED) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_TEMPLATE_MACROENABLED) != null) {
    log.info(""String_Node_Str"");
    p=new WordprocessingMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_MAIN) != null || getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_SLIDESHOW) != null) {
    log.info(""String_Node_Str"");
    p=new PresentationMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_WORKBOOK) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_WORKBOOK_MACROENABLED) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_TEMPLATE_MACROENABLED) != null) {
    log.info(""String_Node_Str"");
    p=new SpreadsheetMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.DRAWINGML_DIAGRAM_LAYOUT) != null) {
    log.info(""String_Node_Str"");
    p=new GloxPackage(this);
    return p;
  }
 else {
    throw new InvalidFormatException(""String_Node_Str"");
  }
}","public OpcPackage createPackage() throws InvalidFormatException {
  OpcPackage p;
  if (getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT_MACROENABLED) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.WORDPROCESSINGML_TEMPLATE_MACROENABLED) != null) {
    log.info(""String_Node_Str"");
    p=new WordprocessingMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_MAIN) != null || getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.PRESENTATIONML_SLIDESHOW) != null) {
    log.info(""String_Node_Str"");
    p=new PresentationMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_WORKBOOK) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_WORKBOOK_MACROENABLED) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_TEMPLATE) != null || getPartNameOverridenByContentType(ContentTypes.SPREADSHEETML_TEMPLATE_MACROENABLED) != null) {
    log.info(""String_Node_Str"");
    p=new SpreadsheetMLPackage(this);
    return p;
  }
 else   if (getPartNameOverridenByContentType(ContentTypes.DRAWINGML_DIAGRAM_LAYOUT) != null) {
    log.info(""String_Node_Str"");
    p=new GloxPackage(this);
    return p;
  }
  String defaultContentTypeForXML=this.defaultContentType.get(""String_Node_Str"").getContentType();
  if (defaultContentTypeForXML != null) {
    if (defaultContentTypeForXML.equals(ContentTypes.WORDPROCESSINGML_DOCUMENT) || defaultContentTypeForXML.equals(ContentTypes.WORDPROCESSINGML_DOCUMENT_MACROENABLED) || defaultContentTypeForXML.equals(ContentTypes.WORDPROCESSINGML_TEMPLATE)|| defaultContentTypeForXML.equals(ContentTypes.WORDPROCESSINGML_TEMPLATE_MACROENABLED)) {
      log.info(""String_Node_Str"");
      p=new WordprocessingMLPackage(this);
      return p;
    }
 else     if (defaultContentTypeForXML.equals(ContentTypes.PRESENTATIONML_MAIN) || defaultContentTypeForXML.equals(ContentTypes.PRESENTATIONML_TEMPLATE) || defaultContentTypeForXML.equals(ContentTypes.PRESENTATIONML_SLIDESHOW)) {
      log.info(""String_Node_Str"");
      p=new PresentationMLPackage(this);
      return p;
    }
 else     if (defaultContentTypeForXML.equals(ContentTypes.SPREADSHEETML_WORKBOOK) || defaultContentTypeForXML.equals(ContentTypes.SPREADSHEETML_WORKBOOK_MACROENABLED) || defaultContentTypeForXML.equals(ContentTypes.SPREADSHEETML_TEMPLATE)|| defaultContentTypeForXML.equals(ContentTypes.SPREADSHEETML_TEMPLATE_MACROENABLED)) {
      log.info(""String_Node_Str"");
      p=new SpreadsheetMLPackage(this);
      return p;
    }
 else     if (defaultContentTypeForXML.equals(ContentTypes.DRAWINGML_DIAGRAM_LAYOUT)) {
      log.info(""String_Node_Str"");
      p=new GloxPackage(this);
      return p;
    }
  }
  throw new InvalidFormatException(""String_Node_Str"" + toString());
}",0.676038338658147
185089,"/** 
 * Main method
 * @param args
 * @throws Docx4JException 
 */
public static void main(String[] args) throws Docx4JException {
  String inputfilepath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  String chartPartName=""String_Node_Str"";
  String xlsPartName=""String_Node_Str"";
  String outputfilepath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
  Random rand=new Random();
  String firstValue=String.valueOf(rand.nextInt(99));
  String secondValue=String.valueOf(rand.nextInt(99));
  PresentationMLPackage ppt=(PresentationMLPackage)OpcPackage.load(new java.io.File(inputfilepath));
  Chart chart=(Chart)ppt.getParts().get(new PartName(chartPartName));
  List<Object> objects=chart.getJaxbElement().getChart().getPlotArea().getAreaChartOrArea3DChartOrLineChart();
  for (  Object object : objects) {
    if (object instanceof CTBarChart) {
      List<CTBarSer> ctBarSers=((CTBarChart)object).getSer();
      for (      CTBarSer ctBarSer : ctBarSers) {
        List<CTNumVal> ctNumVals=ctBarSer.getVal().getNumRef().getNumCache().getPt();
        for (        CTNumVal ctNumVal : ctNumVals) {
          System.out.println(""String_Node_Str"" + ctNumVal.getV());
          if (ctNumVal.getIdx() == 0) {
            ctNumVal.setV(firstValue);
          }
 else           if (ctNumVal.getIdx() == 1) {
            ctNumVal.setV(secondValue);
          }
          System.out.println(""String_Node_Str"" + ctNumVal.getV());
        }
      }
    }
  }
  EmbeddedPackagePart epp=(EmbeddedPackagePart)ppt.getParts().get(new PartName(xlsPartName));
  if (epp == null) {
    throw new Docx4JException(""String_Node_Str"" + xlsPartName);
  }
  InputStream is=BufferUtil.newInputStream(epp.getBuffer());
  SpreadsheetMLPackage spreadSheet=(SpreadsheetMLPackage)SpreadsheetMLPackage.load(is);
  Map<PartName,Part> partsMap=spreadSheet.getParts().getParts();
  Iterator<Entry<PartName,Part>> it=partsMap.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<PartName,Part> pairs=it.next();
    if (partsMap.get(pairs.getKey()) instanceof WorksheetPart) {
      WorksheetPart wsp=(WorksheetPart)partsMap.get(pairs.getKey());
      List<Row> rows=wsp.getJaxbElement().getSheetData().getRow();
      for (      Row row : rows) {
        List<Cell> cells=row.getC();
        for (        Cell cell : cells) {
          if (cell.getR().equals(""String_Node_Str"") && cell.getV() != null) {
            System.out.println(""String_Node_Str"" + cell.getV());
            cell.setV(firstValue);
          }
 else           if (cell.getR().equals(""String_Node_Str"") && cell.getV() != null) {
            System.out.println(""String_Node_Str"" + cell.getV());
            cell.setV(secondValue);
          }
        }
      }
    }
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SaveToZipFile saver=new SaveToZipFile(spreadSheet);
  saver.save(baos);
  epp.setBinaryData(baos.toByteArray());
  ppt.addTargetPart(epp);
  ppt.save(new java.io.File(outputfilepath));
  System.out.println(""String_Node_Str"" + outputfilepath);
}","/** 
 * Main method
 * @param args
 * @throws Docx4JException 
 */
public static void main(String[] args) throws Docx4JException {
  String inputfilepath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  String chartPartName=""String_Node_Str"";
  String xlsPartName=""String_Node_Str"";
  String outputfilepath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
  Random rand=new Random();
  String firstValue=String.valueOf(rand.nextInt(99));
  String secondValue=String.valueOf(rand.nextInt(99));
  PresentationMLPackage ppt=(PresentationMLPackage)OpcPackage.load(new java.io.File(inputfilepath));
  Chart chart=(Chart)ppt.getParts().get(new PartName(chartPartName));
  List<Object> objects=chart.getJaxbElement().getChart().getPlotArea().getAreaChartOrArea3DChartOrLineChart();
  for (  Object object : objects) {
    if (object instanceof CTBarChart) {
      List<CTBarSer> ctBarSers=((CTBarChart)object).getSer();
      for (      CTBarSer ctBarSer : ctBarSers) {
        List<CTNumVal> ctNumVals=ctBarSer.getVal().getNumRef().getNumCache().getPt();
        for (        CTNumVal ctNumVal : ctNumVals) {
          System.out.println(""String_Node_Str"" + ctNumVal.getV());
          if (ctNumVal.getIdx() == 0) {
            ctNumVal.setV(firstValue);
          }
 else           if (ctNumVal.getIdx() == 1) {
            ctNumVal.setV(secondValue);
          }
          System.out.println(""String_Node_Str"" + ctNumVal.getV());
        }
      }
    }
  }
  EmbeddedPackagePart epp=(EmbeddedPackagePart)ppt.getParts().get(new PartName(xlsPartName));
  if (epp == null) {
    throw new Docx4JException(""String_Node_Str"" + xlsPartName);
  }
  InputStream is=BufferUtil.newInputStream(epp.getBuffer());
  SpreadsheetMLPackage spreadSheet=(SpreadsheetMLPackage)SpreadsheetMLPackage.load(is);
  Map<PartName,Part> partsMap=spreadSheet.getParts().getParts();
  Iterator<Entry<PartName,Part>> it=partsMap.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<PartName,Part> pairs=it.next();
    if (partsMap.get(pairs.getKey()) instanceof WorksheetPart) {
      WorksheetPart wsp=(WorksheetPart)partsMap.get(pairs.getKey());
      List<Row> rows=wsp.getJaxbElement().getSheetData().getRow();
      for (      Row row : rows) {
        List<Cell> cells=row.getC();
        for (        Cell cell : cells) {
          if (cell.getR().equals(""String_Node_Str"") && cell.getV() != null) {
            System.out.println(""String_Node_Str"" + cell.getV());
            cell.setT(STCellType.STR);
            cell.setV(firstValue);
          }
 else           if (cell.getR().equals(""String_Node_Str"") && cell.getV() != null) {
            System.out.println(""String_Node_Str"" + cell.getV());
            cell.setT(STCellType.STR);
            cell.setV(secondValue);
          }
        }
      }
    }
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SaveToZipFile saver=new SaveToZipFile(spreadSheet);
  saver.save(baos);
  epp.setBinaryData(baos.toByteArray());
  ppt.save(new java.io.File(outputfilepath));
  System.out.println(""String_Node_Str"" + outputfilepath);
}",0.9833333333333332
185090,"public static P canonicalise(P p,List<FieldRef> fieldRefs){
  P newP=Context.getWmlObjectFactory().createP();
  int depth=0;
  R newR=Context.getWmlObjectFactory().createR();
  RPr fieldRPr=null;
  FieldRef currentField=null;
  boolean seenSeparate=false;
  for (  Object o : p.getContent()) {
    if (o instanceof R) {
      R existingRun=(R)o;
      for (      Object o2 : existingRun.getContent()) {
        if (isCharType(o2,STFldCharType.BEGIN)) {
          seenSeparate=false;
          depth++;
          if (depth == 1) {
            newR=Context.getWmlObjectFactory().createR();
            newR.getContent().add(o2);
            currentField=new FieldRef();
            fieldRefs.add(currentField);
            currentField.setParent(newP);
            currentField.setBeginRun(newR);
          }
        }
 else         if (isCharType(o2,STFldCharType.END)) {
          if (!seenSeparate) {
            R separateR=Context.getWmlObjectFactory().createR();
            FldChar fldChar=Context.getWmlObjectFactory().createFldChar();
            fldChar.setFldCharType(STFldCharType.SEPARATE);
            newR.getContent().add(fldChar);
            newP.getContent().add(separateR);
            newR=Context.getWmlObjectFactory().createR();
            currentField.setResultsSlot(newR);
          }
          depth--;
          if (depth == 0) {
            newP.getContent().add(newR);
            newR=Context.getWmlObjectFactory().createR();
            newR.getContent().add(o2);
            newP.getContent().add(newR);
            currentField.setEndRun(newR);
            newR=Context.getWmlObjectFactory().createR();
          }
 else {
            newR.getContent().add(o2);
          }
        }
 else         if (isCharType(o2,STFldCharType.SEPARATE)) {
          seenSeparate=true;
          newR.getContent().add(o2);
          if (depth == 1) {
            newP.getContent().add(newR);
            newR=Context.getWmlObjectFactory().createR();
            newR.setRPr(fieldRPr);
            currentField.setResultsSlot(newR);
          }
        }
 else         if (o2 instanceof JAXBElement && ((JAXBElement)o2).getName().equals(_RInstrText_QNAME)) {
          currentField.setInstrText((JAXBElement<Text>)o2);
          newR.getContent().add(o2);
          fieldRPr=existingRun.getRPr();
          newR.setRPr(fieldRPr);
        }
 else {
          newR.getContent().add(o2);
          newR.setRPr(existingRun.getRPr());
          newP.getContent().add(newR);
          newR=Context.getWmlObjectFactory().createR();
        }
      }
    }
 else {
      if (newR.getContent().size() > 0) {
        newP.getContent().add(newR);
        newR=Context.getWmlObjectFactory().createR();
      }
      newP.getContent().add(o);
    }
  }
  if (newR.getContent().size() > 0 && !newP.getContent().contains(newR)) {
    newP.getContent().add(newR);
  }
  return newP;
}","public static P canonicalise(P p,List<FieldRef> fieldRefs){
  P newP=Context.getWmlObjectFactory().createP();
  newP.setPPr(p.getPPr());
  int depth=0;
  R newR=Context.getWmlObjectFactory().createR();
  RPr fieldRPr=null;
  FieldRef currentField=null;
  boolean seenSeparate=false;
  for (  Object o : p.getContent()) {
    if (o instanceof R) {
      R existingRun=(R)o;
      for (      Object o2 : existingRun.getContent()) {
        if (isCharType(o2,STFldCharType.BEGIN)) {
          seenSeparate=false;
          depth++;
          if (depth == 1) {
            newR=Context.getWmlObjectFactory().createR();
            newR.getContent().add(o2);
            currentField=new FieldRef();
            fieldRefs.add(currentField);
            currentField.setParent(newP);
            currentField.setBeginRun(newR);
          }
        }
 else         if (isCharType(o2,STFldCharType.END)) {
          if (!seenSeparate) {
            R separateR=Context.getWmlObjectFactory().createR();
            FldChar fldChar=Context.getWmlObjectFactory().createFldChar();
            fldChar.setFldCharType(STFldCharType.SEPARATE);
            newR.getContent().add(fldChar);
            newP.getContent().add(separateR);
            newR=Context.getWmlObjectFactory().createR();
            currentField.setResultsSlot(newR);
          }
          depth--;
          if (depth == 0) {
            newP.getContent().add(newR);
            newR=Context.getWmlObjectFactory().createR();
            newR.getContent().add(o2);
            newP.getContent().add(newR);
            currentField.setEndRun(newR);
            newR=Context.getWmlObjectFactory().createR();
          }
 else {
            newR.getContent().add(o2);
          }
        }
 else         if (isCharType(o2,STFldCharType.SEPARATE)) {
          seenSeparate=true;
          newR.getContent().add(o2);
          if (depth == 1) {
            newP.getContent().add(newR);
            newR=Context.getWmlObjectFactory().createR();
            newR.setRPr(fieldRPr);
            currentField.setResultsSlot(newR);
          }
        }
 else         if (o2 instanceof JAXBElement && ((JAXBElement)o2).getName().equals(_RInstrText_QNAME)) {
          currentField.setInstrText((JAXBElement<Text>)o2);
          newR.getContent().add(o2);
          fieldRPr=existingRun.getRPr();
          newR.setRPr(fieldRPr);
        }
 else {
          newR.getContent().add(o2);
          newR.setRPr(existingRun.getRPr());
          newP.getContent().add(newR);
          newR=Context.getWmlObjectFactory().createR();
        }
      }
    }
 else {
      if (newR.getContent().size() > 0) {
        newP.getContent().add(newR);
        newR=Context.getWmlObjectFactory().createR();
      }
      newP.getContent().add(o);
    }
  }
  if (newR.getContent().size() > 0 && !newP.getContent().contains(newR)) {
    newP.getContent().add(newR);
  }
  return newP;
}",0.9953424184923236
185091,"private void handleRow(NodeList cellContents,Tr tr,int r){
  log.debug(""String_Node_Str"" + r);
  if (borderConflictResolutionRequired && tr.getTblPrEx() != null && tr.getTblPrEx().getTblCellSpacing() != null) {
    borderConflictResolutionRequired=false;
  }
  TcFinder tcFinder=new TcFinder();
  new TraversalUtil(tr,tcFinder);
  int c=0;
  log.debug(""String_Node_Str"" + c);
  for (  Tc tc : tcFinder.tcList) {
    Node wtrNode=cellContents.item(r);
    if (wtrNode == null) {
      log.warn(""String_Node_Str"" + r);
    }
    addCell(tc,getTc(wtrNode,c,new IntRef(0)));
    c++;
  }
}","private void handleRow(NodeList cellContents,Tr tr,int r){
  log.debug(""String_Node_Str"" + r);
  if (borderConflictResolutionRequired && tr.getTblPrEx() != null && tr.getTblPrEx().getTblCellSpacing() != null) {
    borderConflictResolutionRequired=false;
  }
  TcFinder tcFinder=new TcFinder();
  new TraversalUtil(tr,tcFinder);
  int c=0;
  log.debug(""String_Node_Str"" + c);
  for (  Tc tc : tcFinder.tcList) {
    Node wtrNode=cellContents.item(r);
    if (wtrNode == null) {
      log.error(""String_Node_Str"" + r);
      return;
    }
    addCell(tc,getTc(wtrNode,c,new IntRef(0)));
    c++;
  }
}",0.980590717299578
185092,"public static DocumentFragment xpathInjectImage(WordprocessingMLPackage wmlPackage,JaxbXmlPart sourcePart,Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts,String storeItemId,String xpath,String prefixMappings,String sdtParent,String contentChild,String cx,String cy){
  log.debug(""String_Node_Str"" + sdtParent);
  CustomXmlDataStoragePart part=customXmlDataStorageParts.get(storeItemId.toLowerCase());
  if (part == null) {
    log.error(""String_Node_Str"" + storeItemId);
    return null;
  }
  try {
    String r=part.getData().xpathGetString(xpath,prefixMappings);
    log.debug(xpath + ""String_Node_Str"" + r);
    byte[] bytes=Base64.decodeBase64(r.getBytes(""String_Node_Str""));
    BinaryPartAbstractImage imagePart=BinaryPartAbstractImage.createImagePart(wmlPackage,sourcePart,bytes);
    String filenameHint=null;
    String altText=null;
    int id1=0;
    int id2=1;
    Inline inline=null;
    long cxl=0;
    long cyl=0;
    try {
      cxl=Long.parseLong(cx);
      cyl=Long.parseLong(cy);
    }
 catch (    Exception e) {
    }
    if (cxl == 0 || cyl == 0) {
      log.debug(""String_Node_Str"");
      inline=imagePart.createImageInline(filenameHint,altText,id1,id2,false);
    }
 else {
      log.debug(""String_Node_Str"");
      ImageSize size=imagePart.getImageInfo().getSize();
      double ratio=(double)size.getHeightPx() / (double)size.getWidthPx();
      log.debug(""String_Node_Str"" + ratio);
      if (ratio > 1) {
        cxl=(long)((double)cyl / ratio);
      }
 else {
        cyl=(long)((double)cxl * ratio);
      }
      inline=imagePart.createImageInline(filenameHint,altText,id1,id2,cxl,cyl,false);
    }
    org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
    org.docx4j.wml.Tc tc=factory.createTc();
    org.docx4j.wml.P p=factory.createP();
    if (sdtParent.equals(""String_Node_Str"")) {
      tc.getContent().add(p);
    }
    org.docx4j.wml.R run=factory.createR();
    if (sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"")) {
      p.getContent().add(run);
    }
    org.docx4j.wml.Drawing drawing=factory.createDrawing();
    run.getContent().add(drawing);
    drawing.getAnchorOrInline().add(inline);
    Document document=null;
    if (sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(p);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(tc);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(run);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + contentChild);
      if (contentChild.equals(""String_Node_Str"")) {
        p.getContent().add(run);
        document=XmlUtils.marshaltoW3CDomDocument(p);
      }
 else       if (contentChild.equals(""String_Node_Str"")) {
        document=XmlUtils.marshaltoW3CDomDocument(r);
      }
 else {
        log.error(""String_Node_Str"" + contentChild);
      }
    }
 else {
      log.error(""String_Node_Str"" + sdtParent);
    }
    DocumentFragment docfrag=document.createDocumentFragment();
    docfrag.appendChild(document.getDocumentElement());
    return docfrag;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public static DocumentFragment xpathInjectImage(WordprocessingMLPackage wmlPackage,JaxbXmlPart sourcePart,Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts,String storeItemId,String xpath,String prefixMappings,String sdtParent,String contentChild,String cx,String cy){
  log.debug(""String_Node_Str"" + sdtParent);
  CustomXmlDataStoragePart part=customXmlDataStorageParts.get(storeItemId.toLowerCase());
  if (part == null) {
    log.error(""String_Node_Str"" + storeItemId);
    return null;
  }
  try {
    String xpResult=part.getData().xpathGetString(xpath,prefixMappings);
    log.debug(xpath + ""String_Node_Str"" + xpResult);
    byte[] bytes=Base64.decodeBase64(xpResult.getBytes(""String_Node_Str""));
    BinaryPartAbstractImage imagePart=BinaryPartAbstractImage.createImagePart(wmlPackage,sourcePart,bytes);
    String filenameHint=null;
    String altText=null;
    int id1=0;
    int id2=1;
    Inline inline=null;
    long cxl=0;
    long cyl=0;
    try {
      cxl=Long.parseLong(cx);
      cyl=Long.parseLong(cy);
    }
 catch (    Exception e) {
    }
    if (cxl == 0 || cyl == 0) {
      log.debug(""String_Node_Str"");
      inline=imagePart.createImageInline(filenameHint,altText,id1,id2,false);
    }
 else {
      log.debug(""String_Node_Str"");
      ImageSize size=imagePart.getImageInfo().getSize();
      double ratio=(double)size.getHeightPx() / (double)size.getWidthPx();
      log.debug(""String_Node_Str"" + ratio);
      if (ratio > 1) {
        cxl=(long)((double)cyl / ratio);
      }
 else {
        cyl=(long)((double)cxl * ratio);
      }
      inline=imagePart.createImageInline(filenameHint,altText,id1,id2,cxl,cyl,false);
    }
    org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
    org.docx4j.wml.Tc tc=factory.createTc();
    org.docx4j.wml.P p=factory.createP();
    if (sdtParent.equals(""String_Node_Str"")) {
      tc.getContent().add(p);
    }
    org.docx4j.wml.R run=factory.createR();
    if (sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"")) {
      p.getContent().add(run);
    }
    org.docx4j.wml.Drawing drawing=factory.createDrawing();
    run.getContent().add(drawing);
    drawing.getAnchorOrInline().add(inline);
    Document document=null;
    if (sdtParent.equals(""String_Node_Str"") || sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(p);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(tc);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      document=XmlUtils.marshaltoW3CDomDocument(run);
    }
 else     if (sdtParent.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + contentChild);
      if (contentChild.equals(""String_Node_Str"")) {
        p.getContent().add(run);
        document=XmlUtils.marshaltoW3CDomDocument(p);
      }
 else       if (contentChild.equals(""String_Node_Str"")) {
        document=XmlUtils.marshaltoW3CDomDocument(run);
      }
 else {
        log.error(""String_Node_Str"" + contentChild);
      }
    }
 else {
      log.error(""String_Node_Str"" + sdtParent);
    }
    DocumentFragment docfrag=document.createDocumentFragment();
    docfrag.appendChild(document.getDocumentElement());
    return docfrag;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.995699243660092
185093,"public static DocumentFragment xpathDate(WordprocessingMLPackage wmlPackage,JaxbXmlPart sourcePart,Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts,String storeItemId,String xpath,String prefixMappings,String sdtParent,String contentChild,NodeIterator dateNodeIt){
  CustomXmlDataStoragePart part=customXmlDataStorageParts.get(storeItemId.toLowerCase());
  if (part == null) {
    log.error(""String_Node_Str"" + storeItemId);
    return null;
  }
  try {
    String r=part.getData().xpathGetString(xpath,prefixMappings);
    log.debug(xpath + ""String_Node_Str"" + r);
    if (r == null)     return nullResultParagraph(sdtParent,""String_Node_Str"");
    CTSdtDate sdtDate=null;
    Node dateNode=dateNodeIt.nextNode();
    if (dateNode != null) {
      sdtDate=(CTSdtDate)XmlUtils.unmarshal(dateNode,Context.jc,CTSdtDate.class);
    }
    if (r.indexOf(""String_Node_Str"") > 0) {
      r=r.substring(0,r.indexOf(""String_Node_Str"") - 1);
      log.warn(""String_Node_Str"" + r);
    }
    DateFormat dateTimeFormat=new SimpleDateFormat(""String_Node_Str"");
    String format=sdtDate.getDateFormat().getVal();
    System.out.println(""String_Node_Str"" + format);
    if (format.contains(""String_Node_Str"")) {
      format=format.replace(""String_Node_Str"",""String_Node_Str"");
    }
    Format formatter=new SimpleDateFormat(format);
    org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
    Date date;
    RPr rPr=null;
    try {
      date=(Date)dateTimeFormat.parse(r);
    }
 catch (    ParseException e) {
      log.warn(e.getMessage());
      date=new Date();
      rPr=factory.createRPr();
      Color colorRed=factory.createColor();
      colorRed.setVal(""String_Node_Str"");
      rPr.setColor(colorRed);
    }
    String result=formatter.format(date);
    org.docx4j.wml.R run=factory.createR();
    if (rPr != null) {
      run.setRPr(rPr);
    }
    org.docx4j.wml.Text text=factory.createText();
    text.setValue(result);
    run.getContent().add(text);
    org.w3c.dom.Document docContainer=XmlUtils.neww3cDomDocument();
    if (sdtParent.equals(""String_Node_Str"")) {
      docContainer=XmlUtils.marshaltoW3CDomDocument(run);
    }
 else {
      org.docx4j.wml.P p=factory.createP();
      p.getContent().add(run);
      docContainer=XmlUtils.marshaltoW3CDomDocument(p);
    }
    DocumentFragment docfrag=docContainer.createDocumentFragment();
    docfrag.appendChild(docContainer.getDocumentElement());
    return docfrag;
  }
 catch (  Exception e) {
    log.error(e);
    return null;
  }
}","public static DocumentFragment xpathDate(WordprocessingMLPackage wmlPackage,JaxbXmlPart sourcePart,Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts,String storeItemId,String xpath,String prefixMappings,String sdtParent,String contentChild,NodeIterator dateNodeIt){
  CustomXmlDataStoragePart part=customXmlDataStorageParts.get(storeItemId.toLowerCase());
  if (part == null) {
    log.error(""String_Node_Str"" + storeItemId);
    return null;
  }
  try {
    String r=part.getData().xpathGetString(xpath,prefixMappings);
    log.debug(xpath + ""String_Node_Str"" + r);
    if (r == null)     return nullResultParagraph(sdtParent,""String_Node_Str"");
    CTSdtDate sdtDate=null;
    Node dateNode=dateNodeIt.nextNode();
    if (dateNode != null) {
      sdtDate=(CTSdtDate)XmlUtils.unmarshal(dateNode,Context.jc,CTSdtDate.class);
    }
    if (r.indexOf(""String_Node_Str"") > 0) {
      r=r.substring(0,r.indexOf(""String_Node_Str"") - 1);
      log.warn(""String_Node_Str"" + r);
    }
    DateFormat dateTimeFormat=new SimpleDateFormat(""String_Node_Str"");
    String format=sdtDate.getDateFormat().getVal();
    System.out.println(""String_Node_Str"" + format);
    if (format.contains(""String_Node_Str"")) {
      format=format.replace(""String_Node_Str"",""String_Node_Str"");
    }
    Format formatter=new SimpleDateFormat(format);
    org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
    Date date;
    RPr rPr=null;
    try {
      date=(Date)dateTimeFormat.parse(r);
    }
 catch (    ParseException e) {
      try {
        DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
        date=(Date)dateFormat.parse(r);
      }
 catch (      ParseException e2) {
        log.warn(e.getMessage());
        date=new Date();
        rPr=factory.createRPr();
        Color colorRed=factory.createColor();
        colorRed.setVal(""String_Node_Str"");
        rPr.setColor(colorRed);
      }
    }
    String result=formatter.format(date);
    org.docx4j.wml.R run=factory.createR();
    if (rPr != null) {
      run.setRPr(rPr);
    }
    org.docx4j.wml.Text text=factory.createText();
    text.setValue(result);
    run.getContent().add(text);
    org.w3c.dom.Document docContainer=XmlUtils.neww3cDomDocument();
    if (sdtParent.equals(""String_Node_Str"")) {
      docContainer=XmlUtils.marshaltoW3CDomDocument(run);
    }
 else {
      org.docx4j.wml.P p=factory.createP();
      p.getContent().add(run);
      docContainer=XmlUtils.marshaltoW3CDomDocument(p);
    }
    DocumentFragment docfrag=docContainer.createDocumentFragment();
    docfrag.appendChild(docContainer.getDocumentElement());
    return docfrag;
  }
 catch (  Exception e) {
    log.error(e);
    return null;
  }
}",0.963047619047619
185094,"public synchronized static void configure(){
  if (!isConfigured()) {
    boolean disabled=Boolean.parseBoolean(Docx4jProperties.getProperties().getProperty(""String_Node_Str"",""String_Node_Str""));
    if (disabled)     return;
    BasicConfigurator.configure();
    Logger.getRootLogger().setLevel(Level.INFO);
    Logger log=Logger.getLogger(Log4jConfigurator.class);
    log.info(""String_Node_Str"");
    try {
      org.docx4j.convert.out.pdf.viaXSLFO.Conversion.log.setLevel(Level.DEBUG);
    }
 catch (    NoClassDefFoundError n) {
    }
  }
}","public synchronized static void configure(){
  boolean disabled=Boolean.parseBoolean(Docx4jProperties.getProperties().getProperty(""String_Node_Str"",""String_Node_Str""));
  if (disabled)   return;
  if (!isConfigured()) {
    BasicConfigurator.configure();
    Logger.getRootLogger().setLevel(Level.INFO);
    Logger log=Logger.getLogger(Log4jConfigurator.class);
    log.info(""String_Node_Str"");
    try {
      org.docx4j.convert.out.pdf.viaXSLFO.Conversion.log.setLevel(Level.DEBUG);
    }
 catch (    NoClassDefFoundError n) {
    }
  }
}",0.9355432780847146
185095,"public static Part newPartForContentType(String contentType,String partName) throws InvalidFormatException, PartUnrecognisedException {
  if (contentType.equals(ContentTypes.PRESENTATIONML_MAIN)) {
    return new MainPresentationPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE)) {
    return new SlidePart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE_MASTER)) {
    return new SlideMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE_LAYOUT)) {
    return new SlideLayoutPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_TABLE_STYLES)) {
    return new TableStylesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_PRES_PROPS)) {
    return new PresentationPropertiesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_VIEW_PROPS)) {
    return new ViewPropertiesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_TAGS)) {
    return new TagsPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_HANDOUT_MASTER)) {
    return new HandoutMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_NOTES_MASTER)) {
    return new NotesMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_NOTES_SLIDE)) {
    return new NotesSlidePart(new PartName(partName));
  }
 else {
    throw new PartUnrecognisedException(""String_Node_Str"" + partName + ""String_Node_Str""+ contentType+ ""String_Node_Str"");
  }
}","public static Part newPartForContentType(String contentType,String partName) throws InvalidFormatException, PartUnrecognisedException {
  if (contentType.equals(ContentTypes.PRESENTATIONML_MAIN) || contentType.equals(ContentTypes.PRESENTATIONML_TEMPLATE)) {
    return new MainPresentationPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE)) {
    return new SlidePart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE_MASTER)) {
    return new SlideMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_SLIDE_LAYOUT)) {
    return new SlideLayoutPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_TABLE_STYLES)) {
    return new TableStylesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_PRES_PROPS)) {
    return new PresentationPropertiesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_VIEW_PROPS)) {
    return new ViewPropertiesPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_TAGS)) {
    return new TagsPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_HANDOUT_MASTER)) {
    return new HandoutMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_NOTES_MASTER)) {
    return new NotesMasterPart(new PartName(partName));
  }
 else   if (contentType.equals(ContentTypes.PRESENTATIONML_NOTES_SLIDE)) {
    return new NotesSlidePart(new PartName(partName));
  }
 else {
    throw new PartUnrecognisedException(""String_Node_Str"" + partName + ""String_Node_Str""+ contentType+ ""String_Node_Str"");
  }
}",0.9830795262267344
185096,"private static void processString(JaxbXmlPart sourcePart,DocumentFragment docfrag,String text,RPr rPr) throws JAXBException {
  int pos=text.indexOf(""String_Node_Str"");
  if (pos == -1) {
    addRunToDocFrag(sourcePart,docfrag,text,rPr);
    return;
  }
  if (pos == 0) {
    int spacePos=text.indexOf(""String_Node_Str"");
    if (spacePos == -1) {
      addHyperlinkToDocFrag(sourcePart,docfrag,text);
      return;
    }
    String first=text.substring(0,spacePos);
    String rest=text.substring(spacePos);
    addHyperlinkToDocFrag(sourcePart,docfrag,first);
    processString(sourcePart,docfrag,rest,rPr);
    return;
  }
  String first=text.substring(0,pos);
  String rest=text.substring(pos);
  addRunToDocFrag(sourcePart,docfrag,first,rPr);
  processString(sourcePart,docfrag,rest,rPr);
}","private static void processString(JaxbXmlPart sourcePart,DocumentFragment docfrag,String text,RPr rPr) throws JAXBException {
  int NOT_FOUND=99999;
  int pos1=text.indexOf(""String_Node_Str"") == -1 ? NOT_FOUND : text.indexOf(""String_Node_Str"");
  int pos2=text.indexOf(""String_Node_Str"") == -1 ? NOT_FOUND : text.indexOf(""String_Node_Str"");
  int pos3=text.indexOf(""String_Node_Str"") == -1 ? NOT_FOUND : text.indexOf(""String_Node_Str"");
  int pos=Math.min(pos1,Math.min(pos2,pos3));
  if (pos == NOT_FOUND || hyperlinkStyleId == null) {
    addRunToDocFrag(sourcePart,docfrag,text,rPr);
    return;
  }
  if (pos == 0) {
    int spacePos=text.indexOf(""String_Node_Str"");
    if (spacePos == -1) {
      addHyperlinkToDocFrag(sourcePart,docfrag,text);
      return;
    }
    String first=text.substring(0,spacePos);
    String rest=text.substring(spacePos);
    addHyperlinkToDocFrag(sourcePart,docfrag,first);
    processString(sourcePart,docfrag,rest,rPr);
    return;
  }
  String first=text.substring(0,pos);
  String rest=text.substring(pos);
  addRunToDocFrag(sourcePart,docfrag,first,rPr);
  processString(sourcePart,docfrag,rest,rPr);
}",0.6157813305827746
185097,"/** 
 * Configure, how the handler handles links found in Custom XML. If set to <code>null</code>, strings containing 'http://' are not converted to w:hyperlink. This is the default behavior. If set to <code>true</code>, strings containing 'http://' are converted to w:hyperlink.  If you do this, you will need to post-process with RemovalHandler, since a content control with SdtPr w:dataBinding and w:text which contains a w:hyperlink will prevent Word 2007 from opening the docx. Due to the architecture of this class, this is a static flag changing the behavior of all following calls to   {@link #applyBindings}.
 * @param hyperlinkStyle The style to use for hyperlinks (eg Hyperlink)
 */
public static void setHyperlinkStyle(String hyperlinkStyleID){
  hyperlinkStyleId=hyperlinkStyleID;
}","/** 
 * Configure, how the handler handles links found in Custom XML. If hyperlinkStyleId is set to <code>null</code>, strings  containing 'http://' or 'https://' are not converted to  w:hyperlink. This is the default behavior. If hyperlinkStyleId is set to <code>""someWordHyperlinkStyleName""</code>,  strings containing 'http://' or 'https://' or or 'mailto:' are converted to w:hyperlink.   The default Word hyperlink style name is ""Hyperlink"". If you do this, you will need to post-process with RemovalHandler, since a content control with SdtPr w:dataBinding and w:text which contains a w:hyperlink will prevent Word 2007 from opening the docx. Due to the architecture of this class, this is a static flag changing the behavior of all following calls to   {@link #applyBindings}.
 * @param hyperlinkStyleID The style to use for hyperlinks (eg Hyperlink)
 */
public static void setHyperlinkStyle(String hyperlinkStyleID){
  hyperlinkStyleId=hyperlinkStyleID;
}",0.8998862343572241
185098,"public static void applyBindings(JaxbXmlPart part) throws Docx4JException {
  org.docx4j.openpackaging.packages.OpcPackage pkg=part.getPackage();
  org.w3c.dom.Document doc=XmlUtils.marshaltoW3CDomDocument(part.getJaxbElement());
  XPathsPart xPathsPart=null;
  if (((WordprocessingMLPackage)pkg).getMainDocumentPart().getXPathsPart() == null) {
    log.error(""String_Node_Str"");
  }
 else {
    xPathsPart=((WordprocessingMLPackage)pkg).getMainDocumentPart().getXPathsPart();
  }
  JAXBContext jc=Context.jc;
  try {
    Unmarshaller u=jc.createUnmarshaller();
    u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());
    javax.xml.bind.util.JAXBResult result=new javax.xml.bind.util.JAXBResult(u);
    Map<String,Object> transformParameters=new HashMap<String,Object>();
    transformParameters.put(""String_Node_Str"",part.getPackage().getCustomXmlDataStorageParts());
    transformParameters.put(""String_Node_Str"",(WordprocessingMLPackage)pkg);
    transformParameters.put(""String_Node_Str"",part);
    transformParameters.put(""String_Node_Str"",xPathsPart);
    org.docx4j.XmlUtils.transform(doc,xslt,transformParameters,result);
    part.setJaxbElement(result);
  }
 catch (  Exception e) {
    throw new Docx4JException(""String_Node_Str"",e);
  }
}","public static void applyBindings(JaxbXmlPart part) throws Docx4JException {
  org.docx4j.openpackaging.packages.OpcPackage pkg=part.getPackage();
  if (hyperlinkStyleId != null && pkg instanceof WordprocessingMLPackage) {
    ((WordprocessingMLPackage)pkg).getMainDocumentPart().getPropertyResolver().activateStyle(hyperlinkStyleId);
  }
  org.w3c.dom.Document doc=XmlUtils.marshaltoW3CDomDocument(part.getJaxbElement());
  XPathsPart xPathsPart=null;
  if (((WordprocessingMLPackage)pkg).getMainDocumentPart().getXPathsPart() == null) {
    log.error(""String_Node_Str"");
  }
 else {
    xPathsPart=((WordprocessingMLPackage)pkg).getMainDocumentPart().getXPathsPart();
  }
  JAXBContext jc=Context.jc;
  try {
    Unmarshaller u=jc.createUnmarshaller();
    u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());
    javax.xml.bind.util.JAXBResult result=new javax.xml.bind.util.JAXBResult(u);
    Map<String,Object> transformParameters=new HashMap<String,Object>();
    transformParameters.put(""String_Node_Str"",part.getPackage().getCustomXmlDataStorageParts());
    transformParameters.put(""String_Node_Str"",(WordprocessingMLPackage)pkg);
    transformParameters.put(""String_Node_Str"",part);
    transformParameters.put(""String_Node_Str"",xPathsPart);
    org.docx4j.XmlUtils.transform(doc,xslt,transformParameters,result);
    part.setJaxbElement(result);
  }
 catch (  Exception e) {
    throw new Docx4JException(""String_Node_Str"",e);
  }
}",0.9295154185022028
185099,"private void init(PgSz pgSz,PgMar pgMar){
  if (pgSz == null) {
    log.warn(""String_Node_Str"");
    pgSz=Context.getWmlObjectFactory().createSectPrPgSz();
    setPgSize(PageSizePaper.A4,false);
  }
 else {
    this.pgSz=pgSz;
  }
  if (pgMar == null) {
    log.warn(""String_Node_Str"");
    pgMar=Context.getWmlObjectFactory().createSectPrPgMar();
    setMargins(MarginsWellKnown.NORMAL);
  }
 else {
    this.pgMar=pgMar;
  }
}","private void init(PgSz pgSz,PgMar pgMar){
  if (pgSz == null) {
    log.warn(""String_Node_Str"");
    this.pgSz=Context.getWmlObjectFactory().createSectPrPgSz();
    setPgSize(PageSizePaper.A4,false);
  }
 else {
    this.pgSz=pgSz;
  }
  if (pgMar == null) {
    log.warn(""String_Node_Str"");
    this.pgMar=Context.getWmlObjectFactory().createSectPrPgMar();
    setMargins(MarginsWellKnown.NORMAL);
  }
 else {
    this.pgMar=pgMar;
  }
}",0.9884526558891455
185100,"public void addPartsFromRelationships(ZipOutputStream out,RelationshipsPart rp) throws Docx4JException {
  for (  Relationship r : rp.getRelationships().getRelationship()) {
    log.debug(""String_Node_Str"" + r.getId() + ""String_Node_Str""+ rp.getSourceP().getPartName()+ ""String_Node_Str""+ r.getTarget());
    if (r.getTargetMode() != null && r.getTargetMode().equals(""String_Node_Str"")) {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      continue;
    }
    try {
      String resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
      resolvedPartUri=resolvedPartUri.substring(1);
      if (!false) {
        log.debug(""String_Node_Str"" + resolvedPartUri);
        Part part=p.getParts().get(new PartName(""String_Node_Str"" + resolvedPartUri));
        if (part == null) {
          log.error(""String_Node_Str"" + resolvedPartUri + ""String_Node_Str"");
        }
 else {
          log.debug(part.getClass().getName());
        }
        savePart(out,part);
      }
    }
 catch (    Exception e) {
      throw new Docx4JException(""String_Node_Str"",e);
    }
  }
}","public void addPartsFromRelationships(ZipOutputStream out,RelationshipsPart rp) throws Docx4JException {
  for (  Relationship r : rp.getRelationships().getRelationship()) {
    log.debug(""String_Node_Str"" + r.getId() + ""String_Node_Str""+ rp.getSourceP().getPartName()+ ""String_Node_Str""+ r.getTarget());
    if (r.getType().equals(Namespaces.HYPERLINK)) {
      continue;
    }
    if (r.getTargetMode() != null && r.getTargetMode().equals(""String_Node_Str"")) {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      continue;
    }
    try {
      String resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
      resolvedPartUri=resolvedPartUri.substring(1);
      if (!false) {
        log.debug(""String_Node_Str"" + resolvedPartUri);
        Part part=p.getParts().get(new PartName(""String_Node_Str"" + resolvedPartUri));
        if (part == null) {
          log.error(""String_Node_Str"" + resolvedPartUri + ""String_Node_Str"");
        }
 else {
          log.debug(part.getClass().getName());
        }
        savePart(out,part);
      }
    }
 catch (    Exception e) {
      throw new Docx4JException(""String_Node_Str"",e);
    }
  }
}",0.9686706181202372
185101,"/** 
 * Create a linked image part, and attach it as a rel of the specified source part (eg a header part)
 * @param wordMLPackage
 * @param sourcePart
 * @param fileurl
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createLinkedImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,String fileurl) throws Exception {
  ImageInfo info=ensureFormatIsSupported(fileurl,null,null);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  String ext=info.getMimeType().substring(info.getMimeType().indexOf(""String_Node_Str""));
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),createImageName(sourcePart,proposedRelId,ext),null);
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  imagePart.rel=sourcePart.addTargetPart(imagePart);
  imagePart.rel.setTargetMode(""String_Node_Str"");
  wordMLPackage.getExternalResources().put(imagePart.getExternalTarget(),imagePart);
  if (!fileurl.startsWith(""String_Node_Str"") && new File(fileurl).isFile()) {
    imagePart.rel.setTarget(""String_Node_Str"" + fileurl);
  }
 else {
    imagePart.rel.setTarget(fileurl);
  }
  imagePart.setImageInfo(info);
  return imagePart;
}","/** 
 * Create a linked image part, and attach it as a rel of the specified source part (eg a header part)
 * @param wordMLPackage
 * @param sourcePart
 * @param fileurl
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createLinkedImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,String fileurl) throws Exception {
  ImageInfo info=ensureFormatIsSupported(fileurl,null,null);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  String ext=info.getMimeType().substring(info.getMimeType().indexOf(""String_Node_Str"") + 1);
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),createImageName(sourcePart,proposedRelId,ext),null);
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  imagePart.rel=sourcePart.addTargetPart(imagePart);
  imagePart.rel.setTargetMode(""String_Node_Str"");
  wordMLPackage.getExternalResources().put(imagePart.getExternalTarget(),imagePart);
  if (!fileurl.startsWith(""String_Node_Str"") && new File(fileurl).isFile()) {
    imagePart.rel.setTarget(""String_Node_Str"" + fileurl);
  }
 else {
    imagePart.rel.setTarget(fileurl);
  }
  imagePart.setImageInfo(info);
  return imagePart;
}",0.9985218033998522
185102,"/** 
 * Create a <wp:inline> element suitable for this image, which can be linked or embedded in w:p/w:r/w:drawing, specifying height and width.  Note that you'd ordinarily use one of the methods which don't require you to specify height (cy). 
 * @param filenameHint Any text, for example the original filename
 * @param altText Like HTML's alt text
 * @param id1 An id unique in the document
 * @param id2 Another id unique in the document None of these things seem to be exposed in Word 2007's user interface, but Word won't open the document if any of the attributes these go in (except @ desc) aren't present!
 * @param cx    Image width in twip
 * @param cy    Image height in twip
 * @param link  true if this is to be linked not embedded
 * @throws Exception
 */
public Inline createImageInline(String filenameHint,String altText,int id1,int id2,long cx,long cy,boolean link) throws Exception {
  if (filenameHint == null) {
    filenameHint=""String_Node_Str"";
  }
  if (altText == null) {
    altText=""String_Node_Str"";
  }
  String type;
  if (link) {
    type=""String_Node_Str"";
  }
 else {
    type=""String_Node_Str"";
  }
  String ml=""String_Node_Str"" + namespaces + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  java.util.HashMap<String,String> mappings=new java.util.HashMap<String,String>();
  mappings.put(""String_Node_Str"",Long.toString(cx));
  mappings.put(""String_Node_Str"",Long.toString(cy));
  mappings.put(""String_Node_Str"",filenameHint);
  mappings.put(""String_Node_Str"",altText);
  mappings.put(""String_Node_Str"",rel.getId());
  mappings.put(""String_Node_Str"",Integer.toString(id1));
  mappings.put(""String_Node_Str"",Integer.toString(id2));
  Object o=org.docx4j.XmlUtils.unmarshallFromTemplate(ml,mappings);
  Inline inline=(Inline)((JAXBElement)o).getValue();
  return inline;
}","/** 
 * Create a <wp:inline> element suitable for this image, which can be linked or embedded in w:p/w:r/w:drawing, specifying height and width.  Note that you'd ordinarily use one of the methods which don't require you to specify height (cy). 
 * @param filenameHint Any text, for example the original filename
 * @param altText Like HTML's alt text
 * @param id1 An id unique in the document
 * @param id2 Another id unique in the document None of these things seem to be exposed in Word 2007's user interface, but Word won't open the document if any of the attributes these go in (except @ desc) aren't present!
 * @param cx    Image width in EMU
 * @param cy    Image height in EMU
 * @param link  true if this is to be linked not embedded
 * @throws Exception
 */
public Inline createImageInline(String filenameHint,String altText,int id1,int id2,long cx,long cy,boolean link) throws Exception {
  if (filenameHint == null) {
    filenameHint=""String_Node_Str"";
  }
  if (altText == null) {
    altText=""String_Node_Str"";
  }
  String type;
  if (link) {
    type=""String_Node_Str"";
  }
 else {
    type=""String_Node_Str"";
  }
  String ml=""String_Node_Str"" + namespaces + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  java.util.HashMap<String,String> mappings=new java.util.HashMap<String,String>();
  mappings.put(""String_Node_Str"",Long.toString(cx));
  mappings.put(""String_Node_Str"",Long.toString(cy));
  mappings.put(""String_Node_Str"",filenameHint);
  mappings.put(""String_Node_Str"",altText);
  mappings.put(""String_Node_Str"",rel.getId());
  mappings.put(""String_Node_Str"",Integer.toString(id1));
  mappings.put(""String_Node_Str"",Integer.toString(id2));
  Object o=org.docx4j.XmlUtils.unmarshallFromTemplate(ml,mappings);
  Inline inline=(Inline)((JAXBElement)o).getValue();
  return inline;
}",0.9964194373401536
185103,"/** 
 * Get a Part (except a relationships part), and all its related parts.   This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @param zf
 * @param source
 * @param unusedZipEntries
 * @param pkg
 * @param r
 * @param resolvedPartUri
 * @throws Docx4JException
 * @throws InvalidFormatException
 */
private void getPart(ZipFile zf,OpcPackage pkg,RelationshipsPart rp,Relationship r,ContentTypeManager ctm) throws Docx4JException, InvalidFormatException, URISyntaxException {
  Base source=null;
  String resolvedPartUri=null;
  if (r.getTargetMode() == null || !r.getTargetMode().equals(""String_Node_Str"")) {
    source=rp.getSourceP();
    resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
    resolvedPartUri=resolvedPartUri.substring(1);
  }
 else {
    if (loadExternalTargets && r.getType().equals(Namespaces.IMAGE)) {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      BinaryPart bp=ExternalResourceUtils.getExternalResource(r.getTarget());
      pkg.getExternalResources().put(bp.getExternalTarget(),bp);
    }
 else {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
    }
    return;
  }
  if (pkg.handled.get(resolvedPartUri) != null)   return;
  String relationshipType=r.getType();
  Part part=getRawPart(zf,ctm,resolvedPartUri,r);
  if (part instanceof BinaryPart || part instanceof DefaultXmlPart) {
    part.setRelationshipType(relationshipType);
  }
  rp.loadPart(part,r);
  pkg.handled.put(resolvedPartUri,resolvedPartUri);
  if (source.setPartShortcut(part,relationshipType)) {
    log.info(""String_Node_Str"" + source.getPartName() + ""String_Node_Str""+ part.getPartName());
  }
  RelationshipsPart rrp=getRelationshipsPart(zf,part);
  if (rrp != null) {
    addPartsFromRelationships(zf,part,rrp,ctm);
    String relPart=PartName.getRelationshipsPartName(part.getPartName().getName().substring(1));
  }
}","/** 
 * Get a Part (except a relationships part), and all its related parts.   This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @param zf
 * @param source
 * @param unusedZipEntries
 * @param pkg
 * @param r
 * @param resolvedPartUri
 * @throws Docx4JException
 * @throws InvalidFormatException
 */
private void getPart(ZipFile zf,OpcPackage pkg,RelationshipsPart rp,Relationship r,ContentTypeManager ctm) throws Docx4JException, InvalidFormatException, URISyntaxException {
  Base source=null;
  String resolvedPartUri=null;
  if (r.getType().equals(Namespaces.HYPERLINK)) {
    log.info(""String_Node_Str"" + r.getTarget());
    return;
  }
 else   if (r.getTargetMode() == null || !r.getTargetMode().equals(""String_Node_Str"")) {
    source=rp.getSourceP();
    resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
    resolvedPartUri=resolvedPartUri.substring(1);
  }
 else {
    if (loadExternalTargets && r.getType().equals(Namespaces.IMAGE)) {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      BinaryPart bp=ExternalResourceUtils.getExternalResource(r.getTarget());
      pkg.getExternalResources().put(bp.getExternalTarget(),bp);
    }
 else {
      log.warn(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
    }
    return;
  }
  if (pkg.handled.get(resolvedPartUri) != null)   return;
  String relationshipType=r.getType();
  Part part=getRawPart(zf,ctm,resolvedPartUri,r);
  if (part instanceof BinaryPart || part instanceof DefaultXmlPart) {
    part.setRelationshipType(relationshipType);
  }
  rp.loadPart(part,r);
  pkg.handled.put(resolvedPartUri,resolvedPartUri);
  if (source.setPartShortcut(part,relationshipType)) {
    log.info(""String_Node_Str"" + source.getPartName() + ""String_Node_Str""+ part.getPartName());
  }
  RelationshipsPart rrp=getRelationshipsPart(zf,part);
  if (rrp != null) {
    addPartsFromRelationships(zf,part,rrp,ctm);
    String relPart=PartName.getRelationshipsPartName(part.getPartName().getName().substring(1));
  }
}",0.9712247324613557
185104,"/** 
 * Get a Part (except a relationships part), and all its related parts.   This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @param zf
 * @param source
 * @param unusedZipEntries
 * @param pkg
 * @param r
 * @param resolvedPartUri
 * @throws Docx4JException
 * @throws InvalidFormatException
 */
private void getPart(HashMap<String,ByteArray> partByteArrays,OpcPackage pkg,RelationshipsPart rp,Relationship r,ContentTypeManager ctm) throws Docx4JException, InvalidFormatException, URISyntaxException {
  Base source=null;
  String resolvedPartUri=null;
  if (r.getTargetMode() == null || !r.getTargetMode().equals(""String_Node_Str"")) {
    source=rp.getSourceP();
    resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
    resolvedPartUri=resolvedPartUri.substring(1);
  }
 else {
    if (loadExternalTargets && r.getType().equals(Namespaces.IMAGE)) {
      log.info(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      BinaryPart bp=ExternalResourceUtils.getExternalResource(r.getTarget());
      pkg.getExternalResources().put(bp.getExternalTarget(),bp);
    }
 else {
      log.info(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
    }
    return;
  }
  if (pkg.handled.get(resolvedPartUri) != null)   return;
  String relationshipType=r.getType();
  Part part=getRawPart(partByteArrays,ctm,resolvedPartUri,r);
  if (part instanceof BinaryPart || part instanceof DefaultXmlPart) {
    part.setRelationshipType(relationshipType);
  }
  rp.loadPart(part,r);
  pkg.handled.put(resolvedPartUri,resolvedPartUri);
  if (source.setPartShortcut(part,relationshipType)) {
    log.debug(""String_Node_Str"" + source.getPartName() + ""String_Node_Str""+ part.getPartName());
  }
  RelationshipsPart rrp=getRelationshipsPart(partByteArrays,part);
  if (rrp != null) {
    addPartsFromRelationships(partByteArrays,part,rrp,ctm);
    String relPart=PartName.getRelationshipsPartName(part.getPartName().getName().substring(1));
  }
}","/** 
 * Get a Part (except a relationships part), and all its related parts.   This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @param zf
 * @param source
 * @param unusedZipEntries
 * @param pkg
 * @param r
 * @param resolvedPartUri
 * @throws Docx4JException
 * @throws InvalidFormatException
 */
private void getPart(HashMap<String,ByteArray> partByteArrays,OpcPackage pkg,RelationshipsPart rp,Relationship r,ContentTypeManager ctm) throws Docx4JException, InvalidFormatException, URISyntaxException {
  Base source=null;
  String resolvedPartUri=null;
  if (r.getType().equals(Namespaces.HYPERLINK)) {
    log.info(""String_Node_Str"" + r.getTarget());
    return;
  }
 else   if (r.getTargetMode() == null || !r.getTargetMode().equals(""String_Node_Str"")) {
    source=rp.getSourceP();
    resolvedPartUri=URIHelper.resolvePartUri(rp.getSourceURI(),new URI(r.getTarget())).toString();
    resolvedPartUri=resolvedPartUri.substring(1);
  }
 else {
    if (loadExternalTargets && r.getType().equals(Namespaces.IMAGE)) {
      log.info(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
      BinaryPart bp=ExternalResourceUtils.getExternalResource(r.getTarget());
      pkg.getExternalResources().put(bp.getExternalTarget(),bp);
    }
 else {
      log.info(""String_Node_Str"" + r.getTarget() + ""String_Node_Str""+ r.getType());
    }
    return;
  }
  if (pkg.handled.get(resolvedPartUri) != null)   return;
  String relationshipType=r.getType();
  Part part=getRawPart(partByteArrays,ctm,resolvedPartUri,r);
  if (part instanceof BinaryPart || part instanceof DefaultXmlPart) {
    part.setRelationshipType(relationshipType);
  }
  rp.loadPart(part,r);
  pkg.handled.put(resolvedPartUri,resolvedPartUri);
  if (source.setPartShortcut(part,relationshipType)) {
    log.debug(""String_Node_Str"" + source.getPartName() + ""String_Node_Str""+ part.getPartName());
  }
  RelationshipsPart rrp=getRelationshipsPart(partByteArrays,part);
  if (rrp != null) {
    addPartsFromRelationships(partByteArrays,part,rrp,ctm);
    String relPart=PartName.getRelationshipsPartName(part.getPartName().getName().substring(1));
  }
}",0.9721133901820695
185105,"private static void processDescendantBindings(Object sdt,String xpathBase,int index){
  SdtPr sdtPr=getSdtPr(sdt);
  sdtPr.setId();
  CTDataBinding binding=(CTDataBinding)XmlUtils.unwrap(sdtPr.getDataBinding());
  String thisXPath=null;
  String conditionId=null;
  String repeatId=null;
  String bindingId=null;
  Condition c=null;
  org.opendope.xpaths.Xpaths.Xpath xpathObj=null;
  Tag tag=sdtPr.getTag();
  HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
  if (binding == null) {
    conditionId=map.get(BINDING_ROLE_CONDITIONAL);
    repeatId=map.get(BINDING_ROLE_REPEAT);
    if (conditionId != null) {
      c=ConditionsPart.getConditionById(conditions,conditionId);
      xpathObj=getXPathFromCondition(c);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else     if (repeatId != null) {
      xpathObj=XPathsPart.getXPathById(xPaths,repeatId);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else {
      log.warn(""String_Node_Str"");
      return;
    }
  }
 else {
    thisXPath=binding.getXpath();
    bindingId=map.get(BINDING_ROLE_XPATH);
    xpathObj=XPathsPart.getXPathById(xPaths,bindingId);
    if (!thisXPath.equals(xpathObj.getDataBinding().getXpath())) {
      log.error(""String_Node_Str"" + bindingId + ""String_Node_Str""+ xpathObj.getDataBinding().getXpath());
    }
  }
  log.debug(""String_Node_Str"" + thisXPath);
  if (thisXPath.startsWith(xpathBase)) {
    log.debug(""String_Node_Str"" + xpathBase);
    int beginIndex=thisXPath.indexOf(""String_Node_Str"",xpathBase.length() - 1);
    int endIndex=thisXPath.indexOf(""String_Node_Str"",beginIndex);
    String newPath;
    if (endIndex < 0) {
      newPath=thisXPath + ""String_Node_Str"" + (index + 1)+ ""String_Node_Str"";
    }
 else {
      String startBit=thisXPath.substring(0,endIndex);
      if (startBit.endsWith(""String_Node_Str""))       startBit=startBit.substring(0,startBit.lastIndexOf(""String_Node_Str""));
      newPath=startBit + ""String_Node_Str"" + (index + 1)+ ""String_Node_Str""+ thisXPath.substring(endIndex + 1);
    }
    log.debug(""String_Node_Str"" + newPath + ""String_Node_Str"");
    if (binding == null) {
      if (conditionId != null) {
        Condition newCondition=XmlUtils.deepCopy(c);
        String newConditionId=conditionId + ""String_Node_Str"" + index;
        newCondition.setId(newConditionId);
        conditions.getCondition().add(newCondition);
        map.put(BINDING_ROLE_CONDITIONAL,newConditionId);
        tag.setVal(QueryString.create(map));
        org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
        newCondition.getXpathref().setId(newXPathObj.getId());
      }
 else       if (repeatId != null) {
        org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
        map.put(BINDING_ROLE_REPEAT,newXPathObj.getId());
        tag.setVal(QueryString.create(map));
      }
    }
 else {
      binding.setXpath(newPath);
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
  }
 else {
    log.debug(""String_Node_Str"" + xpathBase + ""String_Node_Str"");
  }
}","private static void processDescendantBindings(Object sdt,String xpathBase,int index){
  SdtPr sdtPr=getSdtPr(sdt);
  sdtPr.setId();
  CTDataBinding binding=(CTDataBinding)XmlUtils.unwrap(sdtPr.getDataBinding());
  String thisXPath=null;
  String conditionId=null;
  String repeatId=null;
  String bindingId=null;
  Condition c=null;
  org.opendope.xpaths.Xpaths.Xpath xpathObj=null;
  Tag tag=sdtPr.getTag();
  HashMap<String,String> map=QueryString.parseQueryString(tag.getVal(),true);
  if (binding == null) {
    conditionId=map.get(BINDING_ROLE_CONDITIONAL);
    repeatId=map.get(BINDING_ROLE_REPEAT);
    if (conditionId != null) {
      c=ConditionsPart.getConditionById(conditions,conditionId);
      if (c == null) {
        log.error(""String_Node_Str"" + conditionId);
      }
      log.debug(""String_Node_Str"" + XmlUtils.marshaltoString(c,true,true));
      xpathObj=getXPathFromCondition(c);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else     if (repeatId != null) {
      xpathObj=XPathsPart.getXPathById(xPaths,repeatId);
      thisXPath=xpathObj.getDataBinding().getXpath();
    }
 else {
      log.warn(""String_Node_Str"");
      return;
    }
  }
 else {
    thisXPath=binding.getXpath();
    bindingId=map.get(BINDING_ROLE_XPATH);
    xpathObj=XPathsPart.getXPathById(xPaths,bindingId);
    if (!thisXPath.equals(xpathObj.getDataBinding().getXpath())) {
      log.error(""String_Node_Str"" + bindingId + ""String_Node_Str""+ xpathObj.getDataBinding().getXpath());
    }
  }
  log.debug(""String_Node_Str"" + thisXPath);
  if (!thisXPath.startsWith(xpathBase)) {
    log.debug(""String_Node_Str"" + xpathBase + ""String_Node_Str"");
    return;
  }
  log.debug(""String_Node_Str"" + xpathBase);
  int beginIndex=thisXPath.indexOf(""String_Node_Str"",xpathBase.length() - 1);
  int endIndex=-2;
  if (beginIndex > 0) {
    endIndex=thisXPath.indexOf(""String_Node_Str"",beginIndex);
  }
  log.debug(""String_Node_Str"" + beginIndex);
  log.debug(""String_Node_Str"" + endIndex);
  String newPath;
  if (endIndex < beginIndex) {
    String startBit=thisXPath;
    if (startBit.endsWith(""String_Node_Str""))     startBit=startBit.substring(0,startBit.lastIndexOf(""String_Node_Str""));
    newPath=startBit + ""String_Node_Str"" + (index + 1)+ ""String_Node_Str"";
  }
 else {
    String startBit=thisXPath.substring(0,endIndex);
    if (startBit.endsWith(""String_Node_Str""))     startBit=startBit.substring(0,startBit.lastIndexOf(""String_Node_Str""));
    newPath=startBit + ""String_Node_Str"" + (index + 1)+ ""String_Node_Str""+ thisXPath.substring(endIndex + 1);
  }
  log.debug(""String_Node_Str"" + newPath + ""String_Node_Str"");
  if (binding == null) {
    if (conditionId != null) {
      Condition newCondition=XmlUtils.deepCopy(c);
      String newConditionId=conditionId + ""String_Node_Str"" + index;
      newCondition.setId(newConditionId);
      conditions.getCondition().add(newCondition);
      map.put(BINDING_ROLE_CONDITIONAL,newConditionId);
      tag.setVal(QueryString.create(map));
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      newCondition.getXpathref().setId(newXPathObj.getId());
    }
 else     if (repeatId != null) {
      org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
      map.put(BINDING_ROLE_REPEAT,newXPathObj.getId());
      tag.setVal(QueryString.create(map));
    }
  }
 else {
    binding.setXpath(newPath);
    org.opendope.xpaths.Xpaths.Xpath newXPathObj=createNewXPathObject(newPath,xpathObj,index);
    map.put(BINDING_ROLE_XPATH,newXPathObj.getId());
    tag.setVal(QueryString.create(map));
  }
}",0.8565621370499419
185106,"/** 
 * Preprocess content controls which have tag ""od:condition|od:repeat"". The algorithm is as follows: Look at each top level SDT (ShallowTraversor).   If it does not have a real data binding, it might have a bindingrole tag we need to process (processBindingRoleIfAny). Conditionals are easy. processRepeat method: - clones the sdt n times - invokes DeepTraversor which changes xpath binding on descendant sdts (both sdts with real bindings and sdts with bindingrole tags). It is not the job of DeepTraversor to expand out any other repeats it might encounter, or to resolve conditionals. Those things are done by ShallowTraversor, to which control returns, as it continues its traverse. The implementation of 13 Sept 2010 replaced the previous XPath based implementation, which did not support nested repeats.  I've chosen to build this around TraversalUtil, instead of using XSLT, and this seems to have worked out nicely. The implementation of 10 October 2010 replaced the v1 conventions implementation with a v2 implementation.  The main method in this class can convert v1 documents to v2. The v2 implementation is not yet complete. All v1 features are implemented, but not the new v2 stuff (eg complex conditions).
 * @param documentPart
 * @throws Docx4JException
 */
public static void preprocess(WordprocessingMLPackage wordMLPackage) throws Docx4JException {
  MainDocumentPart documentPart=wordMLPackage.getMainDocumentPart();
  if (wordMLPackage.getMainDocumentPart().getXPathsPart() == null) {
    throw new Docx4JException(""String_Node_Str"");
  }
 else {
    xPaths=wordMLPackage.getMainDocumentPart().getXPathsPart().getJaxbElement();
  }
  if (wordMLPackage.getMainDocumentPart().getConditionsPart() != null) {
    conditions=wordMLPackage.getMainDocumentPart().getConditionsPart().getJaxbElement();
  }
  org.docx4j.wml.Document wmlDocumentEl=(org.docx4j.wml.Document)documentPart.getJaxbElement();
  Body body=wmlDocumentEl.getBody();
  shallowTraversor.wordMLPackage=wordMLPackage;
  new TraversalUtil(body,shallowTraversor);
}","/** 
 * Preprocess content controls which have tag ""od:condition|od:repeat"". The algorithm is as follows: Look at each top level SDT (ShallowTraversor).   If it does not have a real data binding, it might have a bindingrole tag we need to process (processBindingRoleIfAny). Conditionals are easy. processRepeat method: - clones the sdt n times - invokes DeepTraversor which changes xpath binding on descendant sdts (both sdts with real bindings and sdts with bindingrole tags). It is not the job of DeepTraversor to expand out any other repeats it might encounter, or to resolve conditionals. Those things are done by ShallowTraversor, to which control returns, as it continues its traverse. The implementation of 13 Sept 2010 replaced the previous XPath based implementation, which did not support nested repeats.  I've chosen to build this around TraversalUtil, instead of using XSLT, and this seems to have worked out nicely. The implementation of 10 October 2010 replaced the v1 conventions implementation with a v2 implementation.  The main method in this class can convert v1 documents to v2. The v2 implementation is not yet complete. All v1 features are implemented, but not the new v2 stuff (eg complex conditions).
 * @param documentPart
 * @throws Docx4JException
 */
public static void preprocess(WordprocessingMLPackage wordMLPackage) throws Docx4JException {
  MainDocumentPart documentPart=wordMLPackage.getMainDocumentPart();
  if (wordMLPackage.getMainDocumentPart().getXPathsPart() == null) {
    throw new Docx4JException(""String_Node_Str"");
  }
 else {
    xPaths=wordMLPackage.getMainDocumentPart().getXPathsPart().getJaxbElement();
    log.debug(XmlUtils.marshaltoString(xPaths,true,true));
  }
  if (wordMLPackage.getMainDocumentPart().getConditionsPart() != null) {
    conditions=wordMLPackage.getMainDocumentPart().getConditionsPart().getJaxbElement();
    log.debug(XmlUtils.marshaltoString(conditions,true,true));
  }
  org.docx4j.wml.Document wmlDocumentEl=(org.docx4j.wml.Document)documentPart.getJaxbElement();
  Body body=wmlDocumentEl.getBody();
  shallowTraversor.wordMLPackage=wordMLPackage;
  new TraversalUtil(body,shallowTraversor);
}",0.9711037423022264
185107,"public static org.opendope.xpaths.Xpaths.Xpath getXPathFromCondition(Condition c){
  org.opendope.conditions.Xpathref xpathRef=c.getXpathref();
  return XPathsPart.getXPathById(xPaths,xpathRef.getId());
}","public static org.opendope.xpaths.Xpaths.Xpath getXPathFromCondition(Condition c){
  org.opendope.conditions.Xpathref xpathRef=c.getXpathref();
  if (xpathRef == null) {
    log.error(""String_Node_Str"" + c.getId() + ""String_Node_Str"");
  }
  return XPathsPart.getXPathById(xPaths,xpathRef.getId());
}",0.8095238095238095
185108,"/** 
 * This applies to any sdt which might be a conditional|repeat
 * @param wordMLPackage
 * @param sdtParent
 * @param sdt
 * @param tag
 * @param sdtContent
 * @return
 */
private static List<Object> processBindingRoleIfAny(WordprocessingMLPackage wordMLPackage,Object sdt){
  Tag tag=getSdtPr(sdt).getTag();
  if (tag == null) {
    List<Object> newContent=new ArrayList<Object>();
    newContent.add(sdt);
    return newContent;
  }
  log.info(tag.getVal());
  QueryString qs=new QueryString();
  HashMap<String,String> map=qs.parseQueryString(tag.getVal(),true);
  String conditionId=map.get(BINDING_ROLE_CONDITIONAL);
  String repeatId=map.get(BINDING_ROLE_REPEAT);
  if (conditionId == null && repeatId == null) {
    List<Object> newContent=new ArrayList<Object>();
    newContent.add(sdt);
    return newContent;
  }
  Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts=wordMLPackage.getCustomXmlDataStorageParts();
  if (conditionId != null) {
    log.info(""String_Node_Str"" + tag.getVal());
    Condition c=ConditionsPart.getConditionById(conditions,conditionId);
    org.opendope.xpaths.Xpaths.Xpath xpath=getXPathFromCondition(c);
    String val=xpathGetString(customXmlDataStorageParts,xpath.getDataBinding().getStoreItemID(),xpath.getDataBinding().getXpath(),xpath.getDataBinding().getPrefixMappings());
    log.info(""String_Node_Str"" + val);
    if (new Boolean(val)) {
      log.debug(""String_Node_Str"");
      List<Object> newContent=new ArrayList<Object>();
      newContent.add(sdt);
      return newContent;
    }
 else {
      if (sdt instanceof org.docx4j.wml.CTSdtCell) {
        CTSdtContentCell sdtCellContent=((org.docx4j.wml.CTSdtCell)sdt).getSdtContent();
        Tc tc=(Tc)XmlUtils.unwrap(sdtCellContent.getEGContentCellContent().get(0));
        tc.getEGBlockLevelElts().clear();
        P p=Context.getWmlObjectFactory().createP();
        tc.getEGBlockLevelElts().add(p);
        List<Object> newContent=new ArrayList<Object>();
        newContent.add(tc);
        return newContent;
      }
 else {
        return new ArrayList<Object>();
      }
    }
  }
 else   if (repeatId != null) {
    log.info(""String_Node_Str"" + tag.getVal());
    return processRepeat(sdt,customXmlDataStorageParts,wordMLPackage.getMainDocumentPart().getXPathsPart());
  }
  return null;
}","/** 
 * This applies to any sdt which might be a conditional|repeat
 * @param wordMLPackage
 * @param sdtParent
 * @param sdt
 * @param tag
 * @param sdtContent
 * @return
 */
private static List<Object> processBindingRoleIfAny(WordprocessingMLPackage wordMLPackage,Object sdt){
  Tag tag=getSdtPr(sdt).getTag();
  if (tag == null) {
    List<Object> newContent=new ArrayList<Object>();
    newContent.add(sdt);
    return newContent;
  }
  log.info(tag.getVal());
  QueryString qs=new QueryString();
  HashMap<String,String> map=qs.parseQueryString(tag.getVal(),true);
  String conditionId=map.get(BINDING_ROLE_CONDITIONAL);
  String repeatId=map.get(BINDING_ROLE_REPEAT);
  if (conditionId == null && repeatId == null) {
    List<Object> newContent=new ArrayList<Object>();
    newContent.add(sdt);
    return newContent;
  }
  Map<String,CustomXmlDataStoragePart> customXmlDataStorageParts=wordMLPackage.getCustomXmlDataStorageParts();
  if (conditionId != null) {
    log.info(""String_Node_Str"" + tag.getVal());
    Condition c=ConditionsPart.getConditionById(conditions,conditionId);
    if (c == null) {
      log.error(""String_Node_Str"" + conditionId);
    }
    org.opendope.xpaths.Xpaths.Xpath xpath=getXPathFromCondition(c);
    String val=xpathGetString(customXmlDataStorageParts,xpath.getDataBinding().getStoreItemID(),xpath.getDataBinding().getXpath(),xpath.getDataBinding().getPrefixMappings());
    log.info(""String_Node_Str"" + val);
    if (new Boolean(val)) {
      log.debug(""String_Node_Str"");
      List<Object> newContent=new ArrayList<Object>();
      newContent.add(sdt);
      return newContent;
    }
 else {
      if (sdt instanceof org.docx4j.wml.CTSdtCell) {
        CTSdtContentCell sdtCellContent=((org.docx4j.wml.CTSdtCell)sdt).getSdtContent();
        Tc tc=(Tc)XmlUtils.unwrap(sdtCellContent.getEGContentCellContent().get(0));
        tc.getEGBlockLevelElts().clear();
        P p=Context.getWmlObjectFactory().createP();
        tc.getEGBlockLevelElts().add(p);
        List<Object> newContent=new ArrayList<Object>();
        newContent.add(tc);
        return newContent;
      }
 else {
        return new ArrayList<Object>();
      }
    }
  }
 else   if (repeatId != null) {
    log.info(""String_Node_Str"" + tag.getVal());
    return processRepeat(sdt,customXmlDataStorageParts,wordMLPackage.getMainDocumentPart().getXPathsPart());
  }
  return null;
}",0.983634431455898
185109,"/** 
 * Create an image part from the provided byte array, attach it to the source part (eg the main document part, a header part etc), and return it.
 * @param wordMLPackage
 * @param sourcePart
 * @param bytes
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,byte[] bytes) throws Exception {
  File tmpImageFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileOutputStream fos=new FileOutputStream(tmpImageFile);
  fos.write(bytes);
  fos.close();
  log.debug(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
  ImageInfo info=ensureFormatIsSupported(tmpImageFile.getAbsolutePath(),tmpImageFile,bytes);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  if (sourcePart.getRelationshipsPart() == null)   RelationshipsPart.createRelationshipsPartForPart(sourcePart);
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),IMAGE_PREFIX + proposedRelId);
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  FileInputStream fis=new FileInputStream(tmpImageFile);
  imagePart.setBinaryData(fis);
  imagePart.rel=sourcePart.addTargetPart(imagePart,proposedRelId);
  imagePart.setImageInfo(info);
  fos=null;
  fis=null;
  System.gc();
  if (tmpImageFile.delete()) {
    log.debug(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
  }
 else {
    log.warn(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
    tmpImageFile.deleteOnExit();
  }
  return imagePart;
}","/** 
 * Create an image part from the provided byte array, attach it to the source part (eg the main document part, a header part etc), and return it.
 * @param wordMLPackage
 * @param sourcePart
 * @param bytes
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,byte[] bytes) throws Exception {
  File tmpImageFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileOutputStream fos=new FileOutputStream(tmpImageFile);
  fos.write(bytes);
  fos.close();
  log.debug(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
  ImageInfo info=ensureFormatIsSupported(tmpImageFile.getAbsolutePath(),tmpImageFile,bytes);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  if (sourcePart.getRelationshipsPart() == null)   RelationshipsPart.createRelationshipsPartForPart(sourcePart);
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),createImageName(sourcePart,proposedRelId));
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  FileInputStream fis=new FileInputStream(tmpImageFile);
  imagePart.setBinaryData(fis);
  imagePart.rel=sourcePart.addTargetPart(imagePart,proposedRelId);
  imagePart.setImageInfo(info);
  fos=null;
  fis=null;
  System.gc();
  if (tmpImageFile.delete()) {
    log.debug(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
  }
 else {
    log.warn(""String_Node_Str"" + tmpImageFile.getAbsolutePath());
    tmpImageFile.deleteOnExit();
  }
  return imagePart;
}",0.980195093112622
185110,"/** 
 * Create a linked image part, and attach it as a rel of the specified source part (eg a header part)
 * @param wordMLPackage
 * @param sourcePart
 * @param fileurl
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createLinkedImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,String fileurl) throws Exception {
  ImageInfo info=ensureFormatIsSupported(fileurl,null,null);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),IMAGE_PREFIX + proposedRelId);
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  imagePart.rel=sourcePart.addTargetPart(imagePart);
  imagePart.rel.setTargetMode(""String_Node_Str"");
  wordMLPackage.getExternalResources().put(imagePart.getExternalTarget(),imagePart);
  if (!fileurl.startsWith(""String_Node_Str"") && new File(fileurl).isFile()) {
    imagePart.rel.setTarget(""String_Node_Str"" + fileurl);
  }
 else {
    imagePart.rel.setTarget(fileurl);
  }
  imagePart.setImageInfo(info);
  return imagePart;
}","/** 
 * Create a linked image part, and attach it as a rel of the specified source part (eg a header part)
 * @param wordMLPackage
 * @param sourcePart
 * @param fileurl
 * @return
 * @throws Exception
 */
public static BinaryPartAbstractImage createLinkedImagePart(WordprocessingMLPackage wordMLPackage,Part sourcePart,String fileurl) throws Exception {
  ImageInfo info=ensureFormatIsSupported(fileurl,null,null);
  ContentTypeManager ctm=wordMLPackage.getContentTypeManager();
  String proposedRelId=sourcePart.getRelationshipsPart().getNextId();
  BinaryPartAbstractImage imagePart=(BinaryPartAbstractImage)ctm.newPartForContentType(info.getMimeType(),createImageName(sourcePart,proposedRelId));
  log.debug(""String_Node_Str"" + imagePart.getClass().getName() + ""String_Node_Str""+ imagePart.getPartName().toString());
  imagePart.rel=sourcePart.addTargetPart(imagePart);
  imagePart.rel.setTargetMode(""String_Node_Str"");
  wordMLPackage.getExternalResources().put(imagePart.getExternalTarget(),imagePart);
  if (!fileurl.startsWith(""String_Node_Str"") && new File(fileurl).isFile()) {
    imagePart.rel.setTarget(""String_Node_Str"" + fileurl);
  }
 else {
    imagePart.rel.setTarget(fileurl);
  }
  imagePart.setImageInfo(info);
  return imagePart;
}",0.9747089522280208
185111,"public static void createHeaderReference(WordprocessingMLPackage wordprocessingMLPackage,Relationship relationship) throws InvalidFormatException {
  SectPr sectPr=objectFactory.createSectPr();
  HeaderReference headerReference=objectFactory.createHeaderReference();
  headerReference.setId(relationship.getId());
  headerReference.setType(HdrFtrRef.DEFAULT);
  sectPr.getEGHdrFtrReferences().add(headerReference);
  wordprocessingMLPackage.getMainDocumentPart().addObject(sectPr);
}","public static void createHeaderReference(WordprocessingMLPackage wordprocessingMLPackage,Relationship relationship) throws InvalidFormatException {
  List<SectionWrapper> sections=wordprocessingMLPackage.getDocumentModel().getSections();
  SectPr sectPr=sections.get(sections.size() - 1).getSectPr();
  if (sectPr == null) {
    sectPr=objectFactory.createSectPr();
    wordprocessingMLPackage.getMainDocumentPart().addObject(sectPr);
    sections.get(sections.size() - 1).setSectPr(sectPr);
  }
  HeaderReference headerReference=objectFactory.createHeaderReference();
  headerReference.setId(relationship.getId());
  headerReference.setType(HdrFtrRef.DEFAULT);
  sectPr.getEGHdrFtrReferences().add(headerReference);
}",0.6894254787676936
185112,"protected Document createXslFoImageElement(){
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    Document document=factory.newDocumentBuilder().newDocument();
    Element imageElement=document.createElementNS(""String_Node_Str"",""String_Node_Str"");
    if (src != null && !src.equals(""String_Node_Str"")) {
      imageElement.setAttribute(""String_Node_Str"",src);
    }
    if (dimensions.width > 0) {
      imageElement.setAttribute(""String_Node_Str"",Integer.toString(dimensions.width) + dimensions.widthUnit);
    }
    if (dimensions.height > 0) {
      imageElement.setAttribute(""String_Node_Str"",Integer.toString(dimensions.height) + dimensions.heightUnit);
    }
    document.appendChild(imageElement);
    return document;
  }
 catch (  Exception e) {
    log.error(e);
    return null;
  }
}","protected Document createXslFoImageElement(){
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    Document document=factory.newDocumentBuilder().newDocument();
    Element imageElement=document.createElementNS(""String_Node_Str"",""String_Node_Str"");
    if (src != null && !src.equals(""String_Node_Str"")) {
      imageElement.setAttribute(""String_Node_Str"",src);
    }
 else {
      log.error(""String_Node_Str"");
    }
    if (dimensions.width > 0) {
      imageElement.setAttribute(""String_Node_Str"",Integer.toString(dimensions.width) + dimensions.widthUnit);
    }
    if (dimensions.height > 0) {
      imageElement.setAttribute(""String_Node_Str"",Integer.toString(dimensions.height) + dimensions.heightUnit);
    }
    document.appendChild(imageElement);
    return document;
  }
 catch (  Exception e) {
    log.error(e);
    return null;
  }
}",0.9707259953161592
185113,"private void findImageData(){
  if (shape.getAny() == null) {
    System.out.println(""String_Node_Str"" + XmlUtils.marshaltoString(shape,true));
  }
 else {
    for (    Object o : shape.getAny()) {
      if (o instanceof JAXBElement) {
        JAXBElement jb=(JAXBElement)o;
        if (jb.getDeclaredType().getName().equals(""String_Node_Str"")) {
          imageData=(CTImageData)jb.getValue();
          break;
        }
 else {
          log.info(""String_Node_Str"" + XmlUtils.JAXBElementDebug((JAXBElement)o));
        }
      }
 else {
        log.error(o.getClass().getName());
      }
    }
  }
}","private void findImageData(){
  if (shape.getAny() == null) {
    System.out.println(""String_Node_Str"" + XmlUtils.marshaltoString(shape,true));
  }
 else {
    for (    Object o : shape.getAny()) {
      if (o instanceof JAXBElement) {
        JAXBElement jb=(JAXBElement)o;
        if (jb.getDeclaredType().getName().equals(""String_Node_Str"")) {
          imageData=(CTImageData)jb.getValue();
          break;
        }
 else {
          log.debug(""String_Node_Str"" + XmlUtils.JAXBElementDebug((JAXBElement)o));
        }
      }
 else {
        log.error(o.getClass().getName());
      }
    }
  }
}",0.9925187032418952
185114,"/** 
 * Extension function to create an <img> element from ""E1.0 images"" //w:pict
 * @param wmlPackage
 * @param imageDirPath
 * @param shape
 * @param imageData
 * @return
 */
public static DocumentFragment createXslFoImgE10(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator wpict){
  WordXmlPictureE10 converter=createWordXmlPictureFromE10(wmlPackage,imageDirPath,wpict);
  if (converter == null) {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    Document d;
    try {
      d=factory.newDocumentBuilder().newDocument();
      return d.createDocumentFragment();
    }
 catch (    ParserConfigurationException e) {
      log.error(e);
      return null;
    }
  }
 else {
    Document d=converter.createXslFoImageElement();
    DocumentFragment docfrag=d.createDocumentFragment();
    docfrag.appendChild(d.getDocumentElement());
    return docfrag;
  }
}","/** 
 * Extension function to create an <img> element from ""E1.0 images"" //w:pict
 * @param wmlPackage
 * @param imageDirPath
 * @param shape
 * @param imageData
 * @return
 */
public static DocumentFragment createXslFoImgE10(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator wpict){
  WordXmlPictureE10 converter=createWordXmlPictureFromE10(wmlPackage,imageDirPath,wpict);
  log.debug(""String_Node_Str"" + imageDirPath);
  if (converter == null) {
    log.error(""String_Node_Str"");
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    Document d;
    try {
      d=factory.newDocumentBuilder().newDocument();
      return d.createDocumentFragment();
    }
 catch (    ParserConfigurationException e) {
      log.error(e);
      return null;
    }
  }
 else {
    Document d=converter.createXslFoImageElement();
    DocumentFragment docfrag=d.createDocumentFragment();
    docfrag.appendChild(d.getDocumentElement());
    return docfrag;
  }
}",0.9570747217806042
185115,"private static WordXmlPictureE10 createWordXmlPictureFromE10(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator wpict){
  WordXmlPictureE10 converter=new WordXmlPictureE10(wmlPackage,wpict);
  converter.findShape();
  if (converter.shape == null) {
    log.error(""String_Node_Str"");
    return null;
  }
  converter.readStandardAttributes(converter.shape);
  converter.readDimensions(converter.style);
  converter.findImageData();
  if (converter.imageData == null) {
    log.error(""String_Node_Str"");
    return null;
  }
  String imgRelId=converter.imageData.getId();
  if (imgRelId != null && !imgRelId.equals(""String_Node_Str"")) {
    converter.handleImageRel(imgRelId,imageDirPath);
  }
  return converter;
}","private static WordXmlPictureE10 createWordXmlPictureFromE10(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator wpict){
  WordXmlPictureE10 converter=new WordXmlPictureE10(wmlPackage,wpict);
  converter.findShape();
  if (converter.shape == null) {
    log.error(""String_Node_Str"");
    return null;
  }
  converter.readStandardAttributes(converter.shape);
  converter.readDimensions(converter.style);
  converter.findImageData();
  if (converter.imageData == null) {
    log.error(""String_Node_Str"");
    return null;
  }
  String imgRelId=converter.imageData.getOtherAttributes().get(new QName(""String_Node_Str"",""String_Node_Str""));
  if (imgRelId != null && !imgRelId.equals(""String_Node_Str"")) {
    log.debug(""String_Node_Str"" + imgRelId);
    converter.handleImageRel(imgRelId,imageDirPath);
  }
 else {
    log.error(""String_Node_Str"");
  }
  return converter;
}",0.8762376237623762
185116,"/** 
 * Connection (line)
 */
public static Document CxnSpToSVG(CxnSp cxnSp){
  CTTransform2D xfrm=cxnSp.getSpPr().getXfrm();
  Box b=new Box(xfrm.getOff().getX(),xfrm.getOff().getY(),xfrm.getExt().getCx(),xfrm.getExt().getCx());
  if (xfrm.getRot() != 0) {
    b.rotate(xfrm.getRot());
  }
  if (xfrm.isFlipH()) {
    b.flipH();
  }
  if (xfrm.isFlipV()) {
    b.flipV();
  }
  b.toPixels();
  Document document=createDocument();
  Element xhtmlDiv=document.createElement(""String_Node_Str"");
  xhtmlDiv.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Node n=document.appendChild(xhtmlDiv);
  Svg svg=oFactory.createSvg();
  Line line=oFactory.createLine();
  svg.getSVGDescriptionClassOrSVGAnimationClassOrSVGStructureClass().add(line);
  line.setX1(b.getOffset().getXAsString());
  line.setY1(b.getOffset().getYAsString());
  Point otherEnd=b.getOtherCorner();
  line.setX2(otherEnd.getXAsString());
  line.setY2(otherEnd.getYAsString());
  line.setStyle(""String_Node_Str"");
  Document d2=XmlUtils.marshaltoW3CDomDocument(svg,jcSVG);
  XmlUtils.treeCopy(d2,n);
  return document;
}","/** 
 * Connection (line)
 */
public static Document CxnSpToSVG(CxnSp cxnSp){
  CTTransform2D xfrm=cxnSp.getSpPr().getXfrm();
  Box b=new Box(xfrm.getOff().getX(),xfrm.getOff().getY(),xfrm.getExt().getCx(),xfrm.getExt().getCy());
  if (xfrm.getRot() != 0) {
    b.rotate(xfrm.getRot());
  }
  if (xfrm.isFlipH()) {
    b.flipH();
  }
  if (xfrm.isFlipV()) {
    b.flipV();
  }
  b.toPixels();
  Document document=createDocument();
  Element xhtmlDiv=document.createElement(""String_Node_Str"");
  xhtmlDiv.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Node n=document.appendChild(xhtmlDiv);
  Svg svg=oFactory.createSvg();
  Line line=oFactory.createLine();
  svg.getSVGDescriptionClassOrSVGAnimationClassOrSVGStructureClass().add(line);
  line.setX1(b.getOffset().getXAsString());
  line.setY1(b.getOffset().getYAsString());
  Point otherEnd=b.getOtherCorner();
  line.setX2(otherEnd.getXAsString());
  line.setY2(otherEnd.getYAsString());
  line.setStyle(""String_Node_Str"");
  Document d2=XmlUtils.marshaltoW3CDomDocument(svg,jcSVG);
  XmlUtils.treeCopy(d2,n);
  return document;
}",0.9990808823529412
185117,"public String getDefaultFont(){
  if (defaultFont != null) {
    defaultFont=mainDoc.getPropertyResolver().getDefaultFont();
  }
  return defaultFont;
}","public String getDefaultFont(){
  if (defaultFont == null) {
    defaultFont=mainDoc.getPropertyResolver().getDefaultFont();
    log.debug(""String_Node_Str"" + defaultFont);
  }
  return defaultFont;
}",0.8579545454545454
185118,"/** 
 * Build a StyleTree for stylesInUse. 
 * @param stylesInUse
 * @param allStyles
 */
public StyleTree(List<String> stylesInUse,Map<String,Style> allStyles){
  for (  String styleId : stylesInUse) {
    if (pTree.get(styleId) == null) {
      Style style=allStyles.get(styleId);
      if (style == null) {
        log.error(""String_Node_Str"" + styleId);
        continue;
      }
      if (style.getType().equals(""String_Node_Str"")) {
        this.addNode(styleId,allStyles,pTree);
      }
    }
  }
  for (  String styleId : stylesInUse) {
    if (cTree.get(styleId) == null) {
      Style style=allStyles.get(styleId);
      if (style == null) {
        log.error(""String_Node_Str"" + styleId);
        continue;
      }
      if (style.getType().equals(""String_Node_Str"")) {
        this.addNode(styleId,allStyles,cTree);
      }
    }
  }
}","/** 
 * Build a StyleTree for stylesInUse. 
 * @param stylesInUse
 * @param allStyles
 */
public StyleTree(List<String> stylesInUse,Map<String,Style> allStyles){
  stylesInUse.add(""String_Node_Str"");
  for (  String styleId : stylesInUse) {
    if (pTree.get(styleId) == null) {
      Style style=allStyles.get(styleId);
      if (style == null) {
        log.error(""String_Node_Str"" + styleId);
        continue;
      }
      if (style.getType().equals(""String_Node_Str"")) {
        this.addNode(styleId,allStyles,pTree);
      }
    }
  }
  stylesInUse.add(""String_Node_Str"");
  for (  String styleId : stylesInUse) {
    if (cTree.get(styleId) == null) {
      Style style=allStyles.get(styleId);
      if (style == null) {
        log.error(""String_Node_Str"" + styleId);
        continue;
      }
      if (style.getType().equals(""String_Node_Str"")) {
        this.addNode(styleId,allStyles,cTree);
      }
    }
  }
}",0.9570621468926552
185119,"public static Property createPropertyFromCssName(String name,CSSValue value){
  if (name.equals(Font.CSS_NAME)) {
    return new Font(value);
  }
 else   if (name.equals(Bold.CSS_NAME)) {
    return new Bold(value);
  }
 else   if (name.equals(Italics.CSS_NAME)) {
    return new Italics(value);
  }
 else   if (name.equals(Strike.CSS_NAME)) {
    return new Strike(value);
  }
 else   if (name.equals(FontColor.CSS_NAME)) {
    return new FontColor(value);
  }
 else   if (name.equals(FontSize.CSS_NAME)) {
    return new FontSize(value);
  }
 else   if (name.equals(Underline.CSS_NAME)) {
    return new Underline(value);
  }
  if (name.equals(Indent.CSS_NAME)) {
    return new Indent(value);
  }
 else   if (name.equals(Justification.CSS_NAME)) {
    return new Justification(value);
  }
 else   if (name.equals(KeepNext.CSS_NAME)) {
    return new KeepNext(value);
  }
 else   if (name.equals(PageBreakBefore.CSS_NAME)) {
    return new PageBreakBefore(value);
  }
 else   if (name.equals(TextAlignmentVertical.CSS_NAME)) {
    return new TextAlignmentVertical(value);
  }
  log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
  return null;
}","public static Property createPropertyFromCssName(String name,CSSValue value){
  if (name.equals(Font.CSS_NAME)) {
    return new Font(value);
  }
 else   if (name.equals(Bold.CSS_NAME)) {
    return new Bold(value);
  }
 else   if (name.equals(Italics.CSS_NAME)) {
    return new Italics(value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (value.getCssText().toLowerCase().equals(""String_Node_Str"")) {
      return new Strike(value);
    }
 else     if (value.getCssText().toLowerCase().equals(""String_Node_Str"")) {
      return new Underline(value);
    }
 else {
      log.error(""String_Node_Str"" + name + ""String_Node_Str""+ value.getCssText());
    }
  }
 else   if (name.equals(FontColor.CSS_NAME)) {
    return new FontColor(value);
  }
 else   if (name.equals(FontSize.CSS_NAME)) {
    return new FontSize(value);
  }
  if (name.equals(Indent.CSS_NAME)) {
    return new Indent(value);
  }
 else   if (name.equals(Justification.CSS_NAME)) {
    return new Justification(value);
  }
 else   if (name.equals(KeepNext.CSS_NAME)) {
    return new KeepNext(value);
  }
 else   if (name.equals(PageBreakBefore.CSS_NAME)) {
    return new PageBreakBefore(value);
  }
 else   if (name.equals(TextAlignmentVertical.CSS_NAME)) {
    return new TextAlignmentVertical(value);
  }
  log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
  return null;
}",0.6364359586316627
185120,"public Underline(CSSValue value){
  debug(CSS_NAME,value);
}","public Underline(CSSValue value){
  debug(CSS_NAME,value);
  U u=Context.getWmlObjectFactory().createU();
  if (value.getCssText().toLowerCase().equals(""String_Node_Str"")) {
    u.setVal(UnderlineEnumeration.SINGLE);
  }
 else   if (value.getCssText().toLowerCase().equals(""String_Node_Str"")) {
    u.setVal(UnderlineEnumeration.NONE);
  }
 else {
    log.error(""String_Node_Str"" + CSS_NAME + ""String_Node_Str""+ value.getCssText().toLowerCase());
  }
  this.setObject(u);
}",0.225140712945591
185121,"/** 
 * Clone this JAXB object
 * @param value
 * @param jc
 * @return
 */
public static <T>T deepCopy(T value,JAXBContext jc){
  try {
    JAXBElement<?> elem;
    Class<?> valueClass;
    if (value instanceof JAXBElement<?>) {
      log.debug(""String_Node_Str"");
      elem=(JAXBElement<?>)value;
      valueClass=elem.getDeclaredType();
    }
 else {
      log.debug(""String_Node_Str"" + value.getClass().getName());
      @SuppressWarnings(""String_Node_Str"") Class<T> classT=(Class<T>)value.getClass();
      elem=new JAXBElement<T>(new QName(""String_Node_Str""),classT,value);
      valueClass=classT;
    }
    Marshaller mar=Context.jc.createMarshaller();
    ByteArrayOutputStream bout=new ByteArrayOutputStream(256);
    mar.marshal(elem,bout);
    Unmarshaller unmar=Context.jc.createUnmarshaller();
    elem=unmar.unmarshal(new StreamSource(new ByteArrayInputStream(bout.toByteArray())),valueClass);
    T res;
    if (value instanceof JAXBElement<?>) {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem;
      res=resT;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem.getValue();
      res=resT;
    }
    log.info(""String_Node_Str"");
    return res;
  }
 catch (  JAXBException ex) {
    throw new IllegalArgumentException(ex);
  }
}","/** 
 * Clone this JAXB object
 * @param value
 * @param jc
 * @return
 */
public static <T>T deepCopy(T value,JAXBContext jc){
  try {
    JAXBElement<?> elem;
    Class<?> valueClass;
    if (value instanceof JAXBElement<?>) {
      log.debug(""String_Node_Str"");
      elem=(JAXBElement<?>)value;
      valueClass=elem.getDeclaredType();
    }
 else {
      log.debug(""String_Node_Str"" + value.getClass().getName());
      @SuppressWarnings(""String_Node_Str"") Class<T> classT=(Class<T>)value.getClass();
      elem=new JAXBElement<T>(new QName(""String_Node_Str""),classT,value);
      valueClass=classT;
    }
    Marshaller mar=jc.createMarshaller();
    ByteArrayOutputStream bout=new ByteArrayOutputStream(256);
    mar.marshal(elem,bout);
    Unmarshaller unmar=jc.createUnmarshaller();
    elem=unmar.unmarshal(new StreamSource(new ByteArrayInputStream(bout.toByteArray())),valueClass);
    T res;
    if (value instanceof JAXBElement<?>) {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem;
      res=resT;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T resT=(T)elem.getValue();
      res=resT;
    }
    log.info(""String_Node_Str"");
    return res;
  }
 catch (  JAXBException ex) {
    throw new IllegalArgumentException(ex);
  }
}",0.9936908517350158
185122,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  String BASE_DIR=""String_Node_Str"";
  String paraL=BASE_DIR + ""String_Node_Str"";
  String paraR=BASE_DIR + ""String_Node_Str"";
  P pl=loadParagraph(paraL);
  P pr=loadParagraph(paraR);
  StreamResult result=new StreamResult(System.out);
  Differencer pd=new Differencer();
  pd.diff(pl,pr,result,null,null,null,null);
}","public static void main(String[] args) throws Exception {
  Writer diffxResult=new StringWriter();
  try {
    XMLInputFactory inputFactory=XMLInputFactory.newInstance();
    String simplified=combineAdjacent(inputFactory.createXMLStreamReader(new FileInputStream(new File(""String_Node_Str""))));
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    diffxResult=null;
  }
}",0.2521212121212121
185123,"private static String combineAdjacent(XMLStreamReader reader) throws XMLStreamException {
  String memory=null;
  java.io.StringWriter stringWriter=new java.io.StringWriter();
  XMLOutputFactory factory=XMLOutputFactory.newInstance();
  XMLStreamWriter writer=factory.createXMLStreamWriter(stringWriter);
  while (reader.hasNext()) {
    int event=reader.next();
switch (event) {
case XMLStreamConstants.END_ELEMENT:
      if (reader.getLocalName().equals(""String_Node_Str"")) {
        memory=""String_Node_Str"";
      }
 else       if (reader.getLocalName().equals(""String_Node_Str"")) {
        memory=""String_Node_Str"";
      }
 else {
        writer.writeEndElement();
      }
    break;
case XMLStreamConstants.START_ELEMENT:
  if (memory != null) {
    if (memory.equals(reader.getLocalName())) {
      memory=null;
      continue;
    }
 else {
      writer.writeEndElement();
      memory=null;
    }
  }
if (reader.getNamespaceURI() == null) {
  writer.writeStartElement(reader.getLocalName());
}
 else {
  writer.writeStartElement(reader.getPrefix(),reader.getLocalName(),reader.getNamespaceURI());
}
for (int i=0; i < reader.getAttributeCount(); i++) {
writer.writeAttribute(reader.getAttributePrefix(i),reader.getAttributeNamespace(i),reader.getAttributeLocalName(i),reader.getAttributeValue(i));
}
for (int i=0; i < reader.getNamespaceCount(); i++) {
writer.writeNamespace(reader.getNamespacePrefix(i),reader.getNamespaceURI(i));
}
break;
case XMLStreamConstants.CHARACTERS:
if (memory != null) {
writer.writeEndElement();
memory=null;
}
writer.writeCharacters(reader.getText());
break;
case XMLStreamConstants.START_DOCUMENT:
writer.writeStartDocument();
break;
case XMLStreamConstants.END_DOCUMENT:
writer.writeEndDocument();
break;
default :
}
}
writer.flush();
writer.close();
return stringWriter.toString();
}","private static String combineAdjacent(XMLStreamReader reader) throws XMLStreamException {
  String memory=null;
  java.io.StringWriter stringWriter=new java.io.StringWriter();
  XMLOutputFactory factory=XMLOutputFactory.newInstance();
  XMLStreamWriter writer=factory.createXMLStreamWriter(stringWriter);
  while (reader.hasNext()) {
    int event=reader.next();
switch (event) {
case XMLStreamConstants.END_ELEMENT:
      if (reader.getLocalName().equals(""String_Node_Str"")) {
        memory=""String_Node_Str"";
      }
 else       if (reader.getLocalName().equals(""String_Node_Str"")) {
        memory=""String_Node_Str"";
      }
 else {
        writer.writeEndElement();
      }
    break;
case XMLStreamConstants.START_ELEMENT:
  try {
    if (memory != null) {
      if (memory.equals(reader.getLocalName())) {
        memory=null;
        continue;
      }
 else {
        writer.writeEndElement();
        memory=null;
      }
    }
    if (reader.getNamespaceURI() == null) {
      writer.writeStartElement(reader.getLocalName());
    }
 else {
      writer.writeStartElement(reader.getPrefix(),reader.getLocalName(),reader.getNamespaceURI());
    }
    for (int i=0; i < reader.getAttributeCount(); i++) {
      if (reader.getAttributeNamespace(i) == null) {
        writer.writeAttribute(reader.getAttributeLocalName(i),reader.getAttributeValue(i));
      }
 else {
        writer.writeAttribute(reader.getAttributePrefix(i),reader.getAttributeNamespace(i),reader.getAttributeLocalName(i),reader.getAttributeValue(i));
      }
    }
    for (int i=0; i < reader.getNamespaceCount(); i++) {
      writer.writeNamespace(reader.getNamespacePrefix(i),reader.getNamespaceURI(i));
    }
  }
 catch (  XMLStreamException e) {
    System.out.println(""String_Node_Str"" + reader.getLocalName() + ""String_Node_Str"");
    e.printStackTrace();
    throw e;
  }
break;
case XMLStreamConstants.CHARACTERS:
if (memory != null) {
writer.writeEndElement();
memory=null;
}
writer.writeCharacters(reader.getText());
break;
case XMLStreamConstants.START_DOCUMENT:
writer.writeStartDocument();
break;
case XMLStreamConstants.END_DOCUMENT:
writer.writeEndDocument();
break;
default :
}
}
writer.flush();
writer.close();
return stringWriter.toString();
}",0.8823239783357951
185124,"/** 
 * This is private, in order to control what objects the user can invoke diff on.  At present there are public methods for pairs of w:body, w:sdtContent, and w:p.   TODO: consider/test w:table! 
 */
private void diffWorker(Node newer,Node older,javax.xml.transform.Result result,String author,java.util.Calendar date,RelationshipsPart docPartRelsNewer,RelationshipsPart docPartRelsOlder){
  Writer diffxResult=new StringWriter();
  try {
    Docx4jDriver.diff(newer,older,diffxResult);
    diffxResult.close();
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    diffxResult=null;
  }
  try {
    XMLInputFactory inputFactory=XMLInputFactory.newInstance();
    Reader reader;
    if (log.isDebugEnabled()) {
      String res=diffxResult.toString();
      log.debug(res);
      reader=new StringReader(res);
    }
 else {
      reader=new StringReader(diffxResult.toString());
    }
    String simplified=null;
    try {
      simplified=combineAdjacent(inputFactory.createXMLStreamReader(reader));
    }
 catch (    XMLStreamException e) {
      e.printStackTrace();
    }
    log.debug(""String_Node_Str"" + simplified);
    StreamSource src=new StreamSource(new StringReader(simplified));
    transformDiffxOutputToWml(result,author,date,docPartRelsNewer,docPartRelsOlder,src);
  }
 catch (  Exception exc) {
    exc.printStackTrace();
  }
}","/** 
 * This is private, in order to control what objects the user can invoke diff on.  At present there are public methods for pairs of w:body, w:sdtContent, and w:p.   TODO: consider/test w:table! 
 */
private void diffWorker(Node newer,Node older,javax.xml.transform.Result result,String author,java.util.Calendar date,RelationshipsPart docPartRelsNewer,RelationshipsPart docPartRelsOlder){
  Writer diffxResult=new StringWriter();
  try {
    Docx4jDriver.diff(newer,older,diffxResult);
    diffxResult.close();
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    diffxResult=null;
  }
  try {
    XMLInputFactory inputFactory=XMLInputFactory.newInstance();
    Reader reader;
    if (log.isDebugEnabled()) {
      String res=diffxResult.toString();
      log.debug(""String_Node_Str"" + res);
      reader=new StringReader(res);
    }
 else {
      reader=new StringReader(diffxResult.toString());
    }
    String simplified=null;
    try {
      simplified=combineAdjacent(inputFactory.createXMLStreamReader(reader));
    }
 catch (    XMLStreamException e) {
      e.printStackTrace();
    }
    log.debug(""String_Node_Str"" + simplified);
    StreamSource src=new StreamSource(new StringReader(simplified));
    transformDiffxOutputToWml(result,author,date,docPartRelsNewer,docPartRelsOlder,src);
  }
 catch (  Exception exc) {
    exc.printStackTrace();
  }
}",0.9926793557833088
185125,"/** 
 * @param wmlPackage
 * @param imageDirPath - images won't be saved if this is not set
 * @param pictureData
 * @param picSize
 * @param picLink
 * @param linkData
 * @return
 */
public static WordXmlPicture createWordXmlPicture(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator pictureData,NodeIterator picSize,NodeIterator picLink,NodeIterator linkData){
  WordXmlPicture picture=new WordXmlPicture();
  picture.readStandardAttributes(pictureData.nextNode());
  Node picSizeNode=picSize.nextNode();
  if (picSizeNode != null) {
    picture.readSizeAttributes(picSizeNode);
  }
  Node picLinkNode=picLink.nextNode();
  if (picLinkNode != null) {
    String linkRelId=ConvertUtils.getAttributeValueNS(picLinkNode,""String_Node_Str"",""String_Node_Str"");
    if (linkRelId != null && !linkRelId.equals(""String_Node_Str"")) {
      Relationship rel=wmlPackage.getMainDocumentPart().getRelationshipsPart().getRelationshipByID(linkRelId);
      if (rel.getTargetMode() == null || rel.getTargetMode().equals(""String_Node_Str"")) {
        picture.setHlinkReference(""String_Node_Str"");
      }
 else {
        picture.setHlinkReference(rel.getTarget());
      }
    }
    picture.readLinkAttributes(picLinkNode);
  }
  Node linkDataNode=linkData.nextNode();
  if (linkDataNode == null) {
    log.warn(""String_Node_Str"");
  }
 else {
    String imgRelId=ConvertUtils.getAttributeValueNS(linkDataNode,""String_Node_Str"",""String_Node_Str"");
    if (imgRelId != null && !imgRelId.equals(""String_Node_Str"")) {
      Relationship rel=wmlPackage.getMainDocumentPart().getRelationshipsPart().getRelationshipByID(imgRelId);
      if (rel.getTargetMode() == null || rel.getTargetMode().equals(""String_Node_Str"")) {
        Part part=wmlPackage.getMainDocumentPart().getRelationshipsPart().getPart(rel);
        try {
          if (imageDirPath.equals(""String_Node_Str"")) {
            java.nio.ByteBuffer bb=((BinaryPart)part).getBuffer();
            bb.clear();
            byte[] bytes=new byte[bb.capacity()];
            bb.get(bytes,0,bytes.length);
            byte[] encoded=Base64.encodeBase64(bytes,true);
            picture.setSrc(""String_Node_Str"" + part.getContentType() + ""String_Node_Str""+ (new String(encoded,""String_Node_Str"")));
          }
 else {
            FileObject folder=getFileSystemManager().resolveFile(imageDirPath);
            if (!folder.exists()) {
              folder.createFolder();
            }
            String partname=part.getPartName().toString();
            String filename=partname.substring(partname.lastIndexOf(""String_Node_Str"") + 1);
            log.debug(""String_Node_Str"" + filename);
            FileObject fo=folder.resolveFile(filename);
            if (fo.exists()) {
              log.warn(""String_Node_Str"");
            }
 else {
              fo.createFile();
            }
            OutputStream out=fo.getContent().getOutputStream();
            java.nio.ByteBuffer bb=((BinaryPart)part).getBuffer();
            bb.clear();
            byte[] bytes=new byte[bb.capacity()];
            bb.get(bytes,0,bytes.length);
            out.write(bytes);
            String src=fixImgSrcURL(fo);
            picture.setSrc(src);
            log.info(""String_Node_Str"" + src);
          }
        }
 catch (        Exception e) {
          log.error(e);
        }
      }
 else {
        picture.setSrc(rel.getTarget());
      }
    }
  }
  return picture;
}","/** 
 * @param wmlPackage
 * @param imageDirPath - images won't be saved if this is not set
 * @param pictureData
 * @param picSize
 * @param picLink
 * @param linkData
 * @return
 */
public static WordXmlPicture createWordXmlPicture(WordprocessingMLPackage wmlPackage,String imageDirPath,NodeIterator pictureData,NodeIterator picSize,NodeIterator picLink,NodeIterator linkData){
  WordXmlPicture picture=new WordXmlPicture();
  picture.readStandardAttributes(pictureData.nextNode());
  Node picSizeNode=picSize.nextNode();
  if (picSizeNode != null) {
    picture.readSizeAttributes(picSizeNode);
  }
  Node picLinkNode=picLink.nextNode();
  if (picLinkNode != null) {
    String linkRelId=ConvertUtils.getAttributeValueNS(picLinkNode,""String_Node_Str"",""String_Node_Str"");
    if (linkRelId != null && !linkRelId.equals(""String_Node_Str"")) {
      Relationship rel=wmlPackage.getMainDocumentPart().getRelationshipsPart().getRelationshipByID(linkRelId);
      if (rel.getTargetMode() == null || rel.getTargetMode().equals(""String_Node_Str"")) {
        picture.setHlinkReference(""String_Node_Str"");
      }
 else {
        picture.setHlinkReference(rel.getTarget());
      }
    }
    picture.readLinkAttributes(picLinkNode);
  }
  Node linkDataNode=linkData.nextNode();
  if (linkDataNode == null) {
    log.warn(""String_Node_Str"");
  }
 else {
    String imgRelId=ConvertUtils.getAttributeValueNS(linkDataNode,""String_Node_Str"",""String_Node_Str"");
    if (imgRelId != null && !imgRelId.equals(""String_Node_Str"")) {
      Relationship rel=wmlPackage.getMainDocumentPart().getRelationshipsPart().getRelationshipByID(imgRelId);
      if (rel.getTargetMode() == null || rel.getTargetMode().equals(""String_Node_Str"")) {
        Part part=wmlPackage.getMainDocumentPart().getRelationshipsPart().getPart(rel);
        try {
          if (imageDirPath.equals(""String_Node_Str"")) {
            java.nio.ByteBuffer bb=((BinaryPart)part).getBuffer();
            bb.clear();
            byte[] bytes=new byte[bb.capacity()];
            bb.get(bytes,0,bytes.length);
            byte[] encoded=Base64.encodeBase64(bytes,true);
            picture.setSrc(""String_Node_Str"" + part.getContentType() + ""String_Node_Str""+ (new String(encoded,""String_Node_Str"")));
          }
 else {
            FileObject folder=getFileSystemManager().resolveFile(imageDirPath);
            if (!folder.exists()) {
              folder.createFolder();
            }
            String partname=part.getPartName().toString();
            String filename=partname.substring(partname.lastIndexOf(""String_Node_Str"") + 1);
            log.debug(""String_Node_Str"" + filename);
            FileObject fo=folder.resolveFile(filename);
            if (fo.exists()) {
              log.warn(""String_Node_Str"");
            }
 else {
              fo.createFile();
            }
            OutputStream out=fo.getContent().getOutputStream();
            try {
              java.nio.ByteBuffer bb=((BinaryPart)part).getBuffer();
              bb.clear();
              byte[] bytes=new byte[bb.capacity()];
              bb.get(bytes,0,bytes.length);
              out.write(bytes);
              String src=fixImgSrcURL(fo);
              picture.setSrc(src);
              log.info(""String_Node_Str"" + src);
            }
  finally {
              try {
                fo.close();
              }
 catch (              IOException ioe) {
                ioe.printStackTrace();
              }
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
          log.error(e);
        }
      }
 else {
        picture.setSrc(rel.getTarget());
      }
    }
  }
  return picture;
}",0.934779546414988
185126,"public static void diff(Node xml2,Node xml1,Writer out) throws DiffXException, IOException {
  try {
    DiffXConfig diffxConfig=new DiffXConfig();
    diffxConfig.setIgnoreWhiteSpace(false);
    diffxConfig.setPreserveWhiteSpace(true);
    log(xml1.getNodeName());
    log(""String_Node_Str"" + xml1.getChildNodes().getLength());
    log(xml2.getNodeName());
    log(""String_Node_Str"" + xml2.getChildNodes().getLength());
    if (!xml1.getNodeName().equals(xml2.getNodeName()) || ((xml1.getChildNodes().getLength() <= 3) && (xml2.getChildNodes().getLength() <= 3))) {
      log(""String_Node_Str"");
      Main.diff(xml1,xml2,out,diffxConfig);
      out.close();
      return;
    }
    DOMRecorder loader=new DOMRecorder();
    loader.setConfig(diffxConfig);
    log(""String_Node_Str"");
    List<EventSequence> leftES=new ArrayList<EventSequence>();
    for (int i=0; i < xml1.getChildNodes().getLength(); i++) {
      if (xml1.getChildNodes().item(i).getNodeType() != 3) {
        Element e=(Element)xml1.getChildNodes().item(i);
        e.setAttributeNS(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        leftES.add(loader.process(e));
      }
    }
    EventSequenceComparator leftESC=new EventSequenceComparator(leftES);
    List<EventSequence> rightES=new ArrayList<EventSequence>();
    for (int i=0; i < xml2.getChildNodes().getLength(); i++) {
      if (xml2.getChildNodes().item(i).getNodeType() != 3) {
        Element e=(Element)xml2.getChildNodes().item(i);
        e.setAttributeNS(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rightES.add(loader.process(e));
      }
    }
    EventSequenceComparator rightESC=new EventSequenceComparator(rightES);
    log(""String_Node_Str"");
    RangeDifference[] rd=RangeDifferencer.findDifferences(leftESC,rightESC);
    for (int i=0; i < rd.length; i++) {
      RangeDifference rdi=rd[i];
      log(rdi.kindString() + ""String_Node_Str"" + rdi.leftStart()+ ""String_Node_Str""+ rdi.leftLength()+ ""String_Node_Str""+ rdi.rightStart()+ ""String_Node_Str""+ rdi.rightLength());
    }
    log(""String_Node_Str"");
    SmartXMLFormatter formatter=new SmartXMLFormatter(out);
    formatter.setConfig(diffxConfig);
    String rootNodeName=xml1.getNodeName();
    out.append(""String_Node_Str"" + rootNodeName + ""String_Node_Str""+ xml1.getPrefix()+ ""String_Node_Str""+ xml1.getNamespaceURI()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.BASE_NS+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.DELETE_NS+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.BASE_NS+ ""String_Node_Str""+ ""String_Node_Str"");
    int leftIdx=0;
    for (int i=0; i < rd.length; i++) {
      RangeDifference rdi=rd[i];
      if (rdi.leftStart() > leftIdx) {
        for (int k=leftIdx; k < rdi.leftStart(); k++) {
          addComment(""String_Node_Str"",formatter);
          formatter.declarePrefixMapping(leftESC.getItem(k).getPrefixMapping());
          leftESC.getItem(k).format(formatter);
          addComment(""String_Node_Str"",formatter);
        }
        leftIdx=rdi.leftStart();
      }
      EventSequence seq1=new EventSequence();
      for (int k=rdi.leftStart(); k < rdi.leftEnd(); k++) {
        if (rdi.kind() == rdi.CHANGE) {
          seq1.addSequence(leftESC.getItem(k));
          PrefixMapping existingPM=leftESC.getItem(k).getPrefixMapping();
          seq1.getPrefixMapping().add(existingPM);
        }
 else {
          formatter.declarePrefixMapping(leftESC.getItem(k).getPrefixMapping());
          addComment(""String_Node_Str"",formatter);
          leftESC.getItem(k).format(formatter);
          addComment(""String_Node_Str"",formatter);
        }
      }
      EventSequence seq2=new EventSequence();
      for (int k=rdi.rightStart(); k < rdi.rightEnd(); k++) {
        if (rdi.kind() == rdi.CHANGE) {
          seq2.addSequence(rightESC.getItem(k));
          PrefixMapping existingPM=rightESC.getItem(k).getPrefixMapping();
          seq2.getPrefixMapping().add(existingPM);
        }
      }
      leftIdx=rdi.leftEnd();
      addComment(""String_Node_Str"",formatter);
      Main.diff(seq1,seq2,formatter,diffxConfig);
      addComment(""String_Node_Str"",formatter);
    }
    addComment(""String_Node_Str"",formatter);
    if (rd.length > 0) {
      for (int k=rd[rd.length - 1].leftEnd(); k < leftESC.getRangeCount(); k++) {
        leftESC.getItem(k).format(formatter);
      }
    }
    out.append(""String_Node_Str"" + rootNodeName + ""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
    e.printStackTrace();
    throw new DiffXException(e);
  }
}","public static void diff(Node xml2,Node xml1,Writer out) throws DiffXException, IOException {
  try {
    DiffXConfig diffxConfig=new DiffXConfig();
    diffxConfig.setIgnoreWhiteSpace(false);
    diffxConfig.setPreserveWhiteSpace(true);
    log(xml1.getNodeName());
    log(""String_Node_Str"" + xml1.getChildNodes().getLength());
    log(xml2.getNodeName());
    log(""String_Node_Str"" + xml2.getChildNodes().getLength());
    if (!xml1.getNodeName().equals(xml2.getNodeName()) || ((xml1.getChildNodes().getLength() <= 3) && (xml2.getChildNodes().getLength() <= 3))) {
      log(""String_Node_Str"");
      Main.diff(xml1,xml2,out,diffxConfig);
      out.close();
      return;
    }
    DOMRecorder loader=new DOMRecorder();
    loader.setConfig(diffxConfig);
    log(""String_Node_Str"");
    List<EventSequence> leftES=new ArrayList<EventSequence>();
    for (int i=0; i < xml1.getChildNodes().getLength(); i++) {
      if (xml1.getChildNodes().item(i).getNodeType() != 3) {
        Element e=(Element)xml1.getChildNodes().item(i);
        e.setAttributeNS(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        leftES.add(loader.process(e));
      }
    }
    EventSequenceComparator leftESC=new EventSequenceComparator(leftES);
    List<EventSequence> rightES=new ArrayList<EventSequence>();
    for (int i=0; i < xml2.getChildNodes().getLength(); i++) {
      if (xml2.getChildNodes().item(i).getNodeType() != 3) {
        Element e=(Element)xml2.getChildNodes().item(i);
        e.setAttributeNS(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rightES.add(loader.process(e));
      }
    }
    EventSequenceComparator rightESC=new EventSequenceComparator(rightES);
    log(""String_Node_Str"");
    RangeDifference[] rd=RangeDifferencer.findDifferences(leftESC,rightESC);
    SmartXMLFormatter formatter=new SmartXMLFormatter(out);
    formatter.setConfig(diffxConfig);
    String rootNodeName=xml1.getNodeName();
    openResult(rootNodeName,out);
    if (rd.length == 0) {
      log(""String_Node_Str"");
      addComment(""String_Node_Str"",formatter);
      for (      EventSequence es : leftES) {
        es.format(formatter);
      }
      closeResult(rootNodeName,out);
      return;
    }
    for (int i=0; i < rd.length; i++) {
      RangeDifference rdi=rd[i];
      log(rdi.kindString() + ""String_Node_Str"" + rdi.leftStart()+ ""String_Node_Str""+ rdi.leftLength()+ ""String_Node_Str""+ rdi.rightStart()+ ""String_Node_Str""+ rdi.rightLength());
    }
    log(""String_Node_Str"");
    int leftIdx=0;
    for (int i=0; i < rd.length; i++) {
      RangeDifference rdi=rd[i];
      if (rdi.leftStart() > leftIdx) {
        for (int k=leftIdx; k < rdi.leftStart(); k++) {
          addComment(""String_Node_Str"",formatter);
          formatter.declarePrefixMapping(leftESC.getItem(k).getPrefixMapping());
          leftESC.getItem(k).format(formatter);
          addComment(""String_Node_Str"",formatter);
        }
        leftIdx=rdi.leftStart();
      }
      EventSequence seq1=new EventSequence();
      for (int k=rdi.leftStart(); k < rdi.leftEnd(); k++) {
        if (rdi.kind() == rdi.CHANGE) {
          seq1.addSequence(leftESC.getItem(k));
          PrefixMapping existingPM=leftESC.getItem(k).getPrefixMapping();
          seq1.getPrefixMapping().add(existingPM);
        }
 else {
          formatter.declarePrefixMapping(leftESC.getItem(k).getPrefixMapping());
          addComment(""String_Node_Str"",formatter);
          leftESC.getItem(k).format(formatter);
          addComment(""String_Node_Str"",formatter);
        }
      }
      EventSequence seq2=new EventSequence();
      for (int k=rdi.rightStart(); k < rdi.rightEnd(); k++) {
        if (rdi.kind() == rdi.CHANGE) {
          seq2.addSequence(rightESC.getItem(k));
          PrefixMapping existingPM=rightESC.getItem(k).getPrefixMapping();
          seq2.getPrefixMapping().add(existingPM);
        }
      }
      leftIdx=rdi.leftEnd();
      addComment(""String_Node_Str"",formatter);
      Main.diff(seq1,seq2,formatter,diffxConfig);
      addComment(""String_Node_Str"",formatter);
    }
    addComment(""String_Node_Str"",formatter);
    if (rd.length > 0) {
      for (int k=rd[rd.length - 1].leftEnd(); k < leftESC.getRangeCount(); k++) {
        leftESC.getItem(k).format(formatter);
      }
    }
    closeResult(rootNodeName,out);
  }
 catch (  IndexOutOfBoundsException e) {
    e.printStackTrace();
    throw new DiffXException(e);
  }
}",0.863721493885645
185127,"/** 
 * Creates a new formatter using the specified writer.
 * @param w The writer to use.
 * @throws IOException should an I/O exception occurs.
 */
public SmartXMLFormatter(Writer w) throws IOException {
  this.xml=new NSAwareXMLWriter(w,false);
  this.xml.xmlDecl();
  this.xml.setPrefixMapping(Constants.BASE_NS,""String_Node_Str"");
  this.xml.setPrefixMapping(Constants.DELETE_NS,""String_Node_Str"");
}","/** 
 * Creates a new formatter using the specified writer.
 * @param w The writer to use.
 * @throws IOException should an I/O exception occurs.
 */
public SmartXMLFormatter(Writer w) throws IOException {
  this.xml=new NSAwareXMLWriter(w,false);
  this.xml.xmlDecl();
  this.xml.setPrefixMapping(Constants.BASE_NS,""String_Node_Str"");
  this.xml.setPrefixMapping(Constants.DELETE_NS,""String_Node_Str"");
  this.xml.setPrefixMapping(""String_Node_Str"",""String_Node_Str"");
}",0.9246575342465754
185128,"/** 
 * Get a Part (except a relationships part), but not its relationships part or related parts.  Useful if you need quick access to just this part. This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @see To get a Part and all its related parts, and add all to a package, usegetPart.
 * @param zf
 * @param resolvedPartUri
 * @return
 * @throws URISyntaxException
 * @throws InvalidFormatException
 */
public Part getRawPart(ContentTypeManager ctm,String resolvedPartUri) throws Docx4JException {
  Part part=null;
  try {
    org.docx4j.xmlPackage.Part pkgPart=parts.get(resolvedPartUri);
    try {
      if (pkgPart == null) {
        log.error(""String_Node_Str"" + resolvedPartUri);
        return null;
      }
      String contentType=pkgPart.getContentType();
      log.debug(""String_Node_Str"" + contentType);
      org.w3c.dom.Element el=null;
      if (pkgPart.getXmlData() != null) {
        el=pkgPart.getXmlData().getAny();
      }
      part=ctm.newPartForContentType(contentType,resolvedPartUri);
      part.setContentType(new ContentType(contentType));
      ctm.addOverrideContentType(new java.net.URI(resolvedPartUri),contentType);
      if (part instanceof org.docx4j.openpackaging.parts.ThemePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcThemePart);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCorePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCore);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCustomPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCustom);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsExtendedPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsExtended);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jc);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
        ((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).setDocument(convertW3CtoDom4J(el).getDocument());
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.WordprocessingML.BinaryPart) {
        log.debug(""String_Node_Str"" + part.getClass().getName());
        ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
      }
 else {
        log.error(""String_Node_Str"" + resolvedPartUri);
        part=null;
      }
    }
 catch (    PartUnrecognisedException e) {
      log.error(""String_Node_Str"" + resolvedPartUri);
      part=new BinaryPart(new PartName(resolvedPartUri));
      ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new Docx4JException(""String_Node_Str"",ex);
  }
  return part;
}","/** 
 * Get a Part (except a relationships part), but not its relationships part or related parts.  Useful if you need quick access to just this part. This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @see To get a Part and all its related parts, and add all to a package, usegetPart.
 * @param zf
 * @param resolvedPartUri
 * @return
 * @throws URISyntaxException
 * @throws InvalidFormatException
 */
public Part getRawPart(ContentTypeManager ctm,String resolvedPartUri) throws Docx4JException {
  Part part=null;
  try {
    org.docx4j.xmlPackage.Part pkgPart=parts.get(resolvedPartUri);
    org.w3c.dom.Element el=null;
    try {
      if (pkgPart == null) {
        log.error(""String_Node_Str"" + resolvedPartUri);
        return null;
      }
      String contentType=pkgPart.getContentType();
      log.debug(""String_Node_Str"" + contentType);
      if (pkgPart.getXmlData() != null) {
        el=pkgPart.getXmlData().getAny();
      }
      part=ctm.newPartForContentType(contentType,resolvedPartUri);
      part.setContentType(new ContentType(contentType));
      ctm.addOverrideContentType(new java.net.URI(resolvedPartUri),contentType);
      if (part instanceof org.docx4j.openpackaging.parts.ThemePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcThemePart);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCorePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCore);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCustomPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCustom);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsExtendedPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsExtended);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jc);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
        ((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).setDocument(convertW3CtoDom4J(el).getDocument());
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.WordprocessingML.BinaryPart) {
        log.debug(""String_Node_Str"" + part.getClass().getName());
        ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
      }
 else {
        log.error(""String_Node_Str"" + resolvedPartUri);
        part=null;
      }
    }
 catch (    java.lang.IllegalArgumentException e) {
      if (el != null) {
        log.error(e.getMessage());
        log.error(XmlUtils.w3CDomNodeToString(el));
      }
      throw e;
    }
catch (    PartUnrecognisedException e) {
      log.error(""String_Node_Str"" + resolvedPartUri);
      part=new BinaryPart(new PartName(resolvedPartUri));
      ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new Docx4JException(""String_Node_Str"",ex);
  }
  return part;
}",0.9632676216139556
185129,"/** 
 * Get a Part (except a relationships part), but not its relationships part or related parts.  Useful if you need quick access to just this part. This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @see To get a Part and all its related parts, and add all to a package, usegetPart.
 * @param zf
 * @param resolvedPartUri
 * @return
 * @throws URISyntaxException
 * @throws InvalidFormatException
 */
public Part getRawPart(ContentTypeManager ctm,String resolvedPartUri) throws Docx4JException {
  Part part=null;
  try {
    org.docx4j.xmlPackage.Part pkgPart=parts.get(resolvedPartUri);
    try {
      if (pkgPart == null) {
        log.error(""String_Node_Str"" + resolvedPartUri);
        return null;
      }
      String contentType=pkgPart.getContentType();
      org.w3c.dom.Element el=null;
      if (pkgPart.getXmlData() != null) {
        el=pkgPart.getXmlData().getAny();
      }
      part=ctm.newPartForContentType(contentType,resolvedPartUri);
      part.setContentType(new ContentType(contentType));
      ctm.addOverrideContentType(new java.net.URI(resolvedPartUri),contentType);
      if (part instanceof org.docx4j.openpackaging.parts.ThemePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcThemePart);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCorePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCore);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCustomPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCustom);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsExtendedPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsExtended);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jc);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
        ((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).setDocument(convertW3CtoDom4J(el).getDocument());
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.WordprocessingML.ObfuscatedFontPart) {
        log.debug(""String_Node_Str"");
        ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
        log.info(""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"" + resolvedPartUri);
        part=null;
      }
    }
 catch (    PartUnrecognisedException e) {
      ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new Docx4JException(""String_Node_Str"",ex);
  }
  return part;
}","/** 
 * Get a Part (except a relationships part), but not its relationships part or related parts.  Useful if you need quick access to just this part. This can be called directly from outside the library, in which case  the Part will not be owned by a Package until the calling code makes it so.  
 * @see To get a Part and all its related parts, and add all to a package, usegetPart.
 * @param zf
 * @param resolvedPartUri
 * @return
 * @throws URISyntaxException
 * @throws InvalidFormatException
 */
public Part getRawPart(ContentTypeManager ctm,String resolvedPartUri) throws Docx4JException {
  Part part=null;
  try {
    org.docx4j.xmlPackage.Part pkgPart=parts.get(resolvedPartUri);
    try {
      if (pkgPart == null) {
        log.error(""String_Node_Str"" + resolvedPartUri);
        return null;
      }
      String contentType=pkgPart.getContentType();
      log.debug(""String_Node_Str"" + contentType);
      org.w3c.dom.Element el=null;
      if (pkgPart.getXmlData() != null) {
        el=pkgPart.getXmlData().getAny();
      }
      part=ctm.newPartForContentType(contentType,resolvedPartUri);
      part.setContentType(new ContentType(contentType));
      ctm.addOverrideContentType(new java.net.URI(resolvedPartUri),contentType);
      if (part instanceof org.docx4j.openpackaging.parts.ThemePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcThemePart);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCorePart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCore);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsCustomPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsCustom);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.DocPropsExtendedPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jcDocPropsExtended);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).setJAXBContext(Context.jc);
        ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).unmarshal(el);
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
        ((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).setDocument(convertW3CtoDom4J(el).getDocument());
      }
 else       if (part instanceof org.docx4j.openpackaging.parts.WordprocessingML.BinaryPart) {
        log.debug(""String_Node_Str"" + part.getClass().getName());
        ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
      }
 else {
        log.error(""String_Node_Str"" + resolvedPartUri);
        part=null;
      }
    }
 catch (    PartUnrecognisedException e) {
      log.error(""String_Node_Str"" + resolvedPartUri);
      part=new BinaryPart(new PartName(resolvedPartUri));
      ((BinaryPart)part).setBinaryData(pkgPart.getBinaryData());
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new Docx4JException(""String_Node_Str"",ex);
  }
  return part;
}",0.9510198005061784
185130,"/** 
 * Remove a part from this package, including its relationships part and all target parts. Do so recursively.  If this part is relationship part, then delete all relationships in the source part.
 * @param partName The part name of the part to remove.
 */
public void removePart(PartName partName){
  log.info(""String_Node_Str"" + partName.getName());
  if (partName == null)   throw new IllegalArgumentException(""String_Node_Str"");
  Part part=getPackage().getParts().get(partName);
  if (part != null) {
    Relationship relToBeRemoved=null;
    for (    Relationship rel : relationships.getRelationship()) {
      URI resolvedTargetURI=null;
      try {
        resolvedTargetURI=org.docx4j.openpackaging.URIHelper.resolvePartUri(sourceP.partName.getURI(),new URI(rel.getTarget()));
      }
 catch (      URISyntaxException e) {
        log.error(""String_Node_Str"" + rel.getTarget() + ""String_Node_Str"",e);
      }
      log.debug(""String_Node_Str"" + resolvedTargetURI + ""String_Node_Str""+ partName.getName());
      if (partName.getName().equals(resolvedTargetURI.toString())) {
        log.info(""String_Node_Str"" + rel.getTarget());
        relToBeRemoved=rel;
        break;
      }
    }
    if (relToBeRemoved == null) {
      throw new IllegalArgumentException(partName + ""String_Node_Str"" + this.partName);
    }
 else {
      removeRelationship(relToBeRemoved);
    }
    if (part.getRelationshipsPart() != null) {
      part.getRelationshipsPart().removeParts();
    }
    getPackage().getParts().remove(partName);
  }
}","/** 
 * Remove a part from this package, including its relationships part and all target parts. Do so recursively.  If this part is relationship part, then delete all relationships in the source part.
 * @param partName The part name of the part to remove.
 */
public void removePart(PartName partName){
  log.info(""String_Node_Str"" + partName.getName());
  if (partName == null)   throw new IllegalArgumentException(""String_Node_Str"");
  Part part=getPackage().getParts().get(partName);
  if (part != null) {
    Relationship relToBeRemoved=null;
    for (    Relationship rel : relationships.getRelationship()) {
      if (rel.getTargetMode() != null && rel.getTargetMode().equals(""String_Node_Str"")) {
        continue;
      }
      URI resolvedTargetURI=null;
      try {
        resolvedTargetURI=org.docx4j.openpackaging.URIHelper.resolvePartUri(sourceP.partName.getURI(),new URI(rel.getTarget()));
      }
 catch (      URISyntaxException e) {
        log.error(""String_Node_Str"" + rel.getTarget() + ""String_Node_Str"",e);
      }
      log.debug(""String_Node_Str"" + resolvedTargetURI + ""String_Node_Str""+ partName.getName());
      if (partName.getName().equals(resolvedTargetURI.toString())) {
        log.info(""String_Node_Str"" + rel.getTarget());
        relToBeRemoved=rel;
        break;
      }
    }
    if (relToBeRemoved == null) {
      throw new IllegalArgumentException(partName + ""String_Node_Str"" + this.partName);
    }
 else {
      removeRelationship(relToBeRemoved);
    }
    if (part.getRelationshipsPart() != null) {
      part.getRelationshipsPart().removeParts();
    }
    getPackage().getParts().remove(partName);
  }
}",0.9636135508155584
185131,"/** 
 * Add the specified relationship to the collection.
 * @param rel The relationship to add.
 */
public void addRelationship(Relationship rel){
  String id=""String_Node_Str"" + nextId;
  nextId++;
  if (rel.getId() != null && !rel.getId().equals(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  rel.setId(id);
  relationships.getRelationship().add(rel);
}","/** 
 * Add the specified relationship to the collection.
 * @param rel The relationship to add.
 */
public void addRelationship(Relationship rel){
  String id=getNextId();
  if (rel.getId() != null && !rel.getId().equals(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  rel.setId(id);
  relationships.getRelationship().add(rel);
}",0.9555822328931572
185132,"/** 
 * Create a <wp:inline> element suitable for this image, which can be embedded in w:p/w:r/w:drawing
 * @param filenameHint Any text, for example the original filename
 * @param altText  Like HTML's alt text
 * @param id1   An id unique in the document
 * @param id2   Another id unique in the documentNone of these things seem to be exposed in Word 2007's user interface, but Word won't open the document if  any of the attributes these go in (except @ desc) aren't present!
 * @throws Exception
 */
public Inline createImageInline(String filenameHint,String altText,int id1,int id2) throws Exception {
  if (filenameHint == null) {
    filenameHint=""String_Node_Str"";
  }
  if (altText == null) {
    altText=""String_Node_Str"";
  }
  WordprocessingMLPackage wordMLPackage=((WordprocessingMLPackage)this.getPackage());
  MainDocumentPart documentPart=wordMLPackage.getMainDocumentPart();
  org.docx4j.wml.Document wmlDocumentEl=(org.docx4j.wml.Document)documentPart.getJaxbElement();
  SectPr sectPr=wmlDocumentEl.getBody().getSectPr();
  double writableWidthTwips;
  if (sectPr == null) {
    log.debug(""String_Node_Str"");
    writableWidthTwips=DEFAULT_PAGE_WIDTH_TWIPS - (DEFAULT_LEFT_MARGIN_TWIPS + DEFAULT_RIGHT_MARGIN_TWIPS);
  }
 else {
    PgSz pgSz=sectPr.getPgSz();
    PgMar pgMar=sectPr.getPgMar();
    double pageWidth;
    double leftMargin;
    double rightMargin;
    if (pgSz == null) {
      pageWidth=DEFAULT_PAGE_WIDTH_TWIPS;
    }
 else {
      pageWidth=pgSz.getW().doubleValue();
    }
    if (pgMar == null || pgMar.getLeft() == null) {
      leftMargin=DEFAULT_LEFT_MARGIN_TWIPS;
    }
 else {
      leftMargin=pgMar.getLeft().doubleValue();
    }
    if (pgMar == null || pgMar.getRight() == null) {
      rightMargin=DEFAULT_RIGHT_MARGIN_TWIPS;
    }
 else {
      rightMargin=pgMar.getRight().doubleValue();
    }
    writableWidthTwips=pageWidth - (leftMargin + rightMargin);
  }
  log.debug(""String_Node_Str"" + writableWidthTwips);
  ImageSize size=imageInfo.getSize();
  Dimension2D dPt=size.getDimensionPt();
  double imageWidthTwips=dPt.getWidth() * 20;
  log.debug(""String_Node_Str"" + imageWidthTwips);
  long cx;
  long cy;
  if (imageWidthTwips > writableWidthTwips) {
    log.debug(""String_Node_Str"");
    cx=twipToEMU(writableWidthTwips);
    cy=twipToEMU(dPt.getHeight() * 20 * writableWidthTwips / imageWidthTwips);
  }
 else {
    log.debug(""String_Node_Str"");
    cx=twipToEMU(imageWidthTwips);
    cy=twipToEMU(dPt.getHeight() * 20);
  }
  log.debug(""String_Node_Str"" + cx + ""String_Node_Str""+ cy);
  String ml=""String_Node_Str"" + namespaces + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  java.util.HashMap<String,String> mappings=new java.util.HashMap<String,String>();
  mappings.put(""String_Node_Str"",Long.toString(cx));
  mappings.put(""String_Node_Str"",Long.toString(cy));
  mappings.put(""String_Node_Str"",filenameHint);
  mappings.put(""String_Node_Str"",altText);
  mappings.put(""String_Node_Str"",rel.getId());
  mappings.put(""String_Node_Str"",Integer.toString(id1));
  mappings.put(""String_Node_Str"",Integer.toString(id2));
  Object o=org.docx4j.XmlUtils.unmarshallFromTemplate(ml,mappings);
  Inline inline=(Inline)((JAXBElement)o).getValue();
  return inline;
}","/** 
 * Create a <wp:inline> element suitable for this image, which can be embedded in w:p/w:r/w:drawing, specifying height and width.  Note that you'd ordinarily use one of the methods which don't require you to specify height (cy). 
 * @param filenameHint Any text, for example the original filename
 * @param altText Like HTML's alt text
 * @param id1 An id unique in the document
 * @param id2 Another id unique in the document None of these things seem to be exposed in Word 2007's user interface, but Word won't open the document if any of the attributes these go in (except @ desc) aren't present!
 * @param cx    Image width in twip
 * @param cy    Image height in twip
 * @throws Exception
 */
public Inline createImageInline(String filenameHint,String altText,int id1,int id2,long cx,long cy) throws Exception {
  if (filenameHint == null) {
    filenameHint=""String_Node_Str"";
  }
  if (altText == null) {
    altText=""String_Node_Str"";
  }
  String ml=""String_Node_Str"" + namespaces + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  java.util.HashMap<String,String> mappings=new java.util.HashMap<String,String>();
  mappings.put(""String_Node_Str"",Long.toString(cx));
  mappings.put(""String_Node_Str"",Long.toString(cy));
  mappings.put(""String_Node_Str"",filenameHint);
  mappings.put(""String_Node_Str"",altText);
  mappings.put(""String_Node_Str"",rel.getId());
  mappings.put(""String_Node_Str"",Integer.toString(id1));
  mappings.put(""String_Node_Str"",Integer.toString(id2));
  Object o=org.docx4j.XmlUtils.unmarshallFromTemplate(ml,mappings);
  Inline inline=(Inline)((JAXBElement)o).getValue();
  return inline;
}",0.5974282888229476
185133,"private RelationshipsPart getRelationshipsPartFromXmlPackage(Base p,String partName) throws Docx4JException {
  RelationshipsPart thePart=null;
  try {
    org.docx4j.xmlPackage.Part part=parts.get(partName);
    if (part == null) {
      return null;
    }
    org.w3c.dom.Element el=part.getXmlData().getAny();
    RelationshipsPart rp=new RelationshipsPart(new PartName(partName));
    rp.setSourceP(p);
    rp.unmarshal(el);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new Docx4JException(""String_Node_Str"" + partName,e);
  }
  return thePart;
}","private RelationshipsPart getRelationshipsPartFromXmlPackage(Base p,String partName) throws Docx4JException {
  RelationshipsPart rp=null;
  try {
    org.docx4j.xmlPackage.Part part=parts.get(partName);
    if (part == null) {
      return null;
    }
    org.w3c.dom.Element el=part.getXmlData().getAny();
    rp=new RelationshipsPart(new PartName(partName));
    rp.setSourceP(p);
    rp.setRelationships((Relationships)rp.unmarshal(el));
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new Docx4JException(""String_Node_Str"" + partName,e);
  }
  return rp;
}",0.837696335078534
185134,"Map<String,Object> getSettings(){
  Map<String,Object> settings=new java.util.HashMap<String,Object>();
  settings.put(""String_Node_Str"",removeProofErrors);
  return settings;
}","Map<String,Object> getSettings(){
  Map<String,Object> settings=new java.util.HashMap<String,Object>();
  settings.put(""String_Node_Str"",removeProofErrors);
  settings.put(""String_Node_Str"",removeContentControls);
  settings.put(""String_Node_Str"",removeRsids);
  return settings;
}",0.7729257641921398
185135,"public org.docx4j.wml.Package exportPkgXml(){
  org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
  org.docx4j.wml.Package pkg=factory.createPackage();
  org.docx4j.wml.Package.Part pkgPartDocument=factory.createPackagePart();
  MainDocumentPart documentPart=getMainDocumentPart();
  pkgPartDocument.setName(documentPart.getPartName().getName());
  pkgPartDocument.setContentType(documentPart.getContentType());
  org.docx4j.wml.Package.Part.XmlData XmlDataDoc=factory.createPackagePartXmlData();
  org.docx4j.wml.Document wmlDocumentEl=(org.docx4j.wml.Document)documentPart.getJaxbElement();
  XmlDataDoc.setDocument(wmlDocumentEl);
  pkgPartDocument.setXmlData(XmlDataDoc);
  pkg.getPart().add(pkgPartDocument);
  org.docx4j.wml.Package.Part pkgPartStyles=factory.createPackagePart();
  org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart stylesPart=documentPart.getStyleDefinitionsPart();
  pkgPartDocument.setName(stylesPart.getPartName().getName());
  pkgPartDocument.setContentType(stylesPart.getContentType());
  org.docx4j.wml.Package.Part.XmlData XmlDataStyles=factory.createPackagePartXmlData();
  org.docx4j.wml.Styles styles=(org.docx4j.wml.Styles)stylesPart.getJaxbElement();
  XmlDataStyles.setStyles(styles);
  pkgPartStyles.setXmlData(XmlDataStyles);
  pkg.getPart().add(pkgPartStyles);
  return pkg;
}","public org.docx4j.wml.Package exportPkgXml(){
  org.docx4j.wml.ObjectFactory factory=new org.docx4j.wml.ObjectFactory();
  org.docx4j.wml.Package pkg=factory.createPackage();
  org.docx4j.wml.Package.Part pkgPartDocument=factory.createPackagePart();
  MainDocumentPart documentPart=getMainDocumentPart();
  pkgPartDocument.setName(documentPart.getPartName().getName());
  pkgPartDocument.setContentType(documentPart.getContentType());
  org.docx4j.wml.Package.Part.XmlData XmlDataDoc=factory.createPackagePartXmlData();
  org.docx4j.wml.Document wmlDocumentEl=(org.docx4j.wml.Document)documentPart.getJaxbElement();
  XmlDataDoc.setDocument(wmlDocumentEl);
  pkgPartDocument.setXmlData(XmlDataDoc);
  pkg.getPart().add(pkgPartDocument);
  org.docx4j.wml.Package.Part pkgPartStyles=factory.createPackagePart();
  org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart stylesPart=documentPart.getStyleDefinitionsPart();
  pkgPartStyles.setName(stylesPart.getPartName().getName());
  pkgPartStyles.setContentType(stylesPart.getContentType());
  org.docx4j.wml.Package.Part.XmlData XmlDataStyles=factory.createPackagePartXmlData();
  org.docx4j.wml.Styles styles=(org.docx4j.wml.Styles)stylesPart.getJaxbElement();
  XmlDataStyles.setStyles(styles);
  pkgPartStyles.setXmlData(XmlDataStyles);
  pkg.getPart().add(pkgPartStyles);
  return pkg;
}",0.9896755162241888
185136,"public void populateFontMappings(Map documentFontNames,org.docx4j.wml.Fonts fonts) throws Exception {
  List<Fonts.Font> fontList=fonts.getFont();
  Map<String,Fonts.Font> fontsInFontTable=new HashMap<String,Fonts.Font>();
  for (  Fonts.Font font : fontList) {
    fontsInFontTable.put(normalise(font.getName()),font);
  }
  log.info(""String_Node_Str"");
  Iterator documentFontIterator=documentFontNames.entrySet().iterator();
  while (documentFontIterator.hasNext()) {
    Map.Entry pairs=(Map.Entry)documentFontIterator.next();
    if (pairs.getKey() == null) {
      log.info(""String_Node_Str"");
      pairs=(Map.Entry)documentFontIterator.next();
    }
    String fontName=(String)pairs.getKey();
    log.info(""String_Node_Str"" + fontName);
    String normalisedFontName=normalise(fontName);
    if (fontMappings.get(normalisedFontName) != null) {
      continue;
    }
    boolean foundAwtMapping=false;
    boolean foundPdfMapping=false;
    FontMapping fm=new FontMapping();
    fm.setMicrosoftFontName(normalisedFontName);
    org.docx4j.wml.FontPanose panose=null;
    Fonts.Font font=fontsInFontTable.get(normalisedFontName);
    if (font == null) {
      log.error(""String_Node_Str"" + normalisedFontName + ""String_Node_Str"");
    }
 else {
      panose=font.getPanose1();
    }
    org.apache.fop.fonts.Panose fopPanose=null;
    if (panose != null && panose.getVal() != null) {
      fopPanose=new org.apache.fop.fonts.Panose(panose.getVal());
      System.out.println(""String_Node_Str"" + fopPanose.toString());
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (System.getProperty(""String_Node_Str"").toUpperCase().indexOf(""String_Node_Str"") > -1) {
    }
    if (physicalFontMap.get(normalise(fontName)) != null) {
      System.out.println(fontName + ""String_Node_Str"");
      foundPdfMapping=true;
      fm.setPdfSubstituteFont(normalise(fontName));
      fm.setPdfEmbeddedFile(((EmbedFontInfo)physicalFontMap.get(normalise(fontName))).getEmbedFile());
      EmbedFontInfo nfontInfo=((EmbedFontInfo)physicalFontMap.get(normalise(fontName)));
      if (nfontInfo.getPanose() == null) {
        System.out.println(""String_Node_Str"");
      }
 else       if (fopPanose != null) {
        long pd=fopPanose.difference(nfontInfo.getPanose().getPanoseArray());
        System.out.println(""String_Node_Str"" + pd);
      }
      continue;
    }
    String panoseKey=null;
    if (fopPanose != null) {
      if (!org.apache.fop.fonts.Panose.validPanose(panose.getVal())) {
        System.out.println(""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + fopPanose);
      Iterator it=physicalFontMap.entrySet().iterator();
      long bestPanoseMatchValue=-1;
      String matchingPanoseString=null;
      while (it.hasNext()) {
        Map.Entry mapPairs=(Map.Entry)it.next();
        EmbedFontInfo fontInfo=(EmbedFontInfo)mapPairs.getValue();
        if (fontInfo.getPanose() == null) {
          continue;
        }
        long panoseMatchValue=fopPanose.difference(fontInfo.getPanose().getPanoseArray());
        if (bestPanoseMatchValue == -1 || panoseMatchValue < bestPanoseMatchValue) {
          bestPanoseMatchValue=panoseMatchValue;
          matchingPanoseString=fontInfo.getPanose().toString();
          panoseKey=(String)mapPairs.getKey();
          if (bestPanoseMatchValue == 0) {
            continue;
          }
        }
 else {
        }
      }
      if (panoseKey != null && bestPanoseMatchValue < org.apache.fop.fonts.Panose.MATCH_THRESHOLD) {
        log.info(""String_Node_Str"" + panoseKey + ""String_Node_Str""+ matchingPanoseString+ ""String_Node_Str""+ bestPanoseMatchValue);
        log.debug(fontName + ""String_Node_Str"" + ((EmbedFontInfo)physicalFontMap.get(panoseKey)).getEmbedFile());
        fm.setPdfSubstituteFont(panoseKey);
        fm.setPdfEmbeddedFile(((EmbedFontInfo)physicalFontMap.get(panoseKey)).getEmbedFile());
        FontSubstitutions.Replace rtmp=(FontSubstitutions.Replace)replaceMap.get(normalise(fontName));
        if (rtmp != null && rtmp.getSubstFonts() != null) {
          if (rtmp.getSubstFonts().contains(panoseKey)) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
          }
        }
        continue;
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
    FontSubstitutions.Replace replacement=(FontSubstitutions.Replace)replaceMap.get(normalise(fontName));
    if (replacement != null) {
      String[] tokens=replacement.getSubstFonts().split(""String_Node_Str"");
      if (!foundPdfMapping) {
        for (int x=0; x < tokens.length; x++) {
          if (physicalFontMap.get(tokens[x]) != null) {
            EmbedFontInfo embedFontInfo=(EmbedFontInfo)physicalFontMap.get(tokens[x]);
            String physicalFontFile=embedFontInfo.getEmbedFile();
            log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ physicalFontFile);
            foundPdfMapping=true;
            fm.setPdfSubstituteFont(tokens[x]);
            fm.setPdfEmbeddedFile(physicalFontFile);
            if (embedFontInfo.getPanose() == null) {
              System.out.println(""String_Node_Str"");
            }
 else             if (fopPanose != null) {
              long pd=fopPanose.difference(embedFontInfo.getPanose().getPanoseArray());
              if (pd >= org.apache.fop.fonts.Panose.MATCH_THRESHOLD) {
                log.debug(""String_Node_Str"" + pd);
              }
 else {
                log.error(""String_Node_Str"" + pd);
              }
            }
            break;
          }
 else {
          }
        }
      }
      for (int x=0; x < tokens.length; x++) {
        if (awtFontFamilyNames.get(tokens[x]) != null) {
          log.debug(""String_Node_Str"" + tokens[x]);
          fm.setAwtSubstituteFont(tokens[x]);
          foundAwtMapping=true;
          break;
        }
 else {
        }
      }
      if (!foundAwtMapping) {
        log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ replacement.getSubstFonts());
      }
      if (!foundPdfMapping) {
        log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ replacement.getSubstFonts());
      }
    }
 else {
      System.out.println(""String_Node_Str"" + fontName);
    }
    fontMappings.put(normalisedFontName,fm);
    log.info(""String_Node_Str"" + normalisedFontName);
  }
}","public void populateFontMappings(Map documentFontNames,org.docx4j.wml.Fonts fonts) throws Exception {
  List<Fonts.Font> fontList=fonts.getFont();
  Map<String,Fonts.Font> fontsInFontTable=new HashMap<String,Fonts.Font>();
  for (  Fonts.Font font : fontList) {
    fontsInFontTable.put(normalise(font.getName()),font);
  }
  log.info(""String_Node_Str"");
  Iterator documentFontIterator=documentFontNames.entrySet().iterator();
  while (documentFontIterator.hasNext()) {
    Map.Entry pairs=(Map.Entry)documentFontIterator.next();
    if (pairs.getKey() == null) {
      log.info(""String_Node_Str"");
      pairs=(Map.Entry)documentFontIterator.next();
    }
    String fontName=(String)pairs.getKey();
    log.info(""String_Node_Str"" + fontName);
    String normalisedFontName=normalise(fontName);
    if (fontMappings.get(normalisedFontName) != null) {
      continue;
    }
    boolean foundAwtMapping=false;
    boolean foundPdfMapping=false;
    FontMapping fm=new FontMapping();
    fm.setMicrosoftFontName(normalisedFontName);
    org.docx4j.wml.FontPanose panose=null;
    Fonts.Font font=fontsInFontTable.get(normalisedFontName);
    if (font == null) {
      log.error(""String_Node_Str"" + normalisedFontName + ""String_Node_Str"");
    }
 else {
      panose=font.getPanose1();
    }
    org.apache.fop.fonts.Panose fopPanose=null;
    if (panose != null && panose.getVal() != null) {
      fopPanose=new org.apache.fop.fonts.Panose(panose.getVal());
      System.out.println(""String_Node_Str"" + fopPanose.toString());
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (System.getProperty(""String_Node_Str"").toUpperCase().indexOf(""String_Node_Str"") > -1) {
    }
    if (physicalFontMap.get(normalise(fontName)) != null) {
      System.out.println(fontName + ""String_Node_Str"");
      foundPdfMapping=true;
      fm.setPdfSubstituteFont(normalise(fontName));
      fm.setPdfEmbeddedFile(((EmbedFontInfo)physicalFontMap.get(normalise(fontName))).getEmbedFile());
      EmbedFontInfo nfontInfo=((EmbedFontInfo)physicalFontMap.get(normalise(fontName)));
      if (nfontInfo.getPanose() == null) {
        System.out.println(""String_Node_Str"");
      }
 else       if (fopPanose != null) {
        long pd=fopPanose.difference(nfontInfo.getPanose().getPanoseArray());
        System.out.println(""String_Node_Str"" + pd);
      }
      fontMappings.put(normalisedFontName,fm);
      log.info(""String_Node_Str"" + normalisedFontName);
      continue;
    }
    String panoseKey=null;
    if (fopPanose != null) {
      if (!org.apache.fop.fonts.Panose.validPanose(panose.getVal())) {
        System.out.println(""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + fopPanose);
      Iterator it=physicalFontMap.entrySet().iterator();
      long bestPanoseMatchValue=-1;
      String matchingPanoseString=null;
      while (it.hasNext()) {
        Map.Entry mapPairs=(Map.Entry)it.next();
        EmbedFontInfo fontInfo=(EmbedFontInfo)mapPairs.getValue();
        if (fontInfo.getPanose() == null) {
          continue;
        }
        long panoseMatchValue=fopPanose.difference(fontInfo.getPanose().getPanoseArray());
        if (bestPanoseMatchValue == -1 || panoseMatchValue < bestPanoseMatchValue) {
          bestPanoseMatchValue=panoseMatchValue;
          matchingPanoseString=fontInfo.getPanose().toString();
          panoseKey=(String)mapPairs.getKey();
          if (bestPanoseMatchValue == 0) {
            continue;
          }
        }
 else {
        }
      }
      if (panoseKey != null && bestPanoseMatchValue < org.apache.fop.fonts.Panose.MATCH_THRESHOLD) {
        log.info(""String_Node_Str"" + panoseKey + ""String_Node_Str""+ matchingPanoseString+ ""String_Node_Str""+ bestPanoseMatchValue);
        log.debug(fontName + ""String_Node_Str"" + ((EmbedFontInfo)physicalFontMap.get(panoseKey)).getEmbedFile());
        fm.setPdfSubstituteFont(panoseKey);
        fm.setPdfEmbeddedFile(((EmbedFontInfo)physicalFontMap.get(panoseKey)).getEmbedFile());
        FontSubstitutions.Replace rtmp=(FontSubstitutions.Replace)replaceMap.get(normalise(fontName));
        if (rtmp != null && rtmp.getSubstFonts() != null) {
          if (rtmp.getSubstFonts().contains(panoseKey)) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
          }
        }
        fontMappings.put(normalisedFontName,fm);
        log.info(""String_Node_Str"" + normalisedFontName);
        continue;
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
    FontSubstitutions.Replace replacement=(FontSubstitutions.Replace)replaceMap.get(normalise(fontName));
    if (replacement != null) {
      String[] tokens=replacement.getSubstFonts().split(""String_Node_Str"");
      if (!foundPdfMapping) {
        for (int x=0; x < tokens.length; x++) {
          if (physicalFontMap.get(tokens[x]) != null) {
            EmbedFontInfo embedFontInfo=(EmbedFontInfo)physicalFontMap.get(tokens[x]);
            String physicalFontFile=embedFontInfo.getEmbedFile();
            log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ physicalFontFile);
            foundPdfMapping=true;
            fm.setPdfSubstituteFont(tokens[x]);
            fm.setPdfEmbeddedFile(physicalFontFile);
            if (embedFontInfo.getPanose() == null) {
              System.out.println(""String_Node_Str"");
            }
 else             if (fopPanose != null) {
              long pd=fopPanose.difference(embedFontInfo.getPanose().getPanoseArray());
              if (pd >= org.apache.fop.fonts.Panose.MATCH_THRESHOLD) {
                log.debug(""String_Node_Str"" + pd);
              }
 else {
                log.error(""String_Node_Str"" + pd);
              }
            }
            break;
          }
 else {
          }
        }
      }
      for (int x=0; x < tokens.length; x++) {
        if (awtFontFamilyNames.get(tokens[x]) != null) {
          log.debug(""String_Node_Str"" + tokens[x]);
          fm.setAwtSubstituteFont(tokens[x]);
          foundAwtMapping=true;
          break;
        }
 else {
        }
      }
      if (!foundAwtMapping) {
        log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ replacement.getSubstFonts());
      }
      if (!foundPdfMapping) {
        log.debug(""String_Node_Str"" + fontName + ""String_Node_Str""+ replacement.getSubstFonts());
      }
    }
 else {
      System.out.println(""String_Node_Str"" + fontName);
    }
    fontMappings.put(normalisedFontName,fm);
    log.info(""String_Node_Str"" + normalisedFontName);
  }
}",0.9838610513372272
185137,"public boolean handleEvent(ValidationEvent ve){
  if (ve.getSeverity() == ValidationEvent.FATAL_ERROR || ve.getSeverity() == ValidationEvent.ERROR) {
    ValidationEventLocator locator=ve.getLocator();
    if (log.isDebugEnabled()) {
      log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage());
    }
 else {
      log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage().substring(0,120));
    }
    if (ve.getLinkedException() != null && log.isDebugEnabled()) {
      ve.getLinkedException().printStackTrace();
    }
  }
 else   if (ve.getSeverity() == ve.WARNING) {
    log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage());
  }
  log.info(""String_Node_Str"");
  return true;
}","public boolean handleEvent(ValidationEvent ve){
  if (ve.getSeverity() == ValidationEvent.FATAL_ERROR || ve.getSeverity() == ValidationEvent.ERROR) {
    ValidationEventLocator locator=ve.getLocator();
    if (log.isDebugEnabled() || ve.getMessage().length() < 120) {
      log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage());
    }
 else {
      log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage().substring(0,120));
    }
    if (ve.getLinkedException() != null && log.isDebugEnabled()) {
      ve.getLinkedException().printStackTrace();
    }
  }
 else   if (ve.getSeverity() == ve.WARNING) {
    log.warn(printSeverity(ve) + ""String_Node_Str"" + ve.getMessage());
  }
  log.info(""String_Node_Str"");
  return true;
}",0.9766483516483516
185138,"/** 
 * Gets the value of the blockLevelElements property. <p> This accessor method returns a reference to the live list, not a snapshot. Therefore any modification you make to the returned list will be present inside the JAXB object. This is why there is not a <CODE>set</CODE> method for the blockLevelElements property. <p> For example, to add a new item, do as follows: <pre> getBlockLevelElements().add(newItem); </pre> <p> Objects of the following type(s) are allowed in the list  {@link JAXBElement }{@code <}{@link RunTrackChange }{@code >}{@link JAXBElement }{@code <}{@link Tbl }{@code >}{@link Sdt }{@link JAXBElement }{@code <}{@link P }{@code >}{@link JAXBElement }{@code <}{@link RunTrackChange }{@code >}
 */
public List<Object> getBlockLevelElements(){
  if (blockLevelElements == null) {
    blockLevelElements=new ArrayList<Object>();
  }
  return this.blockLevelElements;
}","/** 
 * Gets the value of the blockLevelElements property. <p> This accessor method returns a reference to the live list, not a snapshot. Therefore any modification you make to the returned list will be present inside the JAXB object. This is why there is not a <CODE>set</CODE> method for the blockLevelElements property. <p> For example, to add a new item, do as follows: <pre> getBlockLevelElements().add(newItem); </pre> <p> Objects of the following type(s) are allowed in the list  {@link JAXBElement }{@code <}{@link RunTrackChange }{@code >}{@link JAXBElement }{@code <}{@link RunTrackChange }{@code >}{@link JAXBElement }{@code <}{@link P }{@code >}{@link JAXBElement }{@code <}{@link Tbl }{@code >}{@link Sdt }
 */
public List<Object> getBlockLevelElements(){
  if (blockLevelElements == null) {
    blockLevelElements=new ArrayList<Object>();
  }
  return this.blockLevelElements;
}",0.9473094170403588
185139,"/** 
 * Gets the value of the val property.
 * @return possible object is {@link String }
 */
public byte[] getVal(){
  return val;
}","/** 
 * Gets the value of the val property.
 * @return possible object is {@link String }
 */
public String getVal(){
  return val;
}",0.962406015037594
185140,"/** 
 * Sets the value of the val property.
 * @param value allowed object is {@link String }
 */
public void setVal(byte[] value){
  this.val=((byte[])value);
}","/** 
 * Sets the value of the val property.
 * @param value allowed object is {@link String }
 */
public void setVal(String value){
  this.val=value;
}",0.935897435897436
185141,"public void saveRawXmlPart(ZipOutputStream out,Part part) throws Docx4JException {
  String partName=part.getPartName().getName().substring(1);
  if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
    try {
      ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).marshal(out);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
    try {
      out.putNextEntry(new ZipEntry(partName));
      OutputFormat format=OutputFormat.createPrettyPrint();
      format.setEncoding(""String_Node_Str"");
      XMLWriter writer=new XMLWriter(out,format);
      writer.write(((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).getDocument());
      out.closeEntry();
      log.info(""String_Node_Str"" + partName);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw new Docx4JException(""String_Node_Str"" + partName,e);
    }
  }
 else {
    log.error(""String_Node_Str"" + partName);
  }
}","public void saveRawXmlPart(ZipOutputStream out,Part part) throws Docx4JException {
  String partName=part.getPartName().getName().substring(1);
  if (part instanceof org.docx4j.openpackaging.parts.JaxbXmlPart) {
    try {
      out.putNextEntry(new ZipEntry(partName));
      ((org.docx4j.openpackaging.parts.JaxbXmlPart)part).marshal(out);
      out.closeEntry();
      log.info(""String_Node_Str"" + partName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (part instanceof org.docx4j.openpackaging.parts.Dom4jXmlPart) {
    try {
      out.putNextEntry(new ZipEntry(partName));
      OutputFormat format=OutputFormat.createPrettyPrint();
      format.setEncoding(""String_Node_Str"");
      XMLWriter writer=new XMLWriter(out,format);
      writer.write(((org.docx4j.openpackaging.parts.Dom4jXmlPart)part).getDocument());
      out.closeEntry();
      log.info(""String_Node_Str"" + partName);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw new Docx4JException(""String_Node_Str"" + partName,e);
    }
  }
 else {
    log.error(""String_Node_Str"" + partName);
  }
}",0.9443396226415094
185142,"/** 
 * Get the text content of all runs in the P 
 */
public String toString(){
  StringBuilder result=new StringBuilder();
  List<Object> children=getParagraphContent();
  for (  Object o : children) {
    System.out.println(""String_Node_Str"" + o.getClass().getName());
    if (o instanceof org.docx4j.jaxb.document.R) {
      org.docx4j.jaxb.document.R run=(org.docx4j.jaxb.document.R)o;
      List<Object> runContent=run.getRunContent();
      for (      Object o2 : runContent) {
        if (o instanceof javax.xml.bind.JAXBElement) {
          if (((JAXBElement)o).getDeclaredType().getName().equals(""String_Node_Str"")) {
            org.docx4j.jaxb.document.Text t=(org.docx4j.jaxb.document.Text)((JAXBElement)o).getValue();
            result.append(t.getValue());
          }
        }
      }
    }
  }
  return result.toString();
}","/** 
 * Get the text content of all runs in the P 
 */
public String toString(){
  StringBuilder result=new StringBuilder();
  List<Object> children=getParagraphContent();
  for (  Object o : children) {
    if (o instanceof org.docx4j.jaxb.document.R) {
      org.docx4j.jaxb.document.R run=(org.docx4j.jaxb.document.R)o;
      List<Object> runContent=run.getRunContent();
      for (      Object o2 : runContent) {
        if (o2 instanceof javax.xml.bind.JAXBElement) {
          if (((JAXBElement)o2).getDeclaredType().getName().equals(""String_Node_Str"")) {
            org.docx4j.jaxb.document.Text t=(org.docx4j.jaxb.document.Text)((JAXBElement)o2).getValue();
            result.append(t.getValue());
          }
        }
 else {
        }
      }
    }
  }
  return result.toString();
}",0.9456322541233964
185143,"public DatabaseSearchUI(){
  setLayout(new BorderLayout());
  JPanel displayNamePanel=new JPanel(new BorderLayout());
  JLabel displayNameLabel=new JLabel(""String_Node_Str"");
  baseDisplayedNameField=new JTextField();
  baseDisplayedNameField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (goButton.isEnabled())       goButton.doClick();
    }
  }
);
  displayNameLabel.setLabelFor(baseDisplayedNameField);
  displayNamePanel.add(baseDisplayedNameField,BorderLayout.CENTER);
  displayNamePanel.add(displayNameLabel,BorderLayout.WEST);
  goButton=new JButton();
  String searchButtonText=""String_Node_Str"";
  goButton.getAccessibleContext().setAccessibleName(searchButtonText);
  goButton.setAction(new AbstractAction(searchButtonText){
    @Override public void actionPerformed(    ActionEvent e){
      goButton.setEnabled(false);
      SearchTask task=new SearchTask();
      listModel.removeAllElements();
      resultStatus.setText(null);
      task.execute();
    }
  }
);
  JPanel displayNameAndGoPanel=new JPanel(new BorderLayout());
  displayNameAndGoPanel.add(displayNamePanel,BorderLayout.CENTER);
  displayNameAndGoPanel.add(goButton,BorderLayout.EAST);
  listModel=new DefaultListModel();
  list=new JList(listModel);
  list.getAccessibleContext().setAccessibleName(""String_Node_Str"");
  list.setCellRenderer(new DefaultListCellRenderer(){
    @Override public Component getListCellRendererComponent(    JList list,    Object value,    int index,    boolean isSelected,    boolean cellHasFocus){
      ComponentInfo ci=(ComponentInfo)value;
      JLabel label=(JLabel)super.getListCellRendererComponent(list,ci.name,index,isSelected,cellHasFocus);
      label.setIcon(AbstractComponent.getIconForComponentType(ci.type));
      return label;
    }
  }
);
  list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
  list.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        Collection<View> selectedManifestations=getSelectedManifestations();
        if (!selectedManifestations.isEmpty()) {
          firePropertyChange(SelectionProvider.SELECTION_CHANGED_PROP,null,selectedManifestations);
        }
      }
    }
  }
);
  list.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      Collection<View> selectedManifestations=getSelectedManifestations();
      if (selectedManifestations.isEmpty())       return;
      View manifestation=selectedManifestations.iterator().next();
      if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {
        manifestation.getManifestedComponent().open();
        return;
      }
    }
  }
);
  list.setDragEnabled(true);
  list.setTransferHandler(new TransferHandler(){
    @Override protected Transferable createTransferable(    JComponent c){
      List<View> viewRoles=new ArrayList<View>();
      Collection<View> selectedManifestations=getSelectedManifestations();
      if (!selectedManifestations.isEmpty()) {
        for (        View manifestation : getSelectedManifestations())         viewRoles.add(manifestation);
        return new ViewRoleSelection(viewRoles.toArray(new View[viewRoles.size()]));
      }
 else {
        return null;
      }
    }
    @Override public int getSourceActions(    JComponent c){
      return TransferHandler.COPY;
    }
  }
);
  JPanel controlPanel=new JPanel(new GridLayout(2,1,5,5));
  controlPanel.add(displayNameAndGoPanel);
  findObjectsCreatedByMe=new JCheckBox(""String_Node_Str"");
  controlPanel.add(findObjectsCreatedByMe);
  JPanel descriptionPanel=new JPanel(new GridLayout(2,1));
  JLabel searchEverywhereLabel=new JLabel(""String_Node_Str"");
  searchEverywhereLabel.setFont(searchEverywhereLabel.getFont().deriveFont(Font.BOLD));
  resultStatus=new JLabel();
  resultStatus.setForeground(Color.BLUE);
  descriptionPanel.add(searchEverywhereLabel);
  descriptionPanel.add(resultStatus);
  JPanel upperPanel=new JPanel(new BorderLayout(PADDING,PADDING));
  upperPanel.setBorder(BorderFactory.createEmptyBorder(PADDING,PADDING,PADDING,PADDING));
  upperPanel.add(descriptionPanel,BorderLayout.NORTH);
  upperPanel.add(controlPanel,BorderLayout.CENTER);
  add(upperPanel,BorderLayout.NORTH);
  add(new JScrollPane(list),BorderLayout.CENTER);
}","public DatabaseSearchUI(){
  setLayout(new BorderLayout());
  JPanel displayNamePanel=new JPanel(new BorderLayout());
  JLabel displayNameLabel=new JLabel(""String_Node_Str"");
  baseDisplayedNameField=new JTextField();
  baseDisplayedNameField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (goButton.isEnabled())       goButton.doClick();
    }
  }
);
  displayNameLabel.setLabelFor(baseDisplayedNameField);
  displayNamePanel.add(baseDisplayedNameField,BorderLayout.CENTER);
  displayNamePanel.add(displayNameLabel,BorderLayout.WEST);
  goButton=new JButton();
  String searchButtonText=""String_Node_Str"";
  goButton.getAccessibleContext().setAccessibleName(searchButtonText);
  goButton.setAction(new AbstractAction(searchButtonText){
    @Override public void actionPerformed(    ActionEvent e){
      goButton.setEnabled(false);
      SearchTask task=new SearchTask();
      listModel.removeAllElements();
      resultStatus.setText(null);
      task.execute();
    }
  }
);
  JPanel displayNameAndGoPanel=new JPanel(new BorderLayout());
  displayNameAndGoPanel.add(displayNamePanel,BorderLayout.CENTER);
  displayNameAndGoPanel.add(goButton,BorderLayout.EAST);
  listModel=new DefaultListModel();
  list=new JList(listModel);
  list.getAccessibleContext().setAccessibleName(""String_Node_Str"");
  list.setCellRenderer(new DefaultListCellRenderer(){
    @Override public Component getListCellRendererComponent(    JList list,    Object value,    int index,    boolean isSelected,    boolean cellHasFocus){
      ComponentInfo ci=(ComponentInfo)value;
      JLabel label=(JLabel)super.getListCellRendererComponent(list,ci.name,index,isSelected,cellHasFocus);
      label.setIcon(getIconForComponentType(ci.type));
      return label;
    }
  }
);
  list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
  list.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        Collection<View> selectedManifestations=getSelectedManifestations();
        if (!selectedManifestations.isEmpty()) {
          firePropertyChange(SelectionProvider.SELECTION_CHANGED_PROP,null,selectedManifestations);
        }
      }
    }
  }
);
  list.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      Collection<View> selectedManifestations=getSelectedManifestations();
      if (selectedManifestations.isEmpty())       return;
      View manifestation=selectedManifestations.iterator().next();
      if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {
        manifestation.getManifestedComponent().open();
        return;
      }
    }
  }
);
  list.setDragEnabled(true);
  list.setTransferHandler(new TransferHandler(){
    @Override protected Transferable createTransferable(    JComponent c){
      List<View> viewRoles=new ArrayList<View>();
      Collection<View> selectedManifestations=getSelectedManifestations();
      if (!selectedManifestations.isEmpty()) {
        for (        View manifestation : getSelectedManifestations())         viewRoles.add(manifestation);
        return new ViewRoleSelection(viewRoles.toArray(new View[viewRoles.size()]));
      }
 else {
        return null;
      }
    }
    @Override public int getSourceActions(    JComponent c){
      return TransferHandler.COPY;
    }
  }
);
  JPanel controlPanel=new JPanel(new GridLayout(2,1,5,5));
  controlPanel.add(displayNameAndGoPanel);
  findObjectsCreatedByMe=new JCheckBox(""String_Node_Str"");
  controlPanel.add(findObjectsCreatedByMe);
  JPanel descriptionPanel=new JPanel(new GridLayout(2,1));
  JLabel searchEverywhereLabel=new JLabel(""String_Node_Str"");
  searchEverywhereLabel.setFont(searchEverywhereLabel.getFont().deriveFont(Font.BOLD));
  resultStatus=new JLabel();
  resultStatus.setForeground(Color.BLUE);
  descriptionPanel.add(searchEverywhereLabel);
  descriptionPanel.add(resultStatus);
  JPanel upperPanel=new JPanel(new BorderLayout(PADDING,PADDING));
  upperPanel.setBorder(BorderFactory.createEmptyBorder(PADDING,PADDING,PADDING,PADDING));
  upperPanel.add(descriptionPanel,BorderLayout.NORTH);
  upperPanel.add(controlPanel,BorderLayout.CENTER);
  add(upperPanel,BorderLayout.NORTH);
  add(new JScrollPane(list),BorderLayout.CENTER);
}",0.9979489516864176
185144,"@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  ComponentInfo ci=(ComponentInfo)value;
  JLabel label=(JLabel)super.getListCellRendererComponent(list,ci.name,index,isSelected,cellHasFocus);
  label.setIcon(AbstractComponent.getIconForComponentType(ci.type));
  return label;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  ComponentInfo ci=(ComponentInfo)value;
  JLabel label=(JLabel)super.getListCellRendererComponent(list,ci.name,index,isSelected,cellHasFocus);
  label.setIcon(getIconForComponentType(ci.type));
  return label;
}",0.9745042492917848
185145,"@Test public void testComponentTypeInfos(){
  boolean foundGraphicalComponent=false;
  for (  ComponentTypeInfo info : provider.getComponentTypes()) {
    if (info.getComponentClass().equals(GraphicalComponent.class)) {
      foundGraphicalComponent=true;
      Assert.assertTrue(info.isCreatable());
      Assert.assertTrue(info.getWizardUI() instanceof GraphicalComponentWizardUI);
    }
  }
  Assert.assertTrue(foundGraphicalComponent);
}","@Test public void testComponentTypeInfos(){
  boolean foundGraphicalComponent=false;
  for (  ComponentTypeInfo info : provider.getComponentTypes()) {
    if (info.getComponentClass().equals(GraphicalComponent.class)) {
      foundGraphicalComponent=true;
      Assert.assertTrue(info.isCreatable());
    }
  }
  Assert.assertTrue(foundGraphicalComponent);
}",0.8685857321652065
185146,"@Test public void testPolicyInfos(){
  boolean foundPolicy=false;
  for (  PolicyInfo info : provider.getPolicyInfos()) {
    for (    Class c : info.getPolicyClasses()) {
      if (c.equals(GraphicalViewPolicy.class)) {
        foundPolicy=true;
        Assert.assertEquals(info.getCategoryKey(),PolicyInfo.CategoryType.FILTER_VIEW_ROLE.getKey());
      }
    }
  }
  Assert.assertTrue(foundPolicy);
}","@Test public void testPolicyInfos(){
  boolean foundPolicy=false;
  for (  PolicyInfo info : provider.getPolicyInfos()) {
    for (    Class<?> c : info.getPolicyClasses()) {
      if (c.equals(GraphicalViewPolicy.class)) {
        foundPolicy=true;
        Assert.assertEquals(info.getCategoryKey(),PolicyInfo.CategoryType.FILTER_VIEW_ROLE.getKey());
      }
    }
  }
  Assert.assertTrue(foundPolicy);
}",0.9962825278810408
185147,"@Test public void testViews(){
  Collection<ViewInfo> views=evaluatorProvider.getViews(EvaluatorComponent.class.getName());
  Assert.assertEquals(views.size(),3);
  Assert.assertTrue(views.contains(new ViewInfo(ExpressionsViewManifestation.class,""String_Node_Str"",ViewType.CENTER)));
  Iterator<ViewInfo> it=evaluatorProvider.getViews(EvaluatorComponent.class.getName()).iterator();
  Assert.assertEquals(it.next(),new ViewInfo(InfoViewManifestation.class,""String_Node_Str"",ViewType.CENTER));
  Assert.assertEquals(it.next(),new ViewInfo(ExpressionsViewManifestation.class,""String_Node_Str"",ViewType.CENTER));
  views=multiProvider.getViews(MultiComponent.class.getName());
  Assert.assertEquals(views.size(),3);
  Assert.assertTrue(views.contains(new ViewInfo(MultiViewManifestation.class,""String_Node_Str"",ViewType.CENTER)));
  it=multiProvider.getViews(MultiComponent.class.getName()).iterator();
  Assert.assertEquals(it.next(),new ViewInfo(InfoViewManifestation.class,InfoViewManifestation.VIEW_NAME,InfoViewManifestation.class.getName(),ViewType.OBJECT,null,null,false,MultiComponent.class));
  Assert.assertEquals(it.next(),new ViewInfo(MultiViewManifestation.class,MultiViewManifestation.VIEW_NAME,ViewType.OBJECT));
  Assert.assertEquals(it.next(),new ViewInfo(MultiViewManifestation.class,MultiViewManifestation.VIEW_NAME,InfoViewManifestation.class.getName(),ViewType.CENTER,null,null,true,MultiComponent.class));
}","@Test public void testViews(){
  Collection<ViewInfo> views=evaluatorProvider.getViews(EvaluatorComponent.class.getName());
  Assert.assertEquals(views.size(),3);
  Assert.assertTrue(views.contains(new ViewInfo(ExpressionsViewManifestation.class,""String_Node_Str"",ViewType.CENTER)));
  Iterator<ViewInfo> it=evaluatorProvider.getViews(EvaluatorComponent.class.getName()).iterator();
  Assert.assertEquals(it.next(),new ViewInfo(InfoViewManifestation.class,""String_Node_Str"",ViewType.CENTER));
  Assert.assertEquals(it.next(),new ViewInfo(ExpressionsViewManifestation.class,""String_Node_Str"",ViewType.CENTER));
  views=multiProvider.getViews(MultiComponent.class.getName());
  Assert.assertEquals(views.size(),3);
  Assert.assertTrue(views.contains(new ViewInfo(MultiViewManifestation.class,""String_Node_Str"",ViewType.CENTER)));
  it=multiProvider.getViews(MultiComponent.class.getName()).iterator();
  Assert.assertEquals(it.next(),new ViewInfo(InfoViewManifestation.class,InfoViewManifestation.VIEW_NAME,InfoViewManifestation.class.getName(),ViewType.OBJECT));
  Assert.assertEquals(it.next(),new ViewInfo(MultiViewManifestation.class,MultiViewManifestation.VIEW_NAME,ViewType.OBJECT));
  Assert.assertEquals(it.next(),new ViewInfo(MultiViewManifestation.class,MultiViewManifestation.VIEW_NAME,InfoViewManifestation.class.getName(),ViewType.CENTER));
}",0.9737315581144296
185148,"/** 
 * Get an asset of a specified type. For instance, an  Icon may be retrieved using getAsset(Icon.class).
 * @param assetClass the desired type of asset
 * @return an asset of the desired type (or null if there is none)
 */
public <T>T getAsset(Class<T> assetClass){
  return getCapability(ComponentTypeInfo.class).getAsset(assetClass);
}","/** 
 * Get an asset of a specified type. For instance, an  Icon may be retrieved using getAsset(Icon.class).
 * @param < T > the type of asset desired
 * @param assetClass the desired type of asset
 * @return an asset of the desired type (or null if there is none)
 */
public <T>T getAsset(Class<T> assetClass){
  return getCapability(ComponentTypeInfo.class).getAsset(assetClass);
}",0.7796143250688705
185149,public ProviderDelegateService getProviderDelegateService();,"/** 
 * Provides an instance of the provider delegate service
 * @return the provider delegate service
 */
public ProviderDelegateService getProviderDelegateService();",0.5286343612334802
185150,"/** 
 * Get some asset associated with a given object type. Typically this will be used to obtain  things like icons or create wizards which are associated with specific component or view  types, but are not incorporated into those types directly to preserve separation of  concerns. 
 * @param objectType the type with which the requested asset is associated
 * @param assetClass the type of the requested asset
 * @return an asset of the requested type (or null, if none is provided)
 */
<T>T getAsset(TypeInfo<?> objectType,Class<T> assetClass);","/** 
 * Get some asset associated with a given object type. Typically this will be used to obtain  things like icons or create wizards which are associated with specific component or view  types, but are not incorporated into those types directly to preserve separation of  concerns. 
 * @param < T > the type of asset desired
 * @param objectType the type with which the requested asset is associated
 * @param assetClass the type of the requested asset
 * @return an asset of the requested type (or null, if none is provided)
 */
<T>T getAsset(TypeInfo<?> objectType,Class<T> assetClass);",0.9630931458699472
185151,"/** 
 * Get an asset associated with this type. For instance, getAsset(ImageIcon.class) to get  an icon.
 * @param assetClass the type of asset desired
 * @return an object of the desired type (or null if none is available)
 */
public <A>A getAsset(Class<A> assetClass){
  return PlatformAccess.getPlatform().getComponentRegistry().getAsset(this,assetClass);
}","/** 
 * Get an asset associated with this type. For instance, getAsset(ImageIcon.class) to get  an icon.
 * @param assetClass the type of asset desired
 * @param < A > the type of asset desired
 * @return an object of the desired type (or null if none is available)
 */
public <A>A getAsset(Class<A> assetClass){
  return PlatformAccess.getPlatform().getComponentRegistry().getAsset(this,assetClass);
}",0.9448818897637796
185152,"/** 
 * Get an asset of a specific type, associated with some other type.  For instance, this can be used to obtain an Icon  for a specific component or view class.
 * @param objectType the type with which the asset is associated
 * @param assetClass the type of the desired asset
 * @return an asset of the desired type (or null if none is available)
 */
public <T>T getAsset(TypeInfo<?> objectType,Class<T> assetClass);","/** 
 * Get an asset of a specific type, associated with some other type.  For instance, this can be used to obtain an Icon  for a specific component or view class.
 * @param < T > the type of asset desired
 * @param objectType the type with which the asset is associated
 * @param assetClass the type of the desired asset
 * @return an asset of the desired type (or null if none is available)
 */
public <T>T getAsset(TypeInfo<?> objectType,Class<T> assetClass);",0.9524886877828054
185153,"private JComboBox createOwnerField(){
  List<String> usersAndRoles=new ArrayList<String>();
  usersAndRoles.addAll(Arrays.asList(RoleAccess.getAllRoles()));
  usersAndRoles.addAll(Arrays.asList(RoleAccess.getAllUsers()));
  final JComboBox comboBox=new JComboBox(usersAndRoles.toArray());
  comboBox.setSelectedItem(getManifestedComponent().getOwner());
  return comboBox;
}","@SuppressWarnings(""String_Node_Str"") private JComboBox createOwnerField(){
  List<String> usersAndRoles=new ArrayList<String>();
  usersAndRoles.addAll(Arrays.asList(RoleAccess.getAllRoles()));
  usersAndRoles.addAll(Arrays.asList(RoleAccess.getAllUsers()));
  @SuppressWarnings(""String_Node_Str"") final JComboBox comboBox=new JComboBox(usersAndRoles.toArray());
  comboBox.setSelectedItem(getManifestedComponent().getOwner());
  return comboBox;
}",0.9099756690997568
185154,"private void populateVisualComponent(JComponent component,PropertyDescriptor p){
  Object newValue=null;
switch (p.getVisualControlDescriptor()) {
case Label:
{
      ((JLabel)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
      break;
    }
case TextField:
{
    ((JTextField)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
    break;
  }
case CheckBox:
{
  ((JCheckBox)component).setSelected((Boolean)(newValue=p.getPropertyEditor().getValue()));
  break;
}
case ComboBox:
{
((JComboBox)component).getModel().setSelectedItem(newValue=p.getPropertyEditor().getValue());
break;
}
case TextArea:
{
((JTextArea)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
break;
}
}
extendedFieldCache.put(component,newValue);
}","@SuppressWarnings(""String_Node_Str"") private void populateVisualComponent(JComponent component,PropertyDescriptor p){
  Object newValue=null;
switch (p.getVisualControlDescriptor()) {
case Label:
{
      ((JLabel)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
      break;
    }
case TextField:
{
    ((JTextField)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
    break;
  }
case CheckBox:
{
  ((JCheckBox)component).setSelected((Boolean)(newValue=p.getPropertyEditor().getValue()));
  break;
}
case ComboBox:
{
((JComboBox)component).getModel().setSelectedItem(newValue=p.getPropertyEditor().getValue());
break;
}
case TextArea:
{
((JTextArea)component).setText((String)(newValue=p.getPropertyEditor().getAsText()));
break;
}
}
extendedFieldCache.put(component,newValue);
}",0.9771745835903765
185155,"@Override public void enterLockedState(){
  boolean allowEdit=checkAllowComponentRenamePolicy();
  displayName.setFocusable(allowEdit);
  if (allowEdit) {
    displayName.setEnabled(true);
    displayName.setEditable(true);
  }
 else {
    displayName.setEnabled(false);
    displayName.setDisabledTextColor(fgUIColor);
  }
  boolean canChangeUser=RoleAccess.canChangeOwner(getManifestedComponent(),currentUser);
  owner.setFocusable(canChangeUser);
  owner.setEnabled(canChangeUser);
  if (!canChangeUser) {
    owner.setRenderer(new DefaultListCellRenderer(){
      public void paint(      Graphics g){
        setBackground(bgUIColor);
        setForeground(fgUIColor);
        super.paint(g);
      }
    }
);
  }
  addExtendedContent();
  for (  JComponent jComponent : extendedFieldCache.keySet()) {
    jComponent.setFocusable(true);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void enterLockedState(){
  boolean allowEdit=checkAllowComponentRenamePolicy();
  displayName.setFocusable(allowEdit);
  if (allowEdit) {
    displayName.setEnabled(true);
    displayName.setEditable(true);
  }
 else {
    displayName.setEnabled(false);
    displayName.setDisabledTextColor(fgUIColor);
  }
  boolean canChangeUser=RoleAccess.canChangeOwner(getManifestedComponent(),currentUser);
  owner.setFocusable(canChangeUser);
  owner.setEnabled(canChangeUser);
  if (!canChangeUser) {
    owner.setRenderer(new DefaultListCellRenderer(){
      public void paint(      Graphics g){
        setBackground(bgUIColor);
        setForeground(fgUIColor);
        super.paint(g);
      }
    }
);
  }
  addExtendedContent();
  for (  JComponent jComponent : extendedFieldCache.keySet()) {
    jComponent.setFocusable(true);
  }
}",0.9786003470213996
185156,"@Override public void exitLockedState(){
  boolean allowEdit=checkAllowComponentRenamePolicy();
  displayName.setFocusable(allowEdit);
  displayName.setEnabled(allowEdit);
  displayName.setEditable(allowEdit);
  owner.setFocusable(false);
  owner.setEnabled(false);
  owner.setRenderer(new DefaultListCellRenderer(){
    public void paint(    Graphics g){
      setBackground(bgUIColor);
      setForeground(fgUIColor);
      super.paint(g);
    }
  }
);
  addExtendedContent();
  for (  JComponent jComponent : extendedFieldCache.keySet()) {
    jComponent.setFocusable(false);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void exitLockedState(){
  boolean allowEdit=checkAllowComponentRenamePolicy();
  displayName.setFocusable(allowEdit);
  displayName.setEnabled(allowEdit);
  displayName.setEditable(allowEdit);
  owner.setFocusable(false);
  owner.setEnabled(false);
  owner.setRenderer(new DefaultListCellRenderer(){
    public void paint(    Graphics g){
      setBackground(bgUIColor);
      setForeground(fgUIColor);
      super.paint(g);
    }
  }
);
  addExtendedContent();
  for (  JComponent jComponent : extendedFieldCache.keySet()) {
    jComponent.setFocusable(false);
  }
}",0.9692946058091286
185157,"private JPanel buildWarningPanel(Set<String> componentsToBeDeleted){
  List<String> deleteComps=new ArrayList<String>(componentsToBeDeleted.size());
  for (  String comp : componentsToBeDeleted) {
    deleteComps.add(AbstractComponent.getComponentById(comp).getDisplayName());
  }
  JPanel warning=new JPanel(new FlowLayout());
  warning.setPreferredSize(new Dimension(400,400));
  JList deleteList=new JList(deleteComps.toArray());
  JScrollPane scrollPane2=new JScrollPane(deleteList);
  scrollPane2.setPreferredSize(new Dimension(300,200));
  JLabel deletingObjectsLabel=new JLabel(bundle.getString(""String_Node_Str""));
  deletingObjectsLabel.setPreferredSize(new Dimension(300,20));
  deletingObjectsLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  deletingObjectsLabel.setHorizontalAlignment(SwingConstants.LEFT);
  JTextArea warningMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  warningMessage.setWrapStyleWord(true);
  warningMessage.setLineWrap(true);
  warningMessage.setOpaque(false);
  warningMessage.setPreferredSize(new Dimension(300,200));
  warningMessage.setEditable(false);
  warning.add(warningMessage);
  warning.add(deletingObjectsLabel);
  warning.add(scrollPane2);
  return warning;
}","private JPanel buildWarningPanel(Set<String> componentsToBeDeleted){
  List<String> deleteComps=new ArrayList<String>(componentsToBeDeleted.size());
  for (  String comp : componentsToBeDeleted) {
    deleteComps.add(AbstractComponent.getComponentById(comp).getDisplayName());
  }
  JPanel warning=new JPanel(new FlowLayout());
  warning.setPreferredSize(new Dimension(400,400));
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) JList deleteList=new JList(deleteComps.toArray());
  JScrollPane scrollPane2=new JScrollPane(deleteList);
  scrollPane2.setPreferredSize(new Dimension(300,200));
  JLabel deletingObjectsLabel=new JLabel(bundle.getString(""String_Node_Str""));
  deletingObjectsLabel.setPreferredSize(new Dimension(300,20));
  deletingObjectsLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  deletingObjectsLabel.setHorizontalAlignment(SwingConstants.LEFT);
  JTextArea warningMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  warningMessage.setWrapStyleWord(true);
  warningMessage.setLineWrap(true);
  warningMessage.setOpaque(false);
  warningMessage.setPreferredSize(new Dimension(300,200));
  warningMessage.setEditable(false);
  warning.add(warningMessage);
  warning.add(deletingObjectsLabel);
  warning.add(scrollPane2);
  return warning;
}",0.977263661747108
185158,"private JPanel buildWarningPanel(List<Map<MCTMutableTreeNode,MCTMutableTreeNode>> okToRemoveManifestations,Set<String> lastManifestationComponents){
  Set<String> okComps=new HashSet<String>(okToRemoveManifestations.size());
  List<String> lastComps=new ArrayList<String>(lastManifestationComponents.size());
  for (  Map<MCTMutableTreeNode,MCTMutableTreeNode> okMap : okToRemoveManifestations) {
    AbstractComponent selectedComponent=((View)okMap.entrySet().iterator().next().getValue().getUserObject()).getManifestedComponent();
    okComps.add(selectedComponent.getDisplayName());
  }
  for (  String comp : lastManifestationComponents) {
    lastComps.add(AbstractComponent.getComponentById(comp).getDisplayName());
  }
  JPanel warning=new JPanel(new GridLayout(3,2,0,0));
  warning.setPreferredSize(new Dimension(600,220));
  JList okList=new JList(okComps.toArray());
  JList lastManifestationList=new JList(lastComps.toArray());
  JScrollPane scrollPane1=new JScrollPane(okList);
  scrollPane1.setPreferredSize(new Dimension(180,100));
  JScrollPane scrollPane2=new JScrollPane(lastManifestationList);
  scrollPane2.setPreferredSize(new Dimension(180,100));
  JLabel okLabel=new JLabel(bundle.getString(""String_Node_Str""));
  okLabel.setPreferredSize(new Dimension(200,20));
  okLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  JLabel lastManifestationLabel=new JLabel(bundle.getString(""String_Node_Str""));
  lastManifestationLabel.setPreferredSize(new Dimension(200,20));
  lastManifestationLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  JTextArea warningMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  warningMessage.setWrapStyleWord(true);
  warningMessage.setLineWrap(true);
  warningMessage.setOpaque(false);
  warningMessage.setPreferredSize(new Dimension(180,100));
  warningMessage.setEditable(false);
  JTextArea removeMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  removeMessage.setWrapStyleWord(true);
  removeMessage.setLineWrap(true);
  removeMessage.setOpaque(false);
  removeMessage.setPreferredSize(new Dimension(200,100));
  removeMessage.setMargin(new Insets(0,10,0,10));
  removeMessage.setEditable(false);
  warning.add(removeMessage);
  warning.add(warningMessage);
  warning.add(okLabel);
  warning.add(lastManifestationLabel);
  warning.add(scrollPane1);
  warning.add(scrollPane2);
  return warning;
}","private JPanel buildWarningPanel(List<Map<MCTMutableTreeNode,MCTMutableTreeNode>> okToRemoveManifestations,Set<String> lastManifestationComponents){
  Set<String> okComps=new HashSet<String>(okToRemoveManifestations.size());
  List<String> lastComps=new ArrayList<String>(lastManifestationComponents.size());
  for (  Map<MCTMutableTreeNode,MCTMutableTreeNode> okMap : okToRemoveManifestations) {
    AbstractComponent selectedComponent=((View)okMap.entrySet().iterator().next().getValue().getUserObject()).getManifestedComponent();
    okComps.add(selectedComponent.getDisplayName());
  }
  for (  String comp : lastManifestationComponents) {
    lastComps.add(AbstractComponent.getComponentById(comp).getDisplayName());
  }
  JPanel warning=new JPanel(new GridLayout(3,2,0,0));
  warning.setPreferredSize(new Dimension(600,220));
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) JList okList=new JList(okComps.toArray());
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) JList lastManifestationList=new JList(lastComps.toArray());
  JScrollPane scrollPane1=new JScrollPane(okList);
  scrollPane1.setPreferredSize(new Dimension(180,100));
  JScrollPane scrollPane2=new JScrollPane(lastManifestationList);
  scrollPane2.setPreferredSize(new Dimension(180,100));
  JLabel okLabel=new JLabel(bundle.getString(""String_Node_Str""));
  okLabel.setPreferredSize(new Dimension(200,20));
  okLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  JLabel lastManifestationLabel=new JLabel(bundle.getString(""String_Node_Str""));
  lastManifestationLabel.setPreferredSize(new Dimension(200,20));
  lastManifestationLabel.setVerticalAlignment(SwingConstants.BOTTOM);
  JTextArea warningMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  warningMessage.setWrapStyleWord(true);
  warningMessage.setLineWrap(true);
  warningMessage.setOpaque(false);
  warningMessage.setPreferredSize(new Dimension(180,100));
  warningMessage.setEditable(false);
  JTextArea removeMessage=new JTextArea(bundle.getString(""String_Node_Str""));
  removeMessage.setWrapStyleWord(true);
  removeMessage.setLineWrap(true);
  removeMessage.setOpaque(false);
  removeMessage.setPreferredSize(new Dimension(200,100));
  removeMessage.setMargin(new Insets(0,10,0,10));
  removeMessage.setEditable(false);
  warning.add(removeMessage);
  warning.add(warningMessage);
  warning.add(okLabel);
  warning.add(lastManifestationLabel);
  warning.add(scrollPane1);
  warning.add(scrollPane2);
  return warning;
}",0.9765528589058
185159,"@Test public void testCreateManifestation(){
  ImageIcon icon=new ImageIcon();
  ExtendedComponentProvider extendedProvider=new ExtendedComponentProvider(mockProvider,""String_Node_Str"");
  ComponentTypeInfo info=new ComponentTypeInfo(""String_Node_Str"",""String_Node_Str"",MockComponent.class,null,icon);
  Mockito.when(mockProvider.getComponentTypes()).thenReturn(Collections.singleton(info));
  ExternalComponentRegistryImpl.getInstance().refreshComponents(Collections.singletonList(extendedProvider));
  Assert.assertSame(component.getIcon(),info.getIcon());
  ExternalComponentRegistryImpl.getInstance().refreshComponents(Collections.<ExtendedComponentProvider>emptyList());
}","@SuppressWarnings(""String_Node_Str"") @Test public void testCreateManifestation(){
  ImageIcon icon=new ImageIcon();
  ExtendedComponentProvider extendedProvider=new ExtendedComponentProvider(mockProvider,""String_Node_Str"");
  ComponentTypeInfo info=new ComponentTypeInfo(""String_Node_Str"",""String_Node_Str"",MockComponent.class,null,icon);
  Mockito.when(mockProvider.getComponentTypes()).thenReturn(Collections.singleton(info));
  ExternalComponentRegistryImpl.getInstance().refreshComponents(Collections.singletonList(extendedProvider));
  Assert.assertSame(component.getIcon(),info.getIcon());
  ExternalComponentRegistryImpl.getInstance().refreshComponents(Collections.<ExtendedComponentProvider>emptyList());
}",0.9734004313443566
185160,"private PropertyDescriptor buildMockDescriptor(VisualControlDescriptor vcd){
  PropertyDescriptor mockDescriptor=Mockito.mock(PropertyDescriptor.class);
  PropertyEditor mockEditor=Mockito.mock(PropertyEditor.class);
  Mockito.when(mockDescriptor.getShortDescription()).thenReturn(""String_Node_Str"");
  Mockito.when(mockDescriptor.getVisualControlDescriptor()).thenReturn(vcd);
  Mockito.when(mockDescriptor.getPropertyEditor()).thenReturn(mockEditor);
  Mockito.when(mockDescriptor.isFieldMutable()).thenReturn(true);
  Mockito.when(mockEditor.getTags()).thenReturn(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  Mockito.when(mockEditor.getAsText()).thenReturn(""String_Node_Str"");
  Mockito.when(mockEditor.getValue()).thenReturn(vcd != VisualControlDescriptor.CheckBox ? ""String_Node_Str"" : Boolean.TRUE);
  return mockDescriptor;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private PropertyDescriptor buildMockDescriptor(VisualControlDescriptor vcd){
  PropertyDescriptor mockDescriptor=Mockito.mock(PropertyDescriptor.class);
  PropertyEditor mockEditor=Mockito.mock(PropertyEditor.class);
  Mockito.when(mockDescriptor.getShortDescription()).thenReturn(""String_Node_Str"");
  Mockito.when(mockDescriptor.getVisualControlDescriptor()).thenReturn(vcd);
  Mockito.when(mockDescriptor.getPropertyEditor()).thenReturn(mockEditor);
  Mockito.when(mockDescriptor.isFieldMutable()).thenReturn(true);
  Mockito.when(mockEditor.getTags()).thenReturn(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  Mockito.when(mockEditor.getAsText()).thenReturn(""String_Node_Str"");
  Mockito.when(mockEditor.getValue()).thenReturn(vcd != VisualControlDescriptor.CheckBox ? ""String_Node_Str"" : Boolean.TRUE);
  return mockDescriptor;
}",0.9672601952900632
185161,"@Test(dataProvider=""String_Node_Str"") public void testExtendedFieldRefresh(VisualControlDescriptor a,VisualControlDescriptor b){
  List<PropertyDescriptor> mockDescriptors=Arrays.asList(buildMockDescriptor(a),buildMockDescriptor(b));
  Mockito.when(comp.getFieldDescriptors()).thenReturn(mockDescriptors);
  PropertyDescriptor lastPropertyDescriptor=mockDescriptors.get(mockDescriptors.size() - 1);
  InfoView infoView=new InfoView(comp,info);
  for (  PropertyDescriptor mockDescriptor : mockDescriptors) {
switch (mockDescriptor.getVisualControlDescriptor()) {
case CheckBox:
case ComboBox:
      Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(1)).getValue();
    break;
case Label:
case TextField:
  Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(1)).getAsText();
break;
}
}
ActionEvent mockEvent=Mockito.mock(ActionEvent.class);
switch (lastPropertyDescriptor.getVisualControlDescriptor()) {
case CheckBox:
{
JCheckBox checkBox=findLastComponentOfType(infoView,JCheckBox.class);
checkBox.doClick();
break;
}
case ComboBox:
{
JComboBox comboBox=findLastComponentOfType(infoView,JComboBox.class);
comboBox.setSelectedItem(""String_Node_Str"");
break;
}
case Label:
{
break;
}
case TextField:
{
JTextField textField=findLastComponentOfType(infoView,JTextField.class);
textField.setText(""String_Node_Str"");
for (ActionListener listener : textField.getActionListeners()) {
if (listener.getClass().getName().startsWith(""String_Node_Str"")) {
listener.actionPerformed(mockEvent);
}
}
break;
}
case TextArea:
{
JTextArea textArea=findLastComponentOfType(infoView,JTextArea.class);
textArea.setText(""String_Node_Str"");
for (FocusListener listener : textArea.getFocusListeners()) {
if (listener.getClass().getName().startsWith(""String_Node_Str"")) {
listener.focusLost(Mockito.mock(FocusEvent.class));
}
}
break;
}
}
int expectedTimes=(lastPropertyDescriptor.getVisualControlDescriptor() == VisualControlDescriptor.Label) ? 1 : 2;
PropertyDescriptor mockDescriptor=mockDescriptors.get(0);
switch (mockDescriptor.getVisualControlDescriptor()) {
case CheckBox:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getValue();
break;
case ComboBox:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getValue();
break;
case Label:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
case TextField:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
case TextArea:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
}
}","@Test(dataProvider=""String_Node_Str"") public void testExtendedFieldRefresh(VisualControlDescriptor a,VisualControlDescriptor b){
  List<PropertyDescriptor> mockDescriptors=Arrays.asList(buildMockDescriptor(a),buildMockDescriptor(b));
  Mockito.when(comp.getFieldDescriptors()).thenReturn(mockDescriptors);
  PropertyDescriptor lastPropertyDescriptor=mockDescriptors.get(mockDescriptors.size() - 1);
  InfoView infoView=new InfoView(comp,info);
  for (  PropertyDescriptor mockDescriptor : mockDescriptors) {
switch (mockDescriptor.getVisualControlDescriptor()) {
case CheckBox:
case ComboBox:
      Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(1)).getValue();
    break;
case Label:
case TextField:
  Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(1)).getAsText();
break;
}
}
ActionEvent mockEvent=Mockito.mock(ActionEvent.class);
switch (lastPropertyDescriptor.getVisualControlDescriptor()) {
case CheckBox:
{
JCheckBox checkBox=findLastComponentOfType(infoView,JCheckBox.class);
checkBox.doClick();
break;
}
case ComboBox:
{
@SuppressWarnings(""String_Node_Str"") JComboBox comboBox=findLastComponentOfType(infoView,JComboBox.class);
comboBox.setSelectedItem(""String_Node_Str"");
break;
}
case Label:
{
break;
}
case TextField:
{
JTextField textField=findLastComponentOfType(infoView,JTextField.class);
textField.setText(""String_Node_Str"");
for (ActionListener listener : textField.getActionListeners()) {
if (listener.getClass().getName().startsWith(""String_Node_Str"")) {
listener.actionPerformed(mockEvent);
}
}
break;
}
case TextArea:
{
JTextArea textArea=findLastComponentOfType(infoView,JTextArea.class);
textArea.setText(""String_Node_Str"");
for (FocusListener listener : textArea.getFocusListeners()) {
if (listener.getClass().getName().startsWith(""String_Node_Str"")) {
listener.focusLost(Mockito.mock(FocusEvent.class));
}
}
break;
}
}
int expectedTimes=(lastPropertyDescriptor.getVisualControlDescriptor() == VisualControlDescriptor.Label) ? 1 : 2;
PropertyDescriptor mockDescriptor=mockDescriptors.get(0);
switch (mockDescriptor.getVisualControlDescriptor()) {
case CheckBox:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getValue();
break;
case ComboBox:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getValue();
break;
case Label:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
case TextField:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
case TextArea:
Mockito.verify(mockDescriptor.getPropertyEditor(),Mockito.times(expectedTimes)).getAsText();
break;
}
}",0.9930464198458936
185162,"/** 
 * Set the view housed within this view
 * @param viewInfo the type of view to create
 * @return true if the view was changed; otherwise false 
 */
public boolean setHousedViewManifestation(ViewInfo viewInfo);","/** 
 * Set the view housed within this view.
 * @param viewInfo the type of view to create
 * @return true if the view was changed; otherwise false 
 */
public boolean setHousedViewManifestation(ViewInfo viewInfo);",0.9976689976689976
185163,"private void updateLinePlotFromSettings(){
  int index=lineSettings.getColorIndex();
  Color c=PlotLineColorPalette.getColor(index);
  setForeground(c);
  Stroke s=linePlot.getStroke();
  if (s == null || s instanceof BasicStroke) {
    int t=lineSettings.getThickness();
    linePlot.setStroke(t == 1 ? null : new BasicStroke(t));
    originalPlotLineStroke=linePlot.getStroke();
  }
  if (linePlot.getPointIcon() != null) {
    Shape shape=null;
    if (lineSettings.getUseCharacter()) {
      Graphics g=(Graphics)getGraphics();
      if (g != null && g instanceof Graphics2D) {
        FontRenderContext frc=((Graphics2D)g).getFontRenderContext();
        shape=PlotLineShapePalette.getShape(lineSettings.getCharacter(),frc);
      }
    }
 else {
      int marker=lineSettings.getMarker();
      shape=PlotLineShapePalette.getShape(marker);
    }
    if (shape != null) {
      linePlot.setPointIcon(new PlotMarkerIcon(shape));
      baseDisplayNameLabel.setIcon(new PlotMarkerIcon(shape,false,12,12));
    }
  }
  linePlot.repaint();
  repaint();
}","private void updateLinePlotFromSettings(){
  int index=lineSettings.getColorIndex();
  Color c=PlotLineColorPalette.getColor(index);
  setForeground(c);
  Stroke s=linePlot.getStroke();
  if (s == null || s instanceof BasicStroke) {
    int t=lineSettings.getThickness();
    linePlot.setStroke(t == 1 ? null : new BasicStroke(t));
    originalPlotLineStroke=linePlot.getStroke();
  }
  if (linePlot.getPointIcon() != null) {
    Shape shape=null;
    if (lineSettings.getUseCharacter()) {
      Graphics g=getGraphics();
      if (g != null && g instanceof Graphics2D) {
        FontRenderContext frc=((Graphics2D)g).getFontRenderContext();
        shape=PlotLineShapePalette.getShape(lineSettings.getCharacter(),frc);
      }
    }
 else {
      int marker=lineSettings.getMarker();
      shape=PlotLineShapePalette.getShape(marker);
    }
    if (shape != null) {
      linePlot.setPointIcon(new PlotMarkerIcon(shape));
      baseDisplayNameLabel.setIcon(new PlotMarkerIcon(shape,false,12,12));
    }
  }
  linePlot.repaint();
  repaint();
}",0.9952335557673976
185164,"/** 
 * Get per-line settings currently in use for this stack of plots. Each element of the returned list corresponds,  in order, to the sub-plots displayed, and maps subscription ID to a  LineSettings object describing how its plot line should be drawn.
 * @return a list of subscription->setting mappings for this plot
 */
public List<Map<String,LineSettings>> getLineSettings(){
  List<Map<String,LineSettings>> settingsAssignments=new ArrayList<Map<String,LineSettings>>();
  for (int subPlotIndex=0; subPlotIndex < subPlots.size(); subPlotIndex++) {
    Map<String,LineSettings> settingsMap=new HashMap<String,LineSettings>();
    settingsAssignments.add(settingsMap);
    AbstractPlottingPackage plot=(AbstractPlottingPackage)subPlots.get(subPlotIndex);
    for (    LegendEntry entry : plot.getLegendManager().getLegendEntryList()) {
      settingsMap.put(entry.getDataSetName(),entry.getLineSettings());
    }
  }
  return settingsAssignments;
}","/** 
 * Get per-line settings currently in use for this stack of plots. Each element of the returned list corresponds,  in order, to the sub-plots displayed, and maps subscription ID to a  LineSettings object describing how its plot line should be drawn.
 * @return a list of subscription->setting mappings for this plot
 */
public List<Map<String,LineSettings>> getLineSettings(){
  List<Map<String,LineSettings>> settingsAssignments=new ArrayList<Map<String,LineSettings>>();
  for (int subPlotIndex=0; subPlotIndex < subPlots.size(); subPlotIndex++) {
    Map<String,LineSettings> settingsMap=new HashMap<String,LineSettings>();
    settingsAssignments.add(settingsMap);
    AbstractPlottingPackage plot=subPlots.get(subPlotIndex);
    for (    LegendEntry entry : plot.getLegendManager().getLegendEntryList()) {
      settingsMap.put(entry.getDataSetName(),entry.getLineSettings());
    }
  }
  return settingsAssignments;
}",0.986709197235513
185165,"/** 
 * Set line settings for use in this stack of plots. Each element corresponds, in order, to the sub-plots displayed, and maps  subscription ID to the line settings described by a LineSettings object
 * @param lineSettings a list of subscription->line setting mappings for this plot
 */
public void setLineSettings(List<Map<String,LineSettings>> lineSettings){
  if (lineSettings != null) {
    for (int subPlotIndex=0; subPlotIndex < lineSettings.size() && subPlotIndex < subPlots.size(); subPlotIndex++) {
      AbstractPlottingPackage plot=(AbstractPlottingPackage)subPlots.get(subPlotIndex);
      for (      Entry<String,LineSettings> entry : lineSettings.get(subPlotIndex).entrySet()) {
        AbstractPlotDataSeries series=plot.getPlotDataManager().getNamedDataSeries(entry.getKey());
        if (series != null) {
          AbstractLegendEntry legendEntry=series.getLegendEntry();
          if (legendEntry instanceof LegendEntry) {
            ((LegendEntry)legendEntry).setLineSettings(entry.getValue());
          }
        }
      }
    }
  }
}","/** 
 * Set line settings for use in this stack of plots. Each element corresponds, in order, to the sub-plots displayed, and maps  subscription ID to the line settings described by a LineSettings object
 * @param lineSettings a list of subscription->line setting mappings for this plot
 */
public void setLineSettings(List<Map<String,LineSettings>> lineSettings){
  if (lineSettings != null) {
    for (int subPlotIndex=0; subPlotIndex < lineSettings.size() && subPlotIndex < subPlots.size(); subPlotIndex++) {
      AbstractPlottingPackage plot=subPlots.get(subPlotIndex);
      for (      Entry<String,LineSettings> entry : lineSettings.get(subPlotIndex).entrySet()) {
        AbstractPlotDataSeries series=plot.getPlotDataManager().getNamedDataSeries(entry.getKey());
        if (series != null) {
          AbstractLegendEntry legendEntry=series.getLegendEntry();
          if (legendEntry instanceof LegendEntry) {
            ((LegendEntry)legendEntry).setLineSettings(entry.getValue());
          }
        }
      }
    }
  }
}",0.9880782069623272
185166,"/** 
 * Adds the popup menus to plot legend entry.
 */
public void addPopupMenus(){
  LegendEntryPopupMenuFactory popupManager=new LegendEntryPopupMenuFactory(plotUser);
  for (int index=0; index < subPlots.size(); index++) {
    AbstractPlottingPackage plot=(AbstractPlottingPackage)subPlots.get(index);
    for (    LegendEntry entry : plot.getLegendManager().getLegendEntryList()) {
      entry.setPopup(popupManager);
    }
  }
}","/** 
 * Adds the popup menus to plot legend entry.
 */
public void addPopupMenus(){
  LegendEntryPopupMenuFactory popupManager=new LegendEntryPopupMenuFactory(plotUser);
  for (int index=0; index < subPlots.size(); index++) {
    AbstractPlottingPackage plot=subPlots.get(index);
    for (    LegendEntry entry : plot.getLegendManager().getLegendEntryList()) {
      entry.setPopup(popupManager);
    }
  }
}",0.9655172413793104
185167,"public void updateFrom(PlotViewManifestation view){
  if (temporal) {
    minControls.updateCurrent(getActualMinimum(view));
    maxControls.updateCurrent(getActualMaximum(view));
    minControls.updateAuto((double)view.getCurrentMCTTime());
    maxControls.updateAuto((double)getValue(minControls) + spanControls.getSpanValue());
    if (!maxControls.auto.isSelected()) {
      spanControls.setSpanValue(getValue(maxControls) - getValue(minControls));
    }
  }
 else {
    minControls.currentValue.setValue(getActualMinimum(view));
    maxControls.currentValue.setValue(getActualMaximum(view));
  }
}","public void updateFrom(PlotViewManifestation view){
  if (temporal) {
    minControls.updateCurrent(getActualMinimum(view));
    maxControls.updateCurrent(getActualMaximum(view));
    minControls.updateAuto((double)view.getCurrentMCTTime());
    maxControls.updateAuto(getValue(minControls) + spanControls.getSpanValue());
    if (!maxControls.auto.isSelected()) {
      spanControls.setSpanValue(getValue(maxControls) - getValue(minControls));
    }
  }
 else {
    minControls.currentValue.setValue(getActualMinimum(view));
    maxControls.currentValue.setValue(getActualMaximum(view));
  }
}",0.9933110367892976
185168,"/** 
 * Set the selection for this group. Note that this will be considered  the ""clean"" selection - user changes will flag this as dirty.
 * @param object
 */
public void setSelection(T object){
  this.selection=(T)object;
  ItemWrapper<T> w=items.get(object);
  if (w == null)   return;
  comboBox.removeActionListener(this);
  comboBox.setSelectedItem(w);
  comboBox.addActionListener(this);
}","/** 
 * Set the selection for this group. Note that this will be considered  the ""clean"" selection - user changes will flag this as dirty.
 * @param object
 */
public void setSelection(T object){
  this.selection=object;
  ItemWrapper<T> w=items.get(object);
  if (w == null)   return;
  comboBox.removeActionListener(this);
  comboBox.setSelectedItem(w);
  comboBox.addActionListener(this);
}",0.9961977186311788
185169,"public String[] getTimeSystemChoices(){
  Set<String> s=plotDataAssigner.getTimeSystemChoices();
  return (String[])s.toArray(new String[s.size()]);
}","public String[] getTimeSystemChoices(){
  Set<String> s=plotDataAssigner.getTimeSystemChoices();
  return s.toArray(new String[s.size()]);
}",0.9655172413793104
185170,"public String[] getTimeFormatChoices(){
  Set<String> s=plotDataAssigner.getTimeFormatChoices();
  return (String[])s.toArray(new String[s.size()]);
}","public String[] getTimeFormatChoices(){
  Set<String> s=plotDataAssigner.getTimeFormatChoices();
  return s.toArray(new String[s.size()]);
}",0.9655172413793104
185171,"private Font updateBaseFont(int style){
  baseFont=label.getFont().deriveFont(9f).deriveFont(style);
  Map attrs=baseFont.getAttributes();
  attrs.put(TextAttribute.STRIKETHROUGH,TextAttribute.STRIKETHROUGH_ON);
  strikeThroughFont=baseFont.deriveFont(attrs);
  return baseFont;
}","@SuppressWarnings(""String_Node_Str"") private Font updateBaseFont(int style){
  baseFont=label.getFont().deriveFont(9f).deriveFont(style);
  @SuppressWarnings(""String_Node_Str"") Map attrs=baseFont.getAttributes();
  attrs.put(TextAttribute.STRIKETHROUGH,TextAttribute.STRIKETHROUGH_ON);
  strikeThroughFont=baseFont.deriveFont(attrs);
  return baseFont;
}",0.8832807570977917
185172,"private void addWindowListenerToHousing(){
  this.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      if (UserEnvironmentRegistry.getHousingCount() == 1) {
        Object[] options={""String_Node_Str"",""String_Node_Str""};
        String message=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
        int answer=OptionBox.showOptionDialog(MCTStandardHousing.this,message,""String_Node_Str"",OptionBox.YES_NO_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.YES_OPTION:
          OSGIRuntime osgiRuntime=EquinoxOSGIRuntimeImpl.getOSGIRuntime();
        try {
          osgiRuntime.stopOSGI();
        }
 catch (        Exception e1) {
          LoggerFactory.getLogger(MCTStandardHousing.class).warn(e1.getMessage(),e1);
        }
      disposeHousing();
    System.exit(0);
  break;
default :
break;
}
}
 else {
boolean toCloseWindow=true;
MCTContentArea centerPane=housingViewManifestation.getContentArea();
if (centerPane != null) {
View centerPaneView=centerPane.getHousedViewManifestation();
AbstractComponent centerComponent=centerPaneView.getManifestedComponent();
if (!centerComponent.isStale() && centerComponent.isDirty()) {
toCloseWindow=commitOrAbortPendingChanges(centerPaneView,MessageFormat.format(BUNDLE.getString(""String_Node_Str""),centerPaneView.getInfo().getViewName(),centerComponent.getDisplayName()));
}
}
View inspectionArea=housingViewManifestation.getInspectionArea();
if (inspectionArea != null) {
View inspectorPaneView=inspectionArea.getHousedViewManifestation();
AbstractComponent inspectorComponent=inspectorPaneView.getManifestedComponent();
if (!inspectorComponent.isStale() && inspectorComponent.isDirty()) {
toCloseWindow=commitOrAbortPendingChanges(inspectionArea,MessageFormat.format(BUNDLE.getString(""String_Node_Str""),inspectorPaneView.getInfo().getViewName(),inspectorComponent.getDisplayName()));
}
}
if (toCloseWindow) disposeHousing();
}
}
/** 
 * Prompts users to commit or abort pending changes in view.
 * @param view the modified view
 * @param dialogMessage the dialog message which differs from where the view is located (in the center or inspector pane)
 * @return true to keep the window open, false to close the window
 */
private boolean commitOrAbortPendingChanges(View view,String dialogMessage){
if (!isComponentWriteableByUser(view.getManifestedComponent())) return true;
Object[] options={BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str"")};
int answer=OptionBox.showOptionDialog(view,dialogMessage,BUNDLE.getString(""String_Node_Str""),OptionBox.YES_NO_CANCEL_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.CANCEL_OPTION:
return false;
case OptionBox.YES_OPTION:
PlatformAccess.getPlatform().getPersistenceProvider().persist(Collections.singleton(view.getManifestedComponent()));
default :
return true;
}
}
private boolean isComponentWriteableByUser(AbstractComponent component){
Platform p=PlatformAccess.getPlatform();
PolicyContext policyContext=new PolicyContext();
policyContext.setProperty(PolicyContext.PropertyName.TARGET_COMPONENT.getName(),component);
policyContext.setProperty(PolicyContext.PropertyName.ACTION.getName(),'w');
String inspectionKey=PolicyInfo.CategoryType.OBJECT_INSPECTION_POLICY_CATEGORY.getKey();
return p.getPolicyManager().execute(inspectionKey,policyContext).getStatus();
}
}
);
}","private void addWindowListenerToHousing(){
  this.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      if (UserEnvironmentRegistry.getHousingCount() == 1) {
        Object[] options={""String_Node_Str"",""String_Node_Str""};
        String message=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
        int answer=OptionBox.showOptionDialog(MCTStandardHousing.this,message,""String_Node_Str"",OptionBox.YES_NO_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.YES_OPTION:
          OSGIRuntime osgiRuntime=EquinoxOSGIRuntimeImpl.getOSGIRuntime();
        try {
          osgiRuntime.stopOSGI();
        }
 catch (        Exception e1) {
          LoggerFactory.getLogger(MCTStandardHousing.class).warn(e1.getMessage(),e1);
        }
      disposeHousing();
    System.exit(0);
  break;
default :
break;
}
}
 else {
boolean toCloseWindow=true;
MCTContentArea centerPane=housingViewManifestation.getContentArea();
if (centerPane != null) {
View centerPaneView=centerPane.getHousedViewManifestation();
AbstractComponent centerComponent=centerPaneView.getManifestedComponent();
if (!centerComponent.isStale() && centerComponent.isDirty()) {
toCloseWindow=commitOrAbortPendingChanges(centerPaneView,MessageFormat.format(BUNDLE.getString(""String_Node_Str""),centerPaneView.getInfo().getViewName(),centerComponent.getDisplayName()));
}
}
View inspectionArea=housingViewManifestation.getInspectionArea();
if (inspectionArea != null) {
View inspectorPaneView=inspectionArea.getHousedViewManifestation();
AbstractComponent inspectorComponent=inspectorPaneView.getManifestedComponent();
if (!inspectorComponent.isStale() && inspectorComponent.isDirty()) {
toCloseWindow=commitOrAbortPendingChanges(inspectionArea,MessageFormat.format(BUNDLE.getString(""String_Node_Str""),inspectorPaneView.getInfo().getViewName(),inspectorComponent.getDisplayName()));
}
}
if (toCloseWindow) disposeHousing();
}
}
/** 
 * Prompts users to commit or abort pending changes in view.
 * @param view the modified view
 * @param dialogMessage the dialog message which differs from where the view is located (in the center or inspector pane)
 * @return true to keep the window open, false to close the window
 */
private boolean commitOrAbortPendingChanges(View view,String dialogMessage){
if (!isComponentWriteableByUser(view.getManifestedComponent())) return true;
Object[] options={BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str"")};
int answer=OptionBox.showOptionDialog(view,dialogMessage,BUNDLE.getString(""String_Node_Str""),OptionBox.YES_NO_CANCEL_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.CANCEL_OPTION:
return false;
case OptionBox.YES_OPTION:
PlatformAccess.getPlatform().getPersistenceProvider().persist(Collections.singleton(view.getManifestedComponent()));
return true;
default :
return true;
}
}
private boolean isComponentWriteableByUser(AbstractComponent component){
Platform p=PlatformAccess.getPlatform();
PolicyContext policyContext=new PolicyContext();
policyContext.setProperty(PolicyContext.PropertyName.TARGET_COMPONENT.getName(),component);
policyContext.setProperty(PolicyContext.PropertyName.ACTION.getName(),'w');
String inspectionKey=PolicyInfo.CategoryType.OBJECT_INSPECTION_POLICY_CATEGORY.getKey();
return p.getPolicyManager().execute(inspectionKey,policyContext).getStatus();
}
}
);
}",0.998156812703814
185173,"/** 
 * Prompts users to commit or abort pending changes in view.
 * @param view the modified view
 * @param dialogMessage the dialog message which differs from where the view is located (in the center or inspector pane)
 * @return true to keep the window open, false to close the window
 */
private boolean commitOrAbortPendingChanges(View view,String dialogMessage){
  if (!isComponentWriteableByUser(view.getManifestedComponent()))   return true;
  Object[] options={BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str"")};
  int answer=OptionBox.showOptionDialog(view,dialogMessage,BUNDLE.getString(""String_Node_Str""),OptionBox.YES_NO_CANCEL_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.CANCEL_OPTION:
    return false;
case OptionBox.YES_OPTION:
  PlatformAccess.getPlatform().getPersistenceProvider().persist(Collections.singleton(view.getManifestedComponent()));
default :
return true;
}
}","/** 
 * Prompts users to commit or abort pending changes in view.
 * @param view the modified view
 * @param dialogMessage the dialog message which differs from where the view is located (in the center or inspector pane)
 * @return true to keep the window open, false to close the window
 */
private boolean commitOrAbortPendingChanges(View view,String dialogMessage){
  if (!isComponentWriteableByUser(view.getManifestedComponent()))   return true;
  Object[] options={BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str""),BUNDLE.getString(""String_Node_Str"")};
  int answer=OptionBox.showOptionDialog(view,dialogMessage,BUNDLE.getString(""String_Node_Str""),OptionBox.YES_NO_CANCEL_OPTION,OptionBox.WARNING_MESSAGE,null,options,options[0]);
switch (answer) {
case OptionBox.CANCEL_OPTION:
    return false;
case OptionBox.YES_OPTION:
  PlatformAccess.getPlatform().getPersistenceProvider().persist(Collections.singleton(view.getManifestedComponent()));
return true;
default :
return true;
}
}",0.9935162094763093
185174,"public PlotSettingsControlArea(PlotViewManifestation managedView){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  add(new SectionPanel(""String_Node_Str"",new PlotBehaviorPanel()));
  add(new SectionPanel(""String_Node_Str"",new LineSetupPanel()));
}","public PlotSettingsControlArea(PlotViewManifestation managedView){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  add(new SectionPanel(""String_Node_Str"",new PlotSetupControlPanel(managedView)));
  add(new SectionPanel(""String_Node_Str"",new PlotBehaviorPanel()));
  add(new SectionPanel(""String_Node_Str"",new LineSetupPanel()));
}",0.858603066439523
185175,"public TimeSetupPanel(){
  JPanel timePanel=new PlotSettingsPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new PlotSettingsPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new PlotSettingsPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  String[] choices=getComponentSpecifiedTimeSystemChoices();
  PlotSettingsComboBox<String> timeSystemComboBox=new PlotSettingsComboBox<String>(choices){
    private static final long serialVersionUID=1765748658974789785L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeSystemSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeSystemSetting());
    }
  }
;
  if (choices.length < 1) {
    timeSystemComboBox.setFocusable(false);
    timeSystemComboBox.setEnabled(false);
  }
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemComboBox);
  addSubPanel(timeSystemComboBox);
  choices=getComponentSpecifiedTimeFormatChoices();
  PlotSettingsComboBox<String> timeFormatComboBox=new PlotSettingsComboBox<String>(choices){
    private static final long serialVersionUID=4893624658379045632L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeFormatSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeFormatSetting());
    }
  }
;
  if (choices.length < 1) {
    timeFormatComboBox.setFocusable(false);
    timeFormatComboBox.setEnabled(false);
  }
  timeFormatComboBox.setSelection(plotViewManifestation.getPlot().getTimeFormatSetting());
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatComboBox);
  addSubPanel(timeFormatComboBox);
  PlotSettingsRadioButtonGroup<AxisOrientationSetting> timeAxisButtons=new PlotSettingsRadioButtonGroup<AxisOrientationSetting>(AxisOrientationSetting.values()){
    private static final long serialVersionUID=1L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setAxisOrientationSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getAxisOrientationSetting());
    }
  }
;
  timeAxisButtons.setText(AxisOrientationSetting.X_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Y_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Z_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.insets=new Insets(0,0,2,0);
  gbc.gridy=0;
  add(timeSystemPanel,gbc);
  gbc.gridy=1;
  add(timeFormatsPanel,gbc);
  gbc.gridy=2;
  add(timeAxisButtons,gbc);
}","public TimeSetupPanel(){
  JPanel timePanel=new PlotSettingsPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new PlotSettingsPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new PlotSettingsPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  String[] choices=getComponentSpecifiedTimeSystemChoices();
  PlotSettingsComboBox<String> timeSystemComboBox=new PlotSettingsComboBox<String>(choices){
    private static final long serialVersionUID=1765748658974789785L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeSystemSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeSystemSetting());
    }
  }
;
  if (choices.length < 1) {
    timeSystemComboBox.setFocusable(false);
    timeSystemComboBox.setEnabled(false);
  }
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemComboBox);
  addSubPanel(timeSystemComboBox);
  choices=getComponentSpecifiedTimeFormatChoices();
  for (int i=0; i < choices.length; i++) {
    choices[i]=choices[i].replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  PlotSettingsComboBox<String> timeFormatComboBox=new PlotSettingsComboBox<String>(choices){
    private static final long serialVersionUID=4893624658379045632L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeFormatSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeFormatSetting());
    }
  }
;
  if (choices.length < 1) {
    timeFormatComboBox.setFocusable(false);
    timeFormatComboBox.setEnabled(false);
  }
  timeFormatComboBox.setSelection(plotViewManifestation.getPlot().getTimeFormatSetting());
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatComboBox);
  addSubPanel(timeFormatComboBox);
  PlotSettingsRadioButtonGroup<AxisOrientationSetting> timeAxisButtons=new PlotSettingsRadioButtonGroup<AxisOrientationSetting>(AxisOrientationSetting.values()){
    private static final long serialVersionUID=1L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setAxisOrientationSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getAxisOrientationSetting());
    }
  }
;
  timeAxisButtons.setText(AxisOrientationSetting.X_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Y_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Z_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.insets=new Insets(0,0,2,0);
  gbc.gridy=0;
  add(timeSystemPanel,gbc);
  gbc.gridy=1;
  add(timeFormatsPanel,gbc);
  gbc.gridy=2;
  add(timeAxisButtons,gbc);
}",0.9825214899713468
185176,"@Override public int getDataSetSize(){
  return knownDataSeries.size();
}","@Override public int getDataSetSize(){
  return plotDataManager.size();
}",0.8904109589041096
185177,"@Override public void reset(PlotConfiguration settings,boolean hard){
  super.reset(settings,hard);
switch (settings.getAxisOrientationSetting()) {
case X_AXIS_AS_TIME:
    behaviorTimeAxisLetter.setText(""String_Node_Str"");
  behaviorNonTimeAxisLetter.setText(""String_Node_Str"");
break;
case Y_AXIS_AS_TIME:
behaviorTimeAxisLetter.setText(""String_Node_Str"");
behaviorNonTimeAxisLetter.setText(""String_Node_Str"");
break;
}
if (hard) {
switch (settings.getTimeAxisSubsequentSetting()) {
case JUMP:
timeJumpMode.setSelected(true);
break;
case SCRUNCH:
timeScrunchMode.setSelected(true);
break;
}
switch (settings.getNonTimeAxisSubsequentMinSetting()) {
case AUTO:
nonTimeMinAutoAdjustMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(false);
nonTimeMinSemiFixedMode.setEnabled(false);
break;
case FIXED:
nonTimeMinFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(false);
nonTimeMinSemiFixedMode.setEnabled(true);
break;
case SEMI_FIXED:
nonTimeMinFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setEnabled(true);
break;
}
switch (settings.getNonTimeAxisSubsequentMaxSetting()) {
case AUTO:
nonTimeMaxAutoAdjustMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(false);
nonTimeMaxSemiFixedMode.setEnabled(false);
break;
case FIXED:
nonTimeMaxFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(false);
nonTimeMaxSemiFixedMode.setEnabled(true);
break;
case SEMI_FIXED:
nonTimeMaxFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setEnabled(true);
break;
}
timeJumpPadding.setText(String.valueOf((int)(settings.getTimePadding() * 100)));
timeScrunchPadding.setText(String.valueOf((int)(settings.getTimePadding() * 100)));
nonTimeMinPadding.setText(String.valueOf((int)(settings.getNonTimeMinPadding() * 100)));
nonTimeMaxPadding.setText(String.valueOf((int)(settings.getNonTimeMaxPadding() * 100)));
cacheState();
}
}","@Override public void reset(PlotConfiguration settings,boolean hard){
  super.reset(settings,hard);
switch (settings.getAxisOrientationSetting()) {
case X_AXIS_AS_TIME:
    behaviorTimeAxisLetter.setText(""String_Node_Str"");
  behaviorNonTimeAxisLetter.setText(""String_Node_Str"");
break;
case Y_AXIS_AS_TIME:
behaviorTimeAxisLetter.setText(""String_Node_Str"");
behaviorNonTimeAxisLetter.setText(""String_Node_Str"");
break;
case Z_AXIS_AS_TIME:
behaviorTimeAxisLetter.setText(""String_Node_Str"");
behaviorNonTimeAxisLetter.setText(""String_Node_Str"");
}
if (hard) {
switch (settings.getTimeAxisSubsequentSetting()) {
case JUMP:
timeJumpMode.setSelected(true);
break;
case SCRUNCH:
timeScrunchMode.setSelected(true);
break;
}
switch (settings.getNonTimeAxisSubsequentMinSetting()) {
case AUTO:
nonTimeMinAutoAdjustMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(false);
nonTimeMinSemiFixedMode.setEnabled(false);
break;
case FIXED:
nonTimeMinFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(false);
nonTimeMinSemiFixedMode.setEnabled(true);
break;
case SEMI_FIXED:
nonTimeMinFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setSelected(true);
nonTimeMinSemiFixedMode.setEnabled(true);
break;
}
switch (settings.getNonTimeAxisSubsequentMaxSetting()) {
case AUTO:
nonTimeMaxAutoAdjustMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(false);
nonTimeMaxSemiFixedMode.setEnabled(false);
break;
case FIXED:
nonTimeMaxFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(false);
nonTimeMaxSemiFixedMode.setEnabled(true);
break;
case SEMI_FIXED:
nonTimeMaxFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setSelected(true);
nonTimeMaxSemiFixedMode.setEnabled(true);
break;
}
timeJumpPadding.setText(String.valueOf((int)(settings.getTimePadding() * 100)));
timeScrunchPadding.setText(String.valueOf((int)(settings.getTimePadding() * 100)));
nonTimeMinPadding.setText(String.valueOf((int)(settings.getNonTimeMinPadding() * 100)));
nonTimeMaxPadding.setText(String.valueOf((int)(settings.getNonTimeMaxPadding() * 100)));
cacheState();
}
}",0.96875
185178,"public TimeSetupPanel(){
  JPanel timePanel=new PlotSettingsPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new PlotSettingsPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new PlotSettingsPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  final String[] systemChoices=getComponentSpecifiedTimeSystemChoices();
  PlotSettingsComboBox<String> timeSystemComboBox=new PlotSettingsComboBox<String>(systemChoices){
    private static final long serialVersionUID=1765748658974789785L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeSystemSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard) {
        String system=settings.getTimeSystemSetting();
        setSelection(!system.isEmpty() ? system : systemChoices[0]);
      }
    }
  }
;
  if (systemChoices.length < 1) {
    timeSystemComboBox.setFocusable(false);
    timeSystemComboBox.setEnabled(false);
  }
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemComboBox);
  addSubPanel(timeSystemComboBox);
  String[] formatChoices=getComponentSpecifiedTimeFormatChoices();
  for (int i=0; i < formatChoices.length; i++) {
    formatChoices[i]=formatChoices[i].replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  PlotSettingsComboBox<String> timeFormatComboBox=new PlotSettingsComboBox<String>(formatChoices){
    private static final long serialVersionUID=4893624658379045632L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeFormatSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeFormatSetting());
    }
  }
;
  if (systemChoices.length < 1) {
    timeFormatComboBox.setFocusable(false);
    timeFormatComboBox.setEnabled(false);
  }
  timeFormatComboBox.setSelection(plotViewManifestation.getPlot().getTimeFormatSetting());
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatComboBox);
  addSubPanel(timeFormatComboBox);
  PlotSettingsRadioButtonGroup<AxisOrientationSetting> timeAxisButtons=new PlotSettingsRadioButtonGroup<AxisOrientationSetting>(AxisOrientationSetting.values()){
    private static final long serialVersionUID=1L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setAxisOrientationSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getAxisOrientationSetting());
    }
  }
;
  timeAxisButtons.setText(AxisOrientationSetting.X_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Y_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Z_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.insets=new Insets(0,0,2,0);
  gbc.gridy=0;
  add(timeSystemPanel,gbc);
  gbc.gridy=1;
  add(timeFormatsPanel,gbc);
  gbc.gridy=2;
  add(timeAxisButtons,gbc);
}","public TimeSetupPanel(){
  JPanel timePanel=new PlotSettingsPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new PlotSettingsPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new PlotSettingsPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  final String[] systemChoices=getComponentSpecifiedTimeSystemChoices();
  PlotSettingsComboBox<String> timeSystemComboBox=new PlotSettingsComboBox<String>(systemChoices){
    private static final long serialVersionUID=1765748658974789785L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeSystemSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard && systemChoices.length > 0) {
        String system=settings.getTimeSystemSetting();
        setSelection(!system.isEmpty() ? system : systemChoices[0]);
      }
    }
  }
;
  if (systemChoices.length < 1) {
    timeSystemComboBox.setFocusable(false);
    timeSystemComboBox.setEnabled(false);
  }
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemComboBox);
  addSubPanel(timeSystemComboBox);
  String[] formatChoices=getComponentSpecifiedTimeFormatChoices();
  for (int i=0; i < formatChoices.length; i++) {
    formatChoices[i]=formatChoices[i].replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  PlotSettingsComboBox<String> timeFormatComboBox=new PlotSettingsComboBox<String>(formatChoices){
    private static final long serialVersionUID=4893624658379045632L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setTimeFormatSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getTimeFormatSetting());
    }
  }
;
  if (systemChoices.length < 1) {
    timeFormatComboBox.setFocusable(false);
    timeFormatComboBox.setEnabled(false);
  }
  timeFormatComboBox.setSelection(plotViewManifestation.getPlot().getTimeFormatSetting());
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatComboBox);
  addSubPanel(timeFormatComboBox);
  PlotSettingsRadioButtonGroup<AxisOrientationSetting> timeAxisButtons=new PlotSettingsRadioButtonGroup<AxisOrientationSetting>(AxisOrientationSetting.values()){
    private static final long serialVersionUID=1L;
    @Override public void populate(    PlotConfiguration settings){
      settings.setAxisOrientationSetting(getSelection());
    }
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      if (hard)       setSelection(settings.getAxisOrientationSetting());
    }
  }
;
  timeAxisButtons.setText(AxisOrientationSetting.X_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Y_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  timeAxisButtons.setText(AxisOrientationSetting.Z_AXIS_AS_TIME,BUNDLE.getString(""String_Node_Str""));
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.insets=new Insets(0,0,2,0);
  gbc.gridy=0;
  add(timeSystemPanel,gbc);
  gbc.gridy=1;
  add(timeFormatsPanel,gbc);
  gbc.gridy=2;
  add(timeAxisButtons,gbc);
}",0.9962314939434724
185179,"@Override public void addDataSet(String dataSetName,Color plottingColor){
  if (!dataSetName.contains(PlotConstants.NON_TIME_FEED_SEPARATOR)) {
    beginGroup(dataSetName);
  }
 else {
    String dataSetNames[]=dataSetName.split(PlotConstants.NON_TIME_FEED_SEPARATOR);
    dataSeriesMap.put(dataSetName,new HashMap<String,ScatterPlotDataSeries>());
    LegendEntry legendEntry=new LegendEntry(PlotConstants.LEGEND_BACKGROUND_COLOR,plottingColor,PlotConstants.DEFAULT_TIME_AXIS_FONT,scatterPlot.getPlotLabelingAlgorithm());
    ScatterPlotDataSeries dataSeries=new ScatterPlotDataSeries(scatterPlot,getDataMap(dataSetNames[0]),getDataMap(dataSetNames[1]),legendEntry);
    dataSeriesMap.get(dataSetNames[0]).put(dataSetNames[1],dataSeries);
    addToDataSeriesList(dataSetNames[0],dataSeries);
    addToDataSeriesList(dataSetNames[1],dataSeries);
  }
}","@Override public void addDataSet(String dataSetName,Color plottingColor){
  if (!dataSetName.contains(PlotConstants.NON_TIME_FEED_SEPARATOR)) {
    beginGroup(dataSetName);
  }
 else {
    System.out.println(dataSetName);
    String dataSetNames[]=dataSetName.split(PlotConstants.NON_TIME_FEED_SEPARATOR);
    dataSeriesMap.put(dataSetName,new HashMap<String,ScatterPlotDataSeries>());
    LegendEntry legendEntry=new LegendEntry(PlotConstants.LEGEND_BACKGROUND_COLOR,plottingColor,PlotConstants.DEFAULT_TIME_AXIS_FONT,scatterPlot.getPlotLabelingAlgorithm());
    ScatterPlotDataSeries dataSeries=new ScatterPlotDataSeries(scatterPlot,getDataMap(dataSetNames[0]),getDataMap(dataSetNames[1]),legendEntry);
    dataSeriesMap.get(dataSetNames[0]).put(dataSetNames[1],dataSeries);
    addToDataSeriesList(dataSetNames[0],dataSeries);
    addToDataSeriesList(dataSetNames[1],dataSeries);
  }
}",0.9787234042553192
185180,"@Override public void addData(String feed,SortedMap<Long,Double> points){
  SortedMap<Long,Double> target=getDataMap(feed);
  for (  Entry<Long,Double> point : points.entrySet()) {
    target.put(point.getKey(),point.getValue());
  }
  if (dataSeriesList.containsKey(feed)) {
    for (    ScatterPlotDataSeries series : dataSeriesList.get(feed)) {
      series.updatePlotLine();
    }
  }
  clearBefore(scatterPlot.getCurrentTimeAxisMin().getTimeInMillis());
}","@Override public void addData(String feed,SortedMap<Long,Double> points){
  List<Long> timestamps=new ArrayList<Long>();
  SortedMap<Long,Double> target=getDataMap(feed);
  for (  Entry<Long,Double> point : points.entrySet()) {
    target.put(point.getKey(),point.getValue());
  }
  if (dataSeriesList.containsKey(feed)) {
    for (    ScatterPlotDataSeries series : dataSeriesList.get(feed)) {
      series.updatePlotLine();
    }
  }
  clearBefore(scatterPlot.getCurrentTimeAxisMin().getTimeInMillis());
}",0.9513960703205792
185181,"public void updatePlotLine(){
  for (  Entry<Long,Double> entry : dependent.entrySet()) {
    long t=entry.getKey();
    if (t > lastUpdate) {
      if (independent.containsKey(t)) {
        double depValue=entry.getValue();
        double indValue=independent.get(t);
        plotLine.addData(indValue,depValue);
        timestamps.add(t);
      }
      lastUpdate=t;
    }
  }
}","public void updatePlotLine(){
  for (  Entry<Long,Double> entry : dependent.tailMap(lastUpdate + 1).entrySet()) {
    long t=entry.getKey();
    if (independent.containsKey(t)) {
      double depValue=entry.getValue();
      double indValue=independent.get(t);
      plotLine.addData(indValue,depValue);
      timestamps.add(t);
      lastUpdate=t;
    }
  }
}",0.4
185182,"@Override public void populate(PlotConfiguration settings){
  cachedFlags=getSelectedDrawingFlags();
  settings.setPlotLineDraw(cachedFlags);
  cachedConnectionType=getSelectedConnectionType();
  settings.setPlotLineConnectionType(cachedConnectionType);
}","@Override public void populate(PlotConfiguration settings){
  settings.setPlotLineDraw(getSelectedDrawingFlags());
  settings.setPlotLineConnectionType(getSelectedConnectionType());
}",0.6894977168949772
185183,"public PlotSettingsControlArea(PlotViewManifestation managedView){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  add(new SectionPanel(""String_Node_Str"",new PlotSetupControlPanel(managedView)));
  add(new SectionPanel(""String_Node_Str"",new PlotBehaviorPanel()));
  add(new SectionPanel(""String_Node_Str"",new LineSetupPanel()));
}","public PlotSettingsControlArea(PlotViewManifestation managedView){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  add(new SectionPanel(""String_Node_Str"",new PlotBehaviorPanel()));
  add(new SectionPanel(""String_Node_Str"",new LineSetupPanel()));
}",0.606473594548552
185184,"private JPanel createApplyButtonPanel(final PlotSettingsSubPanel panel){
  final JButton okButton=new JButton(""String_Node_Str"");
  final JButton resetButton=new JButton(""String_Node_Str"");
  final Runnable callback=new Runnable(){
    @Override public void run(){
      okButton.setEnabled(panel.isDirty() && panel.isValid());
      resetButton.setEnabled(panel.isDirty());
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.populate(settings);
      panel.reset(settings,false);
    }
  }
;
  okButton.setEnabled(false);
  resetButton.setEnabled(false);
  panel.addCallback(callback);
  okButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.populate(settings);
      settings.persist(managedView);
      managedView.setupPlot(settings);
      panel.reset(settings,true);
      callback.run();
    }
  }
);
  resetButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.reset(settings,true);
      callback.run();
    }
  }
);
  JPanel okButtonPadded=new JPanel(new FlowLayout(FlowLayout.CENTER,10,7));
  okButtonPadded.add(okButton);
  okButtonPadded.add(resetButton);
  JPanel okPanel=new JPanel();
  okPanel.setLayout(new BorderLayout());
  okPanel.add(okButtonPadded,BorderLayout.EAST);
  okPanel.setName(""String_Node_Str"");
  okButton.setName(""String_Node_Str"");
  okButtonPadded.setName(""String_Node_Str"");
  okButtonPadded.setOpaque(false);
  okPanel.setBackground(Color.DARK_GRAY);
  return okPanel;
}","private JPanel createApplyButtonPanel(final PlotSettingsSubPanel panel){
  final JButton okButton=new JButton(""String_Node_Str"");
  final JButton resetButton=new JButton(""String_Node_Str"");
  final Runnable callback=new Runnable(){
    @Override public void run(){
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.populate(settings);
      panel.reset(settings,false);
      okButton.setEnabled(panel.isDirty() && panel.isValidated());
      resetButton.setEnabled(panel.isDirty());
    }
  }
;
  okButton.setEnabled(false);
  resetButton.setEnabled(false);
  panel.addCallback(callback);
  okButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.populate(settings);
      settings.persist(managedView);
      managedView.setupPlot(settings);
      panel.reset(settings,true);
      callback.run();
    }
  }
);
  resetButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      PlotSettings settings=new PlotSettings();
      settings.loadFrom(managedView);
      panel.reset(settings,true);
      callback.run();
    }
  }
);
  JPanel okButtonPadded=new JPanel(new FlowLayout(FlowLayout.CENTER,10,7));
  okButtonPadded.add(okButton);
  okButtonPadded.add(resetButton);
  JPanel okPanel=new JPanel();
  okPanel.setLayout(new BorderLayout());
  okPanel.add(okButtonPadded,BorderLayout.EAST);
  okPanel.setName(""String_Node_Str"");
  okButton.setName(""String_Node_Str"");
  okButtonPadded.setName(""String_Node_Str"");
  okButtonPadded.setOpaque(false);
  okPanel.setBackground(Color.DARK_GRAY);
  return okPanel;
}",0.9121813031161472
185185,"@Override public void run(){
  okButton.setEnabled(panel.isDirty() && panel.isValid());
  resetButton.setEnabled(panel.isDirty());
  PlotSettings settings=new PlotSettings();
  settings.loadFrom(managedView);
  panel.populate(settings);
  panel.reset(settings,false);
}","@Override public void run(){
  PlotSettings settings=new PlotSettings();
  settings.loadFrom(managedView);
  panel.populate(settings);
  panel.reset(settings,false);
  okButton.setEnabled(panel.isDirty() && panel.isValidated());
  resetButton.setEnabled(panel.isDirty());
}",0.4870848708487085
185186,"@Override public void populate(PlotConfiguration settings){
  for (  PlotSettingsSubPanel subPanel : subPanels) {
    subPanel.populate(settings);
  }
  dirty=false;
}","@Override public void populate(PlotConfiguration settings){
  for (  PlotSettingsSubPanel subPanel : subPanels) {
    subPanel.populate(settings);
  }
  updateState();
}",0.9523809523809524
185187,"@Override public boolean isDirty(){
  return dirty;
}","@Override public boolean isDirty(){
  updateState();
  return dirty;
}",0.8617886178861789
185188,"@Override public boolean isValidated(){
  return valid;
}","@Override public boolean isValidated(){
  updateState();
  return valid;
}",0.8702290076335878
185189,"@Override public void reset(PlotConfiguration settings,boolean hard){
  for (  PlotSettingsSubPanel subPanel : subPanels) {
    subPanel.reset(settings,hard);
  }
  if (hard)   dirty=false;
}","@Override public void reset(PlotConfiguration settings,boolean hard){
  for (  PlotSettingsSubPanel subPanel : subPanels) {
    subPanel.reset(settings,hard);
  }
  updateState();
}",0.913978494623656
185190,"@Override public void run(){
  dirty=false;
  valid=true;
  for (  PlotSettingsSubPanel subPanel : subPanels) {
    dirty|=subPanel.isDirty();
    valid&=subPanel.isValidated();
  }
  fireCallbacks();
}","@Override public void run(){
  updateState();
  fireCallbacks();
}",0.4477611940298507
185191,"public ItemWrapper(T item){
  this.item=item;
}","public ItemWrapper(T item){
  this.item=item;
  this.text=item.toString();
}",0.7642276422764228
185192,"/** 
 * Set the selection for this group. Note that this will be considered  the ""clean"" selection - user changes will flag this as dirty.
 * @param object
 */
public void setSelection(T object){
  this.selection=(T)object;
  comboBox.setSelectedItem(object);
}","/** 
 * Set the selection for this group. Note that this will be considered  the ""clean"" selection - user changes will flag this as dirty.
 * @param object
 */
public void setSelection(T object){
  this.selection=(T)object;
  ItemWrapper<T> w=items.get(object);
  comboBox.setSelectedItem(w);
}",0.918918918918919
185193,"public T getSelection(){
  return selection;
}","@SuppressWarnings(""String_Node_Str"") public T getSelection(){
  ItemWrapper<T> wrapper=((ItemWrapper<T>)comboBox.getSelectedItem());
  return wrapper == null ? null : wrapper.item;
}",0.3596491228070175
185194,"@Override public boolean isDirty(){
  return selection != comboBox.getSelectedItem();
}","@Override public boolean isDirty(){
  return !selection.equals(getSelection());
}",0.8214285714285714
185195,"public PlotSettingsComboBox(T... choices){
  List<ItemWrapper<T>> wrappedChoices=new ArrayList<ItemWrapper<T>>();
  for (  T item : choices) {
    ItemWrapper<T> wrapper=new ItemWrapper<T>(item);
    wrappedChoices.add(wrapper);
    items.put(item,wrapper);
  }
  comboBox=new JComboBox(choices);
  add(comboBox);
}","public PlotSettingsComboBox(T... choices){
  List<ItemWrapper<T>> wrappedChoices=new ArrayList<ItemWrapper<T>>();
  for (  T item : choices) {
    ItemWrapper<T> wrapper=new ItemWrapper<T>(item);
    wrappedChoices.add(wrapper);
    items.put(item,wrapper);
  }
  comboBox=new JComboBox(wrappedChoices.toArray());
  if (choices.length > 0)   setSelection(choices[0]);
  add(comboBox);
}",0.8787446504992867
185196,"@Override public boolean isDirty(){
  if (selection == null)   return false;
  return !selection.isSelected();
}","@Override public boolean isDirty(){
  if (selection == null)   return false;
  return !buttonGroup.isSelected(selection.getModel());
}",0.8617886178861789
185197,"public PlotSettingsRadioButtonGroup(T... options){
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=0;
  gbc.gridy=0;
  for (  T option : options) {
    JRadioButton button=new JRadioButton(option.toString());
    button.addActionListener(this);
    buttonGroup.add(button);
    add(button,gbc);
    gbc.gridy++;
    buttons.put(option,button);
  }
}","public PlotSettingsRadioButtonGroup(T... options){
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=0;
  gbc.gridy=0;
  for (  T option : options) {
    JRadioButton button=new JRadioButton(option.toString());
    buttonGroup.add(button);
    button.addActionListener(this);
    add(button,gbc);
    gbc.gridy++;
    buttons.put(option,button);
  }
  if (options.length > 0) {
    setSelection(options[0]);
  }
}",0.8715203426124197
185198,"@Override public void focusLost(FocusEvent arg0){
}","@Override public void focusLost(FocusEvent e){
  if (e.isTemporary())   return;
  updateNonTimeAxisControls();
}",0.5766871165644172
185199,"@Override public void focusGained(FocusEvent arg0){
  touched();
}","@Override public void focusGained(FocusEvent e){
  if (e.isTemporary())   return;
  companionButton.setSelected(true);
  updateNonTimeAxisControls();
}",0.5529953917050692
185200,"private PlotSettingsSubPanel getAlternateBottomPanel(){
  final AxisPanel yAxisPanel=new AxisPanel(){
    private static final long serialVersionUID=7880175726915727283L;
    @Override public void initialLayout(){
      addAt(minMaxPanel[0],0,3,1,1,GridBagConstraints.SOUTHWEST,GridBagConstraints.BOTH);
      addAt(minMaxPanel[1],0,1,1,1,GridBagConstraints.NORTHWEST,GridBagConstraints.BOTH);
      addAt(minMaxLabel[0],1,3,1,1,GridBagConstraints.SOUTHEAST,GridBagConstraints.NONE);
      addAt(minMaxLabel[1],1,0,1,1,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE);
      addAt(spanPanel,0,2,2,1,GridBagConstraints.EAST,GridBagConstraints.BOTH);
      addAt(axisTitle,0,0,2,1,GridBagConstraints.NORTH,GridBagConstraints.BOTH);
    }
  }
;
  final AxisPanel xAxisPanel=new AxisPanel(){
    private static final long serialVersionUID=7880175726915727283L;
    @Override public void initialLayout(){
      addAt(minMaxPanel[0],0,1,2,1,GridBagConstraints.WEST,GridBagConstraints.NONE);
      addAt(minMaxPanel[1],2,1,2,1,GridBagConstraints.EAST,GridBagConstraints.NONE);
      addAt(minMaxLabel[0],0,0,1,1,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE);
      addAt(minMaxLabel[1],3,0,1,1,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE);
      addAt(spanPanel,1,0,2,1,GridBagConstraints.NORTH,GridBagConstraints.BOTH);
      addAt(axisTitle,1,2,2,1,GridBagConstraints.SOUTH,GridBagConstraints.BOTH);
    }
  }
;
  JPanel p1=new JPanel();
  p1.add(new JLabel(""String_Node_Str""));
  JPanel p2=new JPanel();
  p2.add(new JLabel(""String_Node_Str""));
  JPanel p3=new JPanel();
  final AxisGroup timeGroup=new AxisGroup(new TimeAxisMinimumsPanel(),new TimeAxisMaximumsPanel(),new XAxisSpanCluster());
  final AxisGroup nonTimeGroup=new AxisGroup(new NonTimeAxisMinimumsPanel(false),new NonTimeAxisMaximumsPanel(),new YAxisSpanPanel());
  PlotSettingsPanel panel=new PlotSettingsPanel(){
    private static final long serialVersionUID=1730870211575829997L;
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      boolean xInverted=settings.getXAxisMaximumLocation() == XAxisMaximumLocationSetting.MAXIMUM_AT_LEFT;
      boolean yInverted=settings.getYAxisMaximumLocation() == YAxisMaximumLocationSetting.MAXIMUM_AT_BOTTOM;
switch (settings.getAxisOrientationSetting()) {
case X_AXIS_AS_TIME:
        xAxisPanel.setFrom(timeGroup,xInverted);
      yAxisPanel.setFrom(nonTimeGroup,yInverted);
    timeGroup.setTitle(""String_Node_Str"");
  nonTimeGroup.setTitle(""String_Node_Str"");
break;
case Y_AXIS_AS_TIME:
yAxisPanel.setFrom(timeGroup,xInverted);
xAxisPanel.setFrom(nonTimeGroup,yInverted);
timeGroup.setTitle(""String_Node_Str"");
nonTimeGroup.setTitle(""String_Node_Str"");
break;
}
super.reset(settings,hard);
}
}
;
panel.setLayout(new GridBagLayout());
panel.setBorder(TOP_PADDED_MARGINS);
GridBagConstraints gbc=new GridBagConstraints();
gbc.gridx=0;
gbc.gridy=1;
gbc.gridwidth=1;
gbc.gridheight=3;
gbc.fill=GridBagConstraints.BOTH;
gbc.insets=new Insets(2,0,10,2);
panel.add(yAxisPanel,gbc);
gbc.gridx=1;
gbc.gridy=1;
gbc.gridwidth=3;
gbc.gridheight=3;
panel.add(imagePanel,gbc);
gbc.gridx=1;
gbc.gridy=4;
gbc.gridwidth=3;
gbc.gridheight=1;
gbc.fill=GridBagConstraints.BOTH;
gbc.insets=new Insets(0,8,0,0);
panel.add(xAxisPanel,gbc);
yAxisPanel.setName(""String_Node_Str"");
xAxisPanel.setName(""String_Node_Str"");
return panel;
}","private PlotSettingsSubPanel getAlternateBottomPanel(){
  final AxisPanel xAxisPanel=new AxisPanel(){
    private static final long serialVersionUID=7880175726915727283L;
    @Override public void initialLayout(){
      layout.putConstraint(SpringLayout.WEST,minMaxPanel[0],0,SpringLayout.WEST,this);
      layout.putConstraint(SpringLayout.NORTH,minMaxPanel[0],0,SpringLayout.SOUTH,spanPanel);
      layout.putConstraint(SpringLayout.EAST,this,0,SpringLayout.EAST,minMaxPanel[1]);
      layout.putConstraint(SpringLayout.WEST,minMaxPanel[1],0,SpringLayout.EAST,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.NORTH,minMaxPanel[1],0,SpringLayout.SOUTH,spanPanel);
      layout.putConstraint(SpringLayout.WEST,minMaxLabel[0],0,SpringLayout.WEST,this);
      layout.putConstraint(SpringLayout.NORTH,minMaxLabel[0],0,SpringLayout.NORTH,this);
      layout.putConstraint(SpringLayout.EAST,minMaxLabel[1],0,SpringLayout.EAST,this);
      layout.putConstraint(SpringLayout.NORTH,minMaxLabel[1],0,SpringLayout.NORTH,this);
      layout.putConstraint(SpringLayout.SOUTH,minMaxPanel[1],0,SpringLayout.SOUTH,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.NORTH,axisTitle,0,SpringLayout.SOUTH,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.HORIZONTAL_CENTER,axisTitle,0,SpringLayout.EAST,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.NORTH,spanPanel,0,SpringLayout.NORTH,this);
      layout.putConstraint(SpringLayout.HORIZONTAL_CENTER,spanPanel,0,SpringLayout.EAST,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.SOUTH,this,0,SpringLayout.SOUTH,axisTitle);
    }
  }
;
  final AxisPanel yAxisPanel=new AxisPanel(){
    private static final long serialVersionUID=7880175726915727283L;
    @Override public void initialLayout(){
      layout.putConstraint(SpringLayout.WEST,minMaxPanel[0],0,SpringLayout.WEST,this);
      layout.putConstraint(SpringLayout.WEST,minMaxLabel[0],0,SpringLayout.EAST,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.WEST,minMaxPanel[1],0,SpringLayout.WEST,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.WEST,minMaxLabel[1],0,SpringLayout.EAST,minMaxPanel[1]);
      layout.putConstraint(SpringLayout.EAST,spanPanel,0,SpringLayout.EAST,this);
      layout.putConstraint(SpringLayout.EAST,this,0,SpringLayout.EAST,minMaxLabel[0]);
      layout.putConstraint(SpringLayout.HORIZONTAL_CENTER,axisTitle,0,SpringLayout.HORIZONTAL_CENTER,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.NORTH,axisTitle,0,SpringLayout.NORTH,this);
      layout.putConstraint(SpringLayout.NORTH,minMaxPanel[0],0,SpringLayout.SOUTH,axisTitle);
      layout.putConstraint(SpringLayout.NORTH,spanPanel,0,SpringLayout.SOUTH,minMaxPanel[0]);
      layout.putConstraint(SpringLayout.NORTH,minMaxPanel[1],0,SpringLayout.SOUTH,spanPanel);
      layout.putConstraint(SpringLayout.SOUTH,this,0,SpringLayout.SOUTH,minMaxPanel[1]);
      layout.putConstraint(SpringLayout.SOUTH,minMaxLabel[1],0,SpringLayout.SOUTH,this);
    }
  }
;
  JPanel p1=new JPanel();
  p1.add(new JLabel(""String_Node_Str""));
  JPanel p2=new JPanel();
  p2.add(new JLabel(""String_Node_Str""));
  JPanel p3=new JPanel();
  final AxisGroup timeGroup=new AxisGroup(new TimeAxisMinimumsPanel(),new TimeAxisMaximumsPanel(),new XAxisSpanCluster());
  final AxisGroup nonTimeGroup=new AxisGroup(new NonTimeAxisMinimumsPanel(false),new NonTimeAxisMaximumsPanel(),new YAxisSpanPanel());
  PlotSettingsPanel panel=new PlotSettingsPanel(){
    private static final long serialVersionUID=1730870211575829997L;
    @Override public void reset(    PlotConfiguration settings,    boolean hard){
      boolean xInverted=settings.getXAxisMaximumLocation() == XAxisMaximumLocationSetting.MAXIMUM_AT_LEFT;
      boolean yInverted=settings.getYAxisMaximumLocation() == YAxisMaximumLocationSetting.MAXIMUM_AT_BOTTOM;
switch (settings.getAxisOrientationSetting()) {
case X_AXIS_AS_TIME:
        xAxisPanel.setFrom(timeGroup,xInverted);
      yAxisPanel.setFrom(nonTimeGroup,yInverted);
    break;
case Y_AXIS_AS_TIME:
  yAxisPanel.setFrom(timeGroup,yInverted);
xAxisPanel.setFrom(nonTimeGroup,xInverted);
break;
}
timeGroup.setTitle(""String_Node_Str"");
nonTimeGroup.setTitle(""String_Node_Str"");
super.reset(settings,hard);
}
}
;
panel.setLayout(new GridBagLayout());
panel.setBorder(TOP_PADDED_MARGINS);
GridBagConstraints gbc=new GridBagConstraints();
gbc.gridx=0;
gbc.gridy=1;
gbc.gridwidth=1;
gbc.gridheight=3;
gbc.fill=GridBagConstraints.BOTH;
gbc.insets=new Insets(2,0,10,2);
panel.add(yAxisPanel,gbc);
gbc.gridx=1;
gbc.gridy=1;
gbc.gridwidth=3;
gbc.gridheight=3;
panel.add(imagePanel,gbc);
gbc.gridx=1;
gbc.gridy=4;
gbc.gridwidth=3;
gbc.gridheight=1;
gbc.fill=GridBagConstraints.BOTH;
gbc.insets=new Insets(0,8,0,0);
panel.add(xAxisPanel,gbc);
yAxisPanel.setName(""String_Node_Str"");
xAxisPanel.setName(""String_Node_Str"");
return panel;
}",0.6105365616255019
185201,"@Override public void mouseClicked(MouseEvent arg0){
  touched();
}","@Override public void mouseClicked(MouseEvent e){
  companionButton.setSelected(true);
  companionButton.requestFocusInWindow();
}",0.6192893401015228
185202,"public void setFrom(AxisGroup group,boolean inverted){
  clear();
  int min=inverted ? 1 : 0;
  int max=inverted ? 0 : 1;
  minMaxPanel[min].add(group.getMinControls());
  minMaxPanel[max].add(group.getMaxControls());
  minMaxLabel[min].setText(group.getMinText());
  minMaxLabel[max].setText(group.getMaxText());
  spanPanel.add(group.getSpanControls());
  axisTitle.setText(""String_Node_Str"" + group.getTitle() + ""String_Node_Str"");
  revalidate();
}","public void setFrom(AxisGroup group,boolean inverted){
  clear();
  int min=inverted ? 1 : 0;
  int max=inverted ? 0 : 1;
  minMaxPanel[min].add(group.getMinControls());
  minMaxPanel[max].add(group.getMaxControls());
  minMaxLabel[min].setText(group.getMinText());
  minMaxLabel[max].setText(group.getMaxText());
  spanPanel.add(group.getSpanControls());
  axisTitle.setText(""String_Node_Str"" + group.getTitle() + ""String_Node_Str"");
  layout=new SpringLayout();
  setLayout(layout);
  initialLayout();
  revalidate();
}",0.9290853031860226
185203,"public AxisPanel(){
  for (  JLabel l : minMaxLabel)   l.setFont(l.getFont().deriveFont(Font.BOLD));
  setLayout(new GridBagLayout());
  initialLayout();
}","public AxisPanel(){
  for (  JLabel l : minMaxLabel)   l.setFont(l.getFont().deriveFont(Font.BOLD));
  setLayout(layout);
  add(minMaxPanel[0]);
  add(minMaxPanel[1]);
  add(minMaxLabel[0]);
  add(minMaxLabel[1]);
  add(spanPanel);
  add(axisTitle);
}",0.6009852216748769
185204,"public double getValue(){
  return 0;
}","public Double getValue(){
  String data=getText();
  if (data == null) {
    return null;
  }
  if (data.length() < 3) {
    logger.error(""String_Node_Str"" + data + ""String_Node_Str"");
    return null;
  }
  Double result=null;
  try {
    result=Double.parseDouble(data.substring(1,data.length() - 1));
  }
 catch (  NumberFormatException e) {
    logger.error(""String_Node_Str"" + data.substring(1,data.length() - 1) + ""String_Node_Str"");
  }
  return result;
}",0.1117764471057884
185205,"private JPanel createTopPanel(){
  JPanel initTopPanel=new JPanel();
  initTopPanel.setLayout(new GridBagLayout());
  JPanel timePanel=new JPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new JPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new JPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  String[] choices=getComponentSpecifiedTimeSystemChoices();
  if (choices == null || choices.length <= 0) {
    timeSystemDropdown=new JComboBox(new String[]{TimeService.DEFAULT_TIME_SYSTEM});
    timeSystemDropdown.setFocusable(false);
    timeSystemDropdown.setEnabled(false);
  }
 else {
    timeSystemDropdown=new JComboBox(choices);
  }
  timeSystemDropdown.setSelectedItem(plotViewManifestion.getPlot().getTimeSystemSetting());
  ssTimeSystemSelection=(String)timeSystemDropdown.getSelectedItem();
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemDropdown);
  choices=getComponentSpecifiedTimeFormatChoices();
  if (choices == null || choices.length <= 0) {
    timeFormatDropdown=new JComboBox(new String[]{TimeService.DEFAULT_TIME_FORMAT});
    timeFormatDropdown.setFocusable(false);
    timeFormatDropdown.setEnabled(false);
  }
 else {
    timeFormatDropdown=new JComboBox(choices);
  }
  timeFormatDropdown.setSelectedItem(plotViewManifestion.getPlot().getTimeFormatSetting());
  ssTimeFormatSelection=(String)timeFormatDropdown.getSelectedItem();
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatDropdown);
  xAxisAsTimeRadioButton=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  yAxisAsTimeRadioButton=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  zAxisAsTimeRadioButton=new JRadioButton(""String_Node_Str"");
  JLabel xDirTitle=new JLabel(BUNDLE.getString(""String_Node_Str""));
  xMaxAtRight=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  xMaxAtLeft=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  JLabel yDirTitle=new JLabel(BUNDLE.getString(""String_Node_Str""));
  yMaxAtTop=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  yMaxAtBottom=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  JSeparator separator1=new JSeparator(SwingConstants.VERTICAL);
  JSeparator separator2=new JSeparator(SwingConstants.VERTICAL);
  GridBagConstraints gbcTopA=new GridBagConstraints();
  gbcTopA.anchor=GridBagConstraints.WEST;
  initTopPanel.add(timePanel,gbcTopA);
  GridBagConstraints gbcSep1=new GridBagConstraints();
  gbcSep1.gridheight=3;
  gbcSep1.fill=GridBagConstraints.BOTH;
  gbcSep1.insets=new Insets(0,5,0,5);
  initTopPanel.add(separator1,gbcSep1);
  GridBagConstraints gbcTopB=new GridBagConstraints();
  gbcTopB.anchor=GridBagConstraints.WEST;
  gbcTopB.insets=new Insets(0,4,0,0);
  initTopPanel.add(xDirTitle,gbcTopB);
  initTopPanel.add(separator2,gbcSep1);
  initTopPanel.add(yDirTitle,gbcTopB);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridy=1;
  gbc.gridx=0;
  initTopPanel.add(xAxisAsTimeRadioButton,gbc);
  gbc.gridx=2;
  initTopPanel.add(xMaxAtRight,gbc);
  gbc.gridx=4;
  initTopPanel.add(yMaxAtTop,gbc);
  gbc.gridy=2;
  gbc.gridx=0;
  gbc.insets=new Insets(5,0,0,0);
  initTopPanel.add(yAxisAsTimeRadioButton,gbc);
  gbc.gridx=2;
  initTopPanel.add(xMaxAtLeft,gbc);
  gbc.gridx=4;
  initTopPanel.add(yMaxAtBottom,gbc);
  gbc.gridy=3;
  gbc.gridx=0;
  gbc.insets=new Insets(5,0,0,0);
  initTopPanel.add(zAxisAsTimeRadioButton,gbc);
  GridBagConstraints groupingGbc=new GridBagConstraints();
  groupingGbc.gridheight=3;
  groupingGbc.fill=GridBagConstraints.BOTH;
  groupingGbc.insets=new Insets(0,5,0,5);
  initTopPanel.add(new JSeparator(JSeparator.VERTICAL),groupingGbc);
  groupingGbc.gridheight=1;
  groupingGbc.gridy=0;
  initTopPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")),groupingGbc);
  groupingGbc.gridy=1;
  groupByCollection=new JCheckBox(BUNDLE.getString(""String_Node_Str""));
  groupByCollection.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      updateMainButtons();
    }
  }
);
  initTopPanel.add(groupByCollection,groupingGbc);
  addTopPanelListenersAndState();
  initTopPanel.setName(""String_Node_Str"");
  timePanel.setName(""String_Node_Str"");
  JPanel horizontalSqueeze=new JPanel(new BorderLayout());
  horizontalSqueeze.add(initTopPanel,BorderLayout.WEST);
  return horizontalSqueeze;
}","private JPanel createTopPanel(){
  JPanel initTopPanel=new JPanel();
  initTopPanel.setLayout(new GridBagLayout());
  JPanel timePanel=new JPanel();
  timePanel.setLayout(new BoxLayout(timePanel,BoxLayout.Y_AXIS));
  timePanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  JPanel timeSystemPanel=new JPanel();
  timeSystemPanel.setLayout(new BoxLayout(timeSystemPanel,BoxLayout.X_AXIS));
  timeSystemPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  JPanel timeFormatsPanel=new JPanel();
  timeFormatsPanel.setLayout(new BoxLayout(timeFormatsPanel,BoxLayout.X_AXIS));
  timeFormatsPanel.setBorder(BorderFactory.createEmptyBorder(0,5,2,0));
  timePanel.add(timeSystemPanel);
  timePanel.add(timeFormatsPanel);
  String[] choices=getComponentSpecifiedTimeSystemChoices();
  if (choices == null || choices.length <= 0) {
    timeSystemDropdown=new JComboBox(new String[]{TimeService.DEFAULT_TIME_SYSTEM});
    timeSystemDropdown.setFocusable(false);
    timeSystemDropdown.setEnabled(false);
  }
 else {
    timeSystemDropdown=new JComboBox(choices);
  }
  timeSystemDropdown.setSelectedItem(plotViewManifestion.getPlot().getTimeSystemSetting());
  ssTimeSystemSelection=(String)timeSystemDropdown.getSelectedItem();
  timeSystemPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeSystemPanel.add(timeSystemDropdown);
  choices=getComponentSpecifiedTimeFormatChoices();
  if (choices == null || choices.length <= 0) {
    timeFormatDropdown=new JComboBox(new String[]{TimeService.DEFAULT_TIME_FORMAT});
    timeFormatDropdown.setFocusable(false);
    timeFormatDropdown.setEnabled(false);
  }
 else {
    timeFormatDropdown=new JComboBox(choices);
  }
  timeFormatDropdown.setSelectedItem(plotViewManifestion.getPlot().getTimeFormatSetting());
  ssTimeFormatSelection=(String)timeFormatDropdown.getSelectedItem();
  timeFormatsPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  timeFormatsPanel.add(timeFormatDropdown);
  xAxisAsTimeRadioButton=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  yAxisAsTimeRadioButton=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  zAxisAsTimeRadioButton=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  JLabel xDirTitle=new JLabel(BUNDLE.getString(""String_Node_Str""));
  xMaxAtRight=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  xMaxAtLeft=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  JLabel yDirTitle=new JLabel(BUNDLE.getString(""String_Node_Str""));
  yMaxAtTop=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  yMaxAtBottom=new JRadioButton(BUNDLE.getString(""String_Node_Str""));
  JSeparator separator1=new JSeparator(SwingConstants.VERTICAL);
  JSeparator separator2=new JSeparator(SwingConstants.VERTICAL);
  GridBagConstraints gbcTopA=new GridBagConstraints();
  gbcTopA.anchor=GridBagConstraints.WEST;
  initTopPanel.add(timePanel,gbcTopA);
  GridBagConstraints gbcSep1=new GridBagConstraints();
  gbcSep1.gridheight=4;
  gbcSep1.fill=GridBagConstraints.BOTH;
  gbcSep1.insets=new Insets(0,5,0,5);
  initTopPanel.add(separator1,gbcSep1);
  GridBagConstraints gbcTopB=new GridBagConstraints();
  gbcTopB.anchor=GridBagConstraints.WEST;
  gbcTopB.insets=new Insets(0,4,0,0);
  initTopPanel.add(xDirTitle,gbcTopB);
  initTopPanel.add(separator2,gbcSep1);
  initTopPanel.add(yDirTitle,gbcTopB);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridy=1;
  gbc.gridx=0;
  initTopPanel.add(xAxisAsTimeRadioButton,gbc);
  gbc.gridx=2;
  initTopPanel.add(xMaxAtRight,gbc);
  gbc.gridx=4;
  initTopPanel.add(yMaxAtTop,gbc);
  gbc.gridy=2;
  gbc.gridx=0;
  gbc.insets=new Insets(5,0,0,0);
  initTopPanel.add(yAxisAsTimeRadioButton,gbc);
  gbc.gridx=2;
  initTopPanel.add(xMaxAtLeft,gbc);
  gbc.gridx=4;
  initTopPanel.add(yMaxAtBottom,gbc);
  gbc.gridy=3;
  gbc.gridx=0;
  gbc.insets=new Insets(5,0,0,0);
  initTopPanel.add(zAxisAsTimeRadioButton,gbc);
  GridBagConstraints groupingGbc=new GridBagConstraints();
  groupingGbc.gridheight=4;
  groupingGbc.fill=GridBagConstraints.BOTH;
  groupingGbc.insets=new Insets(0,5,0,5);
  initTopPanel.add(new JSeparator(JSeparator.VERTICAL),groupingGbc);
  groupingGbc.gridheight=1;
  groupingGbc.gridy=0;
  initTopPanel.add(new JLabel(BUNDLE.getString(""String_Node_Str"")),groupingGbc);
  groupingGbc.gridy=1;
  groupByCollection=new JCheckBox(BUNDLE.getString(""String_Node_Str""));
  groupByCollection.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      updateMainButtons();
    }
  }
);
  initTopPanel.add(groupByCollection,groupingGbc);
  addTopPanelListenersAndState();
  initTopPanel.setName(""String_Node_Str"");
  timePanel.setName(""String_Node_Str"");
  JPanel horizontalSqueeze=new JPanel(new BorderLayout());
  horizontalSqueeze.add(initTopPanel,BorderLayout.WEST);
  return horizontalSqueeze;
}",0.9707818930041152
185206,"PlotDataCursor(PlotterPlot plot){
  parentPlot=plot;
  dateFormat=TimeFormatUtils.makeDataFormat(parentPlot.getTimeFormatSetting());
  if (plot.getTimeFormatSetting() != null) {
    timeSystemFormattedLabel.setTimeSystemAxisLabelName(parentPlot.getTimeSystemSetting());
  }
  setupTimeSystemLabel();
  setupXYDisplay();
  setupMarqueeZoom();
  setupSlopeLineDisplay();
  pin=plot.getPlotAbstraction().createPin();
}","PlotDataCursor(PlotterPlot plot){
  parentPlot=plot;
  dateFormat=TimeFormatUtils.makeDataFormat(parentPlot.getTimeFormatSetting());
  if (plot.getTimeSystemSetting() != null) {
    timeSystemFormattedLabel.setTimeSystemAxisLabelName(parentPlot.getTimeSystemSetting());
  }
  setupTimeSystemLabel();
  setupXYDisplay();
  setupMarqueeZoom();
  setupSlopeLineDisplay();
  pin=plot.getPlotAbstraction().createPin();
}",0.9855421686746988
185207,"@Override public String getTimeSystemSetting(){
  return this.get(PlotConstants.TIME_FORMAT_SETTING,String.class);
}","@Override public String getTimeSystemSetting(){
  return this.get(PlotConstants.TIME_SYSTEM_SETTING,String.class);
}",0.956896551724138
185208,"@Override public void addDataSet(String lowerCase,Color plottingColor,String displayName){
}","@Override public void addDataSet(String lowerCase,Color plottingColor,AbstractLegendEntry legend){
}",0.8229166666666666
185209,"public MultiColTable(AbstractComponent component,ViewSettings settings){
  super(new GridLayout(1,0));
  model=new MultiColTableModel(component,this,settings);
  table=new JTable(model);
  table.setAutoCreateRowSorter(true);
  table.setPreferredScrollableViewportSize(new Dimension(400,750));
  table.setFillsViewportHeight(true);
  table.setDefaultRenderer(Object.class,new MuliColTableCellRender());
  for (int colIndex=0; colIndex < model.getColumnCount(); colIndex++) {
    setColumnHeaderBorderState(colIndex,new BorderState(""String_Node_Str""));
    setColumnHeaderBorderColor(colIndex,Color.black);
  }
  scroll=new JScrollPane(table);
  add(scroll);
}","public MultiColTable(AbstractComponent component,ViewSettings settings){
  super(new GridLayout(1,0));
  model=new MultiColTableModel(component,this,settings);
  table=new JTable(model);
  table.setAutoCreateRowSorter(true);
  table.setPreferredScrollableViewportSize(new Dimension(400,750));
  table.setFillsViewportHeight(true);
  DynamicValueCellRender dynamicValueCellRender=new DynamicValueCellRender();
  table.getColumnModel().getColumn(ColumnType.VALUE.ordinal()).setCellRenderer(dynamicValueCellRender);
  table.getColumnModel().getColumn(ColumnType.RAW.ordinal()).setCellRenderer(dynamicValueCellRender);
  for (int colIndex=0; colIndex < model.getColumnCount(); colIndex++) {
    setColumnHeaderBorderState(colIndex,new BorderState(""String_Node_Str""));
    setColumnHeaderBorderColor(colIndex,Color.black);
  }
  scroll=new JScrollPane(table);
  add(scroll);
}",0.7992151733158928
185210,"public Object getValueAt(int r,int c){
  ColumnType colType=settings.getColumnAtIndex(c);
  Object cellDatum=null;
  AbstractComponent cellComponent=childrenList.get(r);
switch (colType) {
case ID:
    cellDatum=ABCD_6789;
  break;
case TITLE:
cellDatum=THRM_T_BITBOX1;
break;
case FSW_NAME:
cellDatum=ADC_RPAM_A_REU_PRT12;
break;
case RAW:
cellDatum=_2;
break;
case VALUE:
cellDatum=getValueForComponent(cellComponent);
break;
case UNIT:
cellDatum=DEQ_C;
break;
case ERT:
cellDatum=_22_59_24_448;
break;
case SCLK:
cellDatum=_0334154108_25000;
break;
case SCET:
cellDatum=_2010_250T21_26_25_762;
break;
}
if (cellDatum == null) {
return ""String_Node_Str"";
}
 else {
return cellDatum;
}
}","public Object getValueAt(int r,int c){
  ColumnType colType=settings.getColumnAtIndex(c);
  Object cellDatum=null;
  AbstractComponent cellComponent=childrenList.get(r);
switch (colType) {
case ID:
    cellDatum=ABCD_6789;
  break;
case TITLE:
cellDatum=THRM_T_BITBOX1;
break;
case FSW_NAME:
cellDatum=ADC_RPAM_A_REU_PRT12;
break;
case RAW:
cellDatum=getValueForComponent(cellComponent);
break;
case VALUE:
cellDatum=getValueForComponent(cellComponent);
break;
case UNIT:
cellDatum=DEQ_C;
break;
case ERT:
cellDatum=_22_59_24_448;
break;
case SCLK:
cellDatum=_0334154108_25000;
break;
case SCET:
cellDatum=_2010_250T21_26_25_762;
break;
}
if (cellDatum == null) {
return ""String_Node_Str"";
}
 else {
return cellDatum;
}
}",0.9737402413058908
185211,"/** 
 * Sets the value of an object updated by a data feed. This change is propogated to all table cells displaying that object.
 * @param id the identifier for the object updated
 * @param value the new value to display
 */
public void setValue(String id,Object value){
  values.put(id,value);
  List<Integer> locations=componentLocations.get(id);
  if (locations != null) {
    for (    Integer row : locations) {
      fireTableCellUpdated(row,ColumnType.VALUE.ordinal());
    }
  }
}","/** 
 * Sets the value of an object updated by a data feed. This change is propogated to all table cells displaying that object.
 * @param id the identifier for the object updated
 * @param value the new value to display
 */
public void setValue(String id,Object value){
  values.put(id,value);
  List<Integer> locations=componentLocations.get(id);
  if (locations != null) {
    for (    Integer row : locations) {
      fireTableCellUpdated(row,ColumnType.VALUE.ordinal());
      fireTableCellUpdated(row,ColumnType.RAW.ordinal());
    }
  }
}",0.9437984496124032
185212,"@Override public ExecutionResult execute(PolicyContext context){
  ExecutionResult trueResult=new ExecutionResult(context,true,""String_Node_Str"");
  AbstractComponent component=context.getProperty(PolicyContext.PropertyName.TARGET_COMPONENT.getName(),AbstractComponent.class);
  if (!checkArguments(context,component))   return trueResult;
  ViewType viewType=context.getProperty(PolicyContext.PropertyName.VIEW_TYPE.getName(),ViewType.class);
  ViewInfo targetViewInfo=context.getProperty(PolicyContext.PropertyName.TARGET_VIEW_INFO.getName(),ViewInfo.class);
  if (viewType == ViewType.OBJECT || viewType == ViewType.CENTER) {
    if (hasPermission(component)) {
      if (DropboxCanvasView.class.isAssignableFrom(targetViewInfo.getViewClass()))       return new ExecutionResult(context,false,""String_Node_Str"");
    }
 else {
      if (!(DropboxCanvasView.class.isAssignableFrom(targetViewInfo.getViewClass())))       return new ExecutionResult(context,false,""String_Node_Str"");
    }
  }
  return trueResult;
}","@Override public ExecutionResult execute(PolicyContext context){
  ExecutionResult trueResult=new ExecutionResult(context,true,""String_Node_Str"");
  AbstractComponent component=context.getProperty(PolicyContext.PropertyName.TARGET_COMPONENT.getName(),AbstractComponent.class);
  if (!checkArguments(context,component))   return trueResult;
  ViewType viewType=context.getProperty(PolicyContext.PropertyName.VIEW_TYPE.getName(),ViewType.class);
  ViewInfo targetViewInfo=context.getProperty(PolicyContext.PropertyName.TARGET_VIEW_INFO.getName(),ViewInfo.class);
  if (viewType == ViewType.OBJECT || viewType == ViewType.CENTER) {
    if (DropboxCanvasView.class.isAssignableFrom(targetViewInfo.getViewClass()) || targetViewInfo.getViewName().equals(""String_Node_Str""))     return new ExecutionResult(context,true,""String_Node_Str"");
  }
  return new ExecutionResult(context,false,""String_Node_Str"");
}",0.8254963427377221
185213,"void layoutPanel(){
  removeAll();
  add(spanTag);
  add(boxStrut);
  add(spanValue);
  add(Box.createHorizontalStrut(INTERCONTROL_HORIZONTAL_SPACING + 3));
  add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
  add(Box.createHorizontalStrut(INTERCONTROL_HORIZONTAL_SPACING + 3));
  add(timeSpanValue.getYearSpanValue());
}","void layoutPanel(){
  removeAll();
  add(spanTag);
  add(boxStrut);
  add(spanValue);
  if (spanValue instanceof TimeSpanTextField) {
    add(Box.createHorizontalStrut(INTERCONTROL_HORIZONTAL_SPACING + 3));
    add(new JLabel(BUNDLE.getString(""String_Node_Str"")));
    add(Box.createHorizontalStrut(INTERCONTROL_HORIZONTAL_SPACING + 3));
    add(timeSpanValue.getYearSpanValue());
  }
}",0.9157303370786516
185214,"private Properties getPersistenceProperties() throws IOException {
  Properties properties=new Properties();
  InputStream is=ClassLoader.getSystemClassLoader().getResourceAsStream(PERSISTENCE_PROPS);
  if (is == null)   throw new IOException(""String_Node_Str"" + PERSISTENCE_PROPS);
  try {
    properties.load(is);
  }
  finally {
    is.close();
  }
  final String dbUser=""String_Node_Str"";
  final String dbPassword=""String_Node_Str"";
  final String dbConnectionURL=""String_Node_Str"";
  final String dbName=""String_Node_Str"";
  final String dbProperties=""String_Node_Str"";
  final String jdbcUrlProperty=""String_Node_Str"";
  if (System.getProperty(jdbcUrlProperty) != null) {
    properties.put(jdbcUrlProperty,System.getProperty(jdbcUrlProperty));
  }
  properties.put(""String_Node_Str"",System.getProperty(dbUser,properties.getProperty(dbUser)));
  properties.put(""String_Node_Str"",System.getProperty(dbPassword,properties.getProperty(dbPassword)));
  String connectionURL=System.getProperty(dbConnectionURL,properties.getProperty(dbConnectionURL)) + System.getProperty(dbName,properties.getProperty(dbName)) + ""String_Node_Str""+ System.getProperty(dbProperties,properties.getProperty(dbProperties));
  if (!properties.containsKey(jdbcUrlProperty)) {
    properties.put(jdbcUrlProperty,connectionURL);
  }
  return properties;
}","private Properties getPersistenceProperties() throws IOException {
  Properties properties=new Properties();
  InputStream is=ClassLoader.getSystemClassLoader().getResourceAsStream(PERSISTENCE_PROPS);
  if (is == null)   throw new IOException(""String_Node_Str"" + PERSISTENCE_PROPS);
  try {
    properties.load(is);
  }
  finally {
    is.close();
  }
  final String dbUser=""String_Node_Str"";
  final String dbPassword=""String_Node_Str"";
  final String dbConnectionURL=""String_Node_Str"";
  final String dbName=""String_Node_Str"";
  final String dbProperties=""String_Node_Str"";
  final String jdbcUrlProperty=""String_Node_Str"";
  if (System.getProperty(jdbcUrlProperty) != null) {
    properties.put(jdbcUrlProperty,System.getProperty(jdbcUrlProperty));
  }
  final String userName=System.getProperty(dbUser,properties.getProperty(dbUser));
  final String pw=System.getProperty(dbPassword,properties.getProperty(dbPassword));
  if (userName != null) {
    properties.put(""String_Node_Str"",userName);
  }
  if (pw != null) {
    properties.put(""String_Node_Str"",pw);
  }
  String connectionURL=System.getProperty(dbConnectionURL,properties.getProperty(dbConnectionURL)) + System.getProperty(dbName,properties.getProperty(dbName)) + ""String_Node_Str""+ System.getProperty(dbProperties,properties.getProperty(dbProperties));
  if (!properties.containsKey(jdbcUrlProperty)) {
    properties.put(jdbcUrlProperty,connectionURL);
  }
  return properties;
}",0.8704103671706264
185215,"private void setMaxAlarmIconToAlarmOpendedByUser(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmOpenedByUserIcon);
}","private void setMaxAlarmIconToAlarmOpendedByUser(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmOpenedByUserIcon,BUNDLE.getString(""String_Node_Str""));
}",0.8807947019867549
185216,"private void setMaxAlarmIconToAlarmClosedByUser(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmClosedByUserIcon);
}","private void setMaxAlarmIconToAlarmClosedByUser(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmClosedByUserIcon,BUNDLE.getString(""String_Node_Str""));
}",0.88
185217,"/** 
 * Set the enabled state of the manager.
 * @param state true if manager is enabled, false otherwise. 
 */
void setEnabled(boolean state){
  if (state) {
    if (cachedNonTimeMinAlarm != LimitAlarmState.NO_ALARM) {
      nonTimeMinAlarm=cachedNonTimeMaxAlarm;
    }
    if (cachedNonTimeMaxAlarm != LimitAlarmState.NO_ALARM) {
      nonTimeMaxAlarm=cachedNonTimeMaxAlarm;
    }
    isEnabled=true;
  }
 else {
    isEnabled=false;
    hideAllLimitButtons();
    cacheCurrentAlarmState();
    nonTimeMinAlarm=LimitAlarmState.NO_ALARM;
    nonTimeMaxAlarm=LimitAlarmState.NO_ALARM;
  }
}","/** 
 * Set the enabled state of the manager.
 * @param state true if manager is enabled, false otherwise. 
 */
void setEnabled(boolean state){
  if (state) {
    if (cachedNonTimeMinAlarm != LimitAlarmState.NO_ALARM) {
      nonTimeMinAlarm=cachedNonTimeMaxAlarm;
    }
    if (cachedNonTimeMaxAlarm != LimitAlarmState.NO_ALARM) {
      nonTimeMaxAlarm=cachedNonTimeMaxAlarm;
    }
    showAllLimitButtons();
    isEnabled=true;
  }
 else {
    isEnabled=false;
    hideAllLimitButtons();
    cacheCurrentAlarmState();
    nonTimeMinAlarm=LimitAlarmState.NO_ALARM;
    nonTimeMaxAlarm=LimitAlarmState.NO_ALARM;
  }
}",0.8831814415907208
185218,"private void setMinAlarmIconToAlarmOpendedByUser(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmOpenedByUserIcon);
}","private void setMinAlarmIconToAlarmOpendedByUser(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmOpenedByUserIcon,BUNDLE.getString(""String_Node_Str""));
}",0.8807947019867549
185219,"private void setMinAlarmIconToAlarmClosedByUser(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmClosedByUserIcon);
}","private void setMinAlarmIconToAlarmClosedByUser(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmClosedByUserIcon,BUNDLE.getString(""String_Node_Str""));
}",0.88
185220,"private void setMaxAlarmIconToAlarmRaised(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmRaisedIcon);
}","private void setMaxAlarmIconToAlarmRaised(){
  changeButtonIcon(nonTimeMaxLimitButton,nonTimeMaxLimitAlarmRaisedIcon,BUNDLE.getString(""String_Node_Str""));
}",0.8695652173913043
185221,"private void setMinAlarmIconToAlarmRaised(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmRaisedIcon);
}","private void setMinAlarmIconToAlarmRaised(){
  changeButtonIcon(nonTimeMinLimitButton,nonTimeMinLimitAlarmRaisedIcon,BUNDLE.getString(""String_Node_Str""));
}",0.8695652173913043
185222,"private void changeButtonIcon(JButton button,ImageIcon newIcon){
  button.setIcon(newIcon);
}","private void changeButtonIcon(JButton button,ImageIcon newIcon,String tooltip){
  button.setIcon(newIcon);
  button.setToolTipText(tooltip);
}",0.7914893617021277
185223,"public static Shape getShape(String character,FontRenderContext frc){
  Font font=PlotLineGlobalConfiguration.getMarkerFont();
  Shape shape=font.createGlyphVector(frc,character).getGlyphOutline(0);
  Rectangle bounds=shape.getBounds();
  shape=AffineTransform.getTranslateInstance(-bounds.width / 2,bounds.height / 2).createTransformedShape(shape);
  return shape;
}","public static Shape getShape(String character,FontRenderContext frc){
  Font font=PlotLineGlobalConfiguration.getMarkerFont();
  Shape shape=font.createGlyphVector(frc,character).getGlyphOutline(0);
  Rectangle bounds=shape.getBounds();
  shape=AffineTransform.getTranslateInstance(-bounds.width / (double)2,bounds.height / (double)2).createTransformedShape(shape);
  return shape;
}",0.9786666666666668
185224,"@Override public boolean verify(JComponent component){
  TimeSpanTextField field=(TimeSpanTextField)component;
  String days=field.getText().substring(DAYS_POSITION,3);
  String hours=field.getText().substring(HOURS_POSITION,6);
  String minutes=field.getText().substring(MINUTES_POSITION,9);
  String seconds=field.getText().substring(SECONDS_POSITION,12);
  int daysValue=Integer.parseInt(days);
  int hoursValue=Integer.parseInt(hours);
  int minutesValue=Integer.parseInt(minutes);
  int secondsValue=Integer.parseInt(seconds);
  if (secondsValue >= 60) {
    minutesValue+=Double.valueOf(Math.floor(secondsValue / 60)).intValue();
    secondsValue=secondsValue % 60;
  }
  if (minutesValue >= 60) {
    hoursValue+=Double.valueOf(Math.floor(minutesValue / 60)).intValue();
    minutesValue=minutesValue % 60;
  }
  if (hoursValue >= 24) {
    daysValue+=Double.valueOf(Math.floor(hoursValue / 24)).intValue();
    hoursValue=hoursValue % 24;
  }
  if (daysValue > 366) {
    field.setSelectionStart(DAYS_POSITION);
    field.setSelectionEnd(3);
    return false;
  }
  setTimeValue(daysValue,hoursValue,minutesValue,secondsValue);
  return field.isEditValid();
}","@Override public boolean verify(JComponent component){
  TimeSpanTextField field=(TimeSpanTextField)component;
  String days=field.getText().substring(DAYS_POSITION,3);
  String hours=field.getText().substring(HOURS_POSITION,6);
  String minutes=field.getText().substring(MINUTES_POSITION,9);
  String seconds=field.getText().substring(SECONDS_POSITION,12);
  int daysValue=Integer.parseInt(days);
  int hoursValue=Integer.parseInt(hours);
  int minutesValue=Integer.parseInt(minutes);
  int secondsValue=Integer.parseInt(seconds);
  if (secondsValue >= 60) {
    minutesValue+=secondsValue / 60;
    secondsValue=secondsValue % 60;
  }
  if (minutesValue >= 60) {
    hoursValue+=minutesValue / 60;
    minutesValue=minutesValue % 60;
  }
  if (hoursValue >= 24) {
    daysValue+=hoursValue / 24;
    hoursValue=hoursValue % 24;
  }
  if (daysValue > 366) {
    field.setSelectionStart(DAYS_POSITION);
    field.setSelectionEnd(3);
    return false;
  }
  setTimeValue(daysValue,hoursValue,minutesValue,secondsValue);
  return field.isEditValid();
}",0.9472259810554804
185225,"@Override public boolean verify(JComponent component){
  TimeTextField field=(TimeTextField)component;
  String text=field.getText();
  if (text == null || text.length() == 0) {
    return true;
  }
  String days=text.substring(DAYS_POSITION,3);
  String hours=text.substring(HOURS_POSITION,6);
  String minutes=text.substring(MINUTES_POSITION,9);
  String seconds=text.substring(SECONDS_POSITION,12);
  int daysValue=Integer.parseInt(days);
  int hoursValue=Integer.parseInt(hours);
  int minutesValue=Integer.parseInt(minutes);
  int secondsValue=Integer.parseInt(seconds);
  if (daysValue == 0) {
    field.setSelectionStart(DAYS_POSITION);
    field.setSelectionEnd(3);
    return false;
  }
  if (secondsValue >= 60) {
    minutesValue+=Double.valueOf(Math.floor(secondsValue / 60)).intValue();
    secondsValue=secondsValue % 60;
  }
  if (minutesValue >= 60) {
    hoursValue+=Double.valueOf(Math.floor(minutesValue / 60)).intValue();
    minutesValue=minutesValue % 60;
  }
  if (hoursValue >= 24) {
    daysValue+=Double.valueOf(Math.floor(hoursValue / 24)).intValue();
    hoursValue=hoursValue % 24;
  }
  if ((modelCalendar.isLeapYear(modelCalendar.get(Calendar.YEAR)) && daysValue > 366) || (!modelCalendar.isLeapYear(modelCalendar.get(Calendar.YEAR)) && daysValue > 365)) {
    yearValue=(modelCalendar.get(Calendar.YEAR) + Double.valueOf(Math.floor(daysValue / 365)).intValue());
    daysValue=(daysValue % 365) + 1;
  }
  setTimeValue(daysValue,hoursValue,minutesValue,secondsValue);
  return field.isEditValid();
}","@Override public boolean verify(JComponent component){
  TimeTextField field=(TimeTextField)component;
  String text=field.getText();
  if (text == null || text.length() == 0) {
    return true;
  }
  String days=text.substring(DAYS_POSITION,3);
  String hours=text.substring(HOURS_POSITION,6);
  String minutes=text.substring(MINUTES_POSITION,9);
  String seconds=text.substring(SECONDS_POSITION,12);
  int daysValue=Integer.parseInt(days);
  int hoursValue=Integer.parseInt(hours);
  int minutesValue=Integer.parseInt(minutes);
  int secondsValue=Integer.parseInt(seconds);
  if (daysValue == 0) {
    field.setSelectionStart(DAYS_POSITION);
    field.setSelectionEnd(3);
    return false;
  }
  if (secondsValue >= 60) {
    minutesValue+=secondsValue / 60;
    secondsValue=secondsValue % 60;
  }
  if (minutesValue >= 60) {
    hoursValue+=minutesValue / 60;
    minutesValue=minutesValue % 60;
  }
  if (hoursValue >= 24) {
    daysValue+=hoursValue / 24;
    hoursValue=hoursValue % 24;
  }
  if ((modelCalendar.isLeapYear(modelCalendar.get(Calendar.YEAR)) && daysValue > 366) || (!modelCalendar.isLeapYear(modelCalendar.get(Calendar.YEAR)) && daysValue > 365)) {
    yearValue=(modelCalendar.get(Calendar.YEAR) + Double.valueOf(Math.floor(daysValue / 365)).intValue());
    daysValue=(daysValue % 365) + 1;
  }
  setTimeValue(daysValue,hoursValue,minutesValue,secondsValue);
  return field.isEditValid();
}",0.9602716468590832
185226,"@Test void testBothAlarms(){
  PlotView testPlot=new PlotView.Builder(PlotterPlot.class).nonTimeAxisMinSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeAxisMaxSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeVaribleAxisMaxValue(10).nonTimeVaribleAxisMinValue(0).build();
  testPlot.setManifestation(mockPlotViewManifestation);
  testPlot.setCompressionEnabled(false);
  Assert.assertFalse(testPlot.isCompresionEnabled());
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addDataSet(""String_Node_Str"");
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),-1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),11);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.ALARM_RAISED);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
}","@Test void testBothAlarms(){
  PlotView testPlot=new PlotView.Builder(PlotterPlot.class).nonTimeAxisMinSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeAxisMaxSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeVaribleAxisMaxValue(10).nonTimeVaribleAxisMinValue(0).build();
  testPlot.setManifestation(mockPlotViewManifestation);
  testPlot.setCompressionEnabled(false);
  Assert.assertFalse(testPlot.isCompresionEnabled());
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addDataSet(""String_Node_Str"");
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),-1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),11);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.ALARM_RAISED);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
}",0.996817313812858
185227,"@Test public void testMinAlarmOnly(){
  PlotView testPlot=new PlotView.Builder(PlotterPlot.class).nonTimeAxisMinSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeAxisMaxSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeVaribleAxisMaxValue(10).nonTimeVaribleAxisMinValue(0).build();
  testPlot.setManifestation(mockPlotViewManifestation);
  testPlot.setCompressionEnabled(false);
  Assert.assertFalse(testPlot.isCompresionEnabled());
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addDataSet(""String_Node_Str"");
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),-1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
}","@Test public void testMinAlarmOnly(){
  PlotView testPlot=new PlotView.Builder(PlotterPlot.class).nonTimeAxisMinSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeAxisMaxSubsequentSetting(NonTimeAxisSubsequentBoundsSetting.FIXED).nonTimeVaribleAxisMaxValue(10).nonTimeVaribleAxisMinValue(0).build();
  testPlot.setManifestation(mockPlotViewManifestation);
  testPlot.setCompressionEnabled(false);
  Assert.assertFalse(testPlot.isCompresionEnabled());
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addDataSet(""String_Node_Str"");
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.NO_ALARM);
  testPlot.addData(""String_Node_Str"",System.currentTimeMillis(),-1);
  Assert.assertEquals(testPlot.getNonTimeMaxAlarmState(0),LimitAlarmState.NO_ALARM);
  Assert.assertEquals(testPlot.getNonTimeMinAlarmState(0),LimitAlarmState.ALARM_RAISED);
}",0.9962490622655664
185228,"/** 
 * Setup the mouse position x,y label that will be positioned at the top of the plot. 
 */
private void setupXYDisplay(){
  pointerXYValueLabel.setSize((int)pointerXYValueLabel.getPreferredSize().getWidth(),(int)pointerXYValueLabel.getPreferredSize().getHeight());
  pointerXYValueLabel.setFont(parentPlot.timeAxisFont);
  pointerXYValueLabel.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  pointerXYValueLabel.attach(parentPlot.plotView);
  if (parentPlot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,dateFormat);
    format.setFormatByArgumentIndex(1,PlotConstants.SCIENTIFIC_FORMAT);
    pointerXYValueLabel.setFormat(format);
  }
 else {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(1,dateFormat);
    pointerXYValueLabel.setFormat(format);
  }
  pointerXYValueLabel.setText(""String_Node_Str"");
  Dimension size=pointerXYValueLabel.getPreferredSize();
  size.width=100;
  pointerXYValueLabel.setText(""String_Node_Str"");
  pointerXYValueLabel.setPreferredSize(size);
  XYPlot plot=parentPlot.plotView;
  XYPlotContents contents=plot.getContents();
  plot.add(pointerXYValueLabel);
  plot.add(timeSystemFormattedLabel);
  SpringLayout layout2=(SpringLayout)plot.getLayout();
  layout2.putConstraint(SpringLayout.NORTH,pointerXYValueLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.WEST,timeSystemFormattedLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.NORTH,timeSystemFormattedLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,10,SpringLayout.EAST,timeSystemFormattedLabel);
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,pointerXYValueLabel);
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,timeSystemFormattedLabel);
  plot.getYAxis().setEndMargin(pointerXYValueLabel.getPreferredSize().height);
  plot.getYAxis().setEndMargin(timeSystemFormattedLabel.getPreferredSize().height);
}","/** 
 * Setup the mouse position x,y label that will be positioned at the top of the plot. 
 */
private void setupXYDisplay(){
  pointerXYValueLabel.setSize((int)pointerXYValueLabel.getPreferredSize().getWidth(),(int)pointerXYValueLabel.getPreferredSize().getHeight());
  pointerXYValueLabel.setFont(parentPlot.timeAxisFont);
  pointerXYValueLabel.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  pointerXYValueLabel.attach(parentPlot.plotView);
  if (parentPlot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,dateFormat);
    format.setFormatByArgumentIndex(1,PlotConstants.SCIENTIFIC_FORMAT);
    pointerXYValueLabel.setFormat(format);
  }
 else {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(1,dateFormat);
    pointerXYValueLabel.setFormat(format);
  }
  pointerXYValueLabel.setText(""String_Node_Str"");
  Dimension size=pointerXYValueLabel.getPreferredSize();
  size.width=100;
  pointerXYValueLabel.setText(""String_Node_Str"");
  pointerXYValueLabel.setPreferredSize(size);
  XYPlot plot=parentPlot.plotView;
  XYPlotContents contents=plot.getContents();
  plot.add(pointerXYValueLabel);
  plot.add(timeSystemFormattedLabel);
  SpringLayout layout2=(SpringLayout)plot.getLayout();
  layout2.putConstraint(SpringLayout.NORTH,pointerXYValueLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.WEST,timeSystemFormattedLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.NORTH,timeSystemFormattedLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,10,SpringLayout.EAST,timeSystemFormattedLabel);
  JComponent top=(pointerXYValueLabel.getPreferredSize().height > timeSystemFormattedLabel.getPreferredSize().height) ? pointerXYValueLabel : timeSystemFormattedLabel;
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,top);
  plot.getYAxis().setEndMargin(top.getPreferredSize().height);
}",0.9149119037387192
185229,"/** 
 * Setup the slope dx, dy label that will be positioned at the top of the plot
 */
@SuppressWarnings(""String_Node_Str"") private void setupSlopeLineDisplay(){
  slopeLine=new SlopeLine();
  slopeLine.attach(parentPlot.plotView);
  slopeLine.addListenerForPlot(parentPlot.plotView,slopeLabel);
  slopeLine.addListenerForPlot(parentPlot.plotView,new SlopeLine.Listener(){
    @Override public void slopeLineUpdated(    SlopeLine line,    XYPlot plot,    double arg2,    double arg3,    double arg4,    double arg5){
    }
    @Override public void slopeLineRemoved(    SlopeLine line,    XYPlot plot){
      pin.setPinned(false);
    }
    @Override public void slopeLineAdded(    SlopeLine line,    XYPlot plot,    double arg2,    double arg3){
      pin.setPinned(true);
    }
  }
);
  slopeLine.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  slopeLabel.setFont(parentPlot.timeAxisFont);
  slopeLabel.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  if (parentPlot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str""+ HTML_WHITESPACES+ ""String_Node_Str""+ BUNDLE.getString(""String_Node_Str"")+ ""String_Node_Str""+ PlotConstants.SLOPE_UNIT+ ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,TIME_SPAN_FORMAT);
    format.setFormatByArgumentIndex(1,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(2,new NumberFormat(){
      @Override public Number parse(      String source,      ParsePosition parsePosition){
        throw new RuntimeException(""String_Node_Str"");
      }
      @Override public StringBuffer format(      long number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(number * PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS));
        return toAppendTo;
      }
      @Override public StringBuffer format(      double number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(number * PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS));
        return toAppendTo;
      }
    }
);
    slopeLabel.setFormat(format);
  }
 else {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str""+ HTML_WHITESPACES+ ""String_Node_Str""+ BUNDLE.getString(""String_Node_Str"")+ ""String_Node_Str""+ PlotConstants.SLOPE_UNIT+ ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(1,TIME_SPAN_FORMAT);
    format.setFormatByArgumentIndex(2,new NumberFormat(){
      @Override public Number parse(      String source,      ParsePosition parsePosition){
        throw new RuntimeException(""String_Node_Str"");
      }
      @Override public StringBuffer format(      long number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS / (double)number));
        return toAppendTo;
      }
      @Override public StringBuffer format(      double number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS / number));
        return toAppendTo;
      }
    }
);
    slopeLabel.setFormat(format);
  }
  slopeLabel.setText(""String_Node_Str"");
  Dimension size=slopeLabel.getPreferredSize();
  size.width=100;
  slopeLabel.setText(""String_Node_Str"");
  slopeLabel.setPreferredSize(size);
  XYPlot plot=parentPlot.plotView;
  plot.add(slopeLabel);
  XYPlotContents contents=plot.getContents();
  SpringLayout layout2=(SpringLayout)plot.getLayout();
  layout2.putConstraint(SpringLayout.NORTH,slopeLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.EAST,slopeLabel,0,SpringLayout.EAST,contents);
  layout2.putConstraint(SpringLayout.WEST,timeSystemFormattedLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.NORTH,timeSystemFormattedLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,10,SpringLayout.EAST,timeSystemFormattedLabel);
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,pointerXYValueLabel);
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,timeSystemFormattedLabel);
}","/** 
 * Setup the slope dx, dy label that will be positioned at the top of the plot
 */
@SuppressWarnings(""String_Node_Str"") private void setupSlopeLineDisplay(){
  slopeLine=new SlopeLine();
  slopeLine.attach(parentPlot.plotView);
  slopeLine.addListenerForPlot(parentPlot.plotView,slopeLabel);
  slopeLine.addListenerForPlot(parentPlot.plotView,new SlopeLine.Listener(){
    @Override public void slopeLineUpdated(    SlopeLine line,    XYPlot plot,    double arg2,    double arg3,    double arg4,    double arg5){
    }
    @Override public void slopeLineRemoved(    SlopeLine line,    XYPlot plot){
      pin.setPinned(false);
    }
    @Override public void slopeLineAdded(    SlopeLine line,    XYPlot plot,    double arg2,    double arg3){
      pin.setPinned(true);
    }
  }
);
  slopeLine.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  slopeLabel.setFont(parentPlot.timeAxisFont);
  slopeLabel.setForeground(PlotConstants.DATA_CURSOR_COLOR);
  if (parentPlot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str""+ HTML_WHITESPACES+ ""String_Node_Str""+ BUNDLE.getString(""String_Node_Str"")+ ""String_Node_Str""+ PlotConstants.SLOPE_UNIT+ ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,TIME_SPAN_FORMAT);
    format.setFormatByArgumentIndex(1,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(2,new NumberFormat(){
      @Override public Number parse(      String source,      ParsePosition parsePosition){
        throw new RuntimeException(""String_Node_Str"");
      }
      @Override public StringBuffer format(      long number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(number * PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS));
        return toAppendTo;
      }
      @Override public StringBuffer format(      double number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(number * PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS));
        return toAppendTo;
      }
    }
);
    slopeLabel.setFormat(format);
  }
 else {
    MessageFormat format=new MessageFormat(""String_Node_Str"" + HTML_WHITESPACES + ""String_Node_Str""+ HTML_WHITESPACES+ ""String_Node_Str""+ BUNDLE.getString(""String_Node_Str"")+ ""String_Node_Str""+ PlotConstants.SLOPE_UNIT+ ""String_Node_Str"");
    format.setFormatByArgumentIndex(0,PlotConstants.SCIENTIFIC_FORMAT);
    format.setFormatByArgumentIndex(1,TIME_SPAN_FORMAT);
    format.setFormatByArgumentIndex(2,new NumberFormat(){
      @Override public Number parse(      String source,      ParsePosition parsePosition){
        throw new RuntimeException(""String_Node_Str"");
      }
      @Override public StringBuffer format(      long number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS / (double)number));
        return toAppendTo;
      }
      @Override public StringBuffer format(      double number,      StringBuffer toAppendTo,      FieldPosition pos){
        toAppendTo.append(PlotConstants.SCIENTIFIC_FORMAT.format(PlotConstants.SLOPE_UNIT_DIVIDER_IN_MS / number));
        return toAppendTo;
      }
    }
);
    slopeLabel.setFormat(format);
  }
  slopeLabel.setText(""String_Node_Str"");
  Dimension size=slopeLabel.getPreferredSize();
  size.width=100;
  slopeLabel.setText(""String_Node_Str"");
  slopeLabel.setPreferredSize(size);
  XYPlot plot=parentPlot.plotView;
  plot.add(slopeLabel);
  XYPlotContents contents=plot.getContents();
  SpringLayout layout2=(SpringLayout)plot.getLayout();
  layout2.putConstraint(SpringLayout.NORTH,slopeLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.EAST,slopeLabel,0,SpringLayout.EAST,contents);
  layout2.putConstraint(SpringLayout.WEST,timeSystemFormattedLabel,0,SpringLayout.WEST,contents);
  layout2.putConstraint(SpringLayout.NORTH,timeSystemFormattedLabel,0,SpringLayout.NORTH,plot);
  layout2.putConstraint(SpringLayout.WEST,pointerXYValueLabel,10,SpringLayout.EAST,timeSystemFormattedLabel);
  JComponent top=(pointerXYValueLabel.getPreferredSize().height > timeSystemFormattedLabel.getPreferredSize().height) ? pointerXYValueLabel : timeSystemFormattedLabel;
  layout2.putConstraint(SpringLayout.NORTH,contents,0,SpringLayout.SOUTH,top);
  plot.getYAxis().setEndMargin(top.getPreferredSize().height);
}",0.9605750870493092
185230,"private void ensureViewPropertiesLoaded(){
}","private synchronized void ensureViewPropertiesLoaded(){
}",0.8712871287128713
185231,"private void ensureViewPropertiesLoaded(){
}","private synchronized void ensureViewPropertiesLoaded(){
}",0.8712871287128713
185232,"@Override public void mouseReleased(MouseEvent e){
  if (canvas != null) {
    xyPlot.getContents().remove(canvas);
    Point2D startCoord=convertPointToLogicalCoord(mouseStartX,mouseStartY);
    Point2D endCoord=convertPointToLogicalCoord(mouseEndX,mouseEndY);
    XYAxis xAxis=xyPlot.getXAxis();
    if (endCoord.getX() > startCoord.getX()) {
      xAxis.setStart(startCoord.getX());
      xAxis.setEnd(endCoord.getX());
    }
 else {
      xAxis.setStart(endCoord.getX());
      xAxis.setEnd(startCoord.getX());
    }
    XYAxis yAxis=xyPlot.getYAxis();
    if (endCoord.getY() > startCoord.getY()) {
      yAxis.setStart(startCoord.getY());
      yAxis.setEnd(endCoord.getY());
    }
 else {
      yAxis.setStart(endCoord.getY());
      yAxis.setEnd(startCoord.getY());
    }
    plotLocalControlsManager.pinXYAxes();
    marqueeRect=null;
    canvas=null;
    xyPlot.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
  }
}","@Override public void mouseReleased(MouseEvent e){
  if (canvas != null) {
    xyPlot.getContents().remove(canvas);
    Point2D startCoord=convertPointToLogicalCoord(mouseStartX,mouseStartY);
    Point2D endCoord=convertPointToLogicalCoord(mouseEndX,mouseEndY);
    XYAxis xAxis=xyPlot.getXAxis();
    if (endCoord.getX() > startCoord.getX()) {
      xAxis.setStart(startCoord.getX());
      xAxis.setEnd(endCoord.getX());
    }
 else {
      xAxis.setStart(endCoord.getX());
      xAxis.setEnd(startCoord.getX());
    }
    XYAxis yAxis=xyPlot.getYAxis();
    if (endCoord.getY() > startCoord.getY()) {
      yAxis.setStart(startCoord.getY());
      yAxis.setEnd(endCoord.getY());
    }
 else {
      yAxis.setStart(endCoord.getY());
      yAxis.setEnd(startCoord.getY());
    }
    plotLocalControlsManager.pinXYAxesAfterZoomedIn();
    marqueeRect=null;
    canvas=null;
    xyPlot.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
  }
}",0.9931253305129562
185233,"@Override protected <T>T handleGetCapability(Class<T> capability){
  if (MultiComponent.class.isAssignableFrom(capability)) {
    return capability.cast(this);
  }
  if (Evaluator.class.isAssignableFrom(capability)) {
    Evaluator e=new Evaluator(){
      @Override public String getCode(){
        return getData().getCode();
      }
      @Override public String getDisplayName(){
        return getDisplay();
      }
      @Override public String getLanguage(){
        return getData().getLanguage();
      }
      public boolean requiresMultipleInputs(){
        return getExecutor() != null && getExecutor().requiresMultipleInputs();
      }
      private Executor getExecutor(){
        Executor e=executor.get();
        if (e == null) {
          executor.set(e=MultiProviderRegistry.getExecutor(MultiComponent.this));
        }
        return e;
      }
      private final AtomicReference<Executor> executor=new AtomicReference<Executor>();
      @Override public FeedProvider.RenderingInfo evaluate(      Map<String,List<Map<String,String>>> data,      List<FeedProvider> providers){
        Executor e=getExecutor();
        FeedProvider.RenderingInfo ri=null;
        if (e != null) {
          if (getData().isPassThrough()) {
            for (            FeedProvider fp : providers) {
              if (fp.getSubscriptionId().startsWith(""String_Node_Str"")) {
                if (fp.getSubscriptionId().substring(4).equals(getData().getPassThroughParameterId())) {
                  List<Map<String,String>> values=data.get(""String_Node_Str"" + getData().getPassThroughParameterId());
                  if (values != null) {
                    ri=fp.getRenderingInfo(values.get(values.size() - 1));
                  }
                }
              }
 else {
                if (fp.getSubscriptionId().equals(getData().getPassThroughParameterId())) {
                  List<Map<String,String>> values=data.get(getData().getPassThroughParameterId());
                  if (values != null) {
                    ri=fp.getRenderingInfo(values.get(values.size() - 1));
                  }
                }
              }
            }
          }
 else {
            ri=e.evaluate(data,providers);
            if (ri == null) {
              ri=new FeedProvider.RenderingInfo(getData().getFallThroughDisplayValue(),Color.red,""String_Node_Str"",Color.red,false);
            }
          }
        }
 else {
          LoggerFactory.getLogger(MultiComponent.class).error(""String_Node_Str"" + getLanguage());
          ri=new FeedProvider.RenderingInfo(""String_Node_Str"",Color.red,""String_Node_Str"",Color.red,false);
        }
        return ri;
      }
    }
;
    return capability.cast(e);
  }
  if (ModelStatePersistence.class.isAssignableFrom(capability)) {
    JAXBModelStatePersistence<MultiModelRole> persistence=new JAXBModelStatePersistence<MultiModelRole>(){
      @Override protected MultiModelRole getStateToPersist(){
        return model.get();
      }
      @Override protected void setPersistentState(      MultiModelRole modelState){
        model.set(modelState);
      }
      @Override protected Class<MultiModelRole> getJAXBClass(){
        return MultiModelRole.class;
      }
    }
;
    return capability.cast(persistence);
  }
  return super.handleGetCapability(capability);
}","@Override protected <T>T handleGetCapability(Class<T> capability){
  if (MultiComponent.class.isAssignableFrom(capability)) {
    return capability.cast(this);
  }
  if (Evaluator.class.isAssignableFrom(capability)) {
    Evaluator e=new Evaluator(){
      @Override public String getCode(){
        return getData().getCode();
      }
      @Override public String getDisplayName(){
        return getDisplay();
      }
      @Override public String getLanguage(){
        return getData().getLanguage();
      }
      public boolean requiresMultipleInputs(){
        return getExecutor() != null && getExecutor().requiresMultipleInputs();
      }
      private Executor getExecutor(){
        Executor e=executor.get();
        if (e == null) {
          executor.set(e=MultiProviderRegistry.getExecutor(MultiComponent.this));
        }
        return e;
      }
      private final AtomicReference<Executor> executor=new AtomicReference<Executor>();
      @Override public FeedProvider.RenderingInfo evaluate(      Map<String,List<Map<String,String>>> data,      List<FeedProvider> providers){
        Executor e=getExecutor();
        FeedProvider.RenderingInfo ri=null;
        if (e != null) {
          if (getData().isPassThrough()) {
            for (            FeedProvider fp : providers) {
              if (fp.getSubscriptionId().equals(getData().getPassThroughParameterId())) {
                List<Map<String,String>> values=data.get(getData().getPassThroughParameterId());
                if (values != null && !values.isEmpty()) {
                  ri=fp.getRenderingInfo(values.get(values.size() - 1));
                }
              }
            }
          }
 else {
            ri=e.evaluate(data,providers);
            if (ri == null) {
              ri=new FeedProvider.RenderingInfo(getData().getFallThroughDisplayValue(),Color.red,""String_Node_Str"",Color.red,false);
            }
          }
        }
 else {
          LoggerFactory.getLogger(MultiComponent.class).error(""String_Node_Str"" + getLanguage());
          ri=new FeedProvider.RenderingInfo(""String_Node_Str"",Color.red,""String_Node_Str"",Color.red,false);
        }
        return ri;
      }
    }
;
    return capability.cast(e);
  }
  if (ModelStatePersistence.class.isAssignableFrom(capability)) {
    JAXBModelStatePersistence<MultiModelRole> persistence=new JAXBModelStatePersistence<MultiModelRole>(){
      @Override protected MultiModelRole getStateToPersist(){
        return model.get();
      }
      @Override protected void setPersistentState(      MultiModelRole modelState){
        model.set(modelState);
      }
      @Override protected Class<MultiModelRole> getJAXBClass(){
        return MultiModelRole.class;
      }
    }
;
    return capability.cast(persistence);
  }
  return super.handleGetCapability(capability);
}",0.9147135416666666
185234,"@Override public FeedProvider.RenderingInfo evaluate(Map<String,List<Map<String,String>>> data,List<FeedProvider> providers){
  Executor e=getExecutor();
  FeedProvider.RenderingInfo ri=null;
  if (e != null) {
    if (getData().isPassThrough()) {
      for (      FeedProvider fp : providers) {
        if (fp.getSubscriptionId().startsWith(""String_Node_Str"")) {
          if (fp.getSubscriptionId().substring(4).equals(getData().getPassThroughParameterId())) {
            List<Map<String,String>> values=data.get(""String_Node_Str"" + getData().getPassThroughParameterId());
            if (values != null) {
              ri=fp.getRenderingInfo(values.get(values.size() - 1));
            }
          }
        }
 else {
          if (fp.getSubscriptionId().equals(getData().getPassThroughParameterId())) {
            List<Map<String,String>> values=data.get(getData().getPassThroughParameterId());
            if (values != null) {
              ri=fp.getRenderingInfo(values.get(values.size() - 1));
            }
          }
        }
      }
    }
 else {
      ri=e.evaluate(data,providers);
      if (ri == null) {
        ri=new FeedProvider.RenderingInfo(getData().getFallThroughDisplayValue(),Color.red,""String_Node_Str"",Color.red,false);
      }
    }
  }
 else {
    LoggerFactory.getLogger(MultiComponent.class).error(""String_Node_Str"" + getLanguage());
    ri=new FeedProvider.RenderingInfo(""String_Node_Str"",Color.red,""String_Node_Str"",Color.red,false);
  }
  return ri;
}","@Override public FeedProvider.RenderingInfo evaluate(Map<String,List<Map<String,String>>> data,List<FeedProvider> providers){
  Executor e=getExecutor();
  FeedProvider.RenderingInfo ri=null;
  if (e != null) {
    if (getData().isPassThrough()) {
      for (      FeedProvider fp : providers) {
        if (fp.getSubscriptionId().equals(getData().getPassThroughParameterId())) {
          List<Map<String,String>> values=data.get(getData().getPassThroughParameterId());
          if (values != null && !values.isEmpty()) {
            ri=fp.getRenderingInfo(values.get(values.size() - 1));
          }
        }
      }
    }
 else {
      ri=e.evaluate(data,providers);
      if (ri == null) {
        ri=new FeedProvider.RenderingInfo(getData().getFallThroughDisplayValue(),Color.red,""String_Node_Str"",Color.red,false);
      }
    }
  }
 else {
    LoggerFactory.getLogger(MultiComponent.class).error(""String_Node_Str"" + getLanguage());
    ri=new FeedProvider.RenderingInfo(""String_Node_Str"",Color.red,""String_Node_Str"",Color.red,false);
  }
  return ri;
}",0.3427450980392157
185235,"/** 
 * Create a map of feedID and values
 * @param providers
 * @param data
 * @return
 */
private Map<String,Double> getValuesFromFeed(List<FeedProvider> providers,Map<String,List<Map<String,String>>> data){
  FeedProvider.RenderingInfo result=null;
  Map<String,Double> valuesMap=new ConcurrentHashMap<String,Double>();
  for (  FeedProvider fp : providers) {
    String feedId=fp.getSubscriptionId();
    List<Map<String,String>> values=data.get(feedId);
    if (values != null) {
      result=fp.getRenderingInfo(values.get(values.size() - 1));
      if (result.getValueText() != null) {
        valuesMap.put(feedId,Double.valueOf(result.getValueText()));
        ;
      }
    }
  }
  return valuesMap;
}","/** 
 * Create a map of feedID and values
 * @param providers
 * @param data
 * @return
 */
private Map<String,Double> getValuesFromFeed(List<FeedProvider> providers,Map<String,List<Map<String,String>>> data){
  FeedProvider.RenderingInfo result=null;
  Map<String,Double> valuesMap=new ConcurrentHashMap<String,Double>();
  for (  FeedProvider fp : providers) {
    String feedId=fp.getSubscriptionId();
    List<Map<String,String>> values=data.get(feedId);
    if (values != null && !values.isEmpty()) {
      result=fp.getRenderingInfo(values.get(values.size() - 1));
      if (result.getValueText() != null) {
        valuesMap.put(feedId,Double.valueOf(result.getValueText()));
        ;
      }
    }
  }
  return valuesMap;
}",0.9854469854469856
185236,"/** 
 * Creates a new component based on the collection of source components.
 * @param sourceComponents the collection of components.
 * @return newly created abstract component.
 */
AbstractComponent createNewMulti(Collection<AbstractComponent> sourceComponents){
  MultiCreationServiceImpl e=new MultiCreationServiceImpl();
  AbstractComponent ac=e.createMulti(MultiEvaluator.LANGUAGE_STRING,""String_Node_Str"");
  ((MultiComponent)ac).getData().setFallThroughDisplayValue(""String_Node_Str"");
  if (sourceComponents.size() == 1) {
    ((MultiComponent)ac).getData().setPassThrough(true);
    ((MultiComponent)ac).getData().setPassThroughParameterId(sourceComponents.iterator().next().getExternalKey());
  }
 else {
    ((MultiComponent)ac).getData().setPassThrough(false);
  }
  ac.addDelegateComponents(sourceComponents);
  return ac;
}","/** 
 * Creates a new component based on the collection of source components.
 * @param sourceComponents the collection of components.
 * @return newly created abstract component.
 */
AbstractComponent createNewMulti(Collection<AbstractComponent> sourceComponents){
  MultiCreationServiceImpl e=new MultiCreationServiceImpl();
  AbstractComponent ac=e.createMulti(MultiEvaluator.LANGUAGE_STRING,""String_Node_Str"");
  ((MultiComponent)ac).getData().setFallThroughDisplayValue(""String_Node_Str"");
  if (sourceComponents.size() == 1) {
    ((MultiComponent)ac).getData().setPassThrough(true);
    FeedProvider fp=sourceComponents.iterator().next().getCapability(FeedProvider.class);
    ((MultiComponent)ac).getData().setPassThroughParameterId(fp.getSubscriptionId());
  }
 else {
    ((MultiComponent)ac).getData().setPassThrough(false);
  }
  ac.addDelegateComponents(sourceComponents);
  return ac;
}",0.908568142610696
185237,"private JPanel createCreationPanel(boolean includeRuleTable){
  JPanel creationPanel=new JPanel();
  creationPanel.setLayout(new GridBagLayout());
  creationPanel.setBorder(BorderFactory.createTitledBorder(bundle.getString(""String_Node_Str"")));
  JPanel creationInnerPanel=new JPanel();
  GridBagConstraints innerPanelConstraints=new GridBagConstraints();
  innerPanelConstraints.fill=GridBagConstraints.NONE;
  innerPanelConstraints.anchor=GridBagConstraints.LINE_START;
  innerPanelConstraints.weighty=1;
  innerPanelConstraints.weightx=0;
  innerPanelConstraints.ipadx=1;
  innerPanelConstraints.gridx=0;
  innerPanelConstraints.gridy=1;
  creationPanel.add(creationInnerPanel,innerPanelConstraints);
  JPanel checkBoxPanel=new JPanel(new FlowLayout(FlowLayout.LEFT));
  passThroughCheckBox=new JCheckBox();
  passThroughCheckBox.setName(bundle.getString(""String_Node_Str""));
  if (multiViewManifestation.getTelemetry().size() != 1) {
    passThroughCheckBox.setEnabled(false);
  }
  if (multiViewManifestation.getMulti().getData().isPassThrough()) {
    passThroughCheckBox.setSelected(true);
  }
  passThroughCheckBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      AbstractButton abstractButton=(AbstractButton)e.getSource();
      if (abstractButton.getModel().isSelected()) {
        multiViewManifestation.getMulti().getData().setPassThrough(true);
        multiViewManifestation.getMulti().getData().setPassThroughParameterId(multiViewManifestation.getTelemetry().get(0).getExternalKey());
        addExpButton.setEnabled(false);
        deleteExpButton.setEnabled(false);
        upOneButton.setEnabled(false);
        downOneButton.setEnabled(false);
      }
 else {
        multiViewManifestation.getMulti().getData().setPassThrough(false);
        multiViewManifestation.getMulti().getData().setPassThroughParameterId(null);
        addExpButton.setEnabled(true);
        deleteExpButton.setEnabled(true);
        upOneButton.setEnabled(true);
        downOneButton.setEnabled(true);
      }
      multiViewManifestation.fireFocusPersist();
    }
  }
);
  checkBoxPanel.add(passThroughCheckBox);
  checkBoxPanel.add(new JLabel(bundle.getString(""String_Node_Str"")));
  creationInnerPanel.setLayout(new GridBagLayout());
  addExpButton=new JButton(bundle.getString(""String_Node_Str""));
  deleteExpButton=new JButton(bundle.getString(""String_Node_Str""));
  upOneButton=new JButton(bundle.getString(""String_Node_Str""));
  downOneButton=new JButton(bundle.getString(""String_Node_Str""));
  applyButton=new JButton(bundle.getString(""String_Node_Str""));
  addExpButton.setName(bundle.getString(""String_Node_Str""));
  deleteExpButton.setName(bundle.getString(""String_Node_Str""));
  upOneButton.setName(bundle.getString(""String_Node_Str""));
  downOneButton.setName(bundle.getString(""String_Node_Str""));
  applyButton.setName(bundle.getString(""String_Node_Str""));
  addExpButton.setToolTipText(bundle.getString(""String_Node_Str""));
  deleteExpButton.setToolTipText(bundle.getString(""String_Node_Str""));
  upOneButton.setToolTipText(bundle.getString(""String_Node_Str""));
  downOneButton.setToolTipText(bundle.getString(""String_Node_Str""));
  applyButton.setToolTipText(bundle.getString(""String_Node_Str""));
  addExpButton.setOpaque(false);
  deleteExpButton.setOpaque(false);
  upOneButton.setOpaque(false);
  downOneButton.setOpaque(false);
  applyButton.setOpaque(false);
  addExpButton.setFocusPainted(false);
  deleteExpButton.setFocusPainted(false);
  upOneButton.setFocusPainted(false);
  downOneButton.setFocusPainted(false);
  applyButton.setFocusPainted(false);
  addExpButton.setSize(200,200);
  addExpButton.setContentAreaFilled(true);
  deleteExpButton.setSize(200,200);
  deleteExpButton.setContentAreaFilled(true);
  upOneButton.setSize(200,10);
  upOneButton.setContentAreaFilled(true);
  downOneButton.setSize(200,10);
  downOneButton.setContentAreaFilled(true);
  applyButton.setSize(200,10);
  applyButton.setContentAreaFilled(true);
  applyButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!valueTextField.getText().isEmpty() && !displayTextField.getText().isEmpty() && multiViewManifestation.getSelectedExpression() != null) {
        MultiRuleExpression newExp=new MultiRuleExpression(setLogicStrings.get(ifComboBox.getSelectedItem().toString()),multiViewManifestation.getSelectedExpression().getPUIs().split(MultiRuleExpression.parameterDelimiter,0),bundle.getString(""String_Node_Str"") + parameterComboBox.getSelectedItem().toString(),opComboBox.getSelectedItem().toString(),valueTextField.getText(),displayTextField.getText(),ruleNameTextField.getText());
        controller.notifyRuleUpdated(multiViewManifestation.getExpressions().indexOf(multiViewManifestation.getSelectedExpression()),multiViewManifestation.getExpressions(),newExp);
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        applyButton.setEnabled(false);
        multiViewManifestation.setSelectedExpression(newExp);
      }
    }
  }
);
  applyButton.setEnabled(false);
  addExpButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (listenersEnabled) {
        ruleTablePanel.setVisible(true);
        bottomPanel.setVisible(true);
        String valueText=valueTextField.getText().isEmpty() ? bundle.getString(""String_Node_Str"") : valueTextField.getText();
        String displayText=displayTextField.getText().isEmpty() ? bundle.getString(""String_Node_Str"") : displayTextField.getText();
        MultiRuleExpression newExp=new MultiRuleExpression(setLogicStrings.get(ifComboBox.getSelectedItem().toString()),addDataFeedPrefixes(getTelemetryIDs()),bundle.getString(""String_Node_Str"") + parameterComboBox.getSelectedItem().toString(),opComboBox.getSelectedItem().toString(),valueText,displayText,ruleNameTextField.getText());
        controller.notifyExpressionAdded(newExp,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(newExp);
        loadRuleButtonSettings();
      }
    }
  }
);
  deleteExpButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyExpressionDeleted(selectedExpression,multiViewManifestation.getExpressions());
        if (multiViewManifestation.getExpressions().size() == 0) {
          ruleTablePanel.setVisible(false);
          bottomPanel.setVisible(false);
        }
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        loadRuleButtonSettings();
      }
    }
  }
);
  upOneButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyMovedUpOne(selectedExpression,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(selectedExpression);
      }
    }
  }
);
  downOneButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyMovedDownOne(selectedExpression,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(selectedExpression);
      }
    }
  }
);
  ruleResultTextField=new JTextField();
  ruleResultTextField.setEditable(false);
  ruleResultTextField.setBackground(Color.WHITE);
  ruleResultTextField.setPreferredSize(new Dimension(100,20));
  GridBagConstraints addExpButtonConstraints=new GridBagConstraints();
  addExpButtonConstraints.fill=GridBagConstraints.NONE;
  addExpButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addExpButtonConstraints.weighty=1;
  addExpButtonConstraints.weightx=0;
  addExpButtonConstraints.ipadx=1;
  addExpButtonConstraints.gridx=0;
  addExpButtonConstraints.gridy=0;
  creationInnerPanel.add(addExpButton,addExpButtonConstraints);
  GridBagConstraints deleteExpButtonConstraints=new GridBagConstraints();
  deleteExpButtonConstraints.fill=GridBagConstraints.NONE;
  deleteExpButtonConstraints.anchor=GridBagConstraints.LINE_START;
  deleteExpButtonConstraints.weighty=1;
  deleteExpButtonConstraints.weightx=0;
  deleteExpButtonConstraints.ipadx=1;
  deleteExpButtonConstraints.gridx=1;
  deleteExpButtonConstraints.gridy=0;
  creationInnerPanel.add(deleteExpButton,deleteExpButtonConstraints);
  GridBagConstraints addAboveButtonConstraints=new GridBagConstraints();
  addAboveButtonConstraints.fill=GridBagConstraints.NONE;
  addAboveButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addAboveButtonConstraints.weighty=1;
  addAboveButtonConstraints.weightx=0;
  addAboveButtonConstraints.ipadx=1;
  addAboveButtonConstraints.gridx=2;
  addAboveButtonConstraints.gridy=0;
  creationInnerPanel.add(upOneButton,addAboveButtonConstraints);
  GridBagConstraints addBelowButtonConstraints=new GridBagConstraints();
  addBelowButtonConstraints.fill=GridBagConstraints.NONE;
  addBelowButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addBelowButtonConstraints.weighty=1;
  addBelowButtonConstraints.weightx=1;
  addBelowButtonConstraints.ipadx=1;
  addBelowButtonConstraints.gridx=3;
  addBelowButtonConstraints.gridy=0;
  creationInnerPanel.add(downOneButton,addBelowButtonConstraints);
  GridBagConstraints checkBoxPanelConstraints=new GridBagConstraints();
  checkBoxPanelConstraints.fill=GridBagConstraints.NONE;
  checkBoxPanelConstraints.anchor=GridBagConstraints.LINE_START;
  checkBoxPanelConstraints.weighty=1;
  checkBoxPanelConstraints.weightx=1;
  checkBoxPanelConstraints.ipadx=1;
  checkBoxPanelConstraints.gridx=5;
  checkBoxPanelConstraints.gridy=0;
  creationInnerPanel.add(checkBoxPanel,checkBoxPanelConstraints);
  if (includeRuleTable) {
    GridBagConstraints rulePanelConstraints=new GridBagConstraints();
    rulePanelConstraints.fill=GridBagConstraints.NONE;
    rulePanelConstraints.anchor=GridBagConstraints.LINE_START;
    rulePanelConstraints.weighty=1;
    rulePanelConstraints.weightx=1;
    rulePanelConstraints.ipadx=1;
    rulePanelConstraints.gridx=0;
    rulePanelConstraints.gridy=2;
    creationPanel.add(createRuleTablePanel(),rulePanelConstraints);
    bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
    bottomPanel.add(new JLabel(bundle.getString(""String_Node_Str"")));
    bottomPanel.add(ruleResultTextField);
    bottomPanel.add(applyButton);
    bottomPanel.setPreferredSize(new Dimension((int)ruleTablePanel.getPreferredSize().getWidth(),50));
    GridBagConstraints rulePanelConstraints2=new GridBagConstraints();
    rulePanelConstraints2.fill=GridBagConstraints.NONE;
    rulePanelConstraints2.anchor=GridBagConstraints.LINE_START;
    rulePanelConstraints2.weighty=1;
    rulePanelConstraints2.weightx=1;
    rulePanelConstraints2.ipadx=1;
    rulePanelConstraints2.gridx=0;
    rulePanelConstraints2.gridy=3;
    creationPanel.add(bottomPanel,rulePanelConstraints2);
  }
  return creationPanel;
}","private JPanel createCreationPanel(boolean includeRuleTable){
  JPanel creationPanel=new JPanel();
  creationPanel.setLayout(new GridBagLayout());
  creationPanel.setBorder(BorderFactory.createTitledBorder(bundle.getString(""String_Node_Str"")));
  JPanel creationInnerPanel=new JPanel();
  GridBagConstraints innerPanelConstraints=new GridBagConstraints();
  innerPanelConstraints.fill=GridBagConstraints.NONE;
  innerPanelConstraints.anchor=GridBagConstraints.LINE_START;
  innerPanelConstraints.weighty=1;
  innerPanelConstraints.weightx=0;
  innerPanelConstraints.ipadx=1;
  innerPanelConstraints.gridx=0;
  innerPanelConstraints.gridy=1;
  creationPanel.add(creationInnerPanel,innerPanelConstraints);
  JPanel checkBoxPanel=new JPanel(new FlowLayout(FlowLayout.LEFT));
  passThroughCheckBox=new JCheckBox();
  passThroughCheckBox.setName(bundle.getString(""String_Node_Str""));
  if (multiViewManifestation.getTelemetry().size() != 1) {
    passThroughCheckBox.setEnabled(false);
  }
  if (multiViewManifestation.getMulti().getData().isPassThrough()) {
    passThroughCheckBox.setSelected(true);
  }
  passThroughCheckBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      AbstractButton abstractButton=(AbstractButton)e.getSource();
      if (abstractButton.getModel().isSelected()) {
        multiViewManifestation.getMulti().getData().setPassThrough(true);
        multiViewManifestation.getMulti().getData().setPassThroughParameterId(multiViewManifestation.getTelemetry().get(0).getCapability(FeedProvider.class).getSubscriptionId());
        addExpButton.setEnabled(false);
        deleteExpButton.setEnabled(false);
        upOneButton.setEnabled(false);
        downOneButton.setEnabled(false);
      }
 else {
        multiViewManifestation.getMulti().getData().setPassThrough(false);
        multiViewManifestation.getMulti().getData().setPassThroughParameterId(null);
        addExpButton.setEnabled(true);
        deleteExpButton.setEnabled(true);
        upOneButton.setEnabled(true);
        downOneButton.setEnabled(true);
      }
      multiViewManifestation.fireFocusPersist();
    }
  }
);
  checkBoxPanel.add(passThroughCheckBox);
  checkBoxPanel.add(new JLabel(bundle.getString(""String_Node_Str"")));
  creationInnerPanel.setLayout(new GridBagLayout());
  addExpButton=new JButton(bundle.getString(""String_Node_Str""));
  deleteExpButton=new JButton(bundle.getString(""String_Node_Str""));
  upOneButton=new JButton(bundle.getString(""String_Node_Str""));
  downOneButton=new JButton(bundle.getString(""String_Node_Str""));
  applyButton=new JButton(bundle.getString(""String_Node_Str""));
  addExpButton.setName(bundle.getString(""String_Node_Str""));
  deleteExpButton.setName(bundle.getString(""String_Node_Str""));
  upOneButton.setName(bundle.getString(""String_Node_Str""));
  downOneButton.setName(bundle.getString(""String_Node_Str""));
  applyButton.setName(bundle.getString(""String_Node_Str""));
  addExpButton.setToolTipText(bundle.getString(""String_Node_Str""));
  deleteExpButton.setToolTipText(bundle.getString(""String_Node_Str""));
  upOneButton.setToolTipText(bundle.getString(""String_Node_Str""));
  downOneButton.setToolTipText(bundle.getString(""String_Node_Str""));
  applyButton.setToolTipText(bundle.getString(""String_Node_Str""));
  addExpButton.setOpaque(false);
  deleteExpButton.setOpaque(false);
  upOneButton.setOpaque(false);
  downOneButton.setOpaque(false);
  applyButton.setOpaque(false);
  addExpButton.setFocusPainted(false);
  deleteExpButton.setFocusPainted(false);
  upOneButton.setFocusPainted(false);
  downOneButton.setFocusPainted(false);
  applyButton.setFocusPainted(false);
  addExpButton.setSize(200,200);
  addExpButton.setContentAreaFilled(true);
  deleteExpButton.setSize(200,200);
  deleteExpButton.setContentAreaFilled(true);
  upOneButton.setSize(200,10);
  upOneButton.setContentAreaFilled(true);
  downOneButton.setSize(200,10);
  downOneButton.setContentAreaFilled(true);
  applyButton.setSize(200,10);
  applyButton.setContentAreaFilled(true);
  applyButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!valueTextField.getText().isEmpty() && !displayTextField.getText().isEmpty() && multiViewManifestation.getSelectedExpression() != null) {
        MultiRuleExpression newExp=new MultiRuleExpression(setLogicStrings.get(ifComboBox.getSelectedItem().toString()),multiViewManifestation.getSelectedExpression().getPUIs().split(MultiRuleExpression.parameterDelimiter,0),bundle.getString(""String_Node_Str"") + parameterComboBox.getSelectedItem().toString(),opComboBox.getSelectedItem().toString(),valueTextField.getText(),displayTextField.getText(),ruleNameTextField.getText());
        controller.notifyRuleUpdated(multiViewManifestation.getExpressions().indexOf(multiViewManifestation.getSelectedExpression()),multiViewManifestation.getExpressions(),newExp);
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        applyButton.setEnabled(false);
        multiViewManifestation.setSelectedExpression(newExp);
      }
    }
  }
);
  applyButton.setEnabled(false);
  addExpButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (listenersEnabled) {
        ruleTablePanel.setVisible(true);
        bottomPanel.setVisible(true);
        String valueText=valueTextField.getText().isEmpty() ? bundle.getString(""String_Node_Str"") : valueTextField.getText();
        String displayText=displayTextField.getText().isEmpty() ? bundle.getString(""String_Node_Str"") : displayTextField.getText();
        MultiRuleExpression newExp=new MultiRuleExpression(setLogicStrings.get(ifComboBox.getSelectedItem().toString()),addDataFeedPrefixes(getTelemetryIDs()),bundle.getString(""String_Node_Str"") + parameterComboBox.getSelectedItem().toString(),opComboBox.getSelectedItem().toString(),valueText,displayText,ruleNameTextField.getText());
        controller.notifyExpressionAdded(newExp,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(newExp);
        loadRuleButtonSettings();
      }
    }
  }
);
  deleteExpButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyExpressionDeleted(selectedExpression,multiViewManifestation.getExpressions());
        if (multiViewManifestation.getExpressions().size() == 0) {
          ruleTablePanel.setVisible(false);
          bottomPanel.setVisible(false);
        }
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        loadRuleButtonSettings();
      }
    }
  }
);
  upOneButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyMovedUpOne(selectedExpression,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(selectedExpression);
      }
    }
  }
);
  downOneButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MultiRuleExpression selectedExpression=multiViewManifestation.getSelectedExpression();
      if (listenersEnabled) {
        controller.notifyMovedDownOne(selectedExpression,multiViewManifestation.getExpressions());
        multiViewManifestation.getMulti().getData().setCode(multiViewManifestation.getExpressions().toString());
        multiViewManifestation.fireFocusPersist();
        multiViewManifestation.setSelectedExpression(selectedExpression);
      }
    }
  }
);
  ruleResultTextField=new JTextField();
  ruleResultTextField.setEditable(false);
  ruleResultTextField.setBackground(Color.WHITE);
  ruleResultTextField.setPreferredSize(new Dimension(100,20));
  GridBagConstraints addExpButtonConstraints=new GridBagConstraints();
  addExpButtonConstraints.fill=GridBagConstraints.NONE;
  addExpButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addExpButtonConstraints.weighty=1;
  addExpButtonConstraints.weightx=0;
  addExpButtonConstraints.ipadx=1;
  addExpButtonConstraints.gridx=0;
  addExpButtonConstraints.gridy=0;
  creationInnerPanel.add(addExpButton,addExpButtonConstraints);
  GridBagConstraints deleteExpButtonConstraints=new GridBagConstraints();
  deleteExpButtonConstraints.fill=GridBagConstraints.NONE;
  deleteExpButtonConstraints.anchor=GridBagConstraints.LINE_START;
  deleteExpButtonConstraints.weighty=1;
  deleteExpButtonConstraints.weightx=0;
  deleteExpButtonConstraints.ipadx=1;
  deleteExpButtonConstraints.gridx=1;
  deleteExpButtonConstraints.gridy=0;
  creationInnerPanel.add(deleteExpButton,deleteExpButtonConstraints);
  GridBagConstraints addAboveButtonConstraints=new GridBagConstraints();
  addAboveButtonConstraints.fill=GridBagConstraints.NONE;
  addAboveButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addAboveButtonConstraints.weighty=1;
  addAboveButtonConstraints.weightx=0;
  addAboveButtonConstraints.ipadx=1;
  addAboveButtonConstraints.gridx=2;
  addAboveButtonConstraints.gridy=0;
  creationInnerPanel.add(upOneButton,addAboveButtonConstraints);
  GridBagConstraints addBelowButtonConstraints=new GridBagConstraints();
  addBelowButtonConstraints.fill=GridBagConstraints.NONE;
  addBelowButtonConstraints.anchor=GridBagConstraints.LINE_START;
  addBelowButtonConstraints.weighty=1;
  addBelowButtonConstraints.weightx=1;
  addBelowButtonConstraints.ipadx=1;
  addBelowButtonConstraints.gridx=3;
  addBelowButtonConstraints.gridy=0;
  creationInnerPanel.add(downOneButton,addBelowButtonConstraints);
  GridBagConstraints checkBoxPanelConstraints=new GridBagConstraints();
  checkBoxPanelConstraints.fill=GridBagConstraints.NONE;
  checkBoxPanelConstraints.anchor=GridBagConstraints.LINE_START;
  checkBoxPanelConstraints.weighty=1;
  checkBoxPanelConstraints.weightx=1;
  checkBoxPanelConstraints.ipadx=1;
  checkBoxPanelConstraints.gridx=5;
  checkBoxPanelConstraints.gridy=0;
  creationInnerPanel.add(checkBoxPanel,checkBoxPanelConstraints);
  if (includeRuleTable) {
    GridBagConstraints rulePanelConstraints=new GridBagConstraints();
    rulePanelConstraints.fill=GridBagConstraints.NONE;
    rulePanelConstraints.anchor=GridBagConstraints.LINE_START;
    rulePanelConstraints.weighty=1;
    rulePanelConstraints.weightx=1;
    rulePanelConstraints.ipadx=1;
    rulePanelConstraints.gridx=0;
    rulePanelConstraints.gridy=2;
    creationPanel.add(createRuleTablePanel(),rulePanelConstraints);
    bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
    bottomPanel.add(new JLabel(bundle.getString(""String_Node_Str"")));
    bottomPanel.add(ruleResultTextField);
    bottomPanel.add(applyButton);
    bottomPanel.setPreferredSize(new Dimension((int)ruleTablePanel.getPreferredSize().getWidth(),50));
    GridBagConstraints rulePanelConstraints2=new GridBagConstraints();
    rulePanelConstraints2.fill=GridBagConstraints.NONE;
    rulePanelConstraints2.anchor=GridBagConstraints.LINE_START;
    rulePanelConstraints2.weighty=1;
    rulePanelConstraints2.weightx=1;
    rulePanelConstraints2.ipadx=1;
    rulePanelConstraints2.gridx=0;
    rulePanelConstraints2.gridy=3;
    creationPanel.add(bottomPanel,rulePanelConstraints2);
  }
  return creationPanel;
}",0.9976264834478452
185238,"@Override public void updateFromFeed(Map<String,List<Map<String,String>>> data){
  if (data != null) {
    Collection<FeedProvider> feeds=getVisibleFeedProviders();
    Map<String,Double> valuesMap=new ConcurrentHashMap<String,Double>();
    for (    FeedProvider provider : feeds) {
      String feedId=provider.getSubscriptionId();
      List<Map<String,String>> dataForThisFeed=data.get(feedId);
      if (dataForThisFeed != null && !dataForThisFeed.isEmpty()) {
        Map<String,String> entry=dataForThisFeed.get(dataForThisFeed.size() - 1);
        try {
          Object value=entry.get(FeedProvider.NORMALIZED_VALUE_KEY);
          RenderingInfo ri=provider.getRenderingInfo(entry);
          value=ri.getValueText();
          valuesMap.put(feedId,Double.valueOf(ri.getValueText()));
          ;
          for (          AbstractComponent parameter : telemetryElements) {
            if (feedId.startsWith(""String_Node_Str"")) {
              if (feedId.substring(4).equals(parameter.getExternalKey())) {
                telemetryTable.getModel().setValueAt(value,telemetryElements.indexOf(parameter),2);
              }
            }
 else {
              if (feedId.equals(parameter.getExternalKey())) {
                telemetryTable.getModel().setValueAt(value,telemetryElements.indexOf(parameter),2);
              }
            }
          }
        }
 catch (        ClassCastException ex) {
          logger.error(""String_Node_Str"",ex);
        }
catch (        NumberFormatException ex) {
          logger.error(""String_Node_Str"",ex);
        }
      }
    }
    FeedProvider.RenderingInfo multiValueInfo=getMulti().getCapability(Evaluator.class).evaluate(data,getFeedProviders(getMulti()));
    if (multiValueInfo != null) {
      resultOutput.setText(multiValueInfo.getValueText() + multiValueInfo.getStatusText());
      resultOutput.setForeground(multiValueInfo.getValueColor());
    }
 else {
      resultOutput.setText(""String_Node_Str"");
    }
    if (getSelectedExpression() != null) {
      MultiExpression expression=new MultiExpression(Enum.valueOf(SetLogic.class,getSelectedExpression().getMultiSetLogic().name()),getSelectedExpression().getPUIs().split(MultiRuleExpression.parameterDelimiter,0),getSelectedExpression().getSinglePui(),getSelectedExpression().getOperator(),getSelectedExpression().getVal().toString(),getSelectedExpression().getDisplay());
      String ruleResult=expression.execute(valuesMap);
      if (ruleResult != null) {
        controlPanel.setRuleResultField(ruleResult);
      }
 else {
        controlPanel.setRuleResultField(""String_Node_Str"");
      }
    }
  }
}","@Override public void updateFromFeed(Map<String,List<Map<String,String>>> data){
  if (data != null) {
    Collection<FeedProvider> feeds=getVisibleFeedProviders();
    Map<String,Double> valuesMap=new HashMap<String,Double>();
    for (    FeedProvider provider : feeds) {
      String feedId=provider.getSubscriptionId();
      List<Map<String,String>> dataForThisFeed=data.get(feedId);
      if (dataForThisFeed != null && !dataForThisFeed.isEmpty()) {
        Map<String,String> entry=dataForThisFeed.get(dataForThisFeed.size() - 1);
        try {
          RenderingInfo ri=provider.getRenderingInfo(entry);
          Object value=ri.getValueText();
          valuesMap.put(feedId,Double.valueOf(ri.getValueText()));
          ;
          for (          AbstractComponent parameter : telemetryElements) {
            FeedProvider fp=parameter.getCapability(FeedProvider.class);
            if (fp != null && feedId.equals(fp.getSubscriptionId())) {
              telemetryTable.getModel().setValueAt(value,telemetryElements.indexOf(parameter),2);
            }
          }
        }
 catch (        ClassCastException ex) {
          logger.error(""String_Node_Str"",ex);
        }
catch (        NumberFormatException ex) {
          logger.error(""String_Node_Str"",ex);
        }
      }
    }
    FeedProvider.RenderingInfo multiValueInfo=getMulti().getCapability(Evaluator.class).evaluate(data,getFeedProviders(getMulti()));
    if (multiValueInfo != null) {
      resultOutput.setText(multiValueInfo.getValueText() + multiValueInfo.getStatusText());
      resultOutput.setForeground(multiValueInfo.getValueColor());
    }
 else {
      resultOutput.setText(""String_Node_Str"");
    }
    if (getSelectedExpression() != null) {
      MultiExpression expression=new MultiExpression(Enum.valueOf(SetLogic.class,getSelectedExpression().getMultiSetLogic().name()),getSelectedExpression().getPUIs().split(MultiRuleExpression.parameterDelimiter,0),getSelectedExpression().getSinglePui(),getSelectedExpression().getOperator(),getSelectedExpression().getVal().toString(),getSelectedExpression().getDisplay());
      String ruleResult=expression.execute(valuesMap);
      if (ruleResult != null) {
        controlPanel.setRuleResultField(ruleResult);
      }
 else {
        controlPanel.setRuleResultField(""String_Node_Str"");
      }
    }
  }
}",0.8708442474309893
185239,"@BeforeMethod public void setUp(){
  MockitoAnnotations.initMocks(this);
  robot=BasicRobot.robotWithCurrentAwtHierarchy();
  tList=new ArrayList<AbstractComponent>();
  tList.add(ac);
  Mockito.when(mockExpManifestation.getExpressions()).thenReturn(ruleList);
  Mockito.when(ruleList.size()).thenReturn(2);
  Mockito.when(mockExpManifestation.getMulti()).thenReturn(mc);
  Mockito.when(mc.getData()).thenReturn(multiData);
  Mockito.when(ac.getExternalKey()).thenReturn(""String_Node_Str"");
  Mockito.when(multiData.isPassThrough()).thenReturn(false);
  Mockito.when(mc.getComponents()).thenReturn(Collections.<AbstractComponent>emptyList());
  Mockito.when(mockExpManifestation.getSelectedTelemetry()).thenReturn(ac);
  Mockito.when(mockExpManifestation.getTelemetry()).thenReturn(tList);
  GuiActionRunner.execute(new GuiTask(){
    @Override protected void executeInEDT() throws Throwable {
      controlPanel=new MultiExpressionsFormattingControlsPanel(mockExpManifestation);
      JFrame frame=new JFrame(TITLE);
      frame.setPreferredSize(new Dimension(950,600));
      frame.setName(TITLE);
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      controlPanel.setOpaque(true);
      frame.setContentPane(controlPanel);
      frame.pack();
      frame.setVisible(true);
    }
  }
);
}","@BeforeMethod public void setUp(){
  MockitoAnnotations.initMocks(this);
  robot=BasicRobot.robotWithCurrentAwtHierarchy();
  tList=new ArrayList<AbstractComponent>();
  tList.add(ac);
  FeedProvider mockfp=Mockito.mock(FeedProvider.class);
  Mockito.when(mockExpManifestation.getExpressions()).thenReturn(ruleList);
  Mockito.when(ruleList.size()).thenReturn(2);
  Mockito.when(mockExpManifestation.getMulti()).thenReturn(mc);
  Mockito.when(mc.getData()).thenReturn(multiData);
  Mockito.when(ac.getExternalKey()).thenReturn(""String_Node_Str"");
  Mockito.when(ac.getCapability(FeedProvider.class)).thenReturn(mockfp);
  Mockito.when(mockfp.getSubscriptionId()).thenReturn(""String_Node_Str"");
  Mockito.when(multiData.isPassThrough()).thenReturn(false);
  Mockito.when(mc.getComponents()).thenReturn(Collections.<AbstractComponent>emptyList());
  Mockito.when(mockExpManifestation.getSelectedTelemetry()).thenReturn(ac);
  Mockito.when(mockExpManifestation.getTelemetry()).thenReturn(tList);
  GuiActionRunner.execute(new GuiTask(){
    @Override protected void executeInEDT() throws Throwable {
      controlPanel=new MultiExpressionsFormattingControlsPanel(mockExpManifestation);
      JFrame frame=new JFrame(TITLE);
      frame.setPreferredSize(new Dimension(950,600));
      frame.setName(TITLE);
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      controlPanel.setOpaque(true);
      frame.setContentPane(controlPanel);
      frame.pack();
      frame.setVisible(true);
    }
  }
);
}",0.9276807980049876
185240,"@Override protected ThriftMessage decode(ChannelHandlerContext ctx,Channel channel,ChannelBuffer buffer) throws Exception {
  if (!buffer.readable()) {
    return null;
  }
  short firstByte=buffer.getUnsignedByte(0);
  if (firstByte >= 0x80) {
    return new ThriftMessage(tryDecodeUnframedMessage(ctx,channel,buffer,inputProtocolFactory),ThriftTransportType.UNFRAMED);
  }
 else   if (buffer.readableBytes() < MESSAGE_FRAME_SIZE) {
    return null;
  }
 else {
    return new ThriftMessage(tryDecodeFramedMessage(ctx,channel,buffer,true),ThriftTransportType.FRAMED);
  }
}","@Override protected ThriftMessage decode(ChannelHandlerContext ctx,Channel channel,ChannelBuffer buffer) throws Exception {
  if (!buffer.readable()) {
    return null;
  }
  short firstByte=buffer.getUnsignedByte(0);
  if (firstByte >= 0x80) {
    ChannelBuffer messageBuffer=tryDecodeUnframedMessage(ctx,channel,buffer,inputProtocolFactory);
    if (messageBuffer == null) {
      return null;
    }
    return new ThriftMessage(messageBuffer,ThriftTransportType.UNFRAMED);
  }
 else   if (buffer.readableBytes() < MESSAGE_FRAME_SIZE) {
    return null;
  }
 else {
    ChannelBuffer messageBuffer=tryDecodeFramedMessage(ctx,channel,buffer,true);
    if (messageBuffer == null) {
      return null;
    }
    return new ThriftMessage(messageBuffer,ThriftTransportType.FRAMED);
  }
}",0.6863033873343152
185241,"public HttpClientConnector(URI uri){
  super(HostAndPort.fromParts(checkNotNull(uri).getHost(),checkNotNull(uri).getPort()));
  checkArgument(uri.isAbsolute() && !uri.isOpaque(),""String_Node_Str"");
  checkArgument(uri.getScheme().compareTo(""String_Node_Str"") != 0 && uri.getScheme().compareTo(""String_Node_Str"") != 0,""String_Node_Str"");
  this.endpointUri=uri;
}","public HttpClientConnector(URI uri){
  super(HostAndPort.fromParts(checkNotNull(uri).getHost(),getPort(uri)));
  checkArgument(uri.isAbsolute() && !uri.isOpaque(),""String_Node_Str"");
  this.endpointUri=uri;
}",0.6596491228070176
185242,"public static void main(String[] args) throws Exception {
  final NiftyBootstrap bootstrap=Guice.createInjector(Stage.PRODUCTION,new NiftyModule(){
    @Override protected void configureNifty(){
      bind().toInstance(new ThriftServerDefBuilder().listen(8080).withProcessor(new scribe.Processor(new scribe.Iface(){
        @Override public ResultCode Log(        List<LogEntry> messages) throws TException {
          for (          LogEntry message : messages) {
            log.info(""String_Node_Str"",message.getCategory(),message.getMessage());
          }
          return ResultCode.OK;
        }
      }
)).build());
    }
  }
.withNettyConfig(NettyConfigProvider.class)).getInstance(NiftyBootstrap.class);
  bootstrap.start();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      bootstrap.stop();
    }
  }
);
}","public static void main(String[] args) throws Exception {
  final NiftyBootstrap bootstrap=Guice.createInjector(Stage.PRODUCTION,new NiftyModule(){
    @Override protected void configureNifty(){
      bind().toInstance(new ThriftServerDefBuilder().listen(8080).withProcessor(new scribe.Processor<scribe.Iface>(new scribe.Iface(){
        @Override public ResultCode Log(        List<LogEntry> messages) throws TException {
          for (          LogEntry message : messages) {
            log.info(""String_Node_Str"",message.getCategory(),message.getMessage());
          }
          return ResultCode.OK;
        }
      }
)).build());
      withNettyConfig(NettyConfigProvider.class);
    }
  }
).getInstance(NiftyBootstrap.class);
  bootstrap.start();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      bootstrap.stop();
    }
  }
);
}",0.9798734905117884
185243,"@Override protected void configureNifty(){
  bind().toInstance(new ThriftServerDefBuilder().listen(8080).withProcessor(new scribe.Processor(new scribe.Iface(){
    @Override public ResultCode Log(    List<LogEntry> messages) throws TException {
      for (      LogEntry message : messages) {
        log.info(""String_Node_Str"",message.getCategory(),message.getMessage());
      }
      return ResultCode.OK;
    }
  }
)).build());
}","@Override protected void configureNifty(){
  bind().toInstance(new ThriftServerDefBuilder().listen(8080).withProcessor(new scribe.Processor<scribe.Iface>(new scribe.Iface(){
    @Override public ResultCode Log(    List<LogEntry> messages) throws TException {
      for (      LogEntry message : messages) {
        log.info(""String_Node_Str"",message.getCategory(),message.getMessage());
      }
      return ResultCode.OK;
    }
  }
)).build());
  withNettyConfig(NettyConfigProvider.class);
}",0.9352051835853132
185244,"public static void main(String[] args) throws Exception {
  ConfigurationFactory cf=new ConfigurationFactory(new ConfigurationLoader().loadProperties());
  AbstractModule exampleModule=new AbstractModule(){
    @Override public void configure(){
      ConfigurationModule.bindConfig(binder()).to(ExampleConfig.class);
      binder().bind(NiftyBootstrap.class).in(Singleton.class);
    }
  }
;
  Guice.createInjector(Stage.PRODUCTION,new ConfigurationModule(cf),new ValidationErrorModule(new ConfigurationValidator(cf,null).validate(exampleModule)),new LifeCycleModule(),exampleModule,new NiftyModule(){
    @Override protected void configureNifty(){
      bind().toProvider(ExampleThriftServerProvider.class);
    }
  }
.withDefaultNettyConfig()).getInstance(LifeCycleManager.class).start();
}","public static void main(String[] args) throws Exception {
  ConfigurationFactory cf=new ConfigurationFactory(new ConfigurationLoader().loadProperties());
  AbstractModule exampleModule=new AbstractModule(){
    @Override public void configure(){
      ConfigurationModule.bindConfig(binder()).to(ExampleConfig.class);
      binder().bind(NiftyBootstrap.class).in(Singleton.class);
    }
  }
;
  Guice.createInjector(Stage.PRODUCTION,new ConfigurationModule(cf),new ValidationErrorModule(new ConfigurationValidator(cf,null).validate(exampleModule)),new LifeCycleModule(),exampleModule,new NiftyModule(){
    @Override protected void configureNifty(){
      bind().toProvider(ExampleThriftServerProvider.class);
      withDefaultNettyConfig();
    }
  }
).getInstance(LifeCycleManager.class).start();
}",0.9868173258003766
185245,"@Override protected void configureNifty(){
  bind().toProvider(ExampleThriftServerProvider.class);
}","@Override protected void configureNifty(){
  bind().toProvider(ExampleThriftServerProvider.class);
  withDefaultNettyConfig();
}",0.8771929824561403
185246,"public ThriftTypeReference getCollectionElementThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    deferredTypesWorkList.get().add(javaType);
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}","public ThriftTypeReference getCollectionElementThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}",0.9196581196581196
185247,"public ThriftTypeReference getMapKeyThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    deferredTypesWorkList.get().add(javaType);
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}","public ThriftTypeReference getMapKeyThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}",0.91651865008881
185248,"public ThriftTypeReference getMapValueThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    deferredTypesWorkList.get().add(javaType);
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}","public ThriftTypeReference getMapValueThriftTypeReference(Type javaType){
  if (isStructType(javaType)) {
    return getThriftTypeReference(javaType,Recursiveness.FORCED);
  }
 else {
    return getThriftTypeReference(javaType,Recursiveness.NOT_ALLOWED);
  }
}",0.9171075837742504
185249,"private ThriftType buildThriftType(Type javaType){
  ThriftType thriftType=buildThriftTypeInternal(javaType);
  typeCache.putIfAbsent(javaType,thriftType);
  if (stack.get().isEmpty()) {
    Deque<Type> unresolvedJavaTypes=deferredTypesWorkList.get();
    do {
      if (unresolvedJavaTypes.isEmpty()) {
        break;
      }
      Type unresolvedJavaType=unresolvedJavaTypes.pop();
      if (!typeCache.containsKey(unresolvedJavaType)) {
        ThriftType resolvedThriftType=buildThriftTypeInternal(deferredTypesWorkList.get().pop());
        typeCache.putIfAbsent(unresolvedJavaType,resolvedThriftType);
      }
    }
 while (true);
  }
  return thriftType;
}","private ThriftType buildThriftType(Type javaType){
  ThriftType thriftType=buildThriftTypeInternal(javaType);
  typeCache.putIfAbsent(javaType,thriftType);
  if (stack.get().isEmpty()) {
    Deque<Type> unresolvedJavaTypes=deferredTypesWorkList.get();
    do {
      if (unresolvedJavaTypes.isEmpty()) {
        break;
      }
      Type unresolvedJavaType=unresolvedJavaTypes.pop();
      if (!typeCache.containsKey(unresolvedJavaType)) {
        ThriftType resolvedThriftType=buildThriftTypeInternal(unresolvedJavaType);
        typeCache.putIfAbsent(unresolvedJavaType,resolvedThriftType);
      }
    }
 while (true);
  }
  return thriftType;
}",0.9610983981693364
185250,"private <T>SuccessAndResult<T> topologicalSort(List<T> list,Predicate<T> isKnown){
  List<T> remaining=list;
  List<T> newList=Lists.newArrayList();
  int prevSize=0;
  while (prevSize != remaining.size()) {
    prevSize=remaining.size();
    List<T> bad=Lists.newArrayList();
    for (    T t : remaining) {
      if (isKnown.apply(t)) {
        newList.add(t);
      }
 else {
        bad.add(t);
      }
    }
    remaining=bad;
  }
  if (prevSize == 0) {
    return new SuccessAndResult(true,newList);
  }
 else {
    return new SuccessAndResult(false,remaining);
  }
}","private <T>SuccessAndResult<T> topologicalSort(List<T> list,Predicate<T> isKnown){
  List<T> remaining=list;
  List<T> newList=Lists.newArrayList();
  int prevSize=0;
  while (prevSize != remaining.size()) {
    prevSize=remaining.size();
    List<T> bad=Lists.newArrayList();
    for (    T t : remaining) {
      if (isKnown.apply(t)) {
        newList.add(t);
      }
 else {
        bad.add(t);
      }
    }
    remaining=bad;
  }
  if (prevSize == 0) {
    return new SuccessAndResult<>(true,newList);
  }
 else {
    return new SuccessAndResult<>(false,remaining);
  }
}",0.9965217391304348
185251,"private boolean verifyTypes(){
  SuccessAndResult<ThriftType> output=topologicalSort(thriftTypes,new Predicate<ThriftType>(){
    @Override public boolean apply(    @Nullable ThriftType t){
      ThriftProtocolType proto=t.getProtocolType();
      if (proto == ThriftProtocolType.ENUM) {
        knownTypes.add(t);
        return true;
      }
 else       if (proto == ThriftProtocolType.STRUCT) {
        return verifyStruct(t,true);
      }
 else {
        Preconditions.checkState(false,""String_Node_Str"");
        return false;
      }
    }
  }
);
  if (output.success) {
    thriftTypes=output.result;
    return true;
  }
 else {
    for (    ThriftType t : output.result) {
      verifyStruct(t,false);
    }
    return false;
  }
}","private boolean verifyTypes(){
  SuccessAndResult<ThriftType> output=topologicalSort(thriftTypes,new Predicate<ThriftType>(){
    @Override public boolean apply(    @Nullable ThriftType t){
      ThriftProtocolType proto=checkNotNull(t).getProtocolType();
      if (proto == ThriftProtocolType.ENUM) {
        knownTypes.add(t);
        return true;
      }
 else       if (proto == ThriftProtocolType.STRUCT) {
        return verifyStruct(t,true);
      }
 else {
        Preconditions.checkState(false,""String_Node_Str"");
        return false;
      }
    }
  }
);
  if (output.success) {
    thriftTypes=output.result;
    return true;
  }
 else {
    for (    ThriftType t : output.result) {
      verifyStruct(t,false);
    }
    return false;
  }
}",0.9892904953145916
185252,"private boolean verifyStruct(ThriftType t,boolean quiet){
  ThriftStructMetadata<?> metadata=t.getStructMetadata();
  boolean ok=true;
  for (  ThriftFieldMetadata fieldMetadata : metadata.getFields(FieldType.THRIFT_FIELD)) {
    boolean fieldOk=verifyField(fieldMetadata.getThriftType());
    if (!fieldOk) {
      ok=false;
      if (!quiet) {
        LOG.error(""String_Node_Str"",thriftTypeRenderer.toString(fieldMetadata.getThriftType()),metadata.getStructName(),fieldMetadata.getName());
      }
    }
  }
  knownTypes.add(t);
  return ok;
}","private boolean verifyStruct(ThriftType t,boolean quiet){
  ThriftStructMetadata<?> metadata=t.getStructMetadata();
  boolean ok=true;
  for (  ThriftFieldMetadata fieldMetadata : metadata.getFields(FieldType.THRIFT_FIELD)) {
    boolean fieldOk=verifyField(fieldMetadata.getThriftType());
    if (!fieldOk) {
      ok=false;
      if (!quiet) {
        LOG.error(""String_Node_Str"",thriftTypeRenderer.toString(fieldMetadata.getThriftType()),metadata.getStructName(),fieldMetadata.getName());
      }
    }
  }
  if (ok) {
    knownTypes.add(t);
  }
  return ok;
}",0.9638989169675092
185253,"private Class<?> load(String className){
  className=getFullClassName(className);
  try {
    Class<?> cls=getClassLoader().loadClass(className);
    return cls;
  }
 catch (  ClassNotFoundException e) {
    LOG.warn(""String_Node_Str"",className);
  }
  return null;
}","private Class<?> load(String className){
  className=getFullClassName(className);
  try {
    return getClassLoader().loadClass(className);
  }
 catch (  ClassNotFoundException e) {
    LOG.warn(""String_Node_Str"",className);
  }
  return null;
}",0.9296875
185254,"@Nullable @Override public ClientWrapper apply(@Nullable AsyncLoadTest client){
  return new ClientWrapper(client,config.operationsPerConnection);
}","@Nullable @Override public ClientWrapper apply(@Nullable AsyncLoadTest client){
  return new ClientWrapper(clientManager,client,config.operationsPerConnection);
}",0.9548387096774194
185255,"protected void fillRequestPipeline(final ClientWrapper clientWrapper){
  if (clientWrapper.shouldStopSending()) {
    return;
  }
  try {
    while (!shutdownRequested) {
      if (channel.hasError()) {
        throw channel.getError();
      }
      long pendingCount=sendRequest(clientWrapper);
      clientWrapper.recordRequestSent();
      if (clientWrapper.shouldStopSending()) {
        reconnect();
        break;
      }
      if (pendingCount >= pendingOperationsHighWaterMark) {
        break;
      }
    }
  }
 catch (  TException ex) {
    logger.error(""String_Node_Str"",Throwables.getRootCause(ex).getMessage());
    clientWrapper.close();
  }
}","protected void fillRequestPipeline(final ClientWrapper clientWrapper){
  if (clientWrapper.shouldStopSending()) {
    return;
  }
  try {
    while (!shutdownRequested) {
      if (clientWrapper.hasError()) {
        throw clientWrapper.getError();
      }
      long pendingCount=sendRequest(clientWrapper);
      clientWrapper.recordRequestSent();
      if (clientWrapper.shouldStopSending()) {
        reconnect();
        break;
      }
      if (pendingCount >= pendingOperationsHighWaterMark) {
        break;
      }
    }
  }
 catch (  TException ex) {
    logger.error(""String_Node_Str"",Throwables.getRootCause(ex).getMessage());
    clientWrapper.close();
  }
}",0.9729323308270676
185256,"public ClientWrapper(AsyncLoadTest client,long requestLimit){
  this.client=client;
  this.requestLimit=requestLimit;
  this.clientId=clientCounter.getAndIncrement();
}","public ClientWrapper(ThriftClientManager clientManager,AsyncLoadTest client,long requestLimit){
  this.clientManager=clientManager;
  this.client=client;
  this.requestLimit=requestLimit;
  this.clientId=clientCounter.getAndIncrement();
}",0.8275862068965517
185257,"@Override public void onFailure(Throwable t){
  if (t instanceof LoadError) {
    onSuccess(null);
    return;
  }
  clientWrapper.recordResponseReceived();
  if (clientWrapper.isFinishedReceivingResponses()) {
    clientWrapper.close();
  }
  if (t instanceof TException) {
    clientWrapper.close();
    logger.error(""String_Node_Str"",Throwables.getRootCause(t).getMessage());
  }
  requestsFailed.incrementAndGet();
  if (requestsPending.decrementAndGet() < pendingOperationsLowWaterMark) {
    fillRequestPipeline(clientWrapper);
  }
}","@Override public void onFailure(Throwable t){
  if (t instanceof LoadError) {
    onSuccess(null);
    return;
  }
  clientWrapper.recordResponseReceived();
  if (clientWrapper.isFinishedReceivingResponses()) {
    clientWrapper.close();
  }
  if (t instanceof TException) {
    clientWrapper.close();
    logger.error(""String_Node_Str"",Throwables.getRootCause(t).getMessage());
  }
  requestsFailed.incrementAndGet();
  if (requestsPending.decrementAndGet() < pendingOperationsLowWaterMark) {
    fillCurrentClientPipeline();
  }
}",0.9710550887021476
185258,"protected void fillRequestPipeline(final ClientWrapper clientWrapper){
  try {
    while (!shutdownRequested) {
      if (channel.hasError()) {
        throw channel.getError();
      }
      long pendingCount=sendRequest(clientWrapper);
      clientWrapper.recordRequestReceived();
      if (clientWrapper.shouldStopSending()) {
        reconnect();
        break;
      }
      if (pendingCount >= pendingOperationsHighWaterMark) {
        break;
      }
    }
  }
 catch (  TException ex) {
    logger.error(""String_Node_Str"",Throwables.getRootCause(ex).getMessage());
    clientWrapper.close();
  }
}","protected void fillRequestPipeline(final ClientWrapper clientWrapper){
  if (clientWrapper.shouldStopSending()) {
    return;
  }
  try {
    while (!shutdownRequested) {
      if (channel.hasError()) {
        throw channel.getError();
      }
      long pendingCount=sendRequest(clientWrapper);
      clientWrapper.recordRequestReceived();
      if (clientWrapper.shouldStopSending()) {
        reconnect();
        break;
      }
      if (pendingCount >= pendingOperationsHighWaterMark) {
        break;
      }
    }
  }
 catch (  TException ex) {
    logger.error(""String_Node_Str"",Throwables.getRootCause(ex).getMessage());
    clientWrapper.close();
  }
}",0.9534333070244672
185259,"@Override public void onSuccess(@Nullable Object result){
  clientWrapper.recordResponseReceived();
  if (clientWrapper.isFinishedReceivingResponses()) {
    clientWrapper.close();
  }
  requestsProcessed.incrementAndGet();
  if (requestsPending.decrementAndGet() < pendingOperationsLowWaterMark) {
    fillRequestPipeline(clientWrapper);
  }
}","@Override public void onSuccess(@Nullable Object result){
  clientWrapper.recordResponseReceived();
  if (clientWrapper.isFinishedReceivingResponses()) {
    clientWrapper.close();
  }
  requestsProcessed.incrementAndGet();
  if (requestsPending.decrementAndGet() < pendingOperationsLowWaterMark) {
    fillCurrentClientPipeline();
  }
}",0.9544787077826724
185260,"@Config(""String_Node_Str"") public void setReadTimeout(Duration readTimeout){
  this.readTimeout=readTimeout;
}","@Config(""String_Node_Str"") public ThriftClientConfig setReadTimeout(Duration readTimeout){
  this.readTimeout=readTimeout;
  return this;
}",0.8674698795180723
185261,"@Config(""String_Node_Str"") public void setConnectTimeout(Duration connectTimeout){
  this.connectTimeout=connectTimeout;
}","@Config(""String_Node_Str"") public ThriftClientConfig setConnectTimeout(Duration connectTimeout){
  this.connectTimeout=connectTimeout;
  return this;
}",0.8791208791208791
185262,"public Class<?> getClientType(){
  return clientType;
}","public String getClientType(){
  return clientType;
}",0.8703703703703703
185263,"private ThriftClientMetadata(Class<?> clientType,String clientName,ThriftCodecManager codecManager){
  Preconditions.checkNotNull(clientType,""String_Node_Str"");
  Preconditions.checkNotNull(clientName,""String_Node_Str"");
  Preconditions.checkNotNull(codecManager,""String_Node_Str"");
  this.clientType=clientType;
  this.clientName=clientName;
  thriftServiceMetadata=new ThriftServiceMetadata(clientType,codecManager.getCatalog());
  ImmutableMap.Builder<Method,ThriftMethodHandler> methods=ImmutableMap.builder();
  for (  ThriftMethodMetadata methodMetadata : thriftServiceMetadata.getMethods().values()) {
    ThriftMethodHandler methodHandler=new ThriftMethodHandler(methodMetadata,codecManager);
    methods.put(methodMetadata.getMethod(),methodHandler);
  }
  methodHandlers=methods.build();
}","private ThriftClientMetadata(Class<?> clientType,String clientName,ThriftCodecManager codecManager){
  Preconditions.checkNotNull(clientType,""String_Node_Str"");
  Preconditions.checkNotNull(clientName,""String_Node_Str"");
  Preconditions.checkNotNull(codecManager,""String_Node_Str"");
  this.clientName=clientName;
  thriftServiceMetadata=new ThriftServiceMetadata(clientType,codecManager.getCatalog());
  this.clientType=thriftServiceMetadata.getName();
  ImmutableMap.Builder<Method,ThriftMethodHandler> methods=ImmutableMap.builder();
  for (  ThriftMethodMetadata methodMetadata : thriftServiceMetadata.getMethods().values()) {
    ThriftMethodHandler methodHandler=new ThriftMethodHandler(methodMetadata,codecManager);
    methods.put(methodMetadata.getMethod(),methodHandler);
  }
  methodHandlers=methods.build();
}",0.8672019765287214
185264,"public <T>void bindThriftClient(Class<T> clientInterface,Class<? extends Annotation> annotationType){
  Preconditions.checkNotNull(clientInterface,""String_Node_Str"");
  TypeLiteral<ThriftClient<T>> typeLiteral=toThriftClientTypeLiteral(clientInterface);
  String name=annotationType.getSimpleName();
  ThriftClientProviderProvider<T> provider=new ThriftClientProviderProvider<>(clientInterface,name,Key.get(ThriftClientConfig.class,annotationType));
  binder.bind(Key.get(typeLiteral,annotationType)).toProvider(provider);
  ExportBinder.newExporter(binder).export(Key.get(typeLiteral)).as(format(""String_Node_Str"",clientInterface.getSimpleName(),name));
  Multibinder.newSetBinder(binder,ThriftClientProviderProvider.class).addBinding().toInstance(provider);
  String prefix=String.format(""String_Node_Str"",clientInterface.getName(),name);
  bindConfig(binder).annotatedWith(annotationType).prefixedWith(prefix).to(ThriftClientConfig.class);
}","public <T>void bindThriftClient(Class<T> clientInterface,Class<? extends Annotation> annotationType){
  Preconditions.checkNotNull(clientInterface,""String_Node_Str"");
  TypeLiteral<ThriftClient<T>> typeLiteral=toThriftClientTypeLiteral(clientInterface);
  String name=annotationType.getSimpleName();
  Named thriftClientConfigKey=Names.named(UUID.randomUUID().toString());
  ThriftClientProviderProvider<T> provider=new ThriftClientProviderProvider<>(clientInterface,name,Key.get(ThriftClientConfig.class,thriftClientConfigKey));
  binder.bind(Key.get(typeLiteral,annotationType)).toProvider(provider).in(Scopes.SINGLETON);
  String typeName=getServiceName(clientInterface);
  ExportBinder.newExporter(binder).export(Key.get(typeLiteral)).as(format(""String_Node_Str"",typeName,name));
  Multibinder.newSetBinder(binder,ThriftClientProviderProvider.class).addBinding().toInstance(provider);
  String prefix=String.format(""String_Node_Str"",typeName,name);
  bindConfig(binder).annotatedWith(thriftClientConfigKey).prefixedWith(prefix).to(ThriftClientConfig.class);
}",0.8570004982561036
185265,"@Provides @Singleton public Map<ObjectName,ThriftMethodHandler> getMethodProcessors(Set<ThriftClientProviderProvider> clientProviders){
  try {
    ImmutableMap.Builder<ObjectName,ThriftMethodHandler> builder=ImmutableMap.builder();
    for (    ThriftClientProviderProvider<?> clientProvider : clientProviders) {
      ThriftClientMetadata clientMetadata=clientProvider.getClientMetadata();
      for (      ThriftMethodHandler methodHandler : clientMetadata.getMethodHandlers().values()) {
        Class<?> clientType=clientMetadata.getClientType();
        String name=format(""String_Node_Str"",clientType.getSimpleName(),clientMetadata.getClientName(),methodHandler.getName());
        builder.put(ObjectName.getInstance(name),methodHandler);
      }
    }
    return builder.build();
  }
 catch (  MalformedObjectNameException e) {
    throw Throwables.propagate(e);
  }
}","@Provides @Singleton public Map<ObjectName,ThriftMethodHandler> getMethodProcessors(Set<ThriftClientProviderProvider> clientProviders){
  try {
    ImmutableMap.Builder<ObjectName,ThriftMethodHandler> builder=ImmutableMap.builder();
    for (    ThriftClientProviderProvider<?> clientProvider : clientProviders) {
      ThriftClientMetadata clientMetadata=clientProvider.getClientMetadata();
      for (      ThriftMethodHandler methodHandler : clientMetadata.getMethodHandlers().values()) {
        String name=format(""String_Node_Str"",clientMetadata.getClientType(),clientMetadata.getClientName(),methodHandler.getName());
        builder.put(ObjectName.getInstance(name),methodHandler);
      }
    }
    return builder.build();
  }
 catch (  MalformedObjectNameException e) {
    throw Throwables.propagate(e);
  }
}",0.902122641509434
185266,"@Override public ObjectName name(ThriftMethodProcessor methodProcessor){
  try {
    Class<?> serviceClass=methodProcessor.getServiceClass();
    String name=format(""String_Node_Str"",serviceClass.getSimpleName(),methodProcessor.getName());
    return new ObjectName(name);
  }
 catch (  MalformedObjectNameException e) {
    throw Throwables.propagate(e);
  }
}","@Override public ObjectName name(ThriftMethodProcessor methodProcessor){
  try {
    Class<?> serviceClass=methodProcessor.getServiceClass();
    String name=format(""String_Node_Str"",getServiceName(serviceClass),methodProcessor.getName());
    return new ObjectName(name);
  }
 catch (  MalformedObjectNameException e) {
    throw Throwables.propagate(e);
  }
}",0.9584487534626038
185267,"@Override public void configure(Binder binder){
  newSetBinder(binder,ThriftServiceExport.class).permitDuplicates();
  binder.bind(ThriftServiceProcessor.class).toProvider(ThriftServiceProcessorProvider.class).in(Scopes.SINGLETON);
  binder.bind(TProcessor.class).to(Key.get(ThriftServiceProcessor.class)).in(Scopes.SINGLETON);
  bindConfig(binder).to(ThriftServerConfig.class);
  binder.bind(ThriftServer.class).in(Scopes.SINGLETON);
  ExportBinder.newExporter(binder).exportMap(ThriftMethodProcessor.class).withGeneratedName(new ObjectNameFunction<ThriftMethodProcessor>(){
    @Override public ObjectName name(    ThriftMethodProcessor methodProcessor){
      try {
        Class<?> serviceClass=methodProcessor.getServiceClass();
        String name=format(""String_Node_Str"",serviceClass.getSimpleName(),methodProcessor.getName());
        return new ObjectName(name);
      }
 catch (      MalformedObjectNameException e) {
        throw Throwables.propagate(e);
      }
    }
  }
);
}","@Override public void configure(Binder binder){
  newSetBinder(binder,ThriftServiceExport.class).permitDuplicates();
  binder.bind(ThriftServiceProcessor.class).toProvider(ThriftServiceProcessorProvider.class).in(Scopes.SINGLETON);
  binder.bind(TProcessor.class).to(Key.get(ThriftServiceProcessor.class)).in(Scopes.SINGLETON);
  bindConfig(binder).to(ThriftServerConfig.class);
  binder.bind(ThriftServer.class).in(Scopes.SINGLETON);
  ExportBinder.newExporter(binder).exportMap(ThriftMethodProcessor.class).withGeneratedName(new ObjectNameFunction<ThriftMethodProcessor>(){
    @Override public ObjectName name(    ThriftMethodProcessor methodProcessor){
      try {
        Class<?> serviceClass=methodProcessor.getServiceClass();
        String name=format(""String_Node_Str"",getServiceName(serviceClass),methodProcessor.getName());
        return new ObjectName(name);
      }
 catch (      MalformedObjectNameException e) {
        throw Throwables.propagate(e);
      }
    }
  }
);
}",0.9848484848484848
185268,"private void writeArguments(TProtocol out,int sequenceId,Object[] args) throws Exception {
  long start=System.nanoTime();
  out.writeMessageBegin(new TMessage(name,CALL,sequenceId));
  TProtocolWriter writer=new TProtocolWriter(out);
  writer.writeStructBegin(name + ""String_Node_Str"");
  for (int i=0; i < args.length; i++) {
    Object value=args[i];
    ParameterHandler parameter=parameterCodecs.get(i);
    writer.writeField(parameter.getName(),parameter.getId(),parameter.getCodec(),value);
  }
  writer.writeStructEnd();
  out.writeMessageEnd();
  out.getTransport().flush();
  stats.addWriteTime(nanosSince(start));
}","private void writeArguments(TProtocol out,int sequenceId,Object[] args) throws Exception {
  long start=System.nanoTime();
  out.writeMessageBegin(new TMessage(name,oneway ? ONEWAY : CALL,sequenceId));
  TProtocolWriter writer=new TProtocolWriter(out);
  writer.writeStructBegin(name + ""String_Node_Str"");
  for (int i=0; i < args.length; i++) {
    Object value=args[i];
    ParameterHandler parameter=parameterCodecs.get(i);
    writer.writeField(parameter.getName(),parameter.getId(),parameter.getCodec(),value);
  }
  writer.writeStructEnd();
  out.writeMessageEnd();
  out.getTransport().flush();
  stats.addWriteTime(nanosSince(start));
}",0.9858267716535432
185269,"public void process(TProtocol in,TProtocol out,int sequenceId) throws Exception {
  long start=System.nanoTime();
  Object[] args=readArguments(in);
  Object result;
  try {
    result=invokeMethod(args);
    writeResponse(out,sequenceId,TMessageType.REPLY,""String_Node_Str"",(short)0,successCodec,result);
    stats.addSuccessTime(nanosSince(start));
  }
 catch (  Exception e) {
    if (!oneway) {
      ExceptionProcessor exceptionCodec=exceptionCodecs.get(e.getClass());
      if (exceptionCodec != null) {
        writeResponse(out,sequenceId,TMessageType.REPLY,""String_Node_Str"",exceptionCodec.getId(),exceptionCodec.getCodec(),e);
        stats.addErrorTime(nanosSince(start));
      }
 else {
        TApplicationException applicationException=new TApplicationException(INTERNAL_ERROR,""String_Node_Str"" + method.getName());
        applicationException.initCause(e);
        out.writeMessageBegin(new TMessage(name,TMessageType.EXCEPTION,sequenceId));
        applicationException.write(out);
        out.writeMessageEnd();
        out.getTransport().flush();
        stats.addErrorTime(nanosSince(start));
      }
    }
  }
}","public void process(TProtocol in,TProtocol out,int sequenceId) throws Exception {
  long start=System.nanoTime();
  Object[] args=readArguments(in);
  Object result;
  try {
    result=invokeMethod(args);
    if (!oneway) {
      writeResponse(out,sequenceId,TMessageType.REPLY,""String_Node_Str"",(short)0,successCodec,result);
    }
    stats.addSuccessTime(nanosSince(start));
  }
 catch (  Exception e) {
    if (!oneway) {
      ExceptionProcessor exceptionCodec=exceptionCodecs.get(e.getClass());
      if (exceptionCodec != null) {
        writeResponse(out,sequenceId,TMessageType.REPLY,""String_Node_Str"",exceptionCodec.getId(),exceptionCodec.getCodec(),e);
        stats.addErrorTime(nanosSince(start));
      }
 else {
        TApplicationException applicationException=new TApplicationException(INTERNAL_ERROR,""String_Node_Str"" + method.getName());
        applicationException.initCause(e);
        out.writeMessageBegin(new TMessage(name,TMessageType.EXCEPTION,sequenceId));
        applicationException.write(out);
        out.writeMessageEnd();
        out.getTransport().flush();
        stats.addErrorTime(nanosSince(start));
      }
    }
 else {
      stats.addErrorTime(nanosSince(start));
    }
  }
}",0.96343537414966
185270,"static <T extends FieldMetadata>Function<T,Short> getThriftFieldId(){
  return new Function<T,Short>(){
    @Override public Short apply(    @Nullable T input){
      if (input == null) {
        return null;
      }
      return input.getId();
    }
  }
;
}","static <T extends FieldMetadata>Function<T,Optional<Short>> getThriftFieldId(){
  return new Function<T,Optional<Short>>(){
    @Override public Optional<Short> apply(    @Nullable T input){
      if (input == null) {
        return Optional.absent();
      }
      Short value=input.getId();
      return Optional.fromNullable(value);
    }
  }
;
}",0.8138385502471169
185271,"public ThriftStructMetadataBuilder(ThriftCatalog catalog,Class<T> structClass){
  this.catalog=checkNotNull(catalog,""String_Node_Str"");
  this.structClass=checkNotNull(structClass,""String_Node_Str"");
  this.problems=new Problems(catalog.getMonitor());
  if (Modifier.isAbstract(structClass.getModifiers())) {
    problems.addError(""String_Node_Str"",structClass.getName());
  }
  if (!Modifier.isPublic(structClass.getModifiers())) {
    problems.addError(""String_Node_Str"",structClass.getName());
  }
  ThriftStruct annotation=structClass.getAnnotation(ThriftStruct.class);
  if (annotation != null) {
    if (!annotation.name().isEmpty()) {
      structName=annotation.name();
    }
 else {
      structName=structClass.getSimpleName();
    }
  }
 else {
    problems.addError(""String_Node_Str"",structClass.getName());
    structName=structClass.getSimpleName();
  }
  if (!annotation.builder().equals(void.class)) {
    builderClass=annotation.builder();
  }
 else {
    builderClass=null;
  }
  if (builderClass != null) {
    addConstructors(builderClass);
    addBuilderMethods();
    for (    Constructor<?> constructor : structClass.getConstructors()) {
      if (constructor.isAnnotationPresent(ThriftConstructor.class)) {
        problems.addWarning(""String_Node_Str"",structClass.getName(),constructor);
      }
    }
  }
 else {
    addConstructors(structClass);
  }
  if (builderClass != null) {
    addFields(builderClass,false,true);
    addFields(structClass,true,false);
  }
 else {
    addFields(structClass,true,true);
  }
  if (builderClass != null) {
    addMethods(builderClass,false,true);
    addMethods(structClass,true,false);
  }
 else {
    addMethods(structClass,true,true);
  }
  Multimap<String,FieldMetadata> fieldsByName=Multimaps.index(fields,getOrExtractThriftFieldName());
  for (  Entry<String,Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
    Collection<FieldMetadata> fields=entry.getValue();
    if (fields.size() <= 1) {
      continue;
    }
    short id=Iterables.find(transform(fields,getThriftFieldId()),notNull(),Short.MIN_VALUE);
    if (id != Short.MIN_VALUE) {
      for (      FieldMetadata field : fields) {
        field.setId(id);
      }
    }
  }
  Multimap<Short,FieldMetadata> fieldsById=Multimaps.index(fields,getThriftFieldId());
  for (  Entry<Short,Collection<FieldMetadata>> entry : fieldsById.asMap().entrySet()) {
    Short id=entry.getKey();
    Collection<FieldMetadata> fields=entry.getValue();
    if (id == null) {
      for (      FieldMetadata field : fields) {
        problems.addError(""String_Node_Str"",structName,field.getName());
      }
      continue;
    }
    Set<String> names=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldName()),notNull()));
    String name;
    if (!names.isEmpty()) {
      if (names.size() > 1) {
        problems.addWarning(""String_Node_Str"",id,names);
      }
      name=names.iterator().next();
    }
 else {
      name=Iterables.find(transform(fields,extractThriftFieldName()),notNull());
    }
    for (    FieldMetadata field : fields) {
      field.setName(name);
    }
    Set<ThriftProtocolFieldType> protocolTypes=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldProtocolType()),notNull()));
    if (protocolTypes.size() > 1) {
      problems.addError(""String_Node_Str"",id,protocolTypes);
      continue;
    }
    ThriftProtocolFieldType type=protocolTypes.iterator().next();
    for (    FieldMetadata field : fields) {
      field.setProtocolType(type);
    }
    Set<ThriftType> types=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldType(catalog)),notNull()));
    if (!types.isEmpty()) {
      if (protocolTypes.size() > 1) {
        problems.addError(""String_Node_Str"",id,protocolTypes);
      }
    }
  }
}","public ThriftStructMetadataBuilder(ThriftCatalog catalog,Class<T> structClass){
  this.catalog=checkNotNull(catalog,""String_Node_Str"");
  this.structClass=checkNotNull(structClass,""String_Node_Str"");
  this.problems=new Problems(catalog.getMonitor());
  if (Modifier.isAbstract(structClass.getModifiers())) {
    problems.addError(""String_Node_Str"",structClass.getName());
  }
  if (!Modifier.isPublic(structClass.getModifiers())) {
    problems.addError(""String_Node_Str"",structClass.getName());
  }
  ThriftStruct annotation=structClass.getAnnotation(ThriftStruct.class);
  if (annotation != null) {
    if (!annotation.name().isEmpty()) {
      structName=annotation.name();
    }
 else {
      structName=structClass.getSimpleName();
    }
  }
 else {
    problems.addError(""String_Node_Str"",structClass.getName());
    structName=structClass.getSimpleName();
  }
  if (!annotation.builder().equals(void.class)) {
    builderClass=annotation.builder();
  }
 else {
    builderClass=null;
  }
  if (builderClass != null) {
    addConstructors(builderClass);
    addBuilderMethods();
    for (    Constructor<?> constructor : structClass.getConstructors()) {
      if (constructor.isAnnotationPresent(ThriftConstructor.class)) {
        problems.addWarning(""String_Node_Str"",structClass.getName(),constructor);
      }
    }
  }
 else {
    addConstructors(structClass);
  }
  if (builderClass != null) {
    addFields(builderClass,false,true);
    addFields(structClass,true,false);
  }
 else {
    addFields(structClass,true,true);
  }
  if (builderClass != null) {
    addMethods(builderClass,false,true);
    addMethods(structClass,true,false);
  }
 else {
    addMethods(structClass,true,true);
  }
  Multimap<String,FieldMetadata> fieldsByName=Multimaps.index(fields,getOrExtractThriftFieldName());
  for (  Entry<String,Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
    Collection<FieldMetadata> fields=entry.getValue();
    if (fields.size() <= 1) {
      continue;
    }
    short id=Iterables.getFirst(Optional.presentInstances(transform(fields,getThriftFieldId())),Short.MIN_VALUE);
    if (id != Short.MIN_VALUE) {
      for (      FieldMetadata field : fields) {
        field.setId(id);
      }
    }
  }
  Multimap<Optional<Short>,FieldMetadata> fieldsById=Multimaps.index(fields,getThriftFieldId());
  for (  Entry<Optional<Short>,Collection<FieldMetadata>> entry : fieldsById.asMap().entrySet()) {
    Short id=entry.getKey().orNull();
    Collection<FieldMetadata> fields=entry.getValue();
    if (id == null) {
      for (      FieldMetadata field : fields) {
        problems.addError(""String_Node_Str"",structName,field.getName());
      }
      continue;
    }
    Set<String> names=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldName()),notNull()));
    String name;
    if (!names.isEmpty()) {
      if (names.size() > 1) {
        problems.addWarning(""String_Node_Str"",id,names);
      }
      name=names.iterator().next();
    }
 else {
      name=Iterables.find(transform(fields,extractThriftFieldName()),notNull());
    }
    for (    FieldMetadata field : fields) {
      field.setName(name);
    }
    Set<ThriftProtocolFieldType> protocolTypes=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldProtocolType()),notNull()));
    if (protocolTypes.size() > 1) {
      problems.addError(""String_Node_Str"",id,protocolTypes);
      continue;
    }
    ThriftProtocolFieldType type=protocolTypes.iterator().next();
    for (    FieldMetadata field : fields) {
      field.setProtocolType(type);
    }
    Set<ThriftType> types=ImmutableSet.copyOf(filter(transform(fields,getThriftFieldType(catalog)),notNull()));
    if (!types.isEmpty()) {
      if (protocolTypes.size() > 1) {
        problems.addError(""String_Node_Str"",id,protocolTypes);
      }
    }
  }
}",0.9900105152471084
185272,"public ThriftStructMetadata<T> build(){
  problems.throwIfHasErrors();
  ThriftMethodInjection builderMethodInjection=null;
  if (builderClass != null) {
    MethodInjection builderMethod=builderMethodInjections.get(0);
    builderMethodInjection=new ThriftMethodInjection(builderMethod.getMethod(),toThriftParameterInjections(builderMethod.getParameters()));
  }
  ConstructorInjection constructor=constructorInjections.get(0);
  Multimap<Short,FieldMetadata> fieldsById=Multimaps.index(fields,getThriftFieldId());
  Iterable<ThriftFieldMetadata> fieldsMetadata=Iterables.transform(fieldsById.asMap().values(),new Function<Collection<FieldMetadata>,ThriftFieldMetadata>(){
    @Override public ThriftFieldMetadata apply(    Collection<FieldMetadata> input){
      checkArgument(!input.isEmpty(),""String_Node_Str"");
      short id=-1;
      String name=null;
      ThriftType type=null;
      ImmutableList.Builder<ThriftInjection> injections=ImmutableList.builder();
      ThriftExtraction extraction=null;
      for (      FieldMetadata fieldMetadata : input) {
        id=fieldMetadata.getId();
        name=fieldMetadata.getName();
        type=catalog.getThriftType(fieldMetadata.getJavaType(),fieldMetadata.getProtocolType());
        if (fieldMetadata instanceof FieldInjection) {
          FieldInjection fieldInjection=(FieldInjection)fieldMetadata;
          injections.add(new ThriftFieldInjection(fieldInjection.getId(),fieldInjection.getName(),fieldInjection.getField()));
        }
 else         if (fieldMetadata instanceof ParameterInjection) {
          ParameterInjection parameterInjection=(ParameterInjection)fieldMetadata;
          injections.add(new ThriftParameterInjection(parameterInjection.getId(),parameterInjection.getName(),parameterInjection.getParameterIndex()));
        }
 else         if (fieldMetadata instanceof FieldExtractor) {
          FieldExtractor fieldExtractor=(FieldExtractor)fieldMetadata;
          extraction=new ThriftFieldExtractor(fieldExtractor.getId(),fieldExtractor.getName(),fieldExtractor.getField());
        }
 else         if (fieldMetadata instanceof MethodExtractor) {
          MethodExtractor methodExtractor=(MethodExtractor)fieldMetadata;
          extraction=new ThriftMethodExtractor(methodExtractor.getId(),methodExtractor.getName(),methodExtractor.getMethod());
        }
      }
      ThriftFieldMetadata thriftFieldMetadata=new ThriftFieldMetadata(id,type,name,injections.build(),extraction);
      return thriftFieldMetadata;
    }
  }
);
  return new ThriftStructMetadata<>(structName,structClass,builderClass,builderMethodInjection,ImmutableList.copyOf(fieldsMetadata),new ThriftConstructorInjection(constructor.getConstructor(),toThriftParameterInjections(constructor.getParameters())),toThriftMethodInjections(methodInjections));
}","public ThriftStructMetadata<T> build(){
  problems.throwIfHasErrors();
  ThriftMethodInjection builderMethodInjection=null;
  if (builderClass != null) {
    MethodInjection builderMethod=builderMethodInjections.get(0);
    builderMethodInjection=new ThriftMethodInjection(builderMethod.getMethod(),toThriftParameterInjections(builderMethod.getParameters()));
  }
  ConstructorInjection constructor=constructorInjections.get(0);
  Multimap<Optional<Short>,FieldMetadata> fieldsById=Multimaps.index(fields,getThriftFieldId());
  Iterable<ThriftFieldMetadata> fieldsMetadata=Iterables.transform(fieldsById.asMap().values(),new Function<Collection<FieldMetadata>,ThriftFieldMetadata>(){
    @Override public ThriftFieldMetadata apply(    Collection<FieldMetadata> input){
      checkArgument(!input.isEmpty(),""String_Node_Str"");
      short id=-1;
      String name=null;
      ThriftType type=null;
      ImmutableList.Builder<ThriftInjection> injections=ImmutableList.builder();
      ThriftExtraction extraction=null;
      for (      FieldMetadata fieldMetadata : input) {
        id=fieldMetadata.getId();
        name=fieldMetadata.getName();
        type=catalog.getThriftType(fieldMetadata.getJavaType(),fieldMetadata.getProtocolType());
        if (fieldMetadata instanceof FieldInjection) {
          FieldInjection fieldInjection=(FieldInjection)fieldMetadata;
          injections.add(new ThriftFieldInjection(fieldInjection.getId(),fieldInjection.getName(),fieldInjection.getField()));
        }
 else         if (fieldMetadata instanceof ParameterInjection) {
          ParameterInjection parameterInjection=(ParameterInjection)fieldMetadata;
          injections.add(new ThriftParameterInjection(parameterInjection.getId(),parameterInjection.getName(),parameterInjection.getParameterIndex()));
        }
 else         if (fieldMetadata instanceof FieldExtractor) {
          FieldExtractor fieldExtractor=(FieldExtractor)fieldMetadata;
          extraction=new ThriftFieldExtractor(fieldExtractor.getId(),fieldExtractor.getName(),fieldExtractor.getField());
        }
 else         if (fieldMetadata instanceof MethodExtractor) {
          MethodExtractor methodExtractor=(MethodExtractor)fieldMetadata;
          extraction=new ThriftMethodExtractor(methodExtractor.getId(),methodExtractor.getName(),methodExtractor.getMethod());
        }
      }
      ThriftFieldMetadata thriftFieldMetadata=new ThriftFieldMetadata(id,type,name,injections.build(),extraction);
      return thriftFieldMetadata;
    }
  }
);
  return new ThriftStructMetadata<>(structName,structClass,builderClass,builderMethodInjection,ImmutableList.copyOf(fieldsMetadata),new ThriftConstructorInjection(constructor.getConstructor(),toThriftParameterInjections(constructor.getParameters())),toThriftMethodInjections(methodInjections));
}",0.998223169864961
185273,"/** 
 * Creates a new   {@link JaxRsLinkBuilder} instance to link to the {@link Path} mapping tied to the given class bindingthe given parameters to the URI template.
 * @param service the class to discover the annotation on, must not be {@literal null}.
 * @param parameters additional parameters to bind to the URI template declared in the annotation, must not be{@literal null}.
 * @return
 */
public static JaxRsLinkBuilder linkTo(Class<?> service,Object... parameters){
  JaxRsLinkBuilder builder=new JaxRsLinkBuilder(ServletUriComponentsBuilder.fromCurrentServletMapping());
  UriTemplate template=new UriTemplate(DISCOVERER.getMapping(service));
  return builder.slash(template.expand(parameters));
}","/** 
 * Creates a new   {@link JaxRsLinkBuilder} instance to link to the {@link Path} mapping tied to the given class bindingthe given parameters to the URI template.
 * @param service the class to discover the annotation on, must not be {@literal null}.
 * @param parameters additional parameters to bind to the URI template declared in the annotation, must not be{@literal null}.
 * @return
 */
public static JaxRsLinkBuilder linkTo(Class<?> service,Object... parameters){
  JaxRsLinkBuilder builder=new JaxRsLinkBuilder(ServletUriComponentsBuilder.fromCurrentServletMapping());
  UriComponents uriComponents=UriComponentsBuilder.fromUriString(DISCOVERER.getMapping(service)).build();
  UriComponents expandedComponents=uriComponents.expand(parameters);
  return builder.slash(expandedComponents);
}",0.8381962864721485
185274,"/** 
 * @see #62
 */
@Test public void jackson2Marshalling() throws Exception {
  assertThat(jackson2Mapper.writeValueAsString(errors),is(json2Reference));
}","/** 
 * @see #62
 */
@Test public void jackson2Marshalling() throws Exception {
  assertThat(jackson2Mapper.writeValueAsString(errors),equalToIgnoringWhiteSpace(json2Reference));
}",0.9258160237388724
185275,"@Test public void appendsFragmentCorrectly(){
  SampleLinkBuilder builder=new SampleLinkBuilder(UriComponentsBuilder.newInstance());
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
}","@Test public void appendsFragmentCorrectly(){
  SampleLinkBuilder builder=new SampleLinkBuilder(UriComponentsBuilder.newInstance());
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
  builder=builder.slash(""String_Node_Str"");
  assertThat(builder.toString(),endsWith(""String_Node_Str""));
}",0.9132569558101472
185276,"@Before public void setUp() throws Exception {
  jackson1Mapper=new ObjectMapper();
  jackson1Mapper.registerModule(new Jackson1HalModule());
  jackson1Mapper.configure(Feature.INDENT_OUTPUT,true);
  jackson2Mapper=new com.fasterxml.jackson.databind.ObjectMapper();
  jackson2Mapper.registerModule(new Jackson2HalModule());
  jackson2Mapper.configure(SerializationFeature.INDENT_OUTPUT,true);
  JAXBContext context=JAXBContext.newInstance(VndErrors.class);
  marshaller=context.createMarshaller();
  VndError error=new VndError(""String_Node_Str"",""String_Node_Str"",new Link(""String_Node_Str"",""String_Node_Str""),new Link(""String_Node_Str"",""String_Node_Str""));
  errors=new VndErrors(error,error,error);
}","@Before public void setUp() throws Exception {
  jackson1Mapper=new ObjectMapper();
  jackson1Mapper.registerModule(new Jackson1HalModule());
  jackson1Mapper.configure(Feature.INDENT_OUTPUT,true);
  jackson2Mapper=new com.fasterxml.jackson.databind.ObjectMapper();
  jackson2Mapper.registerModule(new Jackson2HalModule());
  jackson2Mapper.configure(SerializationFeature.INDENT_OUTPUT,true);
  JAXBContext context=JAXBContext.newInstance(VndErrors.class);
  marshaller=context.createMarshaller();
  unmarshaller=context.createUnmarshaller();
  VndError error=new VndError(""String_Node_Str"",""String_Node_Str"",new Link(""String_Node_Str"",""String_Node_Str""),new Link(""String_Node_Str"",""String_Node_Str""));
  errors=new VndErrors(error,error,error);
}",0.968944099378882
185277,"private ClassNode[] inferClosureParamTypes(ClosureExpression node,VariableScope scope){
  if (node.getParameters() == null) {
    return ClassNode.EMPTY_ARRAY;
  }
  ClassNode primaryType=null;
  ClassNode[] inferredTypes=new ClassNode[node.isParameterSpecified() ? node.getParameters().length : 1];
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null && cat.declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)cat.declaration;
    Parameter methodParam=findTargetParameter(node,cat.call,methodNode,!methodNode.getDeclaringClass().equals(cat.getPerceivedDeclaringType()));
    if (methodParam != null) {
      if (VariableScope.CLOSURE_CLASS_NODE.equals(methodParam.getType())) {
        GroovyUtils.getAnnotations(methodParam,VariableScope.CLOSURE_PARAMS.getName()).findFirst().ifPresent(cp -> {
          SourceUnit sourceUnit=enclosingModule.getContext();
          try {
            @SuppressWarnings(""String_Node_Str"") Class<? extends ClosureSignatureHint> hint=(Class<? extends ClosureSignatureHint>)StaticTypeCheckingSupport.evaluateExpression(GeneralUtils.castX(VariableScope.CLASS_CLASS_NODE,cp.getMember(""String_Node_Str"")),sourceUnit.getConfiguration());
            String[] opts=(String[])StaticTypeCheckingSupport.evaluateExpression(GeneralUtils.castX(VariableScope.STRING_CLASS_NODE.makeArray(),cp.getMember(""String_Node_Str"")),sourceUnit.getConfiguration());
            List<ClassNode[]> sigs=hint.newInstance().getClosureSignatures(methodNode,sourceUnit,resolver.compilationUnit,opts,cat.call);
            if (isNotEmpty(sigs)) {
              for (              ClassNode[] sig : sigs) {
                if (sig.length == inferredTypes.length) {
                  GenericsType[] generics=getMethodCallGenericsTypes(cat.call);
                  List<ClassNode> arguments=GroovyUtils.getParameterTypes(methodNode.getParameters());
                  GenericsMapper map=GenericsMapper.gatherGenerics(arguments,cat.declaringType,methodNode.getOriginal(),generics);
                  for (int i=0, n=sig.length; i < n; i+=1) {
                    inferredTypes[i]=VariableScope.resolveTypeParameterization(map,sig[i]);
                  }
                  break;
                }
              }
            }
          }
 catch (          Exception e) {
            log(e,""String_Node_Str"",methodNode.getTypeDescriptor());
          }
        }
);
      }
      if (inferredTypes[0] == null) {
        primaryType=methodParam.getType();
        if (GenericsMapper.isVargs(methodNode.getParameters()) && DefaultGroovyMethods.last(methodNode.getParameters()) == methodParam) {
          primaryType=primaryType.getComponentType();
        }
      }
    }
  }
 else   if (!completeExpressionStack.isEmpty() && completeExpressionStack.getLast() instanceof CastExpression && ((CastExpression)completeExpressionStack.getLast()).getExpression() == node) {
    primaryType=((CastExpression)completeExpressionStack.getLast()).getType();
  }
 else   if (enclosingAssignment != null && enclosingAssignment.getRightExpression() == node) {
    primaryType=enclosingAssignment.getLeftExpression().getType();
  }
  if (inferredTypes[0] == null) {
    int i=0;
    MethodNode sam;
    if (primaryType != null && (sam=ClassHelper.findSAM(primaryType)) != null) {
      for (      ClassNode t : GroovyUtils.getParameterTypes(sam.getParameters())) {
        if (i == inferredTypes.length)         break;
        inferredTypes[i++]=t;
      }
    }
    Arrays.fill(inferredTypes,i,inferredTypes.length,VariableScope.OBJECT_CLASS_NODE);
  }
  return inferredTypes;
}","private ClassNode[] inferClosureParamTypes(ClosureExpression node,VariableScope scope){
  if (node.getParameters() == null) {
    return ClassNode.EMPTY_ARRAY;
  }
  ClassNode primaryType=null;
  ClassNode[] inferredTypes=new ClassNode[node.isParameterSpecified() ? node.getParameters().length : 1];
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null && cat.declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)cat.declaration;
    Parameter methodParam=findTargetParameter(node,cat.call,methodNode,!methodNode.getDeclaringClass().equals(cat.getPerceivedDeclaringType()));
    if (methodParam != null) {
      if (VariableScope.CLOSURE_CLASS_NODE.equals(methodParam.getType())) {
        GroovyUtils.getAnnotations(methodParam,VariableScope.CLOSURE_PARAMS.getName()).findFirst().ifPresent(cp -> {
          SourceUnit sourceUnit=enclosingModule.getContext();
          try {
            @SuppressWarnings(""String_Node_Str"") Class<? extends ClosureSignatureHint> hint=(Class<? extends ClosureSignatureHint>)StaticTypeCheckingSupport.evaluateExpression(GeneralUtils.castX(VariableScope.CLASS_CLASS_NODE,cp.getMember(""String_Node_Str"")),sourceUnit.getConfiguration());
            String[] opts=(String[])(cp.getMember(""String_Node_Str"") == null ? ClosureParams.class.getMethod(""String_Node_Str"").getDefaultValue() : StaticTypeCheckingSupport.evaluateExpression(GeneralUtils.castX(VariableScope.STRING_CLASS_NODE.makeArray(),cp.getMember(""String_Node_Str"")),sourceUnit.getConfiguration()));
            List<ClassNode[]> sigs=hint.newInstance().getClosureSignatures(methodNode,sourceUnit,resolver.compilationUnit,opts,cat.call);
            if (isNotEmpty(sigs)) {
              for (              ClassNode[] sig : sigs) {
                if (sig.length == inferredTypes.length) {
                  GenericsType[] generics=getMethodCallGenericsTypes(cat.call);
                  List<ClassNode> arguments=GroovyUtils.getParameterTypes(methodNode.getParameters());
                  GenericsMapper map=GenericsMapper.gatherGenerics(arguments,cat.declaringType,methodNode.getOriginal(),generics);
                  for (int i=0, n=sig.length; i < n; i+=1) {
                    inferredTypes[i]=VariableScope.resolveTypeParameterization(map,sig[i]);
                  }
                  break;
                }
              }
            }
          }
 catch (          Exception e) {
            log(e,""String_Node_Str"",methodNode.getTypeDescriptor());
          }
        }
);
      }
      if (inferredTypes[0] == null) {
        primaryType=methodParam.getType();
        if (GenericsMapper.isVargs(methodNode.getParameters()) && DefaultGroovyMethods.last(methodNode.getParameters()) == methodParam) {
          primaryType=primaryType.getComponentType();
        }
      }
    }
  }
 else   if (!completeExpressionStack.isEmpty() && completeExpressionStack.getLast() instanceof CastExpression && ((CastExpression)completeExpressionStack.getLast()).getExpression() == node) {
    primaryType=((CastExpression)completeExpressionStack.getLast()).getType();
  }
 else   if (enclosingAssignment != null && enclosingAssignment.getRightExpression() == node) {
    primaryType=enclosingAssignment.getLeftExpression().getType();
  }
  if (inferredTypes[0] == null) {
    int i=0;
    MethodNode sam;
    if (primaryType != null && (sam=ClassHelper.findSAM(primaryType)) != null) {
      for (      ClassNode t : GroovyUtils.getParameterTypes(sam.getParameters())) {
        if (i == inferredTypes.length)         break;
        inferredTypes[i++]=t;
      }
    }
    Arrays.fill(inferredTypes,i,inferredTypes.length,VariableScope.OBJECT_CLASS_NODE);
  }
  return inferredTypes;
}",0.984652994703246
185278,"private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  return ConstantExpression.EMPTY_EXPRESSION;
}","private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  ConstantExpression ret=new ConstantExpression(null);
  ret.setSourcePosition(exp);
  return ret;
}",0.8954509177972865
185279,"private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  return ConstantExpression.EMPTY_EXPRESSION;
}","private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  ConstantExpression ret=new ConstantExpression(null);
  ret.setSourcePosition(exp);
  return ret;
}",0.8954509177972865
185280,"private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  return ConstantExpression.EMPTY_EXPRESSION;
}","private ConstantExpression getConstantExpression(Expression exp,ClassNode attrType){
  if (exp instanceof ConstantExpression) {
    return (ConstantExpression)exp;
  }
  String base=""String_Node_Str"" + exp.getText() + ""String_Node_Str""+ attrType.getName();
  if (exp instanceof PropertyExpression) {
    addError(base + ""String_Node_Str"",exp);
  }
 else   if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
    addError(base + ""String_Node_Str"",exp);
  }
 else {
    addError(base,exp);
  }
  ConstantExpression ret=new ConstantExpression(null);
  ret.setSourcePosition(exp);
  return ret;
}",0.8954509177972865
185281,"public void reset(){
  compilationUnit=null;
}","public void reset(){
  compilationUnit=null;
  resolver=null;
}",0.8440366972477065
185282,"private void assertAccessRestriction(String source,String... types){
  IPath foo=env.addGroovyClass(src,""String_Node_Str"",source);
  fullBuild();
  source=env.readTextFile(foo);
  List<String> problems=new ArrayList<>();
  for (  String type : types) {
    int offset=-1;
    while ((offset=source.indexOf(type.trim(),offset + 1)) != -1) {
      problems.add(String.format(problemFormat,type.trim(),offset,offset + type.length()));
    }
  }
  expectingProblemsFor(foo,problems);
}","private void assertAccessRestriction(String source,String... types){
  IPath foo=env.addGroovyClass(src,""String_Node_Str"",source);
  fullBuild();
  source=env.readTextFile(foo);
  List<String> problems=new ArrayList<>();
  for (  String type : types) {
    int offset=-1;
    while ((offset=source.indexOf(type.trim(),offset + 1)) != -1) {
      problems.add(String.format(problemFormat,last(type.split(""String_Node_Str"")).trim(),offset,offset + type.length()));
    }
  }
  expectingProblemsFor(foo,problems);
}",0.9607250755287008
185283,"@Test public void testSearchForTypesClass7() throws Exception {
  createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doTestForTwoInClass(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testSearchForTypesClass7() throws Exception {
  createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doTestForTwoInClass(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9251968503937008
185284,"@Test public void testConstructorWithDefaultArgsInCompileStatic() throws Exception {
  String firstContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String secondContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<SearchMatch> matches=getAllMatches(firstContents,secondContents,""String_Node_Str"",""String_Node_Str"",true);
  int lastMatch=0;
  for (  SearchMatch searchMatch : matches) {
    int start=secondContents.indexOf(""String_Node_Str"",lastMatch);
    assertEquals(""String_Node_Str"" + searchMatch,start,searchMatch.getOffset());
    assertEquals(""String_Node_Str"" + searchMatch,""String_Node_Str"".length(),searchMatch.getLength());
    lastMatch=start + 1;
  }
  assertEquals(""String_Node_Str"" + matches,3,matches.size());
}","@Test public void testConstructorWithDefaultArgsInCompileStatic() throws Exception {
  String firstContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String secondContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<SearchMatch> matches=getAllMatches(firstContents,secondContents,""String_Node_Str"",""String_Node_Str"",true);
  int lastMatch=0;
  for (  SearchMatch searchMatch : matches) {
    int start=secondContents.indexOf(""String_Node_Str"",lastMatch);
    assertEquals(""String_Node_Str"" + searchMatch,start,searchMatch.getOffset());
    assertEquals(""String_Node_Str"" + searchMatch,""String_Node_Str"".length(),searchMatch.getLength());
    lastMatch=start + 1;
  }
  assertEquals(""String_Node_Str"" + matches,2,matches.size());
}",0.9989165763813652
185285,"/** 
 * Tests whether queries looking for some type declaration with a name pattern like '*Tests' works correctly.
 */
@Test public void testFindClassDeclarationWithPattern() throws Exception {
  int matchRule=SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE;
  SearchPattern testPattern=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.TYPE,IJavaSearchConstants.DECLARATIONS,matchRule);
  GroovyCompilationUnit songTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit weirdTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit artistTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IJavaProject javaProject=JavaCore.create(project);
  IType songTestsType=javaProject.findType(""String_Node_Str"");
  assertNotNull(songTestsType);
  IType artistTestsType=javaProject.findType(""String_Node_Str"");
  assertNotNull(artistTestsType);
  SearchParticipant[] searchParticipants=new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()};
  final ArrayList<Object> result=new ArrayList<>();
  IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{songTests,weirdTests,artistTests},IJavaSearchScope.SOURCES);
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      Object element=match.getElement();
      result.add(element);
    }
  }
;
  new SearchEngine().search(testPattern,searchParticipants,scope,requestor,new NullProgressMonitor());
  assertEquals(""String_Node_Str"",2,result.size());
  assertElements(new HashSet<>(result),songTestsType,artistTestsType);
}","/** 
 * Tests whether queries looking for some type declaration with a name pattern like '*Tests' works correctly.
 */
@Test public void testFindClassDeclarationWithPattern() throws Exception {
  int matchRule=SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE;
  SearchPattern testPattern=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.TYPE,IJavaSearchConstants.DECLARATIONS,matchRule);
  GroovyCompilationUnit songTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit weirdTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit artistTests=createUnit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IJavaProject javaProject=JavaCore.create(project);
  IType songTestsType=javaProject.findType(""String_Node_Str"");
  assertNotNull(songTestsType);
  IType artistTestsType=javaProject.findType(""String_Node_Str"");
  assertNotNull(artistTestsType);
  SearchParticipant[] searchParticipants=new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()};
  final List<Object> result=new ArrayList<>();
  IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{songTests,weirdTests,artistTests},IJavaSearchScope.SOURCES);
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      Object element=match.getElement();
      result.add(element);
    }
  }
;
  new SearchEngine().search(testPattern,searchParticipants,scope,requestor,new NullProgressMonitor());
  assertEquals(""String_Node_Str"",2,result.size());
  assertElements(new HashSet<>(result),songTestsType,artistTestsType);
}",0.9988006716238906
185286,"@Override protected ImportBinding[] getDefaultImports(){
  if (defaultGroovyImports != null)   return defaultGroovyImports;
  List<ImportBinding> importBindings=new ArrayList<>();
  Collections.addAll(importBindings,super.getDefaultImports());
  importBindings.add(new ImportBinding(javaIo,true,environment.createPackage(javaIo),null));
  importBindings.add(new ImportBinding(javaNet,true,environment.createPackage(javaNet),null));
  importBindings.add(new ImportBinding(javaUtil,true,environment.createPackage(javaUtil),null));
  importBindings.add(new ImportBinding(groovyLang,true,environment.createPackage(groovyLang),null));
  importBindings.add(new ImportBinding(groovyUtil,true,environment.createPackage(groovyUtil),null));
  importBindings.add(new ImportBinding(javaMathBigDecimal,false,createTypeRef(javaMathBigDecimal),null));
  importBindings.add(new ImportBinding(javaMathBigInteger,false,createTypeRef(javaMathBigInteger),null));
  return defaultGroovyImports=importBindings.toArray(new ImportBinding[importBindings.size()]);
}","@Override protected ImportBinding[] getDefaultImports(){
  if (defaultGroovyImports == null) {
    List<ImportBinding> importBindings=new ArrayList<>(8);
    Collections.addAll(importBindings,super.getDefaultImports());
    importBindings.add(new ImportBinding(javaIo,true,environment.getPackage(javaIo,module()),null));
    importBindings.add(new ImportBinding(javaNet,true,environment.getPackage(javaNet,module()),null));
    importBindings.add(new ImportBinding(javaUtil,true,environment.getPackage(javaUtil,module()),null));
    importBindings.add(new ImportBinding(groovyLang,true,environment.getPackage(groovyLang,module()),null));
    importBindings.add(new ImportBinding(groovyUtil,true,environment.getPackage(groovyUtil,module()),null));
    importBindings.add(new ImportBinding(javaMathBigDecimal,false,environment.getType(javaMathBigDecimal),null));
    importBindings.add(new ImportBinding(javaMathBigInteger,false,environment.getType(javaMathBigInteger),null));
    defaultGroovyImports=importBindings.toArray(new ImportBinding[importBindings.size()]);
  }
  return defaultGroovyImports;
}",0.7208216619981326
185287,"private boolean isTrait(ReferenceBinding referenceBinding){
  if (referenceBinding == null) {
    return false;
  }
  if (toBeInitialized) {
    initialize();
  }
  AnnotationBinding[] annotations=referenceBinding.getAnnotations();
  if (annotations != null) {
    for (    AnnotationBinding annotation : annotations) {
      ReferenceBinding annotationType=annotation.getAnnotationType();
      String annotationName=CharOperation.toString(annotationType.compoundName);
      if (""String_Node_Str"".equals(annotationName)) {
        return true;
      }
      if (lookForTraitAlias && ""String_Node_Str"".equals(annotationName)) {
        return true;
      }
    }
  }
  return false;
}","private boolean isTrait(ReferenceBinding referenceBinding){
  if (referenceBinding != null) {
    if (toBeInitialized) {
      initialize();
    }
    AnnotationBinding[] annotations=referenceBinding.getAnnotations();
    if (annotations != null) {
      for (      AnnotationBinding annotation : annotations) {
        if (annotation != null) {
          ReferenceBinding annotationType=annotation.getAnnotationType();
          String annotationName=CharOperation.toString(annotationType.compoundName);
          if (""String_Node_Str"".equals(annotationName)) {
            return true;
          }
          if (lookForTraitAlias && ""String_Node_Str"".equals(annotationName)) {
            return true;
          }
        }
      }
    }
  }
  return false;
}",0.8603042876901799
185288,"/** 
 * Adds any Groovy-specific method bindings to the set determined by the compiler.
 */
@Override protected MethodBinding[] augmentMethodBindings(MethodBinding[] methodBindings){
  SourceTypeBinding binding=referenceContext.binding;
  if (binding != null && (binding.isAnnotationType() || binding.isInterface()) && !traitHelper.isTrait(binding)) {
    return methodBindings;
  }
  boolean implementsGroovyLangObject=false;
  ReferenceBinding[] superInterfaces=binding.superInterfaces != null ? binding.superInterfaces : new ReferenceBinding[0];
  for (int i=0, n=superInterfaces.length; i < n; i+=1) {
    char[][] interfaceName=superInterfaces[i].compoundName;
    if (CharOperation.equals(interfaceName,GroovyCompilationUnitScope.GROOVY_LANG_GROOVYOBJECT)) {
      implementsGroovyLangObject=true;
      break;
    }
  }
  List<MethodBinding> groovyMethods=new ArrayList<>();
  if (implementsGroovyLangObject) {
    if (debugListener != null) {
      debugListener.record(""String_Node_Str"" + String.valueOf(referenceContext.name) + ""String_Node_Str"");
    }
    TypeBinding bindingJLO=getJavaLangObject();
    TypeBinding bindingJLS=getJavaLangString();
    TypeBinding bindingGLM=getGroovyLangMetaClassBinding();
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},TypeBinding.VOID,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",null,bindingGLM,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingGLM},TypeBinding.VOID,groovyMethods,methodBindings,null);
  }
  if (this.referenceContext instanceof GroovyTypeDeclaration) {
    GroovyTypeDeclaration typeDeclaration=(GroovyTypeDeclaration)this.referenceContext;
    boolean useOldWay=false;
    if (useOldWay) {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        FieldBinding fBinding=typeDeclaration.binding.getField(name.toCharArray(),false);
        if (fBinding != null && !(fBinding.type instanceof MissingTypeBinding)) {
          String getterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
          createMethod(getterName,property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          if (!fBinding.isFinal()) {
            String setterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
            createMethod(setterName,property.isStatic(),""String_Node_Str"",new TypeBinding[]{fBinding.type},TypeBinding.VOID,groovyMethods,methodBindings,typeDeclaration);
          }
          if (fBinding.type == TypeBinding.BOOLEAN) {
            createMethod(""String_Node_Str"" + MetaClassHelper.capitalize(name),property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          }
        }
      }
    }
 else {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        String capitalizedName=MetaClassHelper.capitalize(name);
        createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        if (!Modifier.isFinal(property.getModifiers())) {
          createSetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration,property.getType().getName());
        }
        String propertyType=property.getType().getName();
        if (""String_Node_Str"".equals(propertyType)) {
          createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        }
      }
    }
  }
  Map<String,MethodBinding> methodsMap=new HashMap<>();
  for (  ReferenceBinding face : superInterfaces) {
    if (traitHelper.isTrait(face)) {
      ReferenceBinding helperBinding=traitHelper.getHelperBinding(face);
      for (      MethodBinding method : face.availableMethods()) {
        if (method.isPrivate() || method.isStatic()) {
          continue;
        }
        if (isNotActuallyAbstract(method,helperBinding)) {
          methodsMap.put(getMethodAsString(method),method);
        }
      }
    }
  }
  if (!methodsMap.isEmpty()) {
    Set<String> canBeOverridden=new HashSet<>();
    ReferenceBinding superclass=binding.superclass();
    while (superclass != null) {
      for (      MethodBinding method : superclass.availableMethods()) {
        if (method.isPrivate() || method.isPublic() || method.isStatic()) {
          continue;
        }
        canBeOverridden.add(getMethodAsString(method));
      }
      superclass=superclass.superclass();
    }
    for (    MethodBinding method : methodBindings) {
      canBeOverridden.remove(getMethodAsString(method));
    }
    for (    String key : canBeOverridden) {
      MethodBinding method=methodsMap.get(key);
      if (method != null) {
        method=new MethodBinding(method,binding);
        method.modifiers&=~Modifier.ABSTRACT;
        groovyMethods.add(method);
      }
    }
  }
  MethodBinding[] newMethodBindings=groovyMethods.toArray(new MethodBinding[methodBindings.length + groovyMethods.size()]);
  System.arraycopy(methodBindings,0,newMethodBindings,groovyMethods.size(),methodBindings.length);
  return newMethodBindings;
}","/** 
 * Adds any Groovy-specific method bindings to the set determined by the compiler.
 */
@Override protected MethodBinding[] augmentMethodBindings(MethodBinding[] methodBindings){
  SourceTypeBinding binding=referenceContext.binding;
  if (binding != null && (binding.isAnnotationType() || (binding.isInterface() && !traitHelper.isTrait(binding)))) {
    return methodBindings;
  }
  boolean implementsGroovyLangObject=false;
  ReferenceBinding[] superInterfaces=binding.superInterfaces != null ? binding.superInterfaces : new ReferenceBinding[0];
  for (int i=0, n=superInterfaces.length; i < n; i+=1) {
    char[][] interfaceName=superInterfaces[i].compoundName;
    if (CharOperation.equals(interfaceName,GroovyCompilationUnitScope.GROOVY_LANG_GROOVYOBJECT)) {
      implementsGroovyLangObject=true;
      break;
    }
  }
  List<MethodBinding> groovyMethods=new ArrayList<>();
  if (implementsGroovyLangObject) {
    if (debugListener != null) {
      debugListener.record(""String_Node_Str"" + String.valueOf(referenceContext.name) + ""String_Node_Str"");
    }
    TypeBinding bindingJLO=getJavaLangObject();
    TypeBinding bindingJLS=getJavaLangString();
    TypeBinding bindingGLM=getGroovyLangMetaClassBinding();
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},TypeBinding.VOID,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",null,bindingGLM,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingGLM},TypeBinding.VOID,groovyMethods,methodBindings,null);
  }
  if (this.referenceContext instanceof GroovyTypeDeclaration) {
    GroovyTypeDeclaration typeDeclaration=(GroovyTypeDeclaration)this.referenceContext;
    boolean useOldWay=false;
    if (useOldWay) {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        FieldBinding fBinding=typeDeclaration.binding.getField(name.toCharArray(),false);
        if (fBinding != null && !(fBinding.type instanceof MissingTypeBinding)) {
          String getterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
          createMethod(getterName,property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          if (!fBinding.isFinal()) {
            String setterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
            createMethod(setterName,property.isStatic(),""String_Node_Str"",new TypeBinding[]{fBinding.type},TypeBinding.VOID,groovyMethods,methodBindings,typeDeclaration);
          }
          if (fBinding.type == TypeBinding.BOOLEAN) {
            createMethod(""String_Node_Str"" + MetaClassHelper.capitalize(name),property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          }
        }
      }
    }
 else {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        String capitalizedName=MetaClassHelper.capitalize(name);
        createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        if (!Modifier.isFinal(property.getModifiers())) {
          createSetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration,property.getType().getName());
        }
        String propertyType=property.getType().getName();
        if (""String_Node_Str"".equals(propertyType)) {
          createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        }
      }
    }
  }
  Map<String,MethodBinding> methodsMap=new HashMap<>();
  for (  ReferenceBinding face : superInterfaces) {
    if (traitHelper.isTrait(face)) {
      ReferenceBinding helperBinding=traitHelper.getHelperBinding(face);
      for (      MethodBinding method : face.availableMethods()) {
        if (method.isPrivate() || method.isStatic()) {
          continue;
        }
        if (isNotActuallyAbstract(method,helperBinding)) {
          methodsMap.put(getMethodAsString(method),method);
        }
      }
    }
  }
  if (!methodsMap.isEmpty()) {
    Set<String> canBeOverridden=new HashSet<>();
    ReferenceBinding superclass=binding.superclass();
    while (superclass != null) {
      for (      MethodBinding method : superclass.availableMethods()) {
        if (method.isPrivate() || method.isPublic() || method.isStatic()) {
          continue;
        }
        canBeOverridden.add(getMethodAsString(method));
      }
      superclass=superclass.superclass();
    }
    for (    MethodBinding method : methodBindings) {
      canBeOverridden.remove(getMethodAsString(method));
    }
    for (    String key : canBeOverridden) {
      MethodBinding method=methodsMap.get(key);
      if (method != null) {
        method=new MethodBinding(method,binding);
        method.modifiers&=~Modifier.ABSTRACT;
        groovyMethods.add(method);
      }
    }
  }
  MethodBinding[] newMethodBindings=groovyMethods.toArray(new MethodBinding[methodBindings.length + groovyMethods.size()]);
  System.arraycopy(methodBindings,0,newMethodBindings,groovyMethods.size(),methodBindings.length);
  return newMethodBindings;
}",0.9996512641673932
185289,"public CompilationUnitDeclaration dietParse(ICompilationUnit iCompilationUnit,CompilationResult compilationResult){
  String fileName=String.valueOf(iCompilationUnit.getFileName());
  IPath filePath=new Path(fileName);
  IFile eclipseFile=null;
  if (filePath.segmentCount() > 1 && ResourcesPlugin.getPlugin() != null) {
    eclipseFile=ResourcesPlugin.getWorkspace().getRoot().getFile(filePath);
    IPath location=eclipseFile.getLocation();
    if (location != null) {
      fileName=location.toFile().getAbsolutePath();
    }
  }
  if (problemReporter.referenceContext == null) {
    problemReporter.referenceContext=new ReferenceContextImpl(compilationResult);
  }
  if (compilationUnit == null) {
    if (eclipseFile != null && eclipseFile.getProject().isAccessible() && !JavaCore.create(eclipseFile.getProject()).isOnClasspath(eclipseFile)) {
      compilerOptions.groovyCompilerConfigScript=null;
    }
    compilationUnit=unitFactory.get();
  }
  char[] sourceCode=Optional.ofNullable(iCompilationUnit.getContents()).orElse(CharOperation.NO_CHAR);
  SourceUnit sourceUnit=new EclipseSourceUnit(eclipseFile,fileName,String.valueOf(sourceCode),compilationUnit.isReconcile,compilationUnit.getConfiguration(),compilationUnit.getClassLoader(),new GroovyErrorCollectorForJDT(compilationUnit.getConfiguration()),resolver);
  compilationUnit.addSource(sourceUnit);
  if (requestor instanceof Compiler) {
    Compiler compiler=(Compiler)requestor;
    if (compiler.requestor instanceof AbstractImageBuilder) {
      AbstractImageBuilder builder=(AbstractImageBuilder)compiler.requestor;
      if (builder.notifier != null) {
        compilationUnit.setProgressListener(new ProgressListenerImpl(builder.notifier));
      }
      if (eclipseFile != null) {
        SourceFile sourceFile=(SourceFile)builder.fromIFile(eclipseFile);
        if (sourceFile != null) {
          compilationUnit.getConfiguration().setTargetDirectory(sourceFile.getOutputLocation().toFile());
        }
      }
    }
 else     if (compiler.requestor instanceof BatchCompilerRequestor) {
      Main main=ReflectionUtils.getPrivateField(BatchCompilerRequestor.class,""String_Node_Str"",compiler.requestor);
      if (main != null && main.destinationPath != null && main.destinationPath != Main.NONE) {
        compilationUnit.getConfiguration().setTargetDirectory(main.destinationPath);
      }
    }
  }
  compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(sourceCode);
  GroovyCompilationUnitDeclaration gcuDeclaration=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceCode.length,compilationUnit,sourceUnit,compilerOptions);
  gcuDeclaration.processToPhase(Phases.CONVERSION);
  if (gcuDeclaration.getModuleNode() != null) {
    gcuDeclaration.populateCompilationUnitDeclaration();
    for (    TypeDeclaration decl : gcuDeclaration.types) {
      resolver.record((GroovyTypeDeclaration)decl);
    }
  }
  String projectName=compilerOptions.groovyProjectName;
  if (projectName != null && eclipseFile != null) {
    ScriptFolderSelector scriptFolderSelector=scriptFolderSelectorCache.computeIfAbsent(projectName,GroovyParser::newScriptFolderSelector);
    if (scriptFolderSelector.isScript(eclipseFile)) {
      gcuDeclaration.tagAsScript();
    }
  }
  if (debugRequestor != null) {
    debugRequestor.acceptCompilationUnitDeclaration(gcuDeclaration);
  }
  return gcuDeclaration;
}","public CompilationUnitDeclaration dietParse(ICompilationUnit iCompilationUnit,CompilationResult compilationResult){
  String fileName=String.valueOf(iCompilationUnit.getFileName());
  final IPath filePath=new Path(fileName);
  final IFile eclipseFile;
  final boolean isScript;
  if (filePath.segmentCount() > 1 && ResourcesPlugin.getPlugin() != null) {
    eclipseFile=ResourcesPlugin.getWorkspace().getRoot().getFile(filePath);
    IPath location=eclipseFile.getLocation();
    if (location != null) {
      fileName=location.toFile().getAbsolutePath();
    }
    isScript=isScript(eclipseFile,compilerOptions.groovyProjectName);
  }
 else {
    eclipseFile=null;
    isScript=false;
  }
  if (problemReporter.referenceContext == null) {
    problemReporter.referenceContext=new ReferenceContextImpl(compilationResult);
  }
  if (compilationUnit == null) {
    if (isScript || (eclipseFile != null && eclipseFile.getProject().isAccessible() && !JavaCore.create(eclipseFile.getProject()).isOnClasspath(eclipseFile))) {
      compilerOptions.groovyCompilerConfigScript=null;
    }
    compilationUnit=unitFactory.get();
  }
  char[] sourceCode=Optional.ofNullable(iCompilationUnit.getContents()).orElse(CharOperation.NO_CHAR);
  SourceUnit sourceUnit=new EclipseSourceUnit(eclipseFile,fileName,String.valueOf(sourceCode),compilationUnit.isReconcile,compilationUnit.getConfiguration(),compilationUnit.getClassLoader(),new GroovyErrorCollectorForJDT(compilationUnit.getConfiguration()),resolver);
  compilationUnit.addSource(sourceUnit);
  if (requestor instanceof Compiler) {
    Compiler compiler=(Compiler)requestor;
    if (compiler.requestor instanceof AbstractImageBuilder) {
      AbstractImageBuilder builder=(AbstractImageBuilder)compiler.requestor;
      if (builder.notifier != null) {
        compilationUnit.setProgressListener(new ProgressListenerImpl(builder.notifier));
      }
      if (eclipseFile != null) {
        SourceFile sourceFile=(SourceFile)builder.fromIFile(eclipseFile);
        if (sourceFile != null) {
          compilationUnit.getConfiguration().setTargetDirectory(sourceFile.getOutputLocation().toFile());
        }
      }
    }
 else     if (compiler.requestor instanceof BatchCompilerRequestor) {
      Main main=ReflectionUtils.getPrivateField(BatchCompilerRequestor.class,""String_Node_Str"",compiler.requestor);
      if (main != null && main.destinationPath != null && main.destinationPath != Main.NONE) {
        compilationUnit.getConfiguration().setTargetDirectory(main.destinationPath);
      }
    }
  }
  compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(sourceCode);
  GroovyCompilationUnitDeclaration gcuDeclaration=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceCode.length,compilationUnit,sourceUnit,compilerOptions);
  gcuDeclaration.processToPhase(Phases.CONVERSION);
  if (gcuDeclaration.getModuleNode() != null) {
    gcuDeclaration.populateCompilationUnitDeclaration();
    for (    TypeDeclaration decl : gcuDeclaration.types) {
      resolver.record((GroovyTypeDeclaration)decl);
    }
  }
  if (isScript) {
    gcuDeclaration.tagAsScript();
  }
  if (debugRequestor != null) {
    debugRequestor.acceptCompilationUnitDeclaration(gcuDeclaration);
  }
  return gcuDeclaration;
}",0.8882589885126063
185290,"@Test public void testSpread12(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread12(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7447916666666666
185291,"@Test public void testSpread13(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
  start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread13(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6454183266932271
185292,"@Test public void testSpread10(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread10(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7151162790697675
185293,"@Test public void testSpread11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7447916666666666
185294,"@Test public void testClassReference2(){
  String contents=""String_Node_Str"";
  int textStart=contents.indexOf(""String_Node_Str"");
  int textEnd=textStart + ""String_Node_Str"".length();
  assertType(contents,textStart,textEnd,""String_Node_Str"");
}","@Test public void testClassReference2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertDeclType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.4900662251655629
185295,"@Test public void testClassReference1(){
  String contents=""String_Node_Str"";
  int textStart=contents.indexOf(""String_Node_Str"");
  int textEnd=textStart + ""String_Node_Str"".length();
  assertDeclaringType(contents,textStart,textEnd,""String_Node_Str"",false,true);
}","@Test public void testClassReference1(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), until=start + 9;
  assertDeclaringType(contents,start,until,""String_Node_Str"",false,true);
}",0.8164948453608247
185296,"@Test public void testClassReference4(){
  String contents=""String_Node_Str"";
  int textStart=contents.indexOf(""String_Node_Str"");
  int textEnd=textStart + ""String_Node_Str"".length();
  assertType(contents,textStart,textEnd,""String_Node_Str"");
}","@Test public void testClassReference4(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertDeclType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.4900662251655629
185297,"@Test public void testClassReference3(){
  String contents=""String_Node_Str"";
  int textStart=contents.indexOf(""String_Node_Str"");
  int textEnd=textStart + ""String_Node_Str"".length();
  assertType(contents,textStart,textEnd,""String_Node_Str"");
}","@Test public void testClassReference3(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertDeclType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.4900662251655629
185298,"@Test public void testPattern1(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testPattern1(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6852367688022284
185299,"@Test public void testPattern2(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testPattern2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6852367688022284
185300,"@Test public void testBoolean4(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean4(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185301,"@Test public void testBoolean5(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean5(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185302,"@Test public void testBoolean2(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185303,"@Test public void testBoolean3(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean3(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185304,"@Test public void testSpread7(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread7(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185305,"@Test public void testSpread8(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread8(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185306,"@Test public void testSpread5(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread5(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185307,"@Test public void testSpread6(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread6(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185308,"@Test public void testSpread9(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread9(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185309,"@Test public void testMatcher2(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testMatcher2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185310,"@Test public void testSpread3(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread3(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185311,"@Test public void testSpread4(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread4(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185312,"@Test public void testSpread1(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread1(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185313,"@Test public void testMatcher1(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testMatcher1(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6852367688022284
185314,"@Test public void testSpread2(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + ""String_Node_Str"".length(),""String_Node_Str"");
}","@Test public void testSpread2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7134502923976608
185315,"@Test public void testClassLiteral4(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), end=start + 3;
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testClassLiteral4(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
185316,"@Test public void testClassLiteral3(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), end=start + 3;
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testClassLiteral3(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
185317,"@Test public void testClassLiteral2(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), end=start + 3;
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testClassLiteral2(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
185318,"@Test public void testClassLiteral1(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), end=start + 3;
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testClassLiteral1(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
185319,"@Test public void testClassLiteral5(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str""), end=start + 3;
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testClassLiteral5(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
185320,"@Test public void testBoolean6(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean6(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185321,"@Test public void testBoolean7(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testBoolean7(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.6929577464788732
185322,"public PackageBinding getPackage(char[][] packageName,ModuleBinding moduleBinding){
}","public PackageBinding getPackage(char[][] packageName,ModuleBinding moduleBinding){
  if (packageName != null && packageName.length == 2) {
    PackageBinding parent=getTopLevelPackage(packageName[0]);
    if (parent != null) {
      Binding binding=parent.getTypeOrPackage(packageName[1],moduleBinding);
      if ((binding instanceof PackageBinding) && binding.isValidBinding()) {
        return (PackageBinding)binding;
      }
    }
  }
  org.eclipse.jdt.internal.core.util.Util.log(org.eclipse.core.runtime.IStatus.WARNING,""String_Node_Str"" + CharOperation.toString(packageName));
  return TheNotFoundPackage;
}",0.2428571428571428
185323,"public PackageBinding getPackage(char[][] packageName,ModuleBinding moduleBinding){
}","public PackageBinding getPackage(char[][] packageName,ModuleBinding moduleBinding){
  if (packageName != null && packageName.length == 2) {
    PackageBinding parent=getTopLevelPackage(packageName[0]);
    if (parent != null) {
      Binding binding=parent.getTypeOrPackage(packageName[1],moduleBinding);
      if ((binding instanceof PackageBinding) && binding.isValidBinding()) {
        return (PackageBinding)binding;
      }
    }
  }
  org.eclipse.jdt.internal.core.util.Util.log(org.eclipse.core.runtime.IStatus.WARNING,""String_Node_Str"" + CharOperation.toString(packageName));
  return TheNotFoundPackage;
}",0.2428571428571428
185324,"private GroovyClassLoader[] getProjectGroovyClassLoaders(CompilerConfiguration compilerConfiguration){
  String projectName=compilerOptions.groovyProjectName;
  IProject project=findProject(projectName);
  try {
    IJavaProject javaProject=JavaCore.create(project);
    IClasspathEntry[] classpathEntries=javaProject.exists() ? javaProject.getResolvedClasspath(true) : new IClasspathEntry[0];
    Map.Entry<IClasspathEntry[],GroovyClassLoader[]> entry=projectClassLoaderCache.computeIfAbsent(projectName,key -> {
      Set<String> classPaths=new LinkedHashSet<>(), xformPaths=new LinkedHashSet<>();
      if (javaProject.exists())       calculateClasspath(javaProject,classPaths,xformPaths);
      if (GroovyLogManager.manager.hasLoggers()) {
        GroovyLogManager.manager.log(TraceCategory.AST_TRANSFORM,""String_Node_Str"" + String.join(File.pathSeparator,xformPaths));
      }
      return new java.util.AbstractMap.SimpleEntry<>(classpathEntries,new GroovyClassLoader[]{new GrapeAwareGroovyClassLoader(newClassLoader(classPaths,null),compilerConfiguration),new GroovyClassLoader(newClassLoader(xformPaths,GroovyParser.class.getClassLoader()))});
    }
);
    if (Arrays.equals(classpathEntries,entry.getKey())) {
      return entry.getValue();
    }
 else {
      projectClassLoaderCache.remove(projectName);
      return getProjectGroovyClassLoaders(compilerConfiguration);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + projectName + ""String_Node_Str"",e);
  }
}","private GroovyClassLoader[] getProjectGroovyClassLoaders(CompilerConfiguration compilerConfiguration){
  String projectName=compilerOptions.groovyProjectName;
  IProject project=findProject(projectName);
  try {
    IJavaProject javaProject=JavaCore.create(project);
    IClasspathEntry[] classpathEntries=javaProject.exists() ? javaProject.getResolvedClasspath(true) : new IClasspathEntry[0];
    Map.Entry<IClasspathEntry[],GroovyClassLoader[]> entry=projectClassLoaderCache.computeIfAbsent(projectName,key -> {
      Set<String> classPaths=new LinkedHashSet<>(), xformPaths=new LinkedHashSet<>();
      if (javaProject.exists())       calculateClasspath(javaProject,classPaths,xformPaths);
      if (GroovyLogManager.manager.hasLoggers()) {
        GroovyLogManager.manager.log(TraceCategory.AST_TRANSFORM,""String_Node_Str"" + String.join(File.pathSeparator,xformPaths));
      }
      ClassLoader parentClassLoader=null;
      if (classPaths.stream().anyMatch(path -> path.endsWith(""String_Node_Str""))) {
        parentClassLoader=GroovyParser.class.getClassLoader();
      }
      return new java.util.AbstractMap.SimpleEntry<>(classpathEntries,new GroovyClassLoader[]{new GrapeAwareGroovyClassLoader(newClassLoader(classPaths,parentClassLoader),compilerConfiguration),new GroovyClassLoader(newClassLoader(xformPaths,GroovyParser.class.getClassLoader()))});
    }
);
    if (Arrays.equals(classpathEntries,entry.getKey())) {
      return entry.getValue();
    }
 else {
      projectClassLoaderCache.remove(projectName);
      return getProjectGroovyClassLoaders(compilerConfiguration);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + projectName + ""String_Node_Str"",e);
  }
}",0.9324240545567266
185325,"protected void addError(String msg,ASTNode expr){
  int line=expr.getLineNumber();
  int col=expr.getColumnNumber();
  int start=expr.getStart();
  int end=expr.getEnd() - 1;
  if (expr instanceof ClassNode) {
    ClassNode cn=(ClassNode)expr;
    if (cn.getNameEnd() > 0) {
      start=cn.getNameStart();
      end=cn.getNameEnd();
    }
 else     if (cn.getComponentType() != null) {
      end-=1;
    }
  }
 else   if (expr instanceof DeclarationExpression) {
    DeclarationExpression decl=(DeclarationExpression)expr;
    Expression lhs=decl.getLeftExpression();
    start=lhs.getStart();
    end=lhs instanceof VariableExpression ? start + lhs.getText().length() - 1 : lhs.getEnd() - 1;
  }
  SourceUnit source=getSourceUnit();
  source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new PreciseSyntaxException(msg + '\n',line,col,start,end),source));
}","protected void addError(String msg,ASTNode node){
  int start, end;
  if (node instanceof AnnotatedNode && ((AnnotatedNode)node).getNameEnd() > 0) {
    start=((AnnotatedNode)node).getNameStart();
    end=((AnnotatedNode)node).getNameEnd();
  }
 else   if (!(node instanceof DeclarationExpression)) {
    start=node.getStart();
    end=node.getEnd() - 1;
    if (node instanceof ClassNode && ((ClassNode)node).isArray()) {
      end-=1;
    }
  }
 else {
    addError(msg,((DeclarationExpression)node).getLeftExpression());
    return;
  }
  SourceUnit source=getSourceUnit();
  source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new PreciseSyntaxException(msg + '\n',node.getLineNumber(),node.getColumnNumber(),start,end),source));
}",0.355036855036855
185326,"protected void addTypeError(String msg,ClassNode expr){
  SourceUnit source=getSourceUnit();
  source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new PreciseSyntaxException(msg + '\n',expr.getLineNumber(),expr.getColumnNumber(),expr.getNameStart(),expr.getNameEnd()),source));
}","@Deprecated protected void addTypeError(String msg,ClassNode node){
  addError(msg,node);
}",0.3762886597938144
185327,"@Override public void visitDeclarationExpression(DeclarationExpression expression){
  visitAnnotations(expression);
  super.visitDeclarationExpression(expression);
}","public void visitDeclarationExpression(DeclarationExpression expression){
  visitAnnotations(expression);
  super.visitDeclarationExpression(expression);
}",0.96875
185328,"@Override public void visitConstantExpression(ConstantExpression expression){
  Expression original=expression.getNodeMetaData(ORIGINAL_EXPRESSION);
  if (original != null) {
    original.visit(this);
  }
}","public void visitConstantExpression(ConstantExpression expression){
  Expression original=expression.getNodeMetaData(ORIGINAL_EXPRESSION);
  if (original != null) {
    original.visit(this);
  }
}",0.9751243781094528
185329,"private void checkImplementsAndExtends(ClassNode node){
  ClassNode cn=node.getSuperClass();
  if (cn.isInterface() && !node.isInterface()) {
    addTypeError(""String_Node_Str"" + getDescription(cn) + ""String_Node_Str"",node);
  }
  for (  ClassNode anInterface : node.getInterfaces()) {
    cn=anInterface;
    if (!cn.isInterface()) {
      addTypeError(""String_Node_Str"" + getDescription(cn) + ""String_Node_Str"",node);
    }
  }
}","private void checkImplementsAndExtends(ClassNode node){
  ClassNode cn=node.getSuperClass();
  if (cn.isInterface() && !node.isInterface()) {
    addError(""String_Node_Str"" + getDescription(cn) + ""String_Node_Str"",node);
  }
  for (  ClassNode anInterface : node.getInterfaces()) {
    cn=anInterface;
    if (!cn.isInterface()) {
      addError(""String_Node_Str"" + getDescription(cn) + ""String_Node_Str"",node);
    }
  }
}",0.8899297423887588
185330,"private void addWeakerAccessError(ClassNode cn,MethodNode method,Parameter[] parameters,MethodNode superMethod){
  StringBuilder msg=new StringBuilder();
  msg.append(method.getName());
  appendParamsDescription(parameters,msg);
  msg.append(""String_Node_Str"");
  msg.append(cn.getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.getDeclaringClass().getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.isPublic() ? ""String_Node_Str"" : ""String_Node_Str"");
  addError(msg.toString(),method);
}","private void addWeakerAccessError(ClassNode cn,MethodNode method,Parameter[] parameters,MethodNode superMethod){
  StringBuilder msg=new StringBuilder();
  msg.append(method.getName());
  appendParamsDescription(parameters,msg);
  msg.append(""String_Node_Str"");
  msg.append(cn.getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.getDeclaringClass().getName());
  msg.append(""String_Node_Str"");
  msg.append(superMethod.isPublic() ? ""String_Node_Str"" : (superMethod.isProtected() ? ""String_Node_Str"" : ""String_Node_Str""));
  addError(msg.toString(),method);
}",0.932475884244373
185331,"private void checkMethodForWeakerAccessPrivileges(MethodNode mn,ClassNode cn){
  if (mn.isPublic())   return;
  Parameter[] params=mn.getParameters();
  for (  MethodNode superMethod : cn.getSuperClass().getMethods(mn.getName())) {
    Parameter[] superParams=superMethod.getParameters();
    if (!hasEqualParameterTypes(params,superParams))     continue;
    if ((mn.isPrivate() && !superMethod.isPrivate()) || (mn.isProtected() && superMethod.isPublic())) {
      addWeakerAccessError(cn,mn,params,superMethod);
      return;
    }
  }
}","private void checkMethodForWeakerAccessPrivileges(MethodNode mn,ClassNode cn){
  if (mn.isPublic())   return;
  Parameter[] params=mn.getParameters();
  for (  MethodNode superMethod : cn.getSuperClass().getMethods(mn.getName())) {
    Parameter[] superParams=superMethod.getParameters();
    if (!hasEqualParameterTypes(params,superParams))     continue;
    if ((mn.isPrivate() && !superMethod.isPrivate()) || (mn.isProtected() && !superMethod.isProtected() && !superMethod.isPrivate()) || (!mn.isPrivate() && !mn.isProtected() && !mn.isPublic()&& (superMethod.isPublic() || superMethod.isProtected()))) {
      addWeakerAccessError(cn,mn,params,superMethod);
      return;
    }
  }
}",0.8613376835236541
185332,"private void checkNoAbstractMethodsNonabstractClass(ClassNode node){
  if (isAbstract(node.getModifiers()))   return;
  List<MethodNode> abstractMethods=node.getAbstractMethods();
  if (abstractMethods == null)   return;
  for (  MethodNode method : abstractMethods) {
    MethodNode sameArgsMethod=node.getMethod(method.getName(),method.getParameters());
    if (sameArgsMethod == null || method.getReturnType().equals(sameArgsMethod.getReturnType())) {
      addTypeError(""String_Node_Str"" + ""String_Node_Str"" + getDescription(node) + ""String_Node_Str""+ ""String_Node_Str""+ getDescription(method)+ ""String_Node_Str"",node);
    }
 else {
      addError(""String_Node_Str"" + getDescription(method) + ""String_Node_Str""+ ""String_Node_Str""+ (sameArgsMethod.isStatic() ? ""String_Node_Str"" : ""String_Node_Str"")+ getDescription(sameArgsMethod),method);
    }
  }
}","private void checkNoAbstractMethodsNonabstractClass(ClassNode node){
  if (isAbstract(node.getModifiers()))   return;
  List<MethodNode> abstractMethods=node.getAbstractMethods();
  if (abstractMethods == null)   return;
  for (  MethodNode method : abstractMethods) {
    MethodNode sameArgsMethod=node.getMethod(method.getName(),method.getParameters());
    if (sameArgsMethod == null || method.getReturnType().equals(sameArgsMethod.getReturnType())) {
      addError(""String_Node_Str"" + ""String_Node_Str"" + getDescription(node) + ""String_Node_Str""+ ""String_Node_Str""+ getDescription(method)+ ""String_Node_Str"",node);
    }
 else {
      addError(""String_Node_Str"" + getDescription(method) + ""String_Node_Str""+ ""String_Node_Str""+ (sameArgsMethod.isStatic() ? ""String_Node_Str"" : ""String_Node_Str"")+ getDescription(sameArgsMethod),method);
    }
  }
}",0.629976580796253
185333,"public void addError(String msg,ASTNode expr){
  int line=expr.getLineNumber();
  int col=expr.getColumnNumber();
  int start=expr.getStart();
  int end=expr.getEnd() - 1;
  if (expr instanceof ClassNode) {
    ClassNode cn=(ClassNode)expr;
    if (cn.getNameEnd() > 0) {
      start=cn.getNameStart();
      end=cn.getNameEnd();
    }
  }
 else   if (expr instanceof DeclarationExpression) {
    DeclarationExpression decl=(DeclarationExpression)expr;
    Expression lhs=decl.getLeftExpression();
    start=lhs.getStart();
    end=lhs instanceof VariableExpression ? start + lhs.getText().length() - 1 : lhs.getEnd() - 1;
  }
  SourceUnit source=getSourceUnit();
  source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new PreciseSyntaxException(msg + '\n',line,col,start,end),source));
}","public void addError(String msg,ASTNode node){
  int start, end;
  if (node instanceof AnnotatedNode && ((AnnotatedNode)node).getNameEnd() > 0) {
    start=((AnnotatedNode)node).getNameStart();
    end=((AnnotatedNode)node).getNameEnd();
  }
 else   if (!(node instanceof DeclarationExpression)) {
    start=node.getStart();
    end=node.getEnd() - 1;
  }
 else {
    addError(msg,((DeclarationExpression)node).getLeftExpression());
    return;
  }
  SourceUnit source=getSourceUnit();
  source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new PreciseSyntaxException(msg + '\n',node.getLineNumber(),node.getColumnNumber(),start,end),source));
}",0.3203817314246762
185334,"@Test public void testDelegateAnnotationFromOtherMethod() throws Exception {
  createUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",""String_Node_Str"");
  env.fullBuild();
  expectingNoProblems();
  ClassNode clazz=getClassFromScript(unit);
  MethodNode method=null;
  for (  MethodNode m : clazz.getMethods()) {
    if (""String_Node_Str"".equals(m.getName())) {
      method=m;
    }
  }
  assertAnnotation(""String_Node_Str"",method);
}","@Test public void testDelegateAnnotationFromOtherMethod() throws Exception {
  createUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",""String_Node_Str"");
  env.fullBuild();
  expectingNoProblems();
  MethodNode meth=getClassFromScript(unit).getMethods(""String_Node_Str"").stream().filter(mn -> mn.getParameters()[0].getType().getName().equals(""String_Node_Str"")).findFirst().get();
  assertAnnotation(""String_Node_Str"",meth);
}",0.6402214022140221
185335,"@Test public void testOverriding_FinalMethod2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testOverriding_FinalMethod2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.8396694214876033
185336,"@Test public void testOverriding_FinalMethod1(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testOverriding_FinalMethod1(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8808030112923463
185337,"/** 
 * Wraps up any pending operations for the current phase and switches to the next phase.
 */
public void gotoPhase(int phase) throws CompilationFailedException {
  if (!this.phaseComplete) {
    completePhase();
  }
  this.phase=phase;
  this.phaseComplete=false;
}","/** 
 * Wraps up any pending operations for the current phase and switches to the next phase.
 */
public void gotoPhase(int phase) throws CompilationFailedException {
  if (!phaseComplete) {
    completePhase();
  }
  this.phase=phase;
  phaseComplete=false;
}",0.981132075471698
185338,"/** 
 * Returns the description for the current phase.
 */
public String getPhaseDescription(){
  return Phases.getDescription(this.phase);
}","/** 
 * Returns the description for the current phase.
 */
public String getPhaseDescription(){
  return Phases.getDescription(phase);
}",0.9819494584837544
185339,"/** 
 * A synonym for <code>gotoPhase( phase + 1 )</code>.
 */
public void nextPhase() throws CompilationFailedException {
  gotoPhase(this.phase + 1);
}","/** 
 * A synonym for <code>gotoPhase( phase + 1 )</code>.
 */
public void nextPhase() throws CompilationFailedException {
  gotoPhase(phase + 1);
}",0.9833887043189368
185340,"/** 
 * Returns the current phase.
 */
public int getPhase(){
  return this.phase;
}","/** 
 * Returns the current phase.
 */
public int getPhase(){
  return phase;
}",0.9693251533742332
185341,"/** 
 * Wraps up any pending operations for the current phase and switches to the next phase.
 */
public void gotoPhase(int phase) throws CompilationFailedException {
  if (!this.phaseComplete) {
    completePhase();
  }
  this.phase=phase;
  this.phaseComplete=false;
}","/** 
 * Wraps up any pending operations for the current phase and switches to the next phase.
 */
public void gotoPhase(int phase) throws CompilationFailedException {
  if (!phaseComplete) {
    completePhase();
  }
  this.phase=phase;
  phaseComplete=false;
}",0.981132075471698
185342,"/** 
 * Returns the description for the current phase.
 */
public String getPhaseDescription(){
  return Phases.getDescription(this.phase);
}","/** 
 * Returns the description for the current phase.
 */
public String getPhaseDescription(){
  return Phases.getDescription(phase);
}",0.9819494584837544
185343,"/** 
 * A synonym for <code>gotoPhase( phase + 1 )</code>.
 */
public void nextPhase() throws CompilationFailedException {
  gotoPhase(this.phase + 1);
}","/** 
 * A synonym for <code>gotoPhase( phase + 1 )</code>.
 */
public void nextPhase() throws CompilationFailedException {
  gotoPhase(phase + 1);
}",0.9833887043189368
185344,"/** 
 * Returns the current phase.
 */
public int getPhase(){
  return this.phase;
}","/** 
 * Returns the current phase.
 */
public int getPhase(){
  return phase;
}",0.9693251533742332
185345,"@Ignore @Test public void testDGM28(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testDGM28(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.9708029197080292
185346,"@Test public void testDGM43(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test @Ignore(""String_Node_Str"") public void testDGM43(){
  String contents=""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.9078498293515358
185347,"@Test public void testStaticReference5(){
  String contents=""String_Node_Str"";
  assertKnown(contents,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testStaticReference5(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertKnown(contents,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.7019867549668874
185348,"@Test public void testStaticReference6(){
  String contents=""String_Node_Str"";
  assertUnknown(contents,""String_Node_Str"");
}","@Test public void testStaticReference6(){
  String contents=""String_Node_Str"";
  assertKnown(contents,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.8591549295774648
185349,"/** 
 * Looks for a name within an object expression. It is either in the hierarchy, it is in the variable scope, or it is unknown.
 */
protected TypeLookupResult findTypeForNameWithKnownObjectExpression(String name,ClassNode type,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression,boolean isLhsExpression){
  TypeConfidence confidence0=confidence;
  boolean isFieldAccessDirect=(isThisObjectExpression(scope) ? scope.isFieldAccessDirect() : false);
  ASTNode declaration=findDeclaration(name,declaringType,isLhsExpression,isStaticObjectExpression,isFieldAccessDirect,scope.getMethodCallArgumentTypes());
  ClassNode realDeclaringType;
  VariableInfo variableInfo;
  if (declaration != null) {
    type=getTypeFromDeclaration(declaration,declaringType);
    realDeclaringType=getDeclaringTypeFromDeclaration(declaration,declaringType);
  }
 else   if (""String_Node_Str"".equals(name)) {
    declaration=type=realDeclaringType=declaringType.getGenericsTypes()[0].getType();
  }
 else   if (isPrimaryExpression && (variableInfo=scope.lookupName(name)) != null) {
    type=variableInfo.type;
    realDeclaringType=variableInfo.declaringType;
    declaration=findDeclaration(name,realDeclaringType,isLhsExpression,isStaticObjectExpression,false,scope.getMethodCallArgumentTypes());
    if (declaration == null) {
      declaration=variableInfo.declaringType;
    }
  }
 else   if (""String_Node_Str"".equals(name)) {
    realDeclaringType=VariableScope.CLOSURE_CLASS_NODE;
    declaration=realDeclaringType.getMethods(""String_Node_Str"").get(0);
  }
 else {
    realDeclaringType=declaringType;
    confidence=TypeConfidence.UNKNOWN;
  }
  if (declaration != null) {
    if (!VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && !VariableScope.CLASS_CLASS_NODE.equals(type)) {
      if (declaration instanceof FieldNode) {
        if (isStaticObjectExpression && !((FieldNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (declaration instanceof PropertyNode) {
        FieldNode underlyingField=((PropertyNode)declaration).getField();
        if (underlyingField != null) {
          if (isStaticObjectExpression && !underlyingField.isStatic()) {
            confidence=TypeConfidence.UNKNOWN;
          }
        }
 else         if (isStaticObjectExpression && !((PropertyNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (declaration instanceof MethodNode) {
        if (isStaticObjectExpression && !((MethodNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
 else         if (isLooseMatch(scope.getMethodCallArgumentTypes(),((MethodNode)declaration).getParameters())) {
          confidence=TypeConfidence.LOOSELY_INFERRED;
        }
      }
    }
 else     if (VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && declaration instanceof MethodNode) {
      if (isStaticObjectExpression && !((MethodNode)declaration).isStatic() && isLooseMatch(scope.getMethodCallArgumentTypes(),((MethodNode)declaration).getParameters())) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
  }
  if (confidence == TypeConfidence.UNKNOWN && VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && realDeclaringType.isUsingGenerics()) {
    ClassNode typeParam=realDeclaringType.getGenericsTypes()[0].getType();
    if (!VariableScope.CLASS_CLASS_NODE.equals(typeParam) && !VariableScope.OBJECT_CLASS_NODE.equals(typeParam)) {
      return findTypeForNameWithKnownObjectExpression(name,type,typeParam,scope,confidence0,isStaticObjectExpression,isPrimaryExpression,isLhsExpression);
    }
  }
  return new TypeLookupResult(type,realDeclaringType,declaration,confidence,scope);
}","/** 
 * Looks for a name within an object expression. It is either in the hierarchy, it is in the variable scope, or it is unknown.
 */
protected TypeLookupResult findTypeForNameWithKnownObjectExpression(String name,ClassNode type,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression,boolean isLhsExpression){
  TypeConfidence confidence0=confidence;
  boolean isFieldAccessDirect=(isThisObjectExpression(scope) ? scope.isFieldAccessDirect() : false);
  ASTNode declaration=findDeclaration(name,declaringType,isLhsExpression,isStaticObjectExpression,isFieldAccessDirect,scope.getMethodCallArgumentTypes());
  ClassNode realDeclaringType;
  VariableInfo variableInfo;
  if (declaration != null) {
    type=getTypeFromDeclaration(declaration,declaringType);
    realDeclaringType=getDeclaringTypeFromDeclaration(declaration,declaringType);
  }
 else   if (""String_Node_Str"".equals(name)) {
    declaration=type=realDeclaringType=declaringType.getGenericsTypes()[0].getType();
  }
 else   if (isPrimaryExpression && (variableInfo=scope.lookupName(name)) != null) {
    type=variableInfo.type;
    realDeclaringType=variableInfo.declaringType;
    declaration=findDeclaration(name,realDeclaringType,isLhsExpression,isStaticObjectExpression,false,scope.getMethodCallArgumentTypes());
    if (declaration == null) {
      declaration=variableInfo.declaringType;
    }
  }
 else   if (""String_Node_Str"".equals(name)) {
    realDeclaringType=VariableScope.CLOSURE_CLASS_NODE;
    declaration=realDeclaringType.getMethods(""String_Node_Str"").get(0);
  }
 else {
    realDeclaringType=declaringType;
    confidence=TypeConfidence.UNKNOWN;
  }
  if (declaration != null) {
    if (!VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && !VariableScope.CLASS_CLASS_NODE.equals(type)) {
      if (declaration instanceof FieldNode) {
        if (isStaticObjectExpression && !((FieldNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (declaration instanceof PropertyNode) {
        FieldNode underlyingField=((PropertyNode)declaration).getField();
        if (underlyingField != null) {
          if (isStaticObjectExpression && !underlyingField.isStatic()) {
            confidence=TypeConfidence.UNKNOWN;
          }
        }
 else         if (isStaticObjectExpression && !((PropertyNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (declaration instanceof MethodNode) {
        if (isStaticObjectExpression && !((MethodNode)declaration).isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
 else         if (isLooseMatch(scope.getMethodCallArgumentTypes(),((MethodNode)declaration).getParameters())) {
          confidence=TypeConfidence.LOOSELY_INFERRED;
        }
      }
    }
 else     if (VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && declaration instanceof MethodNode) {
      if (isStaticObjectExpression && !((MethodNode)declaration).isStatic() && isLooseMatch(scope.getMethodCallArgumentTypes(),((MethodNode)declaration).getParameters())) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
  }
  if (confidence == TypeConfidence.UNKNOWN && VariableScope.CLASS_CLASS_NODE.equals(declaringType) && declaringType.isUsingGenerics()) {
    ClassNode typeParam=declaringType.getGenericsTypes()[0].getType();
    if (!VariableScope.CLASS_CLASS_NODE.equals(typeParam) && !VariableScope.OBJECT_CLASS_NODE.equals(typeParam)) {
      return findTypeForNameWithKnownObjectExpression(name,type,typeParam,scope,confidence0,isStaticObjectExpression,isPrimaryExpression,isLhsExpression);
    }
  }
  return new TypeLookupResult(type,realDeclaringType,declaration,confidence,scope);
}",0.9976377952755906
185350,"public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    fixModuleNodeLocations();
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}","public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    fixModuleNodeLocations();
    output.putNodeMetaData(LocationSupport.class,locations);
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}",0.9796054831160148
185351,"public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    fixModuleNodeLocations();
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}","public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    fixModuleNodeLocations();
    output.putNodeMetaData(LocationSupport.class,locations);
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}",0.9796054831160148
185352,"@Override public ModuleNode visitCompilationUnit(CompilationUnitContext ctx){
  this.visit(ctx.packageDeclaration());
  for (  ASTNode e : this.visitStatements(ctx.statements())) {
    if (e instanceof DeclarationListStatement) {
      for (      Statement ds : ((DeclarationListStatement)e).getDeclarationStatements()) {
        moduleNode.addStatement(ds);
      }
    }
 else     if (e instanceof Statement) {
      moduleNode.addStatement((Statement)e);
    }
 else     if (e instanceof MethodNode) {
      moduleNode.addMethod((MethodNode)e);
    }
  }
  for (  ClassNode cl : this.classNodeList) {
    moduleNode.addClass(cl);
  }
  if (this.isPackageInfoDeclaration()) {
    this.addPackageInfoClassNode();
  }
 else {
    if (this.isBlankScript()) {
      this.addEmptyReturnStatement();
    }
  }
  this.configureScriptClassNode();
  if (null != this.numberFormatError) {
    throw createParsingFailedException(this.numberFormatError.getSecond().getMessage(),this.numberFormatError.getFirst());
  }
  moduleNode.setLineNumber(1);
  moduleNode.setColumnNumber(1);
  moduleNode.setEnd(locationSupport.getEnd());
  moduleNode.setLastLineNumber(locationSupport.getEndLine());
  moduleNode.setLastColumnNumber(locationSupport.getEndColumn());
  BlockStatement blockStatement=moduleNode.getStatementBlock();
  if (!blockStatement.isEmpty() || !moduleNode.getMethods().isEmpty()) {
    ASTNode alpha=findAlpha(blockStatement,moduleNode.getMethods());
    ASTNode omega=findOmega(blockStatement,moduleNode.getMethods());
    if (!blockStatement.isEmpty()) {
      blockStatement.setStart(alpha.getStart());
      blockStatement.setLineNumber(alpha.getLineNumber());
      blockStatement.setColumnNumber(alpha.getColumnNumber());
      blockStatement.setEnd(omega.getEnd());
      blockStatement.setLastLineNumber(omega.getLastLineNumber());
      blockStatement.setLastColumnNumber(omega.getLastColumnNumber());
    }
    if (!moduleNode.getClasses().isEmpty()) {
      ClassNode scriptClass=moduleNode.getClasses().get(0);
      scriptClass.setStart(alpha.getStart());
      scriptClass.setLineNumber(alpha.getLineNumber());
      scriptClass.setColumnNumber(alpha.getColumnNumber());
      scriptClass.setEnd(omega.getEnd());
      scriptClass.setLastLineNumber(omega.getLastLineNumber());
      scriptClass.setLastColumnNumber(omega.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",Parameter.EMPTY_ARRAY);
      runMethod.setStart(alpha.getStart());
      runMethod.setLineNumber(alpha.getLineNumber());
      runMethod.setColumnNumber(alpha.getColumnNumber());
      runMethod.setEnd(omega.getEnd());
      runMethod.setLastLineNumber(omega.getLastLineNumber());
      runMethod.setLastColumnNumber(omega.getLastColumnNumber());
    }
  }
  sourceUnit.setComments(lexer.getComments());
  return moduleNode;
}","@Override public ModuleNode visitCompilationUnit(CompilationUnitContext ctx){
  this.visit(ctx.packageDeclaration());
  for (  ASTNode e : this.visitStatements(ctx.statements())) {
    if (e instanceof DeclarationListStatement) {
      for (      Statement ds : ((DeclarationListStatement)e).getDeclarationStatements()) {
        moduleNode.addStatement(ds);
      }
    }
 else     if (e instanceof Statement) {
      moduleNode.addStatement((Statement)e);
    }
 else     if (e instanceof MethodNode) {
      moduleNode.addMethod((MethodNode)e);
    }
  }
  for (  ClassNode cl : this.classNodeList) {
    moduleNode.addClass(cl);
  }
  if (this.isPackageInfoDeclaration()) {
    this.addPackageInfoClassNode();
  }
 else {
    if (this.isBlankScript()) {
      this.addEmptyReturnStatement();
    }
  }
  this.configureScriptClassNode();
  if (null != this.numberFormatError) {
    throw createParsingFailedException(this.numberFormatError.getSecond().getMessage(),this.numberFormatError.getFirst());
  }
  moduleNode.setLineNumber(1);
  moduleNode.setColumnNumber(1);
  moduleNode.setEnd(locationSupport.getEnd());
  moduleNode.setLastLineNumber(locationSupport.getEndLine());
  moduleNode.setLastColumnNumber(locationSupport.getEndColumn());
  BlockStatement blockStatement=moduleNode.getStatementBlock();
  if (!blockStatement.isEmpty() || !moduleNode.getMethods().isEmpty()) {
    ASTNode alpha=findAlpha(blockStatement,moduleNode.getMethods());
    ASTNode omega=findOmega(blockStatement,moduleNode.getMethods());
    if (!blockStatement.isEmpty()) {
      blockStatement.setStart(alpha.getStart());
      blockStatement.setLineNumber(alpha.getLineNumber());
      blockStatement.setColumnNumber(alpha.getColumnNumber());
      blockStatement.setEnd(omega.getEnd());
      blockStatement.setLastLineNumber(omega.getLastLineNumber());
      blockStatement.setLastColumnNumber(omega.getLastColumnNumber());
    }
    if (!moduleNode.getClasses().isEmpty()) {
      ClassNode scriptClass=moduleNode.getClasses().get(0);
      scriptClass.setStart(alpha.getStart());
      scriptClass.setLineNumber(alpha.getLineNumber());
      scriptClass.setColumnNumber(alpha.getColumnNumber());
      scriptClass.setEnd(omega.getEnd());
      scriptClass.setLastLineNumber(omega.getLastLineNumber());
      scriptClass.setLastColumnNumber(omega.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",Parameter.EMPTY_ARRAY);
      runMethod.setStart(alpha.getStart());
      runMethod.setLineNumber(alpha.getLineNumber());
      runMethod.setColumnNumber(alpha.getColumnNumber());
      runMethod.setEnd(omega.getEnd());
      runMethod.setLastLineNumber(omega.getLastLineNumber());
      runMethod.setLastColumnNumber(omega.getLastColumnNumber());
    }
  }
  moduleNode.putNodeMetaData(LocationSupport.class,locationSupport);
  sourceUnit.setComments(lexer.getComments());
  return moduleNode;
}",0.98809318377912
185353,"public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    output.setStart(0);
    output.setLineNumber(1);
    output.setColumnNumber(1);
    output.setEnd(locations.getEnd());
    output.setLastLineNumber(locations.getEndLine());
    output.setLastColumnNumber(locations.getEndColumn());
    BlockStatement blockStatement=output.getStatementBlock();
    if (!blockStatement.isEmpty() || !output.getMethods().isEmpty()) {
      ASTNode first=getFirst(blockStatement,output.getMethods());
      ASTNode last=getLast(blockStatement,output.getMethods());
      if (!blockStatement.isEmpty()) {
        blockStatement.setStart(first.getStart());
        blockStatement.setLineNumber(first.getLineNumber());
        blockStatement.setColumnNumber(first.getColumnNumber());
        blockStatement.setEnd(last.getEnd());
        blockStatement.setLastLineNumber(last.getLastLineNumber());
        blockStatement.setLastColumnNumber(last.getLastColumnNumber());
      }
      if (!output.getClasses().isEmpty()) {
        ClassNode scriptClass=output.getClasses().get(0);
        scriptClass.setStart(first.getStart());
        scriptClass.setLineNumber(first.getLineNumber());
        scriptClass.setColumnNumber(first.getColumnNumber());
        scriptClass.setEnd(last.getEnd());
        scriptClass.setLastLineNumber(last.getLastLineNumber());
        scriptClass.setLastColumnNumber(last.getLastColumnNumber());
        MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",Parameter.EMPTY_ARRAY);
        runMethod.setStart(first.getStart());
        runMethod.setLineNumber(first.getLineNumber());
        runMethod.setColumnNumber(first.getColumnNumber());
        runMethod.setEnd(last.getEnd());
        runMethod.setLastLineNumber(last.getLastLineNumber());
        runMethod.setLastColumnNumber(last.getLastColumnNumber());
      }
    }
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}","public ModuleNode buildAST(SourceUnit sourceUnit,ClassLoader classLoader,Reduction cst) throws ParserException {
  setClassLoader(classLoader);
  makeModule();
  try {
    innerClassCounter=1;
    convertGroovy(ast);
    if (looksBroken(output) && output.getMethods().isEmpty() && sourceUnit.getErrorCollector().hasErrors()) {
      output.setEncounteredUnrecoverableError(true);
    }
    if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {
      if (ast == null && sourceUnit.getErrorCollector().hasErrors()) {
        output.setEncounteredUnrecoverableError(true);
      }
      output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }
    ClassNode scriptClassNode=output.getScriptClassDummy();
    if (scriptClassNode != null) {
      List<Statement> statements=output.getStatementBlock().getStatements();
      if (!statements.isEmpty()) {
        Statement firstStatement=statements.get(0);
        Statement lastStatement=statements.get(statements.size() - 1);
        scriptClassNode.setSourcePosition(firstStatement);
        scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
        scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
      }
    }
    output.setStart(0);
    output.setLineNumber(1);
    output.setColumnNumber(1);
    output.setEnd(locations.getEnd());
    output.setLastLineNumber(locations.getEndLine());
    output.setLastColumnNumber(locations.getEndColumn());
    BlockStatement blockStatement=output.getStatementBlock();
    if (!blockStatement.isEmpty() || !output.getMethods().isEmpty()) {
      ASTNode first=getFirst(blockStatement,output.getMethods());
      ASTNode last=getLast(blockStatement,output.getMethods());
      if (!blockStatement.isEmpty()) {
        blockStatement.setStart(first.getStart());
        blockStatement.setLineNumber(first.getLineNumber());
        blockStatement.setColumnNumber(first.getColumnNumber());
        blockStatement.setEnd(last.getEnd());
        blockStatement.setLastLineNumber(last.getLastLineNumber());
        blockStatement.setLastColumnNumber(last.getLastColumnNumber());
      }
      if (!output.getClasses().isEmpty()) {
        ClassNode scriptClass=output.getClasses().get(0);
        scriptClass.setStart(first.getStart());
        scriptClass.setLineNumber(first.getLineNumber());
        scriptClass.setColumnNumber(first.getColumnNumber());
        scriptClass.setEnd(last.getEnd());
        scriptClass.setLastLineNumber(last.getLastLineNumber());
        scriptClass.setLastColumnNumber(last.getLastColumnNumber());
        MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",Parameter.EMPTY_ARRAY);
        runMethod.setStart(first.getStart());
        runMethod.setLineNumber(first.getLineNumber());
        runMethod.setColumnNumber(first.getColumnNumber());
        runMethod.setEnd(last.getEnd());
        runMethod.setLastLineNumber(last.getLastLineNumber());
        runMethod.setLastColumnNumber(last.getLastColumnNumber());
      }
    }
    output.putNodeMetaData(LocationSupport.class,locations);
  }
 catch (  ASTRuntimeException e) {
    throw new ASTParserException(e.getMessage() + ""String_Node_Str"" + sourceUnit.getName(),e);
  }
  ast=null;
  return output;
}",0.9906685023711184
185354,"public EclipseSourceUnit(IFile resource,String filepath,String string,CompilerConfiguration groovyCompilerConfig,GroovyClassLoader classLoader,ErrorCollector errorCollector,JDTResolver resolver){
  super(filepath,string,groovyCompilerConfig,classLoader,errorCollector);
  this.file=resource;
  this.resolver=resolver;
}","public EclipseSourceUnit(IFile file,String filePath,String sourceCode,boolean isReconcile,CompilerConfiguration compilerConfig,GroovyClassLoader classLoader,ErrorCollector errorCollector,JDTResolver resolver){
  super(filePath,sourceCode,compilerConfig,classLoader,errorCollector);
  this.file=file;
  this.resolver=resolver;
  this.isReconcile=isReconcile;
}",0.8053097345132744
185355,"@Override public CompilationUnitDeclaration newCompilationUnitDeclaration(ICompilationUnit icu,ProblemReporter problemReporter,CompilationResult compilationResult,int sourceLength){
  if (ContentTypeUtils.isGroovyLikeFileName(compilationResult.getFileName())) {
    CompilerConfiguration compilerConfig=newCompilerConfiguration(problemReporter.options,problemReporter);
    GroovyClassLoader classLoader=null;
    ErrorCollector errorCollector=new GroovyErrorCollectorForJDT(compilerConfig);
    SourceUnit groovySourceUnit=new SourceUnit(String.valueOf(compilationResult.getFileName()),String.valueOf(icu.getContents()),compilerConfig,classLoader,errorCollector);
    org.codehaus.groovy.control.CompilationUnit gcu=new org.codehaus.groovy.control.CompilationUnit(compilerConfig);
    JDTResolver resolver=new JDTResolver(gcu);
    gcu.setResolveVisitor(resolver);
    compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(icu.getContents());
    gcu.addSource(groovySourceUnit);
    GroovyCompilationUnitDeclaration decl=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceLength,gcu,groovySourceUnit,problemReporter.options);
    decl.processToPhase(Phases.CONVERSION);
    if (decl.getModuleNode() != null) {
      decl.populateCompilationUnitDeclaration();
      for (      TypeDeclaration type : decl.types) {
        resolver.record((GroovyTypeDeclaration)type);
      }
    }
    return decl;
  }
 else {
    return new CompilationUnitDeclaration(problemReporter,compilationResult,sourceLength);
  }
}","@Override public CompilationUnitDeclaration newCompilationUnitDeclaration(ICompilationUnit icu,ProblemReporter problemReporter,CompilationResult compilationResult,int sourceLength){
  if (ContentTypeUtils.isGroovyLikeFileName(compilationResult.getFileName())) {
    CompilerConfiguration compilerConfig=newCompilerConfiguration(problemReporter.options,problemReporter);
    GroovyClassLoader classLoader=null;
    ErrorCollector errorCollector=new GroovyErrorCollectorForJDT(compilerConfig);
    SourceUnit groovySourceUnit=new SourceUnit(String.valueOf(compilationResult.getFileName()),String.valueOf(icu.getContents()),compilerConfig,classLoader,errorCollector);
    org.codehaus.groovy.control.CompilationUnit gcu=new org.codehaus.groovy.control.CompilationUnit(compilerConfig);
    JDTResolver resolver=new JDTResolver(gcu);
    gcu.setResolveVisitor(resolver);
    gcu.addSource(groovySourceUnit);
    compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(icu.getContents());
    GroovyCompilationUnitDeclaration decl=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceLength,gcu,groovySourceUnit,problemReporter.options);
    decl.processToPhase(Phases.CONVERSION);
    if (decl.getModuleNode() != null) {
      decl.populateCompilationUnitDeclaration();
      for (      TypeDeclaration type : decl.types) {
        resolver.record((GroovyTypeDeclaration)type);
      }
    }
    return decl;
  }
 else {
    return new CompilationUnitDeclaration(problemReporter,compilationResult,sourceLength);
  }
}",0.9762668377164848
185356,"public CompilationUnitDeclaration dietParse(ICompilationUnit sourceUnit,CompilationResult compilationResult){
  char[] sourceCode=sourceUnit.getContents();
  if (sourceCode == null) {
    sourceCode=CharOperation.NO_CHAR;
  }
  ErrorCollector errorCollector=new GroovyErrorCollectorForJDT(compilationUnit.getConfiguration());
  String filepath=null;
  char[] fileName=sourceUnit.getFileName();
  if (sourceUnit instanceof org.eclipse.jdt.internal.compiler.batch.CompilationUnit) {
    filepath=String.valueOf(((org.eclipse.jdt.internal.compiler.batch.CompilationUnit)sourceUnit).fileName);
  }
 else {
    filepath=String.valueOf(fileName);
  }
  IPath path=new Path(filepath);
  IFile eclipseFile=null;
  if (ResourcesPlugin.getPlugin() != null && path.segmentCount() >= 2) {
    eclipseFile=ResourcesPlugin.getWorkspace().getRoot().getFile(path);
    final IPath location=eclipseFile.getLocation();
    if (location != null) {
      filepath=location.toFile().getAbsolutePath();
    }
  }
  SourceUnit groovySourceUnit=new EclipseSourceUnit(eclipseFile,filepath,String.valueOf(sourceCode),compilationUnit.getConfiguration(),compilationUnit.getClassLoader(),errorCollector,this.resolver);
  groovySourceUnit.isReconcile=compilationUnit.isReconcile;
  GroovyCompilationUnitDeclaration gcuDeclaration=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceCode.length,compilationUnit,groovySourceUnit,compilerOptions);
  compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(sourceCode);
  compilationUnit.addSource(groovySourceUnit);
  if (requestor instanceof Compiler) {
    if (((Compiler)requestor).requestor instanceof BatchImageBuilder) {
      BuildNotifier notifier=((BatchImageBuilder)((Compiler)requestor).requestor).notifier;
      if (notifier != null) {
        compilationUnit.setProgressListener(new ProgressListenerImpl(notifier));
      }
    }
  }
  gcuDeclaration.processToPhase(Phases.CONVERSION);
  if (gcuDeclaration.getModuleNode() != null) {
    gcuDeclaration.populateCompilationUnitDeclaration();
    for (    TypeDeclaration decl : gcuDeclaration.types) {
      resolver.record((GroovyTypeDeclaration)decl);
    }
  }
  String projectName=compilerOptions.groovyProjectName;
  if (projectName != null && eclipseFile != null) {
    ScriptFolderSelector scriptFolderSelector=scriptFolderSelectorCache.get(projectName);
    if (scriptFolderSelector == null) {
      scriptFolderSelector=new ScriptFolderSelector(ResourcesPlugin.getWorkspace().getRoot().getProject(projectName));
      scriptFolderSelectorCache.put(projectName,scriptFolderSelector);
    }
    if (scriptFolderSelector.isScript(eclipseFile)) {
      gcuDeclaration.tagAsScript();
    }
  }
  if (debugRequestor != null) {
    debugRequestor.acceptCompilationUnitDeclaration(gcuDeclaration);
  }
  return gcuDeclaration;
}","public CompilationUnitDeclaration dietParse(ICompilationUnit iCompilationUnit,CompilationResult compilationResult){
  String fileName=String.valueOf(iCompilationUnit.getFileName());
  IPath filePath=new Path(fileName);
  IFile eclipseFile=null;
  if (filePath.segmentCount() > 1 && ResourcesPlugin.getPlugin() != null) {
    eclipseFile=ResourcesPlugin.getWorkspace().getRoot().getFile(filePath);
    IPath location=eclipseFile.getLocation();
    if (location != null) {
      fileName=location.toFile().getAbsolutePath();
    }
  }
  char[] sourceCode=iCompilationUnit.getContents();
  if (sourceCode == null) {
    sourceCode=CharOperation.NO_CHAR;
  }
  SourceUnit sourceUnit=new EclipseSourceUnit(eclipseFile,fileName,String.valueOf(sourceCode),compilationUnit.isReconcile,compilationUnit.getConfiguration(),compilationUnit.getClassLoader(),new GroovyErrorCollectorForJDT(compilationUnit.getConfiguration()),resolver);
  compilationUnit.addSource(sourceUnit);
  if (requestor instanceof Compiler) {
    Compiler compiler=(Compiler)requestor;
    if (compiler.requestor instanceof AbstractImageBuilder) {
      AbstractImageBuilder builder=(AbstractImageBuilder)compiler.requestor;
      if (builder.notifier != null) {
        compilationUnit.setProgressListener(new ProgressListenerImpl(builder.notifier));
      }
      if (eclipseFile != null) {
        SourceFile sourceFile=(SourceFile)builder.fromIFile(eclipseFile);
        if (sourceFile != null) {
          compilationUnit.getConfiguration().setTargetDirectory(sourceFile.getOutputLocation().toFile());
        }
      }
    }
 else     if (compiler.requestor instanceof BatchCompilerRequestor) {
      Main main=ReflectionUtils.getPrivateField(BatchCompilerRequestor.class,""String_Node_Str"",compiler.requestor);
      if (main != null && main.destinationPath != null && main.destinationPath != Main.NONE) {
        compilationUnit.getConfiguration().setTargetDirectory(main.destinationPath);
      }
    }
  }
  compilationResult.lineSeparatorPositions=GroovyUtils.getSourceLineSeparatorsIn(sourceCode);
  GroovyCompilationUnitDeclaration gcuDeclaration=new GroovyCompilationUnitDeclaration(problemReporter,compilationResult,sourceCode.length,compilationUnit,sourceUnit,compilerOptions);
  gcuDeclaration.processToPhase(Phases.CONVERSION);
  if (gcuDeclaration.getModuleNode() != null) {
    gcuDeclaration.populateCompilationUnitDeclaration();
    for (    TypeDeclaration decl : gcuDeclaration.types) {
      resolver.record((GroovyTypeDeclaration)decl);
    }
  }
  String projectName=compilerOptions.groovyProjectName;
  if (projectName != null && eclipseFile != null) {
    ScriptFolderSelector scriptFolderSelector=scriptFolderSelectorCache.computeIfAbsent(projectName,GroovyParser::newScriptFolderSelector);
    if (scriptFolderSelector.isScript(eclipseFile)) {
      gcuDeclaration.tagAsScript();
    }
  }
  if (debugRequestor != null) {
    debugRequestor.acceptCompilationUnitDeclaration(gcuDeclaration);
  }
  return gcuDeclaration;
}",0.4055896387184731
185357,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> options,IJavaProject javaProject){
  try {
    IProject project=javaProject.getProject();
    if (isGroovyNaturedProject(project)) {
      options.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,project.getFile(javaProject.getOutputLocation().removeFirstSegments(1)).getRawLocation().toOSString());
      options.put(CompilerOptions.OPTIONG_GroovyProjectName,javaProject.getElementName());
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      if (isProbablyGrailsProject(project)) {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"");
    options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> options,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      options.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,getAbsoluteLocation(javaProject.getOutputLocation(),project));
      options.put(CompilerOptions.OPTIONG_GroovyProjectName,javaProject.getElementName());
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      if (isProbablyGrailsProject(project)) {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"");
    options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9211403184005924
185358,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> options,IJavaProject javaProject){
  try {
    IProject project=javaProject.getProject();
    if (isGroovyNaturedProject(project)) {
      options.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,project.getFile(javaProject.getOutputLocation().removeFirstSegments(1)).getRawLocation().toOSString());
      options.put(CompilerOptions.OPTIONG_GroovyProjectName,javaProject.getElementName());
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      if (isProbablyGrailsProject(project)) {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"");
    options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> options,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      options.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,getAbsoluteLocation(javaProject.getOutputLocation(),project));
      options.put(CompilerOptions.OPTIONG_GroovyProjectName,javaProject.getElementName());
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      if (isProbablyGrailsProject(project)) {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"");
    options.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    options.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9211403184005924
185359,"public int getStart(){
  return start;
}","public int getStart(){
  return offsets[0];
}",0.8705882352941177
185360,"public void setStart(int offset){
  start=offset;
}","public void setStart(int offset){
  offsets[0]=offset;
}",0.897196261682243
185361,"public void setEnd(int offset){
  stop=offset;
}","public void setEnd(int offset){
  offsets[1]=offset;
}",0.9019607843137256
185362,"public int getEnd(){
  return stop;
}","public int getEnd(){
  return offsets[1];
}",0.875
185363,"public int getLength(){
  return (stop > 0 && start >= 0 ? stop - start : -1);
}","public int getLength(){
  return (offsets[1] >= 0 && offsets[0] >= 0 ? offsets[1] - offsets[0] : -1);
}",0.7650273224043715
185364,"/** 
 * Sets the source position using another ASTNode. The sourcePosition consists of a line/column pair for the start and a line/column pair for the end of the expression or statement 
 * @param node - the node used to configure the position information
 */
public void setSourcePosition(ASTNode node){
  this.columnNumber=node.getColumnNumber();
  this.lastLineNumber=node.getLastLineNumber();
  this.lastColumnNumber=node.getLastColumnNumber();
  this.lineNumber=node.getLineNumber();
  this.start=node.getStart();
  this.stop=node.getEnd();
}","/** 
 * Sets the source position using another ASTNode. The sourcePosition consists of a line/column pair for the start and a line/column pair for the end of the expression or statement 
 * @param node - the node used to configure the position information
 */
public void setSourcePosition(ASTNode node){
  this.columnNumber=node.getColumnNumber();
  this.lastLineNumber=node.getLastLineNumber();
  this.lastColumnNumber=node.getLastColumnNumber();
  this.lineNumber=node.getLineNumber();
  this.offsets[0]=node.getStart();
  this.offsets[1]=node.getEnd();
}",0.9737556561085972
185365,"protected static boolean isCompatibleConstantExpression(Expression node,VariableScope scope){
  if (node instanceof ConstantExpression) {
    org.codehaus.groovy.ast.ASTNode enclosingNode=scope.getEnclosingNode();
    if (!(enclosingNode instanceof AttributeExpression || enclosingNode instanceof MethodPointerExpression)) {
      return (VariableScope.STRING_CLASS_NODE.equals(node.getType()) && node.getLength() <= node.getText().length());
    }
  }
  return false;
}","protected static boolean isCompatibleConstantExpression(Expression node,VariableScope scope){
  if (node instanceof ConstantExpression && !scope.isTopLevel()) {
    org.codehaus.groovy.ast.ASTNode enclosingNode=scope.getEnclosingNode();
    if (!(enclosingNode instanceof AttributeExpression || enclosingNode instanceof MethodPointerExpression)) {
      return (VariableScope.STRING_CLASS_NODE.equals(node.getType()) && node.getLength() <= node.getText().length());
    }
  }
  return false;
}",0.9761163032191068
185366,"private void assertKnown(String source,String target,String declaringType,String expressionType){
  int offset=source.lastIndexOf(target);
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",source);
  SearchRequestor requestor=doVisit(offset,offset + target.length(),unit,false);
  Assert.assertNotEquals(TypeLookupResult.TypeConfidence.UNKNOWN,requestor.result.confidence);
  Assert.assertEquals(declaringType,requestor.result.declaringType.getName());
  Assert.assertEquals(expressionType,printTypeName(requestor.result.type));
}","private void assertKnown(String source,String target,String declaringType,String expressionType){
  int offset=source.lastIndexOf(target);
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",source);
  SearchRequestor requestor=doVisit(offset,offset + target.length(),unit,false);
  Assert.assertNotEquals(""String_Node_Str"" + target + ""String_Node_Str""+ offset+ ""String_Node_Str"",TypeLookupResult.TypeConfidence.UNKNOWN,requestor.result.confidence);
  Assert.assertEquals(declaringType,requestor.result.declaringType.getName());
  Assert.assertEquals(expressionType,printTypeName(requestor.result.type));
}",0.9356521739130436
185367,"/** 
 * Supplements   {@link #isTypeCompatible} by supporting unequal lengths andtagging Closure -> SAM type as an inexact match.
 */
protected static boolean isLooseMatch(List<ClassNode> arguments,Parameter[] parameters){
  int argCount=(arguments == null ? -1 : arguments.size());
  if (parameters.length != argCount && !(parameters.length < argCount && GenericsMapper.isVargs(parameters))) {
    return true;
  }
 else   if (argCount > 0 && arguments.get(argCount - 1).equals(VariableScope.CLOSURE_CLASS_NODE)) {
    ClassNode lastType=GroovyUtils.getBaseType(parameters[parameters.length - 1].getType());
    if (!lastType.equals(VariableScope.CLOSURE_CLASS_NODE)) {
      return true;
    }
  }
  return false;
}","/** 
 * Supplements   {@link #isTypeCompatible} by supporting unequal lengths andtagging Closure -> SAM type as an inexact match.
 */
protected static boolean isLooseMatch(List<ClassNode> arguments,Parameter[] parameters){
  int argCount=(arguments == null ? -1 : arguments.size());
  if (parameters.length != argCount && !(GenericsMapper.isVargs(parameters) && (parameters.length - 1 == argCount || parameters.length < argCount))) {
    return true;
  }
 else   if (argCount > 0 && arguments.get(argCount - 1).equals(VariableScope.CLOSURE_CLASS_NODE)) {
    ClassNode lastType=GroovyUtils.getBaseType(parameters[parameters.length - 1].getType());
    if (!lastType.equals(VariableScope.CLOSURE_CLASS_NODE)) {
      return true;
    }
  }
  return false;
}",0.8906992532247114
185368,"/** 
 * Finds param with DelegatesTo.Target annotation that has matching value string.
 */
private int indexOfDelegatesToTarget(Parameter[] parameters,String target){
  for (int i=0, n=parameters.length; i < n; i+=1) {
    List<AnnotationNode> annotations=parameters[i].getAnnotations();
    if (annotations != null && !annotations.isEmpty()) {
      for (      AnnotationNode annotation : annotations) {
        if (annotation.getClassNode().getName().equals(""String_Node_Str"")) {
          if (annotation.getMember(""String_Node_Str"") instanceof ConstantExpression) {
            String value=annotation.getMember(""String_Node_Str"").getText();
            if (value.equals(target)) {
              return i;
            }
          }
        }
      }
    }
  }
  return -1;
}","/** 
 * Finds param with DelegatesTo.Target annotation that has matching value string.
 */
private static int indexOfDelegatesToTarget(Parameter[] parameters,String target,CompilerConfiguration config){
  for (int i=0, n=parameters.length; i < n; i+=1) {
    List<AnnotationNode> annotations=parameters[i].getAnnotations();
    if (annotations != null && !annotations.isEmpty()) {
      for (      AnnotationNode annotation : annotations) {
        if (annotation.getClassNode().getName().equals(""String_Node_Str"")) {
          String value=(String)evaluateExpression(castX(STRING_CLASS_NODE,annotation.getMember(""String_Node_Str"")),config);
          if (value.equals(target)) {
            return i;
          }
        }
      }
    }
  }
  return -1;
}",0.821917808219178
185369,"/** 
 * @param declaringType type that declares {@code declaration} in most cases;if  {@code call} is a category method it's likely the calling objecttype; if  {@code call} is an implicit-this call in a closure, then...
 */
public CallAndType(MethodCallExpression call,ASTNode declaration,ClassNode declaringType,ModuleNode enclosingModule){
  this.call=call;
  this.declaration=declaration;
  this.declaringType=declaringType;
  if (declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)declaration;
    Parameter[] parameters=methodNode.getParameters();
    if (parameters != null && parameters.length > 0) {
      List<Expression> arguments=null;
      if (call.getArguments() instanceof TupleExpression) {
        arguments=((TupleExpression)call.getArguments()).getExpressions();
      }
      if (arguments != null && !arguments.isEmpty()) {
        if (!methodNode.getDeclaringClass().equals(getPerceivedDeclaringType())) {
          List<Expression> categoryMethodArguments=new ArrayList<>(arguments.size() + 1);
          categoryMethodArguments.add(new ClassExpression(declaringType));
          categoryMethodArguments.addAll(arguments);
          arguments=categoryMethodArguments;
        }
        for (int i=0, n=parameters.length; i < n; i+=1) {
          List<AnnotationNode> annotations=parameters[i].getAnnotations();
          if (annotations != null && !annotations.isEmpty()) {
            for (            AnnotationNode annotation : annotations) {
              if (annotation.getClassNode().getName().equals(DELEGATES_TO.getName()) && i < arguments.size() && arguments.get(i) instanceof ClosureExpression) {
                ClosureExpression closure=(ClosureExpression)arguments.get(i);
                Expression delegatesToType=annotation.getMember(""String_Node_Str"");
                Expression delegatesToValue=annotation.getMember(""String_Node_Str"");
                Expression delegatesToTarget=annotation.getMember(""String_Node_Str"");
                Expression delegatesToStrategy=annotation.getMember(""String_Node_Str"");
                Expression delegatesToGenericTypeIndex=annotation.getMember(""String_Node_Str"");
                Integer strategy=null, generics=null;
                if (delegatesToStrategy != null) {
                  strategy=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToStrategy),enclosingModule.getUnit().getConfig());
                }
                if (delegatesToGenericTypeIndex != null) {
                  generics=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToGenericTypeIndex),enclosingModule.getUnit().getConfig());
                }
                if (delegatesToValue instanceof ClassExpression && !delegatesToValue.getType().getName().equals(""String_Node_Str"")) {
                  addDelegatesToClosure(closure,delegatesToValue.getType(),strategy);
                }
 else                 if (delegatesToType instanceof ConstantExpression && !""String_Node_Str"".equals(delegatesToType.getText())) {
                  CompilationUnit compilationUnit=null;
                  ClassNode[] resolved=parseClassNodesFromString(delegatesToType.getText(),enclosingModule.getContext(),compilationUnit,methodNode,delegatesToType);
                  addDelegatesToClosure(closure,resolved[0],strategy);
                }
 else                 if (delegatesToValue == null || (delegatesToValue instanceof ClassExpression && delegatesToValue.getType().getName().equals(""String_Node_Str""))) {
                  int j=indexOfDelegatesToTarget(parameters,delegatesToTarget.getText());
                  if (j >= 0 && j < arguments.size()) {
                    Expression target=arguments.get(j);
                    ClassNode targetType=target.getType();
                    if (generics != null && generics >= 0 && targetType.isUsingGenerics()) {
                      targetType.getGenericsTypes()[generics].getType();
                    }
                    addDelegatesToClosure(closure,targetType,strategy);
                  }
                }
              }
            }
          }
        }
        if (delegatesTo == null) {
          if (arguments.get(0) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && methodNode.getDeclaringClass().getName().equals(""String_Node_Str"")) {
            addDelegatesToClosure((ClosureExpression)arguments.get(0),methodNode.getDeclaringClass(),Closure.OWNER_FIRST);
          }
 else           if (arguments.size() > 1 && arguments.get(1) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && DGM_CLASS_NODE.equals(methodNode.getDeclaringClass())) {
            addDelegatesToClosure((ClosureExpression)arguments.get(1),declaringType,Closure.DELEGATE_FIRST);
          }
        }
      }
    }
  }
  if (delegatesTo == null) {
    delegatesTo=Collections.emptyMap();
  }
}","/** 
 * @param declaringType type that declares {@code declaration} in most cases;if  {@code call} is a category method it's likely the calling objecttype; if  {@code call} is an implicit-this call in a closure, then...
 */
public CallAndType(MethodCallExpression call,ASTNode declaration,ClassNode declaringType,ModuleNode enclosingModule){
  this.call=call;
  this.declaration=declaration;
  this.declaringType=declaringType;
  if (declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)declaration;
    Parameter[] parameters=methodNode.getParameters();
    if (parameters != null && parameters.length > 0) {
      List<Expression> arguments=null;
      if (call.getArguments() instanceof TupleExpression) {
        arguments=((TupleExpression)call.getArguments()).getExpressions();
      }
      if (arguments != null && !arguments.isEmpty()) {
        if (!methodNode.getDeclaringClass().equals(getPerceivedDeclaringType())) {
          List<Expression> categoryMethodArguments=new ArrayList<>(arguments.size() + 1);
          categoryMethodArguments.add(new ClassExpression(declaringType));
          categoryMethodArguments.addAll(arguments);
          arguments=categoryMethodArguments;
        }
        for (int i=0, n=parameters.length; i < n; i+=1) {
          List<AnnotationNode> annotations=parameters[i].getAnnotations();
          if (annotations != null && !annotations.isEmpty()) {
            for (            AnnotationNode annotation : annotations) {
              if (annotation.getClassNode().getName().equals(DELEGATES_TO.getName()) && i < arguments.size() && arguments.get(i) instanceof ClosureExpression) {
                ClosureExpression closure=(ClosureExpression)arguments.get(i);
                CompilerConfiguration config=enclosingModule.getUnit().getConfig();
                Expression delegatesToType=annotation.getMember(""String_Node_Str"");
                Expression delegatesToValue=annotation.getMember(""String_Node_Str"");
                Expression delegatesToTarget=annotation.getMember(""String_Node_Str"");
                Expression delegatesToStrategy=annotation.getMember(""String_Node_Str"");
                Expression delegatesToGenericTypeIndex=annotation.getMember(""String_Node_Str"");
                String typeName=null;
                Integer strategy=null, generics=null;
                if (delegatesToType != null) {
                  typeName=(String)evaluateExpression(castX(STRING_CLASS_NODE,delegatesToType),config);
                }
                if (delegatesToStrategy != null) {
                  strategy=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToStrategy),config);
                }
                if (delegatesToGenericTypeIndex != null) {
                  generics=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToGenericTypeIndex),config);
                }
                if (delegatesToValue instanceof ClassExpression && !delegatesToValue.getType().getName().equals(""String_Node_Str"")) {
                  addDelegatesToClosure(closure,delegatesToValue.getType(),strategy);
                }
 else                 if (typeName != null && !typeName.isEmpty()) {
                  CompilationUnit compilationUnit=null;
                  ClassNode[] resolved=parseClassNodesFromString(typeName,enclosingModule.getContext(),compilationUnit,methodNode,delegatesToType);
                  addDelegatesToClosure(closure,resolved[0],strategy);
                }
 else                 if (delegatesToValue == null || (delegatesToValue instanceof ClassExpression && delegatesToValue.getType().getName().equals(""String_Node_Str""))) {
                  int j=indexOfDelegatesToTarget(parameters,(String)evaluateExpression(castX(STRING_CLASS_NODE,delegatesToTarget),config),config);
                  if (j >= 0 && j < arguments.size()) {
                    Expression target=arguments.get(j);
                    ClassNode targetType=target.getType();
                    if (generics != null && generics >= 0 && targetType.isUsingGenerics()) {
                      targetType.getGenericsTypes()[generics].getType();
                    }
                    addDelegatesToClosure(closure,targetType,strategy);
                  }
                }
              }
            }
          }
        }
        if (delegatesTo == null) {
          if (arguments.get(0) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && methodNode.getDeclaringClass().getName().equals(""String_Node_Str"")) {
            addDelegatesToClosure((ClosureExpression)arguments.get(0),methodNode.getDeclaringClass(),Closure.OWNER_FIRST);
          }
 else           if (arguments.size() > 1 && arguments.get(1) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && DGM_CLASS_NODE.equals(methodNode.getDeclaringClass())) {
            addDelegatesToClosure((ClosureExpression)arguments.get(1),declaringType,Closure.DELEGATE_FIRST);
          }
        }
      }
    }
  }
  if (delegatesTo == null) {
    delegatesTo=Collections.emptyMap();
  }
}",0.9391304347826088
185370,"void bubbleUpdates(){
  if (dirtyNames != null && !dirtyNames.isEmpty() && !isTerminal() && !isTopLevel()) {
    for (    String name : dirtyNames) {
      VariableInfo info=nameVariableMap.get(name);
      parent.updateVariable(name,info.type,info.declaringType);
    }
    dirtyNames=null;
  }
}","void bubbleUpdates(){
  if (dirtyNames != null && !dirtyNames.isEmpty() && !isTerminal() && !isTopLevel()) {
    for (    String name : dirtyNames) {
      VariableInfo info=nameVariableMap.get(name);
      parent.updateVariable(name,info.type,info.declaringType);
    }
  }
  dirtyNames=null;
}",0.9898648648648648
185371,"@Test public void testLocalVar8a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar8a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9699367088607594
185372,"@Test @Ignore(""String_Node_Str"") public void testLocalVar9a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar9a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.8857743517869656
185373,"@Test @Ignore(""String_Node_Str"") public void testInstanceOf11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testInstanceOf11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  start=contents.indexOf(""String_Node_Str"",end + 1);
  end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}",0.9866534849233812
185374,"@Test @Ignore(""String_Node_Str"") public void testLocalVar7a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar7a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9496514329976762
185375,"@Test @Ignore(""String_Node_Str"") public void testLocalVar11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar11(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9838998211091234
185376,"@Test @Ignore(""String_Node_Str"") public void testLocalVar10(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar10(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9831355402873204
185377,"@Test @Ignore(""String_Node_Str"") public void testLocalVar7(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar7(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.937592867756315
185378,"@Test @Ignore(""String_Node_Str"") public void testLocalVar9(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar9(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.8885850991114149
185379,"@Test public void testLocalVar8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9567854435178166
185380,"@Test @Ignore(""String_Node_Str"") public void testLocalVar10a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar10a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9827476038338658
185381,"@Override public void visitIfElse(IfStatement node){
  node.getBooleanExpression().visit(this);
  Map<String,ClassNode[]> types=inferInstanceOfType(node.getBooleanExpression(),scopes.getLast());
  scopes.add(new VariableScope(scopes.getLast(),node.getIfBlock(),false));
  for (  Map.Entry<String,ClassNode[]> entry : types.entrySet()) {
    if (entry.getValue().length > 0 && entry.getValue()[0] != null) {
      scopes.getLast().updateVariableSoft(entry.getKey(),entry.getValue()[0]);
    }
  }
  node.getIfBlock().visit(this);
  scopes.removeLast().bubbleUpdates();
  scopes.add(new VariableScope(scopes.getLast(),node.getElseBlock(),false));
  for (  Map.Entry<String,ClassNode[]> entry : types.entrySet()) {
    if (entry.getValue().length > 1 && entry.getValue()[1] != null) {
      scopes.getLast().updateVariableSoft(entry.getKey(),entry.getValue()[1]);
    }
  }
  node.getElseBlock().visit(this);
  scopes.removeLast().bubbleUpdates();
}","@Override public void visitIfElse(IfStatement node){
  scopes.add(new VariableScope(scopes.getLast(),node,false){
    @Override public void updateVariable(    String name,    ClassNode type,    ClassNode declaringType){
      type=WideningCategories.lowestUpperBound(type,lookupName(name).type);
      super.updateVariable(name,type,declaringType);
    }
  }
);
  node.getBooleanExpression().visit(this);
  Map<String,ClassNode[]> types=inferInstanceOfType(node.getBooleanExpression(),scopes.getLast());
  scopes.add(new VariableScope(scopes.getLast(),node.getIfBlock(),false));
  for (  Map.Entry<String,ClassNode[]> entry : types.entrySet()) {
    if (entry.getValue().length > 0 && entry.getValue()[0] != null) {
      scopes.getLast().updateVariableSoft(entry.getKey(),entry.getValue()[0]);
    }
  }
  node.getIfBlock().visit(this);
  VariableScope trueScope=scopes.removeLast();
  scopes.add(new VariableScope(scopes.getLast(),node.getElseBlock(),false));
  for (  Map.Entry<String,ClassNode[]> entry : types.entrySet()) {
    if (entry.getValue().length > 1 && entry.getValue()[1] != null) {
      scopes.getLast().updateVariableSoft(entry.getKey(),entry.getValue()[1]);
    }
  }
  node.getElseBlock().visit(this);
  VariableScope falseScope=scopes.removeLast();
  trueScope.bubbleUpdates();
  falseScope.bubbleUpdates();
  scopes.removeLast().bubbleUpdates();
}",0.8031088082901554
185382,"@Test public void testDGSMDeclaring3(){
  String contents=""String_Node_Str"";
  String target=""String_Node_Str"";
  int start=contents.lastIndexOf(target), until=start + target.length();
  assertUnknownConfidence(contents,start,until,""String_Node_Str"",false);
}","@Test public void testDGSMDeclaring3(){
  String contents=""String_Node_Str"";
  String target=""String_Node_Str"";
  int start=contents.lastIndexOf(target), until=start + target.length();
  assertDeclaringType(contents,start,until,""String_Node_Str"");
}",0.9330708661417324
185383,"@Test public void testDGMDeclaring3(){
  String contents=""String_Node_Str"";
  String str=""String_Node_Str"";
  int start=contents.lastIndexOf(str);
  int end=start + str.length();
  assertDeclaringType(contents,start,end,""String_Node_Str"");
}","@Test public void testDGMDeclaring3(){
  String contents=""String_Node_Str"";
  String target=""String_Node_Str"";
  int start=contents.lastIndexOf(target), until=start + target.length();
  assertDeclaringType(contents,start,until,""String_Node_Str"");
}",0.8875255623721882
185384,"@Test public void testDGMDeclaring2(){
  String contents=""String_Node_Str"";
  String str=""String_Node_Str"";
  int start=contents.lastIndexOf(str);
  int end=start + str.length();
  assertDeclaringType(contents,start,end,""String_Node_Str"");
}","@Test public void testDGMDeclaring2(){
  String contents=""String_Node_Str"";
  String target=""String_Node_Str"";
  int start=contents.lastIndexOf(target), until=start + target.length();
  assertDeclaringType(contents,start,until,""String_Node_Str"");
}",0.8875255623721882
185385,"@Test public void testDGMDeclaring(){
  String contents=""String_Node_Str"";
  String str=""String_Node_Str"";
  int start=contents.lastIndexOf(str);
  int end=start + str.length();
  assertDeclaringType(contents,start,end,""String_Node_Str"");
}","@Test public void testDGMDeclaring(){
  String contents=""String_Node_Str"";
  String target=""String_Node_Str"";
  int start=contents.lastIndexOf(target), until=start + target.length();
  assertDeclaringType(contents,start,until,""String_Node_Str"");
}",0.8870636550308009
185386,"protected static boolean isCompatibleCategoryMethod(MethodNode method,ClassNode firstArgumentType){
  if (method.isStatic()) {
    Parameter[] paramters=method.getParameters();
    if (paramters != null && paramters.length > 0) {
      ClassNode parameterType=paramters[0].getType();
      if (VariableScope.DGSM_CLASS_NODE.equals(method.getDeclaringClass())) {
        parameterType=VariableScope.newClassClassNode(parameterType);
      }
      if (isTypeCompatible(firstArgumentType,parameterType)) {
        return !isDefaultGroovyMethod(method) || !GroovyUtils.isDeprecated(method);
      }
    }
  }
  return false;
}","protected static boolean isCompatibleCategoryMethod(MethodNode method,ClassNode firstArgumentType){
  if (method.isStatic()) {
    Parameter[] paramters=method.getParameters();
    if (paramters != null && paramters.length > 0) {
      ClassNode parameterType=paramters[0].getType();
      if (VariableScope.CLASS_CLASS_NODE.equals(firstArgumentType) && VariableScope.DGSM_CLASS_NODE.equals(method.getDeclaringClass())) {
        parameterType=VariableScope.newClassClassNode(parameterType);
      }
      if (isTypeCompatible(firstArgumentType,parameterType)) {
        return !isDefaultGroovyMethod(method) || !GroovyUtils.isDeprecated(method);
      }
    }
  }
  return false;
}",0.9478527607361964
185387,"@Test public void testTypeCheckingExtension(){
  Activator.getInstancePreferences().getBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,Activator.DEFAULT_SCRIPT_FILTERS_ENABLED);
  Activator.getInstancePreferences().get(Activator.GROOVY_SCRIPT_FILTERS,Activator.DEFAULT_GROOVY_SCRIPT_FILTER);
  try {
    IPath robotPath=env.addPackage(project.getFolder(""String_Node_Str"").getFullPath(),""String_Node_Str"");
    env.addGroovyClass(robotPath,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Activator.getInstancePreferences().putBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,true);
    Activator.getInstancePreferences().put(Activator.GROOVY_SCRIPT_FILTERS,""String_Node_Str"");
    String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    int start=contents.lastIndexOf(""String_Node_Str"");
    int end=start + ""String_Node_Str"".length();
    assertType(contents,start,end,""String_Node_Str"");
    start=contents.lastIndexOf(""String_Node_Str"");
    end=start + ""String_Node_Str"".length();
    assertType(contents,start,end,""String_Node_Str"");
    env.fullBuild(project.getFullPath());
    Problem[] problems=env.getProblemsFor(project.getFullPath());
    assertEquals(""String_Node_Str"" + Arrays.toString(problems),0,problems.length);
  }
  finally {
    Activator.getInstancePreferences().putBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,Activator.DEFAULT_SCRIPT_FILTERS_ENABLED);
    Activator.getInstancePreferences().put(Activator.GROOVY_SCRIPT_FILTERS,Activator.DEFAULT_GROOVY_SCRIPT_FILTER);
  }
}","@Test public void testTypeCheckingExtension(){
  Activator.getInstancePreferences().getBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,Activator.DEFAULT_SCRIPT_FILTERS_ENABLED);
  Activator.getInstancePreferences().get(Activator.GROOVY_SCRIPT_FILTERS,Activator.DEFAULT_GROOVY_SCRIPT_FILTER);
  try {
    IPath robotPath=env.addPackage(project.getFolder(""String_Node_Str"").getFullPath(),""String_Node_Str"");
    env.addGroovyClass(robotPath,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Activator.getInstancePreferences().putBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,true);
    Activator.getInstancePreferences().put(Activator.GROOVY_SCRIPT_FILTERS,""String_Node_Str"");
    String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    int offset=contents.lastIndexOf(""String_Node_Str"");
    assertType(contents,offset,offset + ""String_Node_Str"".length(),""String_Node_Str"");
    offset=contents.lastIndexOf(""String_Node_Str"");
    assertType(contents,offset,offset + ""String_Node_Str"".length(),""String_Node_Str"");
    env.fullBuild(project.getFullPath());
    Problem[] problems=env.getProblemsFor(project.getFullPath());
    assertEquals(""String_Node_Str"" + Arrays.toString(problems),0,problems.length);
  }
  finally {
    Activator.getInstancePreferences().putBoolean(Activator.GROOVY_SCRIPT_FILTERS_ENABLED,Activator.DEFAULT_SCRIPT_FILTERS_ENABLED);
    Activator.getInstancePreferences().put(Activator.GROOVY_SCRIPT_FILTERS,Activator.DEFAULT_GROOVY_SCRIPT_FILTER);
  }
}",0.9489744872436218
185388,"@Test public void testDelegatesToValue4(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue4(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8455598455598455
185389,"@Test public void testDelegatesToValue5(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue5(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8455598455598455
185390,"@Test public void testDelegatesToValue2(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue2(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8566308243727598
185391,"@Test public void testDelegatesToValue3(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue3(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8566308243727598
185392,"@Test public void testDelegatesToValue(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8561151079136691
185393,"@Test public void testDelegatesToValue6(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int start=contents.lastIndexOf(toFind);
  int end=start + toFind.length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDelegatesToValue6(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  String toFind=""String_Node_Str"";
  int offset=contents.lastIndexOf(toFind);
  assertType(contents,offset,offset + toFind.length(),""String_Node_Str"");
}",0.8455598455598455
185394,"/** 
 * Updates the identifier if it exists in this scope or a parent scope. Otherwise does nothing
 * @param name identifier to update
 * @param type type of identifier
 * @param declaringType declaring type of identifier
 * @return true iff the variable exists in scope and was updated
 */
public boolean updateVariable(String name,ClassNode type,ClassNode declaringType){
  return internalUpdateVariable(name,type,declaringType);
}","/** 
 * Updates the identifier if it exists in this scope or a parent scope. Otherwise does nothing
 * @param name identifier to update
 * @param type type of identifier
 * @param declaringType declaring type of identifier
 */
public void updateVariable(String name,ClassNode type,ClassNode declaringType){
  updateVariableImpl(name,type,declaringType);
}",0.8795944233206591
185395,"/** 
 * @param declaringType type that declares {@code declaration} in most cases;if  {@code call} is a category method it's likely the calling objecttype; if  {@code call} is an implicit-this call in a closure, then...
 */
public CallAndType(MethodCallExpression call,ASTNode declaration,ClassNode declaringType,ModuleNode enclosingModule){
  this.call=call;
  this.declaration=declaration;
  this.declaringType=declaringType;
  if (declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)declaration;
    Parameter[] parameters=methodNode.getParameters();
    if (parameters != null && parameters.length > 0) {
      List<Expression> arguments=null;
      if (call.getArguments() instanceof TupleExpression) {
        arguments=((TupleExpression)call.getArguments()).getExpressions();
      }
      if (arguments != null && !arguments.isEmpty()) {
        if (!methodNode.getDeclaringClass().equals(getPerceivedDeclaringType())) {
          List<Expression> categoryMethodArguments=new ArrayList<>(arguments.size() + 1);
          categoryMethodArguments.add(new ClassExpression(declaringType));
          categoryMethodArguments.addAll(arguments);
          arguments=categoryMethodArguments;
        }
        for (int i=0, n=parameters.length; i < n; i+=1) {
          List<AnnotationNode> annotations=parameters[i].getAnnotations();
          if (annotations != null && !annotations.isEmpty()) {
            for (            AnnotationNode annotation : annotations) {
              if (annotation.getClassNode().getName().equals(DELEGATES_TO.getName()) && i < arguments.size() && arguments.get(i) instanceof ClosureExpression) {
                ClosureExpression closure=(ClosureExpression)arguments.get(i);
                Expression delegatesToType=annotation.getMember(""String_Node_Str"");
                Expression delegatesToValue=annotation.getMember(""String_Node_Str"");
                Expression delegatesToTarget=annotation.getMember(""String_Node_Str"");
                Expression delegatesToStrategy=annotation.getMember(""String_Node_Str"");
                Expression delegatesToGenericTypeIndex=annotation.getMember(""String_Node_Str"");
                Integer strategy=null, generics=null;
                if (delegatesToStrategy instanceof ConstantExpression) {
                  strategy=Integer.valueOf(delegatesToStrategy.getText());
                }
                if (delegatesToGenericTypeIndex instanceof ConstantExpression) {
                  generics=Integer.valueOf(delegatesToGenericTypeIndex.getText());
                }
                if (delegatesToValue instanceof ClassExpression && !delegatesToValue.getType().getName().equals(""String_Node_Str"")) {
                  addDelegatesToClosure(closure,delegatesToValue.getType(),strategy);
                }
 else                 if (delegatesToType instanceof ConstantExpression && !""String_Node_Str"".equals(delegatesToType.getText())) {
                }
 else                 if (delegatesToValue == null || (delegatesToValue instanceof ClassExpression && delegatesToValue.getType().getName().equals(""String_Node_Str""))) {
                  int j=indexOfDelegatesToTarget(parameters,delegatesToTarget.getText());
                  if (j >= 0 && j < arguments.size()) {
                    Expression target=arguments.get(j);
                    ClassNode targetType=target.getType();
                    if (generics != null && generics >= 0 && targetType.isUsingGenerics()) {
                      targetType.getGenericsTypes()[generics].getType();
                    }
                    addDelegatesToClosure(closure,targetType,strategy);
                  }
                }
              }
            }
          }
        }
        if (delegatesTo == null) {
          if (arguments.get(0) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && methodNode.getDeclaringClass().getName().equals(""String_Node_Str"")) {
            addDelegatesToClosure((ClosureExpression)arguments.get(0),methodNode.getDeclaringClass(),Closure.OWNER_FIRST);
          }
 else           if (arguments.size() > 1 && arguments.get(1) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && DGM_CLASS_NODE.equals(methodNode.getDeclaringClass())) {
            addDelegatesToClosure((ClosureExpression)arguments.get(1),declaringType,Closure.DELEGATE_FIRST);
          }
        }
      }
    }
  }
  if (delegatesTo == null) {
    delegatesTo=Collections.emptyMap();
  }
}","/** 
 * @param declaringType type that declares {@code declaration} in most cases;if  {@code call} is a category method it's likely the calling objecttype; if  {@code call} is an implicit-this call in a closure, then...
 */
public CallAndType(MethodCallExpression call,ASTNode declaration,ClassNode declaringType,ModuleNode enclosingModule){
  this.call=call;
  this.declaration=declaration;
  this.declaringType=declaringType;
  if (declaration instanceof MethodNode) {
    MethodNode methodNode=(MethodNode)declaration;
    Parameter[] parameters=methodNode.getParameters();
    if (parameters != null && parameters.length > 0) {
      List<Expression> arguments=null;
      if (call.getArguments() instanceof TupleExpression) {
        arguments=((TupleExpression)call.getArguments()).getExpressions();
      }
      if (arguments != null && !arguments.isEmpty()) {
        if (!methodNode.getDeclaringClass().equals(getPerceivedDeclaringType())) {
          List<Expression> categoryMethodArguments=new ArrayList<>(arguments.size() + 1);
          categoryMethodArguments.add(new ClassExpression(declaringType));
          categoryMethodArguments.addAll(arguments);
          arguments=categoryMethodArguments;
        }
        for (int i=0, n=parameters.length; i < n; i+=1) {
          List<AnnotationNode> annotations=parameters[i].getAnnotations();
          if (annotations != null && !annotations.isEmpty()) {
            for (            AnnotationNode annotation : annotations) {
              if (annotation.getClassNode().getName().equals(DELEGATES_TO.getName()) && i < arguments.size() && arguments.get(i) instanceof ClosureExpression) {
                ClosureExpression closure=(ClosureExpression)arguments.get(i);
                Expression delegatesToType=annotation.getMember(""String_Node_Str"");
                Expression delegatesToValue=annotation.getMember(""String_Node_Str"");
                Expression delegatesToTarget=annotation.getMember(""String_Node_Str"");
                Expression delegatesToStrategy=annotation.getMember(""String_Node_Str"");
                Expression delegatesToGenericTypeIndex=annotation.getMember(""String_Node_Str"");
                Integer strategy=null, generics=null;
                if (delegatesToStrategy != null) {
                  strategy=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToStrategy),enclosingModule.getUnit().getConfig());
                }
                if (delegatesToGenericTypeIndex != null) {
                  generics=(Integer)evaluateExpression(castX(INTEGER_CLASS_NODE,delegatesToGenericTypeIndex),enclosingModule.getUnit().getConfig());
                }
                if (delegatesToValue instanceof ClassExpression && !delegatesToValue.getType().getName().equals(""String_Node_Str"")) {
                  addDelegatesToClosure(closure,delegatesToValue.getType(),strategy);
                }
 else                 if (delegatesToType instanceof ConstantExpression && !""String_Node_Str"".equals(delegatesToType.getText())) {
                  CompilationUnit compilationUnit=null;
                  ClassNode[] resolved=parseClassNodesFromString(delegatesToType.getText(),enclosingModule.getContext(),compilationUnit,methodNode,delegatesToType);
                  addDelegatesToClosure(closure,resolved[0],strategy);
                }
 else                 if (delegatesToValue == null || (delegatesToValue instanceof ClassExpression && delegatesToValue.getType().getName().equals(""String_Node_Str""))) {
                  int j=indexOfDelegatesToTarget(parameters,delegatesToTarget.getText());
                  if (j >= 0 && j < arguments.size()) {
                    Expression target=arguments.get(j);
                    ClassNode targetType=target.getType();
                    if (generics != null && generics >= 0 && targetType.isUsingGenerics()) {
                      targetType.getGenericsTypes()[generics].getType();
                    }
                    addDelegatesToClosure(closure,targetType,strategy);
                  }
                }
              }
            }
          }
        }
        if (delegatesTo == null) {
          if (arguments.get(0) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && methodNode.getDeclaringClass().getName().equals(""String_Node_Str"")) {
            addDelegatesToClosure((ClosureExpression)arguments.get(0),methodNode.getDeclaringClass(),Closure.OWNER_FIRST);
          }
 else           if (arguments.size() > 1 && arguments.get(1) instanceof ClosureExpression && methodNode.getName().matches(""String_Node_Str"") && DGM_CLASS_NODE.equals(methodNode.getDeclaringClass())) {
            addDelegatesToClosure((ClosureExpression)arguments.get(1),declaringType,Closure.DELEGATE_FIRST);
          }
        }
      }
    }
  }
  if (delegatesTo == null) {
    delegatesTo=Collections.emptyMap();
  }
}",0.9112338076024634
185396,"/** 
 * Updates the type info of this variable if it already exists in scope, or just adds it if it doesn't
 */
public void updateOrAddVariable(String name,ClassNode type,ClassNode declaringType){
  if (!internalUpdateVariable(name,type,declaringType)) {
    addVariable(name,type,declaringType);
  }
}","/** 
 * Updates the type info of this variable if it already exists in scope, or just adds it if it doesn't
 */
public void updateOrAddVariable(String name,ClassNode type,ClassNode declaringType){
  if (!updateVariableImpl(name,type,declaringType)) {
    addVariable(name,type,declaringType);
  }
}",0.9766666666666668
185397,"private static PropertyNode createPropertyNodeForMethodNode(MethodNode methodNode){
  ClassNode propertyType=methodNode.getReturnType();
  String methodName=methodNode.getName();
  StringBuffer propertyName=new StringBuffer();
  propertyName.append(Character.toLowerCase(methodName.charAt(3)));
  if (methodName.length() > 4) {
    propertyName.append(methodName.substring(4));
  }
  int mods=methodNode.getModifiers();
  ClassNode declaringClass=methodNode.getDeclaringClass();
  PropertyNode property=new PropertyNode(propertyName.toString(),mods,propertyType,declaringClass,null,null,null);
  property.setDeclaringClass(declaringClass);
  property.getField().setDeclaringClass(declaringClass);
  return property;
}","private static PropertyNode createPropertyNodeForMethodNode(MethodNode methodNode){
  String methodName=methodNode.getName();
  String propertyName=Introspector.decapitalize(methodName.substring(methodName.startsWith(""String_Node_Str"") ? 2 : 3));
  return new PropertyNode(propertyName,methodNode.getModifiers(),methodNode.getReturnType(),methodNode.getDeclaringClass(),null,null,null);
}",0.23710407239819
185398,"public static boolean isVoidOrObject(ClassNode type){
  return type != null && (type.getName().equals(VOID_CLASS_NODE.getName()) || type.getName().equals(VOID_WRAPPER_CLASS_NODE.getName()) || type.getName().equals(OBJECT_CLASS_NODE.getName()));
}","public static boolean isVoidOrObject(ClassNode type){
  return VOID_CLASS_NODE.equals(type) || OBJECT_CLASS_NODE.equals(type);
}",0.6256684491978609
185399,"protected void assertType(String contents,int exprStart,int exprEnd,String expectedType,String extraDocSnippet,boolean forceWorkingCopy){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  assertType(unit,exprStart,exprEnd,expectedType,extraDocSnippet,forceWorkingCopy);
}","public static void assertType(GroovyCompilationUnit unit,int exprStart,int exprEnd,String expectedType,String extraDocSnippet,boolean forceWorkingCopy){
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,forceWorkingCopy);
  Assert.assertNotNull(""String_Node_Str"",requestor.node);
  if (!expectedType.equals(printTypeName(requestor.result.type))) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + expectedType + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.type) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.declaringType) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.node + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.result.confidence + ""String_Node_Str"");
    Assert.fail(sb.toString());
  }
  if (extraDocSnippet != null && (requestor.result.extraDoc == null || !requestor.result.extraDoc.replace(""String_Node_Str"",""String_Node_Str"").contains(extraDocSnippet))) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + extraDocSnippet + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.result.extraDoc + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.node + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.result.confidence + ""String_Node_Str"");
    Assert.fail(sb.toString());
  }
}",0.1036619718309859
185400,"protected void assertTypeOneOf(String contents,int start,int end,String... expectedTypes) throws Throwable {
  boolean ok=false;
  Throwable error=null;
  for (int i=0; !ok && i < expectedTypes.length; i++) {
    try {
      assertType(contents,start,end,expectedTypes[i]);
      ok=true;
    }
 catch (    Throwable e) {
      error=e;
    }
  }
  if (!ok) {
    if (error != null) {
      throw error;
    }
 else {
      fail(""String_Node_Str"");
    }
  }
}","protected void assertTypeOneOf(String contents,int start,int end,String... expectedTypes) throws Throwable {
  boolean ok=false;
  Throwable error=null;
  for (int i=0; !ok && i < expectedTypes.length; i++) {
    try {
      assertType(contents,start,end,expectedTypes[i]);
      ok=true;
    }
 catch (    Throwable e) {
      error=e;
    }
  }
  if (!ok) {
    if (error != null) {
      throw error;
    }
 else {
      Assert.fail(""String_Node_Str"");
    }
  }
}",0.9924487594390508
185401,"protected void assertUnknownConfidence(String contents,int exprStart,int exprEnd,String expectedDeclaringType,boolean forceWorkingCopy){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,forceWorkingCopy);
  assertNotNull(""String_Node_Str"",requestor.node);
  if (requestor.result.confidence != TypeConfidence.UNKNOWN) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + requestor.result.confidence + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + expectedDeclaringType + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.type) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.declaringType) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.node + ""String_Node_Str"");
    fail(sb.toString());
  }
}","protected void assertUnknownConfidence(String contents,int exprStart,int exprEnd,String expectedDeclaringType,boolean forceWorkingCopy){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,forceWorkingCopy);
  Assert.assertNotNull(""String_Node_Str"",requestor.node);
  if (requestor.result.confidence != TypeConfidence.UNKNOWN) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + requestor.result.confidence + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + expectedDeclaringType + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.type) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + printTypeName(requestor.result.declaringType) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + requestor.node + ""String_Node_Str"");
    Assert.fail(sb.toString());
  }
}",0.9922651933701656
185402,"/** 
 * Asserts that the declaration returned at the selection is deprecated Checks only for the deprecated flag, (and so will only succeed for deprecated DSLDs).  Could change this in the future
 */
protected void assertDeprecated(String contents,int exprStart,int exprEnd){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,false);
  assertNotNull(""String_Node_Str"",requestor.node);
  assertTrue(""String_Node_Str"" + requestor.result.declaration,GroovyUtils.isDeprecated(requestor.result.declaration));
}","/** 
 * Asserts that the declaration returned at the selection is deprecated Checks only for the deprecated flag, (and so will only succeed for deprecated DSLDs).  Could change this in the future
 */
protected void assertDeprecated(String contents,int exprStart,int exprEnd){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,false);
  Assert.assertNotNull(""String_Node_Str"",requestor.node);
  Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,GroovyUtils.isDeprecated(requestor.result.declaration));
}",0.988135593220339
185403,"protected void assertDeclaringType(String contents,int exprStart,int exprEnd,String expectedDeclaringType,boolean forceWorkingCopy,boolean expectingUnknown){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,forceWorkingCopy);
  assertNotNull(""String_Node_Str"",requestor.node);
  if (!expectedDeclaringType.equals(requestor.getDeclaringTypeName())) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(requestor.node);
    fail(sb.toString());
  }
  if (expectingUnknown) {
    if (requestor.result.confidence != TypeConfidence.UNKNOWN) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"").append(requestor.result.confidence).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(requestor.node);
      fail(sb.toString());
    }
  }
 else {
    if (requestor.result.confidence == TypeConfidence.UNKNOWN) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(requestor.node);
      fail(sb.toString());
    }
  }
}","protected void assertDeclaringType(String contents,int exprStart,int exprEnd,String expectedDeclaringType,boolean forceWorkingCopy,boolean expectingUnknown){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,forceWorkingCopy);
  Assert.assertNotNull(""String_Node_Str"",requestor.node);
  if (!expectedDeclaringType.equals(requestor.getDeclaringTypeName())) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(requestor.node);
    Assert.fail(sb.toString());
  }
  if (expectingUnknown) {
    if (requestor.result.confidence != TypeConfidence.UNKNOWN) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"").append(requestor.result.confidence).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(requestor.node);
      Assert.fail(sb.toString());
    }
  }
 else {
    if (requestor.result.confidence == TypeConfidence.UNKNOWN) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(expectedDeclaringType).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.type)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(printTypeName(requestor.result.declaringType)).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(requestor.node);
      Assert.fail(sb.toString());
    }
  }
}",0.9934055581723976
185404,"protected <N extends ASTNode>N assertDeclaration(String contents,int exprStart,int exprEnd,String expectedDeclaringType,String declarationName,DeclarationKind kind){
  assertDeclaringType(contents,exprStart,exprEnd,expectedDeclaringType,false,false);
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,false);
switch (kind) {
case CLASS:
    assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof ClassNode);
  assertEquals(""String_Node_Str"",declarationName,((ClassNode)requestor.result.declaration).getName());
break;
case FIELD:
assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof FieldNode);
assertEquals(""String_Node_Str"",declarationName,((FieldNode)requestor.result.declaration).getName());
break;
case METHOD:
assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof MethodNode);
assertEquals(""String_Node_Str"",declarationName,((MethodNode)requestor.result.declaration).getName());
break;
case PROPERTY:
assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof PropertyNode);
assertEquals(""String_Node_Str"",declarationName,((PropertyNode)requestor.result.declaration).getName());
break;
case VARIABLE:
assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof Variable && !(requestor.result.declaration instanceof FieldNode || requestor.result.declaration instanceof PropertyNode));
assertEquals(""String_Node_Str"",declarationName,((Variable)requestor.result.declaration).getName());
break;
}
@SuppressWarnings(""String_Node_Str"") N decl=(N)requestor.result.declaration;
return decl;
}","protected <N extends ASTNode>N assertDeclaration(String contents,int exprStart,int exprEnd,String expectedDeclaringType,String declarationName,DeclarationKind kind){
  assertDeclaringType(contents,exprStart,exprEnd,expectedDeclaringType,false,false);
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  SearchRequestor requestor=doVisit(exprStart,exprEnd,unit,false);
switch (kind) {
case CLASS:
    Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof ClassNode);
  Assert.assertEquals(""String_Node_Str"",declarationName,((ClassNode)requestor.result.declaration).getName());
break;
case FIELD:
Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof FieldNode);
Assert.assertEquals(""String_Node_Str"",declarationName,((FieldNode)requestor.result.declaration).getName());
break;
case METHOD:
Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof MethodNode);
Assert.assertEquals(""String_Node_Str"",declarationName,((MethodNode)requestor.result.declaration).getName());
break;
case PROPERTY:
Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof PropertyNode);
Assert.assertEquals(""String_Node_Str"",declarationName,((PropertyNode)requestor.result.declaration).getName());
break;
case VARIABLE:
Assert.assertTrue(""String_Node_Str"" + requestor.result.declaration,requestor.result.declaration instanceof Variable && !(requestor.result.declaration instanceof FieldNode || requestor.result.declaration instanceof PropertyNode));
Assert.assertEquals(""String_Node_Str"",declarationName,((Variable)requestor.result.declaration).getName());
break;
}
@SuppressWarnings(""String_Node_Str"") N decl=(N)requestor.result.declaration;
return decl;
}",0.9807903402854008
185405,"@Test public void testListRemove(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"") + 2;
  MethodNode m=assertDeclaration(contents,offset,offset + ""String_Node_Str"".length(),""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  assertEquals(""String_Node_Str"",""String_Node_Str"",printTypeName(m.getParameters()[0].getType()));
}","@Test public void testListRemove(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"") + 2;
  MethodNode m=assertDeclaration(contents,offset,offset + ""String_Node_Str"".length(),""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",printTypeName(m.getParameters()[0].getType()));
}",0.9938434476693052
185406,"@Test public void testMethodOverloadsAndPerfectArgumentMatching(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  assertTrue(""String_Node_Str"",m.getParameters().length == 3 && m.getParameters()[2].getType().getNameWithoutPackage().equals(""String_Node_Str""));
}","@Test public void testMethodOverloadsAndPerfectArgumentMatching(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  Assert.assertTrue(""String_Node_Str"",m.getParameters().length == 3 && m.getParameters()[2].getType().getNameWithoutPackage().equals(""String_Node_Str""));
}",0.995855535820012
185407,"@Test public void testMethodOverloadsAndImperfectArgumentMatching(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  assertEquals(""String_Node_Str"",3,m.getParameters().length);
}","@Test public void testMethodOverloadsAndImperfectArgumentMatching(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  Assert.assertEquals(""String_Node_Str"",3,m.getParameters().length);
}",0.995162404975812
185408,"@Test public void testListSort2(){
  String contents=""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 4,""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  assertEquals(""String_Node_Str"",""String_Node_Str"",printTypeName(m.getParameters()[0].getType()));
}","@Test public void testListSort2(){
  String contents=""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 4,""String_Node_Str"");
  MethodNode m=assertDeclaration(contents,offset,offset + 4,""String_Node_Str"",""String_Node_Str"",DeclarationKind.METHOD);
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",printTypeName(m.getParameters()[0].getType()));
}",0.9914738124238732
185409,"public final ReferenceBinding getGroovyLangMetaClassBinding(){
  CompilationUnitScope unitScope=compilationUnitScope();
  unitScope.recordQualifiedReference(GROOVY_LANG_METACLASS);
  return unitScope.environment.getResolvedType(GROOVY_LANG_METACLASS,this);
}","public final ReferenceBinding getGroovyLangMetaClassBinding(){
  CompilationUnitScope unitScope=compilationUnitScope();
  unitScope.recordQualifiedReference(GroovyCompilationUnitScope.GROOVY_LANG_METACLASS);
  return unitScope.environment.getResolvedType(GroovyCompilationUnitScope.GROOVY_LANG_METACLASS,this);
}",0.9052631578947368
185410,"/** 
 * Add any groovy specific method bindings to the set determined by the compiler. These
 */
@Override protected MethodBinding[] augmentMethodBindings(MethodBinding[] methodBindings){
  SourceTypeBinding binding=this.referenceContext.binding;
  if (binding != null && (binding.isAnnotationType() || binding.isInterface())) {
    return methodBindings;
  }
  boolean implementsGroovyLangObject=false;
  ReferenceBinding[] superInterfaces=binding.superInterfaces;
  if (superInterfaces != null) {
    for (int i=0, max=superInterfaces.length; i < max; i++) {
      char[][] interfaceName=superInterfaces[i].compoundName;
      if (CharOperation.equals(interfaceName,GROOVY_LANG_GROOVYOBJECT)) {
        implementsGroovyLangObject=true;
        break;
      }
    }
  }
  List<MethodBinding> groovyMethods=new ArrayList<>();
  if (implementsGroovyLangObject) {
    if (debugListener != null) {
      debugListener.record(""String_Node_Str"" + new String(referenceContext.name) + ""String_Node_Str"");
    }
    TypeBinding bindingJLO=getJavaLangObject();
    TypeBinding bindingJLS=getJavaLangString();
    TypeBinding bindingGLM=getGroovyLangMetaClassBinding();
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},TypeBinding.VOID,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",null,bindingGLM,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingGLM},TypeBinding.VOID,groovyMethods,methodBindings,null);
  }
  if (this.referenceContext instanceof GroovyTypeDeclaration) {
    GroovyTypeDeclaration typeDeclaration=(GroovyTypeDeclaration)this.referenceContext;
    boolean useOldWay=false;
    if (useOldWay) {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        FieldBinding fBinding=typeDeclaration.binding.getField(name.toCharArray(),false);
        if (fBinding != null && !(fBinding.type instanceof MissingTypeBinding)) {
          String getterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
          createMethod(getterName,property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          if (!fBinding.isFinal()) {
            String setterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
            createMethod(setterName,property.isStatic(),""String_Node_Str"",new TypeBinding[]{fBinding.type},TypeBinding.VOID,groovyMethods,methodBindings,typeDeclaration);
          }
          if (fBinding.type == TypeBinding.BOOLEAN) {
            createMethod(""String_Node_Str"" + MetaClassHelper.capitalize(name),property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          }
        }
      }
    }
 else {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        String capitalizedName=MetaClassHelper.capitalize(name);
        createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        if (!Modifier.isFinal(property.getModifiers())) {
          createSetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration,property.getType().getName());
        }
        String propertyType=property.getType().getName();
        if (propertyType.equals(""String_Node_Str"")) {
          createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        }
      }
    }
  }
  Map<String,MethodBinding> methodsMap=new HashMap<>();
  for (  ReferenceBinding i : superInterfaces) {
    if (traitHelper.isTrait(i)) {
      ReferenceBinding helperBinding=traitHelper.getHelperBinding(i);
      for (      MethodBinding method : i.availableMethods()) {
        if (method.isPrivate() || method.isStatic()) {
          continue;
        }
        if (isNotActuallyAbstract(method,helperBinding)) {
          methodsMap.put(getMethodAsString(method),method);
        }
      }
    }
  }
  if (!methodsMap.isEmpty()) {
    Set<String> canBeOverridden=new HashSet<>();
    ReferenceBinding superclass=binding.superclass();
    while (superclass != null) {
      for (      MethodBinding method : superclass.availableMethods()) {
        if (method.isPrivate() || method.isPublic() || method.isStatic()) {
          continue;
        }
        canBeOverridden.add(getMethodAsString(method));
      }
      superclass=superclass.superclass();
    }
    for (    MethodBinding method : methodBindings) {
      canBeOverridden.remove(getMethodAsString(method));
    }
    for (    String key : canBeOverridden) {
      MethodBinding method=methodsMap.get(key);
      if (method != null) {
        method=new MethodBinding(method,binding);
        method.modifiers&=~Modifier.ABSTRACT;
        groovyMethods.add(method);
      }
    }
  }
  MethodBinding[] newMethodBindings=groovyMethods.toArray(new MethodBinding[methodBindings.length + groovyMethods.size()]);
  System.arraycopy(methodBindings,0,newMethodBindings,groovyMethods.size(),methodBindings.length);
  return newMethodBindings;
}","/** 
 * Adds any Groovy-specific method bindings to the set determined by the compiler.
 */
@Override protected MethodBinding[] augmentMethodBindings(MethodBinding[] methodBindings){
  SourceTypeBinding binding=referenceContext.binding;
  if (binding != null && (binding.isAnnotationType() || binding.isInterface())) {
    return methodBindings;
  }
  boolean implementsGroovyLangObject=false;
  ReferenceBinding[] superInterfaces=binding.superInterfaces != null ? binding.superInterfaces : new ReferenceBinding[0];
  for (int i=0, n=superInterfaces.length; i < n; i+=1) {
    char[][] interfaceName=superInterfaces[i].compoundName;
    if (CharOperation.equals(interfaceName,GroovyCompilationUnitScope.GROOVY_LANG_GROOVYOBJECT)) {
      implementsGroovyLangObject=true;
      break;
    }
  }
  List<MethodBinding> groovyMethods=new ArrayList<>();
  if (implementsGroovyLangObject) {
    if (debugListener != null) {
      debugListener.record(""String_Node_Str"" + String.valueOf(referenceContext.name) + ""String_Node_Str"");
    }
    TypeBinding bindingJLO=getJavaLangObject();
    TypeBinding bindingJLS=getJavaLangString();
    TypeBinding bindingGLM=getGroovyLangMetaClassBinding();
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS},bindingJLO,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingJLS,bindingJLO},TypeBinding.VOID,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",null,bindingGLM,groovyMethods,methodBindings,null);
    createMethod(""String_Node_Str"",false,""String_Node_Str"",new TypeBinding[]{bindingGLM},TypeBinding.VOID,groovyMethods,methodBindings,null);
  }
  if (this.referenceContext instanceof GroovyTypeDeclaration) {
    GroovyTypeDeclaration typeDeclaration=(GroovyTypeDeclaration)this.referenceContext;
    boolean useOldWay=false;
    if (useOldWay) {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        FieldBinding fBinding=typeDeclaration.binding.getField(name.toCharArray(),false);
        if (fBinding != null && !(fBinding.type instanceof MissingTypeBinding)) {
          String getterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
          createMethod(getterName,property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          if (!fBinding.isFinal()) {
            String setterName=""String_Node_Str"" + MetaClassHelper.capitalize(name);
            createMethod(setterName,property.isStatic(),""String_Node_Str"",new TypeBinding[]{fBinding.type},TypeBinding.VOID,groovyMethods,methodBindings,typeDeclaration);
          }
          if (fBinding.type == TypeBinding.BOOLEAN) {
            createMethod(""String_Node_Str"" + MetaClassHelper.capitalize(name),property.isStatic(),""String_Node_Str"",null,fBinding.type,groovyMethods,methodBindings,typeDeclaration);
          }
        }
      }
    }
 else {
      List<PropertyNode> properties=typeDeclaration.properties;
      for (      PropertyNode property : properties) {
        String name=property.getName();
        String capitalizedName=MetaClassHelper.capitalize(name);
        createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        if (!Modifier.isFinal(property.getModifiers())) {
          createSetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration,property.getType().getName());
        }
        String propertyType=property.getType().getName();
        if (propertyType.equals(""String_Node_Str"")) {
          createGetterMethod(name,""String_Node_Str"" + capitalizedName,property.isStatic(),groovyMethods,methodBindings,typeDeclaration);
        }
      }
    }
  }
  Map<String,MethodBinding> methodsMap=new HashMap<>();
  for (  ReferenceBinding face : superInterfaces) {
    if (traitHelper.isTrait(face)) {
      ReferenceBinding helperBinding=traitHelper.getHelperBinding(face);
      for (      MethodBinding method : face.availableMethods()) {
        if (method.isPrivate() || method.isStatic()) {
          continue;
        }
        if (isNotActuallyAbstract(method,helperBinding)) {
          methodsMap.put(getMethodAsString(method),method);
        }
      }
    }
  }
  if (!methodsMap.isEmpty()) {
    Set<String> canBeOverridden=new HashSet<>();
    ReferenceBinding superclass=binding.superclass();
    while (superclass != null) {
      for (      MethodBinding method : superclass.availableMethods()) {
        if (method.isPrivate() || method.isPublic() || method.isStatic()) {
          continue;
        }
        canBeOverridden.add(getMethodAsString(method));
      }
      superclass=superclass.superclass();
    }
    for (    MethodBinding method : methodBindings) {
      canBeOverridden.remove(getMethodAsString(method));
    }
    for (    String key : canBeOverridden) {
      MethodBinding method=methodsMap.get(key);
      if (method != null) {
        method=new MethodBinding(method,binding);
        method.modifiers&=~Modifier.ABSTRACT;
        groovyMethods.add(method);
      }
    }
  }
  MethodBinding[] newMethodBindings=groovyMethods.toArray(new MethodBinding[methodBindings.length + groovyMethods.size()]);
  System.arraycopy(methodBindings,0,newMethodBindings,groovyMethods.size(),methodBindings.length);
  return newMethodBindings;
}",0.9817829798468716
185411,"@Test @Ignore(""String_Node_Str"") public void testLocalVar8a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar8a(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.979683972911964
185412,"@Test public void testLocalVar14(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testLocalVar14(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.9404761904761904
185413,"@Test public void testLocalVar12(){
  String contents=""String_Node_Str"" + ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testLocalVar12(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.2580037664783427
185414,"@Test @Ignore(""String_Node_Str"") public void testLocalVar8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}","@Test public void testLocalVar8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.indexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
  offset=contents.indexOf(""String_Node_Str"",offset + 1);
  assertType(contents,offset,offset + 1,""String_Node_Str"");
}",0.9807555238774056
185415,"@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  boolean doCheck=false;
  boolean isAssignment=false;
  boolean isDeclaration=false;
  int start=0;
  int end=0;
  if (node instanceof ConstantExpression) {
    if (fieldName.equals(((ConstantExpression)node).getText()) && (result.confidence == TypeConfidence.UNKNOWN || result.declaringType.getField(fieldName) != null || result.declaringType.getProperty(fieldName) != null)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldExpression) {
    if (fieldName.equals(((FieldExpression)node).getFieldName())) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=end - fieldName.length();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldNode) {
    FieldNode fnode=(FieldNode)node;
    if (fieldName.equals(fnode.getName())) {
      doCheck=true;
      isAssignment=true;
      isDeclaration=true;
      start=fnode.getNameStart();
      end=fnode.getNameEnd() + 1;
    }
  }
 else   if (node instanceof VariableExpression) {
    String vname=((VariableExpression)node).getName();
    if (fieldName.equals(vname)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=start + vname.length();
    }
  }
  if (doCheck && end > 0 && result.declaringType != null) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      boolean isCompleteMatch=qualifiedNameMatches(GroovyUtils.getBaseType(result.declaringType));
      if (isCompleteMatch && ((isAssignment && writeAccess) || (!isAssignment && readAccess) || (isDeclaration && findDeclarations))) {
        SearchMatch match=null;
        IJavaElement realElement=enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy ? ((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement) : enclosingElement;
        if (isDeclaration && findDeclarations) {
          match=new FieldDeclarationMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,realElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new FieldReferenceMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,!isAssignment,isAssignment,false,participant,realElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + realElement + ""String_Node_Str""+ realElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  boolean doCheck=false;
  boolean isAssignment=false;
  boolean isDeclaration=false;
  int start=0;
  int end=0;
  if (node instanceof ConstantExpression) {
    if (fieldName.equals(((ConstantExpression)node).getText()) && (result.confidence == TypeConfidence.UNKNOWN || result.declaringType.getField(fieldName) != null || result.declaringType.getProperty(fieldName) != null)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldExpression) {
    if (fieldName.equals(((FieldExpression)node).getFieldName())) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getEnd() - fieldName.length();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldNode) {
    FieldNode fnode=(FieldNode)node;
    if (fieldName.equals(fnode.getName())) {
      doCheck=true;
      isAssignment=true;
      isDeclaration=true;
      start=fnode.getNameStart();
      end=fnode.getNameEnd() + 1;
    }
  }
 else   if (node instanceof VariableExpression) {
    if (fieldName.equals(((VariableExpression)node).getName()) && (result.declaration instanceof FieldNode || result.declaration instanceof PropertyNode)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=node.getEnd();
    }
  }
  if (doCheck && end > 0 && result.declaringType != null) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      boolean isCompleteMatch=qualifiedNameMatches(GroovyUtils.getBaseType(result.declaringType));
      if (isCompleteMatch && ((isAssignment && writeAccess) || (!isAssignment && readAccess) || (isDeclaration && findDeclarations))) {
        SearchMatch match=null;
        if (enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy)         enclosingElement=((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement);
        if (isDeclaration && findDeclarations) {
          match=new FieldDeclarationMatch(enclosingElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,enclosingElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new FieldReferenceMatch(enclosingElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,!isAssignment,isAssignment,false,participant,enclosingElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + enclosingElement + ""String_Node_Str""+ enclosingElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.9434881455017864
185416,"protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    VariableScope outer=(VariableScope)owner.getNodeMetaData(""String_Node_Str"");
    if (outer != null) {
      if (isLhsExpr)       scope.getWormhole().put(""String_Node_Str"",var);
      VariableScope.CallAndType cat=outer.getEnclosingMethodCallExpression();
      int enclosingResolveStrategy=(cat == null ? 0 : cat.getResolveStrategy(outer.getEnclosingClosure()));
      candidate=findDeclarationForDynamicVariable(var,outer.getOwner(),outer,enclosingResolveStrategy);
    }
 else {
      candidate=findDeclaration(var.getName(),owner,isLhsExpr,scope.isOwnerStatic(),scope.isFieldAccessDirect(),callArgs);
    }
    if (candidate == null && resolveStrategy < Closure.DELEGATE_FIRST && scope.getEnclosingClosure() != null) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
    }
  }
  if (candidate == null && (resolveStrategy <= Closure.DELEGATE_FIRST || resolveStrategy == Closure.TO_SELF) && (resolveStrategy > 0 || scope.getEnclosingClosure() != null)) {
    candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,false,callArgs);
  }
  return candidate;
}","protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    VariableScope outer=(VariableScope)owner.getNodeMetaData(""String_Node_Str"");
    if (outer != null) {
      if (isLhsExpr)       scope.getWormhole().put(""String_Node_Str"",var);
      VariableScope.CallAndType cat=outer.getEnclosingMethodCallExpression();
      int enclosingResolveStrategy=(cat == null ? 0 : cat.getResolveStrategy(outer.getEnclosingClosure()));
      candidate=findDeclarationForDynamicVariable(var,getBaseDeclaringType(outer.getOwner()),outer,enclosingResolveStrategy);
    }
 else {
      candidate=findDeclaration(var.getName(),owner,isLhsExpr,scope.isOwnerStatic(),scope.isFieldAccessDirect(),callArgs);
    }
    if (candidate == null && resolveStrategy < Closure.DELEGATE_FIRST && scope.getEnclosingClosure() != null) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
    }
  }
  if (candidate == null && (resolveStrategy <= Closure.DELEGATE_FIRST || resolveStrategy == Closure.TO_SELF) && (resolveStrategy > 0 || scope.getEnclosingClosure() != null)) {
    candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,false,callArgs);
  }
  return candidate;
}",0.9936083672283555
185417,"@Override public void visitConstructorOrMethod(MethodNode node,boolean isConstructor){
  TypeLookupResult result=null;
  VariableScope scope=scopes.getLast();
  for (  ITypeLookup lookup : lookups) {
    TypeLookupResult candidate=lookup.lookupType(node,scope);
    if (candidate != null) {
      if (result == null || result.confidence.isLessThan(candidate.confidence)) {
        result=candidate;
      }
      if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
        break;
      }
    }
  }
  scope.setPrimaryNode(false);
  VisitStatus status=notifyRequestor(node,requestor,result);
switch (status) {
case CONTINUE:
    visitGenericTypes(node.getGenericsTypes(),null);
  visitClassReference(node.getReturnType());
if (node.getExceptions() != null) {
  for (  ClassNode e : node.getExceptions()) {
    visitClassReference(e);
  }
}
if (handleParameterList(node.getParameters())) {
super.visitConstructorOrMethod(node,isConstructor);
}
case CANCEL_BRANCH:
return;
case CANCEL_MEMBER:
case STOP_VISIT:
throw new VisitCompleted(status);
}
}","@Override public void visitConstructorOrMethod(MethodNode node,boolean isConstructor){
  TypeLookupResult result=null;
  VariableScope scope=scopes.getLast();
  for (  ITypeLookup lookup : lookups) {
    TypeLookupResult candidate=lookup.lookupType(node,scope);
    if (candidate != null) {
      if (result == null || result.confidence.isLessThan(candidate.confidence)) {
        result=candidate;
      }
      if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
        break;
      }
    }
  }
  scope.setPrimaryNode(false);
  VisitStatus status=notifyRequestor(node,requestor,result);
switch (status) {
case CONTINUE:
    visitGenericTypes(node.getGenericsTypes(),null);
  visitClassReference(node.getReturnType());
if (node.getExceptions() != null) {
  for (  ClassNode e : node.getExceptions()) {
    visitClassReference(e);
  }
}
if (handleParameterList(node.getParameters())) {
visitAnnotations(node);
if (!isConstructor || !(node.getCode() instanceof BlockStatement)) {
  visitClassCodeContainer(node.getCode());
}
 else {
  for (  Statement stmt : ((BlockStatement)node.getCode()).getStatements()) {
    if (stmt.getEnd() > 0) {
      stmt.visit(this);
    }
  }
}
}
case CANCEL_BRANCH:
return;
case CANCEL_MEMBER:
case STOP_VISIT:
throw new VisitCompleted(status);
}
}",0.861051731509192
185418,"private boolean handleParameterList(Parameter[] params){
  if (params != null) {
    VariableScope scope=scopes.getLast();
    scope.setPrimaryNode(false);
    for (    Parameter param : params) {
      if (!scope.containsInThisScope(param.getName())) {
        scope.addVariable(param);
      }
      TypeLookupResult result=null;
      for (      ITypeLookup lookup : lookups) {
        TypeLookupResult candidate=lookup.lookupType(param,scope);
        if (candidate != null) {
          if (result == null || result.confidence.isLessThan(candidate.confidence)) {
            result=candidate;
          }
          if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
            break;
          }
        }
      }
      TypeLookupResult parameterResult=new TypeLookupResult(result.type,result.declaringType,param,TypeConfidence.EXACT,scope);
      VisitStatus status=notifyRequestor(param,requestor,parameterResult);
switch (status) {
case CONTINUE:
        break;
case CANCEL_BRANCH:
      return false;
case CANCEL_MEMBER:
case STOP_VISIT:
    throw new VisitCompleted(status);
}
visitClassReference(param.getOriginType());
visitAnnotations(param);
Expression init=param.getInitialExpression();
if (init != null) {
  init.visit(this);
}
}
}
return true;
}","private boolean handleParameterList(Parameter[] params){
  if (params != null) {
    VariableScope scope=scopes.getLast();
    scope.setPrimaryNode(false);
    for (    Parameter param : params) {
      if (!scope.containsInThisScope(param.getName())) {
        scope.addVariable(param);
      }
      TypeLookupResult result=null;
      for (      ITypeLookup lookup : lookups) {
        TypeLookupResult candidate=lookup.lookupType(param,scope);
        if (candidate != null) {
          if (result == null || result.confidence.isLessThan(candidate.confidence)) {
            result=candidate;
          }
          if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
            break;
          }
        }
      }
      TypeLookupResult parameterResult=new TypeLookupResult(result.type,result.declaringType,param,TypeConfidence.EXACT,scope);
      VisitStatus status=notifyRequestor(param,requestor,parameterResult);
switch (status) {
case CONTINUE:
        break;
case CANCEL_BRANCH:
      return false;
case CANCEL_MEMBER:
case STOP_VISIT:
    throw new VisitCompleted(status);
}
visitAnnotations(param);
visitClassReference(param.getOriginType());
Expression init=param.getInitialExpression();
if (init != null) {
  init.visit(this);
}
}
}
return true;
}",0.980330448465775
185419,"@Override public void visitConstructorCallExpression(ConstructorCallExpression expression){
  char[] typeName=expression.getType().getName().toCharArray();
  for (int i=0; i < 10; i+=1) {
    requestor.acceptConstructorReference(typeName,i,expression.getStart());
  }
  super.visitConstructorCallExpression(expression);
}","@Override public void visitConstructorCallExpression(ConstructorCallExpression expression){
  char[] typeName=expression.getType().getName().toCharArray();
  for (int i=0; i <= 9; i+=1) {
    requestor.acceptConstructorReference(typeName,i,expression.getStart());
  }
  ((TupleExpression)expression.getArguments()).getExpressions().stream().filter(e -> e instanceof NamedArgumentListExpression).flatMap(e -> ((NamedArgumentListExpression)e).getMapEntryExpressions().stream()).forEach(kv -> {
    if (kv.getKeyExpression() instanceof ConstantExpression) {
      visitNameReference(AccessorSupport.SETTER,kv.getKeyExpression().getText(),kv.getKeyExpression().getStart());
    }
  }
);
  super.visitConstructorCallExpression(expression);
}",0.5127719962157048
185420,"@Override public void visitMethodCallExpression(MethodCallExpression expression){
  String methodStr=expression.getMethodAsString();
  if (methodStr != null) {
    char[] methodName=methodStr.toCharArray();
    requestor.acceptFieldReference(methodName,expression.getStart());
    for (int i=0; i < 7; i+=1) {
      requestor.acceptMethodReference(methodName,i,expression.getStart());
    }
  }
  if (expression.isUsingGenerics() && isNotEmpty(expression.getGenericsTypes())) {
    visitTypeParameters(expression.getGenericsTypes(),null);
  }
  super.visitMethodCallExpression(expression);
}","@Override public void visitMethodCallExpression(MethodCallExpression expression){
  String methodStr=expression.getMethodAsString();
  if (methodStr != null) {
    char[] methodName=methodStr.toCharArray();
    requestor.acceptFieldReference(methodName,expression.getStart());
    for (int i=0; i <= 7; i+=1) {
      requestor.acceptMethodReference(methodName,i,expression.getStart());
    }
  }
  if (expression.isUsingGenerics() && isNotEmpty(expression.getGenericsTypes())) {
    visitTypeParameters(expression.getGenericsTypes(),null);
  }
  super.visitMethodCallExpression(expression);
}",0.9991546914623838
185421,"@Override public void visitConstantExpression(ConstantExpression expression){
  if (!(expression.isNullExpression() || expression.isTrueExpression() || expression.isFalseExpression()|| expression.isEmptyStringExpression())) {
    if (expression instanceof AnnotationConstantExpression) {
      visitTypeReference(expression.getType(),true,true);
    }
    char[] constName=expression.getValue().toString().toCharArray();
    requestor.acceptFieldReference(constName,expression.getStart());
    for (int i=0; i < 7; i+=1) {
      requestor.acceptMethodReference(constName,i,expression.getStart());
    }
  }
  super.visitConstantExpression(expression);
}","@Override public void visitConstantExpression(ConstantExpression expression){
  if (!(expression.isNullExpression() || expression.isTrueExpression() || expression.isFalseExpression()|| expression.isEmptyStringExpression())) {
    if (expression instanceof AnnotationConstantExpression) {
      visitTypeReference(expression.getType(),true,true);
    }
    char[] constName=expression.getValue().toString().toCharArray();
    requestor.acceptFieldReference(constName,expression.getStart());
    for (int i=0; i <= 7; i+=1) {
      requestor.acceptMethodReference(constName,i,expression.getStart());
    }
  }
  super.visitConstantExpression(expression);
}",0.9992348890589136
185422,"private ICompletionProposal newEnumProposal(Position position,String replacement,CompletionProposal supporting,Image image,char[] triggers){
  CompletionProposal groovyProposal=CompletionProposal.create(CompletionProposal.METHOD_REF,0);
  groovyProposal.setRequiredProposals(new CompletionProposal[]{supporting});
  JavaCompletionProposal javaProposal=new JavaCompletionProposal(replacement,0,0,image,null,1,false,invocationContext){
    @Override public int getReplacementLength(){
      return position.getLength();
    }
    @Override public int getReplacementOffset(){
      return position.getOffset();
    }
  }
;
  javaProposal.setProposalInfo(new FieldProposalInfo(invocationContext.getProject(),groovyProposal));
  javaProposal.setTriggerCharacters(triggers);
  return javaProposal;
}","private ICompletionProposal newEnumProposal(Position position,String replacement,CompletionProposal supporting,Image image,char[] triggers){
  CompletionProposal groovyProposal=CompletionProposal.create(CompletionProposal.METHOD_REF,0);
  groovyProposal.setRequiredProposals(new CompletionProposal[]{supporting});
  JavaCompletionProposal javaProposal=new JavaCompletionProposal(replacement,0,0,image,null,1,false,invocationContext){
    @Override public int getReplacementLength(){
      return position.getLength();
    }
    @Override public int getReplacementOffset(){
      return position.getOffset();
    }
    @Override public void setReplacementOffset(    int offset){
      if (offset > getReplacementOffset() && getReplacementLength() > super.getReplacementLength()) {
        offset=getReplacementOffset() + (getReplacementLength() - super.getReplacementLength());
        position.setOffset(offset);
        position.setLength(super.getReplacementLength());
      }
    }
  }
;
  javaProposal.setProposalInfo(new FieldProposalInfo(invocationContext.getProject(),groovyProposal));
  javaProposal.setTriggerCharacters(triggers);
  return javaProposal;
}",0.8104241185487991
185423,"protected ClassNode findDeclaringType(Expression node,VariableScope scope,TypeConfidence[] confidence){
  if (node instanceof ClassExpression || node instanceof ConstructorCallExpression) {
    return node.getType();
  }
 else   if (node instanceof FieldExpression) {
    return ((FieldExpression)node).getField().getDeclaringClass();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    return ((StaticMethodCallExpression)node).getOwnerType();
  }
 else   if (node instanceof ConstantExpression && scope.isMethodCall()) {
    ClassNode ownerType;
    if (scope.getEnclosingClosure() != null) {
      ownerType=scope.getOwner();
    }
 else {
      ownerType=scope.getEnclosingTypeDeclaration();
    }
    return ownerType;
  }
 else   if (node instanceof VariableExpression) {
    Variable var=((VariableExpression)node).getAccessedVariable();
    if (var != null && !(var instanceof Parameter || var instanceof VariableExpression)) {
      ClassNode ownerType;
      if (scope.getEnclosingClosure() != null) {
        ownerType=scope.getOwner();
      }
 else {
        ownerType=scope.getEnclosingTypeDeclaration();
      }
      return ownerType;
    }
  }
  return VariableScope.OBJECT_CLASS_NODE;
}","protected ClassNode findDeclaringType(Expression node,VariableScope scope,TypeConfidence[] confidence){
  if (node instanceof ClassExpression || node instanceof ConstructorCallExpression) {
    return node.getType();
  }
 else   if (node instanceof FieldExpression) {
    return ((FieldExpression)node).getField().getDeclaringClass();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    return ((StaticMethodCallExpression)node).getOwnerType();
  }
 else   if (node instanceof ConstantExpression && scope.isMethodCall()) {
    ClassNode ownerType;
    if (scope.getEnclosingClosure() != null) {
      ownerType=getBaseDeclaringType(scope.getOwner());
    }
 else {
      ownerType=scope.getEnclosingTypeDeclaration();
    }
    return ownerType;
  }
 else   if (node instanceof VariableExpression) {
    Variable var=((VariableExpression)node).getAccessedVariable();
    if (var != null && !(var instanceof Parameter || var instanceof VariableExpression)) {
      ClassNode ownerType;
      if (scope.getEnclosingClosure() != null) {
        ownerType=getBaseDeclaringType(scope.getOwner());
      }
 else {
        ownerType=scope.getEnclosingTypeDeclaration();
      }
      return ownerType;
    }
  }
  return VariableScope.OBJECT_CLASS_NODE;
}",0.9822580645161292
185424,"@Test public void testTraitBasics() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClasses(""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
}","@Test public void testTraitBasics() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClasses(""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
}",0.9859363434492968
185425,"@Test public void testPackageNames_GRE342_3() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingNoProblems();
  executeClass(projectPath,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testPackageNames_GRE342_3() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingSpecificProblemFor(path,new Problem(""String_Node_Str"",""String_Node_Str"",path,0,1,60,IMarker.SEVERITY_ERROR));
}",0.8513513513513513
185426,"@Override protected boolean reportPackageIsNotExpectedPackage(CompilationUnitDeclaration compUnitDecl){
  if (!isScript && compUnitDecl != null && compUnitDecl.compilationResult != null && compUnitDecl.compilationResult.compilationUnit != null) {
    char[][] packageName=compUnitDecl.compilationResult.compilationUnit.getPackageName();
    String shouldBe=packageName == null ? ""String_Node_Str"" : CharOperation.toString(packageName);
    String actuallyIs=compUnitDecl.currentPackage == null ? ""String_Node_Str"" : CharOperation.toString(compUnitDecl.currentPackage.tokens);
    if (actuallyIs.length() > 0 && !shouldBe.equals(actuallyIs)) {
      problemReporter().packageIsNotExpectedPackage(compUnitDecl);
      return true;
    }
  }
  return false;
}","/** 
 * Checks expected package against actual package declaration.
 */
@Override protected boolean reportPackageIsNotExpectedPackage(CompilationUnitDeclaration compUnitDecl){
  if (compUnitDecl != null && compUnitDecl.compilationResult != null && compUnitDecl.compilationResult.compilationUnit != null) {
    char[][] expectedPackage=compUnitDecl.compilationResult.compilationUnit.getPackageName();
    if (expectedPackage != null && !CharOperation.equals(expectedPackage,compUnitDecl.currentPackage != null ? compUnitDecl.currentPackage.tokens : CharOperation.NO_CHAR_CHAR)) {
      problemReporter().packageIsNotExpectedPackage(compUnitDecl);
      return true;
    }
  }
  return false;
}",0.4861878453038674
185427,"@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  boolean isDeclaration=(node instanceof MethodNode);
  int start=0;
  int end=0;
  if (result.declaration instanceof MethodNode) {
    if (methodName.equals(((MethodNode)result.declaration).getName())) {
      if (isDeclaration || node instanceof StaticMethodCallExpression) {
        start=((AnnotatedNode)node).getNameStart();
        end=((AnnotatedNode)node).getNameEnd() + 1;
      }
 else {
        String text=node.getText();
        if (methodName.equals(text) || result.declaringType.getField(text) != null) {
          start=node.getStart();
          end=node.getEnd();
        }
      }
    }
  }
  if (end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      if (nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),isDeclaration ? GroovyUtils.getParameterTypes(((MethodNode)node).getParameters()) : result.scope.getMethodCallArgumentTypes())) {
        if (enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy) {
          enclosingElement=((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement);
        }
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,false,false,false,false,participant,enclosingElement.getResource());
        }
        if (match != null) {
          try {
            acceptedPositions.add(position);
            requestor.acceptSearchMatch(match);
          }
 catch (          Exception e) {
            Util.log(e,""String_Node_Str"" + enclosingElement + ""String_Node_Str""+ enclosingElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  boolean isDeclaration=(node instanceof MethodNode);
  int start=0;
  int end=0;
  if (result.declaration instanceof MethodNode && ((MethodNode)result.declaration).getName().equals(methodName)) {
    if (isDeclaration || node instanceof StaticMethodCallExpression) {
      start=((AnnotatedNode)node).getNameStart();
      end=((AnnotatedNode)node).getNameEnd() + 1;
    }
 else     if (node.getText().equals(methodName) || isNotSynthetic(node.getText(),result.declaringType)) {
      start=node.getStart();
      end=node.getEnd();
    }
  }
  if (end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      if (nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),isDeclaration ? GroovyUtils.getParameterTypes(((MethodNode)node).getParameters()) : result.scope.getMethodCallArgumentTypes())) {
        if (enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy) {
          enclosingElement=((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement);
        }
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,false,false,false,false,participant,enclosingElement.getResource());
        }
        if (match != null) {
          try {
            acceptedPositions.add(position);
            requestor.acceptSearchMatch(match);
          }
 catch (          Exception e) {
            Util.log(e,""String_Node_Str"" + enclosingElement + ""String_Node_Str""+ enclosingElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.9078276980083372
185428,"@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  boolean doCheck=false;
  boolean isAssignment=false;
  boolean isDeclaration=false;
  int start=0;
  int end=0;
  if (node instanceof ConstantExpression) {
    String cName=((ConstantExpression)node).getText();
    if (cName != null && CharOperation.equals(name,cName.toCharArray())) {
      doCheck=true;
      if (EqualityVisitor.checkForAssignment(node,result.enclosingAssignment)) {
        isAssignment=true;
      }
      start=node.getStart();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldExpression) {
    if (CharOperation.equals(name,((FieldExpression)node).getFieldName().toCharArray())) {
      doCheck=true;
      if (EqualityVisitor.checkForAssignment(node,result.enclosingAssignment)) {
        isAssignment=true;
      }
      end=node.getEnd();
      start=end - name.length;
    }
  }
 else   if (node instanceof FieldNode) {
    FieldNode fnode=(FieldNode)node;
    if (CharOperation.equals(name,fnode.getName().toCharArray())) {
      doCheck=true;
      isDeclaration=true;
      isAssignment=true;
      start=fnode.getNameStart();
      end=fnode.getNameEnd() + 1;
    }
  }
 else   if (node instanceof VariableExpression) {
    VariableExpression vnode=(VariableExpression)node;
    if (CharOperation.equals(name,vnode.getName().toCharArray())) {
      doCheck=true;
      if (EqualityVisitor.checkForAssignment(node,result.enclosingAssignment)) {
        isAssignment=true;
      }
      start=vnode.getStart();
      end=start + vnode.getName().length();
    }
  }
  if (doCheck && end > 0 && result.declaringType != null) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      boolean isCompleteMatch=qualifiedNameMatches(GroovyUtils.getBaseType(result.declaringType));
      if (isCompleteMatch && ((isAssignment && writeAccess) || (!isAssignment && readAccess) || (isDeclaration && findDeclarations))) {
        SearchMatch match=null;
        IJavaElement realElement=enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy ? ((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement) : enclosingElement;
        if (isDeclaration && findDeclarations) {
          match=new FieldDeclarationMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,realElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new FieldReferenceMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,!isAssignment,isAssignment,false,participant,realElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + realElement + ""String_Node_Str""+ realElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  boolean doCheck=false;
  boolean isAssignment=false;
  boolean isDeclaration=false;
  int start=0;
  int end=0;
  if (node instanceof ConstantExpression) {
    if (fieldName.equals(((ConstantExpression)node).getText()) && (result.confidence == TypeConfidence.UNKNOWN || result.declaringType.getField(fieldName) != null || result.declaringType.getProperty(fieldName) != null)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldExpression) {
    if (fieldName.equals(((FieldExpression)node).getFieldName())) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=end - fieldName.length();
      end=node.getEnd();
    }
  }
 else   if (node instanceof FieldNode) {
    FieldNode fnode=(FieldNode)node;
    if (fieldName.equals(fnode.getName())) {
      doCheck=true;
      isAssignment=true;
      isDeclaration=true;
      start=fnode.getNameStart();
      end=fnode.getNameEnd() + 1;
    }
  }
 else   if (node instanceof VariableExpression) {
    String vname=((VariableExpression)node).getName();
    if (fieldName.equals(vname)) {
      doCheck=true;
      isAssignment=EqualityVisitor.checkForAssignment(node,result.enclosingAssignment);
      start=node.getStart();
      end=start + vname.length();
    }
  }
  if (doCheck && end > 0 && result.declaringType != null) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      boolean isCompleteMatch=qualifiedNameMatches(GroovyUtils.getBaseType(result.declaringType));
      if (isCompleteMatch && ((isAssignment && writeAccess) || (!isAssignment && readAccess) || (isDeclaration && findDeclarations))) {
        SearchMatch match=null;
        IJavaElement realElement=enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy ? ((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement) : enclosingElement;
        if (isDeclaration && findDeclarations) {
          match=new FieldDeclarationMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,realElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new FieldReferenceMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,!isAssignment,isAssignment,false,participant,realElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + realElement + ""String_Node_Str""+ realElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.6463989595187775
185429,"public FieldReferenceSearchRequestor(FieldPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  name=(char[])ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  char[] arr=(char[])ReflectionUtils.getPrivateField(FieldPattern.class,""String_Node_Str"",pattern);
  String declaringSimpleName=arr == null ? ""String_Node_Str"" : String.valueOf(arr);
  arr=(char[])ReflectionUtils.getPrivateField(FieldPattern.class,""String_Node_Str"",pattern);
  String declaringQualification=((arr == null || arr.length == 0) ? ""String_Node_Str"" : (String.valueOf(arr) + ""String_Node_Str""));
  declaringQualifiedName=declaringQualification + declaringSimpleName;
  readAccess=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  writeAccess=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
}","public FieldReferenceSearchRequestor(FieldPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  char[] arr=(char[])ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  fieldName=String.valueOf(arr);
  arr=(char[])ReflectionUtils.getPrivateField(FieldPattern.class,""String_Node_Str"",pattern);
  String declaringSimpleName=((arr == null || arr.length == 0) ? ""String_Node_Str"" : String.valueOf(arr));
  arr=(char[])ReflectionUtils.getPrivateField(FieldPattern.class,""String_Node_Str"",pattern);
  String declaringQualification=((arr == null || arr.length == 0) ? ""String_Node_Str"" : (String.valueOf(arr) + ""String_Node_Str""));
  declaringQualifiedName=declaringQualification + declaringSimpleName;
  readAccess=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  writeAccess=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(VariablePattern.class,""String_Node_Str"",pattern);
}",0.8034753827058336
185430,"private boolean qualifiedNameMatches(ClassNode declaringType){
  if (declaringType == null) {
    return false;
  }
 else   if (declaringQualifiedName == null || declaringQualifiedName.equals(""String_Node_Str"")) {
    return true;
  }
 else   if (declaringType.getName().equals(declaringQualifiedName)) {
    return true;
  }
 else {
    return false;
  }
}","private boolean qualifiedNameMatches(ClassNode declaringType){
  if (declaringType == null) {
    return false;
  }
 else   if (declaringQualifiedName.isEmpty()) {
    return true;
  }
 else   if (declaringType.getName().equals(declaringQualifiedName)) {
    return true;
  }
 else {
    return false;
  }
}",0.9006024096385542
185431,"@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  boolean isConstructorCall=false;
  boolean isDeclaration=(node instanceof MethodNode);
  int start=0;
  int end=0;
  if (result.declaration instanceof MethodNode) {
    if (methodName.equals(((MethodNode)result.declaration).getName())) {
      if (isDeclaration) {
        start=((MethodNode)node).getNameStart();
        end=((MethodNode)node).getNameEnd() + 1;
      }
 else       if (node.getText().equals(methodName)) {
        start=node.getStart();
        end=node.getEnd();
      }
 else       if (node instanceof StaticMethodCallExpression && node.getText().contains(""String_Node_Str"" + methodName + ""String_Node_Str"")) {
        start=((StaticMethodCallExpression)node).getStart();
        end=start + methodName.length();
      }
    }
  }
  if (end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      if (nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),isDeclaration ? GroovyUtils.getParameterTypes(((MethodNode)node).getParameters()) : result.scope.getMethodCallArgumentTypes())) {
        if (enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy) {
          enclosingElement=((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement);
        }
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,isConstructorCall,false,false,false,participant,enclosingElement.getResource());
        }
        if (match != null) {
          try {
            acceptedPositions.add(position);
            requestor.acceptSearchMatch(match);
          }
 catch (          Exception e) {
            Util.log(e,""String_Node_Str"" + enclosingElement + ""String_Node_Str""+ enclosingElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","@Override public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  boolean isDeclaration=(node instanceof MethodNode);
  int start=0;
  int end=0;
  if (result.declaration instanceof MethodNode) {
    if (methodName.equals(((MethodNode)result.declaration).getName())) {
      if (isDeclaration || node instanceof StaticMethodCallExpression) {
        start=((AnnotatedNode)node).getNameStart();
        end=((AnnotatedNode)node).getNameEnd() + 1;
      }
 else {
        String text=node.getText();
        if (methodName.equals(text) || result.declaringType.getField(text) != null) {
          start=node.getStart();
          end=node.getEnd();
        }
      }
    }
  }
  if (end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      if (nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),isDeclaration ? GroovyUtils.getParameterTypes(((MethodNode)node).getParameters()) : result.scope.getMethodCallArgumentTypes())) {
        if (enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy) {
          enclosingElement=((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement);
        }
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,false,false,false,false,participant,enclosingElement.getResource());
        }
        if (match != null) {
          try {
            acceptedPositions.add(position);
            requestor.acceptSearchMatch(match);
          }
 catch (          Exception e) {
            Util.log(e,""String_Node_Str"" + enclosingElement + ""String_Node_Str""+ enclosingElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.8905045164133069
185432,"public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  this.methodName=String.valueOf(pattern.selector);
  String[] parameterTypeSignatures=getParameterTypeSignatures(pattern);
  IType declaringType=(IType)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] declaringQualifiedName=null;
  try {
    if (pattern.focus instanceof IMethod && supportsOverride((IMethod)pattern.focus)) {
      LinkedList<IMethod> methods=new LinkedList<>();
      if (declaringType == null)       declaringType=((IMethod)pattern.focus).getDeclaringType();
      for (      IType superType : declaringType.newSupertypeHierarchy(null).getAllSupertypes(declaringType)) {
        IMethod superMeth=superType.getMethod(methodName,parameterTypeSignatures);
        if (superMeth.exists() && supportsOverride(superMeth)) {
          methods.add(superMeth);
        }
      }
      if (!methods.isEmpty()) {
        IType type=methods.getLast().getDeclaringType();
        char[] superTypeName=type.getElementName().toCharArray();
        char[] packageName=type.getPackageFragment().getElementName().toCharArray();
        declaringQualifiedName=CharOperation.concat(packageName,superTypeName,'.');
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  if (declaringQualifiedName == null) {
    declaringQualifiedName=CharOperation.concat(pattern.declaringQualification,pattern.declaringSimpleName,'.');
    if (declaringQualifiedName == null) {
      if (declaringType != null) {
        declaringQualifiedName=CharOperation.concat(declaringType.getPackageFragment().getElementName().toCharArray(),declaringType.getElementName().toCharArray(),'.');
      }
 else {
        declaringQualifiedName=CharOperation.NO_CHAR;
      }
    }
  }
  declaringTypeName=String.valueOf(declaringQualifiedName);
  parameterTypeNames=getParameterTypeNames(pattern,parameterTypeSignatures,declaringType);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
}","public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  this.methodName=String.valueOf(pattern.selector);
  String[] parameterTypeSignatures=getParameterTypeSignatures(pattern);
  IType declaringType=(IType)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] declaringQualifiedName=null;
  try {
    if (pattern.focus instanceof IMethod && supportsOverride((IMethod)pattern.focus)) {
      LinkedList<IMethod> methods=new LinkedList<>();
      if (declaringType == null)       declaringType=((IMethod)pattern.focus).getDeclaringType();
      for (      IType superType : declaringType.newSupertypeHierarchy(null).getAllSupertypes(declaringType)) {
        IMethod superMeth=superType.getMethod(methodName,parameterTypeSignatures);
        if (superMeth.exists() && supportsOverride(superMeth)) {
          methods.add(superMeth);
        }
      }
      if (!methods.isEmpty()) {
        IType type=methods.getLast().getDeclaringType();
        char[] superTypeName=type.getElementName().toCharArray();
        char[] packageName=type.getPackageFragment().getElementName().toCharArray();
        declaringQualifiedName=CharOperation.concat(packageName,superTypeName,'.');
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  if (declaringQualifiedName == null) {
    declaringQualifiedName=CharOperation.concat(pattern.declaringQualification,pattern.declaringSimpleName,'.');
    if (declaringQualifiedName == null) {
      if (declaringType != null) {
        declaringQualifiedName=CharOperation.concat(declaringType.getPackageFragment().getElementName().toCharArray(),declaringType.getElementName().toCharArray(),'.');
      }
 else {
        declaringQualifiedName=CharOperation.NO_CHAR;
      }
    }
  }
  declaringTypeName=String.valueOf(declaringQualifiedName);
  parameterTypeNames=getParameterTypeNames(pattern,parameterTypeSignatures,declaringType);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
}",0.9911111111111112
185433,"@Test public void testParsingDotTerminatedImportStatic_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  Map<String,ImportNode> imports=mn.getStaticStarImports();
  ImportNode brokenImportNode=imports.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","@Test public void testParsingDotTerminatedImportStatic_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  Map<String,ImportNode> imports=mn.getStaticStarImports();
  ImportNode recoveredImport=imports.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",recoveredImport.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9638709677419356
185434,"@Test public void testParsingDotTerminatedImportFollowedByClassDeclaration_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","@Test public void testParsingDotTerminatedImportFollowedByClassDeclaration_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(""String_Node_Str"",recoveredImport.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9605077574047954
185435,"@Test public void testParsingBlankImportStatic_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  Map<String,ImportNode> imports=mn.getStaticImports();
  ImportNode brokenImportNode=imports.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","@Test public void testParsingBlankImportStatic_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(0,recoveredImport.getStart());
  assertEquals(14,recoveredImport.getEnd());
  assertEquals(""String_Node_Str"",recoveredImport.getType().getName());
  assertTrue(mn.getStaticImports().isEmpty());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.7681755829903978
185436,"@Test public void testParsingIncompleteClassDeclaration_495() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  List<ClassNode> l=mn.getClasses();
  for (int i=0; i < l.size(); i++) {
    System.out.println(l.get(i));
  }
  assertFalse(mn.encounteredUnrecoverableError());
  ClassNode cn=mn.getClasses().get(2);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
  cn=mn.getClasses().get(1);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","@Test public void testParsingIncompleteClassDeclaration_495(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  List<ClassNode> l=mn.getClasses();
  for (int i=0; i < l.size(); i++) {
    System.out.println(l.get(i));
  }
  assertFalse(mn.encounteredUnrecoverableError());
  ClassNode cn=mn.getClasses().get(2);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
  cn=mn.getClasses().get(1);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9891956782713084
185437,"@Test public void testParsingDotTerminatedImport_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","@Test public void testParsingDotTerminatedImport_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(""String_Node_Str"",recoveredImport.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.9368258859784284
185438,"@Test public void testParsingBlankImportFollowedByClassDeclaration_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","@Test public void testParsingBlankImportFollowedByClassDeclaration_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(""String_Node_Str"",recoveredImport.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.96
185439,"@Test public void testParsingBlankImport_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(0,brokenImportNode.getStart());
  assertEquals(6,brokenImportNode.getEnd());
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","@Test public void testParsingBlankImport_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(0,recoveredImport.getStart());
  assertEquals(7,recoveredImport.getEnd());
  assertEquals(""String_Node_Str"",recoveredImport.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.9343365253077976
185440,"@Test public void testInnerClass4() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","@Test public void testInnerClass4(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.966542750929368
185441,"@Test public void testInnerClass5() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testInnerClass5(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.970967741935484
185442,"@Test public void testParsingDotTerminatedImportFollowedByModifierAndClassDeclaration_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","@Test public void testParsingDotTerminatedImportFollowedByModifierAndClassDeclaration_538(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode recoveredImport=imports.get(0);
  assertEquals(""String_Node_Str"",recoveredImport.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9611111111111112
185443,"@Test public void testInnerClass2() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","@Test public void testInnerClass2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.97239263803681
185444,"@Test public void testInnerClass3() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","@Test public void testInnerClass3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.966542750929368
185445,"@Test public void testInnerClass1() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","@Test public void testInnerClass1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.961038961038961
185446,"protected GenericsType[] makeGenericsType(AST rootNode){
  AST typeParameter=rootNode.getFirstChild();
  LinkedList ret=new LinkedList();
  assertNodeType(TYPE_PARAMETER,typeParameter);
  while (isType(TYPE_PARAMETER,typeParameter)) {
    AST typeNode=typeParameter.getFirstChild();
    ClassNode type=makeType(typeParameter);
    GenericsType gt=new GenericsType(type,makeGenericsBounds(typeNode,TYPE_UPPER_BOUNDS),null);
    configureAST(gt,typeParameter);
    ret.add(gt);
    typeParameter=typeParameter.getNextSibling();
  }
  return (GenericsType[])ret.toArray(new GenericsType[0]);
}","protected GenericsType[] makeGenericsType(AST rootNode){
  AST typeParameter=rootNode.getFirstChild();
  LinkedList ret=new LinkedList();
  assertNodeType(TYPE_PARAMETER,typeParameter);
  while (isType(TYPE_PARAMETER,typeParameter)) {
    AST typeNode=typeParameter.getFirstChild();
    ClassNode type=makeType(typeParameter);
    GenericsType gt=new GenericsType(type,makeGenericsBounds(typeNode,TYPE_UPPER_BOUNDS),null);
    configureAST(gt,typeParameter);
    ret.add(gt);
    typeParameter=typeParameter.getNextSibling();
  }
  return (GenericsType[])ret.toArray(new GenericsType[ret.size()]);
}",0.990748528174937
185447,"protected void packageDef(AST packageDef){
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=packageDef.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  if (node == null)   return;
  String name=qualifiedName(node);
  setPackageName(name);
  if (name != null && !name.isEmpty()) {
    name+='.';
  }
  PackageNode packageNode=new PackageNode(name);
  packageNode.addAnnotations(annotations);
  output.setPackage(packageNode);
  configureAST(packageNode,node);
}","protected void packageDef(AST packageDef){
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=packageDef.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  String name=qualifiedName(node);
  PackageNode packageNode=setPackage(name,annotations);
  configureAST(packageNode,node);
}",0.65
185448,"protected void importDef(AST importNode){
  try {
    output.putNodeMetaData(ImportNode.class,ImportNode.class);
    boolean isStatic=importNode.getType() == STATIC_IMPORT;
    List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
    AST node=importNode.getFirstChild();
    if (isType(ANNOTATIONS,node)) {
      processAnnotations(annotations,node);
      node=node.getNextSibling();
    }
    String alias=null;
    AST aliasNode=null;
    if (isType(LITERAL_as,node)) {
      node=node.getFirstChild();
      aliasNode=node.getNextSibling();
      alias=identifier(aliasNode);
    }
    if (node == null) {
      if (isStatic) {
        addStaticImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
      }
 else {
        addImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
      }
      return;
    }
    if (node.getNumberOfChildren() == 0) {
      String name=identifier(node);
      ClassNode type=ClassHelper.make(name);
      configureAST(type,importNode);
      addImport(type,name,alias,annotations);
      return;
    }
    AST packageNode=node.getFirstChild();
    String packageName=qualifiedName(packageNode);
    AST nameNode=packageNode.getNextSibling();
    if (isType(STAR,nameNode)) {
      if (isStatic) {
        ClassNode type=ClassHelper.make(packageName);
        configureAST(type,packageNode);
        addStaticStarImport(type,packageName,annotations);
        ASTNode imp=output.getStaticStarImports().get(packageName);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,packageNode);
        }
        configureAST(imp,importNode);
      }
 else {
        addStarImport(packageName,annotations);
        ASTNode imp=output.getStarImports().get(output.getStarImports().size() - 1);
        configureAST(imp,importNode);
      }
      if (alias != null)       throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      ImportNode imp;
      String name=identifier(nameNode);
      if (isStatic) {
        ClassNode type=ClassHelper.make(packageName);
        configureAST(type,packageNode);
        addStaticImport(type,name,alias,annotations);
        imp=output.getStaticImports().get(alias == null ? name : alias);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,packageNode);
        }
        configureAST(imp,importNode);
        ConstantExpression nameExpr=new ConstantExpression(name);
        configureAST(nameExpr,nameNode);
        imp.setFieldNameExpr(nameExpr);
      }
 else {
        ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
        configureAST(type,nameNode);
        addImport(type,name,alias,annotations);
        imp=output.getImport(alias == null ? name : alias);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,nameNode);
        }
        configureAST(imp,importNode);
      }
      if (alias != null) {
        ConstantExpression aliasExpr=new ConstantExpression(alias);
        configureAST(aliasExpr,aliasNode);
        imp.setAliasExpr(aliasExpr);
      }
    }
  }
  finally {
    Object node=output.getNodeMetaData(ImportNode.class);
    if (node != null && node != ImportNode.class) {
      configureAST((ImportNode)node,importNode);
    }
    output.removeNodeMetaData(ImportNode.class);
  }
}","protected void importDef(AST importNode){
  try {
    output.putNodeMetaData(ImportNode.class,ImportNode.class);
    boolean isStatic=importNode.getType() == STATIC_IMPORT;
    List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
    AST node=importNode.getFirstChild();
    if (isType(ANNOTATIONS,node)) {
      processAnnotations(annotations,node);
      node=node.getNextSibling();
    }
    String alias=null;
    AST aliasNode=null;
    if (isType(LITERAL_as,node)) {
      node=node.getFirstChild();
      aliasNode=node.getNextSibling();
      alias=identifier(aliasNode);
    }
    if (node.getNumberOfChildren() == 0) {
      String name=identifier(node);
      ClassNode type=ClassHelper.make(name);
      configureAST(type,importNode);
      addImport(type,name,alias,annotations);
      return;
    }
    AST packageNode=node.getFirstChild();
    String packageName=qualifiedName(packageNode);
    AST nameNode=packageNode.getNextSibling();
    if (isType(STAR,nameNode)) {
      if (isStatic) {
        ClassNode type=ClassHelper.make(packageName);
        configureAST(type,packageNode);
        addStaticStarImport(type,packageName,annotations);
        ASTNode imp=output.getStaticStarImports().get(packageName);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,packageNode);
        }
        configureAST(imp,importNode);
      }
 else {
        addStarImport(packageName,annotations);
        ASTNode imp=output.getStarImports().get(output.getStarImports().size() - 1);
        configureAST(imp,importNode);
      }
      if (alias != null)       throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      ImportNode imp;
      String name=identifier(nameNode);
      if (isStatic) {
        ClassNode type=ClassHelper.make(packageName);
        configureAST(type,packageNode);
        addStaticImport(type,name,alias,annotations);
        imp=output.getStaticImports().get(alias == null ? name : alias);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,packageNode);
        }
        configureAST(imp,importNode);
        ConstantExpression nameExpr=new ConstantExpression(name);
        configureAST(nameExpr,nameNode);
        imp.setFieldNameExpr(nameExpr);
      }
 else {
        ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
        configureAST(type,nameNode);
        addImport(type,name,alias,annotations);
        imp=output.getImport(alias == null ? name : alias);
        if (type instanceof ImmutableClassNode) {
          ClassExpression typeNode=new ClassExpression(type);
          imp.setNodeMetaData(ClassExpression.class,typeNode);
          configureAST(typeNode,nameNode);
        }
        configureAST(imp,importNode);
      }
      if (alias != null) {
        ConstantExpression aliasExpr=new ConstantExpression(alias);
        configureAST(aliasExpr,aliasNode);
        imp.setAliasExpr(aliasExpr);
      }
    }
  }
  finally {
    Object node=output.getNodeMetaData(ImportNode.class);
    if (node != null && node != ImportNode.class) {
      configureAST((ImportNode)node,importNode);
    }
    output.removeNodeMetaData(ImportNode.class);
  }
}",0.9647613762486128
185449,"@Override public void visitCastExpression(CastExpression expression){
  if (expression.getEnd() > 0 && expression.getStart() == expression.getType().getStart()) {
    visitTypeReference(expression.getType(),false,true);
  }
  super.visitCastExpression(expression);
}","@Override public void visitCastExpression(CastExpression expression){
  if (expression.getEnd() > 0 && (expression.getStart() == expression.getType().getStart() || expression.getEnd() == expression.getType().getEnd())) {
    visitTypeReference(expression.getType(),false,true);
  }
  super.visitCastExpression(expression);
}",0.7830508474576271
185450,"@Override protected String computeReplacementString(){
  if (fProposal.getCompletion() == null || fProposal.getCompletion().length == 0) {
    return ""String_Node_Str"";
  }
  char[] proposalName=fProposal.getName();
  boolean hasWhitespace=ProposalUtils.hasWhitespace(proposalName);
  if (fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
    return String.valueOf(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  }
  if (!hasWhitespace && (!hasParameters() || !hasArgumentList())) {
    String replacementString=super.computeReplacementString();
    if (replacementString.endsWith(""String_Node_Str"")) {
      replacementString=replacementString.substring(0,replacementString.length() - 1);
    }
    return replacementString;
  }
  StringBuffer buffer=new StringBuffer();
  fProposal.setName(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  appendMethodNameReplacement(buffer);
  fProposal.setName(proposalName);
  if (!hasParameters()) {
    while (Character.isWhitespace(buffer.charAt(buffer.length() - 1))) {
      buffer.deleteCharAt(buffer.length() - 1);
    }
    if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BETWEEN_EMPTY_PARENS_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    buffer.append(RPAREN);
  }
 else   if (!fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES)) {
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    if (!fPreferences.bCommandChaining)     buffer.append(RPAREN);
  }
 else {
    int indexOfLastClosure=-1;
    char[][] namedParameterTypes=((GroovyCompletionProposal)fProposal).getNamedParameterTypeNames();
    char[][] regularParameterTypes=((GroovyCompletionProposal)fProposal).getRegularParameterTypeNames();
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_NOPARENS)) {
      if (lastParamIsClosure(regularParameterTypes,CharOperation.NO_CHAR_CHAR)) {
        indexOfLastClosure=namedParameterTypes.length + regularParameterTypes.length - 1;
      }
      if (indexOfLastClosure == 0) {
        buffer.deleteCharAt(buffer.length() - 1);
        if (!fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
      }
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    char[][] namedParameterNames=((GroovyCompletionProposal)fProposal).getNamedParameterNames();
    char[][] regularParameterNames=((GroovyCompletionProposal)fProposal).getRegularParameterNames();
    int namedCount=namedParameterNames.length, totalCount=regularParameterNames.length + namedCount;
    computeReplacementProposals(namedParameterNames,regularParameterNames,indexOfLastClosure);
    for (int i=0; i < totalCount; i+=1) {
      @SuppressWarnings(""String_Node_Str"") char[] nextName, nextType;
      if (i < namedCount) {
        nextName=namedParameterNames[i];
        nextType=namedParameterTypes[i];
      }
 else {
        nextName=regularParameterNames[i - namedCount];
        nextType=regularParameterTypes[i - namedCount];
      }
      String nextValue=fProposals.get(i)[0].getDisplayString();
      if ((fPreferences.isEnabled(GroovyContentAssist.NAMED_ARGUMENTS) || i < namedCount) && i != indexOfLastClosure) {
        buffer.append(nextName);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
      }
      fPositions.get(i).setLength(nextValue.length());
      fPositions.get(i).setOffset(buffer.length());
      buffer.append(nextValue);
      if (i == (indexOfLastClosure - 1) || (i != indexOfLastClosure && i == (totalCount - 1) && !fPreferences.bCommandChaining)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
        buffer.append(RPAREN);
        if (i == (indexOfLastClosure - 1) && (!fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) || fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK))) {
          buffer.append(SPACE);
        }
      }
 else       if (i < (totalCount - 1)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
        buffer.append(COMMA);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
      }
    }
  }
  return buffer.toString();
}","@Override protected String computeReplacementString(){
  if (fProposal.getCompletion() == null || fProposal.getCompletion().length == 0) {
    setContextInformationPosition(1);
    return ""String_Node_Str"";
  }
  char[] proposalName=fProposal.getName();
  boolean hasWhitespace=ProposalUtils.hasWhitespace(proposalName);
  if (fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
    return String.valueOf(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  }
  if (!hasWhitespace && (!hasParameters() || !hasArgumentList())) {
    String replacementString=super.computeReplacementString();
    if (replacementString.endsWith(""String_Node_Str"")) {
      replacementString=replacementString.substring(0,replacementString.length() - 1);
    }
    return replacementString;
  }
  StringBuffer buffer=new StringBuffer();
  fProposal.setName(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  appendMethodNameReplacement(buffer);
  fProposal.setName(proposalName);
  if (!hasParameters()) {
    while (Character.isWhitespace(buffer.charAt(buffer.length() - 1))) {
      buffer.deleteCharAt(buffer.length() - 1);
    }
    if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BETWEEN_EMPTY_PARENS_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    buffer.append(RPAREN);
  }
 else   if (!fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES)) {
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    if (!fPreferences.bCommandChaining)     buffer.append(RPAREN);
  }
 else {
    int indexOfLastClosure=-1;
    char[][] namedParameterTypes=((GroovyCompletionProposal)fProposal).getNamedParameterTypeNames();
    char[][] regularParameterTypes=((GroovyCompletionProposal)fProposal).getRegularParameterTypeNames();
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_NOPARENS)) {
      if (lastParamIsClosure(regularParameterTypes,CharOperation.NO_CHAR_CHAR)) {
        indexOfLastClosure=namedParameterTypes.length + regularParameterTypes.length - 1;
      }
      if (indexOfLastClosure == 0) {
        buffer.deleteCharAt(buffer.length() - 1);
        if (!fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
      }
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    char[][] namedParameterNames=((GroovyCompletionProposal)fProposal).getNamedParameterNames();
    char[][] regularParameterNames=((GroovyCompletionProposal)fProposal).getRegularParameterNames();
    int namedCount=namedParameterNames.length, totalCount=regularParameterNames.length + namedCount;
    computeReplacementProposals(namedParameterNames,regularParameterNames,indexOfLastClosure);
    for (int i=0; i < totalCount; i+=1) {
      @SuppressWarnings(""String_Node_Str"") char[] nextName, nextType;
      if (i < namedCount) {
        nextName=namedParameterNames[i];
        nextType=namedParameterTypes[i];
      }
 else {
        nextName=regularParameterNames[i - namedCount];
        nextType=regularParameterTypes[i - namedCount];
      }
      String nextValue=fProposals.get(i)[0].getDisplayString();
      if ((fPreferences.isEnabled(GroovyContentAssist.NAMED_ARGUMENTS) || i < namedCount) && i != indexOfLastClosure) {
        buffer.append(nextName);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
      }
      fPositions.get(i).setLength(nextValue.length());
      fPositions.get(i).setOffset(buffer.length());
      buffer.append(nextValue);
      if (i == (indexOfLastClosure - 1) || (i != indexOfLastClosure && i == (totalCount - 1) && !fPreferences.bCommandChaining)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
        buffer.append(RPAREN);
        if (i == (indexOfLastClosure - 1) && (!fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) || fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK))) {
          buffer.append(SPACE);
        }
      }
 else       if (i < (totalCount - 1)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
        buffer.append(COMMA);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
      }
    }
  }
  return buffer.toString();
}",0.9966973752824612
185451,"protected void computeReplacementProposals(char[][] namedParameterNames,char[][] positionalParameterNames,int indexOfLastClosure){
  boolean guess=(fInvocationContext.getCoreContext().isExtended() && fPreferences.isEnabled(PreferenceConstants.CODEASSIST_GUESS_METHOD_ARGUMENTS));
  char[][] parameterTypes=Signature.getParameterTypes(SignatureUtil.fix83600(fProposal.getSignature()));
  int npc=namedParameterNames.length, n=npc + positionalParameterNames.length;
  fPositions=new ArrayList<>(n);
  fProposals=new ArrayList<>(n);
  for (int i=0; i < n; i+=1) {
    fPositions.add(new Position(0));
    char[] name=(i < npc ? namedParameterNames[i] : positionalParameterNames[i - npc]);
    char[] type=(i < npc ? parameterTypes[i + positionalParameterNames.length] : parameterTypes[i - npc]);
    ICompletionProposal[] vals;
    if (guess) {
      boolean fillBestGuess=true;
      String typeSignature=String.valueOf(type);
      IJavaElement[] visibleElements=fInvocationContext.getCoreContext().getVisibleElements(typeSignature);
      vals=new ParameterGuesserDelegate(getEnclosingElement(),fInvocationContext).parameterProposals(Signature.toString(typeSignature),String.valueOf(name),fPositions.get(i),visibleElements,fillBestGuess);
    }
 else {
      StringBuilder buffer=new StringBuilder();
      if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) && CharOperation.equals(type,CLOSURE_TYPE_SIGNATURE)) {
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_BRACE_IN_ARRAY_INITIALIZER)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_BRACE_IN_ARRAY_INITIALIZER)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
      }
 else {
        buffer.append(name);
      }
      vals=new ICompletionProposal[]{new JavaCompletionProposal(buffer.toString(),0,buffer.length(),null,buffer.toString(),1)};
    }
    fProposals.add(vals);
  }
}","protected void computeReplacementProposals(char[][] namedParameterNames,char[][] positionalParameterNames,int indexOfLastClosure){
  boolean guess=(fInvocationContext.getCoreContext().isExtended() && fPreferences.isEnabled(PreferenceConstants.CODEASSIST_GUESS_METHOD_ARGUMENTS));
  char[][] parameterTypes=Signature.getParameterTypes(SignatureUtil.fix83600(fProposal.getSignature()));
  int npc=namedParameterNames.length, n=npc + positionalParameterNames.length;
  fPositions=new ArrayList<>(n);
  fProposals=new ArrayList<>(n);
  for (int i=0; i < n; i+=1) {
    fPositions.add(new Position(0));
    char[] name=(i < npc ? namedParameterNames[i] : positionalParameterNames[i - npc]);
    char[] type=(i < npc ? parameterTypes[i + positionalParameterNames.length] : parameterTypes[i - npc]);
    ICompletionProposal[] vals;
    if (guess) {
      boolean fillBestGuess=true;
      String typeSignature=String.valueOf(type);
      IJavaElement[] visibleElements=fInvocationContext.getCoreContext().getVisibleElements(typeSignature);
      vals=new ParameterGuesserDelegate(getEnclosingElement(),fInvocationContext).parameterProposals(Signature.toString(typeSignature),String.valueOf(name),fPositions.get(i),visibleElements,fillBestGuess);
    }
 else {
      StringBuilder buffer=new StringBuilder();
      if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) && CharOperation.equals(CLOSURE_TYPE_SIGNATURE,type,1,type.length)) {
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_BRACE_IN_ARRAY_INITIALIZER)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_BRACE_IN_ARRAY_INITIALIZER)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
      }
 else {
        buffer.append(name);
      }
      vals=new ICompletionProposal[]{new JavaCompletionProposal(buffer.toString(),0,buffer.length(),null,buffer.toString(),1)};
    }
    fProposals.add(vals);
  }
}",0.9943661971830986
185452,"@Override protected IContextInformation computeContextInformation(){
  if (hasParameters() && (fProposal.getKind() == CompletionProposal.METHOD_REF || fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION)) {
    ProposalContextInformation contextInformation=new ProposalContextInformation(fProposal);
    if (fContextInformationPosition != 0 && fProposal.getCompletion().length == 0)     contextInformation.setContextInformationPosition(fContextInformationPosition);
    return contextInformation;
  }
  return super.computeContextInformation();
}","@Override protected IContextInformation computeContextInformation(){
  if (hasParameters() && (fProposal.getKind() == CompletionProposal.METHOD_REF || fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION)) {
    return new ProposalContextInformation(fProposal);
  }
  return super.computeContextInformation();
}",0.6167800453514739
185453,"@Override public void apply(IDocument document,char trigger,int offset){
  try {
    if (trigger == '{' && (fProposal.getCompletion() != null && fProposal.getCompletion().length > 0)) {
      String replacement=getReplacementString();
      if (replacement.endsWith(""String_Node_Str"") || fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
        trigger=0;
      }
 else       if (fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION || !fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES) || !lastParamAcceptsClosure(Signature.getParameterTypes(fProposal.getSignature()))) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK)) {
          setReplacementString(replacement + SPACE);
        }
      }
 else {
        setReplacementString(recomputeReplacementString());
        trigger=0;
      }
    }
    super.apply(document,trigger,offset);
    if (fContextInformationPosition > 0) {
      setContextInformationPosition(getReplacementOffset() + fContextInformationPosition);
      if (fPositions == null || fPositions.isEmpty()) {
        fSelectedRegion=new Region(fContextInformationPosition,0);
      }
 else {
        fSelectedRegion=new Region(fPositions.get(0).getOffset(),fPositions.get(0).getLength());
      }
    }
  }
 catch (  Exception e) {
    GroovyContentAssist.logError(e);
    ensurePositionCategoryRemoved(document);
  }
}","@Override public void apply(IDocument document,char trigger,int offset){
  try {
    if (trigger == '{' && (fProposal.getCompletion() != null && fProposal.getCompletion().length > 0)) {
      String replacement=getReplacementString();
      if (replacement.endsWith(""String_Node_Str"") || fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
        trigger=0;
      }
 else       if (fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION || !fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES) || !lastParamAcceptsClosure(Signature.getParameterTypes(fProposal.getSignature()))) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK)) {
          setReplacementString(replacement + SPACE);
        }
      }
 else {
        setReplacementString(recomputeReplacementString());
        trigger=0;
      }
    }
    super.apply(document,trigger,offset);
    if (fContextInformationPosition > 0) {
      setContextInformationPosition(getReplacementOffset() + fContextInformationPosition);
      if (fProposal.getCompletion() != null && fProposal.getCompletion().length > 0) {
        if (fPositions == null || fPositions.isEmpty()) {
          fSelectedRegion=new Region(fContextInformationPosition,0);
        }
 else {
          fSelectedRegion=new Region(fPositions.get(0).getOffset(),fPositions.get(0).getLength());
        }
      }
    }
  }
 catch (  Exception e) {
    GroovyContentAssist.logError(e);
    ensurePositionCategoryRemoved(document);
  }
}",0.9653808110781404
185454,"private ICompletionProposal proposeConstructor(char[] simpleTypeName,int parameterCount,char[] signature,char[][] parameterTypes,char[][] parameterNames,int modifiers,char[] packageName,int typeModifiers,int accessibility,char[] fullyQualifiedName,boolean isQualified,int extraFlags){
  char[] completionExpressionChars=completionExpression.toCharArray();
  if (contextOnly && !CharOperation.equals(completionExpressionChars,simpleTypeName) && !CharOperation.equals(completionExpressionChars,fullyQualifiedName)) {
    return null;
  }
  GroovyCompletionProposal proposal=createProposal(contextOnly ? CompletionProposal.METHOD_REF : CompletionProposal.CONSTRUCTOR_INVOCATION,offset - 1);
  proposal.setIsContructor(true);
  proposal.setName(simpleTypeName);
  proposal.setTypeName(simpleTypeName);
  proposal.setPackageName(packageName);
  proposal.setDeclarationTypeName(simpleTypeName);
  proposal.setDeclarationPackageName(packageName);
  proposal.setDeclarationSignature(CompletionEngine.createNonGenericTypeSignature(packageName,simpleTypeName));
  proposal.setFlags(Flags.isDeprecated(typeModifiers) ? modifiers | Flags.AccDeprecated : modifiers);
  proposal.setAdditionalFlags(extraFlags);
  proposal.setAccessibility(accessibility);
  populateParameterInfo(proposal,parameterCount,parameterNames,parameterTypes,signature,isQualified);
  populateReplacementInfo(proposal,packageName,simpleTypeName,fullyQualifiedName);
  float relevanceMultiplier=(accessibility == IAccessRule.K_ACCESSIBLE) ? 3 : 0;
  relevanceMultiplier+=computeRelevanceForCaseMatching(completionExpressionChars,simpleTypeName);
  proposal.setRelevance(Relevance.MEDIUM_HIGH.getRelevance(relevanceMultiplier));
  GroovyJavaMethodCompletionProposal lazyProposal=new GroovyJavaMethodCompletionProposal(proposal,getProposalOptions(),javaContext,null);
  lazyProposal.setImportRewite(groovyRewriter.getImportRewrite(monitor));
  return lazyProposal;
}","private ICompletionProposal proposeConstructor(char[] simpleTypeName,int parameterCount,char[] signature,char[][] parameterTypes,char[][] parameterNames,int modifiers,char[] packageName,int typeModifiers,int accessibility,char[] fullyQualifiedName,boolean isQualified,int extraFlags){
  char[] completionExpressionChars=completionExpression.toCharArray();
  int completionOffset=offset - 1, kind=CompletionProposal.CONSTRUCTOR_INVOCATION;
  if (contextOnly) {
    if (!CharOperation.equals(completionExpressionChars,simpleTypeName) && !CharOperation.equals(completionExpressionChars,fullyQualifiedName)) {
      return null;
    }
    kind=CompletionProposal.METHOD_REF;
    completionOffset=((MethodInfoContentAssistContext)context).methodNameEnd;
  }
  GroovyCompletionProposal proposal=createProposal(kind,completionOffset);
  proposal.setIsContructor(true);
  proposal.setName(simpleTypeName);
  proposal.setTypeName(simpleTypeName);
  proposal.setPackageName(packageName);
  proposal.setDeclarationTypeName(simpleTypeName);
  proposal.setDeclarationPackageName(packageName);
  proposal.setDeclarationSignature(CompletionEngine.createNonGenericTypeSignature(packageName,simpleTypeName));
  proposal.setFlags(Flags.isDeprecated(typeModifiers) ? modifiers | Flags.AccDeprecated : modifiers);
  proposal.setAdditionalFlags(extraFlags);
  proposal.setAccessibility(accessibility);
  populateParameterInfo(proposal,parameterCount,parameterNames,parameterTypes,signature,isQualified);
  populateReplacementInfo(proposal,packageName,simpleTypeName,fullyQualifiedName);
  float relevanceMultiplier=(accessibility == IAccessRule.K_ACCESSIBLE) ? 3 : 0;
  relevanceMultiplier+=computeRelevanceForCaseMatching(completionExpressionChars,simpleTypeName);
  proposal.setRelevance(Relevance.MEDIUM_HIGH.getRelevance(relevanceMultiplier));
  GroovyJavaMethodCompletionProposal lazyProposal=new GroovyJavaMethodCompletionProposal(proposal,getProposalOptions(),javaContext,null);
  lazyProposal.setImportRewite(groovyRewriter.getImportRewrite(monitor));
  return lazyProposal;
}",0.8755644756648269
185455,"@Override public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  int kind;
switch (context.location) {
case ANNOTATION_BODY:
    kind=CompletionProposal.ANNOTATION_ATTRIBUTE_REF;
  break;
case IMPORT:
kind=CompletionProposal.METHOD_NAME_REFERENCE;
break;
case EXPRESSION:
if (METHOD_POINTER_COMPLETION.matcher(context.fullCompletionExpression).matches()) {
kind=CompletionProposal.METHOD_NAME_REFERENCE;
break;
}
default :
kind=CompletionProposal.METHOD_REF;
}
GroovyCompletionProposal proposal=new GroovyCompletionProposal(kind,context.completionLocation);
if (context.location == ContentAssistLocation.METHOD_CONTEXT) {
MethodInfoContentAssistContext methodContext=(MethodInfoContentAssistContext)context;
if (!methodContext.methodName.equals(method.getName())) {
return null;
}
proposal.setCompletion(CharOperation.NO_CHAR);
proposal.setReplaceRange(context.completionLocation,context.completionLocation);
}
 else {
boolean parens=(kind == CompletionProposal.ANNOTATION_ATTRIBUTE_REF ? false : !isParens(context,javaContext));
proposal.setCompletion(completionName(parens));
proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionEnd);
}
proposal.setDeclarationSignature(createTypeSignature(method.getDeclaringClass()));
proposal.setName(method.getName().toCharArray());
if (method instanceof NamedArgsMethodNode) {
fillInExtraParameters((NamedArgsMethodNode)method,proposal);
}
 else {
proposal.setParameterNames(createAllParameterNames(context.unit));
proposal.setParameterTypeNames(getParameterTypeNames(method.getParameters()));
}
proposal.setFlags(getModifiers());
proposal.setAdditionalFlags(CompletionFlags.Default);
proposal.setSignature(createMethodSignature());
proposal.setKey(proposal.getSignature());
proposal.setRelevance(computeRelevance(context));
if (getRequiredStaticImport() != null) {
CompletionProposal importProposal;
if (new AssistOptions(javaContext.getProject().getOptions(true)).suggestStaticImport) {
importProposal=CompletionProposal.create(CompletionProposal.METHOD_IMPORT,context.completionLocation);
importProposal.setAdditionalFlags(CompletionFlags.StaticImport);
importProposal.setDeclarationSignature(proposal.getDeclarationSignature());
importProposal.setName(proposal.getName());
}
 else {
importProposal=CompletionProposal.create(CompletionProposal.TYPE_IMPORT,context.completionLocation);
importProposal.setSignature(proposal.getDeclarationSignature());
}
proposal.setRequiredProposals(new CompletionProposal[]{importProposal});
}
LazyJavaCompletionProposal lazyProposal=null;
if (kind == CompletionProposal.ANNOTATION_ATTRIBUTE_REF) {
proposal.setSignature(createTypeSignature(getMethod().getReturnType()));
proposal.setFlags(getModifiers() & 0xFFFDFFFF);
lazyProposal=new LazyJavaCompletionProposal(proposal,javaContext);
lazyProposal.setProposalInfo(new AnnotationAtttributeProposalInfo(javaContext.getProject(),proposal));
}
 else {
lazyProposal=new GroovyJavaMethodCompletionProposal(proposal,getProposalFormattingOptions(),javaContext,contributor);
}
return lazyProposal;
}","@Override @SuppressWarnings(""String_Node_Str"") public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  int completionOffset=context.completionLocation, kind=CompletionProposal.METHOD_REF;
switch (context.location) {
case ANNOTATION_BODY:
    kind=CompletionProposal.ANNOTATION_ATTRIBUTE_REF;
  break;
case EXPRESSION:
if (METHOD_POINTER_COMPLETION.matcher(context.fullCompletionExpression).matches()) {
  kind=CompletionProposal.METHOD_NAME_REFERENCE;
}
break;
case IMPORT:
kind=CompletionProposal.METHOD_NAME_REFERENCE;
break;
case METHOD_CONTEXT:
MethodInfoContentAssistContext methodContext=(MethodInfoContentAssistContext)context;
if (!methodContext.methodName.equals(method.getName())) {
return null;
}
completionOffset=methodContext.methodNameEnd;
}
GroovyCompletionProposal proposal=new GroovyCompletionProposal(kind,completionOffset);
if (context.location == ContentAssistLocation.METHOD_CONTEXT) {
proposal.setCompletion(CharOperation.NO_CHAR);
proposal.setReplaceRange(context.completionLocation,context.completionLocation);
}
 else {
boolean parens=(kind == CompletionProposal.ANNOTATION_ATTRIBUTE_REF ? false : !isParens(context,javaContext));
proposal.setCompletion(completionName(parens));
proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionEnd);
}
proposal.setDeclarationSignature(createTypeSignature(method.getDeclaringClass()));
proposal.setName(method.getName().toCharArray());
if (method instanceof NamedArgsMethodNode) {
fillInExtraParameters((NamedArgsMethodNode)method,proposal);
}
 else {
proposal.setParameterNames(createAllParameterNames(context.unit));
proposal.setParameterTypeNames(getParameterTypeNames(method.getParameters()));
}
proposal.setFlags(getModifiers());
proposal.setAdditionalFlags(CompletionFlags.Default);
proposal.setSignature(createMethodSignature());
proposal.setKey(proposal.getSignature());
proposal.setRelevance(computeRelevance(context));
if (getRequiredStaticImport() != null) {
CompletionProposal importProposal;
if (new AssistOptions(javaContext.getProject().getOptions(true)).suggestStaticImport) {
importProposal=CompletionProposal.create(CompletionProposal.METHOD_IMPORT,context.completionLocation);
importProposal.setAdditionalFlags(CompletionFlags.StaticImport);
importProposal.setDeclarationSignature(proposal.getDeclarationSignature());
importProposal.setName(proposal.getName());
}
 else {
importProposal=CompletionProposal.create(CompletionProposal.TYPE_IMPORT,context.completionLocation);
importProposal.setSignature(proposal.getDeclarationSignature());
}
proposal.setRequiredProposals(new CompletionProposal[]{importProposal});
}
LazyJavaCompletionProposal lazyProposal=null;
if (kind == CompletionProposal.ANNOTATION_ATTRIBUTE_REF) {
proposal.setSignature(createTypeSignature(getMethod().getReturnType()));
proposal.setFlags(getModifiers() & 0xFFFDFFFF);
lazyProposal=new LazyJavaCompletionProposal(proposal,javaContext);
lazyProposal.setProposalInfo(new AnnotationAtttributeProposalInfo(javaContext.getProject(),proposal));
}
 else {
lazyProposal=new GroovyJavaMethodCompletionProposal(proposal,getProposalFormattingOptions(),javaContext,contributor);
}
return lazyProposal;
}",0.8996108949416343
185456,"@Override protected void setUpLinkedMode(IDocument document,char closingCharacter){
  if (getTextViewer() != null) {
    try {
      int baseOffset=getReplacementOffset();
      LinkedModeModel model=new LinkedModeModel();
      for (int i=0; i < fPositions.size(); i+=1) {
        Position position=fPositions.get(i);
        position.setOffset(baseOffset + position.getOffset());
        LinkedPositionGroup group=new LinkedPositionGroup();
        if (fProposals.size() <= i || fProposals.get(i).length < 2) {
          group.addPosition(new LinkedPosition(document,position.getOffset(),position.getLength(),LinkedPositionGroup.NO_STOP));
        }
 else {
          ensurePositionCategoryInstalled(document,model);
          document.addPosition(fPositionCategory,position);
          group.addPosition(new ProposalPosition(document,position.getOffset(),position.getLength(),LinkedPositionGroup.NO_STOP,fProposals.get(i)));
        }
        model.addGroup(group);
      }
      JavaEditor editor=getJavaEditor();
      if (editor != null) {
        model.addLinkingListener(new EditorHighlightingSynchronizer(editor));
      }
      model.forceInstall();
      LinkedModeUI ui=new EditorLinkedModeUI(model,getTextViewer());
      ui.setCyclingMode(LinkedModeUI.CYCLE_NEVER);
      ui.setDoContextInfo(true);
      ui.setExitPolicy(new ExitPolicy(closingCharacter,document));
      ui.setExitPosition(getTextViewer(),baseOffset + getCursorPosition(),0,Integer.MAX_VALUE);
      ui.enter();
    }
 catch (    BadLocationException|BadPositionCategoryException e) {
      GroovyContentAssist.logError(e);
    }
  }
}","@Override protected void setUpLinkedMode(IDocument document,char closingCharacter){
  if (getTextViewer() != null) {
    try {
      int baseOffset=getReplacementOffset();
      LinkedModeModel model=new LinkedModeModel();
      if (fPositions == null) {
        LinkedPositionGroup group=new LinkedPositionGroup();
        group.addPosition(new LinkedPosition(document,baseOffset + fContextInformationPosition,0));
        model.addGroup(group);
      }
 else {
        for (int i=0, n=fPositions.size(); i < n; i+=1) {
          Position position=fPositions.get(i);
          position.setOffset(baseOffset + position.getOffset());
          LinkedPositionGroup group=new LinkedPositionGroup();
          if (fProposals.size() <= i || fProposals.get(i).length <= 1) {
            group.addPosition(new LinkedPosition(document,position.getOffset(),position.getLength(),LinkedPositionGroup.NO_STOP));
          }
 else {
            ensurePositionCategoryInstalled(document,model);
            document.addPosition(fPositionCategory,position);
            group.addPosition(new ProposalPosition(document,position.getOffset(),position.getLength(),LinkedPositionGroup.NO_STOP,fProposals.get(i)));
          }
          model.addGroup(group);
        }
      }
      JavaEditor editor=getJavaEditor();
      if (editor != null) {
        model.addLinkingListener(new EditorHighlightingSynchronizer(editor));
      }
      model.forceInstall();
      LinkedModeUI ui=new EditorLinkedModeUI(model,getTextViewer());
      ui.setCyclingMode(LinkedModeUI.CYCLE_NEVER);
      ui.setDoContextInfo(true);
      ui.setExitPolicy(new ExitPolicy(closingCharacter,document));
      ui.setExitPosition(getTextViewer(),baseOffset + getCursorPosition(),0,Integer.MAX_VALUE);
      ui.enter();
    }
 catch (    BadLocationException|BadPositionCategoryException e) {
      GroovyContentAssist.logError(e);
    }
  }
}",0.9095048377916904
185457,"@Override protected String computeReplacementString(){
  if (fProposal.getCompletion() == null || fProposal.getCompletion().length == 0) {
    return ""String_Node_Str"";
  }
  char[] proposalName=fProposal.getName();
  boolean hasWhitespace=ProposalUtils.hasWhitespace(proposalName);
  if (fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
    return String.valueOf(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  }
  if (!hasWhitespace && (!hasParameters() || !hasArgumentList())) {
    String replacementString=super.computeReplacementString();
    if (replacementString.endsWith(""String_Node_Str"")) {
      replacementString=replacementString.substring(0,replacementString.length() - 1);
    }
    return replacementString;
  }
  StringBuffer buffer=new StringBuffer();
  fProposal.setName(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  appendMethodNameReplacement(buffer);
  fProposal.setName(proposalName);
  if (!hasParameters()) {
    while (Character.isWhitespace(buffer.charAt(buffer.length() - 1))) {
      buffer.deleteCharAt(buffer.length() - 1);
    }
    if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BETWEEN_EMPTY_PARENS_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    buffer.append(RPAREN);
  }
 else   if (!fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES)) {
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setCursorPosition(buffer.length());
    setContextInformationPosition(getCursorPosition());
    if (!fPreferences.bCommandChaining)     buffer.append(RPAREN);
  }
 else {
    int indexOfLastClosure=-1;
    char[][] namedParameterTypes=((GroovyCompletionProposal)fProposal).getNamedParameterTypeNames();
    char[][] regularParameterTypes=((GroovyCompletionProposal)fProposal).getRegularParameterTypeNames();
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_NOPARENS)) {
      if (lastParamIsClosure(regularParameterTypes,CharOperation.NO_CHAR_CHAR)) {
        indexOfLastClosure=namedParameterTypes.length + regularParameterTypes.length - 1;
      }
      if (indexOfLastClosure == 0) {
        buffer.deleteCharAt(buffer.length() - 1);
        if (!fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
      }
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    char[][] namedParameterNames=((GroovyCompletionProposal)fProposal).getNamedParameterNames();
    char[][] regularParameterNames=((GroovyCompletionProposal)fProposal).getRegularParameterNames();
    int namedCount=namedParameterNames.length, totalCount=regularParameterNames.length + namedCount;
    computeReplacementProposals(namedParameterNames,regularParameterNames,indexOfLastClosure);
    for (int i=0; i < totalCount; i+=1) {
      @SuppressWarnings(""String_Node_Str"") char[] nextName, nextType;
      if (i < namedCount) {
        nextName=namedParameterNames[i];
        nextType=namedParameterTypes[i];
      }
 else {
        nextName=regularParameterNames[i - namedCount];
        nextType=regularParameterTypes[i - namedCount];
      }
      String nextValue=fProposals.get(i)[0].getDisplayString();
      if ((fPreferences.isEnabled(GroovyContentAssist.NAMED_ARGUMENTS) || i < namedCount) && i != indexOfLastClosure) {
        buffer.append(nextName);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
      }
      fPositions.get(i).setLength(nextValue.length());
      fPositions.get(i).setOffset(buffer.length());
      buffer.append(nextValue);
      if (i == (indexOfLastClosure - 1) || (i != indexOfLastClosure && i == (totalCount - 1) && !fPreferences.bCommandChaining)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
        buffer.append(RPAREN);
        if (i == (indexOfLastClosure - 1) && (!fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) || fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK))) {
          buffer.append(SPACE);
        }
      }
 else       if (i < (totalCount - 1)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
        buffer.append(COMMA);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
      }
    }
  }
  return buffer.toString();
}","@Override protected String computeReplacementString(){
  if (fProposal.getCompletion() == null || fProposal.getCompletion().length == 0) {
    return ""String_Node_Str"";
  }
  char[] proposalName=fProposal.getName();
  boolean hasWhitespace=ProposalUtils.hasWhitespace(proposalName);
  if (fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
    return String.valueOf(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  }
  if (!hasWhitespace && (!hasParameters() || !hasArgumentList())) {
    String replacementString=super.computeReplacementString();
    if (replacementString.endsWith(""String_Node_Str"")) {
      replacementString=replacementString.substring(0,replacementString.length() - 1);
    }
    return replacementString;
  }
  StringBuffer buffer=new StringBuffer();
  fProposal.setName(!hasWhitespace ? proposalName : CharOperation.concat('""',proposalName,'""'));
  appendMethodNameReplacement(buffer);
  fProposal.setName(proposalName);
  if (!hasParameters()) {
    while (Character.isWhitespace(buffer.charAt(buffer.length() - 1))) {
      buffer.deleteCharAt(buffer.length() - 1);
    }
    if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BETWEEN_EMPTY_PARENS_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    buffer.append(RPAREN);
  }
 else   if (!fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES)) {
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    if (!fPreferences.bCommandChaining)     buffer.append(RPAREN);
  }
 else {
    int indexOfLastClosure=-1;
    char[][] namedParameterTypes=((GroovyCompletionProposal)fProposal).getNamedParameterTypeNames();
    char[][] regularParameterTypes=((GroovyCompletionProposal)fProposal).getRegularParameterTypeNames();
    if (fPreferences.bCommandChaining) {
      int i=buffer.lastIndexOf(LPAREN);
      while (Character.isWhitespace(buffer.charAt(i - 1))) {
        i-=1;
      }
      buffer.replace(i,buffer.length(),SPACE);
    }
 else     if (fPreferences.isEnabled(GroovyContentAssist.CLOSURE_NOPARENS)) {
      if (lastParamIsClosure(regularParameterTypes,CharOperation.NO_CHAR_CHAR)) {
        indexOfLastClosure=namedParameterTypes.length + regularParameterTypes.length - 1;
      }
      if (indexOfLastClosure == 0) {
        buffer.deleteCharAt(buffer.length() - 1);
        if (!fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
      }
    }
 else     if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_PAREN_IN_METHOD_INVOCATION)) {
      buffer.append(SPACE);
    }
    setContextInformationPosition(buffer.length());
    char[][] namedParameterNames=((GroovyCompletionProposal)fProposal).getNamedParameterNames();
    char[][] regularParameterNames=((GroovyCompletionProposal)fProposal).getRegularParameterNames();
    int namedCount=namedParameterNames.length, totalCount=regularParameterNames.length + namedCount;
    computeReplacementProposals(namedParameterNames,regularParameterNames,indexOfLastClosure);
    for (int i=0; i < totalCount; i+=1) {
      @SuppressWarnings(""String_Node_Str"") char[] nextName, nextType;
      if (i < namedCount) {
        nextName=namedParameterNames[i];
        nextType=namedParameterTypes[i];
      }
 else {
        nextName=regularParameterNames[i - namedCount];
        nextType=regularParameterTypes[i - namedCount];
      }
      String nextValue=fProposals.get(i)[0].getDisplayString();
      if ((fPreferences.isEnabled(GroovyContentAssist.NAMED_ARGUMENTS) || i < namedCount) && i != indexOfLastClosure) {
        buffer.append(nextName);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
        buffer.append(""String_Node_Str"");
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COLON_IN_LABELED_STATEMENT)) {
          buffer.append(SPACE);
        }
      }
      fPositions.get(i).setLength(nextValue.length());
      fPositions.get(i).setOffset(buffer.length());
      buffer.append(nextValue);
      if (i == (indexOfLastClosure - 1) || (i != indexOfLastClosure && i == (totalCount - 1) && !fPreferences.bCommandChaining)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_CLOSING_PAREN_IN_METHOD_INVOCATION)) {
          buffer.append(SPACE);
        }
        buffer.append(RPAREN);
        if (i == (indexOfLastClosure - 1) && (!fPreferences.isEnabled(GroovyContentAssist.CLOSURE_BRACKETS) || fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK))) {
          buffer.append(SPACE);
        }
      }
 else       if (i < (totalCount - 1)) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
        buffer.append(COMMA);
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COMMA_IN_METHOD_INVOCATION_ARGUMENTS)) {
          buffer.append(SPACE);
        }
      }
    }
  }
  return buffer.toString();
}",0.9932244614315496
185458,"@Override public void apply(IDocument document,char trigger,int offset){
  try {
    if (trigger == '{' && (fProposal.getCompletion() != null && fProposal.getCompletion().length > 0)) {
      String replacement=getReplacementString();
      if (replacement.endsWith(""String_Node_Str"") || fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
        trigger=0;
      }
 else       if (fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION || !fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES) || !lastParamAcceptsClosure(Signature.getParameterTypes(fProposal.getSignature()))) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK)) {
          setReplacementString(replacement + SPACE);
        }
      }
 else {
        setReplacementString(recomputeReplacementString());
        trigger=0;
      }
    }
    super.apply(document,trigger,offset);
    if (getContextInformationPosition() > 0) {
      setContextInformationPosition(getContextInformationPosition() + getReplacementOffset());
    }
    if (fPositions != null && !fPositions.isEmpty()) {
      fSelectedRegion=new Region(fPositions.get(0).getOffset(),fPositions.get(0).getLength());
    }
  }
 catch (  Exception e) {
    GroovyContentAssist.logError(e);
    ensurePositionCategoryRemoved(document);
  }
}","@Override public void apply(IDocument document,char trigger,int offset){
  try {
    if (trigger == '{' && (fProposal.getCompletion() != null && fProposal.getCompletion().length > 0)) {
      String replacement=getReplacementString();
      if (replacement.endsWith(""String_Node_Str"") || fProposal.getKind() == CompletionProposal.METHOD_NAME_REFERENCE) {
        trigger=0;
      }
 else       if (fProposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION || !fPreferences.isEnabled(PreferenceConstants.CODEASSIST_FILL_ARGUMENT_NAMES) || !lastParamAcceptsClosure(Signature.getParameterTypes(fProposal.getSignature()))) {
        if (fPreferences.isEnabled(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_BRACE_IN_BLOCK)) {
          setReplacementString(replacement + SPACE);
        }
      }
 else {
        setReplacementString(recomputeReplacementString());
        trigger=0;
      }
    }
    super.apply(document,trigger,offset);
    if (fContextInformationPosition > 0) {
      setContextInformationPosition(getReplacementOffset() + fContextInformationPosition);
      if (fPositions == null || fPositions.isEmpty()) {
        fSelectedRegion=new Region(fContextInformationPosition,0);
      }
 else {
        fSelectedRegion=new Region(fPositions.get(0).getOffset(),fPositions.get(0).getLength());
      }
    }
  }
 catch (  Exception e) {
    GroovyContentAssist.logError(e);
    ensurePositionCategoryRemoved(document);
  }
}",0.8504213483146067
185459,"private ICompletionProposal newEnumProposal(Position position,String replacement,CompletionProposal supporting,Image image,char[] triggers){
  CompletionProposal groovyProposal=CompletionProposal.create(CompletionProposal.METHOD_REF,0);
  groovyProposal.setRequiredProposals(new CompletionProposal[]{supporting});
  JavaCompletionProposal javaProposal=new JavaCompletionProposal(replacement,0,0,image,null,1,false,invocationContext){
    @Override public int getReplacementLength(){
      return position.getLength();
    }
    @Override public int getReplacementOffset(){
      return position.getOffset();
    }
    @Override public void setReplacementOffset(    int offset){
      if (offset > getReplacementOffset()) {
        position.setOffset(getReplacementOffset() + (getReplacementLength() - super.getReplacementLength()));
        position.setLength(super.getReplacementLength());
      }
      super.setReplacementOffset(offset);
    }
    @Override public void setReplacementLength(    int length){
      super.setReplacementLength(length);
    }
  }
;
  javaProposal.setProposalInfo(new FieldProposalInfo(invocationContext.getProject(),groovyProposal));
  javaProposal.setTriggerCharacters(triggers);
  return javaProposal;
}","private ICompletionProposal newEnumProposal(Position position,String replacement,CompletionProposal supporting,Image image,char[] triggers){
  CompletionProposal groovyProposal=CompletionProposal.create(CompletionProposal.METHOD_REF,0);
  groovyProposal.setRequiredProposals(new CompletionProposal[]{supporting});
  JavaCompletionProposal javaProposal=new JavaCompletionProposal(replacement,0,0,image,null,1,false,invocationContext){
    @Override public int getReplacementLength(){
      return position.getLength();
    }
    @Override public int getReplacementOffset(){
      return position.getOffset();
    }
  }
;
  javaProposal.setProposalInfo(new FieldProposalInfo(invocationContext.getProject(),groovyProposal));
  javaProposal.setTriggerCharacters(triggers);
  return javaProposal;
}",0.6184145741014279
185460,"@Test public void testImportStatic3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertTrue(irs[0] instanceof AliasImportReference);
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
  assertEquals(""String_Node_Str"",new String(((AliasImportReference)irs[0]).getSimpleName()));
}","@Test public void testImportStatic3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  ImportReference ref=getCUDeclFor(""String_Node_Str"").imports[0];
  assertTrue(ref.isStatic());
  assertTrue(ref instanceof AliasImportReference);
  assertEquals(""String_Node_Str"",ref.toString());
  assertEquals(""String_Node_Str"",String.valueOf(ref.getSimpleName()));
}",0.7560975609756098
185461,"@Test public void testImportStatic1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}","@Test public void testImportStatic1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  ImportReference ref=getCUDeclFor(""String_Node_Str"").imports[0];
  assertTrue(ref.isStatic());
  assertEquals(""String_Node_Str"",ref.toString());
  assertFalse(ref instanceof AliasImportReference);
  assertEquals(""String_Node_Str"",String.valueOf(ref.getSimpleName()));
}",0.6006528835690969
185462,"@Test public void testImportStatic2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}","@Test public void testImportStatic2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  ImportReference ref=getCUDeclFor(""String_Node_Str"").imports[0];
  assertTrue(ref.isStatic());
  assertEquals(""String_Node_Str"",ref.toString());
}",0.7989949748743719
185463,"private ClassNode javaTypeToGroovyClass(IType type){
  ICompilationUnit unit=type.getCompilationUnit();
  if (unit instanceof GroovyCompilationUnit) {
    ModuleNode module=((GroovyCompilationUnit)unit).getModuleNode();
    List<ClassNode> classes=module.getClasses();
    for (    ClassNode classNode : classes) {
      if (classNode.getNameWithoutPackage().equals(type.getElementName())) {
        return classNode;
      }
    }
  }
  return null;
}","private static ClassNode javaTypeToGroovyClass(IType type){
  ICompilationUnit unit=type.getCompilationUnit();
  if (unit instanceof GroovyCompilationUnit) {
    ModuleNode module=((GroovyCompilationUnit)unit).getModuleNode();
    List<ClassNode> classes=module.getClasses();
    for (    ClassNode classNode : classes) {
      if (classNode.getNameWithoutPackage().equals(type.getElementName())) {
        return classNode;
      }
    }
  }
  return null;
}",0.9923161361141604
185464,"private Parameter[] getParametersForTypes(String[] signatures){
  int n=signatures.length;
  Parameter[] parameters=new Parameter[n];
  for (int i=0; i < n; i+=1) {
    parameters[i]=new Parameter(ClassHelper.makeWithoutCaching(Signature.toString(signatures[i])),null);
  }
  return parameters;
}","private Parameter[] getParametersForTypes(String[] signatures){
  int n=signatures.length;
  Parameter[] parameters=new Parameter[n];
  for (int i=0; i < n; i+=1) {
    parameters[i]=new Parameter(javaTypeToGroovyClass(signatures[i]),null);
  }
  return parameters;
}",0.8419182948490231
185465,"@Test public void testConstructorReferenceSearch() throws Exception {
  String groovyContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String otherContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  GroovyCompilationUnit first=createUnit(""String_Node_Str"",""String_Node_Str"",groovyContents);
  createUnit(""String_Node_Str"",""String_Node_Str"",otherContents);
  IMethod constructor=first.getType(""String_Node_Str"").getMethods()[0];
  MockSearchRequestor requestor=new MockSearchRequestor();
  SearchEngine engine=new SearchEngine();
  engine.search(SearchPattern.createPattern(constructor,IJavaSearchConstants.REFERENCES),new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},SearchEngine.createJavaSearchScope(new IJavaElement[]{first.getPackageFragmentRoot()},false),requestor,new NullProgressMonitor());
  List<SearchMatch> matches=requestor.getMatches();
  assertEquals(""String_Node_Str"" + matches,6,matches.size());
  int fooCnt=0, otherCnt=0;
  for (  SearchMatch match : matches) {
    if (match.getElement() instanceof IMethod) {
      if (((IMethod)match.getElement()).getResource().getName().equals(""String_Node_Str"")) {
        fooCnt+=1;
      }
 else       if (((IMethod)match.getElement()).getResource().getName().equals(""String_Node_Str"")) {
        otherCnt+=1;
      }
    }
  }
  assertEquals(""String_Node_Str"",2,fooCnt);
  assertEquals(""String_Node_Str"",4,otherCnt);
}","@Test public void testConstructorReferenceSearch() throws Exception {
  String groovyContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String otherContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  GroovyCompilationUnit first=createUnit(""String_Node_Str"",""String_Node_Str"",groovyContents);
  createUnit(""String_Node_Str"",""String_Node_Str"",otherContents);
  IMethod constructor=first.getType(""String_Node_Str"").getMethods()[0];
  new SearchEngine().search(SearchPattern.createPattern(constructor,IJavaSearchConstants.REFERENCES),new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},SearchEngine.createJavaSearchScope(new IJavaElement[]{first.getPackageFragmentRoot()},false),searchRequestor,new NullProgressMonitor());
  List<SearchMatch> matches=searchRequestor.getMatches();
  assertEquals(""String_Node_Str"" + matches,6,matches.size());
  int fooCnt=0, otherCnt=0;
  for (  SearchMatch match : matches) {
    if (match.getElement() instanceof IMethod) {
      if (((IMethod)match.getElement()).getResource().getName().equals(""String_Node_Str"")) {
        fooCnt+=1;
      }
 else       if (((IMethod)match.getElement()).getResource().getName().equals(""String_Node_Str"")) {
        otherCnt+=1;
      }
    }
  }
  assertEquals(""String_Node_Str"",2,fooCnt);
  assertEquals(""String_Node_Str"",4,otherCnt);
}",0.9648046496609622
185466,"@Override public void buildFieldsAndMethods(){
  super.buildFieldsAndMethods();
  GroovyTypeDeclaration context=(GroovyTypeDeclaration)referenceContext;
  GroovyTypeDeclaration[] anonymousTypes=context.getAnonymousTypes();
  if (anonymousTypes != null) {
    for (    GroovyTypeDeclaration anonType : anonymousTypes) {
      anonType.scope=new GroovyClassScope(this,anonType);
      anonType.resolve(anonType.enclosingScope);
    }
  }
  for (  MethodBinding method : referenceContext.binding.methods()) {
    fixupTypeParameters(method);
  }
}","@Override public void buildFieldsAndMethods(){
  super.buildFieldsAndMethods();
  GroovyTypeDeclaration[] anonymousTypes=((GroovyTypeDeclaration)referenceContext).getAnonymousTypes();
  if (anonymousTypes != null) {
    for (    GroovyTypeDeclaration anonType : anonymousTypes) {
      anonType.scope=new GroovyClassScope(this,anonType);
      anonType.resolve(anonType.enclosingScope);
    }
  }
  for (  MethodBinding method : referenceContext.binding.methods()) {
    fixupTypeParameters(method);
  }
}",0.8960915157292659
185467,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185468,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185469,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185470,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185471,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185472,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185473,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185474,"protected void process(PossibleMatch possibleMatch,boolean bindingsWereCreated) throws CoreException {
  if (possibleMatch.isInterestingSourceFile()) {
    try {
      this.lookupEnvironment.buildTypeBindings(possibleMatch.parsedUnit,null);
    }
 catch (    Throwable t) {
      t.printStackTrace();
    }
    possibleMatch.parsedUnit.resolve();
    return;
  }
  this.currentPossibleMatch=possibleMatch;
  CompilationUnitDeclaration unit=possibleMatch.parsedUnit;
  try {
    if (unit.isEmpty()) {
      if (this.currentPossibleMatch.openable instanceof ClassFile) {
        ClassFile classFile=(ClassFile)this.currentPossibleMatch.openable;
        IBinaryType info=null;
        try {
          info=getBinaryInfo(classFile,classFile.resource());
        }
 catch (        CoreException ce) {
        }
        if (info != null) {
          boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
          this.patternLocator.mayBeGeneric=false;
          try {
            new ClassFileMatchLocator().locateMatches(this,classFile,info);
          }
  finally {
            this.patternLocator.mayBeGeneric=mayBeGeneric;
          }
        }
      }
 else       if (this.currentPossibleMatch.openable instanceof ModularClassFile && unit.moduleDeclaration == null) {
        boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
        this.patternLocator.mayBeGeneric=false;
        try {
          new ModularClassFileMatchLocator().locateMatches(this,(ModularClassFile)this.currentPossibleMatch.openable);
        }
  finally {
          this.patternLocator.mayBeGeneric=mayBeGeneric;
        }
        return;
      }
      if (!unit.isModuleInfo())       return;
    }
    if (hasAlreadyDefinedType(unit))     return;
    boolean mustResolve=(this.pattern.mustResolve || possibleMatch.nodeSet.mustResolve);
    if (bindingsWereCreated && mustResolve) {
      if (unit.types != null) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        reduceParseTree(unit);
        if (unit.scope != null) {
          unit.scope.faultInTypes();
        }
        unit.resolve();
      }
 else       if (unit.isPackageInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        unit.resolve();
      }
 else       if (unit.isModuleInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        if (unit.scope != null && unit.moduleDeclaration != null) {
          unit.moduleDeclaration.resolveTypeDirectives(unit.scope);
        }
      }
    }
    reportMatching(unit,mustResolve);
  }
 catch (  AbortCompilation e) {
    if (BasicSearchEngine.VERBOSE) {
      System.out.println(""String_Node_Str"" + String.valueOf(unit.getFileName()));
      e.printStackTrace();
    }
    reportMatching(unit,false);
    if (!(e instanceof AbortCompilationUnit)) {
      throw e;
    }
  }
 finally {
    this.lookupEnvironment.unitBeingCompleted=null;
    this.currentPossibleMatch=null;
  }
}","protected void process(PossibleMatch possibleMatch,boolean bindingsWereCreated) throws CoreException {
  if (possibleMatch.isInterestingSourceFile()) {
    return;
  }
  this.currentPossibleMatch=possibleMatch;
  CompilationUnitDeclaration unit=possibleMatch.parsedUnit;
  try {
    if (unit.isEmpty()) {
      if (this.currentPossibleMatch.openable instanceof ClassFile) {
        ClassFile classFile=(ClassFile)this.currentPossibleMatch.openable;
        IBinaryType info=null;
        try {
          info=getBinaryInfo(classFile,classFile.resource());
        }
 catch (        CoreException ce) {
        }
        if (info != null) {
          boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
          this.patternLocator.mayBeGeneric=false;
          try {
            new ClassFileMatchLocator().locateMatches(this,classFile,info);
          }
  finally {
            this.patternLocator.mayBeGeneric=mayBeGeneric;
          }
        }
      }
 else       if (this.currentPossibleMatch.openable instanceof ModularClassFile && unit.moduleDeclaration == null) {
        boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
        this.patternLocator.mayBeGeneric=false;
        try {
          new ModularClassFileMatchLocator().locateMatches(this,(ModularClassFile)this.currentPossibleMatch.openable);
        }
  finally {
          this.patternLocator.mayBeGeneric=mayBeGeneric;
        }
        return;
      }
      if (!unit.isModuleInfo())       return;
    }
    if (hasAlreadyDefinedType(unit))     return;
    boolean mustResolve=(this.pattern.mustResolve || possibleMatch.nodeSet.mustResolve);
    if (bindingsWereCreated && mustResolve) {
      if (unit.types != null) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        reduceParseTree(unit);
        if (unit.scope != null) {
          unit.scope.faultInTypes();
        }
        unit.resolve();
      }
 else       if (unit.isPackageInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        unit.resolve();
      }
 else       if (unit.isModuleInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        if (unit.scope != null && unit.moduleDeclaration != null) {
          unit.moduleDeclaration.resolveTypeDirectives(unit.scope);
        }
      }
    }
    reportMatching(unit,mustResolve);
  }
 catch (  AbortCompilation e) {
    if (BasicSearchEngine.VERBOSE) {
      System.out.println(""String_Node_Str"" + String.valueOf(unit.getFileName()));
      e.printStackTrace();
    }
    reportMatching(unit,false);
    if (!(e instanceof AbortCompilationUnit)) {
      throw e;
    }
  }
 finally {
    this.lookupEnvironment.unitBeingCompleted=null;
    this.currentPossibleMatch=null;
  }
}",0.9695455255349056
185475,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185476,"protected void process(PossibleMatch possibleMatch,boolean bindingsWereCreated) throws CoreException {
  if (possibleMatch.isInterestingSourceFile()) {
    try {
      this.lookupEnvironment.buildTypeBindings(possibleMatch.parsedUnit,null);
    }
 catch (    Throwable t) {
      t.printStackTrace();
    }
    possibleMatch.parsedUnit.resolve();
    return;
  }
  this.currentPossibleMatch=possibleMatch;
  CompilationUnitDeclaration unit=possibleMatch.parsedUnit;
  try {
    if (unit.isEmpty()) {
      if (this.currentPossibleMatch.openable instanceof ClassFile) {
        ClassFile classFile=(ClassFile)this.currentPossibleMatch.openable;
        IBinaryType info=null;
        try {
          info=getBinaryInfo(classFile,classFile.resource());
        }
 catch (        CoreException ce) {
        }
        if (info != null) {
          boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
          this.patternLocator.mayBeGeneric=false;
          try {
            new ClassFileMatchLocator().locateMatches(this,classFile,info);
          }
  finally {
            this.patternLocator.mayBeGeneric=mayBeGeneric;
          }
        }
      }
 else       if (this.currentPossibleMatch.openable instanceof ModularClassFile && unit.moduleDeclaration == null) {
        boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
        this.patternLocator.mayBeGeneric=false;
        try {
          new ModularClassFileMatchLocator().locateMatches(this,(ModularClassFile)this.currentPossibleMatch.openable);
        }
  finally {
          this.patternLocator.mayBeGeneric=mayBeGeneric;
        }
        return;
      }
      if (!unit.isModuleInfo())       return;
    }
    if (hasAlreadyDefinedType(unit))     return;
    boolean mustResolve=(this.pattern.mustResolve || possibleMatch.nodeSet.mustResolve);
    if (bindingsWereCreated && mustResolve) {
      if (unit.types != null) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        reduceParseTree(unit);
        if (unit.scope != null) {
          unit.scope.faultInTypes();
        }
        unit.resolve();
      }
 else       if (unit.isPackageInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        unit.resolve();
      }
 else       if (unit.isModuleInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        if (unit.scope != null && unit.moduleDeclaration != null) {
          unit.moduleDeclaration.resolveTypeDirectives(unit.scope);
        }
      }
    }
    reportMatching(unit,mustResolve);
  }
 catch (  AbortCompilation e) {
    if (BasicSearchEngine.VERBOSE) {
      System.out.println(""String_Node_Str"" + String.valueOf(unit.getFileName()));
      e.printStackTrace();
    }
    reportMatching(unit,false);
    if (!(e instanceof AbortCompilationUnit)) {
      throw e;
    }
  }
 finally {
    this.lookupEnvironment.unitBeingCompleted=null;
    this.currentPossibleMatch=null;
  }
}","protected void process(PossibleMatch possibleMatch,boolean bindingsWereCreated) throws CoreException {
  if (possibleMatch.isInterestingSourceFile()) {
    return;
  }
  this.currentPossibleMatch=possibleMatch;
  CompilationUnitDeclaration unit=possibleMatch.parsedUnit;
  try {
    if (unit.isEmpty()) {
      if (this.currentPossibleMatch.openable instanceof ClassFile) {
        ClassFile classFile=(ClassFile)this.currentPossibleMatch.openable;
        IBinaryType info=null;
        try {
          info=getBinaryInfo(classFile,classFile.resource());
        }
 catch (        CoreException ce) {
        }
        if (info != null) {
          boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
          this.patternLocator.mayBeGeneric=false;
          try {
            new ClassFileMatchLocator().locateMatches(this,classFile,info);
          }
  finally {
            this.patternLocator.mayBeGeneric=mayBeGeneric;
          }
        }
      }
 else       if (this.currentPossibleMatch.openable instanceof ModularClassFile && unit.moduleDeclaration == null) {
        boolean mayBeGeneric=this.patternLocator.mayBeGeneric;
        this.patternLocator.mayBeGeneric=false;
        try {
          new ModularClassFileMatchLocator().locateMatches(this,(ModularClassFile)this.currentPossibleMatch.openable);
        }
  finally {
          this.patternLocator.mayBeGeneric=mayBeGeneric;
        }
        return;
      }
      if (!unit.isModuleInfo())       return;
    }
    if (hasAlreadyDefinedType(unit))     return;
    boolean mustResolve=(this.pattern.mustResolve || possibleMatch.nodeSet.mustResolve);
    if (bindingsWereCreated && mustResolve) {
      if (unit.types != null) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        reduceParseTree(unit);
        if (unit.scope != null) {
          unit.scope.faultInTypes();
        }
        unit.resolve();
      }
 else       if (unit.isPackageInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        unit.resolve();
      }
 else       if (unit.isModuleInfo()) {
        if (BasicSearchEngine.VERBOSE)         System.out.println(""String_Node_Str"" + this.currentPossibleMatch.openable.toStringWithAncestors());
        this.lookupEnvironment.unitBeingCompleted=unit;
        if (unit.scope != null && unit.moduleDeclaration != null) {
          unit.moduleDeclaration.resolveTypeDirectives(unit.scope);
        }
      }
    }
    reportMatching(unit,mustResolve);
  }
 catch (  AbortCompilation e) {
    if (BasicSearchEngine.VERBOSE) {
      System.out.println(""String_Node_Str"" + String.valueOf(unit.getFileName()));
      e.printStackTrace();
    }
    reportMatching(unit,false);
    if (!(e instanceof AbortCompilationUnit)) {
      throw e;
    }
  }
 finally {
    this.lookupEnvironment.unitBeingCompleted=null;
    this.currentPossibleMatch=null;
  }
}",0.9695455255349056
185477,"protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=new Parser(problemReporter,false);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}","protected Parser basicParser(){
  if (this.basicParser == null) {
    ProblemReporter problemReporter=new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),this.options,new DefaultProblemFactory());
    this.basicParser=LanguageSupportFactory.getParser(this,this.options,problemReporter,false,1);
    this.basicParser.reportOnlyOneSyntaxError=true;
  }
  return this.basicParser;
}",0.9157894736842104
185478,"protected MethodNode findMethodDeclaration0(List<MethodNode> candidates,List<ClassNode> arguments){
  MethodNode closestMatch=candidates.get(0);
  if (arguments == null) {
    arguments=Collections.emptyList();
  }
  for (Iterator<MethodNode> iterator=candidates.iterator(); iterator.hasNext(); ) {
    MethodNode maybeMethod=iterator.next();
    Parameter[] parameters=maybeMethod.getParameters();
    if (parameters.length == 0 && arguments.isEmpty()) {
      return maybeMethod.getOriginal();
    }
    if (parameters.length == arguments.size()) {
      Boolean suitable=isTypeCompatible(arguments,parameters);
      if (Boolean.TRUE.equals(suitable)) {
        return maybeMethod.getOriginal();
      }
      if (!Boolean.FALSE.equals(suitable)) {
        closestMatch=maybeMethod.getOriginal();
        continue;
      }
    }
    iterator.remove();
  }
  return closestMatch;
}","protected MethodNode findMethodDeclaration0(List<MethodNode> candidates,List<ClassNode> arguments){
  MethodNode closestMatch=candidates.get(0);
  if (arguments == null) {
    arguments=Collections.emptyList();
  }
  for (  MethodNode candidate : candidates) {
    Parameter[] parameters=candidate.getParameters();
    if (parameters.length == 0 && arguments.isEmpty()) {
      return candidate.getOriginal();
    }
    if (parameters.length == arguments.size()) {
      Boolean suitable=isTypeCompatible(arguments,parameters);
      if (Boolean.TRUE.equals(suitable)) {
        return candidate.getOriginal();
      }
      if (!Boolean.FALSE.equals(suitable) || closestMatch.getParameters().length != arguments.size()) {
        closestMatch=candidate.getOriginal();
      }
    }
  }
  return closestMatch;
}",0.7520661157024794
185479,"private ClassNode findClassNode(String name){
  for (  ClassNode clazz : findModuleNode().getClasses()) {
    if (clazz.getNameWithoutPackage().equals(name)) {
      return clazz;
    }
  }
  return null;
}","private ClassNode findClassNode(String name){
  for (  ClassNode clazz : enclosingModule.getClasses()) {
    if (clazz.getNameWithoutPackage().equals(name)) {
      return clazz;
    }
  }
  return null;
}",0.6277372262773723
185480,"/** 
 * Use factory to instantiate
 */
TypeInferencingVisitorWithRequestor(GroovyCompilationUnit unit,ITypeLookup[] lookups){
  super();
  this.unit=unit;
  this.lookups=lookups;
  ModuleNodeInfo info=createModuleNode(unit);
  this.resolver=info != null ? info.resolver : null;
  this.enclosingDeclarationNode=info != null ? info.module : null;
}","/** 
 * Use factory to instantiate
 */
TypeInferencingVisitorWithRequestor(GroovyCompilationUnit unit,ITypeLookup[] lookups){
  super();
  this.unit=unit;
  this.lookups=lookups;
  ModuleNodeInfo info=createModuleNode(unit);
  this.resolver=info != null ? info.resolver : null;
  this.enclosingDeclarationNode=this.enclosingModule=info != null ? info.module : null;
}",0.97054698457223
185481,"public void visitCompilationUnit(ITypeRequestor requestor){
  if (enclosingDeclarationNode == null) {
    return;
  }
  this.requestor=requestor;
  this.enclosingElement=unit;
  VariableScope topLevelScope=new VariableScope(null,enclosingDeclarationNode,false);
  scopes.add(topLevelScope);
  for (  ITypeLookup lookup : lookups) {
    if (lookup instanceof ITypeResolver) {
      ((ITypeResolver)lookup).setResolverInformation((ModuleNode)enclosingDeclarationNode,resolver);
    }
    lookup.initialize(unit,topLevelScope);
  }
  try {
    visitPackage(((ModuleNode)enclosingDeclarationNode).getPackage());
    visitImports((ModuleNode)enclosingDeclarationNode);
    for (    IType type : unit.getTypes()) {
      visitJDT(type,requestor);
    }
  }
 catch (  VisitCompleted vc) {
  }
catch (  Exception e) {
    log(e,""String_Node_Str"",unit.getElementName());
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
 finally {
    scopes.removeLast();
  }
  if (DEBUG) {
    postVisitSanityCheck();
  }
}","public void visitCompilationUnit(ITypeRequestor requestor){
  if (enclosingModule == null) {
    return;
  }
  this.requestor=requestor;
  this.enclosingElement=unit;
  VariableScope topLevelScope=new VariableScope(null,enclosingModule,false);
  scopes.add(topLevelScope);
  for (  ITypeLookup lookup : lookups) {
    if (lookup instanceof ITypeResolver) {
      ((ITypeResolver)lookup).setResolverInformation(enclosingModule,resolver);
    }
    lookup.initialize(unit,topLevelScope);
  }
  try {
    visitPackage(enclosingModule.getPackage());
    visitImports(enclosingModule);
    for (    IType type : unit.getTypes()) {
      visitJDT(type,requestor);
    }
  }
 catch (  VisitCompleted vc) {
  }
catch (  Exception e) {
    log(e,""String_Node_Str"",unit.getElementName());
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
 finally {
    scopes.removeLast();
  }
  if (DEBUG) {
    postVisitSanityCheck();
  }
}",0.9220843672456576
185482,"private IType findAnonType(ClassNode node){
  return new GroovyProjectFacade(enclosingElement).groovyClassToJavaType(node);
}","private IType findAnonType(ClassNode node){
}",0.5294117647058824
185483,"@Override public void visitMethodCallExpression(MethodCallExpression node){
  VariableScope scope=scopes.getLast();
  scope.setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  VariableScope.CallAndType call=new VariableScope.CallAndType(node,t.declaration,t.declaringType,unit.getModuleNode());
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scope.setCategoryBeingDeclared(catNode);
  }
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scope.forgetCurrentNode();
}","@Override public void visitMethodCallExpression(MethodCallExpression node){
  VariableScope scope=scopes.getLast();
  scope.setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  VariableScope.CallAndType call=new VariableScope.CallAndType(node,t.declaration,t.declaringType,enclosingModule);
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scope.setCategoryBeingDeclared(catNode);
  }
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scope.forgetCurrentNode();
}",0.9885297184567258
185484,"@Test public void testDGM45() throws Throwable {
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertTypeOneOf(contents,start,end,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testDGM45(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 2,""String_Node_Str"");
}",0.8150470219435737
185485,"@Test public void testDGM44(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testDGM44(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 2,""String_Node_Str"");
}",0.8710217755443886
185486,"@Test public void testListSort1(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
  assertDeclaringType(contents,start,end,""String_Node_Str"");
}","@Test public void testListSort1(){
  String contents=""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 4,""String_Node_Str"");
  assertDeclaringType(contents,offset,offset + 4,""String_Node_Str"");
}",0.8022181146025879
185487,"@Test public void testListSort2(){
  boolean jdkListSort;
  try {
    List.class.getDeclaredMethod(""String_Node_Str"",Comparator.class);
    jdkListSort=true;
  }
 catch (  Exception e) {
    jdkListSort=false;
  }
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,jdkListSort ? ""String_Node_Str"" : ""String_Node_Str"");
  assertDeclaringType(contents,start,end,jdkListSort ? ""String_Node_Str"" : ""String_Node_Str"");
}","@Test public void testListSort2(){
  String contents=""String_Node_Str"";
  int offset=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,offset,offset + 4,""String_Node_Str"");
  assertDeclaringType(contents,offset,offset + 4,""String_Node_Str"");
}",0.4441624365482233
185488,"/** 
 * @return finds the number of parameters in the method reference/declaration currently being analyzed.
 */
private int findNumberOfParameters(ASTNode node,TypeLookupResult result){
  return (node instanceof MethodNode && ((MethodNode)node).getParameters() != null) ? ((MethodNode)node).getParameters().length : Math.max(0,result.scope.getMethodCallNumberOfArguments());
}","/** 
 * @return finds the number of parameters in the method reference/declaration currently being analyzed.
 */
private int findNumberOfParameters(ASTNode node,TypeLookupResult result){
  return (node instanceof MethodNode && ((MethodNode)node).getParameters() != null) ? ((MethodNode)node).getParameters().length : result.scope.getMethodCallNumberOfArguments();
}",0.9407008086253368
185489,"/** 
 * Looks for a name within an object expression. It is either in the hierarchy, it is in the variable scope, or it is unknown.
 */
protected TypeLookupResult findTypeForNameWithKnownObjectExpression(String name,ClassNode type,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression,boolean isLhsExpression){
  TypeConfidence confidence0=confidence;
  boolean isFieldAccessDirect=(isThisObjectExpression(scope) ? scope.isFieldAccessDirect() : false);
  ASTNode declaration=findDeclaration(name,declaringType,isLhsExpression,isStaticObjectExpression,isFieldAccessDirect,scope.getMethodCallArgumentTypes());
  ClassNode realDeclaringType;
  VariableInfo variableInfo;
  if (declaration != null) {
    type=getTypeFromDeclaration(declaration,declaringType);
    realDeclaringType=getDeclaringTypeFromDeclaration(declaration,declaringType);
  }
 else   if (""String_Node_Str"".equals(name)) {
    declaration=type=realDeclaringType=declaringType.getGenericsTypes()[0].getType();
  }
 else   if (isPrimaryExpression && (variableInfo=scope.lookupName(name)) != null) {
    type=variableInfo.type;
    realDeclaringType=variableInfo.declaringType;
    declaration=findDeclaration(name,realDeclaringType,isLhsExpression,isStaticObjectExpression,false,scope.getMethodCallArgumentTypes());
    if (declaration == null) {
      declaration=variableInfo.declaringType;
    }
  }
 else   if (""String_Node_Str"".equals(name)) {
    realDeclaringType=VariableScope.CLOSURE_CLASS_NODE;
    declaration=realDeclaringType.getMethods(""String_Node_Str"").get(0);
  }
 else {
    realDeclaringType=declaringType;
    confidence=TypeConfidence.UNKNOWN;
  }
  if (declaration != null && !VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && !VariableScope.CLASS_CLASS_NODE.equals(type)) {
    if (declaration instanceof FieldNode) {
      if (isStaticObjectExpression && !((FieldNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
 else     if (declaration instanceof PropertyNode) {
      FieldNode underlyingField=((PropertyNode)declaration).getField();
      if (underlyingField != null) {
        if (isStaticObjectExpression && !underlyingField.isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (isStaticObjectExpression && !((PropertyNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
 else     if (declaration instanceof MethodNode) {
      if (isStaticObjectExpression && !((MethodNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
 else {
        if (((MethodNode)declaration).getParameters().length != scope.getMethodCallNumberOfArguments()) {
          confidence=TypeConfidence.LOOSELY_INFERRED;
        }
      }
    }
  }
  if (TypeConfidence.UNKNOWN.equals(confidence) && VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType)) {
    ClassNode typeParam=realDeclaringType.getGenericsTypes()[0].getType();
    if (!VariableScope.CLASS_CLASS_NODE.equals(typeParam) && !VariableScope.OBJECT_CLASS_NODE.equals(typeParam)) {
      return findTypeForNameWithKnownObjectExpression(name,type,typeParam,scope,confidence0,isStaticObjectExpression,isPrimaryExpression,isLhsExpression);
    }
  }
  return new TypeLookupResult(type,realDeclaringType,declaration,confidence,scope);
}","/** 
 * Looks for a name within an object expression. It is either in the hierarchy, it is in the variable scope, or it is unknown.
 */
protected TypeLookupResult findTypeForNameWithKnownObjectExpression(String name,ClassNode type,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression,boolean isLhsExpression){
  TypeConfidence confidence0=confidence;
  boolean isFieldAccessDirect=(isThisObjectExpression(scope) ? scope.isFieldAccessDirect() : false);
  ASTNode declaration=findDeclaration(name,declaringType,isLhsExpression,isStaticObjectExpression,isFieldAccessDirect,scope.getMethodCallArgumentTypes());
  ClassNode realDeclaringType;
  VariableInfo variableInfo;
  if (declaration != null) {
    type=getTypeFromDeclaration(declaration,declaringType);
    realDeclaringType=getDeclaringTypeFromDeclaration(declaration,declaringType);
  }
 else   if (""String_Node_Str"".equals(name)) {
    declaration=type=realDeclaringType=declaringType.getGenericsTypes()[0].getType();
  }
 else   if (isPrimaryExpression && (variableInfo=scope.lookupName(name)) != null) {
    type=variableInfo.type;
    realDeclaringType=variableInfo.declaringType;
    declaration=findDeclaration(name,realDeclaringType,isLhsExpression,isStaticObjectExpression,false,scope.getMethodCallArgumentTypes());
    if (declaration == null) {
      declaration=variableInfo.declaringType;
    }
  }
 else   if (""String_Node_Str"".equals(name)) {
    realDeclaringType=VariableScope.CLOSURE_CLASS_NODE;
    declaration=realDeclaringType.getMethods(""String_Node_Str"").get(0);
  }
 else {
    realDeclaringType=declaringType;
    confidence=TypeConfidence.UNKNOWN;
  }
  if (declaration != null && !VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType) && !VariableScope.CLASS_CLASS_NODE.equals(type)) {
    if (declaration instanceof FieldNode) {
      if (isStaticObjectExpression && !((FieldNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
 else     if (declaration instanceof PropertyNode) {
      FieldNode underlyingField=((PropertyNode)declaration).getField();
      if (underlyingField != null) {
        if (isStaticObjectExpression && !underlyingField.isStatic()) {
          confidence=TypeConfidence.UNKNOWN;
        }
      }
 else       if (isStaticObjectExpression && !((PropertyNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
    }
 else     if (declaration instanceof MethodNode) {
      if (isStaticObjectExpression && !((MethodNode)declaration).isStatic()) {
        confidence=TypeConfidence.UNKNOWN;
      }
 else       if (isLooseMatch(scope.getMethodCallArgumentTypes(),((MethodNode)declaration).getParameters())) {
        confidence=TypeConfidence.LOOSELY_INFERRED;
      }
    }
  }
  if (TypeConfidence.UNKNOWN.equals(confidence) && VariableScope.CLASS_CLASS_NODE.equals(realDeclaringType)) {
    ClassNode typeParam=realDeclaringType.getGenericsTypes()[0].getType();
    if (!VariableScope.CLASS_CLASS_NODE.equals(typeParam) && !VariableScope.OBJECT_CLASS_NODE.equals(typeParam)) {
      return findTypeForNameWithKnownObjectExpression(name,type,typeParam,scope,confidence0,isStaticObjectExpression,isPrimaryExpression,isLhsExpression);
    }
  }
  return new TypeLookupResult(type,realDeclaringType,declaration,confidence,scope);
}",0.9725420726306466
185490,"public void visitMethodCallExpression(MethodCallExpression expression){
  visitAnnotations(expression.getAnnotations());
  expression.getObjectExpression().visit(this);
  expression.getMethod().visit(this);
  expression.getArguments().visit(this);
  visitIfPresent(getTraitFieldExpression(expression));
  visitExpression(expression);
}","public void visitMethodCallExpression(MethodCallExpression expression){
  visitAnnotations(expression.getAnnotations());
  expression.getObjectExpression().visit(this);
  expression.getMethod().visit(this);
  expression.getArguments().visit(this);
  visitIfPresent(getTraitFieldExpression(expression));
  ClassNode type=expression.getType();
  if (type.isEnum() && GroovyUtils.isAnonymous(type.redirect()) && expression.getMethodAsString().equals(""String_Node_Str"")) {
    visitClass(type.redirect());
  }
  visitExpression(expression);
}",0.7033218785796106
185491,"public Image decorateImage(Image image,Object element){
  if (preventRecursion) {
    return null;
  }
  boolean isGroovyFile=false, noBaseImage=(image == null);
  if (element instanceof String && (isGroovyFile=isGroovyLikeFileName((String)element))) {
    image=getImage(new JavaElementImageDescriptor(GroovyPluginImages.DESC_GROOVY_FILE,0,JavaElementImageProvider.SMALL_SIZE));
  }
 else {
    IResource resource=null;
    if (element instanceof IFile) {
      resource=(IResource)element;
    }
 else     if (element instanceof ICompilationUnit) {
      resource=((ICompilationUnit)element).getResource();
    }
    if (resource != null && (isGroovyFile=isGroovyLikeFileName(resource.getName()))) {
      image=getJavaElementImageDescriptor(image,resource);
    }
  }
  if (image != null && isGroovyFile) {
    preventRecursion=true;
    try {
      image=problemsDecorator.decorateImage(image,element);
      if (!noBaseImage) {
        if (defaultDecorator == null) {
          defaultDecorator=WorkbenchPlugin.getDefault().getDecoratorManager();
        }
        image=defaultDecorator.decorateImage(image,element);
      }
    }
  finally {
      preventRecursion=false;
    }
    return image;
  }
  return null;
}","private Image decorateImage(ImageDescriptor base,IResource rsrc,Point size){
  int flags=0;
  if (!isExternalProject(rsrc.getProject()))   try {
    if (isGroovyProject(rsrc.getProject())) {
      if (isRuntimeCompiled(rsrc)) {
        flags|=0x8000;
      }
    }
 else {
      flags|=JavaElementImageDescriptor.BUILDPATH_ERROR;
    }
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"" + rsrc.getName(),e);
  }
  return getImage(base,flags,size);
}",0.0515524311657879
185492,"private Image getImage(ImageDescriptor descriptor){
  return JavaPlugin.getImageDescriptorRegistry().get(descriptor);
}","private Image getImage(ImageDescriptor base,int flags,Point size){
  return JavaPlugin.getImageDescriptorRegistry().get(new JavaElementImageDescriptor(base,flags,size));
}",0.7724137931034483
185493,"private IType fakeAnonymousInnerClass(IType outer,final InnerClassNode inner){
  return new ResolvedSourceType((JavaElement)outer,inner.getName(),GroovyUtils.getTypeSignature(inner,true,true)){
    public Object getElementInfo() throws JavaModelException {
      try {
        return super.getElementInfo();
      }
 catch (      JavaModelException jme) {
        if (!jme.getJavaModelStatus().isDoesNotExist()) {
          throw jme;
        }
        final IType anonType=this;
        return new org.eclipse.jdt.internal.core.SourceTypeElementInfo(){
{
            setHandle(anonType);
            setFlags(inner.getModifiers());
            ClassNode[] faces=inner.getInterfaces();
            char[][] names=new char[faces.length][];
            for (int i=0; i < faces.length; i+=1) {
              names[i]=faces[i].getName().toCharArray();
            }
            setSuperInterfaceNames(names);
            setSuperclassName(inner.getUnresolvedSuperClass().getName().toCharArray());
            setNameSourceStart(inner.getNameStart());
            setNameSourceEnd(inner.getNameEnd());
            setSourceRangeStart(inner.getStart());
            setSourceRangeEnd(inner.getEnd());
          }
        }
;
      }
    }
  }
;
}","private IType fakeAnonymousInnerClass(IType outer,final InnerClassNode inner){
  return new ResolvedSourceType((JavaElement)outer,inner.getName(),GroovyUtils.getTypeSignature(inner,true,true)){
    @Override public Object getElementInfo() throws JavaModelException {
      try {
        return super.getElementInfo();
      }
 catch (      JavaModelException jme) {
        if (!jme.getJavaModelStatus().isDoesNotExist()) {
          throw jme;
        }
        final IType anonType=this;
        return new org.eclipse.jdt.internal.core.SourceTypeElementInfo(){
{
            setHandle(anonType);
            setFlags(inner.getModifiers());
            ClassNode[] faces=inner.getInterfaces();
            char[][] names=new char[faces.length][];
            for (int i=0; i < faces.length; i+=1) {
              names[i]=faces[i].getName().toCharArray();
            }
            setSuperInterfaceNames(names);
            setSuperclassName(inner.getUnresolvedSuperClass().getName().toCharArray());
            setNameSourceStart(inner.getNameStart());
            setNameSourceEnd(inner.getNameEnd());
            setSourceRangeStart(inner.getStart());
            setSourceRangeEnd(inner.getEnd());
          }
        }
;
      }
    }
    @Override public IField getField(    String fieldName){
      final FieldNode fieldNode=inner.getDeclaredField(fieldName);
      if (fieldNode == null) {
        return super.getField(fieldName);
      }
      String uniqueKey=GroovyUtils.getTypeSignature(fieldNode.getDeclaringClass(),true,true) + Signature.C_DOT + fieldName+ ""String_Node_Str""+ GroovyUtils.getTypeSignature(fieldNode.getType(),true,true);
      return new ResolvedSourceField(this,fieldName,uniqueKey){
        @Override public Object getElementInfo() throws JavaModelException {
          try {
            return super.getElementInfo();
          }
 catch (          JavaModelException jme) {
            if (!jme.getJavaModelStatus().isDoesNotExist()) {
              throw jme;
            }
            return new org.eclipse.jdt.internal.core.SourceFieldElementInfo(){
{
                setTypeName(fieldNode.getType().toString(false).toCharArray());
                setNameSourceStart(fieldNode.getNameStart());
                setNameSourceEnd(fieldNode.getNameEnd());
                setSourceRangeStart(fieldNode.getStart());
                setSourceRangeEnd(fieldNode.getEnd());
                setFlags(fieldNode.getModifiers());
              }
            }
;
          }
        }
      }
;
    }
    @Override public IMethod getMethod(    String methodName,    String[] parameterTypeSignatures){
      final MethodNode methodNode=inner.getDeclaredMethod(methodName,getParametersForTypes(parameterTypeSignatures));
      if (methodNode == null) {
        return super.getMethod(methodName,parameterTypeSignatures);
      }
      String uniqueKey=GroovyUtils.getTypeSignature(methodNode.getDeclaringClass(),true,true) + Signature.C_DOT + methodName+ Signature.C_PARAM_START+ Signature.C_PARAM_END+ GroovyUtils.getTypeSignature(methodNode.getReturnType(),true,true);
      return new ResolvedSourceMethod(this,methodName,parameterTypeSignatures,uniqueKey){
        @Override public Object getElementInfo() throws JavaModelException {
          try {
            return super.getElementInfo();
          }
 catch (          JavaModelException jme) {
            if (!jme.getJavaModelStatus().isDoesNotExist()) {
              throw jme;
            }
            return new org.eclipse.jdt.internal.core.SourceMethodInfo(){
{
                setReturnType(methodNode.getReturnType().getNameWithoutPackage().toCharArray());
                setNameSourceStart(methodNode.getNameStart());
                setNameSourceEnd(methodNode.getNameEnd());
                setSourceRangeStart(methodNode.getStart());
                setSourceRangeEnd(methodNode.getEnd());
                setFlags(methodNode.getModifiers());
              }
            }
;
          }
        }
      }
;
    }
  }
;
}",0.470722433460076
185494,"public Object getElementInfo() throws JavaModelException {
  try {
    return super.getElementInfo();
  }
 catch (  JavaModelException jme) {
    if (!jme.getJavaModelStatus().isDoesNotExist()) {
      throw jme;
    }
    final IType anonType=this;
    return new org.eclipse.jdt.internal.core.SourceTypeElementInfo(){
{
        setHandle(anonType);
        setFlags(inner.getModifiers());
        ClassNode[] faces=inner.getInterfaces();
        char[][] names=new char[faces.length][];
        for (int i=0; i < faces.length; i+=1) {
          names[i]=faces[i].getName().toCharArray();
        }
        setSuperInterfaceNames(names);
        setSuperclassName(inner.getUnresolvedSuperClass().getName().toCharArray());
        setNameSourceStart(inner.getNameStart());
        setNameSourceEnd(inner.getNameEnd());
        setSourceRangeStart(inner.getStart());
        setSourceRangeEnd(inner.getEnd());
      }
    }
;
  }
}","@Override public Object getElementInfo() throws JavaModelException {
  try {
    return super.getElementInfo();
  }
 catch (  JavaModelException jme) {
    if (!jme.getJavaModelStatus().isDoesNotExist()) {
      throw jme;
    }
    return new org.eclipse.jdt.internal.core.SourceMethodInfo(){
{
        setReturnType(methodNode.getReturnType().getNameWithoutPackage().toCharArray());
        setNameSourceStart(methodNode.getNameStart());
        setNameSourceEnd(methodNode.getNameEnd());
        setSourceRangeStart(methodNode.getStart());
        setSourceRangeEnd(methodNode.getEnd());
        setFlags(methodNode.getModifiers());
      }
    }
;
  }
}",0.3201008191556396
185495,"/** 
 * If this fully qualified name is in a groovy file, then return the classnode If this is not a groovy file, then return null
 */
public ClassNode getClassNodeForName(String name){
  try {
    IType type=project.findType(name,new NullProgressMonitor());
    if (type instanceof SourceType) {
      return javaTypeToGroovyClass(type);
    }
  }
 catch (  JavaModelException e) {
    Util.log(e);
  }
  return null;
}","/** 
 * If this fully qualified name is in a groovy file, then return the ClassNode. If this is not a groovy file, then return null
 */
public ClassNode getClassNodeForName(String name){
  try {
    IType type=project.findType(name,(IProgressMonitor)null);
    if (type instanceof SourceType) {
      return javaTypeToGroovyClass(type);
    }
  }
 catch (  JavaModelException e) {
    Util.log(e);
  }
  return null;
}",0.9570405727923628
185496,"public IType groovyClassToJavaType(ClassNode node){
  try {
    ClassNode toLookFor=node;
    if (GroovyUtils.isAnonymous(node)) {
      toLookFor=node.getOuterClass();
      IType enclosing=groovyClassToJavaType(toLookFor);
      if (enclosing != null) {
        if (!enclosing.isBinary()) {
          return fakeAnonymousInnerClass(enclosing,(InnerClassNode)node);
        }
 else {
          return project.findType(node.getName(),new NullProgressMonitor());
        }
      }
 else {
        return null;
      }
    }
    String name=toLookFor.getName().replace('$','.');
    IType type=project.findType(name,new NullProgressMonitor());
    if (type != null && toLookFor != node) {
      type=type.getType(""String_Node_Str"",1);
      if (!type.exists()) {
        type=null;
      }
    }
    return type;
  }
 catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + node.getName());
    return null;
  }
}","public IType groovyClassToJavaType(ClassNode node){
  if (parent != null && parent.getFullyQualifiedName().equals(node.getName())) {
    return parent;
  }
  try {
    ClassNode toLookFor=node;
    if (GroovyUtils.isAnonymous(node)) {
      toLookFor=node.getOuterClass();
      IType enclosing=groovyClassToJavaType(toLookFor);
      if (enclosing != null && !enclosing.isBinary()) {
        return fakeAnonymousInnerClass(enclosing,(InnerClassNode)node);
      }
 else {
        return project.findType(node.getName(),(IProgressMonitor)null);
      }
    }
    String name=toLookFor.getName().replace('$','.');
    IType type=project.findType(name,(IProgressMonitor)null);
    if (type != null && toLookFor != node) {
      type=type.getType(""String_Node_Str"",1);
      if (!type.exists()) {
        type=null;
      }
    }
    return type;
  }
 catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + node.getName());
    return null;
  }
}",0.7450771687067589
185497,"/** 
 * @param node anonymous inner class for enum constant
 */
private void visitMethodOverrides(ClassNode node){
  scopes.add(new VariableScope(scopes.getLast(),node,false));
  ASTNode enclosingDeclaration0=enclosingDeclarationNode;
  IJavaElement enclosingElement0=enclosingElement;
  enclosingDeclarationNode=node;
  try {
    for (    MethodNode method : node.getMethods()) {
      if (method.getEnd() > 0) {
        visitMethodInternal(method,false);
      }
    }
  }
  finally {
    scopes.removeLast();
    enclosingElement=enclosingElement0;
    enclosingDeclarationNode=enclosingDeclaration0;
  }
}","/** 
 * @param node anonymous inner class for enum constant
 */
private void visitMethodOverrides(ClassNode node){
  scopes.add(new VariableScope(scopes.getLast(),node,false));
  ASTNode enclosingDeclaration0=enclosingDeclarationNode;
  IJavaElement enclosingElement0=enclosingElement;
  enclosingDeclarationNode=node;
  try {
    for (    MethodNode method : node.getMethods()) {
      if (method.getEnd() > 0) {
        enclosingElement=findAnonType(node).getMethod(method.getName(),GroovyUtils.getParameterTypeSignatures(method,true));
        visitMethodInternal(method,false);
      }
    }
  }
  finally {
    scopes.removeLast();
    enclosingElement=enclosingElement0;
    enclosingDeclarationNode=enclosingDeclaration0;
  }
}",0.9069247952345496
185498,"@Override public void visitConstructorCallExpression(ConstructorCallExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    ClassNode type=node.getType();
    visitClassReference(node.isUsingAnonymousInnerClass() ? type.getUnresolvedSuperClass() : type);
    if (node.getArguments() instanceof TupleExpression) {
      TupleExpression tuple=(TupleExpression)node.getArguments();
      if (isNotEmpty(tuple.getExpressions())) {
        if ((tuple.getExpressions().size() == 1 && tuple.getExpressions().get(0) instanceof MapExpression) || tuple.getExpression(tuple.getExpressions().size() - 1) instanceof NamedArgumentListExpression) {
          enclosingConstructorCall=node;
        }
      }
    }
    super.visitConstructorCallExpression(node);
    if (node.isUsingAnonymousInnerClass()) {
      scopes.add(new VariableScope(scopes.getLast(),type,false));
      ASTNode enclosingDeclaration0=enclosingDeclarationNode;
      IJavaElement enclosingElement0=enclosingElement;
      enclosingDeclarationNode=type;
      try {
        for (        ClassNode face : type.getInterfaces()) {
          if (face.getEnd() > 0)           visitClassReference(face);
        }
        for (        Statement stmt : type.getObjectInitializerStatements()) {
          stmt.visit(this);
        }
        for (        FieldNode field : type.getFields()) {
          if (field.getEnd() > 0) {
            visitField(field);
          }
        }
        for (        MethodNode method : type.getMethods()) {
          if (method.getEnd() > 0) {
            visitMethodInternal(method,false);
          }
        }
      }
  finally {
        scopes.removeLast();
        enclosingElement=enclosingElement0;
        enclosingDeclarationNode=enclosingDeclaration0;
      }
    }
  }
}","@Override public void visitConstructorCallExpression(ConstructorCallExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    ClassNode type=node.getType();
    visitClassReference(node.isUsingAnonymousInnerClass() ? type.getUnresolvedSuperClass() : type);
    if (node.getArguments() instanceof TupleExpression) {
      TupleExpression tuple=(TupleExpression)node.getArguments();
      if (isNotEmpty(tuple.getExpressions())) {
        if ((tuple.getExpressions().size() == 1 && tuple.getExpressions().get(0) instanceof MapExpression) || tuple.getExpression(tuple.getExpressions().size() - 1) instanceof NamedArgumentListExpression) {
          enclosingConstructorCall=node;
        }
      }
    }
    super.visitConstructorCallExpression(node);
    if (node.isUsingAnonymousInnerClass()) {
      scopes.add(new VariableScope(scopes.getLast(),type,false));
      ASTNode enclosingDeclaration0=enclosingDeclarationNode;
      IJavaElement enclosingElement0=enclosingElement;
      enclosingDeclarationNode=type;
      try {
        for (        ClassNode face : type.getInterfaces()) {
          if (face.getEnd() > 0)           visitClassReference(face);
        }
        for (        Statement stmt : type.getObjectInitializerStatements()) {
          stmt.visit(this);
        }
        for (        FieldNode field : type.getFields()) {
          if (field.getEnd() > 0) {
            enclosingElement=findAnonType(type).getField(field.getName());
            visitField(field);
          }
        }
        for (        MethodNode method : type.getMethods()) {
          if (method.getEnd() > 0) {
            enclosingElement=findAnonType(type).getMethod(method.getName(),GroovyUtils.getParameterTypeSignatures(method,true));
            visitMethodInternal(method,false);
          }
        }
      }
  finally {
        scopes.removeLast();
        enclosingElement=enclosingElement0;
        enclosingDeclarationNode=enclosingDeclaration0;
      }
    }
  }
}",0.9467084639498432
185499,"public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  this.methodName=String.valueOf(pattern.selector);
  String[] parameterTypeSignatures=getParameterTypeSignatures(pattern);
  IType declaringType=(IType)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] declaringQualifiedName=null;
  try {
    if (pattern.focus instanceof IMethod && supportsOverride((IMethod)pattern.focus)) {
      LinkedList<IMethod> methods=new LinkedList<IMethod>();
      if (declaringType == null)       declaringType=((IMethod)pattern.focus).getDeclaringType();
      for (      IType superType : declaringType.newSupertypeHierarchy(null).getAllSupertypes(declaringType)) {
        IMethod superMeth=superType.getMethod(methodName,parameterTypeSignatures);
        if (superMeth.exists() && supportsOverride(superMeth)) {
          methods.add(superMeth);
        }
      }
      if (!methods.isEmpty()) {
        declaringType=methods.getLast().getDeclaringType();
        char[] superTypeName=declaringType.getElementName().toCharArray();
        char[] packageName=declaringType.getPackageFragment().getElementName().toCharArray();
        declaringQualifiedName=CharOperation.concat(packageName,superTypeName,'.');
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  if (declaringQualifiedName == null) {
    declaringQualifiedName=CharOperation.concat(pattern.declaringQualification,pattern.declaringSimpleName,'.');
    if (declaringQualifiedName == null) {
      if (declaringType != null) {
        declaringQualifiedName=CharOperation.concat(declaringType.getPackageFragment().getElementName().toCharArray(),declaringType.getElementName().toCharArray(),'.');
      }
 else {
        declaringQualifiedName=CharOperation.NO_CHAR;
      }
    }
  }
  declaringTypeName=String.valueOf(declaringQualifiedName);
  parameterTypeNames=getParameterTypeNames(pattern,parameterTypeSignatures,declaringType);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
}","public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  this.methodName=String.valueOf(pattern.selector);
  String[] parameterTypeSignatures=getParameterTypeSignatures(pattern);
  IType declaringType=(IType)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] declaringQualifiedName=null;
  try {
    if (pattern.focus instanceof IMethod && supportsOverride((IMethod)pattern.focus)) {
      LinkedList<IMethod> methods=new LinkedList<IMethod>();
      if (declaringType == null)       declaringType=((IMethod)pattern.focus).getDeclaringType();
      for (      IType superType : declaringType.newSupertypeHierarchy(null).getAllSupertypes(declaringType)) {
        IMethod superMeth=superType.getMethod(methodName,parameterTypeSignatures);
        if (superMeth.exists() && supportsOverride(superMeth)) {
          methods.add(superMeth);
        }
      }
      if (!methods.isEmpty()) {
        IType type=methods.getLast().getDeclaringType();
        char[] superTypeName=type.getElementName().toCharArray();
        char[] packageName=type.getPackageFragment().getElementName().toCharArray();
        declaringQualifiedName=CharOperation.concat(packageName,superTypeName,'.');
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  if (declaringQualifiedName == null) {
    declaringQualifiedName=CharOperation.concat(pattern.declaringQualification,pattern.declaringSimpleName,'.');
    if (declaringQualifiedName == null) {
      if (declaringType != null) {
        declaringQualifiedName=CharOperation.concat(declaringType.getPackageFragment().getElementName().toCharArray(),declaringType.getElementName().toCharArray(),'.');
      }
 else {
        declaringQualifiedName=CharOperation.NO_CHAR;
      }
    }
  }
  declaringTypeName=String.valueOf(declaringQualifiedName);
  parameterTypeNames=getParameterTypeNames(pattern,parameterTypeSignatures,declaringType);
  findDeclarations=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  findReferences=(Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
}",0.9914002205071664
185500,"protected static String[] getParameterTypeNames(MethodPattern pattern,String[] parameterTypeSignatures,IType declaringType){
  int n=parameterTypeSignatures.length;
  String[] typeNames=new String[n];
  for (int i=0; i < n; i+=1) {
    if (pattern.parameterQualifications[i] != null || isPrimitiveType(pattern.parameterSimpleNames[i])) {
      typeNames[i]=String.valueOf(CharOperation.concat(pattern.parameterQualifications[i],pattern.parameterSimpleNames[i],'.'));
    }
 else {
      int arrayCount=Signature.getArrayCount(parameterTypeSignatures[i]);
      try {
        String[][] resolved=declaringType.resolveType(String.valueOf(pattern.parameterSimpleNames[i],0,pattern.parameterSimpleNames[i].length - (2 * arrayCount)));
        typeNames[i]=Signature.toQualifiedName(resolved[0]);
        if (typeNames[i].charAt(0) == '.') {
          typeNames[i]=typeNames[i].substring(1);
        }
        while (arrayCount-- > 0) {
          typeNames[i]+=""String_Node_Str"";
        }
      }
 catch (      Exception e) {
        Util.log(e);
      }
    }
  }
  return typeNames;
}","protected static String[] getParameterTypeNames(MethodPattern pattern,String[] parameterTypeSignatures,IType declaringType){
  int n=parameterTypeSignatures.length;
  String[] typeNames=new String[n];
  if (declaringType != null)   try {
    int candidates=0;
    if (n > 0) {
      for (      IMethod m : declaringType.getMethods()) {
        if (equal(pattern.selector,m.getElementName()) && n == m.getNumberOfParameters()) {
          candidates+=1;
        }
      }
    }
    if (candidates > 1) {
      for (int i=0; i < n; i+=1) {
        if (pattern.parameterQualifications[i] != null || isPrimitiveType(pattern.parameterSimpleNames[i])) {
          typeNames[i]=String.valueOf(CharOperation.concat(pattern.parameterQualifications[i],pattern.parameterSimpleNames[i],'.'));
        }
 else {
          int arrayCount=Signature.getArrayCount(parameterTypeSignatures[i]);
          String[][] resolved=declaringType.resolveType(String.valueOf(pattern.parameterSimpleNames[i],0,pattern.parameterSimpleNames[i].length - (2 * arrayCount)));
          typeNames[i]=Signature.toQualifiedName(resolved[0]);
          if (typeNames[i].charAt(0) == '.') {
            typeNames[i]=typeNames[i].substring(1);
          }
          while (arrayCount-- > 0) {
            typeNames[i]+=""String_Node_Str"";
          }
        }
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  return typeNames;
}",0.822347266881029
185501,"/** 
 * When matching method references and declarations, we can't actually match on parameter types. Instead, we match on the number of parameterrs and assume that it is slightly more preceise than just matching on name. The heuristic that is used in this method is this: <ol> <li>The search pattern expects 'n' parameters <li>the current node has 'm' arguments. <li>if the m == n, then there is a precise match. <li>if not, look at all methods in current type with same name. <li>if there is a method in the current type with the same number of arguments, then assume the current node matches that other method, and there is no match. <li>If there are no existing methods with same number of parameters, then assume that current method call is an alternative way of calling the method and return a match </ol>
 * @return true if there is a precise match between number of arguments andnumner of parameters. false if there exists a different method with same number of arguments in current type, or true otherwise
 */
private boolean nameAndArgsMatch(ClassNode declaringType,List<ClassNode> argumentTypes){
  if (matchOnName(declaringType)) {
    if (argumentTypes == null || argumentTypes.size() == parameterTypeNames.length) {
      return true;
    }
 else {
      boolean[] foundParameterNumbers=cachedParameterCounts.get(declaringType);
      if (foundParameterNumbers == null) {
        foundParameterNumbers=new boolean[MAX_PARAMS + 1];
        gatherParameters(declaringType,foundParameterNumbers);
        cachedParameterCounts.put(declaringType,foundParameterNumbers);
      }
      return !foundParameterNumbers[Math.min(MAX_PARAMS,argumentTypes.size())];
    }
  }
  return false;
}","/** 
 * When matching method references and declarations, match on the number of parameterrs and assume that it is slightly more accurate than matching on name alone.  If parameters and arguments are equal length, check the type compatibility of each pair. The heuristic that is used in this method is this: <ol> <li>The search pattern expects 'n' parameters <li>the current node has 'm' arguments. <li>if the m == n, then there is a precise match. <li>if not, look at all methods in current type with same name. <li>if there is a method in the current type with the same number of arguments, then assume the current node matches that other method, and there is no match. <li>If there are no existing methods with same number of parameters, then assume that current method call is an alternative way of calling the method and return a match </ol>
 */
private boolean nameAndArgsMatch(ClassNode declaringType,List<ClassNode> argumentTypes){
  if (matchOnName(declaringType)) {
    if (argumentTypes == null) {
      return true;
    }
    if (argumentTypes.size() == parameterTypeNames.length) {
      for (int i=0; i < parameterTypeNames.length; i+=1) {
        if (parameterTypeNames[i] == null)         continue;
        ClassNode source=argumentTypes.get(i), target=ClassHelper.makeWithoutCaching(parameterTypeNames[i]);
        if (Boolean.FALSE.equals(SimpleTypeLookup.isTypeCompatible(source,target))) {
          return false;
        }
      }
      return true;
    }
 else {
      boolean[] foundParameterNumbers=cachedParameterCounts.get(declaringType);
      if (foundParameterNumbers == null) {
        foundParameterNumbers=new boolean[MAX_PARAMS + 1];
        gatherParameters(declaringType,foundParameterNumbers);
        cachedParameterCounts.put(declaringType,foundParameterNumbers);
      }
      return !foundParameterNumbers[Math.min(MAX_PARAMS,argumentTypes.size())];
    }
  }
  return false;
}",0.7375415282392026
185502,"@Override public void visitStaticMethodCallExpression(StaticMethodCallExpression node){
  ClassNode type=node.getOwnerType();
  if (isPrimaryExpression(node)) {
    visitMethodCallExpression(new MethodCallExpression(new ClassExpression(type),node.getMethod(),node.getArguments()));
  }
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    boolean isPresentInSource=(node.getEnd() > 0);
    if (isPresentInSource) {
      visitClassReference(type);
    }
    if (isPresentInSource || isEnumInit(node)) {
      super.visitStaticMethodCallExpression(node);
      if (GroovyUtils.isAnonymous(type)) {
        scopes.add(new VariableScope(scopes.getLast(),type,false));
        ASTNode enclosingDeclaration0=enclosingDeclarationNode;
        IJavaElement enclosingElement0=enclosingElement;
        enclosingDeclarationNode=type;
        try {
          for (          MethodNode method : type.getMethods()) {
            if (method.getEnd() > 0) {
              visitMethodInternal(method,false);
            }
          }
        }
  finally {
          scopes.removeLast();
          enclosingElement=enclosingElement0;
          enclosingDeclarationNode=enclosingDeclaration0;
        }
      }
    }
  }
}","@Override public void visitStaticMethodCallExpression(StaticMethodCallExpression node){
  ClassNode type=node.getOwnerType();
  if (isPrimaryExpression(node)) {
    visitMethodCallExpression(new MethodCallExpression(new ClassExpression(type),node.getMethod(),node.getArguments()));
  }
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    boolean isPresentInSource=(node.getEnd() > 0);
    if (isPresentInSource) {
      visitClassReference(type);
    }
    if (isPresentInSource || isEnumInit(node)) {
      super.visitStaticMethodCallExpression(node);
      if (GroovyUtils.isAnonymous(type)) {
        visitMethodOverrides(type);
      }
    }
  }
}",0.6854460093896714
185503,"@Override public void visitMethodCallExpression(MethodCallExpression node){
  VariableScope scope=scopes.getLast();
  scope.setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  VariableScope.CallAndType call=new VariableScope.CallAndType(node,t.declaration,t.declaringType,enclosingModule);
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scope.setCategoryBeingDeclared(catNode);
  }
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scope.forgetCurrentNode();
}","@Override public void visitMethodCallExpression(MethodCallExpression node){
  VariableScope scope=scopes.getLast();
  scope.setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  VariableScope.CallAndType call=new VariableScope.CallAndType(node,t.declaration,t.declaringType,enclosingModule);
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scope.setCategoryBeingDeclared(catNode);
  }
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  ClassNode type;
  if (isEnumInit(node) && GroovyUtils.isAnonymous(type=((Expression)node.getReceiver()).getType())) {
    visitMethodOverrides(type);
  }
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scope.forgetCurrentNode();
}",0.8982826948480845
185504,"/** 
 * Checks to see if this requestor has something to do with refactoring, if so, we always want an accurate match otherwise we get complaints in the refactoring wizard of ""possible matches"".
 */
private boolean shouldAlwaysBeAccurate(){
  return requestor.getClass().getPackage().getName().indexOf(""String_Node_Str"") != -1;
}","/** 
 * Checks to see if this requestor has something to do with refactoring, if so, we always want an accurate match otherwise we get complaints in the refactoring wizard of ""possible matches"".
 */
private boolean shouldAlwaysBeAccurate(){
  return (requestor.getClass().getPackage().getName().indexOf(""String_Node_Str"") != -1);
}",0.996969696969697
185505,"private int getAccuracy(TypeConfidence confidence){
  if (shouldAlwaysBeAccurate()) {
    return SearchMatch.A_ACCURATE;
  }
switch (confidence) {
case EXACT:
    return SearchMatch.A_ACCURATE;
default :
  return SearchMatch.A_INACCURATE;
}
}","private int getAccuracy(TypeConfidence confidence){
  return (shouldAlwaysBeAccurate() || confidence == TypeConfidence.EXACT ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE);
}",0.6540284360189573
185506,"protected TypeReferenceMatch createMatch(TypeLookupResult result,IJavaElement enclosingElement,int start,int end){
  IJavaElement element;
  if (findDeclaration) {
    try {
      ClassNode type=result.type;
      while (type.getComponentType() != null) {
        type=type.getComponentType();
      }
      element=enclosingElement.getJavaProject().findType(type.getName().replace('$','.'),new NullProgressMonitor());
      if (element == null) {
        element=enclosingElement;
      }
    }
 catch (    JavaModelException e) {
      Util.log(e);
      element=enclosingElement;
    }
  }
 else {
    element=enclosingElement;
  }
  return new TypeReferenceMatch(element,getAccuracy(result.confidence),start,end - start,false,participant,element.getResource());
}","protected TypeReferenceMatch createMatch(TypeLookupResult result,IJavaElement enclosingElement,int start,int end){
  IJavaElement element=enclosingElement;
  if (findDeclaration) {
    try {
      ClassNode type=GroovyUtils.getBaseType(result.type);
      IJavaElement e=enclosingElement.getJavaProject().findType(type.getName().replace('$','.'),new NullProgressMonitor());
      if (e != null) {
        element=e;
      }
    }
 catch (    JavaModelException e) {
      Util.log(e);
    }
  }
  return new TypeReferenceMatch(element,getAccuracy(result.confidence),start,end - start,false,participant,element.getResource());
}",0.5710186513629842
185507,"private boolean qualifiedNameMatches(String fullyQualifiedName){
  String[] tuple=splitQualifierAndSimpleName(fullyQualifiedName);
  String name=tuple[1], qualifier=tuple[0];
  if (!isCaseSensitive) {
    name=name.toLowerCase();
    qualifier=qualifier.toLowerCase();
  }
  boolean match=true;
  if (namePattern != null) {
    if (isCamelCase) {
      match=CharOperation.camelCaseMatch(namePattern,name.toCharArray());
    }
 else {
      match=CharOperation.equals(namePattern,name.toCharArray());
    }
  }
  if (match && qualificationPattern != null) {
    if (isCamelCase) {
      match=CharOperation.camelCaseMatch(qualificationPattern,qualifier.toCharArray());
    }
 else {
      match=CharOperation.equals(qualificationPattern,qualifier.toCharArray());
    }
  }
  if (!match && namePattern != null && qualificationPattern != null && qualifier.length() > (namePattern.length + qualificationPattern.length)) {
    char[] q=qualifier.toCharArray();
    int qualEnd=qualificationPattern.length, nameEnd=qualificationPattern.length + 1 + namePattern.length;
    if ((q[qualEnd] == '.' || q[qualEnd] == '$') && CharOperation.equals(qualificationPattern,q,0,qualEnd) && CharOperation.equals(namePattern,q,qualEnd + 1,nameEnd)) {
      match=(nameEnd == q.length || q[nameEnd] == '.' || q[nameEnd] == '$');
    }
  }
  return match;
}","private boolean qualifiedNameMatches(String fullyQualifiedName){
  String[] tuple=splitQualifierAndSimpleName(fullyQualifiedName);
  String name=tuple[1], qualifier=tuple[0];
  boolean match=unqualifiedNameMatches(name);
  if (match) {
    if (isCamelCase) {
      match=CharOperation.camelCaseMatch(qualificationPattern,qualifier.toCharArray());
    }
 else {
      match=CharOperation.match(qualificationPattern,qualifier.toCharArray(),isCaseSensitive);
    }
  }
  if (!match && namePattern != null && qualificationPattern != null && qualifier.length() > (namePattern.length + qualificationPattern.length)) {
    char[] q=qualifier.toCharArray();
    int qualEnd=qualificationPattern.length, nameEnd=qualificationPattern.length + namePattern.length + 1;
    if ((q[qualEnd] == '.' || q[qualEnd] == '$') && (q.length == nameEnd || q[nameEnd] == '.' || q[nameEnd] == '$') && CharOperation.match(CharOperation.concat(qualificationPattern,namePattern,'?'),q,isCaseSensitive)) {
      match=true;
    }
  }
  return match;
}",0.6180584993641374
185508,"/** 
 * The problem that this method gets around is that we can't tell exactly what the text is and exactly where or if there is a match in the source location. For example, in the text, the type can be fully qualified, or array, or coming from an alias, or a bound type parameter. On top of that, some source locations are off by one. All these will have location relative to the offset provided in the start and end fields of the   {@link ClassNode}.
 * @param node the class node to find in the source
 * @param elem the element used to find the text
 * @return the start and end offsets of the actual match, or null if no match exists.
 */
private int[] getMatchLocation(ClassNode node,IJavaElement elem,int maybeStart,int maybeEnd){
  if (cachedContentsAvailable(elem)) {
    int nameLength=maybeEnd - maybeStart;
    int start=-1, until=-1;
    String name=node.getName();
    int dollarIndex=name.lastIndexOf('$');
    name=name.substring(dollarIndex + 1);
    if (name.length() <= nameLength) {
      start=CharOperation.indexOf(name.toCharArray(),cachedContents,isCaseSensitive,maybeStart,maybeEnd + 1);
      until=start + name.length();
    }
    if (start == -1) {
      String nameWithoutPackage=node.getNameWithoutPackage();
      start=CharOperation.indexOf(nameWithoutPackage.toCharArray(),cachedContents,isCaseSensitive,maybeStart,maybeEnd + 1);
      until=start + nameWithoutPackage.length();
    }
    if (start != -1) {
      return new int[]{start,until};
    }
  }
  return null;
}","/** 
 * The problem that this method gets around is that we can't tell exactly what the text is and exactly where or if there is a match in the source location. For example, in the text, the type can be fully qualified, or array, or coming from an alias, or a bound type parameter. On top of that, some source locations are off by one. All these will have location relative to the offset provided in the start and end fields of the   {@link ClassNode}.
 * @param node the class node to find in the source
 * @param elem the element used to find the text
 * @return the start and end offsets of the actual match, or null if no match exists.
 */
private int[] getMatchLocation(ClassNode node,IJavaElement elem,int maybeStart,int maybeEnd){
  if (maybeEnd > 0 && cachedContentsAvailable(elem)) {
    return getMatchLocation0(node.getName(),maybeStart,maybeEnd);
  }
  return null;
}",0.6747796894670584
185509,"@Test public void testAnonymousInner1() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner1() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.9867711905928468
185510,"@Test public void testAnonymousInner2() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),2,children.length);
    for (int i=0; i < 2; i++) {
      IType anonType=(IType)children[i];
      assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
      IJavaElement[] anonChildren=anonType.getChildren();
      assertEquals(""String_Node_Str"" + Arrays.toString(anonChildren),i + 1,anonChildren.length);
      assertEquals(""String_Node_Str"",anonChildren[0].getElementName());
      if (i == 1) {
        assertEquals(""String_Node_Str"",anonChildren[1].getElementName());
      }
    }
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner2() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),2,children.length);
    for (int i=0; i < 2; i++) {
      IType anonType=(IType)children[i];
      assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
      IJavaElement[] anonChildren=anonType.getChildren();
      assertEquals(""String_Node_Str"" + Arrays.toString(anonChildren),i + 1,anonChildren.length);
      assertEquals(""String_Node_Str"",anonChildren[0].getElementName());
      if (i == 1) {
        assertEquals(""String_Node_Str"",anonChildren[1].getElementName());
      }
    }
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.988984088127295
185511,"@Test public void testAnonymousInner3() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner3() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.9876993166287016
185512,"@Test public void testAnonymousInner4() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),2,children.length);
    for (int i=0; i < 2; i++) {
      IType anonType=(IType)children[i];
      assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
      IJavaElement[] innerChildren=anonType.getChildren();
      assertEquals(""String_Node_Str"" + Arrays.toString(children),i + 1,innerChildren.length);
      assertEquals(""String_Node_Str"",innerChildren[0].getElementName());
      if (i == 1) {
        assertEquals(""String_Node_Str"",innerChildren[1].getElementName());
      }
    }
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner4() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),2,children.length);
    for (int i=0; i < 2; i++) {
      IType anonType=(IType)children[i];
      assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
      IJavaElement[] innerChildren=anonType.getChildren();
      assertEquals(""String_Node_Str"" + Arrays.toString(children),i + 1,innerChildren.length);
      assertEquals(""String_Node_Str"",innerChildren[0].getElementName());
      if (i == 1) {
        assertEquals(""String_Node_Str"",innerChildren[1].getElementName());
      }
    }
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.9896273530541684
185513,"@Test public void testAnonymousInner5() throws Exception {
  IPath path=env.addGroovyClass(createAnnotationGroovyProject(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IField field=type.getField(""String_Node_Str"");
    assertEquals(0,field.getChildren().length);
    IType anon=type.getType(""String_Node_Str"");
    assertTrue(""String_Node_Str"",anon.exists());
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner5() throws Exception {
  IPath path=env.addGroovyClass(createAnnotationGroovyProject(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    IType type=unit.getType(""String_Node_Str"");
    IField field=type.getField(""String_Node_Str"");
    assertEquals(0,field.getChildren().length);
    IType anon=type.getType(""String_Node_Str"");
    assertTrue(""String_Node_Str"",anon.exists());
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.9814941740918436
185514,"@Test public void testAnonymousInner6() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    unit.getType(""String_Node_Str"").exists();
    unit.getType(""String_Node_Str"").exists();
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}","@Test @Ignore(""String_Node_Str"") public void testAnonymousInner6() throws Exception {
  IPath root=createAnnotationGroovyProject();
  IPath path=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild();
  env.waitForAutoBuild();
  expectingNoProblems();
  GroovyCompilationUnit unit=env.getUnit(path);
  unit.becomeWorkingCopy(new NullProgressMonitor());
  try {
    unit.getType(""String_Node_Str"").exists();
    unit.getType(""String_Node_Str"").exists();
    IType type=unit.getType(""String_Node_Str"");
    IMethod method=type.getMethod(""String_Node_Str"",new String[0]);
    IJavaElement[] children=method.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    IType anonType=(IType)children[0];
    assertEquals(""String_Node_Str"",""String_Node_Str"",anonType.getElementName());
    children=anonType.getChildren();
    assertEquals(""String_Node_Str"" + Arrays.toString(children),1,children.length);
    assertEquals(""String_Node_Str"",children[0].getElementName());
  }
  finally {
    unit.discardWorkingCopy();
  }
}",0.9882761615284412
185515,"@Override public void buildFieldsAndMethods(){
  super.buildFieldsAndMethods();
  GroovyTypeDeclaration context=(GroovyTypeDeclaration)referenceContext;
  GroovyTypeDeclaration[] anonymousTypes=context.getAnonymousTypes();
  if (anonymousTypes != null) {
    for (    GroovyTypeDeclaration anonType : anonymousTypes) {
      GroovyClassScope anonScope=new GroovyClassScope(this,anonType);
      anonType.scope=anonScope;
      anonType.resolve(anonType.enclosingMethod.scope);
    }
  }
  for (  MethodBinding method : referenceContext.binding.methods()) {
    fixupTypeParameters(method);
  }
}","@Override public void buildFieldsAndMethods(){
  super.buildFieldsAndMethods();
  GroovyTypeDeclaration context=(GroovyTypeDeclaration)referenceContext;
  GroovyTypeDeclaration[] anonymousTypes=context.getAnonymousTypes();
  if (anonymousTypes != null) {
    for (    GroovyTypeDeclaration anonType : anonymousTypes) {
      anonType.scope=new GroovyClassScope(this,anonType);
      anonType.resolve(anonType.enclosingScope);
    }
  }
  for (  MethodBinding method : referenceContext.binding.methods()) {
    fixupTypeParameters(method);
  }
}",0.6233538191395961
185516,"@Test public void testClosure9(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClosure9(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.8100686498855835
185517,"@Test public void testClosure7(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClosure7(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.8623548922056384
185518,"@Test public void testClosure8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClosure8(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.8623548922056384
185519,"protected ClassNode findDeclaringType(Expression node,VariableScope scope,TypeConfidence[] confidence){
  if (node instanceof ClassExpression || node instanceof ConstructorCallExpression) {
    return node.getType();
  }
 else   if (node instanceof FieldExpression) {
    return ((FieldExpression)node).getField().getDeclaringClass();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    return ((StaticMethodCallExpression)node).getOwnerType();
  }
 else   if (node instanceof ConstantExpression && scope.isMethodCall()) {
    return scope.getDelegateOrThis();
  }
 else   if (node instanceof VariableExpression) {
    Variable var=((VariableExpression)node).getAccessedVariable();
    if (var != null && !(var instanceof Parameter || var instanceof VariableExpression)) {
      ClassNode ownerType;
      ownerType=scope.getEnclosingTypeDeclaration();
      return ownerType;
    }
  }
  return VariableScope.OBJECT_CLASS_NODE;
}","protected ClassNode findDeclaringType(Expression node,VariableScope scope,TypeConfidence[] confidence){
  if (node instanceof ClassExpression || node instanceof ConstructorCallExpression) {
    return node.getType();
  }
 else   if (node instanceof FieldExpression) {
    return ((FieldExpression)node).getField().getDeclaringClass();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    return ((StaticMethodCallExpression)node).getOwnerType();
  }
 else   if (node instanceof ConstantExpression && scope.isMethodCall()) {
    ClassNode ownerType;
    if (scope.getEnclosingClosure() != null) {
      ownerType=scope.getOwner();
    }
 else {
      ownerType=scope.getEnclosingTypeDeclaration();
    }
    return ownerType;
  }
 else   if (node instanceof VariableExpression) {
    Variable var=((VariableExpression)node).getAccessedVariable();
    if (var != null && !(var instanceof Parameter || var instanceof VariableExpression)) {
      ClassNode ownerType;
      if (scope.getEnclosingClosure() != null) {
        ownerType=scope.getOwner();
      }
 else {
        ownerType=scope.getEnclosingTypeDeclaration();
      }
      return ownerType;
    }
  }
  return VariableScope.OBJECT_CLASS_NODE;
}",0.7215541165587419
185520,"protected static boolean isCompatible(AnnotatedNode declaration,boolean isStaticExpression){
  if (declaration != null) {
    boolean isStatic=false;
    if (declaration instanceof FieldNode) {
      isStatic=((FieldNode)declaration).isStatic();
    }
 else     if (declaration instanceof MethodNode) {
      isStatic=((MethodNode)declaration).isStatic();
    }
 else     if (declaration instanceof PropertyNode) {
      isStatic=((PropertyNode)declaration).isStatic();
    }
    if (!isStaticExpression || isStatic || declaration.getDeclaringClass().equals(VariableScope.CLASS_CLASS_NODE)) {
      return true;
    }
  }
  return false;
}","protected static boolean isCompatible(AnnotatedNode declaration,boolean isStaticExpression){
  if (declaration != null) {
    boolean isStatic=false;
    if (declaration instanceof FieldNode) {
      isStatic=((FieldNode)declaration).isStatic();
    }
 else     if (declaration instanceof MethodNode) {
      isStatic=((MethodNode)declaration).isStatic();
    }
 else     if (declaration instanceof PropertyNode) {
      isStatic=((PropertyNode)declaration).isStatic();
    }
    if (!isStaticExpression || isStatic || VariableScope.CLASS_CLASS_NODE.equals(declaration.getDeclaringClass())) {
      return true;
    }
  }
  return false;
}",0.9389671361502347
185521,"protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),owner,isLhsExpr,scope.isOwnerStatic(),scope.isFieldAccessDirect(),callArgs);
    if (candidate == null && resolveStrategy < Closure.DELEGATE_FIRST && scope.getEnclosingClosure() != null) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
    }
  }
  if (candidate == null && (resolveStrategy <= Closure.DELEGATE_FIRST || resolveStrategy == Closure.TO_SELF) && (resolveStrategy > 0 || scope.getEnclosingClosure() != null)) {
    candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,false,callArgs);
  }
  return candidate;
}","protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    VariableScope outer=owner.getNodeMetaData(""String_Node_Str"");
    if (outer != null) {
      if (isLhsExpr)       scope.getWormhole().put(""String_Node_Str"",var);
      VariableScope.CallAndType cat=outer.getEnclosingMethodCallExpression();
      int enclosingResolveStrategy=(cat == null ? 0 : cat.getResolveStrategy(outer.getEnclosingClosure()));
      candidate=findDeclarationForDynamicVariable(var,outer.getOwner(),outer,enclosingResolveStrategy);
    }
 else {
      candidate=findDeclaration(var.getName(),owner,isLhsExpr,scope.isOwnerStatic(),scope.isFieldAccessDirect(),callArgs);
    }
    if (candidate == null && resolveStrategy < Closure.DELEGATE_FIRST && scope.getEnclosingClosure() != null) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,false,callArgs);
    }
  }
  if (candidate == null && (resolveStrategy <= Closure.DELEGATE_FIRST || resolveStrategy == Closure.TO_SELF) && (resolveStrategy > 0 || scope.getEnclosingClosure() != null)) {
    candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,false,callArgs);
  }
  return candidate;
}",0.8021978021978022
185522,"protected TypeLookupResult findType(Expression node,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression){
  MethodNode target;
  if (scope.isMethodCall() && (target=getMethodTarget(node)) != null) {
    return new TypeLookupResult(target.getReturnType(),target.getDeclaringClass(),target,confidence,scope);
  }
  if (node instanceof VariableExpression) {
    return findTypeForVariable((VariableExpression)node,scope,confidence,declaringType);
  }
  if (!isPrimaryExpression && node instanceof ConstantExpression && scope.getEnclosingNode() instanceof AttributeExpression) {
    ClassNode clazz=!isStaticObjectExpression ? declaringType : declaringType.getGenericsTypes()[0].getType();
    FieldNode field=clazz.getDeclaredField(node.getText());
    if (isCompatible(field,isStaticObjectExpression)) {
      return new TypeLookupResult(field.getType(),clazz,field,TypeConfidence.EXACT,scope);
    }
 else {
      return new TypeLookupResult(VariableScope.VOID_CLASS_NODE,clazz,null,TypeConfidence.UNKNOWN,scope);
    }
  }
  ClassNode nodeType=node.getType();
  if ((!isPrimaryExpression || scope.isMethodCall()) && node instanceof ConstantExpression) {
    return findTypeForNameWithKnownObjectExpression(node.getText(),nodeType,declaringType,scope,confidence,isStaticObjectExpression,isPrimaryExpression,(scope.getWormhole().remove(""String_Node_Str"") == node));
  }
  if (node instanceof ConstantExpression) {
    ConstantExpression cexp=(ConstantExpression)node;
    if (cexp.isNullExpression()) {
      return new TypeLookupResult(VariableScope.VOID_CLASS_NODE,null,null,confidence,scope);
    }
 else     if (cexp.isTrueExpression() || cexp.isFalseExpression()) {
      return new TypeLookupResult(VariableScope.BOOLEAN_CLASS_NODE,null,null,confidence,scope);
    }
 else     if (cexp.isEmptyStringExpression() || VariableScope.STRING_CLASS_NODE.equals(nodeType)) {
      return new TypeLookupResult(VariableScope.STRING_CLASS_NODE,null,node,confidence,scope);
    }
 else     if (ClassHelper.isNumberType(nodeType) || VariableScope.BIG_DECIMAL_CLASS.equals(nodeType) || VariableScope.BIG_INTEGER_CLASS.equals(nodeType)) {
      return new TypeLookupResult(ClassHelper.isPrimitiveType(nodeType) ? ClassHelper.getWrapper(nodeType) : nodeType,null,null,confidence,scope);
    }
 else {
      return new TypeLookupResult(nodeType,null,null,TypeConfidence.UNKNOWN,scope);
    }
  }
 else   if (node instanceof BooleanExpression) {
    return new TypeLookupResult(VariableScope.BOOLEAN_CLASS_NODE,null,null,confidence,scope);
  }
 else   if (node instanceof GStringExpression) {
    return new TypeLookupResult(VariableScope.STRING_CLASS_NODE,null,null,confidence,scope);
  }
 else   if (node instanceof BitwiseNegationExpression) {
    ClassNode type=((BitwiseNegationExpression)node).getExpression().getType();
    if (VariableScope.STRING_CLASS_NODE.equals(type)) {
      return new TypeLookupResult(VariableScope.PATTERN_CLASS_NODE,null,null,confidence,scope);
    }
    return new TypeLookupResult(type,null,null,confidence,scope);
  }
 else   if (node instanceof ClosureExpression && VariableScope.isPlainClosure(nodeType)) {
    ClassNode returnType=(ClassNode)node.getNodeMetaData(""String_Node_Str"");
    if (returnType != null && !VariableScope.isVoidOrObject(returnType))     GroovyUtils.updateClosureWithInferredTypes(nodeType,returnType,((ClosureExpression)node).getParameters());
  }
 else   if (node instanceof ClassExpression) {
    ClassNode classType=VariableScope.newClassClassNode(node.getType());
    classType.setSourcePosition(node);
    return new TypeLookupResult(classType,null,node.getType(),TypeConfidence.EXACT,scope);
  }
 else   if (node instanceof ConstructorCallExpression) {
    ConstructorCallExpression constructorCall=(ConstructorCallExpression)node;
    MethodNode constructorDecl=scope.getEnclosingMethodDeclaration();
    if (constructorCall.isThisCall()) {
      declaringType=constructorDecl != null ? constructorDecl.getDeclaringClass() : scope.getEnclosingTypeDeclaration();
    }
 else     if (constructorCall.isSuperCall()) {
      declaringType=constructorDecl != null ? constructorDecl.getDeclaringClass().getUnresolvedSuperClass() : scope.getEnclosingTypeDeclaration();
    }
    List<ConstructorNode> declaredConstructors=declaringType.getDeclaredConstructors();
    if (constructorCall.getArguments() instanceof ArgumentListExpression && declaredConstructors.size() > 1) {
      List<ConstructorNode> looseMatches=new ArrayList<ConstructorNode>();
      List<ClassNode> callTypes=scope.getMethodCallArgumentTypes();
      for (      ConstructorNode ctor : declaredConstructors) {
        if (callTypes.size() == ctor.getParameters().length) {
          if (Boolean.TRUE.equals(isTypeCompatible(callTypes,ctor.getParameters()))) {
            return new TypeLookupResult(nodeType,declaringType,ctor,confidence,scope);
          }
          looseMatches.add(ctor);
        }
      }
      if (!looseMatches.isEmpty()) {
        declaredConstructors=looseMatches;
      }
    }
    ASTNode declaration=!declaredConstructors.isEmpty() ? declaredConstructors.get(0) : declaringType;
    return new TypeLookupResult(nodeType,declaringType,declaration,confidence,scope);
  }
 else   if (node instanceof StaticMethodCallExpression) {
    String methodName=((StaticMethodCallExpression)node).getMethod();
    ClassNode ownerType=((StaticMethodCallExpression)node).getOwnerType();
    List<MethodNode> candidates=new LinkedList<MethodNode>();
    if (!ownerType.isInterface()) {
      candidates.addAll(ownerType.getMethods(methodName));
    }
 else {
      LinkedHashSet<ClassNode> faces=new LinkedHashSet<ClassNode>();
      VariableScope.findAllInterfaces(ownerType,faces,false);
      for (      ClassNode face : faces) {
        candidates.addAll(face.getMethods(methodName));
      }
    }
    for (Iterator<MethodNode> it=candidates.iterator(); it.hasNext(); ) {
      if (!it.next().isStatic())       it.remove();
    }
    if (!candidates.isEmpty()) {
      MethodNode closestMatch;
      if (scope.isMethodCall()) {
        closestMatch=findMethodDeclaration0(candidates,scope.getMethodCallArgumentTypes());
        confidence=TypeConfidence.INFERRED;
      }
 else {
        closestMatch=candidates.get(0);
        confidence=TypeConfidence.LOOSELY_INFERRED;
      }
      return new TypeLookupResult(closestMatch.getReturnType(),closestMatch.getDeclaringClass(),closestMatch,confidence,scope);
    }
  }
  if (!(node instanceof TupleExpression) && nodeType.equals(VariableScope.OBJECT_CLASS_NODE)) {
    confidence=TypeConfidence.UNKNOWN;
  }
  return new TypeLookupResult(nodeType,declaringType,null,confidence,scope);
}","protected TypeLookupResult findType(Expression node,ClassNode declaringType,VariableScope scope,TypeConfidence confidence,boolean isStaticObjectExpression,boolean isPrimaryExpression){
  MethodNode target;
  if (scope.isMethodCall() && (target=getMethodTarget(node)) != null) {
    return new TypeLookupResult(target.getReturnType(),target.getDeclaringClass(),target,confidence,scope);
  }
  if (node instanceof VariableExpression) {
    return findTypeForVariable((VariableExpression)node,scope,confidence,declaringType);
  }
 else   if (node instanceof ConstantExpression && isPrimaryExpression && scope.isMethodCall()) {
    VariableExpression expr=new VariableExpression(new DynamicVariable(node.getText(),false));
    TypeLookupResult result=findTypeForVariable(expr,scope,confidence,declaringType);
    if (isCompatible((AnnotatedNode)result.declaration,isStaticObjectExpression)) {
      return result;
    }
  }
  ClassNode nodeType=node.getType();
  if (node instanceof ConstantExpression) {
    if (!isPrimaryExpression) {
      if (scope.getEnclosingNode() instanceof AttributeExpression) {
        ClassNode clazz=!isStaticObjectExpression ? declaringType : declaringType.getGenericsTypes()[0].getType();
        FieldNode field=clazz.getDeclaredField(node.getText());
        if (isCompatible(field,isStaticObjectExpression)) {
          return new TypeLookupResult(field.getType(),clazz,field,TypeConfidence.EXACT,scope);
        }
 else {
          return new TypeLookupResult(VariableScope.VOID_CLASS_NODE,clazz,null,TypeConfidence.UNKNOWN,scope);
        }
      }
    }
    if (!isPrimaryExpression || scope.isMethodCall()) {
      return findTypeForNameWithKnownObjectExpression(node.getText(),nodeType,declaringType,scope,confidence,isStaticObjectExpression,isPrimaryExpression,(scope.getWormhole().remove(""String_Node_Str"") == node));
    }
    ConstantExpression cexp=(ConstantExpression)node;
    if (cexp.isNullExpression()) {
      return new TypeLookupResult(VariableScope.VOID_CLASS_NODE,null,null,confidence,scope);
    }
 else     if (cexp.isTrueExpression() || cexp.isFalseExpression()) {
      return new TypeLookupResult(VariableScope.BOOLEAN_CLASS_NODE,null,null,confidence,scope);
    }
 else     if (cexp.isEmptyStringExpression() || VariableScope.STRING_CLASS_NODE.equals(nodeType)) {
      return new TypeLookupResult(VariableScope.STRING_CLASS_NODE,null,node,confidence,scope);
    }
 else     if (ClassHelper.isNumberType(nodeType) || VariableScope.BIG_DECIMAL_CLASS.equals(nodeType) || VariableScope.BIG_INTEGER_CLASS.equals(nodeType)) {
      return new TypeLookupResult(ClassHelper.isPrimitiveType(nodeType) ? ClassHelper.getWrapper(nodeType) : nodeType,null,null,confidence,scope);
    }
 else {
      return new TypeLookupResult(nodeType,null,null,TypeConfidence.UNKNOWN,scope);
    }
  }
 else   if (node instanceof BooleanExpression) {
    return new TypeLookupResult(VariableScope.BOOLEAN_CLASS_NODE,null,null,confidence,scope);
  }
 else   if (node instanceof GStringExpression) {
    return new TypeLookupResult(VariableScope.STRING_CLASS_NODE,null,null,confidence,scope);
  }
 else   if (node instanceof BitwiseNegationExpression) {
    ClassNode type=((BitwiseNegationExpression)node).getExpression().getType();
    if (VariableScope.STRING_CLASS_NODE.equals(type)) {
      return new TypeLookupResult(VariableScope.PATTERN_CLASS_NODE,null,null,confidence,scope);
    }
    return new TypeLookupResult(type,null,null,confidence,scope);
  }
 else   if (node instanceof ClosureExpression && VariableScope.isPlainClosure(nodeType)) {
    ClassNode returnType=(ClassNode)node.getNodeMetaData(""String_Node_Str"");
    if (returnType != null && !VariableScope.isVoidOrObject(returnType))     GroovyUtils.updateClosureWithInferredTypes(nodeType,returnType,((ClosureExpression)node).getParameters());
  }
 else   if (node instanceof ClassExpression) {
    ClassNode classType=VariableScope.newClassClassNode(node.getType());
    classType.setSourcePosition(node);
    return new TypeLookupResult(classType,null,node.getType(),TypeConfidence.EXACT,scope);
  }
 else   if (node instanceof ConstructorCallExpression) {
    ConstructorCallExpression constructorCall=(ConstructorCallExpression)node;
    MethodNode constructorDecl=scope.getEnclosingMethodDeclaration();
    if (constructorCall.isThisCall()) {
      declaringType=constructorDecl != null ? constructorDecl.getDeclaringClass() : scope.getEnclosingTypeDeclaration();
    }
 else     if (constructorCall.isSuperCall()) {
      declaringType=constructorDecl != null ? constructorDecl.getDeclaringClass().getUnresolvedSuperClass() : scope.getEnclosingTypeDeclaration();
    }
    List<ConstructorNode> declaredConstructors=declaringType.getDeclaredConstructors();
    if (constructorCall.getArguments() instanceof ArgumentListExpression && declaredConstructors.size() > 1) {
      List<ConstructorNode> looseMatches=new ArrayList<ConstructorNode>();
      List<ClassNode> callTypes=scope.getMethodCallArgumentTypes();
      for (      ConstructorNode ctor : declaredConstructors) {
        if (callTypes.size() == ctor.getParameters().length) {
          if (Boolean.TRUE.equals(isTypeCompatible(callTypes,ctor.getParameters()))) {
            return new TypeLookupResult(nodeType,declaringType,ctor,confidence,scope);
          }
          looseMatches.add(ctor);
        }
      }
      if (!looseMatches.isEmpty()) {
        declaredConstructors=looseMatches;
      }
    }
    ASTNode declaration=!declaredConstructors.isEmpty() ? declaredConstructors.get(0) : declaringType;
    return new TypeLookupResult(nodeType,declaringType,declaration,confidence,scope);
  }
 else   if (node instanceof StaticMethodCallExpression) {
    String methodName=((StaticMethodCallExpression)node).getMethod();
    ClassNode ownerType=((StaticMethodCallExpression)node).getOwnerType();
    List<MethodNode> candidates=new LinkedList<MethodNode>();
    if (!ownerType.isInterface()) {
      candidates.addAll(ownerType.getMethods(methodName));
    }
 else {
      LinkedHashSet<ClassNode> faces=new LinkedHashSet<ClassNode>();
      VariableScope.findAllInterfaces(ownerType,faces,false);
      for (      ClassNode face : faces) {
        candidates.addAll(face.getMethods(methodName));
      }
    }
    for (Iterator<MethodNode> it=candidates.iterator(); it.hasNext(); ) {
      if (!it.next().isStatic())       it.remove();
    }
    if (!candidates.isEmpty()) {
      MethodNode closestMatch;
      if (scope.isMethodCall()) {
        closestMatch=findMethodDeclaration0(candidates,scope.getMethodCallArgumentTypes());
        confidence=TypeConfidence.INFERRED;
      }
 else {
        closestMatch=candidates.get(0);
        confidence=TypeConfidence.LOOSELY_INFERRED;
      }
      return new TypeLookupResult(closestMatch.getReturnType(),closestMatch.getDeclaringClass(),closestMatch,confidence,scope);
    }
  }
  if (!(node instanceof TupleExpression) && nodeType.equals(VariableScope.OBJECT_CLASS_NODE)) {
    confidence=TypeConfidence.UNKNOWN;
  }
  return new TypeLookupResult(nodeType,declaringType,null,confidence,scope);
}",0.948036036036036
185523,"@Override public void visitClosureExpression(ClosureExpression node){
  VariableScope parent=scopes.getLast();
  VariableScope scope=new VariableScope(parent,node,false);
  scopes.add(scope);
  ClassNode[] inferredParamTypes=inferClosureParamTypes(scope,node);
  Parameter[] parameters=node.getParameters();
  final int n;
  if (parameters != null && (n=parameters.length) > 0) {
    handleParameterList(parameters);
    for (int i=0; i < n; i+=1) {
      Parameter parameter=parameters[i];
      if (inferredParamTypes[i] != VariableScope.OBJECT_CLASS_NODE && parameter.isDynamicTyped()) {
        parameter.setType(inferredParamTypes[i]);
        scope.addVariable(parameter);
      }
    }
  }
 else   if (inferredParamTypes[0] != VariableScope.OBJECT_CLASS_NODE && !scope.containsInThisScope(""String_Node_Str"")) {
    scope.addVariable(""String_Node_Str"",inferredParamTypes[0],VariableScope.OBJECT_CLASS_NODE);
  }
  if (scope.lookupNameInCurrentScope(""String_Node_Str"") == null) {
    inferItType(node,scope);
  }
  if (parent.getEnclosingClosure() != null) {
    ClassNode closureType=GenericsUtils.nonGeneric(VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",closureType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",closureType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode ownerType=scope.getThis();
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null && cat.getDelegateType(node) != null) {
    ClassNode delegateType=cat.getDelegateType(node);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode delegateType=scope.lookupName(""String_Node_Str"").type;
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
  super.visitClosureExpression(node);
  handleSimpleExpression(node);
  scopes.removeLast();
}","@Override public void visitClosureExpression(ClosureExpression node){
  VariableScope parent=scopes.getLast();
  VariableScope scope=new VariableScope(parent,node,false);
  scopes.add(scope);
  ClassNode[] inferredParamTypes=inferClosureParamTypes(scope,node);
  Parameter[] parameters=node.getParameters();
  final int n;
  if (parameters != null && (n=parameters.length) > 0) {
    handleParameterList(parameters);
    for (int i=0; i < n; i+=1) {
      Parameter parameter=parameters[i];
      if (inferredParamTypes[i] != VariableScope.OBJECT_CLASS_NODE && parameter.isDynamicTyped()) {
        parameter.setType(inferredParamTypes[i]);
        scope.addVariable(parameter);
      }
    }
  }
 else   if (inferredParamTypes[0] != VariableScope.OBJECT_CLASS_NODE && !scope.containsInThisScope(""String_Node_Str"")) {
    scope.addVariable(""String_Node_Str"",inferredParamTypes[0],VariableScope.OBJECT_CLASS_NODE);
  }
  if (scope.lookupNameInCurrentScope(""String_Node_Str"") == null) {
    inferItType(node,scope);
  }
  if (parent.getEnclosingClosure() != null) {
    ClassNode closureType=GenericsUtils.nonGeneric(VariableScope.CLOSURE_CLASS_NODE);
    closureType.putNodeMetaData(""String_Node_Str"",parent.getEnclosingClosureScope());
    scope.addVariable(""String_Node_Str"",closureType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",closureType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode ownerType=scope.getThis();
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null && cat.getDelegateType(node) != null) {
    ClassNode delegateType=cat.getDelegateType(node);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode delegateType=scope.getOwner();
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
  super.visitClosureExpression(node);
  handleSimpleExpression(node);
  scopes.removeLast();
}",0.9609014390442574
185524,"public ClassNode getThis(){
  VariableInfo thiz=lookupName(""String_Node_Str"");
  return thiz != null ? thiz.type : null;
}","public ClassNode getThis(){
  VariableInfo info=lookupName(""String_Node_Str"");
  return info != null ? info.type : null;
}",0.9262295081967212
185525,"public ClassNode getDelegate(){
  VariableInfo delegate=lookupName(""String_Node_Str"");
  return delegate != null ? delegate.type : null;
}","public ClassNode getDelegate(){
  VariableInfo info=lookupName(""String_Node_Str"");
  return info != null ? info.type : null;
}",0.8636363636363636
185526,"public ClassNode getDelegateOrThis(){
  VariableInfo info=getDelegateOrThisInfo();
  return info != null ? info.type : null;
}","/** 
 * @return the current delegate type if exists, or this type if exists.Returns null if in top level scope (i.e. in import statement).
 */
public ClassNode getDelegateOrThis(){
  ClassNode type=getDelegate();
  if (type == null) {
    type=getThis();
  }
  return type;
}",0.3241895261845386
185527,"private VariableScope getEnclosingClosureScope(){
  VariableScope scope=this;
  do {
    if (scope.scopeNode instanceof ClosureExpression) {
      return scope;
    }
  }
 while ((scope=scope.parent) != null);
  return null;
}","VariableScope getEnclosingClosureScope(){
  VariableScope scope=this;
  do {
    if (scope.scopeNode instanceof ClosureExpression) {
      return scope;
    }
  }
 while ((scope=scope.parent) != null);
  return null;
}",0.981981981981982
185528,"@Test public void testDGM2(){
  String contents=""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + 5,""String_Node_Str"");
}","@Test public void testDGM2(){
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  assertType(contents,start,start + 5,""String_Node_Str"");
}",0.69921875
185529,"/** 
 * Determines if the parameter type can be implicitly determined.  We look for DGM method calls that take closures and see what kind of type they expect.
 * @return array of {@link ClassNode}s specifying the inferred types of the closure's parameters
 */
private static ClassNode[] inferClosureParamTypes(VariableScope scope,ClosureExpression closure){
  int paramCount=closure.getParameters() == null ? 0 : closure.getParameters().length;
  if (paramCount == 0) {
    paramCount+=1;
  }
  ClassNode[] inferredTypes=new ClassNode[paramCount];
  CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null) {
    ClassNode delegateType=cat.declaringType;
    String methodName=cat.call.getMethodAsString();
    ClassNode inferredParamType;
    if (dgmClosureDelegateMethods.contains(methodName)) {
      inferredParamType=VariableScope.extractElementType(delegateType);
    }
 else {
      inferredParamType=dgmClosureFixedTypeMethods.get(methodName);
    }
    if (inferredParamType != null) {
      Arrays.fill(inferredTypes,inferredParamType);
      if (methodName.equals(""String_Node_Str"") && inferredTypes.length > 1) {
        inferredTypes[inferredTypes.length - 1]=VariableScope.INTEGER_CLASS_NODE;
      }
      if (delegateType.getName().equals(VariableScope.MAP_CLASS_NODE.getName())) {
        if ((dgmClosureMaybeMap.contains(methodName) && paramCount == 2) || (methodName.equals(""String_Node_Str"") && paramCount == 3)) {
          GenericsType[] typeParams=inferredParamType.getGenericsTypes();
          if (typeParams != null && typeParams.length == 2) {
            inferredTypes[0]=typeParams[0].getType();
            inferredTypes[1]=typeParams[1].getType();
          }
        }
      }
      return inferredTypes;
    }
  }
  Arrays.fill(inferredTypes,VariableScope.OBJECT_CLASS_NODE);
  return inferredTypes;
}","/** 
 * Determines if the parameter type can be implicitly determined.  We look for DGM method calls that take closures and see what kind of type they expect.
 * @return array of {@link ClassNode}s specifying the inferred types of the closure's parameters
 */
private static ClassNode[] inferClosureParamTypes(VariableScope scope,ClosureExpression closure){
  int paramCount=closure.getParameters() == null ? 0 : closure.getParameters().length;
  if (paramCount == 0) {
    paramCount+=1;
  }
  ClassNode[] inferredTypes=new ClassNode[paramCount];
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null) {
    ClassNode delegateType=cat.declaringType;
    String methodName=cat.call.getMethodAsString();
    ClassNode inferredParamType;
    if (dgmClosureDelegateMethods.contains(methodName)) {
      inferredParamType=VariableScope.extractElementType(delegateType);
    }
 else {
      inferredParamType=dgmClosureFixedTypeMethods.get(methodName);
    }
    if (inferredParamType != null) {
      Arrays.fill(inferredTypes,inferredParamType);
      if (methodName.equals(""String_Node_Str"") && inferredTypes.length > 1) {
        inferredTypes[inferredTypes.length - 1]=VariableScope.INTEGER_CLASS_NODE;
      }
      if (delegateType.getName().equals(VariableScope.MAP_CLASS_NODE.getName())) {
        if ((dgmClosureMaybeMap.contains(methodName) && paramCount == 2) || (methodName.equals(""String_Node_Str"") && paramCount == 3)) {
          GenericsType[] typeParams=inferredParamType.getGenericsTypes();
          if (typeParams != null && typeParams.length == 2) {
            inferredTypes[0]=typeParams[0].getType();
            inferredTypes[1]=typeParams[1].getType();
          }
        }
      }
      return inferredTypes;
    }
  }
  Arrays.fill(inferredTypes,VariableScope.OBJECT_CLASS_NODE);
  return inferredTypes;
}",0.9962385814078452
185530,"@Override public void visitArgumentlistExpression(ArgumentListExpression node){
  CallAndType callAndType=scopes.getLast().getEnclosingMethodCallExpression();
  boolean closureFound=false;
  if (callAndType != null && callAndType.declaration instanceof MethodNode) {
    Map<ClosureExpression,ClassNode> map=new HashMap<ClosureExpression,ClassNode>();
    MethodNode methodNode=(MethodNode)callAndType.declaration;
    if (node.getExpressions().size() == methodNode.getParameters().length) {
      for (int i=0; i < node.getExpressions().size(); i++) {
        if (node.getExpression(i) instanceof ClosureExpression) {
          map.put((ClosureExpression)node.getExpression(i),methodNode.getParameters()[i].getType());
          closureFound=true;
        }
      }
    }
    if (closureFound) {
      closureTypes.addLast(map);
    }
  }
  visitTupleExpression(node);
  if (closureFound) {
    closureTypes.removeLast();
  }
}","@Override public void visitArgumentlistExpression(ArgumentListExpression node){
  VariableScope.CallAndType callAndType=scopes.getLast().getEnclosingMethodCallExpression();
  boolean closureFound=false;
  if (callAndType != null && callAndType.declaration instanceof MethodNode) {
    Map<ClosureExpression,ClassNode> map=new HashMap<ClosureExpression,ClassNode>();
    MethodNode methodNode=(MethodNode)callAndType.declaration;
    if (node.getExpressions().size() == methodNode.getParameters().length) {
      for (int i=0; i < node.getExpressions().size(); i++) {
        if (node.getExpression(i) instanceof ClosureExpression) {
          map.put((ClosureExpression)node.getExpression(i),methodNode.getParameters()[i].getType());
          closureFound=true;
        }
      }
    }
    if (closureFound) {
      closureTypes.addLast(map);
    }
  }
  visitTupleExpression(node);
  if (closureFound) {
    closureTypes.removeLast();
  }
}",0.9925133689839571
185531,"@Override public void visitClosureExpression(ClosureExpression node){
  VariableScope parent=scopes.getLast();
  VariableScope scope=new VariableScope(parent,node,false);
  scopes.add(scope);
  ClassNode[] inferredParamTypes=inferClosureParamTypes(scope,node);
  Parameter[] parameters=node.getParameters();
  final int n;
  if (parameters != null && (n=parameters.length) > 0) {
    handleParameterList(parameters);
    for (int i=0; i < n; i+=1) {
      Parameter parameter=parameters[i];
      if (inferredParamTypes[i] != VariableScope.OBJECT_CLASS_NODE && parameter.isDynamicTyped()) {
        parameter.setType(inferredParamTypes[i]);
        scope.addVariable(parameter);
      }
    }
  }
 else   if (inferredParamTypes[0] != VariableScope.OBJECT_CLASS_NODE && !scope.containsInThisScope(""String_Node_Str"")) {
    scope.addVariable(""String_Node_Str"",inferredParamTypes[0],VariableScope.OBJECT_CLASS_NODE);
  }
  if (scope.lookupNameInCurrentScope(""String_Node_Str"") == null) {
    inferItType(node,scope);
  }
  CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null) {
    ClassNode delegateType=cat.getDelegateType(node);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode thisType=scope.getThis();
    if (scope.lookupName(""String_Node_Str"") == null) {
      scope.addVariable(""String_Node_Str"",thisType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",thisType,VariableScope.CLOSURE_CLASS_NODE);
  }
  if (parent.getEnclosingClosure() != null) {
    scope.addVariable(""String_Node_Str"",VariableScope.CLOSURE_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLOSURE_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode thisType=scope.getThis();
    if (scope.lookupName(""String_Node_Str"") == null) {
      scope.addVariable(""String_Node_Str"",thisType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",thisType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
  super.visitClosureExpression(node);
  handleSimpleExpression(node);
  scopes.removeLast();
}","@Override public void visitClosureExpression(ClosureExpression node){
  VariableScope parent=scopes.getLast();
  VariableScope scope=new VariableScope(parent,node,false);
  scopes.add(scope);
  ClassNode[] inferredParamTypes=inferClosureParamTypes(scope,node);
  Parameter[] parameters=node.getParameters();
  final int n;
  if (parameters != null && (n=parameters.length) > 0) {
    handleParameterList(parameters);
    for (int i=0; i < n; i+=1) {
      Parameter parameter=parameters[i];
      if (inferredParamTypes[i] != VariableScope.OBJECT_CLASS_NODE && parameter.isDynamicTyped()) {
        parameter.setType(inferredParamTypes[i]);
        scope.addVariable(parameter);
      }
    }
  }
 else   if (inferredParamTypes[0] != VariableScope.OBJECT_CLASS_NODE && !scope.containsInThisScope(""String_Node_Str"")) {
    scope.addVariable(""String_Node_Str"",inferredParamTypes[0],VariableScope.OBJECT_CLASS_NODE);
  }
  if (scope.lookupNameInCurrentScope(""String_Node_Str"") == null) {
    inferItType(node,scope);
  }
  VariableScope.CallAndType cat=scope.getEnclosingMethodCallExpression();
  if (cat != null) {
    ClassNode delegateType=cat.getDelegateType(node);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode delegateType=scope.getThis();
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",delegateType,VariableScope.CLOSURE_CLASS_NODE);
  }
  if (parent.getEnclosingClosure() != null) {
    scope.addVariable(""String_Node_Str"",VariableScope.CLOSURE_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLOSURE_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
 else {
    ClassNode ownerType=scope.getThis();
    VariableScope.VariableInfo inf=scope.lookupName(""String_Node_Str"");
    if (inf == null || inf.scopeNode instanceof ClosureExpression) {
      scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    }
    scope.addVariable(""String_Node_Str"",ownerType,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.OBJECT_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.CLASS_ARRAY_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
    scope.addVariable(""String_Node_Str"",VariableScope.INTEGER_CLASS_NODE,VariableScope.CLOSURE_CLASS_NODE);
  }
  super.visitClosureExpression(node);
  handleSimpleExpression(node);
  scopes.removeLast();
}",0.9621245102307358
185532,"@Override public void visitMethodCallExpression(MethodCallExpression node){
  scopes.getLast().setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  CallAndType call=new CallAndType(node,t.declaringType,t.declaration,unit.getModuleNode());
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scopes.getLast().setCategoryBeingDeclared(catNode);
  }
  VariableScope scope=scopes.getLast();
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scopes.getLast().forgetCurrentNode();
}","@Override public void visitMethodCallExpression(MethodCallExpression node){
  scopes.getLast().setCurrentNode(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.removeLast();
  }
  completeExpressionStack.add(node);
  node.getObjectExpression().visit(this);
  if (node.isSpreadSafe()) {
    ClassNode objType=primaryTypeStack.removeLast();
    primaryTypeStack.add(VariableScope.extractElementType(objType));
  }
  if (node.isUsingGenerics()) {
    visitGenericTypes(node.getGenericsTypes(),null);
  }
  node.getMethod().visit(this);
  ClassNode returnType=dependentTypeStack.removeLast();
  Tuple t=dependentDeclarationStack.removeLast();
  VariableScope.CallAndType call=new VariableScope.CallAndType(node,t.declaringType,t.declaration,unit.getModuleNode());
  completeExpressionStack.removeLast();
  ClassNode catNode=isCategoryDeclaration(node);
  if (catNode != null) {
    scopes.getLast().setCategoryBeingDeclared(catNode);
  }
  VariableScope scope=scopes.getLast();
  scope.addEnclosingMethodCall(call);
  node.getArguments().visit(this);
  scope.forgetEnclosingMethodCall();
  if (node.isSpreadSafe()) {
    returnType=createParameterizedList(returnType);
  }
  Expression expr=GroovyUtils.getTraitFieldExpression(node);
  if (expr != null) {
    handleSimpleExpression(expr);
    postVisit(node,returnType,t.declaringType,node);
  }
 else {
    handleCompleteExpression(node,returnType,t.declaringType);
  }
  scopes.getLast().forgetCurrentNode();
}",0.9904109589041096
185533,"public void addEnclosingMethodCall(CallAndType enclosingMethodCall){
  shared.enclosingCallStack.add(enclosingMethodCall);
}","public void addEnclosingMethodCall(CallAndType enclosingMethodCall){
}",0.7216494845360825
185534,"public int getEnclosingClosureResolveStrategy(){
  int resolveStrategy=Closure.OWNER_FIRST;
  CallAndType cat=getEnclosingMethodCallExpression();
  if (cat != null) {
    resolveStrategy=cat.getResolveStrategy(getEnclosingClosure());
  }
  return resolveStrategy;
}","public int getEnclosingClosureResolveStrategy(){
  VariableScope scope=getEnclosingClosureScope();
  int resolveStrategy=Closure.OWNER_FIRST;
  if (scope != null) {
    CallAndType cat=scope.getEnclosingMethodCallExpression();
    if (cat != null) {
      resolveStrategy=cat.getResolveStrategy((ClosureExpression)scope.scopeNode);
    }
  }
  return resolveStrategy;
}",0.6845425867507886
185535,"public VariableScope(VariableScope parent,ASTNode enclosingNode,boolean isStatic){
  this.parent=parent;
  this.scopeNode=enclosingNode;
  this.shared=parent != null ? parent.shared : new SharedState();
  this.isStaticScope=(isStatic || (parent != null && parent.isStaticScope)) && (getEnclosingClosure() == null);
  if (enclosingNode instanceof MethodNode) {
    this.shared.isRunMethod=((MethodNode)enclosingNode).isScriptBody();
  }
 else   if (enclosingNode instanceof FieldNode || enclosingNode instanceof ClassNode) {
    this.shared.isRunMethod=false;
  }
}","public VariableScope(VariableScope parent,ASTNode enclosingNode,boolean isStatic){
  this.parent=parent;
  this.scopeNode=enclosingNode;
  this.shared=parent != null ? parent.shared : new SharedState();
  this.enclosingCallStackDepth=shared.enclosingCallStack.size();
  this.isStaticScope=(isStatic || (parent != null && parent.isStaticScope)) && (getEnclosingClosure() == null);
  if (enclosingNode instanceof MethodNode) {
    this.shared.isRunMethod=((MethodNode)enclosingNode).isScriptBody();
  }
 else   if (enclosingNode instanceof FieldNode || enclosingNode instanceof ClassNode) {
    this.shared.isRunMethod=false;
  }
}",0.9455155071248952
185536,"public ClosureExpression getEnclosingClosure(){
  if (scopeNode instanceof ClosureExpression) {
    return (ClosureExpression)scopeNode;
  }
  if (parent != null) {
    return parent.getEnclosingClosure();
  }
  return null;
}","public ClosureExpression getEnclosingClosure(){
  VariableScope scope=getEnclosingClosureScope();
  return (scope != null ? (ClosureExpression)scope.scopeNode : null);
}",0.5974683544303797
185537,"public void forgetEnclosingMethodCall(){
  shared.enclosingCallStack.removeLast();
}","public void forgetEnclosingMethodCall(){
}",0.6666666666666666
185538,"public CallAndType getEnclosingMethodCallExpression(){
  if (shared.enclosingCallStack.isEmpty()) {
    return null;
  }
 else {
    return shared.enclosingCallStack.getLast();
  }
}","public CallAndType getEnclosingMethodCallExpression(){
  List<CallAndType> enclosingCalls=getAllEnclosingMethodCallExpressions();
  return (!enclosingCalls.isEmpty() ? enclosingCalls.get(enclosingCalls.size() - 1) : null);
}",0.3842364532019704
185539,"/** 
 * @return the enclosing method call expression if one exists, or null otherwise.For example, when visiting the following closure, the enclosing method call is 'run' <pre> def runner = new Runner() runner.run { print ""hello!"" } </pre>
 */
public List<CallAndType> getAllEnclosingMethodCallExpressions(){
  return shared.enclosingCallStack;
}","/** 
 * @return the enclosing method call expression if one exists, or null otherwise.For example, when visiting the following closure, the enclosing method call is 'run' <pre> def runner = new Runner() runner.run { print ""hello!"" } </pre>
 */
public List<CallAndType> getAllEnclosingMethodCallExpressions(){
  return shared.enclosingCallStack.subList(0,enclosingCallStackDepth);
}",0.951856946354883
185540,"protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy > 0) {
    if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,callArgs);
    }
 else     if (resolveStrategy == Closure.TO_SELF) {
      candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,callArgs);
    }
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),owner,isLhsExpr,isOwnerStatic(scope),callArgs);
    if (candidate == null && resolveStrategy < Closure.OWNER_FIRST) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,callArgs);
    }
  }
  return candidate;
}","protected ASTNode findDeclarationForDynamicVariable(VariableExpression var,ClassNode owner,VariableScope scope,int resolveStrategy){
  ASTNode candidate=null;
  List<ClassNode> callArgs=scope.getMethodCallArgumentTypes();
  boolean isLhsExpr=(scope.getWormhole().remove(""String_Node_Str"") == var);
  if (resolveStrategy > 0) {
    if (resolveStrategy == Closure.DELEGATE_FIRST || resolveStrategy == Closure.DELEGATE_ONLY) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,callArgs);
    }
 else     if (resolveStrategy == Closure.TO_SELF) {
      candidate=findDeclaration(var.getName(),VariableScope.CLOSURE_CLASS_NODE,isLhsExpr,false,callArgs);
    }
  }
  if (candidate == null && resolveStrategy < Closure.DELEGATE_ONLY) {
    candidate=findDeclaration(var.getName(),owner,isLhsExpr,scope.isOwnerStatic(),callArgs);
    if (candidate == null && resolveStrategy < Closure.OWNER_FIRST) {
      candidate=findDeclaration(var.getName(),scope.getDelegate(),isLhsExpr,false,callArgs);
    }
  }
  return candidate;
}",0.9947494033412888
185541,"/** 
 * Looks for the named member in the declaring type. Also searches super types. The result can be a field, method, or property.
 * @param name the name of the field, method, constant or property to find
 * @param declaringType the type in which the named member's declaration resides
 * @param isLhsExpression {@code true} if named member is being assigned a value
 * @param isStaticExpression {@code true} if member is being accessed statically
 * @param methodCallArgumentTypes types of arguments to the associated method call (or {@code null} if not a method call)
 */
protected ASTNode findDeclaration(String name,ClassNode declaringType,boolean isLhsExpression,boolean isStaticExpression,List<ClassNode> methodCallArgumentTypes){
  if (declaringType.isArray()) {
    if (name.equals(""String_Node_Str"")) {
      return createLengthField(declaringType);
    }
    return findDeclaration(name,VariableScope.OBJECT_CLASS_NODE,isLhsExpression,isStaticExpression,methodCallArgumentTypes);
  }
  if (methodCallArgumentTypes != null) {
    ASTNode method=findMethodDeclaration(name,declaringType,methodCallArgumentTypes);
    if (method != null) {
      return method;
    }
  }
  MethodNode accessor=AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false,!isLhsExpression ? READER : WRITER);
  if (accessor != null && !isSynthetic(accessor) && (accessor.isStatic() == isStaticExpression)) {
    return accessor;
  }
  LinkedHashSet<ClassNode> typeHierarchy=new LinkedHashSet<ClassNode>();
  VariableScope.createTypeHierarchy(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    PropertyNode property=type.getProperty(name);
    if (property != null) {
      return property;
    }
  }
  FieldNode field=declaringType.getField(name);
  if (field != null) {
    return field;
  }
  typeHierarchy.clear();
  VariableScope.findAllInterfaces(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    if (type == declaringType) {
      continue;
    }
    field=type.getField(name);
    if (field != null && field.isFinal() && field.isStatic()) {
      return field;
    }
  }
  if (accessor != null) {
    return accessor;
  }
  if (methodCallArgumentTypes == null) {
    return findMethodDeclaration(name,declaringType,null);
  }
  return null;
}","/** 
 * Looks for the named member in the declaring type. Also searches super types. The result can be a field, method, or property.
 * @param name the name of the field, method, constant or property to find
 * @param declaringType the type in which the named member's declaration resides
 * @param isLhsExpression {@code true} if named member is being assigned a value
 * @param isStaticExpression {@code true} if member is being accessed statically
 * @param methodCallArgumentTypes types of arguments to the associated method call (or {@code null} if not a method call)
 */
protected ASTNode findDeclaration(String name,ClassNode declaringType,boolean isLhsExpression,boolean isStaticExpression,List<ClassNode> methodCallArgumentTypes){
  if (declaringType.isArray()) {
    if (name.equals(""String_Node_Str"")) {
      return createLengthField(declaringType);
    }
    return findDeclaration(name,VariableScope.OBJECT_CLASS_NODE,isLhsExpression,isStaticExpression,methodCallArgumentTypes);
  }
  if (methodCallArgumentTypes != null) {
    ASTNode method=findMethodDeclaration(name,declaringType,methodCallArgumentTypes);
    if (method != null) {
      return method;
    }
  }
  MethodNode accessor=AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false,!isLhsExpression ? READER : WRITER);
  if (accessor != null && !isSynthetic(accessor) && (accessor.isStatic() == isStaticExpression)) {
    return accessor;
  }
  LinkedHashSet<ClassNode> typeHierarchy=new LinkedHashSet<ClassNode>();
  VariableScope.createTypeHierarchy(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    PropertyNode property=type.getProperty(name);
    if (isCompatible(property,isStaticExpression)) {
      return property;
    }
  }
  FieldNode field=declaringType.getField(name);
  if (isCompatible(field,isStaticExpression)) {
    return field;
  }
  typeHierarchy.clear();
  VariableScope.findAllInterfaces(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    if (type == declaringType) {
      continue;
    }
    field=type.getField(name);
    if (field != null && field.isFinal() && field.isStatic()) {
      return field;
    }
  }
  if (isCompatible(accessor,isStaticExpression)) {
    return accessor;
  }
  if (methodCallArgumentTypes == null) {
    return findMethodDeclaration(name,declaringType,null);
  }
  return null;
}",0.7450647420929739
185542,"private ICompletionProposal proposeImportableType(char[] packageName,char[] simpleTypeName,int modifiers,int accessibility,char[] qualifiedTypeName,char[] fullyQualifiedName,boolean isQualified){
  GroovyCompletionProposal proposal=createProposal(CompletionProposal.TYPE_REF,context.completionLocation - offset);
  proposal.setAccessibility(accessibility);
  proposal.setCompletion(isQualified ? fullyQualifiedName : simpleTypeName);
  proposal.setDeclarationSignature(packageName);
  proposal.setFlags(modifiers);
  proposal.setNameLookup(nameLookup);
  proposal.setPackageName(packageName);
  proposal.setReplaceRange(offset,offset + replaceLength);
  proposal.setRelevance(IRelevanceRule.DEFAULT.getRelevance(fullyQualifiedName,allTypesInUnit,accessibility,modifiers));
  proposal.setSignature(CompletionEngine.createNonGenericTypeSignature(packageName,simpleTypeName));
  proposal.setTokenRange(offset,context.completionLocation);
  proposal.setTypeName(simpleTypeName);
  LazyJavaTypeCompletionProposal javaCompletionProposal=new LazyJavaTypeCompletionProposal(proposal,javaContext);
  javaCompletionProposal.setTriggerCharacters(ProposalUtils.TYPE_TRIGGERS);
  javaCompletionProposal.setRelevance(proposal.getRelevance());
  ImportRewrite r=groovyRewriter.getImportRewrite(monitor);
  if (r != null) {
    ReflectionUtils.setPrivateField(LazyJavaTypeCompletionProposal.class,""String_Node_Str"",javaCompletionProposal,r);
  }
  return javaCompletionProposal;
}","private ICompletionProposal proposeImportableType(char[] packageName,char[] simpleTypeName,int modifiers,int accessibility,char[] qualifiedTypeName,char[] fullyQualifiedName,boolean isQualified){
  GroovyCompletionProposal proposal=createProposal(CompletionProposal.TYPE_REF,context.completionLocation - offset);
  proposal.setAccessibility(accessibility);
  proposal.setCompletion(isQualified ? fullyQualifiedName : simpleTypeName);
  proposal.setDeclarationSignature(packageName);
  proposal.setFlags(modifiers);
  proposal.setNameLookup(nameLookup);
  proposal.setPackageName(packageName);
  proposal.setReplaceRange(offset,offset + replaceLength);
  proposal.setRelevance(IRelevanceRule.DEFAULT.getRelevance(fullyQualifiedName,allTypesInUnit,accessibility,modifiers));
  proposal.setSignature(CompletionEngine.createNonGenericTypeSignature(packageName,simpleTypeName));
  proposal.setTokenRange(offset,context.completionLocation);
  proposal.setTypeName(simpleTypeName);
  LazyJavaTypeCompletionProposal javaProposal=new LazyJavaTypeCompletionProposal(proposal,javaContext);
  javaProposal.setTriggerCharacters(ProposalUtils.TYPE_TRIGGERS);
  javaProposal.setRelevance(proposal.getRelevance());
  ImportRewrite r=groovyRewriter.getImportRewrite(monitor);
  if (r != null) {
    ReflectionUtils.setPrivateField(LazyJavaTypeCompletionProposal.class,""String_Node_Str"",javaProposal,r);
  }
  return javaProposal;
}",0.9485753995830438
185543,"List<ICompletionProposal> processAcceptedPackages(){
  checkCancel();
  List<ICompletionProposal> proposals=new LinkedList<ICompletionProposal>();
  if (acceptedPackages != null && acceptedPackages.size() > 0) {
    for (    String packageNameStr : acceptedPackages) {
      char[] packageName=packageNameStr.toCharArray();
      GroovyCompletionProposal proposal=createProposal(CompletionProposal.PACKAGE_REF,context.completionLocation);
      proposal.setDeclarationSignature(packageName);
      proposal.setPackageName(packageName);
      proposal.setCompletion(packageName);
      proposal.setReplaceRange(offset,context.completionLocation);
      proposal.setTokenRange(offset,context.completionLocation);
      proposal.setRelevance(Relevance.LOWEST.getRelevance());
      LazyJavaCompletionProposal javaProposal=new LazyJavaCompletionProposal(proposal,javaContext);
      proposals.add(javaProposal);
      javaProposal.setRelevance(proposal.getRelevance());
    }
  }
  return proposals;
}","List<ICompletionProposal> processAcceptedPackages(){
  checkCancel();
  List<ICompletionProposal> proposals=new LinkedList<ICompletionProposal>();
  if (acceptedPackages != null && acceptedPackages.size() > 0) {
    for (    String packageNameStr : acceptedPackages) {
      char[] packageName=packageNameStr.toCharArray();
      GroovyCompletionProposal proposal=createProposal(CompletionProposal.PACKAGE_REF,context.completionLocation);
      proposal.setDeclarationSignature(packageName);
      proposal.setPackageName(packageName);
      proposal.setCompletion(packageName);
      proposal.setReplaceRange(offset,context.completionLocation);
      proposal.setTokenRange(offset,context.completionLocation);
      proposal.setRelevance(Relevance.LOWEST.getRelevance());
      LazyJavaCompletionProposal javaProposal=new LazyJavaCompletionProposal(proposal,javaContext);
      javaProposal.setTriggerCharacters(ProposalUtils.TYPE_TRIGGERS);
      javaProposal.setRelevance(proposal.getRelevance());
      proposals.add(javaProposal);
    }
  }
  return proposals;
}",0.9098837209302324
185544,"private ICompletionProposal createProposal(String replaceName,ClassNode type){
  CompletionProposal proposal=CompletionProposal.create(CompletionProposal.LOCAL_VARIABLE_REF,offset);
  proposal.setCompletion(replaceName.toCharArray());
  proposal.setReplaceRange(offset - replaceLength,getContext().completionEnd);
  proposal.setSignature(ProposalUtils.createTypeSignature(type));
  proposal.setRelevance(Relevance.HIGH.getRelevance());
  LazyJavaCompletionProposal completion=new LazyJavaCompletionProposal(proposal,getJavaContext());
  completion.setRelevance(proposal.getRelevance());
  return completion;
}","private ICompletionProposal createProposal(String replaceName,ClassNode type){
  CompletionProposal proposal=CompletionProposal.create(CompletionProposal.LOCAL_VARIABLE_REF,offset);
  proposal.setCompletion(replaceName.toCharArray());
  proposal.setReplaceRange(offset - replaceLength,getContext().completionEnd);
  proposal.setSignature(ProposalUtils.createTypeSignature(type));
  proposal.setRelevance(Relevance.HIGH.getRelevance());
  LazyJavaCompletionProposal javaProposal=new LazyJavaCompletionProposal(proposal,getJavaContext());
  javaProposal.setTriggerCharacters(ProposalUtils.VAR_TRIGGER);
  javaProposal.setRelevance(proposal.getRelevance());
  return javaProposal;
}",0.8990683229813664
185545,"/** 
 * Looks for the named member in the declaring type. Also searches super types. The result can be a field, method, or property.
 * @param name the name of the field, method, constant or property to find
 * @param declaringType the type in which the named member's declaration resides
 * @param isLhsExpression {@code true} if named member is being assigned a value
 * @param isStaticExpression {@code true} if member is being accessed statically
 * @param directFieldAccess {@code false} if accessor methods may take precedence
 * @param methodCallArgumentTypes types of arguments to the associated method call(or  {@code null} if not a method call)
 */
protected ASTNode findDeclaration(String name,ClassNode declaringType,boolean isLhsExpression,boolean isStaticExpression,boolean directFieldAccess,List<ClassNode> methodCallArgumentTypes){
  if (declaringType.isArray()) {
    if (name.equals(""String_Node_Str"")) {
      return createLengthField(declaringType);
    }
    return findDeclaration(name,VariableScope.OBJECT_CLASS_NODE,isLhsExpression,isStaticExpression,directFieldAccess,methodCallArgumentTypes);
  }
  if (methodCallArgumentTypes != null) {
    ASTNode method=findMethodDeclaration(name,declaringType,methodCallArgumentTypes);
    if (method != null) {
      return method;
    }
  }
  MethodNode accessor=AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false,!isLhsExpression ? READER : WRITER);
  if (accessor != null && !isSynthetic(accessor) && (accessor.isStatic() == isStaticExpression) && !(directFieldAccess && declaringType.equals(accessor.getDeclaringClass()))) {
    return accessor;
  }
  LinkedHashSet<ClassNode> typeHierarchy=new LinkedHashSet<ClassNode>();
  VariableScope.createTypeHierarchy(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    PropertyNode property=type.getProperty(name);
    if (isCompatible(property,isStaticExpression)) {
      return property;
    }
  }
  FieldNode field=declaringType.getField(name);
  if (isCompatible(field,isStaticExpression)) {
    return field;
  }
  typeHierarchy.clear();
  VariableScope.findAllInterfaces(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    if (type == declaringType) {
      continue;
    }
    field=type.getField(name);
    if (field != null && field.isFinal() && field.isStatic()) {
      return field;
    }
  }
  if (isCompatible(accessor,isStaticExpression)) {
    return accessor;
  }
  if (methodCallArgumentTypes == null) {
    return findMethodDeclaration(name,declaringType,null);
  }
  return null;
}","/** 
 * Looks for the named member in the declaring type. Also searches super types. The result can be a field, method, or property.
 * @param name the name of the field, method, constant or property to find
 * @param declaringType the type in which the named member's declaration resides
 * @param isLhsExpression {@code true} if named member is being assigned a value
 * @param isStaticExpression {@code true} if member is being accessed statically
 * @param directFieldAccess {@code false} if accessor methods may take precedence
 * @param methodCallArgumentTypes types of arguments to the associated method call(or  {@code null} if not a method call)
 */
protected ASTNode findDeclaration(String name,ClassNode declaringType,boolean isLhsExpression,boolean isStaticExpression,boolean directFieldAccess,List<ClassNode> methodCallArgumentTypes){
  if (declaringType.isArray()) {
    if (name.equals(""String_Node_Str"")) {
      return createLengthField(declaringType);
    }
    return findDeclaration(name,VariableScope.OBJECT_CLASS_NODE,isLhsExpression,isStaticExpression,directFieldAccess,methodCallArgumentTypes);
  }
  if (methodCallArgumentTypes != null) {
    ASTNode method=findMethodDeclaration(name,declaringType,methodCallArgumentTypes);
    if (method != null) {
      return method;
    }
  }
  MethodNode accessor=AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false,!isLhsExpression ? READER : WRITER);
  if (accessor != null && !isSynthetic(accessor) && (accessor.isStatic() == isStaticExpression) && !(directFieldAccess && declaringType.equals(accessor.getDeclaringClass()))) {
    return accessor;
  }
  LinkedHashSet<ClassNode> typeHierarchy=new LinkedHashSet<ClassNode>();
  VariableScope.createTypeHierarchy(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    PropertyNode property=type.getProperty(name);
    if (isCompatible(property,isStaticExpression)) {
      return property;
    }
  }
  FieldNode field=declaringType.getField(name);
  if (isCompatible(field,isStaticExpression)) {
    return field;
  }
  typeHierarchy.clear();
  VariableScope.findAllInterfaces(declaringType,typeHierarchy,true);
  for (  ClassNode type : typeHierarchy) {
    if (type == declaringType) {
      continue;
    }
    field=type.getField(name);
    if (field != null && field.isFinal() && field.isStatic()) {
      return field;
    }
  }
  if (isCompatible(accessor,isStaticExpression)) {
    return accessor;
  }
  if (declaringType instanceof InnerClassNode && (declaringType.getModifiers() & ClassNode.ACC_STATIC) == 0) {
    ASTNode declaration=findDeclaration(name,((InnerClassNode)declaringType).getOuterClass(),isLhsExpression,isStaticExpression,directFieldAccess,methodCallArgumentTypes);
    if (declaration != null) {
      return declaration;
    }
  }
  if (methodCallArgumentTypes == null) {
    return findMethodDeclaration(name,declaringType,null);
  }
  return null;
}",0.9278499278499278
185546,"private void assertNoUnknowns(String contents){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",contents);
  TypeInferencingVisitorWithRequestor visitor=factory.createVisitor(unit);
  visitor.DEBUG=true;
  UnknownTypeRequestor requestor=new UnknownTypeRequestor();
  visitor.visitCompilationUnit(requestor);
  List<ASTNode> unknownNodes=requestor.getUnknownNodes();
  assertTrue(""String_Node_Str"" + unknownNodes,unknownNodes.isEmpty());
}","private void assertNoUnknowns(String source){
  GroovyCompilationUnit unit=createUnit(""String_Node_Str"",source);
  TypeInferencingVisitorWithRequestor visitor=factory.createVisitor(unit);
  visitor.DEBUG=true;
  UnknownTypeRequestor requestor=new UnknownTypeRequestor();
  visitor.visitCompilationUnit(requestor);
  List<ASTNode> unknownNodes=requestor.getUnknownNodes();
  assertTrue(""String_Node_Str"" + unknownNodes,unknownNodes.isEmpty());
}",0.968609865470852
185547,"@Test public void testFieldAndPropertyWithSameName(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  createJavaUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  int start=contents.lastIndexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","@Test public void testFieldAndPropertyWithSameName(){
  createJavaUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  createJavaUnit(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  String contents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertExprType(contents,""String_Node_Str"",""String_Node_Str"");
}",0.8813247470101196
185548,"private List<ClassNode> getMethodCallArgumentTypes(ASTNode node){
  Expression arguments=null;
  if (node instanceof MethodCallExpression) {
    arguments=((MethodCallExpression)node).getArguments();
  }
 else   if (node instanceof ConstructorCallExpression) {
    arguments=((ConstructorCallExpression)node).getArguments();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    arguments=((StaticMethodCallExpression)node).getArguments();
  }
  if (arguments != null) {
    if (arguments instanceof ArgumentListExpression) {
      List<Expression> expressions=((ArgumentListExpression)arguments).getExpressions();
      if (!expressions.isEmpty()) {
        List<ClassNode> types=new ArrayList<ClassNode>(expressions.size());
        for (        Expression expression : expressions) {
          if (expression instanceof ConstantExpression && ((ConstantExpression)expression).isNullExpression()) {
            types.add(VariableScope.NULL_TYPE);
          }
 else {
            scopes.getLast().setMethodCallArgumentTypes(getMethodCallArgumentTypes(expression));
            TypeLookupResult tlr=lookupExpressionType(expression,null,false,scopes.getLast());
            types.add(tlr.type);
          }
        }
        return types;
      }
    }
    return Collections.emptyList();
  }
  return null;
}","private List<ClassNode> getMethodCallArgumentTypes(ASTNode node){
  Expression arguments=null;
  if (node instanceof MethodCallExpression) {
    arguments=((MethodCallExpression)node).getArguments();
  }
 else   if (node instanceof ConstructorCallExpression) {
    arguments=((ConstructorCallExpression)node).getArguments();
  }
 else   if (node instanceof StaticMethodCallExpression) {
    arguments=((StaticMethodCallExpression)node).getArguments();
  }
  if (arguments != null) {
    if (arguments instanceof ArgumentListExpression) {
      List<Expression> expressions=((ArgumentListExpression)arguments).getExpressions();
      if (!expressions.isEmpty()) {
        List<ClassNode> types=new ArrayList<ClassNode>(expressions.size());
        for (        Expression expression : expressions) {
          if (expression instanceof ConstantExpression && ((ConstantExpression)expression).isNullExpression()) {
            types.add(VariableScope.NULL_TYPE);
          }
 else {
            scopes.getLast().setMethodCallArgumentTypes(getMethodCallArgumentTypes(expression));
            TypeLookupResult tlr;
            if (!(expression instanceof MethodCallExpression)) {
              tlr=lookupExpressionType(expression,null,false,scopes.getLast());
            }
 else {
              MethodCallExpression call=(MethodCallExpression)expression;
              tlr=lookupExpressionType(call.getObjectExpression(),null,false,scopes.getLast());
              tlr=lookupExpressionType(call.getMethod(),tlr.type,call.getObjectExpression() instanceof ClassExpression,scopes.getLast());
            }
            types.add(tlr.type);
          }
        }
        return types;
      }
    }
    return Collections.emptyList();
  }
  return null;
}",0.8604044357469015
185549,"protected boolean isCompatibleCategoryMethod(MethodNode method,ClassNode firstArgumentType){
  if (method.isStatic()) {
    Parameter[] paramters=method.getParameters();
    if (paramters != null && paramters.length > 0 && SimpleTypeLookup.isTypeCompatible(firstArgumentType,paramters[0].getType()) != Boolean.FALSE) {
      return true;
    }
  }
  return false;
}","protected boolean isCompatibleCategoryMethod(MethodNode method,ClassNode firstArgumentType){
  if (method.isStatic()) {
    Parameter[] paramters=method.getParameters();
    if (paramters != null && paramters.length > 0) {
      ClassNode parameterType=paramters[0].getType();
      if (VariableScope.DGSM_CLASS_NODE.equals(method.getDeclaringClass())) {
        parameterType=VariableScope.newClassClassNode(parameterType);
      }
      if (isTypeCompatible(firstArgumentType,parameterType)) {
        return true;
      }
    }
  }
  return false;
}",0.6390403489640131
185550,"protected boolean isDefaultGroovyMethod(MethodNode method){
  return VariableScope.ALL_DEFAULT_CATEGORIES.contains(method.getDeclaringClass());
}","protected final boolean isDefaultGroovyMethod(MethodNode method){
  return VariableScope.ALL_DEFAULT_CATEGORIES.contains(method.getDeclaringClass());
}",0.9797297297297296
185551,"private void setCompletionToken(char[][] tokens,int sourceStart,int sourceEnd,long[] sourcePositions){
  setCompletionToken(tokens,sourceStart,sourceEnd,sourcePositions,true);
}","private void setCompletionToken(char[][] tokens,int sourceStart,int sourceEnd,long[] sourcePositions){
  setCompletionToken(tokens,sourceStart,sourceEnd,sourcePositions,tokens.length > 0 && tokens[tokens.length - 1].length > 0);
}",0.855036855036855
185552,"synchronized IPackageBinding getPackageBinding(org.eclipse.jdt.internal.compiler.lookup.PackageBinding packageBinding){
  if (packageBinding == null) {
    return null;
  }
  IPackageBinding binding=(IPackageBinding)this.bindingTables.compilerBindingsToASTBindings.get(packageBinding);
  if (binding != null) {
    return binding;
  }
  binding=new PackageBinding(packageBinding,this);
  this.bindingTables.compilerBindingsToASTBindings.put(packageBinding,binding);
  return binding;
}","synchronized IPackageBinding getPackageBinding(org.eclipse.jdt.internal.compiler.lookup.PackageBinding packageBinding){
  if (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {
    return null;
  }
  IPackageBinding binding=(IPackageBinding)this.bindingTables.compilerBindingsToASTBindings.get(packageBinding);
  if (binding != null) {
    return binding;
  }
  binding=new PackageBinding(packageBinding,this);
  this.bindingTables.compilerBindingsToASTBindings.put(packageBinding,binding);
  return binding;
}",0.950048971596474
185553,"@Override public void visitTernaryExpression(final TernaryExpression expression){
  Map<VariableExpression,List<ClassNode>> oldTracker=pushAssignmentTracking();
  pushTemporaryTypeInfo();
  expression.getBooleanExpression().visit(this);
  Expression trueExpression=expression.getTrueExpression();
  Expression falseExpression=expression.getFalseExpression();
  trueExpression.visit(this);
  temporaryIfBranchTypeInformation.pop();
  falseExpression.visit(this);
  ClassNode resultType;
  if (isNullConstant(trueExpression) || isNullConstant(falseExpression)) {
    if (currentBinaryExpression != null && currentBinaryExpression.getRightExpression() == expression) {
      resultType=getType(currentBinaryExpression.getLeftExpression());
    }
 else     if (isNullConstant(trueExpression) && isNullConstant(falseExpression)) {
      resultType=OBJECT_TYPE;
    }
 else     if (isNullConstant(trueExpression)) {
      resultType=wrapTypeIfNecessary(getType(falseExpression));
    }
 else {
      resultType=wrapTypeIfNecessary(getType(trueExpression));
    }
  }
 else {
    final ClassNode typeOfTrue=getType(trueExpression);
    final ClassNode typeOfFalse=getType(falseExpression);
    resultType=lowestUpperBound(typeOfTrue,typeOfFalse);
  }
  storeType(expression,resultType);
  popAssignmentTracking(oldTracker);
}","@Override public void visitTernaryExpression(final TernaryExpression expression){
  Map<VariableExpression,List<ClassNode>> oldTracker=pushAssignmentTracking();
  pushTemporaryTypeInfo();
  expression.getBooleanExpression().visit(this);
  Expression trueExpression=expression.getTrueExpression();
  Expression falseExpression=expression.getFalseExpression();
  trueExpression.visit(this);
  final ClassNode typeOfTrue=findCurrentInstanceOfClass(trueExpression,getType(trueExpression));
  temporaryIfBranchTypeInformation.pop();
  falseExpression.visit(this);
  ClassNode resultType;
  if (isNullConstant(trueExpression) || isNullConstant(falseExpression)) {
    if (currentBinaryExpression != null && currentBinaryExpression.getRightExpression() == expression) {
      resultType=getType(currentBinaryExpression.getLeftExpression());
    }
 else     if (isNullConstant(trueExpression) && isNullConstant(falseExpression)) {
      resultType=OBJECT_TYPE;
    }
 else     if (isNullConstant(trueExpression)) {
      resultType=wrapTypeIfNecessary(getType(falseExpression));
    }
 else {
      resultType=wrapTypeIfNecessary(getType(trueExpression));
    }
  }
 else {
    final ClassNode typeOfFalse=getType(falseExpression);
    resultType=lowestUpperBound(typeOfTrue,typeOfFalse);
  }
  storeType(expression,resultType);
  popAssignmentTracking(oldTracker);
}",0.942846469929025
185554,"/** 
 * Crude way to determine it... basically check for a folder called 'grails-app'.  The reason we need to know is because of the extra transform that will run if it is a grails-app (tagging domain classes).
 */
private static boolean isProbablyGrailsProject(IProject project){
  try {
    IFolder folder=project.getFolder(""String_Node_Str"");
    return folder.exists();
  }
 catch (  Exception e) {
    return false;
  }
}","/** 
 * Crude way to determine it... check for a folder called 'grails-app'. The reason we need to know is because of the extra transform that will run if it is a grails-app (tagging domain classes).
 */
private static boolean isProbablyGrailsProject(IProject project){
  try {
    IFolder folder=project.getFolder(""String_Node_Str"");
    return folder.exists();
  }
 catch (  Exception e) {
    return false;
  }
}",0.9869203329369798
185555,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  String classpath=null;
  IProject project=javaProject.getProject();
  String projectName=project.getName();
  try {
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null && (classpath=CLASSPATH_CACHE.get(cpes)) == null) {
      Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              Util.log(t,""String_Node_Str"");
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      String defaultOutputLocation=pathToString(javaProject.getOutputLocation(),project);
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        Util.log(e,""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      classpath=sb.toString();
      CLASSPATH_CACHE.put(cpes,classpath);
    }
  }
 catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + projectName + ""String_Node_Str"");
  }
  return classpath != null ? classpath : ""String_Node_Str"";
}",0.8373483383154563
185556,"private static String pathToString(IPath path,IProject project){
  String realLocation=null;
  if (path != null) {
    String prefix=path.segment(0);
    if (prefix.equals(project.getName())) {
      if (path.segmentCount() == 1) {
        IPath rawPath=project.getRawLocation();
        if (rawPath == null) {
          System.err.println(""String_Node_Str"" + project);
        }
 else {
          realLocation=project.getRawLocation().toOSString();
        }
      }
 else {
        IPath rawLocation=project.getFile(path.removeFirstSegments(1)).getRawLocation();
        if (rawLocation != null) {
          realLocation=rawLocation.toOSString();
        }
      }
    }
 else {
      realLocation=path.toOSString();
    }
  }
  return realLocation;
}","private static String pathToString(IPath path,IProject project){
  String realLocation=null;
  if (path != null) {
    String prefix=path.segment(0);
    if (prefix.equals(project.getName())) {
      if (path.segmentCount() == 1) {
        IPath rawPath=project.getRawLocation();
        if (rawPath == null) {
          Util.log(null,""String_Node_Str"" + project + ""String_Node_Str"");
        }
 else {
          realLocation=project.getRawLocation().toOSString();
        }
      }
 else {
        IPath rawLocation=project.getFile(path.removeFirstSegments(1)).getRawLocation();
        if (rawLocation != null) {
          realLocation=rawLocation.toOSString();
        }
      }
    }
 else {
      realLocation=path.toOSString();
    }
  }
  return realLocation;
}",0.965154503616042
185557,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  try {
    IProject project=javaProject.getProject();
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"");
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9725792630676948
185558,"public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      for (      String k : prb.keySet()) {
        String v=fixup(prb.getString(k),javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    Throwable t) {
      Util.log(t,""String_Node_Str"");
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      Util.log(t,""String_Node_Str"");
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    Util.log(t,""String_Node_Str"");
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.8025649679379008
185559,"/** 
 * https://github.com/groovy/groovy-eclipse/issues/174 java.lang.NullPointerException at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) at com.sun.beans.TypeResolver.resolve(TypeResolver.java:162) at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81) at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370) at java.beans.Introspector.getTargetEventInfo(Introspector.java:1052) at java.beans.Introspector.getBeanInfo(Introspector.java:427) at java.beans.Introspector.getBeanInfo(Introspector.java:173) at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290) at java.security.AccessController.doPrivileged(Native Method) at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288) at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3265) at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:254) at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285) at MIData.$getStaticMetaClass(MIData.groovy) at MIData.<init>(MIData.groovy) at Main.main(Main.groovy:3)
 */
@Test @Ignore public void testExtendingGenerics_GroovyExtendsJava14(){
  assumeTrue(isAtLeastGroovy(20));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources,""String_Node_Str"");
}","/** 
 * https://github.com/groovy/groovy-eclipse/issues/174 java.lang.NullPointerException at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) at com.sun.beans.TypeResolver.resolve(TypeResolver.java:162) at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81) at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370) at java.beans.Introspector.getTargetEventInfo(Introspector.java:1052) at java.beans.Introspector.getBeanInfo(Introspector.java:427) at java.beans.Introspector.getBeanInfo(Introspector.java:173) at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290) at java.security.AccessController.doPrivileged(Native Method) at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288) at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3265) at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:254) at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285) at MIData.$getStaticMetaClass(MIData.groovy) at MIData.<init>(MIData.groovy) at Main.main(Main.groovy:3)
 */
@Test public void testExtendingGenerics_GroovyExtendsJava14(){
  assumeTrue(isAtLeastGroovy(20));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources,""String_Node_Str"");
}",0.9976498237367802
185560,"private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,oldMethod.getReturnType().getPlainNodeReference(),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}","private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,GenericsUtils.nonGeneric(oldMethod.getReturnType()),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}",0.9932489451476794
185561,"private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,oldMethod.getReturnType().getPlainNodeReference(),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}","private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,GenericsUtils.nonGeneric(oldMethod.getReturnType()),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}",0.9932489451476794
185562,"private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,oldMethod.getReturnType().getPlainNodeReference(),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}","private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  if (equalReturnType && normalEqualParameters)   return null;
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ oldMethod.getTypeDescriptor()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else       if (oldM) {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,GenericsUtils.nonGeneric(oldMethod.getReturnType()),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()));
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}",0.9932489451476794
185563,"private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ testmr.getName()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (equalReturnType && normalEqualParameters)   return null;
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,oldMethod.getReturnType().getPlainNodeReference(),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()),false);
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}","private MethodNode getCovariantImplementation(final MethodNode oldMethod,final MethodNode overridingMethod,Map genericsSpec){
  if (!oldMethod.getName().equals(overridingMethod.getName()))   return null;
  if ((overridingMethod.getModifiers() & ACC_BRIDGE) != 0)   return null;
  boolean normalEqualParameters=equalParametersNormal(overridingMethod,oldMethod);
  boolean genericEqualParameters=equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
  if (!normalEqualParameters && !genericEqualParameters)   return null;
  ClassNode mr=overridingMethod.getReturnType();
  ClassNode omr=oldMethod.getReturnType();
  boolean equalReturnType=mr.equals(omr);
  ClassNode testmr=correctToGenericsSpec(genericsSpec,omr);
  if (!isAssignable(mr,testmr)) {
    throw new RuntimeParserException(""String_Node_Str"" + overridingMethod.getTypeDescriptor() + ""String_Node_Str""+ overridingMethod.getDeclaringClass().getName()+ ""String_Node_Str""+ testmr.getName()+ ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (equalReturnType && normalEqualParameters)   return null;
  if ((oldMethod.getModifiers() & ACC_FINAL) != 0) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName(),overridingMethod);
  }
  if (oldMethod.isStatic() != overridingMethod.isStatic()) {
    throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ ""String_Node_Str"",overridingMethod);
  }
  if (!equalReturnType) {
    boolean oldM=ClassHelper.isPrimitiveType(oldMethod.getReturnType());
    boolean newM=ClassHelper.isPrimitiveType(overridingMethod.getReturnType());
    if (oldM || newM) {
      String message=""String_Node_Str"";
      if (oldM && newM) {
        message=""String_Node_Str"";
      }
 else       if (newM) {
        message=""String_Node_Str"";
      }
 else {
        message=""String_Node_Str"";
      }
      throw new RuntimeParserException(""String_Node_Str"" + oldMethod.getTypeDescriptor() + ""String_Node_Str""+ oldMethod.getDeclaringClass().getName()+ message,overridingMethod);
    }
  }
  MethodNode newMethod=new MethodNode(oldMethod.getName(),overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,GenericsUtils.nonGeneric(oldMethod.getReturnType()),cleanParameters(oldMethod.getParameters()),oldMethod.getExceptions(),null);
  List instructions=new ArrayList(1);
  instructions.add(new BytecodeInstruction(){
    public void visit(    MethodVisitor mv){
      mv.visitVarInsn(ALOAD,0);
      Parameter[] para=oldMethod.getParameters();
      Parameter[] goal=overridingMethod.getParameters();
      int doubleSlotOffset=0;
      for (int i=0; i < para.length; i++) {
        ClassNode type=para[i].getType();
        BytecodeHelper.load(mv,type,i + 1 + doubleSlotOffset);
        if (type.redirect() == ClassHelper.double_TYPE || type.redirect() == ClassHelper.long_TYPE) {
          doubleSlotOffset++;
        }
        if (!type.equals(goal[i].getType())) {
          BytecodeHelper.doCast(mv,goal[i].getType());
        }
      }
      mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),overridingMethod.getName(),BytecodeHelper.getMethodDescriptor(overridingMethod.getReturnType(),overridingMethod.getParameters()),false);
      BytecodeHelper.doReturn(mv,oldMethod.getReturnType());
    }
  }
);
  newMethod.setCode(new BytecodeSequence(instructions));
  return newMethod;
}",0.9932049830124576
185564,"private void gatherParameters(ClassNode declaringType,boolean[] foundParameterNumbers){
  if (declaringType == null) {
    return;
  }
  declaringType=findWrappedNode(declaringType.redirect());
  List<MethodNode> methods=declaringType.getMethods(String.valueOf(name));
  for (  MethodNode method : methods) {
    method=method.getOriginal();
    foundParameterNumbers[Math.min(method.getParameters().length,MAX_PARAMS)]=true;
  }
  gatherParameters(declaringType.getSuperClass(),foundParameterNumbers);
  for (  ClassNode iface : declaringType.getInterfaces()) {
    gatherParameters(iface,foundParameterNumbers);
  }
}","private void gatherParameters(ClassNode declaringType,boolean[] foundParameterNumbers){
  if (declaringType == null) {
    return;
  }
  declaringType=findWrappedNode(declaringType.redirect());
  List<MethodNode> methods=declaringType.getMethods(name);
  for (  MethodNode method : methods) {
    method=method.getOriginal();
    foundParameterNumbers[Math.min(method.getParameters().length,MAX_PARAMS)]=true;
  }
  gatherParameters(declaringType.getSuperClass(),foundParameterNumbers);
  for (  ClassNode iface : declaringType.getInterfaces()) {
    gatherParameters(iface,foundParameterNumbers);
  }
}",0.9803600654664484
185565,"/** 
 * @return finds the number of parameters in the method reference/declaration currently being analyzed.
 */
private int findNumberOfParameters(ASTNode node,TypeLookupResult result){
  return node instanceof MethodNode && ((MethodNode)node).getParameters() != null ? ((MethodNode)node).getParameters().length : Math.max(0,result.scope.getMethodCallNumberOfArguments());
}","/** 
 * @return finds the number of parameters in the method reference/declaration currently being analyzed.
 */
private int findNumberOfParameters(ASTNode node,TypeLookupResult result){
  return (node instanceof MethodNode && ((MethodNode)node).getParameters() != null) ? ((MethodNode)node).getParameters().length : Math.max(0,result.scope.getMethodCallNumberOfArguments());
}",0.9973404255319148
185566,"/** 
 * Attempt to convert from a   {@link JDTClassNode} to a {@link ClassNode} in order to check default parameters
 */
private ClassNode findWrappedNode(ClassNode declaringType){
  ClassNode wrappedNode=null;
  if (declaringType instanceof JDTClassNode) {
    ReferenceBinding binding=((JDTClassNode)declaringType).getJdtBinding();
    if (binding instanceof SourceTypeBinding) {
      SourceTypeBinding sourceTypeBinding=(SourceTypeBinding)binding;
      if (sourceTypeBinding.scope != null) {
        TypeDeclaration typeDeclaration=sourceTypeBinding.scope.referenceContext;
        if (typeDeclaration instanceof GroovyTypeDeclaration) {
          GroovyTypeDeclaration groovyTypeDeclaration=(GroovyTypeDeclaration)typeDeclaration;
          wrappedNode=groovyTypeDeclaration.getClassNode();
        }
      }
    }
  }
  return wrappedNode == null ? declaringType : wrappedNode;
}","/** 
 * Converts from a   {@link JDTClassNode} to a {@link ClassNode} in order tocheck default parameters.
 */
private ClassNode findWrappedNode(ClassNode declaringType){
  ClassNode wrappedNode=null;
  if (declaringType instanceof JDTClassNode) {
    ReferenceBinding binding=((JDTClassNode)declaringType).getJdtBinding();
    if (binding instanceof SourceTypeBinding) {
      SourceTypeBinding sourceTypeBinding=(SourceTypeBinding)binding;
      if (sourceTypeBinding.scope != null) {
        TypeDeclaration typeDeclaration=sourceTypeBinding.scope.referenceContext;
        if (typeDeclaration instanceof GroovyTypeDeclaration) {
          GroovyTypeDeclaration groovyTypeDeclaration=(GroovyTypeDeclaration)typeDeclaration;
          wrappedNode=groovyTypeDeclaration.getClassNode();
        }
      }
    }
  }
  return wrappedNode == null ? declaringType : wrappedNode;
}",0.9909194097616344
185567,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  boolean doCheck=false;
  boolean isDeclaration=false;
  boolean isConstructorCall=false;
  int start=0;
  int end=0;
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  if (node instanceof ConstantExpression) {
    String cName=((ConstantExpression)node).getText();
    if (cName != null && CharOperation.equals(name,cName.toCharArray())) {
      start=node.getStart();
      end=node.getEnd();
      doCheck=end > 0;
    }
  }
 else   if (node instanceof FieldExpression) {
    if (CharOperation.equals(name,((FieldExpression)node).getFieldName().toCharArray())) {
      start=node.getStart();
      end=node.getEnd();
      doCheck=end > 0;
    }
  }
 else   if (node instanceof MethodNode) {
    MethodNode mnode=(MethodNode)node;
    if (CharOperation.equals(name,mnode.getName().toCharArray())) {
      isDeclaration=true;
      start=mnode.getNameStart();
      end=mnode.getNameEnd() + 1;
      doCheck=true;
    }
  }
 else   if (node instanceof VariableExpression) {
    VariableExpression vnode=(VariableExpression)node;
    if (CharOperation.equals(name,vnode.getName().toCharArray())) {
      start=vnode.getStart();
      end=start + vnode.getName().length();
      doCheck=true;
    }
  }
 else   if (node instanceof StaticMethodCallExpression) {
    StaticMethodCallExpression smnode=(StaticMethodCallExpression)node;
    if (CharOperation.equals(name,smnode.getMethod().toCharArray())) {
      start=smnode.getStart();
      end=start + name.length;
      doCheck=true;
    }
  }
  if (doCheck && end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      int numberOfParameters=findNumberOfParameters(node,result);
      boolean isCompleteMatch=nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),numberOfParameters);
      if (isCompleteMatch) {
        IJavaElement realElement=enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy ? ((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement) : enclosingElement;
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,realElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,isConstructorCall,false,false,false,participant,realElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + realElement + ""String_Node_Str""+ realElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (result.declaringType == null) {
    return VisitStatus.CONTINUE;
  }
  boolean doCheck=false;
  boolean isDeclaration=false;
  boolean isConstructorCall=false;
  int start=0;
  int end=0;
  if (node instanceof ConstantExpression) {
    String cName=((ConstantExpression)node).getText();
    if (name.equals(cName)) {
      start=node.getStart();
      end=node.getEnd();
      doCheck=end > 0;
    }
  }
 else   if (node instanceof FieldExpression) {
    if (name.equals(((FieldExpression)node).getFieldName())) {
      start=node.getStart();
      end=node.getEnd();
      doCheck=end > 0;
    }
  }
 else   if (node instanceof MethodNode) {
    MethodNode mnode=(MethodNode)node;
    if (name.equals(mnode.getName())) {
      isDeclaration=true;
      start=mnode.getNameStart();
      end=mnode.getNameEnd() + 1;
      doCheck=true;
    }
  }
 else   if (node instanceof VariableExpression) {
    VariableExpression vnode=(VariableExpression)node;
    if (name.equals(vnode.getName())) {
      start=vnode.getStart();
      end=start + vnode.getName().length();
      doCheck=true;
    }
  }
 else   if (node instanceof StaticMethodCallExpression) {
    StaticMethodCallExpression smnode=(StaticMethodCallExpression)node;
    if (name.equals(smnode.getMethod())) {
      start=smnode.getStart();
      end=start + name.length();
      doCheck=true;
    }
  }
  if (doCheck && end > 0) {
    Position position=new Position(start,end - start);
    if (!acceptedPositions.contains(position)) {
      int numberOfParameters=findNumberOfParameters(node,result);
      boolean isCompleteMatch=nameAndArgsMatch(GroovyUtils.getBaseType(result.declaringType),numberOfParameters);
      if (isCompleteMatch) {
        IJavaElement realElement=enclosingElement.getOpenable() instanceof GroovyClassFileWorkingCopy ? ((GroovyClassFileWorkingCopy)enclosingElement.getOpenable()).convertToBinary(enclosingElement) : enclosingElement;
        SearchMatch match=null;
        if (isDeclaration && findDeclarations) {
          match=new MethodDeclarationMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,participant,realElement.getResource());
        }
 else         if (!isDeclaration && findReferences) {
          match=new MethodReferenceMatch(realElement,getAccuracy(result.confidence,isCompleteMatch),start,end - start,isConstructorCall,false,false,false,participant,realElement.getResource());
        }
        if (match != null) {
          try {
            requestor.acceptSearchMatch(match);
            acceptedPositions.add(position);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + realElement + ""String_Node_Str""+ realElement.getResource());
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.8669239805336466
185568,"/** 
 * check to see if this requestor has something to do with refactoring, if so, we always want an accurate match otherwise we get complaints in the refactoring wizard of ""possible matches""
 */
private boolean shouldAlwaysBeAccurate(){
  return requestor.getClass().getPackage().getName().indexOf(""String_Node_Str"") != -1;
}","/** 
 * Checks to see if this requestor has something to do with refactoring, if so, we always want an accurate match otherwise we get complaints in the refactoring wizard of ""possible matches""
 */
private boolean shouldAlwaysBeAccurate(){
  return requestor.getClass().getPackage().getName().indexOf(""String_Node_Str"") != -1;
}",0.9954198473282444
185569,"public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  name=(char[])ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] arr=(char[])ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  String declaringSimpleName=arr == null ? ""String_Node_Str"" : new String(arr);
  arr=(char[])ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  String declaringQualification=((arr == null || arr.length == 0) ? ""String_Node_Str"" : (new String(arr) + ""String_Node_Str""));
  declaringQualifiedName=declaringQualification + declaringSimpleName;
  findDeclarations=((Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern)).booleanValue();
  findReferences=((Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern)).booleanValue();
  parameterQualifications=pattern.parameterQualifications;
  parameterSimpleNames=pattern.parameterSimpleNames;
  declaredParameterCount=pattern.parameterSimpleNames == null ? 0 : pattern.parameterSimpleNames.length;
}","public MethodReferenceSearchRequestor(MethodPattern pattern,SearchRequestor requestor,SearchParticipant participant){
  this.requestor=requestor;
  this.participant=participant;
  name=String.valueOf(pattern.selector);
  parameterSimpleNames=pattern.parameterSimpleNames;
  parameterQualifications=pattern.parameterQualifications;
  declaredParameterCount=parameterSimpleNames == null ? 0 : parameterSimpleNames.length;
  IType declaringType=(IType)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern);
  char[] declaringQualifiedName=null;
  try {
    if (pattern.focus instanceof IMethod && supportsOverride((IMethod)pattern.focus)) {
      LinkedList<IMethod> methods=new LinkedList<IMethod>();
      if (declaringType == null)       declaringType=((IMethod)pattern.focus).getDeclaringType();
      for (      IType superType : declaringType.newSupertypeHierarchy(null).getAllSupertypes(declaringType)) {
        next:         for (        IMethod superMeth : superType.getMethods()) {
          if (supportsOverride(superMeth) && superMeth.getElementName().equals(name)) {
            String[] paramTypes=superMeth.getParameterTypes();
            if (paramTypes.length == declaredParameterCount) {
              for (int i=0; i < declaredParameterCount; i+=1) {
                if (!equal(parameterSimpleNames[i],Signature.getSimpleName(Signature.toString(paramTypes[i])))) {
                  continue next;
                }
              }
              methods.add(superMeth);
            }
          }
        }
      }
      if (!methods.isEmpty()) {
        IType decl=methods.getLast().getDeclaringType();
        char[] superTypeName=decl.getElementName().toCharArray();
        char[] packageName=decl.getPackageFragment().getElementName().toCharArray();
        declaringQualifiedName=CharOperation.concat(packageName,superTypeName,'.');
      }
    }
  }
 catch (  Exception e) {
    Util.log(e);
  }
  if (declaringQualifiedName == null) {
    declaringQualifiedName=CharOperation.concat(pattern.declaringQualification,pattern.declaringSimpleName,'.');
    if (declaringQualifiedName == null) {
      if (declaringType != null) {
        declaringQualifiedName=CharOperation.concat(pattern.declaringPackageName,declaringType.getElementName().toCharArray(),'.');
      }
 else {
        declaringQualifiedName=CharOperation.NO_CHAR;
      }
    }
  }
  this.declaringQualifiedName=String.valueOf(declaringQualifiedName);
  findDeclarations=((Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern)).booleanValue();
  findReferences=((Boolean)ReflectionUtils.getPrivateField(MethodPattern.class,""String_Node_Str"",pattern)).booleanValue();
}",0.2251655629139073
185570,"/** 
 * When matching method references and declarations, we can't actually match on parameter types. Instead, we match on the number of parameterrs and assume that it is slightly more preceise than just matching on name. The heuristic that is used in this method is this: <ol> <li>The search pattern expects 'n' parameters <li>the current node has 'm' arguments. <li>if the m == n, then there is a precise match. <li>if not, look at all methods in current type with same name. <li>if there is a method in the current type with the same number of arguments, then assume the current node matches that other method, and there is no match. <li>If there are no existing methods with same number of parameters, then assume that current method call is an alternative way of calling the method and return a match </ol>
 * @param declaringType
 * @param currentCallCount
 * @return true if there is a precise match between number of arguments and numner of parameters. false if there exists adifferent method with same number of arguments in current type, or true otherwise
 */
private boolean matchOnNumberOfParameters(ClassNode declaringType,int currentCallCount){
  boolean methodParamNumberMatch;
  if (currentCallCount == declaredParameterCount) {
    methodParamNumberMatch=true;
  }
 else {
    boolean[] foundParameterNumbers=cachedParameterCounts.get(declaringType);
    if (foundParameterNumbers == null) {
      foundParameterNumbers=new boolean[MAX_PARAMS + 1];
      gatherParameters(declaringType,foundParameterNumbers);
      cachedParameterCounts.put(declaringType,foundParameterNumbers);
    }
    methodParamNumberMatch=!foundParameterNumbers[Math.min(MAX_PARAMS,currentCallCount)];
  }
  return methodParamNumberMatch;
}","/** 
 * When matching method references and declarations, we can't actually match on parameter types. Instead, we match on the number of parameterrs and assume that it is slightly more preceise than just matching on name. The heuristic that is used in this method is this: <ol> <li>The search pattern expects 'n' parameters <li>the current node has 'm' arguments. <li>if the m == n, then there is a precise match. <li>if not, look at all methods in current type with same name. <li>if there is a method in the current type with the same number of arguments, then assume the current node matches that other method, and there is no match. <li>If there are no existing methods with same number of parameters, then assume that current method call is an alternative way of calling the method and return a match </ol>
 * @return true if there is a precise match between number of arguments andnumner of parameters. false if there exists a different method with same number of arguments in current type, or true otherwise
 */
private boolean matchOnNumberOfParameters(ClassNode declaringType,int currentCallCount){
  boolean methodParamNumberMatch;
  if (currentCallCount == declaredParameterCount) {
    methodParamNumberMatch=true;
  }
 else {
    boolean[] foundParameterNumbers=cachedParameterCounts.get(declaringType);
    if (foundParameterNumbers == null) {
      foundParameterNumbers=new boolean[MAX_PARAMS + 1];
      gatherParameters(declaringType,foundParameterNumbers);
      cachedParameterCounts.put(declaringType,foundParameterNumbers);
    }
    methodParamNumberMatch=!foundParameterNumbers[Math.min(MAX_PARAMS,currentCallCount)];
  }
  return methodParamNumberMatch;
}",0.9434183523893288
185571,"private boolean matchOnName(ClassNode declaringType){
  if (declaringType == null) {
    return false;
  }
  String declaringTypeName=declaringType.getName();
  if ((declaringTypeName.equals(""String_Node_Str"") && declaringType.getDeclaredMethods(String.valueOf(name)).size() == 0)) {
    return false;
  }
  if (declaringQualifiedName == null || declaringQualifiedName.equals(""String_Node_Str"")) {
    return true;
  }
  declaringTypeName=declaringTypeName.replace('$','.');
  Boolean maybeMatch=cachedDeclaringNameMatches.get(declaringType);
  if (maybeMatch != null) {
    return maybeMatch;
  }
  if (declaringTypeName.equals(declaringQualifiedName)) {
    cachedDeclaringNameMatches.put(declaringType,true);
    return true;
  }
 else {
    maybeMatch=matchOnName(declaringType.getSuperClass());
    if (!maybeMatch) {
      for (      ClassNode iface : declaringType.getInterfaces()) {
        maybeMatch=matchOnName(iface);
        if (maybeMatch) {
          break;
        }
      }
    }
    cachedDeclaringNameMatches.put(declaringType,maybeMatch);
    return maybeMatch;
  }
}","private boolean matchOnName(ClassNode declaringType){
  if (declaringType == null) {
    return false;
  }
  String declaringTypeName=declaringType.getName();
  if (declaringTypeName.equals(""String_Node_Str"") && declaringType.getDeclaredMethods(name).isEmpty()) {
    return false;
  }
  if (declaringQualifiedName == null || declaringQualifiedName.equals(""String_Node_Str"")) {
    return true;
  }
  declaringTypeName=declaringTypeName.replace('$','.');
  Boolean maybeMatch=cachedDeclaringNameMatches.get(declaringType);
  if (maybeMatch != null) {
    return maybeMatch;
  }
  if (declaringTypeName.equals(declaringQualifiedName)) {
    cachedDeclaringNameMatches.put(declaringType,true);
    return true;
  }
 else {
    maybeMatch=matchOnName(declaringType.getSuperClass());
    if (!maybeMatch) {
      for (      ClassNode iface : declaringType.getInterfaces()) {
        maybeMatch=matchOnName(iface);
        if (maybeMatch) {
          break;
        }
      }
    }
    cachedDeclaringNameMatches.put(declaringType,maybeMatch);
    return maybeMatch;
  }
}",0.977715877437326
185572,"void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  int index=defaultImports.length;
  ImportBinding[] resolvedImports=new ImportBinding[numberOfImports + index - 1];
  System.arraycopy(defaultImports,0,resolvedImports,0,index);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < index; j++) {
      ImportBinding resolved=resolvedImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      resolvedImports[index++]=new ImportBinding(compoundName,true,importBinding,importReference);
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          recordImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      ReferenceBinding conflictingType=null;
      if (importBinding instanceof MethodBinding) {
        conflictingType=(ReferenceBinding)getType(compoundName,compoundName.length);
        if (!conflictingType.isValidBinding() || (importReference.isStatic() && !conflictingType.isStatic()))         conflictingType=null;
      }
      if (importBinding instanceof ReferenceBinding || conflictingType != null) {
        ReferenceBinding referenceBinding=conflictingType == null ? (ReferenceBinding)importBinding : conflictingType;
        ReferenceBinding typeToCheck=referenceBinding.problemId() == ProblemReasons.Ambiguous ? ((ProblemReferenceBinding)referenceBinding).closestMatch : referenceBinding;
        if (importReference.isTypeUseDeprecated(typeToCheck,this))         problemReporter().deprecatedType(typeToCheck,importReference);
        ReferenceBinding existingType=typesBySimpleNames.get(importReference.getSimpleName());
        if (existingType != null) {
          if (existingType == referenceBinding) {
            for (int j=0; j < index; j++) {
              ImportBinding resolved=resolvedImports[j];
              if (resolved instanceof ImportConflictBinding) {
                ImportConflictBinding importConflictBinding=(ImportConflictBinding)resolved;
                if (importConflictBinding.conflictingTypeBinding == referenceBinding) {
                  if (!importReference.isStatic()) {
                    problemReporter().duplicateImport(importReference);
                    resolvedImports[index++]=new ImportBinding(compoundName,false,importBinding,importReference);
                  }
                }
              }
 else               if (resolved.resolvedImport == referenceBinding) {
                if (importReference.isStatic() != resolved.isStatic()) {
                  problemReporter().duplicateImport(importReference);
                  resolvedImports[index++]=new ImportBinding(compoundName,false,importBinding,importReference);
                }
              }
            }
            continue nextImport;
          }
          for (int j=0, length=this.topLevelTypes.length; j < length; j++) {
            if (CharOperation.equals(this.topLevelTypes[j].sourceName,existingType.sourceName)) {
              problemReporter().conflictingImport(importReference);
              continue nextImport;
            }
          }
          problemReporter().duplicateImport(importReference);
          continue nextImport;
        }
        typesBySimpleNames.put(importReference.getSimpleName(),referenceBinding);
      }
 else       if (importBinding instanceof FieldBinding) {
        for (int j=0; j < index; j++) {
          ImportBinding resolved=resolvedImports[j];
          if (resolved.isStatic() && resolved.resolvedImport instanceof FieldBinding && importBinding != resolved.resolvedImport) {
            if (CharOperation.equals(compoundName[compoundName.length - 1],resolved.compoundName[resolved.compoundName.length - 1])) {
              problemReporter().duplicateImport(importReference);
              continue nextImport;
            }
          }
        }
      }
      resolvedImports[index++]=conflictingType == null ? new ImportBinding(compoundName,false,importBinding,importReference) : new ImportConflictBinding(compoundName,importBinding,conflictingType,importReference);
    }
  }
  if (resolvedImports.length > index)   System.arraycopy(resolvedImports,0,resolvedImports=new ImportBinding[index],0,index);
  this.imports=resolvedImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}","void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  int index=defaultImports.length;
  ImportBinding[] resolvedImports=new ImportBinding[numberOfImports + index - 1];
  System.arraycopy(defaultImports,0,resolvedImports,0,index);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < index; j++) {
      ImportBinding resolved=resolvedImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      resolvedImports[index++]=new ImportBinding(compoundName,true,importBinding,importReference);
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          reportImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      ReferenceBinding conflictingType=null;
      if (importBinding instanceof MethodBinding) {
        conflictingType=(ReferenceBinding)getType(compoundName,compoundName.length);
        if (!conflictingType.isValidBinding() || (importReference.isStatic() && !conflictingType.isStatic()))         conflictingType=null;
      }
      if (importBinding instanceof ReferenceBinding || conflictingType != null) {
        ReferenceBinding referenceBinding=conflictingType == null ? (ReferenceBinding)importBinding : conflictingType;
        ReferenceBinding typeToCheck=referenceBinding.problemId() == ProblemReasons.Ambiguous ? ((ProblemReferenceBinding)referenceBinding).closestMatch : referenceBinding;
        if (importReference.isTypeUseDeprecated(typeToCheck,this))         problemReporter().deprecatedType(typeToCheck,importReference);
        ReferenceBinding existingType=typesBySimpleNames.get(importReference.getSimpleName());
        if (existingType != null) {
          if (existingType == referenceBinding) {
            for (int j=0; j < index; j++) {
              ImportBinding resolved=resolvedImports[j];
              if (resolved instanceof ImportConflictBinding) {
                ImportConflictBinding importConflictBinding=(ImportConflictBinding)resolved;
                if (importConflictBinding.conflictingTypeBinding == referenceBinding) {
                  if (!importReference.isStatic()) {
                    problemReporter().duplicateImport(importReference);
                    resolvedImports[index++]=new ImportBinding(compoundName,false,importBinding,importReference);
                  }
                }
              }
 else               if (resolved.resolvedImport == referenceBinding) {
                if (importReference.isStatic() != resolved.isStatic()) {
                  problemReporter().duplicateImport(importReference);
                  resolvedImports[index++]=new ImportBinding(compoundName,false,importBinding,importReference);
                }
              }
            }
            continue nextImport;
          }
          for (int j=0, length=this.topLevelTypes.length; j < length; j++) {
            if (CharOperation.equals(this.topLevelTypes[j].sourceName,existingType.sourceName)) {
              problemReporter().conflictingImport(importReference);
              continue nextImport;
            }
          }
          problemReporter().duplicateImport(importReference);
          continue nextImport;
        }
        typesBySimpleNames.put(importReference.getSimpleName(),referenceBinding);
      }
 else       if (importBinding instanceof FieldBinding) {
        for (int j=0; j < index; j++) {
          ImportBinding resolved=resolvedImports[j];
          if (resolved.isStatic() && resolved.resolvedImport instanceof FieldBinding && importBinding != resolved.resolvedImport) {
            if (CharOperation.equals(compoundName[compoundName.length - 1],resolved.compoundName[resolved.compoundName.length - 1])) {
              problemReporter().duplicateImport(importReference);
              continue nextImport;
            }
          }
        }
      }
      resolvedImports[index++]=conflictingType == null ? new ImportBinding(compoundName,false,importBinding,importReference) : new ImportConflictBinding(compoundName,importBinding,conflictingType,importReference);
    }
  }
  if (resolvedImports.length > index)   System.arraycopy(resolvedImports,0,resolvedImports=new ImportBinding[index],0,index);
  this.imports=resolvedImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}",0.999438832772166
185573,"void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          recordImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}","void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          reportImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}",0.999080036798528
185574,"void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          recordImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}","void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          reportImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}",0.999080036798528
185575,"void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          recordImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}","void faultInImports(){
  if (this.typeOrPackageCache != null)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          reportImportProblem(importReference,importBinding);
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
}",0.999080036798528
185576,"void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            recordImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}","void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            reportImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}",0.9991334488734837
185577,"void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            recordImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}","void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            reportImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}",0.9991334488734837
185578,"void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            recordImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}","void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            reportImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}",0.9991334488734837
185579,"void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            recordImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}","void faultInImports(){
  boolean unresolvedFound=false;
  boolean reportUnresolved=!this.suppressImportErrors;
  if (this.typeOrPackageCache != null && !this.skipCachingImports)   return;
  if (this.referenceContext.imports == null) {
    this.typeOrPackageCache=new HashtableOfObject(1);
    return;
  }
  int numberOfStatements=this.referenceContext.imports.length;
  HashtableOfType typesBySimpleNames=null;
  for (int i=0; i < numberOfStatements; i++) {
    if ((this.referenceContext.imports[i].bits & ASTNode.OnDemand) == 0) {
      typesBySimpleNames=new HashtableOfType(this.topLevelTypes.length + numberOfStatements);
      for (int j=0, length=this.topLevelTypes.length; j < length; j++)       typesBySimpleNames.put(this.topLevelTypes[j].sourceName,this.topLevelTypes[j]);
      break;
    }
  }
  int numberOfImports=numberOfStatements + 1;
  for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG,importReference.tokens) && !importReference.isStatic()) {
      numberOfImports--;
      break;
    }
  }
  ImportBinding[] defaultImports=getDefaultImports();
  this.importPtr=defaultImports.length;
  this.tempImports=new ImportBinding[numberOfImports + this.importPtr - 1];
  System.arraycopy(defaultImports,0,this.tempImports,0,this.importPtr);
  nextImport:   for (int i=0; i < numberOfStatements; i++) {
    ImportReference importReference=this.referenceContext.imports[i];
    char[][] compoundName=importReference.getImportName();
    for (int j=0; j < this.importPtr; j++) {
      ImportBinding resolved=this.tempImports[j];
      if (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic()) {
        if (CharOperation.equals(compoundName,resolved.compoundName) && CharOperation.equals(importReference.getSimpleName(),getSimpleName(resolved))) {
          problemReporter().unusedImport(importReference);
          continue nextImport;
        }
      }
    }
    if ((importReference.bits & ASTNode.OnDemand) != 0) {
      if (CharOperation.equals(compoundName,this.currentPackageName)) {
        problemReporter().unusedImport(importReference);
        continue nextImport;
      }
      Binding importBinding=findImport(compoundName,compoundName.length);
      if (!importBinding.isValidBinding()) {
        reportImportProblem(importReference,importBinding);
        continue nextImport;
      }
      if (importReference.isStatic() && importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      recordImportBinding(new ImportBinding(compoundName,true,importBinding,importReference));
    }
 else {
      Binding importBinding=findSingleImport(compoundName,Binding.TYPE | Binding.FIELD | Binding.METHOD,importReference.isStatic());
      if (!importBinding.isValidBinding()) {
        if (importBinding.problemId() == ProblemReasons.Ambiguous) {
        }
 else {
          unresolvedFound=true;
          if (reportUnresolved) {
            reportImportProblem(importReference,importBinding);
          }
          continue nextImport;
        }
      }
      if (importBinding instanceof PackageBinding) {
        problemReporter().cannotImportPackage(importReference);
        continue nextImport;
      }
      if (checkAndRecordImportBinding(importBinding,typesBySimpleNames,importReference,compoundName) == -1)       continue nextImport;
      if (importReference.isStatic()) {
        if (importBinding.kind() == Binding.FIELD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE | Binding.METHOD,importReference);
        }
 else         if (importBinding.kind() == Binding.METHOD) {
          checkMoreStaticBindings(compoundName,typesBySimpleNames,Binding.TYPE,importReference);
        }
      }
    }
  }
  if (this.tempImports.length > this.importPtr)   System.arraycopy(this.tempImports,0,this.tempImports=new ImportBinding[this.importPtr],0,this.importPtr);
  this.imports=this.tempImports;
  int length=this.imports.length;
  this.typeOrPackageCache=new HashtableOfObject(length);
  for (int i=0; i < length; i++) {
    ImportBinding binding=this.imports[i];
    if (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)     this.typeOrPackageCache.put(getSimpleName(binding),binding);
  }
  this.skipCachingImports=this.suppressImportErrors && unresolvedFound;
}",0.9991334488734837
185580,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  try {
    if (node instanceof PackageNode) {
      String name=((PackageNode)node).getName();
      if (name.startsWith(packageName)) {
        notifyRequestor(enclosingElement,node.getStart());
      }
    }
 else     if (node instanceof ImportNode) {
      ImportNode i=((ImportNode)node);
      String name=i.getClassName();
      if (i.isStar() && !i.isStatic())       name=i.getPackageName();
      if (name.startsWith(packageName)) {
        notifyRequestor(enclosingElement,i.getType().getStart());
      }
    }
 else     if (node instanceof ClassNode && enclosingElement.getElementType() != IJavaElement.IMPORT_DECLARATION) {
      String name=((ClassNode)node).getName();
      if (name.startsWith(packageName) && name.length() <= node.getLength()) {
        if (enclosingElement instanceof ISourceReference) {
          ISourceRange range=((ISourceReference)enclosingElement).getSourceRange();
          if (node.getStart() >= range.getOffset() && node.getEnd() <= (range.getOffset() + range.getLength())) {
            notifyRequestor(enclosingElement,node.getStart());
          }
        }
      }
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"" + node.getClass().getSimpleName() + ""String_Node_Str""+ enclosingElement);
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  try {
    if (node instanceof PackageNode) {
      String name=((PackageNode)node).getName();
      if (name.startsWith(packageName)) {
        notifyRequestor(enclosingElement,node.getStart());
      }
    }
 else     if (node instanceof ImportNode) {
      ImportNode i=((ImportNode)node);
      String name=i.getClassName();
      if (i.isStar() && !i.isStatic())       name=i.getPackageName();
      if (name.startsWith(packageName)) {
        notifyRequestor(enclosingElement,i.getType().getStart());
      }
    }
 else     if (node instanceof ClassNode && enclosingElement.getElementType() != IJavaElement.IMPORT_DECLARATION) {
      String name=((ClassNode)node).getName();
      if (name.startsWith(packageName) && name.length() <= node.getLength()) {
        if (enclosingElement instanceof ISourceReference) {
          ISourceRange range=((ISourceReference)enclosingElement).getSourceRange();
          if (node.getStart() >= range.getOffset() && node.getLength() < range.getLength()) {
            notifyRequestor(enclosingElement,node.getStart());
          }
        }
      }
    }
  }
 catch (  CoreException e) {
    Util.log(e,""String_Node_Str"" + node.getClass().getSimpleName() + ""String_Node_Str""+ enclosingElement);
  }
  return VisitStatus.CONTINUE;
}",0.9884726224783862
185581,"@Override public void visitPackage(PackageNode node){
  if (node != null) {
    visitAnnotations(node);
    TypeLookupResult result=new TypeLookupResult(null,null,node,TypeConfidence.EXACT,null);
    VisitStatus status=notifyRequestor(node,requestor,result);
    if (status == VisitStatus.STOP_VISIT) {
      throw new VisitCompleted(status);
    }
  }
}","@Override public void visitPackage(PackageNode node){
  if (node != null) {
    visitAnnotations(node);
    IJavaElement oldEnclosing=enclosingElement;
    enclosingElement=unit.getPackageDeclaration(node.getName().substring(0,node.getName().length() - 1));
    try {
      TypeLookupResult result=new TypeLookupResult(null,null,node,TypeConfidence.EXACT,null);
      VisitStatus status=notifyRequestor(node,requestor,result);
      if (status == VisitStatus.STOP_VISIT) {
        throw new VisitCompleted(status);
      }
    }
  finally {
      enclosingElement=oldEnclosing;
    }
  }
}",0.750795334040297
185582,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.936858316221766
185583,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.936858316221766
185584,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.936858316221766
185585,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"");
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.936858316221766
185586,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.9370522006141248
185587,"private void processClassVariable(VariableExpression expression){
  String name=expression.getName();
  if (passingParams && controller.isInScriptBody()) {
    MethodVisitor mv=controller.getMethodVisitor();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    loadThisOrOwner();
    mv.visitLdcInsn(name);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
 else {
    PropertyExpression pexp=new PropertyExpression(new VariableExpression(""String_Node_Str"",ClassHelper.DYNAMIC_TYPE),name);
    pexp.getObjectExpression().setSourcePosition(expression);
    pexp.getProperty().setSourcePosition(expression);
    pexp.setImplicitThis(true);
    visitPropertyExpression(pexp);
  }
}","private void processClassVariable(VariableExpression expression){
  if (passingParams && controller.isInScriptBody()) {
    MethodVisitor mv=controller.getMethodVisitor();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    loadThisOrOwner();
    mv.visitLdcInsn(expression.getName());
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
 else {
    PropertyExpression pexp=new PropertyExpression(new VariableExpression(""String_Node_Str""),expression.getName());
    pexp.getObjectExpression().setSourcePosition(expression);
    pexp.getProperty().setSourcePosition(expression);
    pexp.setImplicitThis(true);
    visitPropertyExpression(pexp);
  }
}",0.9245411284840244
185588,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.9370522006141248
185589,"private void processClassVariable(VariableExpression expression){
  String name=expression.getName();
  if (passingParams && controller.isInScriptBody()) {
    MethodVisitor mv=controller.getMethodVisitor();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    loadThisOrOwner();
    mv.visitLdcInsn(name);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
 else {
    PropertyExpression pexp=new PropertyExpression(new VariableExpression(""String_Node_Str"",ClassHelper.DYNAMIC_TYPE),name);
    pexp.getObjectExpression().setSourcePosition(expression);
    pexp.getProperty().setSourcePosition(expression);
    pexp.setImplicitThis(true);
    visitPropertyExpression(pexp);
  }
}","private void processClassVariable(VariableExpression expression){
  if (passingParams && controller.isInScriptBody()) {
    MethodVisitor mv=controller.getMethodVisitor();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    loadThisOrOwner();
    mv.visitLdcInsn(expression.getName());
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
 else {
    PropertyExpression pexp=new PropertyExpression(new VariableExpression(""String_Node_Str"",ClassHelper.DYNAMIC_TYPE),expression.getName());
    pexp.getObjectExpression().setSourcePosition(expression);
    pexp.getProperty().setSourcePosition(expression);
    pexp.setImplicitThis(true);
    visitPropertyExpression(pexp);
  }
}",0.9438502673796793
185590,"public void visitClass(ClassNode classNode){
  referencedClasses.clear();
  WriterControllerFactory factory=(WriterControllerFactory)classNode.getNodeMetaData(WriterControllerFactory.class);
  WriterController normalController=new WriterController();
  if (factory != null) {
    this.controller=factory.makeController(normalController);
  }
 else {
    this.controller=normalController;
  }
  this.controller.init(this,context,cv,classNode);
  if (controller.shouldOptimizeForInt() || factory != null) {
    OptimizingStatementWriter.setNodeMeta(controller.getTypeChooser(),classNode);
  }
  try {
    cv.visit(controller.getBytecodeVersion(),adjustedClassModifiersForClassWriting(classNode),controller.getInternalClassName(),BytecodeHelper.getGenericsSignature(classNode),controller.getInternalBaseClassName(),BytecodeHelper.getClassInternalNames(classNode.getInterfaces()));
    cv.visitSource(sourceFile,null);
    if (classNode instanceof InnerClassNode) {
      InnerClassNode innerClass=(InnerClassNode)classNode;
      MethodNode enclosingMethod=innerClass.getEnclosingMethod();
      if (enclosingMethod != null) {
        String outerClassName=BytecodeHelper.getClassInternalName(innerClass.getOuterClass().getName());
        cv.visitOuterClass(outerClassName,enclosingMethod.getName(),BytecodeHelper.getMethodDescriptor(enclosingMethod));
      }
    }
    if (classNode.getName().endsWith(""String_Node_Str"")) {
      PackageNode packageNode=classNode.getPackage();
      if (packageNode != null) {
        for (        AnnotationNode an : packageNode.getAnnotations()) {
          if (an.isBuiltIn())           continue;
          if (an.hasSourceRetention())           continue;
          AnnotationVisitor av=getAnnotationVisitor(classNode,an,cv);
          visitAnnotationAttributes(an,av);
          av.visitEnd();
        }
      }
      cv.visitEnd();
      return;
    }
 else {
      visitAnnotations(classNode,cv);
    }
    if (classNode.isInterface()) {
      ClassNode owner=classNode;
      if (owner instanceof InnerClassNode) {
        owner=owner.getOuterClass();
      }
      String outerClassName=classNode.getName();
      String name=outerClassName + ""String_Node_Str"" + context.getNextInnerClassIdx();
      controller.setInterfaceClassLoadingClass(new InterfaceHelperClassNode(owner,name,ACC_SUPER | ACC_SYNTHETIC | ACC_STATIC,ClassHelper.OBJECT_TYPE,controller.getCallSiteWriter().getCallSites()));
      super.visitClass(classNode);
      createInterfaceSyntheticStaticFields();
    }
 else {
      super.visitClass(classNode);
      MopWriter.Factory mopWriterFactory=classNode.getNodeMetaData(MopWriter.Factory.class);
      if (mopWriterFactory == null) {
        mopWriterFactory=MopWriter.FACTORY;
      }
      MopWriter mopWriter=mopWriterFactory.create(controller);
      mopWriter.createMopMethods();
      controller.getCallSiteWriter().generateCallSiteArray();
      createSyntheticStaticFields();
    }
    for (Iterator<InnerClassNode> iter=classNode.getInnerClasses(); iter.hasNext(); ) {
      InnerClassNode innerClass=iter.next();
      makeInnerClassEntry(innerClass);
    }
    makeInnerClassEntry(classNode);
    cv.visitEnd();
  }
 catch (  GroovyRuntimeException e) {
    e.setModule(classNode.getModule());
    throw e;
  }
catch (  NegativeArraySizeException nase) {
    throw new GroovyRuntimeException(""String_Node_Str"" + sourceFile,nase);
  }
catch (  NullPointerException npe) {
    throw new GroovyRuntimeException(""String_Node_Str"" + sourceFile,npe);
  }
}","public void visitClass(ClassNode classNode){
  referencedClasses.clear();
  WriterControllerFactory factory=classNode.getNodeMetaData(WriterControllerFactory.class);
  WriterController normalController=new WriterController();
  if (factory != null) {
    this.controller=factory.makeController(normalController);
  }
 else {
    this.controller=normalController;
  }
  this.controller.init(this,context,cv,classNode);
  this.cv=this.controller.getClassVisitor();
  if (controller.shouldOptimizeForInt() || factory != null) {
    OptimizingStatementWriter.setNodeMeta(controller.getTypeChooser(),classNode);
  }
  try {
    cv.visit(controller.getBytecodeVersion(),adjustedClassModifiersForClassWriting(classNode),controller.getInternalClassName(),BytecodeHelper.getGenericsSignature(classNode),controller.getInternalBaseClassName(),BytecodeHelper.getClassInternalNames(classNode.getInterfaces()));
    cv.visitSource(sourceFile,null);
    if (classNode instanceof InnerClassNode) {
      InnerClassNode innerClass=(InnerClassNode)classNode;
      MethodNode enclosingMethod=innerClass.getEnclosingMethod();
      if (enclosingMethod != null) {
        String outerClassName=BytecodeHelper.getClassInternalName(innerClass.getOuterClass().getName());
        cv.visitOuterClass(outerClassName,enclosingMethod.getName(),BytecodeHelper.getMethodDescriptor(enclosingMethod));
      }
    }
    if (classNode.getName().endsWith(""String_Node_Str"")) {
      PackageNode packageNode=classNode.getPackage();
      if (packageNode != null) {
        for (        AnnotationNode an : packageNode.getAnnotations()) {
          if (an.isBuiltIn())           continue;
          if (an.hasSourceRetention())           continue;
          AnnotationVisitor av=getAnnotationVisitor(classNode,an,cv);
          visitAnnotationAttributes(an,av);
          av.visitEnd();
        }
      }
      cv.visitEnd();
      return;
    }
 else {
      visitAnnotations(classNode,cv);
    }
    if (classNode.isInterface()) {
      ClassNode owner=classNode;
      if (owner instanceof InnerClassNode) {
        owner=owner.getOuterClass();
      }
      String outerClassName=classNode.getName();
      String name=outerClassName + ""String_Node_Str"" + context.getNextInnerClassIdx();
      controller.setInterfaceClassLoadingClass(new InterfaceHelperClassNode(owner,name,ACC_SUPER | ACC_SYNTHETIC | ACC_STATIC,ClassHelper.OBJECT_TYPE,controller.getCallSiteWriter().getCallSites()));
      super.visitClass(classNode);
      createInterfaceSyntheticStaticFields();
    }
 else {
      super.visitClass(classNode);
      MopWriter.Factory mopWriterFactory=classNode.getNodeMetaData(MopWriter.Factory.class);
      if (mopWriterFactory == null) {
        mopWriterFactory=MopWriter.FACTORY;
      }
      MopWriter mopWriter=mopWriterFactory.create(controller);
      mopWriter.createMopMethods();
      controller.getCallSiteWriter().generateCallSiteArray();
      createSyntheticStaticFields();
    }
    for (Iterator<InnerClassNode> iter=classNode.getInnerClasses(); iter.hasNext(); ) {
      InnerClassNode innerClass=iter.next();
      makeInnerClassEntry(innerClass);
    }
    makeInnerClassEntry(classNode);
    cv.visitEnd();
  }
 catch (  GroovyRuntimeException e) {
    e.setModule(classNode.getModule());
    throw e;
  }
catch (  NegativeArraySizeException nase) {
    throw new GroovyRuntimeException(""String_Node_Str"" + sourceFile,nase);
  }
catch (  NullPointerException npe) {
    throw new GroovyRuntimeException(""String_Node_Str"" + sourceFile,npe);
  }
}",0.990096208262592
185591,"private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}","private void visitStdMethod(MethodNode node,boolean isConstructor,Parameter[] parameters,Statement code){
  controller.getCompileStack().init(node.getVariableScope(),parameters);
  controller.getCallSiteWriter().makeSiteEntry();
  MethodVisitor mv=controller.getMethodVisitor();
  final ClassNode superClass=controller.getClassNode().getSuperClass();
  if (isConstructor && (code == null || !((ConstructorNode)node).firstStatementIsSpecialConstructorCall())) {
    boolean hasCallToSuper=false;
    if (code != null && controller.getClassNode() instanceof InnerClassNode) {
      if (code instanceof BlockStatement) {
        for (        Statement statement : ((BlockStatement)code).getStatements()) {
          if (statement instanceof ExpressionStatement) {
            final Expression expression=((ExpressionStatement)statement).getExpression();
            if (expression instanceof ConstructorCallExpression) {
              ConstructorCallExpression call=(ConstructorCallExpression)expression;
              if (call.isSuperCall()) {
                hasCallToSuper=true;
                break;
              }
            }
          }
        }
      }
    }
    if (!hasCallToSuper) {
      mv.visitVarInsn(ALOAD,0);
      mv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superClass),""String_Node_Str"",""String_Node_Str"",false);
    }
  }
  super.visitConstructorOrMethod(node,isConstructor);
  controller.getCompileStack().clear();
  if (node.isVoidMethod()) {
    mv.visitInsn(RETURN);
  }
 else {
    ClassNode type=node.getReturnType().redirect();
    if (ClassHelper.isPrimitiveType(type)) {
      mv.visitLdcInsn(0);
      controller.getOperandStack().push(ClassHelper.int_TYPE);
      controller.getOperandStack().doGroovyCast(type);
      BytecodeHelper.doReturn(mv,type);
      controller.getOperandStack().remove(1);
    }
 else {
      mv.visitInsn(ACONST_NULL);
      BytecodeHelper.doReturn(mv,type);
    }
  }
}",0.9370522006141248
185592,"@Override public void visitImports(ModuleNode node){
  for (  ImportNode imp : GroovyUtils.getAllImportNodes(node)) {
    IJavaElement oldEnclosingElement=enclosingElement;
    visitAnnotations(imp);
    ClassNode type=imp.getType();
    if (type != null) {
      String importName=imp.getClassName().replace('$','.') + (imp.getFieldName() != null ? ""String_Node_Str"" + imp.getFieldName() : ""String_Node_Str"");
      enclosingElement=unit.getImport(importName);
      if (!enclosingElement.exists()) {
        enclosingElement=oldEnclosingElement;
      }
    }
    try {
      TypeLookupResult result=null;
      VariableScope scope=scopes.getLast();
      scope.setPrimaryNode(false);
      assignmentStorer.storeImport(imp,scope);
      for (      ITypeLookup lookup : lookups) {
        TypeLookupResult candidate=lookup.lookupType(imp,scope);
        if (candidate != null) {
          if (result == null || result.confidence.isLessThan(candidate.confidence)) {
            result=candidate;
          }
          if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
            break;
          }
        }
      }
      VisitStatus status=notifyRequestor(imp,requestor,result);
switch (status) {
case CONTINUE:
        try {
          if (type != null) {
            visitClassReference(type);
            completeExpressionStack.add(imp);
            if (imp.getFieldNameExpr() != null) {
              primaryTypeStack.add(type);
              imp.getFieldNameExpr().visit(this);
              dependentDeclarationStack.removeLast();
              dependentTypeStack.removeLast();
            }
            completeExpressionStack.removeLast();
          }
        }
 catch (        VisitCompleted e) {
          if (e.status == VisitStatus.STOP_VISIT) {
            throw e;
          }
        }
case CANCEL_MEMBER:
      continue;
case CANCEL_BRANCH:
    return;
case STOP_VISIT:
  throw new VisitCompleted(status);
}
}
  finally {
enclosingElement=oldEnclosingElement;
}
}
}","@Override public void visitImports(ModuleNode node){
  for (  ImportNode imp : GroovyUtils.getAllImportNodes(node)) {
    IJavaElement oldEnclosingElement=enclosingElement;
    visitAnnotations(imp);
    String importName;
    if (imp.isStar()) {
      if (!imp.isStatic()) {
        importName=imp.getPackageName() + ""String_Node_Str"";
      }
 else {
        importName=imp.getClassName().replace('$','.') + ""String_Node_Str"";
      }
    }
 else {
      if (!imp.isStatic()) {
        importName=imp.getClassName().replace('$','.');
      }
 else {
        importName=imp.getClassName().replace('$','.') + ""String_Node_Str"" + imp.getFieldName();
      }
    }
    enclosingElement=unit.getImport(importName);
    if (!enclosingElement.exists()) {
      enclosingElement=oldEnclosingElement;
    }
    try {
      TypeLookupResult result=null;
      VariableScope scope=scopes.getLast();
      scope.setPrimaryNode(false);
      assignmentStorer.storeImport(imp,scope);
      for (      ITypeLookup lookup : lookups) {
        TypeLookupResult candidate=lookup.lookupType(imp,scope);
        if (candidate != null) {
          if (result == null || result.confidence.isLessThan(candidate.confidence)) {
            result=candidate;
          }
          if (result.confidence.isAtLeast(TypeConfidence.INFERRED)) {
            break;
          }
        }
      }
      VisitStatus status=notifyRequestor(imp,requestor,result);
switch (status) {
case CONTINUE:
        try {
          ClassNode type=imp.getType();
          if (type != null) {
            visitClassReference(type);
            completeExpressionStack.add(imp);
            if (imp.getFieldNameExpr() != null) {
              primaryTypeStack.add(type);
              imp.getFieldNameExpr().visit(this);
              dependentDeclarationStack.removeLast();
              dependentTypeStack.removeLast();
            }
            completeExpressionStack.removeLast();
          }
        }
 catch (        VisitCompleted e) {
          if (e.status == VisitStatus.STOP_VISIT) {
            throw e;
          }
        }
case CANCEL_MEMBER:
      continue;
case CANCEL_BRANCH:
    return;
case STOP_VISIT:
  throw new VisitCompleted(status);
}
}
  finally {
enclosingElement=oldEnclosingElement;
}
}
}",0.8804500703234881
185593,"public ITypeRequestor createRequestor(PossibleMatch possibleMatch,SearchPattern pattern,SearchRequestor requestor){
  if (pattern instanceof TypeReferencePattern) {
    return new TypeReferenceSearchRequestor((TypeReferencePattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof TypeDeclarationPattern) {
    return new TypeDeclarationSearchRequestor((TypeDeclarationPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof FieldPattern) {
    return new FieldReferenceSearchRequestor((FieldPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof MethodPattern) {
    return new MethodReferenceSearchRequestor((MethodPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof LocalVariablePattern) {
    ILocalVariable localVar=(ILocalVariable)ReflectionUtils.getPrivateField(LocalVariablePattern.class,""String_Node_Str"",pattern);
    int start;
    try {
      start=localVar.getSourceRange().getOffset();
    }
 catch (    JavaModelException e) {
      Util.log(e);
      start=-1;
    }
    return new LocalVariableReferenceRequestor(localVar.getElementName(),localVar.getParent(),requestor,possibleMatch.document.getParticipant(),start);
  }
 else   if (pattern instanceof ConstructorPattern) {
    return new ConstructorReferenceSearchRequestor((ConstructorPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof OrPattern) {
    SearchPattern[] patterns=getPatterns((OrPattern)pattern);
    List<ITypeRequestor> requestors=new ArrayList<ITypeRequestor>(patterns.length);
    for (    SearchPattern orPattern : patterns) {
      if (orPattern != null) {
        ITypeRequestor maybeRequestor=createRequestor(possibleMatch,orPattern,requestor);
        if (maybeRequestor != null) {
          requestors.add(maybeRequestor);
        }
      }
    }
    return new OrPatternRequestor(requestors);
  }
  return null;
}","public ITypeRequestor createRequestor(PossibleMatch possibleMatch,SearchPattern pattern,SearchRequestor requestor){
  if (pattern instanceof TypeReferencePattern) {
    return new TypeReferenceSearchRequestor((TypeReferencePattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof TypeDeclarationPattern) {
    return new TypeDeclarationSearchRequestor((TypeDeclarationPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof FieldPattern) {
    return new FieldReferenceSearchRequestor((FieldPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof MethodPattern) {
    return new MethodReferenceSearchRequestor((MethodPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof ConstructorPattern) {
    return new ConstructorReferenceSearchRequestor((ConstructorPattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof PackageReferencePattern) {
    return new PackageReferenceSearchRequestor((PackageReferencePattern)pattern,requestor,possibleMatch.document.getParticipant());
  }
 else   if (pattern instanceof LocalVariablePattern) {
    ILocalVariable localVar=(ILocalVariable)ReflectionUtils.getPrivateField(LocalVariablePattern.class,""String_Node_Str"",pattern);
    int start;
    try {
      start=localVar.getSourceRange().getOffset();
    }
 catch (    JavaModelException e) {
      Util.log(e);
      start=-1;
    }
    return new LocalVariableReferenceRequestor(localVar.getElementName(),localVar.getParent(),requestor,possibleMatch.document.getParticipant(),start);
  }
 else   if (pattern instanceof OrPattern) {
    SearchPattern[] patterns=(SearchPattern[])ReflectionUtils.getPrivateField(OrPattern.class,""String_Node_Str"",pattern);
    List<ITypeRequestor> requestors=new ArrayList<ITypeRequestor>(patterns.length);
    for (    SearchPattern orPattern : patterns) {
      if (orPattern != null) {
        ITypeRequestor maybeRequestor=createRequestor(possibleMatch,orPattern,requestor);
        if (maybeRequestor != null) {
          requestors.add(maybeRequestor);
        }
      }
    }
    return new OrPatternRequestor(requestors);
  }
  return null;
}",0.8512396694214877
185594,"private static String stateString(int bundleState){
switch (bundleState) {
case Bundle.ACTIVE:
    return ""String_Node_Str"";
case Bundle.UNINSTALLED:
  return ""String_Node_Str"";
case Bundle.INSTALLED:
return ""String_Node_Str"";
case Bundle.RESOLVED:
return ""String_Node_Str"";
case Bundle.STARTING:
return ""String_Node_Str"";
case Bundle.STOPPING:
return ""String_Node_Str"";
}
return ""String_Node_Str"" + bundleState + ""String_Node_Str"";
}","private static String stateString(int bundleState){
switch (bundleState) {
case Bundle.UNINSTALLED:
    return ""String_Node_Str"";
case Bundle.INSTALLED:
  return ""String_Node_Str"";
case Bundle.RESOLVED:
return ""String_Node_Str"";
case Bundle.STARTING:
return ""String_Node_Str"";
case Bundle.STOPPING:
return ""String_Node_Str"";
case Bundle.ACTIVE:
return ""String_Node_Str"";
}
return ""String_Node_Str"" + bundleState + ""String_Node_Str"";
}",0.8847926267281107
185595,"private void refreshPackages(Bundle... bundles){
  final CountDownLatch latch=new CountDownLatch(1);
  bundleContext.getBundle(0).adapt(FrameworkWiring.class).refreshBundles(Arrays.asList(bundles),new FrameworkListener(){
    public void frameworkEvent(    FrameworkEvent event){
      if (event.getType() == FrameworkEvent.PACKAGES_REFRESHED) {
        latch.countDown();
      }
    }
  }
);
  try {
    latch.await(5,TimeUnit.SECONDS);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  dump(bundles);
}","private void refreshPackages(Collection<Bundle> bundles){
  FrameworkWiring wiring=bundleContext.getBundle(0).adapt(FrameworkWiring.class);
  System.out.println(""String_Node_Str"");
  dump(wiring.getDependencyClosure(bundles));
  final CountDownLatch latch=new CountDownLatch(1);
  wiring.refreshBundles(bundles,new FrameworkListener(){
    public void frameworkEvent(    FrameworkEvent event){
      if (event.getType() == FrameworkEvent.PACKAGES_REFRESHED) {
        latch.countDown();
      }
    }
  }
);
  try {
    latch.await(5,TimeUnit.SECONDS);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.7240461401952085
185596,"public void stop(BundleContext bundleContext) throws Exception {
  this.bundleContext.removeServiceListener(serviceListener);
  this.bundleContext=null;
  serviceListener=null;
  initialized=false;
}","public void stop(BundleContext bundleContext) throws Exception {
  if (serviceListener != null) {
    bundleContext.removeServiceListener(serviceListener);
  }
  this.bundleContext=null;
  serviceListener=null;
  initialized=false;
}",0.8379629629629629
185597,"public CompilerChooser initialize() throws BundleException {
  if (initialized)   return this;
  initialized=true;
  SpecifiedVersion specifiedVersion=getVersionFromProperties();
  if (specifiedVersion == SpecifiedVersion.UNSPECIFIED) {
    specifiedVersion=getVersionFromPrefenences();
  }
  System.out.println(""String_Node_Str"" + specifiedVersion.toReadableVersionString());
  Bundle[] bundles=Platform.getBundles(GROOVY_PLUGIN_ID,null);
  if (bundles == null || bundles.length == 0) {
    System.out.println(""String_Node_Str"");
    bundles=new Bundle[0];
  }
 else {
    dump(bundles);
  }
  allVersions=new Version[bundles.length];
  allSpecifiedVersions=new SpecifiedVersion[bundles.length];
  if (specifiedVersion != SpecifiedVersion.UNSPECIFIED) {
    boolean found=false;
    for (int i=0, n=bundles.length; i < n; i+=1) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
      if (allSpecifiedVersions[i] == specifiedVersion && !found) {
        activeIndex=i;
        found=true;
      }
    }
    if (found) {
      for (int i=0, n=bundles.length; i < n; i+=1) {
        Bundle bundle=bundles[i];
        if (i != activeIndex) {
          System.out.println(""String_Node_Str"" + bundle.getVersion());
          bundle.uninstall();
          refreshPackages(bundle);
        }
 else {
          System.out.println(""String_Node_Str"" + bundle.getVersion());
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"" + allVersions[0] + ""String_Node_Str"");
    }
  }
 else {
    for (int i=0, n=bundles.length; i < n; i+=1) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
    }
  }
  return this;
}","public CompilerChooser initialize() throws BundleException {
  if (!initialized) {
    initialized=true;
    SpecifiedVersion specifiedVersion=getVersionFromProperties();
    if (specifiedVersion == SpecifiedVersion.UNSPECIFIED) {
      specifiedVersion=getVersionFromPrefenences();
    }
    System.out.println(""String_Node_Str"" + specifiedVersion.toReadableVersionString());
    Bundle[] bundles=Platform.getBundles(GROOVY_PLUGIN_ID,null);
    if (bundles == null || bundles.length == 0) {
      System.out.println(""String_Node_Str"");
      bundles=new Bundle[0];
    }
 else {
      dump(Arrays.asList(bundles));
    }
    allVersions=new Version[bundles.length];
    allSpecifiedVersions=new SpecifiedVersion[bundles.length];
    for (int i=0, n=bundles.length; i < n; i+=1) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
      if (allSpecifiedVersions[i] == specifiedVersion && activeIndex == -1) {
        activeIndex=i;
      }
    }
    if (bundles.length > 1) {
      int skip=Math.max(0,activeIndex);
      Collection<Bundle> dirty=new ArrayList<Bundle>();
      for (int i=0, n=bundles.length; i < n; i+=1) {
        Bundle bundle=bundles[i];
        if (i == skip) {
          System.out.println(""String_Node_Str"" + bundle.getVersion());
        }
 else {
          System.out.println(""String_Node_Str"" + bundle.getVersion());
          bundle.uninstall();
          dirty.add(bundle);
        }
      }
      refreshPackages(dirty);
    }
  }
  return this;
}",0.7000292654375183
185598,"private void dump(Bundle... bundles){
  for (  Bundle b : bundles) {
    String message=b.getBundleId() + ""String_Node_Str"" + b.getVersion()+ ""String_Node_Str""+ stateString(b.getState());
    System.out.println(message);
  }
}","private void dump(Collection<Bundle> bundles){
  for (  Bundle b : bundles) {
    System.out.println(String.format(""String_Node_Str"",b.getBundleId(),b.getSymbolicName(),b.getVersion(),stateString(b.getState())));
  }
}",0.5
185599,"private int getDeclarationOffset(){
  if (declarationExpression.getEnd() > 0) {
    return declarationExpression.getStart();
  }
  if (!declarationExpression.getAnnotations().isEmpty()) {
    return declarationExpression.getAnnotations().get(0).getStart() - 1;
  }
  throw new IllegalStateException(""String_Node_Str"" + declarationExpression.getText());
}","private int getDeclarationOffset(){
  if (declarationExpression.getEnd() > 0) {
    return declarationExpression.getStart();
  }
  if (!declarationExpression.getAnnotations().isEmpty()) {
    return declarationExpression.getAnnotations().get(0).getStart() - 1;
  }
  throw new IllegalStateException(""String_Node_Str"" + variableExpressionInDeclaration.getLineNumber());
}",0.8977900552486188
185600,"@Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException {
  String[] classpath=super.getClasspath(configuration);
  List<String> newClasspath=Arrays.asList(classpath);
  try {
    newClasspath.addAll(getExtraClasspathElements());
  }
 catch (  IOException e) {
    GroovyCore.logException(""String_Node_Str"",e);
  }
  return newClasspath.toArray(new String[0]);
}","@Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException {
  String[] classpath=super.getClasspath(configuration);
  boolean jline=false, commons_cli=false;
  for (  String entry : classpath) {
    if (entry.matches(""String_Node_Str"")) {
      jline=true;
    }
 else     if (entry.matches(""String_Node_Str"")) {
      commons_cli=true;
    }
  }
  if (!jline) {
    IPath path=CompilerUtils.getJarInGroovyLib(""String_Node_Str"");
    if (path != null) {
      classpath=(String[])ArrayUtils.add(classpath,path.toOSString());
    }
  }
  if (!commons_cli) {
    IPath path=CompilerUtils.getJarInGroovyLib(""String_Node_Str"");
    if (path != null) {
      classpath=(String[])ArrayUtils.add(classpath,path.toOSString());
    }
  }
  return classpath;
}",0.3226890756302521
185601,"private void launchGroovy(IJavaProject project,String mode){
  String className=org.codehaus.groovy.tools.shell.Main.class.getName();
  try {
    String launchName=getLaunchManager().generateLaunchConfigurationName(project.getProject().getName());
    ILaunchConfigurationWorkingCopy launchConfig=getGroovyLaunchConfigType().newInstance(null,launchName);
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME,className);
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME,project.getElementName());
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_VM_ARGUMENTS,""String_Node_Str"");
    List<String> classpath=new ArrayList<String>(Arrays.asList(JavaRuntime.computeDefaultRuntimeClassPath(project)));
    try {
      classpath.addAll(0,GroovyShellLaunchDelegate.getExtraClasspathElements());
    }
 catch (    Exception e) {
      GroovyCore.logException(""String_Node_Str"",e);
    }
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_CLASSPATH,classpath);
    DebugUITools.launch(launchConfig,mode);
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",e);
  }
}","private void launchGroovy(IJavaProject project,String mode){
  try {
    String launchName=getLaunchManager().generateLaunchConfigurationName(project.getProject().getName());
    ILaunchConfigurationWorkingCopy launchConfig=getGroovyLaunchConfigType().newInstance(null,launchName);
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME,Main.class.getName());
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME,project.getElementName());
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_VM_ARGUMENTS,""String_Node_Str"");
    List<String> classpath=new ArrayList<String>(Arrays.asList(JavaRuntime.computeDefaultRuntimeClassPath(project)));
    launchConfig.setAttribute(IJavaLaunchConfigurationConstants.ATTR_CLASSPATH,classpath);
    DebugUITools.launch(launchConfig,mode);
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",e);
  }
}",0.685981308411215
185602,"/** 
 * This is a convenince method for getting the Launch Manager from the Debug plugin.
 * @return Returns the default Eclipse launch manager.
 */
public static ILaunchManager getLaunchManager(){
  return DebugPlugin.getDefault().getLaunchManager();
}","/** 
 * This is a convenince method for getting the Launch Manager from the Debug plugin.
 * @return the default Eclipse launch manager
 */
public static ILaunchManager getLaunchManager(){
  return DebugPlugin.getDefault().getLaunchManager();
}",0.9818913480885312
185603,"/** 
 * This method is called after all types have been accepted by this requestor.  Converts each type into an   {@link ICompletionProposal}
 * @return list of all {@link ICompletionProposal}s applicable for this content assist request.
 */
List<ICompletionProposal> processAcceptedTypes(JDTResolver resolver){
  this.checkCancel();
  if (this.acceptedTypes == null)   return Collections.EMPTY_LIST;
  int length=this.acceptedTypes.size();
  if (length == 0)   return Collections.EMPTY_LIST;
  HashtableOfObject onDemandFound=new HashtableOfObject();
  String thisPackageName=module.getPackageName() == null ? ""String_Node_Str"" : module.getPackageName();
  List<ICompletionProposal> proposals=new LinkedList<ICompletionProposal>();
  try {
    next:     for (int i=0; i < length; i+=1) {
      if ((i % CHECK_CANCEL_FREQUENCY) == 0) {
        checkCancel();
      }
      AcceptedType acceptedType=(AcceptedType)this.acceptedTypes.elementAt(i);
      char[] packageName=acceptedType.packageName;
      char[] simpleTypeName=acceptedType.simpleTypeName;
      char[][] enclosingTypeNames=acceptedType.enclosingTypeNames;
      int modifiers=acceptedType.modifiers;
      int accessibility=acceptedType.accessibility;
      char[] typeName;
      char[] flatEnclosingTypeNames;
      if (enclosingTypeNames == null || enclosingTypeNames.length == 0) {
        flatEnclosingTypeNames=null;
        typeName=simpleTypeName;
      }
 else {
        flatEnclosingTypeNames=CharOperation.concatWith(acceptedType.enclosingTypeNames,'.');
        typeName=CharOperation.concat(flatEnclosingTypeNames,simpleTypeName,'.');
      }
      char[] fullyQualifiedName=CharOperation.concat(packageName,typeName,'.');
      if (imports == null && resolver.getScope() != null) {
        initializeImportArrays(resolver.getScope());
      }
      for (int j=0; j < imports.length; j++) {
        char[][] importName=imports[j];
        if (CharOperation.equals(typeName,importName[0])) {
          proposals.add(proposeType(packageName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,!CharOperation.equals(fullyQualifiedName,importName[1])));
          continue next;
        }
      }
      if ((enclosingTypeNames == null || enclosingTypeNames.length == 0) && CharOperation.equals(thisPackageName.toCharArray(),packageName)) {
        proposals.add(proposeType(packageName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,false));
        continue next;
      }
 else {
        char[] fullyQualifiedEnclosingTypeOrPackageName=null;
        if (((AcceptedType)onDemandFound.get(simpleTypeName)) == null) {
          for (int j=0; j < this.onDemandimports.length; j++) {
            char[] importFlatName=onDemandimports[j];
            if (fullyQualifiedEnclosingTypeOrPackageName == null) {
              if (enclosingTypeNames != null && enclosingTypeNames.length != 0) {
                fullyQualifiedEnclosingTypeOrPackageName=CharOperation.concat(packageName,flatEnclosingTypeNames,'.');
              }
 else {
                fullyQualifiedEnclosingTypeOrPackageName=packageName;
              }
            }
            if (CharOperation.equals(fullyQualifiedEnclosingTypeOrPackageName,importFlatName)) {
              acceptedType.qualifiedTypeName=typeName;
              acceptedType.fullyQualifiedName=fullyQualifiedName;
              onDemandFound.put(simpleTypeName,acceptedType);
              continue next;
            }
          }
          proposals.add(proposeType(fullyQualifiedEnclosingTypeOrPackageName != null ? fullyQualifiedEnclosingTypeOrPackageName : packageName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,true));
        }
      }
    }
    char[][] keys=onDemandFound.keyTable;
    Object[] values=onDemandFound.valueTable;
    int max=keys.length;
    for (int i=0; i < max; i++) {
      if ((i % CHECK_CANCEL_FREQUENCY) == 0)       checkCancel();
      if (keys[i] != null) {
        AcceptedType value=(AcceptedType)values[i];
        if (value != null) {
          proposals.add(proposeType(value.packageName,value.simpleTypeName,value.modifiers,value.accessibility,value.qualifiedTypeName,value.fullyQualifiedName,value.mustBeQualified));
        }
      }
    }
  }
  finally {
    this.acceptedTypes=null;
  }
  return proposals;
}","/** 
 * Called after all types have been accepted by this requestor.  Converts each type into an   {@link ICompletionProposal}.
 * @return list of all {@link ICompletionProposal}s applicable for this content assist request
 */
List<ICompletionProposal> processAcceptedTypes(JDTResolver resolver){
  checkCancel();
  int n;
  if (acceptedTypes == null || (n=acceptedTypes.size()) == 0) {
    return Collections.EMPTY_LIST;
  }
  HashtableOfObject onDemandFound=new HashtableOfObject();
  String thisPackageName=module.getPackageName();
  if (thisPackageName == null)   thisPackageName=""String_Node_Str"";
  List<ICompletionProposal> proposals=new LinkedList<ICompletionProposal>();
  try {
    next:     for (int i=0; i < n; i+=1) {
      if ((i % CHECK_CANCEL_FREQUENCY) == 0) {
        checkCancel();
      }
      AcceptedType acceptedType=(AcceptedType)acceptedTypes.elementAt(i);
      char[] packageName=acceptedType.packageName;
      char[] simpleTypeName=acceptedType.simpleTypeName;
      char[][] enclosingTypeNames=acceptedType.enclosingTypeNames;
      int modifiers=acceptedType.modifiers;
      int accessibility=acceptedType.accessibility;
      char[] typeName;
      char[] flatEnclosingTypeNames;
      if (enclosingTypeNames == null || enclosingTypeNames.length == 0) {
        flatEnclosingTypeNames=null;
        typeName=simpleTypeName;
      }
 else {
        flatEnclosingTypeNames=CharOperation.concatWith(acceptedType.enclosingTypeNames,'.');
        typeName=CharOperation.concat(flatEnclosingTypeNames,simpleTypeName,'.');
      }
      char[] fullyQualifiedName=CharOperation.concat(packageName,typeName,'.');
      if (imports == null && resolver.getScope() != null) {
        initializeImportArrays(resolver.getScope());
      }
      if (imports != null) {
        for (        char[][] importName : imports) {
          if (CharOperation.equals(typeName,importName[0])) {
            proposals.add(proposeType(packageName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,!CharOperation.equals(fullyQualifiedName,importName[1])));
            continue next;
          }
        }
      }
      if ((enclosingTypeNames == null || enclosingTypeNames.length == 0) && CharOperation.equals(thisPackageName.toCharArray(),packageName)) {
        proposals.add(proposeType(packageName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,false));
        continue next;
      }
 else       if (((AcceptedType)onDemandFound.get(simpleTypeName)) == null && onDemandimports != null) {
        char[] fullyQualifiedEnclosingTypeOrPackageName=null;
        for (        char[] importFlatName : onDemandimports) {
          if (fullyQualifiedEnclosingTypeOrPackageName == null) {
            if (enclosingTypeNames != null && enclosingTypeNames.length != 0) {
              fullyQualifiedEnclosingTypeOrPackageName=CharOperation.concat(packageName,flatEnclosingTypeNames,'.');
            }
 else {
              fullyQualifiedEnclosingTypeOrPackageName=packageName;
            }
          }
          if (CharOperation.equals(fullyQualifiedEnclosingTypeOrPackageName,importFlatName)) {
            acceptedType.qualifiedTypeName=typeName;
            acceptedType.fullyQualifiedName=fullyQualifiedName;
            onDemandFound.put(simpleTypeName,acceptedType);
            continue next;
          }
        }
        char[] packName=fullyQualifiedEnclosingTypeOrPackageName != null ? fullyQualifiedEnclosingTypeOrPackageName : packageName;
        proposals.add(proposeType(packName,simpleTypeName,modifiers,accessibility,typeName,fullyQualifiedName,true));
      }
    }
    char[][] keys=onDemandFound.keyTable;
    Object[] vals=onDemandFound.valueTable;
    for (int i=0; i < keys.length; i+=1) {
      if ((i % CHECK_CANCEL_FREQUENCY) == 0)       checkCancel();
      if (keys[i] != null) {
        AcceptedType value=(AcceptedType)vals[i];
        if (value != null) {
          proposals.add(proposeType(value.packageName,value.simpleTypeName,value.modifiers,value.accessibility,value.qualifiedTypeName,value.fullyQualifiedName,value.mustBeQualified));
        }
      }
    }
  }
  finally {
    this.acceptedTypes=null;
  }
  return proposals;
}",0.898850035203004
185604,"private boolean isArgument(Expression expr,List<? extends Expression> args){
  if (args != null && !args.isEmpty()) {
    for (    Expression arg : args) {
      if (arg instanceof NamedArgumentListExpression) {
        return isArgument(expr,((NamedArgumentListExpression)arg).getMapEntryExpressions());
      }
      if (arg == expr) {
        return true;
      }
    }
  }
  return false;
}","private boolean isArgument(Expression expr,List<? extends Expression> args){
  if (args != null && !args.isEmpty()) {
    for (    Expression arg : args) {
      if (arg == expr) {
        return true;
      }
      if (arg instanceof NamedArgumentListExpression) {
        return isArgument(expr,((NamedArgumentListExpression)arg).getMapEntryExpressions());
      }
    }
  }
  return false;
}",0.8121827411167513
185605,"public List<IGroovyProposal> getStatementAndExpressionProposals(ContentAssistContext context,ClassNode completionType,boolean isStatic,Set<ClassNode> categories){
  String event=null;
  if (GroovyLogManager.manager.hasLoggers()) {
    GroovyLogManager.manager.log(TraceCategory.DSL,""String_Node_Str"" + context.fullCompletionExpression);
    event=""String_Node_Str"";
    GroovyLogManager.manager.logStart(event);
  }
  List<IContributionElement> contributions;
  List<IGroovyProposal> proposals=new ArrayList<IGroovyProposal>();
  try {
    DSLDStore store=GroovyDSLCoreActivator.getDefault().getContextStoreManager().getDSLDStore(context.unit.getJavaProject());
    ModuleNodeInfo info=context.unit.getModuleInfo(true);
    if (info == null) {
      if (GroovyLogManager.manager.hasLoggers()) {
        GroovyLogManager.manager.log(TraceCategory.CONTENT_ASSIST,""String_Node_Str"" + context.unit.getElementName());
      }
      return Collections.EMPTY_LIST;
    }
    GroovyDSLDContext pattern=new GroovyDSLDContext(context.unit,info.module,info.resolver);
    pattern.setCurrentScope(context.currentScope);
    pattern.setTargetType(completionType);
    pattern.setStatic(isStatic);
    pattern.setPrimaryNode(context.location == ContentAssistLocation.STATEMENT || (context.location == ContentAssistLocation.METHOD_CONTEXT && context.currentScope.isPrimaryNode()));
    contributions=store.findContributions(pattern,DSLPreferences.getDisabledScriptsAsSet());
    boolean isMethodContext=context instanceof MethodInfoContentAssistContext;
    for (    IContributionElement element : contributions) {
      if (element.contributionName().startsWith(context.getPerceivedCompletionExpression())) {
        IGroovyProposal proposal=element.toProposal(completionType,pattern.getResolverCache());
        if (proposal != null) {
          proposals.add(proposal);
        }
        if (isMethodContext) {
          proposals.addAll(element.extraProposals(completionType,pattern.getResolverCache(),(Expression)((MethodInfoContentAssistContext)context).completionNode));
        }
      }
    }
  }
 catch (  CoreException e) {
    GroovyDSLCoreActivator.logException(e);
  }
  if (event != null) {
    GroovyLogManager.manager.logEnd(event,TraceCategory.DSL);
  }
  return proposals;
}","public List<IGroovyProposal> getStatementAndExpressionProposals(ContentAssistContext context,ClassNode completionType,boolean isStatic,Set<ClassNode> categories){
  String event=null;
  if (GroovyLogManager.manager.hasLoggers()) {
    GroovyLogManager.manager.log(TraceCategory.DSL,""String_Node_Str"" + context.fullCompletionExpression);
    event=""String_Node_Str"";
    GroovyLogManager.manager.logStart(event);
  }
  List<IContributionElement> contributions;
  List<IGroovyProposal> proposals=new ArrayList<IGroovyProposal>();
  try {
    DSLDStore store=GroovyDSLCoreActivator.getDefault().getContextStoreManager().getDSLDStore(context.unit.getJavaProject());
    ModuleNodeInfo info=context.unit.getModuleInfo(true);
    if (info == null) {
      if (GroovyLogManager.manager.hasLoggers()) {
        GroovyLogManager.manager.log(TraceCategory.CONTENT_ASSIST,""String_Node_Str"" + context.unit.getElementName());
      }
      return Collections.EMPTY_LIST;
    }
    GroovyDSLDContext pattern=new GroovyDSLDContext(context.unit,info.module,info.resolver);
    pattern.setCurrentScope(context.currentScope);
    pattern.setTargetType(completionType);
    pattern.setStatic(isStatic);
    pattern.setPrimaryNode(context.location == ContentAssistLocation.STATEMENT || (context.location == ContentAssistLocation.METHOD_CONTEXT && context.currentScope.isPrimaryNode()));
    contributions=store.findContributions(pattern,DSLPreferences.getDisabledScriptsAsSet());
    boolean isMethodContext=(context instanceof MethodInfoContentAssistContext);
    for (    IContributionElement element : contributions) {
      if (element.contributionName().startsWith(context.getPerceivedCompletionExpression())) {
        IGroovyProposal proposal=element.toProposal(completionType,pattern.getResolverCache());
        if (proposal != null) {
          proposals.add(proposal);
        }
        if (isMethodContext) {
          proposals.addAll(element.extraProposals(completionType,pattern.getResolverCache(),(Expression)((MethodInfoContentAssistContext)context).completionNode));
        }
      }
    }
  }
 catch (  CoreException e) {
    GroovyDSLCoreActivator.logException(e);
  }
  if (event != null) {
    GroovyLogManager.manager.logEnd(event,TraceCategory.DSL);
  }
  return proposals;
}",0.9995612110574812
185606,"private void initializeMembers(){
  if (jdtBinding instanceof SourceTypeBinding) {
    SourceTypeBinding sourceType=(SourceTypeBinding)jdtBinding;
    if (sourceType.scope != null) {
      TypeDeclaration typeDecl=sourceType.scope.referenceContext;
      if (typeDecl instanceof GroovyTypeDeclaration) {
        groovyDecl=typeDecl;
      }
    }
  }
  if (redirect != null) {
    return;
  }
  MethodBinding[] bindings=null;
  if (jdtBinding instanceof ParameterizedTypeBinding) {
    ReferenceBinding genericType=((ParameterizedTypeBinding)jdtBinding).genericType();
    bindings=genericType.methods();
  }
 else {
    bindings=jdtBinding.methods();
  }
  if (bindings != null) {
    for (int i=0; i < bindings.length; i++) {
      if (bindings[i].isConstructor()) {
        ConstructorNode cNode=constructorBindingToConstructorNode(bindings[i]);
        addConstructor(cNode);
      }
 else {
        MethodNode mNode=methodBindingToMethodNode(bindings[i]);
        addMethod(mNode);
      }
    }
  }
  if (jdtBinding instanceof BinaryTypeBinding) {
    MethodBinding[] infraBindings=((BinaryTypeBinding)jdtBinding).infraMethods();
    for (int i=0; i < infraBindings.length; i++) {
      if (infraBindings[i].isConstructor()) {
        ConstructorNode cNode=constructorBindingToConstructorNode(infraBindings[i]);
        addConstructor(cNode);
      }
 else {
        MethodNode mNode=methodBindingToMethodNode(infraBindings[i]);
        addMethod(mNode);
      }
    }
  }
  if (jdtBinding instanceof SourceTypeBinding) {
    SourceTypeBinding jdtSourceTypeBinding=(SourceTypeBinding)jdtBinding;
    ClassScope classScope=jdtSourceTypeBinding.scope;
    if (classScope != null) {
      CompilationUnitScope cuScope=classScope.compilationUnitScope();
      LookupEnvironment environment=classScope.environment();
      MethodVerifier verifier=environment.methodVerifier();
      cuScope.verifyMethods(verifier);
    }
    SyntheticMethodBinding[] syntheticMethodBindings=((SourceTypeBinding)jdtBinding).syntheticMethods();
    if (syntheticMethodBindings != null) {
      for (int i=0; i < syntheticMethodBindings.length; i++) {
        if (syntheticMethodBindings[i].isConstructor()) {
          ConstructorNode cNode=constructorBindingToConstructorNode(bindings[i]);
          addConstructor(cNode);
        }
 else {
          MethodNode mNode=methodBindingToMethodNode(syntheticMethodBindings[i]);
          addMethod(mNode);
        }
      }
    }
  }
  FieldBinding[] fieldBindings=null;
  if (jdtBinding instanceof ParameterizedTypeBinding) {
    fieldBindings=((ParameterizedTypeBinding)jdtBinding).genericType().fields();
  }
 else {
    fieldBindings=jdtBinding.fields();
  }
  if (fieldBindings != null) {
    for (int i=0; i < fieldBindings.length; i++) {
      FieldNode fNode=fieldBindingToFieldNode(fieldBindings[i],groovyDecl);
      addField(fNode);
    }
  }
}","private void initializeMembers(){
  if (jdtBinding instanceof SourceTypeBinding) {
    SourceTypeBinding sourceType=(SourceTypeBinding)jdtBinding;
    if (sourceType.scope != null) {
      TypeDeclaration typeDecl=sourceType.scope.referenceContext;
      if (typeDecl instanceof GroovyTypeDeclaration) {
        groovyDecl=typeDecl;
      }
    }
  }
  if (redirect != null) {
    return;
  }
  MethodBinding[] methodBindings;
  if (jdtBinding instanceof ParameterizedTypeBinding) {
    ReferenceBinding genericType=((ParameterizedTypeBinding)jdtBinding).genericType();
    methodBindings=genericType.methods();
  }
 else {
    methodBindings=jdtBinding.methods();
  }
  if (methodBindings != null) {
    for (    MethodBinding methodBinding : methodBindings) {
      if (methodBinding.isConstructor()) {
        ConstructorNode cNode=constructorBindingToConstructorNode(methodBinding);
        addConstructor(cNode);
      }
 else {
        MethodNode mNode=methodBindingToMethodNode(methodBinding);
        addMethod(mNode);
      }
    }
  }
  if (jdtBinding instanceof BinaryTypeBinding) {
    MethodBinding[] infraBindings=((BinaryTypeBinding)jdtBinding).infraMethods();
    for (    MethodBinding methodBinding : infraBindings) {
      if (methodBinding.isConstructor()) {
        ConstructorNode cNode=constructorBindingToConstructorNode(methodBinding);
        addConstructor(cNode);
      }
 else {
        MethodNode mNode=methodBindingToMethodNode(methodBinding);
        addMethod(mNode);
      }
    }
  }
 else   if (jdtBinding instanceof SourceTypeBinding) {
    SourceTypeBinding jdtSourceTypeBinding=(SourceTypeBinding)jdtBinding;
    ClassScope classScope=jdtSourceTypeBinding.scope;
    if (classScope != null) {
      CompilationUnitScope cuScope=classScope.compilationUnitScope();
      LookupEnvironment environment=classScope.environment();
      MethodVerifier verifier=environment.methodVerifier();
      cuScope.verifyMethods(verifier);
    }
    if (jdtSourceTypeBinding.isPrototype()) {
      SyntheticMethodBinding[] syntheticMethodBindings=jdtSourceTypeBinding.syntheticMethods();
      if (syntheticMethodBindings != null) {
        for (        SyntheticMethodBinding syntheticBinding : syntheticMethodBindings) {
          if (syntheticBinding.isConstructor()) {
            ConstructorNode cNode=constructorBindingToConstructorNode(syntheticBinding);
            addConstructor(cNode);
          }
 else {
            MethodNode mNode=methodBindingToMethodNode(syntheticBinding);
            addMethod(mNode);
          }
        }
      }
    }
  }
  FieldBinding[] fieldBindings;
  if (jdtBinding instanceof ParameterizedTypeBinding) {
    fieldBindings=((ParameterizedTypeBinding)jdtBinding).genericType().fields();
  }
 else {
    fieldBindings=jdtBinding.fields();
  }
  if (fieldBindings != null) {
    for (    FieldBinding fieldBinding : fieldBindings) {
      FieldNode fNode=fieldBindingToFieldNode(fieldBinding,groovyDecl);
      addField(fNode);
    }
  }
}",0.5761848139969424
185607,"/** 
 * Basic initialization of the node - try and do most resolution lazily but some elements are worth getting correct up front: superclass, superinterfaces
 */
void initialize(){
  if (beingInitialized) {
    return;
  }
  try {
    beingInitialized=true;
    if (!jdtBinding.isInterface()) {
      ReferenceBinding superClass=jdtBinding.superclass();
      if (superClass != null) {
        setUnresolvedSuperClass(resolver.convertToClassNode(superClass));
      }
    }
    ReferenceBinding[] superInterfaceBindings=jdtBinding.superInterfaces();
    superInterfaceBindings=superInterfaceBindings == null ? Binding.NO_SUPERINTERFACES : superInterfaceBindings;
    ClassNode[] interfaces=new ClassNode[superInterfaceBindings.length];
    for (int i=0; i < superInterfaceBindings.length; i++) {
      interfaces[i]=resolver.convertToClassNode(superInterfaceBindings[i]);
    }
    setInterfaces(interfaces);
    initializeMembers();
  }
  finally {
    beingInitialized=false;
  }
}","/** 
 * Basic initialization of the node - try and do most resolution lazily but some elements are worth getting correct up front: superclass, superinterfaces
 */
void initialize(){
  if (beingInitialized) {
    return;
  }
  try {
    beingInitialized=true;
    if (!jdtBinding.isInterface()) {
      ReferenceBinding superClass=jdtBinding.superclass();
      if (superClass != null) {
        setUnresolvedSuperClass(resolver.convertToClassNode(superClass));
      }
    }
    ReferenceBinding[] superInterfaceBindings=jdtBinding.superInterfaces();
    if (superInterfaceBindings == null)     superInterfaceBindings=Binding.NO_SUPERINTERFACES;
    int n=superInterfaceBindings.length;
    ClassNode[] interfaces=new ClassNode[n];
    for (int i=0; i < n; i+=1) {
      interfaces[i]=resolver.convertToClassNode(superInterfaceBindings[i]);
    }
    setInterfaces(interfaces);
    initializeMembers();
  }
  finally {
    beingInitialized=false;
  }
}",0.871900826446281
185608,"/** 
 * https://github.com/groovy/groovy-eclipse/issues/174 java.lang.NullPointerException at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) at com.sun.beans.TypeResolver.resolve(TypeResolver.java:162) at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81) at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370) at java.beans.Introspector.getTargetEventInfo(Introspector.java:1052) at java.beans.Introspector.getBeanInfo(Introspector.java:427) at java.beans.Introspector.getBeanInfo(Introspector.java:173) at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290) at java.security.AccessController.doPrivileged(Native Method) at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288) at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3265) at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:254) at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285) at MIData.$getStaticMetaClass(MIData.groovy) at MIData.<init>(MIData.groovy) at Main.main(Main.groovy:3)
 */
@Test public void testExtendingGenerics_GroovyExtendsJava14(){
  assumeTrue(isAtLeastGroovy(20));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runWarningFreeTest(sources);
}","/** 
 * https://github.com/groovy/groovy-eclipse/issues/174 java.lang.NullPointerException at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) at com.sun.beans.TypeResolver.resolve(TypeResolver.java:162) at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81) at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370) at java.beans.Introspector.getTargetEventInfo(Introspector.java:1052) at java.beans.Introspector.getBeanInfo(Introspector.java:427) at java.beans.Introspector.getBeanInfo(Introspector.java:173) at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290) at java.security.AccessController.doPrivileged(Native Method) at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288) at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3265) at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:254) at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285) at MIData.$getStaticMetaClass(MIData.groovy) at MIData.<init>(MIData.groovy) at Main.main(Main.groovy:3)
 */
@Test @Ignore public void testExtendingGenerics_GroovyExtendsJava14(){
  assumeTrue(isAtLeastGroovy(20));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources,""String_Node_Str"");
}",0.9870206489675516
185609,"protected String wrapHTML(JavadocBrowserInformationControlInput input,IGroovyResolvedElement elt){
  String preamble;
  if (!elt.getElementName().equals(elt.getInferredElementName())) {
    preamble=createLabel(elt.getInferredElement());
  }
 else {
    preamble=""String_Node_Str"";
  }
  if (elt.getExtraDoc() != null) {
    String wrapped=preamble + extraDocAsHtml(elt) + ""String_Node_Str""+ input.getHtml();
    return wrapped;
  }
 else {
    return preamble + input.getHtml();
  }
}","protected String wrapHTML(JavadocBrowserInformationControlInput input,IGroovyResolvedElement elt){
  String preamble;
  if (!elt.getElementName().equals(elt.getInferredElementName())) {
    preamble=createLabel(elt.getInferredElement());
  }
 else {
    preamble=""String_Node_Str"";
  }
  if (elt.getExtraDoc() != null) {
    return preamble + extraDocAsHtml(elt) + ""String_Node_Str""+ input.getHtml();
  }
 else {
    return preamble + input.getHtml();
  }
}",0.8556263269639066
185610,"protected String extraDocAsHtml(IGroovyResolvedElement elt){
  String extraDoc=""String_Node_Str"" + elt.getExtraDoc() + ""String_Node_Str"";
  if (!extraDoc.startsWith(""String_Node_Str"")) {
    extraDoc=""String_Node_Str"" + extraDoc;
  }
  if (!extraDoc.endsWith(""String_Node_Str"")) {
    extraDoc=extraDoc + ""String_Node_Str"";
  }
  return (String)ReflectionUtils.executePrivateMethod(JavadocContentAccess2.class,""String_Node_Str"",new Class[]{IMember.class,String.class},null,new Object[]{elt,extraDoc});
}","protected String extraDocAsHtml(IGroovyResolvedElement elem){
  String extraDoc=elem.getExtraDoc();
  if (!extraDoc.startsWith(""String_Node_Str"")) {
    extraDoc=""String_Node_Str"" + extraDoc;
  }
  if (!extraDoc.endsWith(""String_Node_Str"")) {
    extraDoc=extraDoc + ""String_Node_Str"";
  }
  String html;
  try {
    html=(String)ReflectionUtils.throwableExecutePrivateMethod(JavadocContentAccess2.class,""String_Node_Str"",new Class[]{IMember.class,IJavaElement.class,String.class},null,new Object[]{elem,elem,extraDoc});
  }
 catch (  Exception e) {
    html=(String)ReflectionUtils.executePrivateMethod(JavadocContentAccess2.class,""String_Node_Str"",new Class[]{IMember.class,String.class},null,new Object[]{elem,extraDoc});
  }
  return html;
}",0.3830128205128205
185611,"private String createClassLabel(ClassNode node){
  StringBuilder sb=new StringBuilder();
  node=node.redirect();
  if (ClassHelper.DYNAMIC_TYPE == node) {
    return ""String_Node_Str"";
  }
  sb.append(node.getNameWithoutPackage());
  GenericsType[] genericsTypes=node.getGenericsTypes();
  if (genericsTypes != null && genericsTypes.length > 0) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < genericsTypes.length; i++) {
      sb.append(genericsTypes[i].getName());
      if (i < genericsTypes.length - 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","private String createClassLabel(ClassNode node){
  StringBuilder sb=new StringBuilder();
  node=node.redirect();
  if (ClassHelper.DYNAMIC_TYPE == node) {
    return ""String_Node_Str"";
  }
  sb.append(node.getNameWithoutPackage());
  GenericsType[] generics=node.getGenericsTypes();
  if (generics != null && generics.length > 0) {
    sb.append(""String_Node_Str"");
    for (int i=0, n=generics.length; i < n; i+=1) {
      sb.append(generics[i].getName());
      if (i < generics.length - 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.8006430868167203
185612,"/** 
 * Possibly compute the hover. Might return null.
 */
private Object computeHover(IRegion hoverRegion,IJavaElement[] elements){
  Object hover;
  hover=ReflectionUtils.executePrivateMethod(JavadocHover.class,""String_Node_Str"",new Class[]{IJavaElement[].class,ITypeRoot.class,IRegion.class,JavadocBrowserInformationControlInput.class},this,new Object[]{elements,getEditorInputJavaElement(),hoverRegion,null});
  if (hover instanceof JavadocBrowserInformationControlInput && elements[0] instanceof IGroovyResolvedElement) {
    JavadocBrowserInformationControlInput input=(JavadocBrowserInformationControlInput)hover;
    hover=new JavadocBrowserInformationControlInput((JavadocBrowserInformationControlInput)input.getPrevious(),input.getElement(),wrapHTML(input,(IGroovyResolvedElement)elements[0]),input.getLeadingImageWidth());
  }
  return hover;
}","/** 
 * Possibly compute the hover. Might return null.
 */
private Object computeHover(IRegion hoverRegion,IJavaElement[] elements){
  JavadocBrowserInformationControlInput hover=getHoverInfo(elements,getEditorInputJavaElement(),hoverRegion,null);
  if (hover != null && elements[0] instanceof IGroovyResolvedElement) {
    hover=new JavadocBrowserInformationControlInput((JavadocBrowserInformationControlInput)hover.getPrevious(),hover.getElement(),wrapHTML(hover,(IGroovyResolvedElement)elements[0]),hover.getLeadingImageWidth());
  }
  return hover;
}",0.5691980127750177
185613,"private String createMethodLabel(MethodNode node){
  StringBuilder sb=new StringBuilder();
  sb.append(createClassLabel(node.getReturnType()));
  sb.append(""String_Node_Str"");
  sb.append(createClassLabel(node.getDeclaringClass()));
  sb.append(""String_Node_Str"");
  sb.append(node.getName());
  sb.append(""String_Node_Str"");
  Parameter[] params=node.getParameters();
  if (params != null) {
    for (int i=0; i < params.length; i++) {
      sb.append(createClassLabel(params[i].getType()));
      sb.append(""String_Node_Str"" + params[i].getName());
      if (i < params.length - 1) {
        sb.append(""String_Node_Str"");
      }
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String createMethodLabel(MethodNode node){
  StringBuilder sb=new StringBuilder();
  sb.append(createClassLabel(node.getReturnType()));
  sb.append(""String_Node_Str"");
  sb.append(createClassLabel(node.getDeclaringClass()));
  sb.append(""String_Node_Str"");
  sb.append(node.getName());
  sb.append(""String_Node_Str"");
  Parameter[] params=node.getParameters();
  if (params != null) {
    for (int i=0, n=params.length; i < n; i+=1) {
      sb.append(createClassLabel(params[i].getType()));
      sb.append(""String_Node_Str"" + params[i].getName());
      if (i < params.length - 1) {
        sb.append(""String_Node_Str"");
      }
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9757834757834758
185614,"public GroovyParser(Object requestor,CompilerOptions options,ProblemReporter problemReporter,boolean allowTransforms,boolean isReconcile){
  this.requestor=requestor;
  this.compilerOptions=options;
  this.problemReporter=problemReporter;
  this.projectName=options.groovyProjectName;
  this.gclClasspath=(options == null ? null : options.groovyClassLoaderPath);
  GroovyClassLoader gcl=getLoaderFor(this.gclClasspath);
  GrapeAwareGroovyClassLoader grabbyLoader=new GrapeAwareGroovyClassLoader(gcl);
  this.compilationUnit=makeCompilationUnit(grabbyLoader,gcl,isReconcile,allowTransforms);
  this.compilationUnit.removeOutputPhaseOperation();
}","public GroovyParser(Object requestor,CompilerOptions compilerOptions,ProblemReporter problemReporter,boolean allowTransforms,boolean isReconcile){
  this.requestor=requestor;
  this.compilerOptions=compilerOptions;
  this.problemReporter=problemReporter;
  this.projectName=compilerOptions.groovyProjectName;
  this.gclClasspath=compilerOptions.groovyClassLoaderPath;
  GroovyClassLoader gcl=getLoaderFor(gclClasspath);
  GrapeAwareGroovyClassLoader grabbyLoader=new GrapeAwareGroovyClassLoader(gcl);
  this.compilationUnit=makeCompilationUnit(grabbyLoader,gcl,isReconcile,allowTransforms);
  this.compilationUnit.removeOutputPhaseOperation();
}",0.8418604651162791
185615,"/** 
 * Returns a list of markers that exist at the current ruler location.
 * @return a list of markers that exist at the current ruler location
 */
protected List<IMarker> getMarkers(){
  List<IMarker> breakpoints=new ArrayList<IMarker>();
  IResource resource=getResource();
  IDocument document=getDocument();
  AbstractMarkerAnnotationModel model=getAnnotationModel();
  if (model != null) {
    try {
      IMarker[] markers=null;
      if (resource instanceof IFile)       markers=resource.findMarkers(IBreakpoint.BREAKPOINT_MARKER,true,IResource.DEPTH_INFINITE);
 else {
        IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
        markers=root.findMarkers(IBreakpoint.BREAKPOINT_MARKER,true,IResource.DEPTH_INFINITE);
      }
      if (markers != null) {
        IBreakpointManager breakpointManager=DebugPlugin.getDefault().getBreakpointManager();
        for (int i=0; i < markers.length; i++) {
          IBreakpoint breakpoint=breakpointManager.getBreakpoint(markers[i]);
          if (breakpoint != null && breakpointManager.isRegistered(breakpoint) && includesRulerLine(model.getMarkerPosition(markers[i]),document))           breakpoints.add(markers[i]);
        }
      }
    }
 catch (    CoreException x) {
      JDIDebugUIPlugin.log(x.getStatus());
    }
  }
  return breakpoints;
}","/** 
 * Returns a list of markers that exist at the current ruler location.
 */
protected List<IMarker> getMarkers(){
  List<IMarker> breakpoints=Collections.emptyList();
  try {
    IEditorInput editorInput=fTextEditor.getEditorInput();
    IDocumentProvider provider=fTextEditor.getDocumentProvider();
    IAnnotationModel model=provider.getAnnotationModel(editorInput);
    if (model instanceof AbstractMarkerAnnotationModel) {
      IMarker[] markers;
      if (editorInput instanceof IFileEditorInput) {
        markers=((IFileEditorInput)editorInput).getFile().findMarkers(IBreakpoint.BREAKPOINT_MARKER,true,IResource.DEPTH_INFINITE);
      }
 else {
        markers=ResourcesPlugin.getWorkspace().getRoot().findMarkers(IBreakpoint.BREAKPOINT_MARKER,true,IResource.DEPTH_INFINITE);
      }
      if (markers != null) {
        IDocument document=provider.getDocument(editorInput);
        IBreakpointManager breakpointManager=DebugPlugin.getDefault().getBreakpointManager();
        for (        IMarker marker : markers) {
          IBreakpoint breakpoint=breakpointManager.getBreakpoint(marker);
          if (breakpoint != null && breakpointManager.isRegistered(breakpoint) && includesRulerLine(((AbstractMarkerAnnotationModel)model).getMarkerPosition(marker),document)) {
            if (breakpoints.isEmpty())             breakpoints=new ArrayList<IMarker>();
            breakpoints.add(marker);
          }
        }
      }
    }
  }
 catch (  CoreException e) {
    JDIDebugUIPlugin.log(e.getStatus());
  }
catch (  Throwable t) {
    JDIDebugUIPlugin.log(t);
  }
  return breakpoints;
}",0.655255049640534
185616,"/** 
 * Disposes this action
 */
public void dispose(){
  fTextEditor=null;
  fRuler=null;
}","public void dispose(){
  fTextEditor=null;
  fRuler=null;
}",0.7814569536423841
185617,"@Override @SuppressWarnings(""String_Node_Str"") public IContentAssistant getContentAssistant(ISourceViewer sourceViewer){
  ContentAssistant assistant=(ContentAssistant)super.getContentAssistant(sourceViewer);
  ContentAssistProcessor stringProcessor=new JavaCompletionProcessor(getEditor(),assistant,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  assistant.setContentAssistProcessor(stringProcessor,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  IContentAssistProcessor processor=assistant.getContentAssistProcessor(IDocument.DEFAULT_CONTENT_TYPE);
  List<CompletionProposalCategory> categories=(List<CompletionProposalCategory>)ReflectionUtils.getPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor);
  List<CompletionProposalCategory> newCategories=new ArrayList<CompletionProposalCategory>(categories.size() - 1);
  for (  CompletionProposalCategory category : categories) {
    if (!JAVA_CONTENT_ASSIST.matcher(category.getId()).matches()) {
      newCategories.add(category);
    }
  }
  ReflectionUtils.setPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor,newCategories);
  return assistant;
}","@Override @SuppressWarnings(""String_Node_Str"") public IContentAssistant getContentAssistant(ISourceViewer sourceViewer){
  ContentAssistant assistant=(ContentAssistant)super.getContentAssistant(sourceViewer);
  String contentType=GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS;
  assistant.setContentAssistProcessor(new JavaCompletionProcessor(getEditor(),assistant,contentType),contentType);
  IContentAssistProcessor processor=assistant.getContentAssistProcessor(IDocument.DEFAULT_CONTENT_TYPE);
  List<CompletionProposalCategory> categories=(List<CompletionProposalCategory>)ReflectionUtils.getPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor);
  List<CompletionProposalCategory> newCategories=new ArrayList<CompletionProposalCategory>();
  for (  CompletionProposalCategory category : categories) {
    if (GROOVY_CONTENT_ASSIST.matcher(category.getId()).matches()) {
      newCategories.add(category);
    }
  }
  ReflectionUtils.setPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor,newCategories);
  return assistant;
}",0.3757904245709124
185618,"@Override @SuppressWarnings(""String_Node_Str"") public IContentAssistant getContentAssistant(ISourceViewer sourceViewer){
  ContentAssistant assistant=(ContentAssistant)super.getContentAssistant(sourceViewer);
  ContentAssistProcessor stringProcessor=new JavaCompletionProcessor(getEditor(),assistant,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  assistant.setContentAssistProcessor(stringProcessor,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  IContentAssistProcessor processor=assistant.getContentAssistProcessor(IDocument.DEFAULT_CONTENT_TYPE);
  List<CompletionProposalCategory> categories=(List<CompletionProposalCategory>)ReflectionUtils.getPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor);
  List<CompletionProposalCategory> newCategories=new ArrayList<CompletionProposalCategory>(categories.size() - 1);
  for (  CompletionProposalCategory category : categories) {
    if (!category.getId().equals(""String_Node_Str"") && !category.getId().equals(""String_Node_Str"") && !category.getId().equals(""String_Node_Str"")&& !category.getId().equals(""String_Node_Str"")&& !category.getId().equals(""String_Node_Str"")&& !category.getId().equals(""String_Node_Str"")&& !category.getId().equals(""String_Node_Str"")) {
      newCategories.add(category);
    }
  }
  ReflectionUtils.setPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor,newCategories);
  return assistant;
}","@Override @SuppressWarnings(""String_Node_Str"") public IContentAssistant getContentAssistant(ISourceViewer sourceViewer){
  ContentAssistant assistant=(ContentAssistant)super.getContentAssistant(sourceViewer);
  ContentAssistProcessor stringProcessor=new JavaCompletionProcessor(getEditor(),assistant,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  assistant.setContentAssistProcessor(stringProcessor,GroovyPartitionScanner.GROOVY_MULTILINE_STRINGS);
  IContentAssistProcessor processor=assistant.getContentAssistProcessor(IDocument.DEFAULT_CONTENT_TYPE);
  List<CompletionProposalCategory> categories=(List<CompletionProposalCategory>)ReflectionUtils.getPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor);
  List<CompletionProposalCategory> newCategories=new ArrayList<CompletionProposalCategory>(categories.size() - 1);
  for (  CompletionProposalCategory category : categories) {
    if (!JAVA_CONTENT_ASSIST.matcher(category.getId()).matches()) {
      newCategories.add(category);
    }
  }
  ReflectionUtils.setPrivateField(ContentAssistProcessor.class,""String_Node_Str"",processor,newCategories);
  return assistant;
}",0.8667448221961703
185619,"@Test public void testTypeChecked4(){
  assumeTrue(isAtLeastGroovy(21));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources);
}","@Test public void testTypeChecked4(){
  assumeTrue(isAtLeastGroovy(24));
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources);
}",0.9963636363636365
185620,"public GroovyConfiguration(GroovyColorManager colorManager,IPreferenceStore preferenceStore,ITextEditor editor){
  super(colorManager,preferenceStore,editor,IJavaPartitions.JAVA_PARTITIONING);
  AbstractJavaScanner stringScanner=new SingleTokenJavaScanner(colorManager,preferenceStore,GROOVY_EDITOR_HIGHLIGHT_STRINGS_COLOR);
  ReflectionUtils.setPrivateField(JavaSourceViewerConfiguration.class,""String_Node_Str"",this,stringScanner);
  try {
    IProject project=null;
    if (editor != null && editor instanceof GroovyEditor) {
      IEditorInput input=((GroovyEditor)editor).internalInput;
      if (input instanceof FileEditorInput) {
        project=((FileEditorInput)input).getFile().getProject();
      }
    }
    HighlightingExtenderRegistry registry=GroovyPlugin.getDefault().getTextTools().getHighlightingExtenderRegistry();
    AbstractJavaScanner codeScanner=new GroovyTagScanner(colorManager,registry.getInitialAdditionalRulesForProject(project),registry.getAdditionalRulesForProject(project),registry.getExtraGroovyKeywordsForProject(project),registry.getExtraGJDKKeywordsForProject(project));
    ReflectionUtils.setPrivateField(JavaSourceViewerConfiguration.class,""String_Node_Str"",this,codeScanner);
  }
 catch (  CoreException e) {
    GroovyCore.logException(""String_Node_Str"",e);
  }
}","public GroovyConfiguration(GroovyColorManager colorManager,IPreferenceStore preferenceStore,ITextEditor editor){
  super(colorManager,preferenceStore,editor,IJavaPartitions.JAVA_PARTITIONING);
  AbstractJavaScanner stringScanner=new SingleTokenJavaScanner(colorManager,preferenceStore,GROOVY_EDITOR_HIGHLIGHT_STRINGS_COLOR);
  ReflectionUtils.setPrivateField(JavaSourceViewerConfiguration.class,""String_Node_Str"",this,stringScanner);
  try {
    IProject project=null;
    if (editor != null && editor instanceof GroovyEditor) {
      if (editor.getEditorInput() instanceof FileEditorInput) {
        project=((FileEditorInput)editor.getEditorInput()).getFile().getProject();
      }
    }
    HighlightingExtenderRegistry registry=GroovyPlugin.getDefault().getTextTools().getHighlightingExtenderRegistry();
    AbstractJavaScanner codeScanner=new GroovyTagScanner(colorManager,registry.getInitialAdditionalRulesForProject(project),registry.getAdditionalRulesForProject(project),registry.getExtraGroovyKeywordsForProject(project),registry.getExtraGJDKKeywordsForProject(project));
    ReflectionUtils.setPrivateField(JavaSourceViewerConfiguration.class,""String_Node_Str"",this,codeScanner);
  }
 catch (  Exception e) {
    GroovyCore.logException(""String_Node_Str"",e);
  }
}",0.9236138037999224
185621,"private void installGroovySemanticHighlighting(){
  try {
    fSemanticManager.uninstall();
    semanticReconciler=new GroovySemanticReconciler();
    semanticReconciler.install(this,(JavaSourceViewer)this.getSourceViewer());
    ReflectionUtils.executePrivateMethod(CompilationUnitEditor.class,""String_Node_Str"",new Class[]{IJavaReconcilingListener.class},this,new Object[]{semanticReconciler});
  }
 catch (  SecurityException e) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",e);
  }
}","private void installGroovySemanticHighlighting(){
  try {
    fSemanticManager.uninstall();
    semanticReconciler=new GroovySemanticReconciler();
    semanticReconciler.install(this,(JavaSourceViewer)getSourceViewer());
    ReflectionUtils.executePrivateMethod(CompilationUnitEditor.class,""String_Node_Str"",new Class[]{IJavaReconcilingListener.class},this,new Object[]{semanticReconciler});
  }
 catch (  Throwable t) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",t);
  }
}",0.9625126646403244
185622,"private void uninstallGroovySemanticHighlighting(){
  if (semanticHighlightingInstalled()) {
    try {
      semanticReconciler.uninstall();
      ReflectionUtils.executePrivateMethod(CompilationUnitEditor.class,""String_Node_Str"",new Class[]{IJavaReconcilingListener.class},this,new Object[]{semanticReconciler});
      semanticReconciler=null;
    }
 catch (    SecurityException e) {
      GroovyPlugin.getDefault().logError(""String_Node_Str"",e);
    }
  }
}","private void uninstallGroovySemanticHighlighting(){
  if (semanticHighlightingInstalled()) {
    try {
      semanticReconciler.uninstall();
      ReflectionUtils.executePrivateMethod(CompilationUnitEditor.class,""String_Node_Str"",new Class[]{IJavaReconcilingListener.class},this,new Object[]{semanticReconciler});
      semanticReconciler=null;
    }
 catch (    Throwable t) {
      GroovyPlugin.getDefault().logError(""String_Node_Str"",t);
    }
  }
}",0.9649122807017544
185623,"@Override public void createPartControl(Composite parent){
  super.createPartControl(parent);
  unsetJavaBreakpointUpdater();
  installGroovySemanticHighlighting();
  IPreferenceStore preferenceStore=getPreferenceStore();
  boolean closeBrackets=preferenceStore.getBoolean(CLOSE_BRACKETS);
  boolean closeStrings=preferenceStore.getBoolean(CLOSE_STRINGS);
  boolean closeBraces=preferenceStore.getBoolean(CLOSE_BRACES);
  boolean closeAngularBrackets=JavaCore.VERSION_1_5.compareTo(preferenceStore.getString(JavaCore.COMPILER_SOURCE)) <= 0;
  groovyBracketInserter.setCloseBracketsEnabled(closeBrackets);
  groovyBracketInserter.setCloseStringsEnabled(closeStrings);
  groovyBracketInserter.setCloseAngularBracketsEnabled(closeAngularBrackets);
  groovyBracketInserter.setCloseBracesEnabled(closeBraces);
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer instanceof ITextViewerExtension) {
    ((ITextViewerExtension)sourceViewer).prependVerifyKeyListener(groovyBracketInserter);
  }
  disableBracketInserter();
}","@Override public void createPartControl(Composite parent){
  super.createPartControl(parent);
  unsetJavaBreakpointUpdater();
  installGroovySemanticHighlighting();
  IPreferenceStore preferenceStore=getPreferenceStore();
  groovyBracketInserter.setCloseBracesEnabled(preferenceStore.getBoolean(CLOSE_BRACES));
  groovyBracketInserter.setCloseBracketsEnabled(preferenceStore.getBoolean(CLOSE_BRACKETS));
  groovyBracketInserter.setCloseStringsEnabled(preferenceStore.getBoolean(CLOSE_STRINGS));
  groovyBracketInserter.setCloseAngularBracketsEnabled(preferenceStore.getString(JavaCore.COMPILER_SOURCE).compareTo(JavaCore.VERSION_1_5) >= 0);
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer instanceof ITextViewerExtension) {
    ((ITextViewerExtension)sourceViewer).prependVerifyKeyListener(groovyBracketInserter);
  }
  disableBracketInserter();
}",0.5896624472573839
185624,"/** 
 * Override this method so that we can get access to the newly initialized annotation model
 */
@Override protected void doSetInput(IEditorInput input) throws CoreException {
  try {
    internalInput=input;
    boolean wasInstalled=semanticHighlightingInstalled();
    if (wasInstalled) {
      uninstallGroovySemanticHighlighting();
    }
    super.doSetInput(input);
    unsetJavaBreakpointUpdater();
    if (wasInstalled) {
      installGroovySemanticHighlighting();
    }
  }
  finally {
    internalInput=null;
  }
}","@Override protected void doSetInput(IEditorInput input) throws CoreException {
  final boolean installed=semanticHighlightingInstalled();
  if (installed) {
    uninstallGroovySemanticHighlighting();
  }
  super.doSetInput(input);
  unsetJavaBreakpointUpdater();
  if (installed) {
    installGroovySemanticHighlighting();
  }
}",0.5941520467836258
185625,"/** 
 * Ensure that the Java breakpoint updater is removed because we need to use Groovy's breakpoint updater instead
 */
private void unsetJavaBreakpointUpdater(){
  try {
    ISourceViewer viewer=getSourceViewer();
    if (viewer != null) {
      IAnnotationModel model=viewer.getAnnotationModel();
      if (model instanceof AbstractMarkerAnnotationModel) {
        ReflectionUtils.executePrivateMethod(AbstractMarkerAnnotationModel.class,""String_Node_Str"",new Class[]{},model,new Object[]{});
        @SuppressWarnings(""String_Node_Str"") List<IConfigurationElement> updaterSpecs=(List<IConfigurationElement>)ReflectionUtils.getPrivateField(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model);
        for (Iterator<IConfigurationElement> specIter=updaterSpecs.iterator(); specIter.hasNext(); ) {
          IConfigurationElement spec=specIter.next();
          if (spec.getAttribute(""String_Node_Str"").equals(BreakpointMarkerUpdater.class.getCanonicalName())) {
            specIter.remove();
            break;
          }
        }
      }
    }
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",e);
  }
}","/** 
 * Ensures that the Java breakpoint updater is removed because we need to use Groovy's breakpoint updater instead.
 */
private void unsetJavaBreakpointUpdater(){
  try {
    ISourceViewer viewer=getSourceViewer();
    if (viewer != null) {
      IAnnotationModel model=viewer.getAnnotationModel();
      if (model instanceof AbstractMarkerAnnotationModel) {
        if (ReflectionUtils.getPrivateField(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model) == null) {
          ReflectionUtils.executeNoArgPrivateMethod(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model);
        }
        @SuppressWarnings(""String_Node_Str"") List<IConfigurationElement> updaterSpecs=(List<IConfigurationElement>)ReflectionUtils.getPrivateField(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model);
        for (Iterator<IConfigurationElement> specIter=updaterSpecs.iterator(); specIter.hasNext(); ) {
          IConfigurationElement spec=specIter.next();
          if (spec.getAttribute(""String_Node_Str"").equals(BreakpointMarkerUpdater.class.getCanonicalName())) {
            specIter.remove();
            break;
          }
        }
      }
    }
  }
 catch (  Throwable t) {
    GroovyPlugin.getDefault().logError(""String_Node_Str"",t);
  }
}",0.9130794701986756
185626,"@Override public void visitConstructorCallExpression(ConstructorCallExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    visitClassReference(node.getType());
    if (node.getArguments() instanceof TupleExpression && ((TupleExpression)node.getArguments()).getExpressions().size() == 1) {
      Expression arg=((TupleExpression)node.getArguments()).getExpressions().get(0);
      if (arg instanceof MapExpression) {
        enclosingConstructorCall=node;
      }
    }
    super.visitConstructorCallExpression(node);
  }
}","@Override public void visitConstructorCallExpression(ConstructorCallExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue) {
    visitClassReference(node.getType());
    if (node.getArguments() instanceof TupleExpression) {
      TupleExpression tuple=(TupleExpression)node.getArguments();
      if (isNotEmpty(tuple.getExpressions())) {
        if ((tuple.getExpressions().size() == 1 && tuple.getExpressions().get(0) instanceof MapExpression) || tuple.getExpression(tuple.getExpressions().size() - 1) instanceof NamedArgumentListExpression) {
          enclosingConstructorCall=node;
        }
      }
    }
    super.visitConstructorCallExpression(node);
  }
}",0.4531864673485444
185627,"/** 
 * <ul> <li> argument list (named or positional) <li> chained assignment, as in:   {@code a = b = 1}<li> multi-assignment, as in:   {@code def (a, b) = [1, 2]}</ul>
 */
@Override public void visitTupleExpression(TupleExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue && isNotEmpty(node.getExpressions())) {
    if (node instanceof ArgumentListExpression || node.getExpression(0) instanceof NamedArgumentListExpression) {
      super.visitTupleExpression(node);
    }
  }
}","/** 
 * <ul> <li> argument list (named or positional) <li> chained assignment, as in:   {@code a = b = 1}<li> multi-assignment, as in:   {@code def (a, b) = [1, 2]}</ul>
 */
@Override public void visitTupleExpression(TupleExpression node){
  boolean shouldContinue=handleSimpleExpression(node);
  if (shouldContinue && isNotEmpty(node.getExpressions())) {
    if (node instanceof ArgumentListExpression || node.getExpression(node.getExpressions().size() - 1) instanceof NamedArgumentListExpression) {
      super.visitTupleExpression(node);
    }
  }
}",0.9692451071761417
185628,"private ClassNode configureClass(BinaryTypeBinding type){
  if (type.id == TypeIds.T_JavaLangObject) {
    return ClassHelper.OBJECT_TYPE;
  }
 else   if (type.id == TypeIds.T_JavaLangString) {
    return ClassHelper.STRING_TYPE;
  }
 else   if (type.id == TypeIds.T_JavaLangClass) {
    return ClassHelper.CLASS_Type;
  }
  JDTClassNode jcn=new JDTClassNode(type,resolver);
  return jcn;
}","private ClassNode configureClass(BinaryTypeBinding type){
  if (type.id == TypeIds.T_JavaLangObject) {
    return ClassHelper.OBJECT_TYPE;
  }
 else   if (type.id == TypeIds.T_JavaLangString) {
    return ClassHelper.STRING_TYPE;
  }
  return new JDTClassNode(type,resolver);
}",0.7136431784107946
185629,"private ClassNode configureSourceType(SourceTypeBinding type){
  JDTClassNode jcn=new JDTClassNode(type,resolver);
  return jcn;
}","private ClassNode configureSourceType(SourceTypeBinding type){
  return new JDTClassNode(type,resolver);
}",0.8559322033898306
185630,"private String checkQualifiedType(TypeLookupResult result,IJavaElement enclosingElement) throws JavaModelException {
  if (result.declaration instanceof ClassNode || result.declaration instanceof ConstructorNode) {
    ClassNode type=result.type;
    if (type == null)     type=result.declaringType;
    if (type == null)     type=(ClassNode)result.declaration;
    int typeStart=startOffset(type), typeEnd=endOffset(type);
    type=GroovyUtils.getBaseType(type);
    if (typeEnd > 0) {
      String source=gunit.getSource().substring(typeStart,typeEnd);
      int nameStart=typeStart + source.indexOf(GroovyUtils.splitName(type)[1]);
      if (nameStart > typeStart && nameStart > selectRegion.getEnd() && selectRegion.getEnd() > typeStart) {
        String selected=gunit.getSource().substring(typeStart,selectRegion.getEnd());
        selected=selected.replaceAll(""String_Node_Str"",""String_Node_Str"");
        String qualifier=GroovyUtils.splitName(type)[0].replace('$','.');
        Pattern pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
        Matcher matcher=pattern.matcher(qualifier);
        if (matcher.find()) {
          return matcher.group();
        }
        pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
        matcher=pattern.matcher(qualifier);
        if (matcher.find()) {
          return qualifier.substring(0,matcher.end());
        }
        ImportNode alias=findImportAlias(selected,enclosingElement);
        if (alias != null) {
          selected=selected.replace(alias.getAlias(),alias.getType().getNameWithoutPackage());
          pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
          matcher=pattern.matcher(qualifier);
          if (matcher.find()) {
            return qualifier.substring(0,matcher.end());
          }
        }
      }
    }
  }
  return null;
}","private String checkQualifiedType(TypeLookupResult result,IJavaElement enclosingElement) throws JavaModelException {
  if (result.declaration instanceof ClassNode || result.declaration instanceof ConstructorNode) {
    ClassNode type=result.type;
    if (type == null)     type=result.declaringType;
    if (type == null)     type=(ClassNode)result.declaration;
    int typeStart=startOffset(type), typeEnd=endOffset(type);
    type=GroovyUtils.getBaseType(type);
    if (typeStart >= 0 && typeEnd > typeStart) {
      String gunitSource=gunit.getSource();
      if (typeEnd == gunitSource.length() + 1)       typeEnd=gunitSource.length();
 else       if (typeEnd > gunitSource.length())       return null;
      String source=gunitSource.substring(typeStart,typeEnd);
      int nameStart=typeStart + source.indexOf(GroovyUtils.splitName(type)[1]);
      if (nameStart > typeStart && nameStart > selectRegion.getEnd() && selectRegion.getEnd() > typeStart) {
        String selected=gunitSource.substring(typeStart,selectRegion.getEnd());
        selected=selected.replaceAll(""String_Node_Str"",""String_Node_Str"");
        String qualifier=GroovyUtils.splitName(type)[0].replace('$','.');
        Pattern pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
        Matcher matcher=pattern.matcher(qualifier);
        if (matcher.find()) {
          return matcher.group();
        }
        pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
        matcher=pattern.matcher(qualifier);
        if (matcher.find()) {
          return qualifier.substring(0,matcher.end());
        }
        ImportNode alias=findImportAlias(selected,enclosingElement);
        if (alias != null) {
          selected=selected.replace(alias.getAlias(),alias.getType().getNameWithoutPackage());
          pattern=Pattern.compile(""String_Node_Str"" + selected + ""String_Node_Str"");
          matcher=pattern.matcher(qualifier);
          if (matcher.find()) {
            return qualifier.substring(0,matcher.end());
          }
        }
      }
    }
  }
  return null;
}",0.9291813159216474
185631,"/** 
 * Splits the given expression into two parts: the type evaluation part, and the code completion part.
 * @param expression The expression returned by the {@link #findForCompletions(ISourceBuffer,int)} method.
 * @return A string pair, the expression to complete, and the prefix to becompleted.<br> { """", null } if no completion expression could be found String[0] is an expression .<br> String[1] is the empty string if the last character is a '.'.<br> String[1] is 'ident' if the expression ends with '.ident'.<br> String[1] is null if the expression itself is to be used for completion. Also, remove starting '$'. These only occur when inside GStrings, and should not be completed against.
 */
public String[] splitForCompletion(String expression){
  String[] split=splitForCompletionNoTrim(expression);
  if (split[0] != null) {
    split[0]=split[0].trim();
    if (split[0].startsWith(""String_Node_Str"")) {
      split[0]=split[0].substring(1);
    }
  }
  if (split[1] != null) {
    split[1]=split[1].trim();
    if (split[1].startsWith(""String_Node_Str"")) {
      split[1]=split[1].substring(1);
    }
  }
  return split;
}","/** 
 * Splits the given expression into two parts: the type evaluation part, and the code completion part.
 * @param expression returned by the {@link #findForCompletions(ISourceBuffer,int)} method
 * @return A string pair, the expression to complete, and the prefix to becompleted.<br> { """", null } if no completion expression could be found String[0] is an expression .<br> String[1] is the empty string if the last character is a '.'.<br> String[1] is 'ident' if the expression ends with '.ident'.<br> String[1] is null if the expression itself is to be used for completion. Also, remove starting '$'. These only occur when inside GStrings, and should not be completed against.
 */
public String[] splitForCompletion(String expression){
  String[] split=splitForCompletionNoTrim(expression);
  if (split[0] != null) {
    split[0]=split[0].trim();
    if (split[0].startsWith(""String_Node_Str"")) {
      split[0]=split[0].substring(1);
    }
  }
  if (split[1] != null) {
    split[1]=split[1].trim();
    if (split[1].startsWith(""String_Node_Str"")) {
      split[1]=split[1].substring(1);
    }
  }
  return split;
}",0.9929140832595216
185632,"public NameAndLocation findPreviousTypeNameToken(ISourceBuffer buffer,int start){
  int current=start;
  current--;
  while (current >= 0 && !Character.isWhitespace(buffer.charAt(current)) && Character.isJavaIdentifierPart(buffer.charAt(current))) {
    current--;
  }
  if (current < 0 || !Character.isWhitespace(buffer.charAt(current))) {
    return null;
  }
  StringBuilder sb=new StringBuilder();
  while (current >= 0 && (Character.isWhitespace(buffer.charAt(current)) || buffer.charAt(current) == '[' || buffer.charAt(current) == ']') && buffer.charAt(current) != '\n' && buffer.charAt(current) != '\r') {
    sb.append(buffer.charAt(current--));
  }
  if (current < 0 || !Character.isJavaIdentifierPart(buffer.charAt(current))) {
    return null;
  }
  while (current >= 0 && Character.isJavaIdentifierPart(buffer.charAt(current))) {
    sb.append(buffer.charAt(current--));
  }
  if (sb.length() > 0) {
    return new NameAndLocation(sb.reverse().toString(),current + 1);
  }
 else {
    return null;
  }
}","public NameAndLocation findPreviousTypeNameToken(ISourceBuffer buffer,int start){
  int current=Math.min(start,buffer.length()) - 1;
  while (current >= 0 && !Character.isWhitespace(buffer.charAt(current)) && Character.isJavaIdentifierPart(buffer.charAt(current))) {
    current-=1;
  }
  if (current < 0 || !Character.isWhitespace(buffer.charAt(current))) {
    return null;
  }
  StringBuilder sb=new StringBuilder();
  while (current >= 0 && (Character.isWhitespace(buffer.charAt(current)) || buffer.charAt(current) == '[' || buffer.charAt(current) == ']') && buffer.charAt(current) != '\n' && buffer.charAt(current) != '\r') {
    sb.append(buffer.charAt(current--));
  }
  if (current < 0 || !Character.isJavaIdentifierPart(buffer.charAt(current))) {
    return null;
  }
  while (current >= 0 && Character.isJavaIdentifierPart(buffer.charAt(current))) {
    sb.append(buffer.charAt(current--));
  }
  if (sb.length() > 0) {
    return new NameAndLocation(sb.reverse().toString(),current + 1);
  }
 else {
    return null;
  }
}",0.9736328125
185633,"/** 
 * Finds the end of the String token that exists at initialOffset. searches the document for the next non-word character and returns that as the end
 * @param buffer the document to search
 * @param initialOffset the initial offset
 * @return the offset of the first non-word character starting atinitialOffset
 */
public int findTokenEnd(ISourceBuffer buffer,int initialOffset){
  int candidate=initialOffset;
  while (buffer.length() > candidate) {
    if (!Character.isJavaIdentifierPart(buffer.charAt(candidate))) {
      break;
    }
    candidate+=1;
  }
  return candidate;
}","/** 
 * Finds the end of the String token that exists at initialOffset. searches the document for the next non-word character and returns that as the end
 * @param buffer the document to search
 * @param initialOffset the initial offset
 * @return the offset of the first non-word character starting at initialOffset
 */
public int findTokenEnd(ISourceBuffer buffer,int initialOffset){
  int candidate=initialOffset;
  while (buffer.length() > candidate) {
    if (!Character.isJavaIdentifierPart(buffer.charAt(candidate))) {
      break;
    }
    candidate+=1;
  }
  return candidate;
}",0.9991489361702128
185634,"public void addModule(ModuleNode node){
  if (node == null)   return;
  modules.add(node);
  this.sortedModules=null;
  node.setUnit(this);
  addClasses(node.getClasses());
}","public void addModule(ModuleNode node){
  if (node == null)   return;
  modules.add(node);
  node.setUnit(this);
  addClasses(node.getClasses());
}",0.9158878504672896
185635,"/** 
 * Adds a class to the unit.
 */
public void addClass(ClassNode node){
  node=node.redirect();
  String name=node.getName();
  ClassNode stored=classes.get(name);
  if (stored != null && stored != node) {
    SourceUnit nodeSource=node.getModule().getContext();
    SourceUnit storedSource=stored.getModule().getContext();
    String txt=""String_Node_Str"" + node.getName() + ""String_Node_Str"";
    if (nodeSource == storedSource) {
      txt+=""String_Node_Str"" + nodeSource.getName() + ""String_Node_Str""+ node.getName()+ ""String_Node_Str"";
      if (node.isScriptBody() || stored.isScriptBody()) {
        txt+=""String_Node_Str"" + ""String_Node_Str"";
      }
    }
 else {
      txt+=""String_Node_Str"" + nodeSource.getName() + ""String_Node_Str""+ storedSource.getName()+ ""String_Node_Str""+ node.getName()+ ""String_Node_Str"";
    }
    nodeSource.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new SyntaxException(txt,node.getLineNumber(),node.getColumnNumber(),node.getLastLineNumber(),node.getLastColumnNumber()),nodeSource));
  }
  classes.put(name,node);
  if (classesToCompile.containsKey(name)) {
    ClassNode cn=classesToCompile.get(name);
    cn.setRedirect(node);
    classesToCompile.remove(name);
  }
}","/** 
 * Adds a class to the unit.
 */
public void addClass(ClassNode node){
  node=node.redirect();
  String name=node.getName();
  ClassNode stored=classes.get(name);
  if (stored != null && stored != node) {
    SourceUnit nodeSource=node.getModule().getContext();
    SourceUnit storedSource=stored.getModule().getContext();
    String txt=""String_Node_Str"" + node.getName() + ""String_Node_Str"";
    if (nodeSource == storedSource) {
      txt+=""String_Node_Str"" + nodeSource.getName() + ""String_Node_Str""+ node.getName()+ ""String_Node_Str"";
      if (node.isScriptBody() || stored.isScriptBody()) {
        txt+=""String_Node_Str"" + ""String_Node_Str"";
      }
    }
 else {
      txt+=""String_Node_Str"" + nodeSource.getName() + ""String_Node_Str""+ storedSource.getName()+ ""String_Node_Str""+ node.getName()+ ""String_Node_Str"";
    }
    nodeSource.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new SyntaxException(txt,node.getLineNumber(),node.getColumnNumber(),node.getLastLineNumber(),node.getLastColumnNumber()),nodeSource));
  }
  classes.put(name,node);
  sortedClasses=null;
  if (classesToCompile.containsKey(name)) {
    ClassNode cn=classesToCompile.get(name);
    cn.setRedirect(node);
    classesToCompile.remove(name);
  }
}",0.991150442477876
185636,"public void testClosure4(){
  String contents=""String_Node_Str"";
  assertType(contents,4,6,""String_Node_Str"");
}","public void testClosure4(){
  String contents=""String_Node_Str"";
  assertType(contents,4,6,GroovyUtils.GROOVY_LEVEL > 23 ? ""String_Node_Str"" : ""String_Node_Str"");
}",0.8115942028985508
185637,"public void testClassReference3(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,""String_Node_Str"");
}","public void testClassReference3(){
  String contents=""String_Node_Str"";
  int start=contents.indexOf(""String_Node_Str"");
  int end=start + ""String_Node_Str"".length();
  assertType(contents,start,end,GroovyUtils.GROOVY_LEVEL > 23 ? ""String_Node_Str"" : ""String_Node_Str"");
}",0.8943089430894309
185638,"public boolean isSourceFile(String fileName,boolean isInterestingProject){
  if (isInterestingProject) {
    return Util.isJavaLikeFileName(fileName);
  }
 else {
    return ContentTypeUtils.isJavaLikeButNotGroovyLikeExtension(fileName);
  }
}","public boolean isSourceFile(String fileName,boolean isInterestingProject){
  if (isInterestingProject) {
    return Util.isJavaLikeFileName(fileName);
  }
 else {
    return ContentTypeUtils.isJavaLikeButNotGroovyLikeFileName(fileName);
  }
}",0.9649484536082474
185639,"private static boolean isGroovyLikeSourceUnit(ICompilationUnit sourceUnit){
  if (sourceUnit.getFileName() == null || !isJavaLikeButNotGroovyLikeExtension(String.valueOf(sourceUnit.getFileName()))) {
    if (GROOVY_SOURCE_DISCRIMINATOR.matcher(new CharArraySequence(sourceUnit.getContents())).find()) {
      Util.log(1,""String_Node_Str"" + String.valueOf(sourceUnit.getContents(),0,Math.min(250,sourceUnit.getContents().length)));
      return true;
    }
  }
  return false;
}","private static boolean isGroovyLikeSourceUnit(ICompilationUnit sourceUnit){
  if (sourceUnit.getFileName() == null || !isJavaLikeButNotGroovyLikeFileName(String.valueOf(sourceUnit.getFileName()))) {
    if (GROOVY_SOURCE_DISCRIMINATOR.matcher(new CharArraySequence(sourceUnit.getContents())).find()) {
      Util.log(1,""String_Node_Str"" + String.valueOf(sourceUnit.getContents(),0,Math.min(250,sourceUnit.getContents().length)));
      return true;
    }
  }
  return false;
}",0.9821615949632738
185640,"private static ImageDescriptor createDescriptor2(String path){
  ImageDescriptor desc;
  try {
    desc=ImageDescriptor.createFromURL(new java.net.URL(path));
    org.eclipse.swt.graphics.Image img=desc.createImage(false);
    if (img != null) {
      img.dispose();
    }
 else {
      desc=null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    desc=null;
  }
  return desc;
}","private static ImageDescriptor createDescriptor2(String path){
  try {
    java.net.URL url=new java.net.URL(path);
    url.openConnection();
    return ImageDescriptor.createFromURL(url);
  }
 catch (  Exception e) {
    return null;
  }
}",0.4770932069510268
185641,"public void testInvalidScripts_GRE323_2(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}","public void testInvalidScripts_GRE323_2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
}",0.556390977443609
185642,"public void testInvalidScripts_GRE323_6(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}","public void testInvalidScripts_GRE323_6(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.5804066543438078
185643,"public void testEnumPositions_GRE1072(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration decl=getCUDeclFor(""String_Node_Str"");
  FieldDeclaration fDecl=null;
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
}","public void testEnumPositions_GRE1072(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
  GroovyCompilationUnitDeclaration decl=getCUDeclFor(""String_Node_Str"");
  FieldDeclaration fDecl=grabField(decl,""String_Node_Str"");
  assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  fDecl=grabField(decl,""String_Node_Str"");
  assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  fDecl=grabField(decl,""String_Node_Str"");
  assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
}",0.705955334987593
185644,"protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  GroovySourceAST groovySourceAST=(GroovySourceAST)node;
  int nameStart=locations.findOffset(groovySourceAST.getLine(),groovySourceAST.getColumn());
  int nameEnd=nameStart + identifier.length() - 1;
  ClassNode fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  configureAST(fn,node);
  fn.setNameStart(nameStart);
  fn.setNameEnd(nameEnd);
  fn.setStart(nameStart);
  fn.setEnd(nameEnd);
  enumConstantBeingDef=false;
}","protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  ClassNode nonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  nonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(nonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  fn.setNameStart(locations.findOffset(savedLine,savedColumn));
  fn.setNameEnd(fn.getNameStart() + identifier.length() - 1);
  fn.addAnnotations(annotations);
  configureAST(fn,node);
  enumConstantBeingDef=false;
}",0.7839442965390129
185645,"protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  GroovySourceAST groovySourceAST=(GroovySourceAST)node;
  int nameStart=locations.findOffset(groovySourceAST.getLine(),groovySourceAST.getColumn());
  int nameEnd=nameStart + identifier.length() - 1;
  ClassNode fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  configureAST(fn,node);
  fn.setNameStart(nameStart);
  fn.setNameEnd(nameEnd);
  fn.setStart(nameStart);
  fn.setEnd(nameEnd);
  enumConstantBeingDef=false;
}","protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  ClassNode nonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  nonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(nonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  fn.setNameStart(locations.findOffset(savedLine,savedColumn));
  fn.setNameEnd(fn.getNameStart() + identifier.length() - 1);
  fn.addAnnotations(annotations);
  configureAST(fn,node);
  enumConstantBeingDef=false;
}",0.7839442965390129
185646,"protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  GroovySourceAST groovySourceAST=(GroovySourceAST)node;
  int nameStart=locations.findOffset(groovySourceAST.getLine(),groovySourceAST.getColumn());
  int nameEnd=nameStart + identifier.length() - 1;
  ClassNode fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  configureAST(fn,node);
  fn.setNameStart(nameStart);
  fn.setNameEnd(nameEnd);
  fn.setStart(nameStart);
  fn.setEnd(nameEnd);
  enumConstantBeingDef=false;
}","protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  ClassNode nonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  nonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(nonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  fn.setNameStart(locations.findOffset(savedLine,savedColumn));
  fn.setNameEnd(fn.getNameStart() + identifier.length() - 1);
  fn.addAnnotations(annotations);
  configureAST(fn,node);
  enumConstantBeingDef=false;
}",0.7839442965390129
185647,"protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  GroovySourceAST groovySourceAST=(GroovySourceAST)node;
  int nameStart=locations.findOffset(groovySourceAST.getLine(),groovySourceAST.getColumn());
  int nameEnd=nameStart + identifier.length() - 1;
  ClassNode fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  configureAST(fn,node);
  fn.setNameStart(nameStart);
  fn.setNameEnd(nameEnd);
  fn.setStart(nameStart);
  fn.setEnd(nameEnd);
  enumConstantBeingDef=false;
}","protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  ClassNode nonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  nonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode enumField=EnumHelper.addEnumConstant(nonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  enumField.setNameStart(locations.findOffset(savedLine,savedColumn));
  enumField.setNameEnd(enumField.getNameStart() + identifier.length() - 1);
  enumField.addAnnotations(annotations);
  configureAST(enumField,node);
  enumConstantBeingDef=false;
}",0.7772588832487309
185648,"protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  GroovySourceAST groovySourceAST=(GroovySourceAST)node;
  int nameStart=locations.findOffset(groovySourceAST.getLine(),groovySourceAST.getColumn());
  int nameEnd=nameStart + identifier.length() - 1;
  ClassNode fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode fn=EnumHelper.addEnumConstant(fakeNodeToRepresentTheNonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  configureAST(fn,node);
  fn.setNameStart(nameStart);
  fn.setNameEnd(nameEnd);
  fn.setStart(nameStart);
  fn.setEnd(nameEnd);
  enumConstantBeingDef=false;
}","protected void enumConstantDef(AST node){
  enumConstantBeingDef=true;
  assertNodeType(ENUM_CONSTANT_DEF,node);
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST element=node.getFirstChild();
  if (isType(ANNOTATIONS,element)) {
    processAnnotations(annotations,element);
    element=element.getNextSibling();
  }
  String identifier=identifier(element);
  int savedLine=element.getLine();
  int savedColumn=element.getColumn();
  Expression init=null;
  element=element.getNextSibling();
  if (element != null) {
    init=expression(element);
    ClassNode innerClass;
    if (element.getNextSibling() == null) {
      innerClass=getAnonymousInnerClassNode(init);
      if (innerClass != null) {
        init=null;
      }
    }
 else {
      element=element.getNextSibling();
      Expression next=expression(element);
      innerClass=getAnonymousInnerClassNode(next);
    }
    if (innerClass != null) {
      innerClass.setSuperClass(classNode.getPlainNodeReference());
      innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
      Expression inner=new ClassExpression(innerClass);
      if (init == null) {
        ListExpression le=new ListExpression();
        le.addExpression(inner);
        init=le;
      }
 else {
        if (init instanceof ListExpression) {
          ((ListExpression)init).addExpression(inner);
        }
 else {
          ListExpression le=new ListExpression();
          le.addExpression(init);
          le.addExpression(inner);
          init=le;
        }
      }
      classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
    }
 else     if (isType(ELIST,element)) {
      if (init instanceof ListExpression && !((ListExpression)init).isWrapped()) {
        ListExpression le=new ListExpression();
        le.addExpression(init);
        init=le;
      }
    }
  }
  ClassNode nonDeclaredTypeOfEnumValue=ClassHelper.make(classNode.getName());
  nonDeclaredTypeOfEnumValue.setRedirect(classNode);
  FieldNode enumField=EnumHelper.addEnumConstant(nonDeclaredTypeOfEnumValue,classNode,identifier,init,savedLine,savedColumn);
  enumField.setNameStart(locations.findOffset(savedLine,savedColumn));
  enumField.setNameEnd(enumField.getNameStart() + identifier.length() - 1);
  enumField.addAnnotations(annotations);
  configureAST(enumField,node);
  enumConstantBeingDef=false;
}",0.7772588832487309
185649,"/** 
 * Try to get the source locations for field declarations to be as correct as possible
 */
private void fixupSourceLocationsForFieldDeclaration(FieldDeclaration fieldDeclaration,FieldNode fieldNode,boolean isEnumField){
  fieldDeclaration.sourceStart=fieldNode.getNameStart();
  fieldDeclaration.sourceEnd=fieldNode.getNameEnd();
  int line=fieldNode.getLineNumber();
  Javadoc doc=findJavadoc(line);
  fieldDeclaration.javadoc=doc;
  if (isEnumField) {
    fieldDeclaration.declarationSourceStart=doc == null ? fieldNode.getNameStart() : doc.sourceStart;
    fieldDeclaration.declarationSourceEnd=fieldNode.getNameEnd() - 1;
  }
 else {
    fieldDeclaration.declarationSourceStart=doc == null ? fieldNode.getStart() : doc.sourceStart;
    fieldDeclaration.declarationSourceEnd=fieldNode.getEnd() - 1;
  }
  fieldDeclaration.modifiersSourceStart=fieldNode.getStart();
  fieldDeclaration.declarationEnd=fieldNode.getEnd();
  fieldDeclaration.endPart1Position=fieldNode.getNameStart();
  fieldDeclaration.endPart2Position=fieldNode.getEnd() - 1;
}","/** 
 * Try to get the source locations for field declarations to be as correct as possible
 */
private void fixupSourceLocationsForFieldDeclaration(FieldDeclaration fieldDeclaration,FieldNode fieldNode,boolean isEnumField){
  fieldDeclaration.sourceStart=fieldNode.getNameStart();
  fieldDeclaration.sourceEnd=fieldNode.getNameEnd();
  int line=fieldNode.getLineNumber();
  Javadoc doc=findJavadoc(line);
  fieldDeclaration.javadoc=doc;
  if (isEnumField) {
    fieldDeclaration.declarationSourceStart=doc == null ? fieldNode.getStart() : doc.sourceStart;
    fieldDeclaration.declarationSourceEnd=fieldNode.getEnd() - 1;
  }
 else {
    fieldDeclaration.declarationSourceStart=doc == null ? fieldNode.getStart() : doc.sourceStart;
    fieldDeclaration.declarationSourceEnd=fieldNode.getEnd() - 1;
  }
  fieldDeclaration.modifiersSourceStart=fieldNode.getStart();
  fieldDeclaration.declarationEnd=fieldNode.getEnd();
  fieldDeclaration.endPart1Position=fieldNode.getNameStart();
  fieldDeclaration.endPart2Position=fieldNode.getEnd() - 1;
}",0.9961759082217974
185650,"/** 
 * Returns an indentation service that uses the right preferences for a given IJavaProject. The same object will be returned if the javaProject is the same as the one from the last request, but a new instance will be created if the project has changed.
 */
public static synchronized GroovyIndentationService get(IJavaProject project){
  if (lastIndenter != null && !project.equals(lastIndenter.project)) {
    disposeLastImpl();
  }
  if (lastIndenter == null) {
    lastIndenter=new GroovyIndentationService(project);
  }
  return lastIndenter;
}","/** 
 * Returns an indentation service that uses the right preferences for a given IJavaProject. The same object will be returned if the javaProject is the same as the one from the last request, but a new instance will be created if the project has changed.
 */
public static synchronized GroovyIndentationService get(IJavaProject project){
  if (lastIndenter != null && project != null && !project.equals(lastIndenter.project)) {
    disposeLastImpl();
  }
  if (lastIndenter == null) {
    lastIndenter=new GroovyIndentationService(project);
  }
  return lastIndenter;
}",0.9831111111111112
185651,"public void testImportsBigInteger3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigInteger3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9272030651340996
185652,"public void testImportsBigInteger1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigInteger1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9015544041450776
185653,"public void testImportsBigDecimal1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigDecimal1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9015544041450776
185654,"private ReferenceBinding createTypeRef(char[][] compoundName){
  try {
    if (getTypeFromCompoundName == null) {
      getTypeFromCompoundName=LookupEnvironment.class.getDeclaredMethod(""String_Node_Str"",char[][].class,boolean.class,boolean.class);
      getTypeFromCompoundName.setAccessible(true);
    }
    return (ReferenceBinding)getTypeFromCompoundName.invoke(environment,new Object[]{compoundName,Boolean.FALSE,Boolean.FALSE});
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private ReferenceBinding createTypeRef(char[][] compoundName){
  return environment.getType(compoundName);
}",0.3398692810457516
185655,"/** 
 * Returns an indentation service that uses the right preferences for a given IJavaProject. The same object will be returned if the javaProject is the same as the one from the last request, but a new instance will be created if the project has changed.
 */
public static synchronized GroovyIndentationService get(IJavaProject project){
  if (lastIndenter != null && !lastIndenter.project.equals(project)) {
    disposeLastImpl();
  }
  if (lastIndenter == null) {
    lastIndenter=new GroovyIndentationService(project);
  }
  return lastIndenter;
}","/** 
 * Returns an indentation service that uses the right preferences for a given IJavaProject. The same object will be returned if the javaProject is the same as the one from the last request, but a new instance will be created if the project has changed.
 */
public static synchronized GroovyIndentationService get(IJavaProject project){
  if (lastIndenter != null && !project.equals(lastIndenter.project)) {
    disposeLastImpl();
  }
  if (lastIndenter == null) {
    lastIndenter=new GroovyIndentationService(project);
  }
  return lastIndenter;
}",0.952983725135624
185656,"public void testGetModuleNode_7() throws Exception {
  IFile groovyFile=createSimpleGroovyProject();
  GroovyCompilationUnit unit1=(GroovyCompilationUnit)JavaCore.createCompilationUnitFrom(groovyFile);
  unit1.becomeWorkingCopy(null);
  unit1.getModuleNode();
  GroovyCompilationUnit unit2=(GroovyCompilationUnit)JavaCore.createCompilationUnitFrom(groovyFile);
  unit2.becomeWorkingCopy(null);
  unit2.getModuleNode();
  unit1.getBuffer().append(""String_Node_Str"");
  unit1.getModuleNode();
  unit2.getModuleNode();
  unit1.discardWorkingCopy();
  unit2.discardWorkingCopy();
  assertTrue(""String_Node_Str"",getInitialModuleNodeMapperSize() >= ModuleNodeMapper.size());
}","public void testGetModuleNode_7() throws Exception {
  IFile groovyFile=createSimpleGroovyProject();
  GroovyCompilationUnit unit1=(GroovyCompilationUnit)JavaCore.createCompilationUnitFrom(groovyFile);
  unit1.becomeWorkingCopy(null);
  unit1.getModuleNode();
  GroovyCompilationUnit unit2=(GroovyCompilationUnit)JavaCore.createCompilationUnitFrom(groovyFile);
  unit2.becomeWorkingCopy(null);
  unit2.getModuleNode();
  unit1.getBuffer().append(""String_Node_Str"");
  unit1.getModuleNode();
  unit2.getModuleNode();
  unit1.discardWorkingCopy();
  unit2.discardWorkingCopy();
  assertTrue(""String_Node_Str"",moduleNodeMapperCacheSize >= ModuleNodeMapper.size());
}",0.9632408102025506
185657,"/** 
 * Sets up this test.
 */
protected void setUp() throws Exception {
  super.setUp();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getName());
  debugRequestor=new EfficiencyCompilerRequestor();
  Compiler.DebugRequestor=debugRequestor;
  if (env == null) {
    env=new TestingEnvironment();
    env.openEmptyWorkspace();
  }
  env.resetWorkspace();
  env.setAutoBuilding(false);
  this.moduleNodeMapperCacheSize=ModuleNodeMapper.size();
}","protected void setUp() throws Exception {
  super.setUp();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getName());
  debugRequestor=new EfficiencyCompilerRequestor();
  Compiler.DebugRequestor=debugRequestor;
  if (env == null) {
    env=new TestingEnvironment();
    env.openEmptyWorkspace();
  }
  env.resetWorkspace();
  env.setAutoBuilding(false);
  this.moduleNodeMapperCacheSize=ModuleNodeMapper.size();
}",0.9666307857911732
185658,"/** 
 * @see junit.framework.TestCase#tearDown()
 */
protected void tearDown() throws Exception {
  env.resetWorkspace();
  ICompilationUnit[] wcs=null;
  int i=0;
  do {
    wcs=JavaModelManager.getJavaModelManager().getWorkingCopies(null,true);
    if (wcs != null) {
      for (      ICompilationUnit workingCopy : wcs) {
        try {
          workingCopy.discardWorkingCopy();
          workingCopy.close();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    i++;
    if (i > 20 && wcs != null) {
      fail(""String_Node_Str"" + wcs);
    }
  }
 while (wcs != null && wcs.length > 0);
  assertTrue(""String_Node_Str"",getInitialModuleNodeMapperSize() >= ModuleNodeMapper.size());
  JavaCore.setOptions(JavaCore.getDefaultOptions());
  super.tearDown();
}","protected void tearDown() throws Exception {
  env.resetWorkspace();
  ICompilationUnit[] wcs=null;
  int i=0;
  do {
    wcs=JavaModelManager.getJavaModelManager().getWorkingCopies(null,true);
    if (wcs != null) {
      for (      ICompilationUnit workingCopy : wcs) {
        try {
          workingCopy.discardWorkingCopy();
          workingCopy.close();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    i++;
    if (i > 20 && wcs != null) {
      fail(""String_Node_Str"" + wcs);
    }
  }
 while (wcs != null && wcs.length > 0);
  assertTrue(""String_Node_Str"",moduleNodeMapperCacheSize >= ModuleNodeMapper.size());
  JavaCore.setOptions(JavaCore.getDefaultOptions());
  super.tearDown();
}",0.9355670103092784
185659,"/** 
 * Open an empty workspace.
 */
public void openEmptyWorkspace(){
  close();
  openWorkspace();
  fProjects=new Hashtable<String,IProject>(10);
  setup();
}","/** 
 * Open an empty workspace.
 */
public void openEmptyWorkspace(){
  close();
  openWorkspace();
  fProjects=new Hashtable<String,IProject>(10);
  fIsOpen=true;
}",0.9663608562691132
185660,"public void testCrashingOnBadCode_GRE290_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testCrashingOnBadCode_GRE290_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8798988621997471
185661,"public void testAliasedAnnotationClassLiteral2(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources);
}","public void testAliasedAnnotationClassLiteral2(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runConformTest(sources);
}",0.8888888888888888
185662,"private boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}","private static boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}",0.9868667917448404
185663,"private boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}","private static boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}",0.9802816901408452
185664,"private Expression repairClassLiteralReference(Expression exp,BlockScope scope,TypeBinding[] valueType){
  TypeBinding vtb=null;
  if (exp instanceof SingleNameReference) {
    vtb=exp.resolveType(scope);
    SingleNameReference ref=(SingleNameReference)exp;
    if (vtb != null && Arrays.equals(ref.token,vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (this.value instanceof QualifiedNameReference) {
    vtb=exp.resolveType(scope);
    QualifiedNameReference ref=(QualifiedNameReference)exp;
    if (vtb != null && Arrays.equals(ref.tokens[ref.tokens.length - 1],vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  if (valueType != null) {
    valueType[0]=vtb;
  }
  return exp;
}","private static Expression repairClassLiteralReference(Expression exp,BlockScope scope){
  if (exp instanceof SingleNameReference) {
    if (exp.resolveType(scope) != null) {
      SingleNameReference ref=(SingleNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (exp instanceof QualifiedNameReference) {
    if (exp.resolveType(scope) != null) {
      QualifiedNameReference ref=(QualifiedNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  return exp;
}",0.3760356915232632
185665,"public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  TypeBinding[] vtb=null;
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope,null);
      }
    }
 else {
      vtb=new TypeBinding[1];
      this.value=repairClassLiteralReference(this.value,scope,vtb);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=(vtb != null && vtb[0] != null) ? vtb[0] : this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}","public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope);
      }
    }
 else {
      this.value=repairClassLiteralReference(this.value,scope);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}",0.9822749298648304
185666,"private boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}","private static boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}",0.9868667917448404
185667,"private boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}","private static boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}",0.9802816901408452
185668,"private Expression repairClassLiteralReference(Expression exp,BlockScope scope,TypeBinding[] valueType){
  TypeBinding vtb=null;
  if (exp instanceof SingleNameReference) {
    vtb=exp.resolveType(scope);
    SingleNameReference ref=(SingleNameReference)exp;
    if (vtb != null && Arrays.equals(ref.token,vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (this.value instanceof QualifiedNameReference) {
    vtb=exp.resolveType(scope);
    QualifiedNameReference ref=(QualifiedNameReference)exp;
    if (vtb != null && Arrays.equals(ref.tokens[ref.tokens.length - 1],vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  if (valueType != null) {
    valueType[0]=vtb;
  }
  return exp;
}","private static Expression repairClassLiteralReference(Expression exp,BlockScope scope){
  if (exp instanceof SingleNameReference) {
    if (exp.resolveType(scope) != null) {
      SingleNameReference ref=(SingleNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (exp instanceof QualifiedNameReference) {
    if (exp.resolveType(scope) != null) {
      QualifiedNameReference ref=(QualifiedNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  return exp;
}",0.3760356915232632
185669,"public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  TypeBinding[] vtb=null;
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope,null);
      }
    }
 else {
      vtb=new TypeBinding[1];
      this.value=repairClassLiteralReference(this.value,scope,vtb);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=(vtb != null && vtb[0] != null) ? vtb[0] : this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}","public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope);
      }
    }
 else {
      this.value=repairClassLiteralReference(this.value,scope);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}",0.9822749298648304
185670,"private boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}","private static boolean isClass(TypeBinding requiredType){
  if (requiredType.isArrayType()) {
    requiredType=requiredType.leafComponentType();
  }
  requiredType=requiredType.original();
  boolean isClass=requiredType.id == TypeIds.T_JavaLangClass;
  return isClass;
}",0.9868667917448404
185671,"private boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}","private static boolean isGroovy(Scope scope){
  while (scope.parent != null) {
    scope=scope.parent;
  }
  return scope.getClass().getSimpleName().startsWith(""String_Node_Str"");
}",0.9802816901408452
185672,"private Expression repairClassLiteralReference(Expression exp,BlockScope scope,TypeBinding[] valueType){
  TypeBinding vtb=null;
  if (exp instanceof SingleNameReference) {
    vtb=exp.resolveType(scope);
    SingleNameReference ref=(SingleNameReference)exp;
    if (vtb != null && Arrays.equals(ref.token,vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (this.value instanceof QualifiedNameReference) {
    vtb=exp.resolveType(scope);
    QualifiedNameReference ref=(QualifiedNameReference)exp;
    if (vtb != null && Arrays.equals(ref.tokens[ref.tokens.length - 1],vtb.sourceName())) {
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  if (valueType != null) {
    valueType[0]=vtb;
  }
  return exp;
}","private static Expression repairClassLiteralReference(Expression exp,BlockScope scope){
  if (exp instanceof SingleNameReference) {
    if (exp.resolveType(scope) != null) {
      SingleNameReference ref=(SingleNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new SingleTypeReference(ref.token,((long)ref.sourceStart) << 32 | ref.sourceEnd));
    }
  }
 else   if (exp instanceof QualifiedNameReference) {
    if (exp.resolveType(scope) != null) {
      QualifiedNameReference ref=(QualifiedNameReference)exp;
      return new ClassLiteralAccess(ref.sourceEnd,new QualifiedTypeReference(ref.tokens,ref.sourcePositions));
    }
  }
  return exp;
}",0.3760356915232632
185673,"public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  TypeBinding[] vtb=null;
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope,null);
      }
    }
 else {
      vtb=new TypeBinding[1];
      this.value=repairClassLiteralReference(this.value,scope,vtb);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=(vtb != null && vtb[0] != null) ? vtb[0] : this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}","public void resolveTypeExpecting(BlockScope scope,TypeBinding requiredType){
  if (this.value == null) {
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (requiredType == null) {
    if (this.value instanceof ArrayInitializer) {
      this.value.resolveTypeExpecting(scope,null);
    }
 else {
      this.value.resolveType(scope);
    }
    this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
    return;
  }
  if (isClass(requiredType) && isGroovy(scope)) {
    if (this.value instanceof ArrayInitializer) {
      Expression[] values=((ArrayInitializer)this.value).expressions;
      for (int i=0, n=values.length; i < n; i+=1) {
        values[i]=repairClassLiteralReference(values[i],scope);
      }
    }
 else {
      this.value=repairClassLiteralReference(this.value,scope);
    }
  }
  this.value.setExpectedType(requiredType);
  TypeBinding valueType;
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    valueType=initializer.resolveTypeExpecting(scope,this.binding.returnType);
  }
 else   if (this.value instanceof ArrayAllocationExpression) {
    scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    this.value.resolveType(scope);
    valueType=null;
  }
 else {
    valueType=this.value.resolveType(scope);
    ASTVisitor visitor=new ASTVisitor(){
      public boolean visit(      SingleNameReference reference,      BlockScope scop){
        if (reference.binding instanceof LocalVariableBinding) {
          ((LocalVariableBinding)reference.binding).useFlag=LocalVariableBinding.USED;
        }
        return true;
      }
    }
;
    this.value.traverse(visitor,scope);
  }
  this.compilerElementPair=new ElementValuePair(this.name,this.value,this.binding);
  if (valueType == null)   return;
  TypeBinding leafType=requiredType.leafComponentType();
  if (!(this.value.isConstantValueOfTypeAssignableToType(valueType,requiredType) || valueType.isCompatibleWith(requiredType))) {
    if (!(requiredType.isArrayType() && requiredType.dimensions() == 1 && (this.value.isConstantValueOfTypeAssignableToType(valueType,leafType) || valueType.isCompatibleWith(leafType)))) {
      if (leafType.isAnnotationType() && !valueType.isAnnotationType()) {
        scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
      }
 else {
        scope.problemReporter().typeMismatchError(valueType,requiredType,this.value,null);
      }
      return;
    }
  }
 else {
    scope.compilationUnitScope().recordTypeConversion(requiredType.leafComponentType(),valueType.leafComponentType());
    this.value.computeConversion(scope,requiredType,valueType);
  }
  checkAnnotationMethodType: {
switch (leafType.erasure().id) {
case T_byte:
case T_short:
case T_char:
case T_int:
case T_long:
case T_float:
case T_double:
case T_boolean:
case T_JavaLangString:
      if (this.value instanceof ArrayInitializer) {
        ArrayInitializer initializer=(ArrayInitializer)this.value;
        final Expression[] expressions=initializer.expressions;
        if (expressions != null) {
          for (int i=0, max=expressions.length; i < max; i++) {
            Expression expression=expressions[i];
            if (expression.resolvedType == null)             continue;
            if (expression.constant == Constant.NotAConstant) {
              scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,expressions[i],false);
            }
          }
        }
      }
 else       if (this.value.constant == Constant.NotAConstant) {
        if (valueType.isArrayType()) {
          scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
        }
 else {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,false);
        }
      }
    break checkAnnotationMethodType;
case T_JavaLangClass:
  if (this.value instanceof ArrayInitializer) {
    ArrayInitializer initializer=(ArrayInitializer)this.value;
    final Expression[] expressions=initializer.expressions;
    if (expressions != null) {
      for (int i=0, max=expressions.length; i < max; i++) {
        Expression currentExpression=expressions[i];
        if (!(currentExpression instanceof ClassLiteralAccess)) {
          scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,currentExpression);
        }
      }
    }
  }
 else   if (!(this.value instanceof ClassLiteralAccess)) {
    scope.problemReporter().annotationValueMustBeClassLiteral(this.binding.declaringClass,this.name,this.value);
  }
break checkAnnotationMethodType;
}
if (leafType.isEnum()) {
if (this.value instanceof NullLiteral) {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
    }
 else     if (currentExpression instanceof NameReference) {
      NameReference nameReference=(NameReference)currentExpression;
      final Binding nameReferenceBinding=nameReference.binding;
      if (nameReferenceBinding.kind() == Binding.FIELD) {
        FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
        if (!fieldBinding.declaringClass.isEnum()) {
          scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,currentExpression,true);
        }
      }
    }
  }
}
}
 else if (this.value instanceof NameReference) {
NameReference nameReference=(NameReference)this.value;
final Binding nameReferenceBinding=nameReference.binding;
if (nameReferenceBinding.kind() == Binding.FIELD) {
  FieldBinding fieldBinding=(FieldBinding)nameReferenceBinding;
  if (!fieldBinding.declaringClass.isEnum()) {
    if (!fieldBinding.type.isArrayType()) {
      scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
    }
 else {
      scope.problemReporter().annotationValueMustBeArrayInitializer(this.binding.declaringClass,this.name,this.value);
    }
  }
}
}
 else {
scope.problemReporter().annotationValueMustBeConstant(this.binding.declaringClass,this.name,this.value,true);
}
break checkAnnotationMethodType;
}
if (leafType.isAnnotationType()) {
if (!valueType.leafComponentType().isAnnotationType()) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
 else if (this.value instanceof ArrayInitializer) {
ArrayInitializer initializer=(ArrayInitializer)this.value;
final Expression[] expressions=initializer.expressions;
if (expressions != null) {
  for (int i=0, max=expressions.length; i < max; i++) {
    Expression currentExpression=expressions[i];
    if (currentExpression instanceof NullLiteral || !(currentExpression instanceof Annotation)) {
      scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,currentExpression,leafType);
    }
  }
}
}
 else if (!(this.value instanceof Annotation)) {
scope.problemReporter().annotationValueMustBeAnnotation(this.binding.declaringClass,this.name,this.value,leafType);
}
break checkAnnotationMethodType;
}
}
}",0.9822749298648304
185674,"public void testAccessForExtends(){
  env.addGroovyClass(src,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  fullBuild();
  expectingProblemsFor(src.append(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}","public void testAccessForExtends(){
  String source=""String_Node_Str"" + ""String_Node_Str"";
  assertAccessRestriction(source,""String_Node_Str"");
}",0.6380697050938338
185675,"public void testAccessForImplements(){
  env.addGroovyClass(src,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  fullBuild();
  expectingProblemsFor(src.append(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}","public void testAccessForImplements(){
  String source=""String_Node_Str"" + ""String_Node_Str"";
  assertAccessRestriction(source,""String_Node_Str"");
}",0.6437994722955145
185676,"/** 
 * @param type
 * @param cl erasure of type
 * @return
 */
private ClassNode makeClassNode(TypeBinding t,TypeBinding c){
  ClassNode back=null;
  if (back == null)   back=resolver.convertToClassNode(c);
  if (!((t instanceof BinaryTypeBinding) || (t instanceof SourceTypeBinding))) {
    ClassNode front=JDTClassNodeBuilder.build(this.resolver,t);
    front.setRedirect(back);
    return front;
  }
  return back;
}","/** 
 * @param t type
 * @param c erasure of type
 */
private ClassNode makeClassNode(TypeBinding t,TypeBinding c){
  ClassNode back=resolver.convertToClassNode(c);
  if (!((t instanceof BinaryTypeBinding) || (t instanceof SourceTypeBinding))) {
    ClassNode front=JDTClassNodeBuilder.build(this.resolver,t);
    front.setRedirect(back);
    return front;
  }
  return back;
}",0.9008782936010038
185677,"/** 
 * Creates a Groovy ClassNode that represents the JDT TypeBinding. Build the basic structure, mark it as 'in progress' and then continue with initialization. This allows self referential generic declarations.
 * @param jdtBinding the JDT binding for which to create a ClassNode
 * @return the new ClassNode, of type JDTClassNode
 */
private ClassNode createJDTClassNode(TypeBinding jdtBinding){
}","/** 
 * Creates a Groovy ClassNode that represents the JDT TypeBinding. Steps include building the basic structure, marking node as 'in progress' and continuing with initialization. This allows self-referential generics.
 * @param jdtBinding the JDT binding for which to create a ClassNode
 * @return a {@link JDTClassNode}
 */
private ClassNode createJDTClassNode(TypeBinding jdtBinding){
}",0.8535353535353535
185678,"@Override protected boolean resolveFromModule(ClassNode type,boolean testModuleImports){
  boolean foundit=super.resolveFromModule(type,testModuleImports);
  recordDependency(type.getName());
  if (DEBUG) {
    log(""String_Node_Str"",type,foundit);
  }
  return foundit;
}","@Override protected boolean resolveFromModule(ClassNode type,boolean testModuleImports){
  boolean foundit=super.resolveFromModule(type,testModuleImports);
  recordDependency(type.getName());
  if (DEBUG) {
    log(""String_Node_Str"",type,foundit);
  }
  if (foundit) {
    if (type.redirect() instanceof JDTClassNode && ((JDTClassNode)type.redirect()).getJdtBinding().hasRestrictedAccess()) {
      TypeBinding binding=((JDTClassNode)type.redirect()).getJdtBinding();
      AccessRestriction restriction=activeScope.environment().getAccessRestriction(binding.erasure());
      if (restriction != null) {
        SingleTypeReference ref=new SingleTypeReference(type.getNameWithoutPackage().toCharArray(),((long)type.getStart() << 32 | (long)type.getEnd() - 1));
        activeScope.problemReporter().forbiddenReference(binding,ref,restriction.classpathEntryType,restriction.classpathEntryName,restriction.getProblemId());
      }
    }
  }
  return foundit;
}",0.4182262001627339
185679,"public void testStaticImports_GtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testStaticImports_GtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9926144756277696
185680,"public void testBrokenPackage(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testBrokenPackage(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.989648033126294
185681,"public void testEnums(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testEnums(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9839228295819936
185682,"public void _testOverridingFinalMethod(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void _testOverridingFinalMethod(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9912739965095986
185683,"/** 
 * Now a class extending a java type which extends a base groovy class.  Super groovy type should get them. This looks odd to me, not sure why Foo and One both get the methods when One inherits them through Foo - perhaps the java type in the middle makes a difference.  Anyway by augmenting both of these we are actually doing the same as groovyc, and that is the main thing.
 */
public void testClassHierarchiesAndGroovyObjectMethods3(){
  try {
    GroovyClassScope.debugListener=new EventListener();
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
    assertEventCount(2,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}","/** 
 * Now a class extending a java type which extends a base groovy class.  Super groovy type should get them. This looks odd to me, not sure why Foo and One both get the methods when One inherits them through Foo - perhaps the java type in the middle makes a difference.  Anyway by augmenting both of these we are actually doing the same as groovyc, and that is the main thing.
 */
public void testClassHierarchiesAndGroovyObjectMethods3(){
  try {
    GroovyClassScope.debugListener=new EventListener();
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
    assertEventCount(2,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}",0.9975550122249388
185684,"/** 
 * First a class extending another.  The superclass gets augmented but not the subclass.
 */
public void testClassHierarchiesAndGroovyObjectMethods(){
  try {
    GroovyClassScope.debugListener=new EventListener(""String_Node_Str"");
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    assertEventCount(1,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    System.err.println(GroovyClassScope.debugListener.toString());
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}","/** 
 * First a class extending another.  The superclass gets augmented but not the subclass.
 */
public void testClassHierarchiesAndGroovyObjectMethods(){
  try {
    GroovyClassScope.debugListener=new EventListener(""String_Node_Str"");
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    assertEventCount(1,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    System.err.println(GroovyClassScope.debugListener.toString());
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}",0.9965059399021664
185685,"/** 
 * Now a class implementing an interface.  The subclass gets augmented because the superclass did not.
 */
public void testClassHierarchiesAndGroovyObjectMethods2(){
  try {
    GroovyClassScope.debugListener=new EventListener(""String_Node_Str"");
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    assertEventCount(1,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    System.err.println(GroovyClassScope.debugListener.toString());
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}","/** 
 * Now a class implementing an interface.  The subclass gets augmented because the superclass did not.
 */
public void testClassHierarchiesAndGroovyObjectMethods2(){
  try {
    GroovyClassScope.debugListener=new EventListener(""String_Node_Str"");
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    assertEventCount(1,GroovyClassScope.debugListener);
    assertEvent(""String_Node_Str"",GroovyClassScope.debugListener);
    System.err.println(GroovyClassScope.debugListener.toString());
  }
  finally {
    GroovyClassScope.debugListener=null;
  }
}",0.9965776865160848
185686,"public void testImplementingInterface_MethodWithParameters_JextendsG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters_JextendsG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933065595716198
185687,"public void testConstructorsForEnumWrong_GRE285(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testConstructorsForEnumWrong_GRE285(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9944258639910812
185688,"public void testImportInnerInner01(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportInnerInner01(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9942462600690448
185689,"public void testImportAliasing(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportAliasing(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9950641658440276
185690,"public void testCrashingOnBadCode_GRE290_3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCrashingOnBadCode_GRE290_3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.988399071925754
185691,"public void testGroovyObjectsAreGroovyAtCompileTime(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyObjectsAreGroovyAtCompileTime(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9929873772791024
185692,"public void testCrashingOnBadCode_GRE290_4(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testCrashingOnBadCode_GRE290_4(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9908925318761383
185693,"public void testParsingDotTerminatedImportFollowedByClassDeclaration_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","public void testParsingDotTerminatedImportFollowedByClassDeclaration_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9596231493943472
185694,"public void testCrashingOnBadCode_GRE290_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testCrashingOnBadCode_GRE290_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9943883277216612
185695,"public void testGroovyPropertyAccessors_Set(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors_Set(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9935316946959896
185696,"public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_QualifiedArrayReferenceReturnType(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_QualifiedArrayReferenceReturnType(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9961449498843484
185697,"public void testDefaultValueMethods02(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}","public void testDefaultValueMethods02(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}",0.9982400563181978
185698,"public void testInvalidScripts_GRE323_1b(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_1b(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9923430321592648
185699,"public void testExtendingJavaWithGroovyAndThenJava(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingJavaWithGroovyAndThenJava(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.993939393939394
185700,"public void testAbstractCovariance_GRE272(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}","public void testAbstractCovariance_GRE272(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}",0.9910873440285204
185701,"public void testImports2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImports2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.990138067061144
185702,"public void testImports1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImports1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9908256880733946
185703,"public void testPositions(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testPositions(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.993270524899058
185704,"public void testImplementingInterface_MethodWithParameters_GextendsJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters_GextendsJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933065595716198
185705,"public void testNotMakingInterfacesImplementGroovyObject(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testNotMakingInterfacesImplementGroovyObject(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9922720247295208
185706,"public void testReferencingFields_GreferingToJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testReferencingFields_GreferingToJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992887624466572
185707,"public void testVisibility(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testVisibility(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9924357034795764
185708,"public void testExtendingJavaWithGroovy1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingJavaWithGroovy1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9923430321592648
185709,"public void testExtendingInterface1(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testExtendingInterface1(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9922720247295208
185710,"public void testExtendingInterface2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testExtendingInterface2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9922958397534668
185711,"public void testExtendingGroovyWithJava1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingGroovyWithJava1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9923430321592648
185712,"public void testParsingBlankImportStatic_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  Map<String,ImportNode> imports=mn.getStaticImports();
  ImportNode brokenImportNode=imports.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","public void testParsingBlankImportStatic_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  Map<String,ImportNode> imports=mn.getStaticImports();
  ImportNode brokenImportNode=imports.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.9576271186440678
185713,"public void testImportAliasingAndOldReference(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImportAliasingAndOldReference(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9957007738607052
185714,"public void testPrimitiveLikeTypeNames_GRE891_2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  assertEquals(""String_Node_Str"",getReturnTypeOfMethod(""String_Node_Str"",""String_Node_Str""));
}","public void testPrimitiveLikeTypeNames_GRE891_2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  assertEquals(""String_Node_Str"",getReturnTypeOfMethod(""String_Node_Str"",""String_Node_Str""));
}",0.9938800489596084
185715,"public void testNewRuleInLatestGroovy(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}","public void testNewRuleInLatestGroovy(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}",0.9929378531073446
185716,"public void testClashingMethodsWithDefaultParams(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testClashingMethodsWithDefaultParams(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.994232987312572
185717,"public void testMixedModeInnerProperties2_GRE597(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMixedModeInnerProperties2_GRE597(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9955555555555556
185718,"public void testNonTerminalMissingImport(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNonTerminalMissingImport(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9928263988522238
185719,"public void testScriptCallJava(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}","public void testScriptCallJava(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}",0.9844236760124612
185720,"public void testExtendingJavaInterfaceWithGroovy(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingJavaInterfaceWithGroovy(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9920508744038156
185721,"public void testInvokingVarargsCtors01_GtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargsCtors01_GtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9945945945945946
185722,"public void testImportStatic3(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertTrue(irs[0] instanceof AliasImportReference);
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
  assertEquals(""String_Node_Str"",new String(((AliasImportReference)irs[0]).getSimpleName()));
}","public void testImportStatic3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertTrue(irs[0] instanceof AliasImportReference);
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
  assertEquals(""String_Node_Str"",new String(((AliasImportReference)irs[0]).getSimpleName()));
}",0.9956255468066492
185723,"public void testCallStaticMethodFromGtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallStaticMethodFromGtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9931412894375856
185724,"public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_ParamPosition(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_ParamPosition(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.996022275258552
185725,"public void testStandaloneGroovyFile2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testStandaloneGroovyFile2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9938195302843016
185726,"public void testImportStatic1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}","public void testImportStatic1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}",0.9940968122786304
185727,"public void testImportStatic2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}","public void testImportStatic2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  ImportReference[] irs=gcud.imports;
  assertEquals(""String_Node_Str"",irs[0].toString().trim());
  assertTrue(irs[0].isStatic());
}",0.9940968122786304
185728,"public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9959316517493898
185729,"public void testParsingIncompleteClassDeclaration_495() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  List<ClassNode> l=mn.getClasses();
  for (int i=0; i < l.size(); i++) {
    System.out.println(l.get(i));
  }
  assertFalse(mn.encounteredUnrecoverableError());
  ClassNode cn=mn.getClasses().get(2);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
  cn=mn.getClasses().get(1);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","public void testParsingIncompleteClassDeclaration_495() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  List<ClassNode> l=mn.getClasses();
  for (int i=0; i < l.size(); i++) {
    System.out.println(l.get(i));
  }
  assertFalse(mn.encounteredUnrecoverableError());
  ClassNode cn=mn.getClasses().get(2);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
  cn=mn.getClasses().get(1);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9653579676674364
185730,"public void testStandaloneGroovyFile(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testStandaloneGroovyFile(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.989010989010989
185731,"public void testImportInnerClass01_JavaCase(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportInnerClass01_JavaCase(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.994110718492344
185732,"public void testInvokingVarargs03_JtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargs03_JtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9953139643861292
185733,"public void testImportsBigInteger3(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigInteger3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.991150442477876
185734,"public void testImportsBigInteger2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigInteger2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9897750511247444
185735,"public void testInvokingVarargs02_GtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargs02_GtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9953139643861292
185736,"public void testImportInnerClass01_GroovyCase(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportInnerClass01_GroovyCase(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9941383352872216
185737,"public void testDuplicateGroovyObjectMethods(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testDuplicateGroovyObjectMethods(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9908592321755028
185738,"public void testImportAliasingGoober(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportAliasingGoober(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9898580121703854
185739,"public void testImportsBigInteger1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigInteger1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9905123339658444
185740,"public void testInnerTypes_1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testInnerTypes_1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9949031600407748
185741,"public void testStaticProperties_GRE364_2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}","public void testStaticProperties_GRE364_2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}",0.9881796690307328
185742,"public void testTransientMethod_GRE370(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testTransientMethod_GRE370(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9855072463768116
185743,"public void testTypeClash(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testTypeClash(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9932523616734144
185744,"public void testGroovyPropertyAccessors(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9931224209078404
185745,"public void testAliasing_GRE473_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testAliasing_GRE473_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9917627677100496
185746,"public void testParentIsObject_GRE528(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testParentIsObject_GRE528(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9938195302843016
185747,"public void testGroovyBug(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyBug(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9872122762148338
185748,"public void testExtendingRawJavaType(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingRawJavaType(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9926362297496318
185749,"public void testMissingTypesForGeneratedBindingsGivesNPE_GRE273_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMissingTypesForGeneratedBindingsGivesNPE_GRE273_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9886104783599088
185750,"public void testNotSeriousEnough_GRE396_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNotSeriousEnough_GRE396_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9946062567421792
185751,"public void testIncorrectReturnType_GRE292_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testIncorrectReturnType_GRE292_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9920508744038156
185752,"public void testCallingMethods_JcallingG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingMethods_JcallingG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9931412894375856
185753,"public void testGroovyPropertyAccessors_ErrorCases1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors_ErrorCases1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933422103861518
185754,"public void testIncorrectReturnType_GRE292_3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testIncorrectReturnType_GRE292_3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9929078014184396
185755,"public void testGroovyPropertyAccessors_ErrorCases2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors_ErrorCases2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933422103861518
185756,"public void testIncorrectReturnType_GRE292_4(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testIncorrectReturnType_GRE292_4(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9920508744038156
185757,"public void testInvokingVarargs01_GtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargs01_GtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9953139643861292
185758,"public void testBridgeMethods_GRE336(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testBridgeMethods_GRE336(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9951314508276532
185759,"public void testEnums2(){
  try {
    JDTResolver.recordInstances=true;
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""});
    JDTClassNode classnode=JDTResolver.getCachedNode(""String_Node_Str"");
    assertNotNull(classnode);
    List<MethodNode> methods=classnode.getMethods();
    assertEquals(1,methods.size());
    assertEquals(""String_Node_Str"",methods.get(0).getTypeDescriptor());
    classnode.lazyClassInit();
  }
  finally {
    JDTResolver.instances.clear();
    JDTResolver.recordInstances=false;
  }
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""});
}","public void testEnums2(){
  try {
    JDTResolver.recordInstances=true;
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""});
    JDTClassNode classnode=JDTResolver.getCachedNode(""String_Node_Str"");
    assertNotNull(classnode);
    List<MethodNode> methods=classnode.getMethods();
    assertEquals(1,methods.size());
    assertEquals(""String_Node_Str"",methods.get(0).getTypeDescriptor());
    classnode.lazyClassInit();
  }
  finally {
    JDTResolver.instances.clear();
    JDTResolver.recordInstances=false;
  }
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""});
}",0.9948347107438016
185760,"public void testGroovyPropertyAccessors_ErrorCases3(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors_ErrorCases3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933422103861518
185761,"public void testGroovyPropertyAccessors_ErrorCases4(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyPropertyAccessors_ErrorCases4(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9936628643852978
185762,"public void testCallingJavaFromGroovy1() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingJavaFromGroovy1() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9934296977660972
185763,"public void testCallingJavaFromGroovy2() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingJavaFromGroovy2() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9947423764458464
185764,"public void testImportsBigDecimal1(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigDecimal1(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9905123339658444
185765,"public void testImportsBigDecimal2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportsBigDecimal2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9897750511247444
185766,"public void testIncorrectReturnType_GRE292(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testIncorrectReturnType_GRE292(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.992867332382311
185767,"public void testNotSeriousEnough_GRE396(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNotSeriousEnough_GRE396(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9945828819068256
185768,"public void testAbstractMethodWithinEnum_STS3803(){
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
}","public void testAbstractMethodWithinEnum_STS3803(){
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
}",0.992503748125937
185769,"public void testStaticImportsAliasing_G(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testStaticImportsAliasing_G(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9891540130151844
185770,"public void testInvalidScripts_GRE323_3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9913344887348352
185771,"public void testInvalidScripts_GRE323_4(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_4(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9923430321592648
185772,"public void testMixedModeInnerProperties_GRE597(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMixedModeInnerProperties_GRE597(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9955476402493322
185773,"public void testInvalidScripts_GRE323_1(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_1(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9923430321592648
185774,"public void testInvalidScripts_GRE323_2(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}","public void testInvalidScripts_GRE323_2(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}",0.993455497382199
185775,"public void testInnerTypeReferencing_GRE339_2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerTypeReferencing_GRE339_2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9924585218702866
185776,"public void testCallingMethods_GcallingJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingMethods_GcallingJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9931412894375856
185777,"public void testInvalidScripts_GRE323_5(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_5(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9927641099855282
185778,"public void testInvalidScripts_GRE323_6(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}","public void testInvalidScripts_GRE323_6(){
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  }
}",0.993455497382199
185779,"public void testInnerTypeReferencing_GRE339(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerTypeReferencing_GRE339(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992412746585736
185780,"public void testImportInnerClass(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportInnerClass(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9936628643852978
185781,"public void testInnerTypeReferencing_GRE339_3(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerTypeReferencing_GRE339_3(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.990138067061144
185782,"public void testJDTClassNode_633(){
  try {
    JDTResolver.recordInstances=true;
    this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    JDTClassNode classnode=JDTResolver.getCachedNode(""String_Node_Str"");
    assertNotNull(classnode);
    List<MethodNode> methods=classnode.getMethods();
    assertEquals(1,methods.size());
    assertEquals(""String_Node_Str"",methods.get(0).getTypeDescriptor());
  }
  finally {
    JDTResolver.instances.clear();
    JDTResolver.recordInstances=false;
  }
}","public void testJDTClassNode_633(){
  try {
    JDTResolver.recordInstances=true;
    runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
    JDTClassNode classnode=JDTResolver.getCachedNode(""String_Node_Str"");
    assertNotNull(classnode);
    List<MethodNode> methods=classnode.getMethods();
    assertEquals(1,methods.size());
    assertEquals(""String_Node_Str"",methods.get(0).getTypeDescriptor());
  }
  finally {
    JDTResolver.instances.clear();
    JDTResolver.recordInstances=false;
  }
}",0.9974240082431736
185783,"public void testStaticImports2_GtoJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testStaticImports2_GtoJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933949801849404
185784,"public void testParsingDotTerminatedImport_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","public void testParsingDotTerminatedImport_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.9560761346998536
185785,"public void testMultipleTypesInOneFile03(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMultipleTypesInOneFile03(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.991869918699187
185786,"public void testMultipleTypesInOneFile02(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMultipleTypesInOneFile02(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9907235621521336
185787,"public void testMultipleTypesInOneFile01(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMultipleTypesInOneFile01(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9900199600798404
185788,"public void testRecursion_GR531(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testRecursion_GR531(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9926144756277696
185789,"public void testTypeVariableBoundIsRawType(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testTypeVariableBoundIsRawType(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9927641099855282
185790,"public void testDefaultValueConstructors(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}","public void testDefaultValueConstructors(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}",0.9976602714085168
185791,"public void testParsingBlankImportFollowedByClassDeclaration_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","public void testParsingBlankImportFollowedByClassDeclaration_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.9967170059093894
185792,"public void testFailureWhilstAttemptingToReportError(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testFailureWhilstAttemptingToReportError(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.994026284348865
185793,"public void testExtendingJavaWithGroovyAndThenJavaAndThenGroovy(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingJavaWithGroovyAndThenJavaAndThenGroovy(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9943374858437146
185794,"public void testCallingConstructors_JcallingG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingConstructors_JcallingG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.993234100135318
185795,"public void testImplementingInterface_MethodWithParameters2_JextendsG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters2_JextendsG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933244325767692
185796,"public void testSecondaryTypeTagging(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  TypeDeclaration[] tds=gcud.types;
  assertFalse((tds[0].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[1].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[2].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[3].bits & ASTNode.IsSecondaryType) != 0);
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  gcud=getCUDeclFor(""String_Node_Str"");
  tds=gcud.types;
  assertTrue((tds[0].bits & ASTNode.IsSecondaryType) != 0);
  assertFalse((tds[1].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[2].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[3].bits & ASTNode.IsSecondaryType) != 0);
}","public void testSecondaryTypeTagging(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration gcud=getCUDeclFor(""String_Node_Str"");
  TypeDeclaration[] tds=gcud.types;
  assertFalse((tds[0].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[1].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[2].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[3].bits & ASTNode.IsSecondaryType) != 0);
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  gcud=getCUDeclFor(""String_Node_Str"");
  tds=gcud.types;
  assertTrue((tds[0].bits & ASTNode.IsSecondaryType) != 0);
  assertFalse((tds[1].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[2].bits & ASTNode.IsSecondaryType) != 0);
  assertTrue((tds[3].bits & ASTNode.IsSecondaryType) != 0);
}",0.994934143870314
185797,"public void testPositions_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testPositions_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9933065595716198
185798,"public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_QualifiedParamPosition(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_QualifiedParamPosition(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.996078431372549
185799,"public void testEnum(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testEnum(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9906542056074766
185800,"public void testDefaultValueMethods(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}","public void testDefaultValueMethods(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  checkGCUDeclaration(""String_Node_Str"",expectedOutput);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
  expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  checkDisassemblyFor(""String_Node_Str"",expectedOutput,ClassFileBytesDisassembler.COMPACT);
}",0.9973670352817272
185801,"public void testAbstractClass_GRE274_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testAbstractClass_GRE274_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9934980494148244
185802,"public void testExtendingGroovyObjects_clinit(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingGroovyObjects_clinit(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992867332382311
185803,"public void testReferencingFields_JreferingToG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testReferencingFields_JreferingToG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992887624466572
185804,"public void testMissingContext_GRE308(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testMissingContext_GRE308(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9927641099855282
185805,"public void testEnumPositions_GRE1072(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration decl=getCUDeclFor(""String_Node_Str"");
  FieldDeclaration fDecl=null;
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
}","public void testEnumPositions_GRE1072(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
  GroovyCompilationUnitDeclaration decl=getCUDeclFor(""String_Node_Str"");
  FieldDeclaration fDecl=null;
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
  fDecl=grabField(decl,""String_Node_Str"");
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
 else {
    assertEquals(""String_Node_Str"",stringifyFieldDecl(fDecl));
  }
}",0.997511199601792
185806,"public void testImplementingInterface_MethodWithParameters3_JextendsG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters3_JextendsG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933244325767692
185807,"public void testStaticProperties_GRE364(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testStaticProperties_GRE364(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9880668257756564
185808,"public void testGroovyObjectsAreGroovyAtRunTime(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyObjectsAreGroovyAtRunTime(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9929078014184396
185809,"public void testInvokingVarargs02_JtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargs02_JtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9953139643861292
185810,"public void testParsingBlankImport_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  if (GroovyUtils.GROOVY_LEVEL >= 21) {
    assertEquals(0,brokenImportNode.getStart());
    assertEquals(6,brokenImportNode.getEnd());
  }
 else {
    assertEquals(2,brokenImportNode.getStart());
    assertEquals(0,brokenImportNode.getEnd());
  }
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}","public void testParsingBlankImport_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 21) {
    return;
  }
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getImports();
  ImportNode brokenImportNode=imports.get(0);
  if (GroovyUtils.GROOVY_LEVEL >= 21) {
    assertEquals(0,brokenImportNode.getStart());
    assertEquals(6,brokenImportNode.getEnd());
  }
 else {
    assertEquals(2,brokenImportNode.getStart());
    assertEquals(0,brokenImportNode.getEnd());
  }
  assertEquals(""String_Node_Str"",brokenImportNode.getType().getName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertTrue(cn.getName().equals(""String_Node_Str""));
}",0.9973670352817272
185811,"public void testScriptWithError(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testScriptWithError(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.988814317673378
185812,"public void testRecursion_GR531_4(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testRecursion_GR531_4(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9926578560939796
185813,"public void testRecursion_GR531_3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testRecursion_GR531_3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9960095770151636
185814,"public void testRecursion_GR531_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testRecursion_GR531_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9937264742785444
185815,"public void testClosuresBasic(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testClosuresBasic(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9903288201160542
185816,"public void testCallingConstructors_GcallingJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallingConstructors_GcallingJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.993234100135318
185817,"public void testCallStaticMethodFromJtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallStaticMethodFromJtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9931412894375856
185818,"public void testAbstractCovariance_GRE272_4(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testAbstractCovariance_GRE272_4(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9934640522875816
185819,"public void testDuplicateGroovyObjectMethods2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testDuplicateGroovyObjectMethods2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992
185820,"public void testAbstractCovariance_GRE272_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testAbstractCovariance_GRE272_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9934640522875816
185821,"public void testAbstractCovariance_GRE272_3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testAbstractCovariance_GRE272_3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9934640522875816
185822,"public void testMemberTypeResolution(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testMemberTypeResolution(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9947312961011592
185823,"public void testImplementingAnInterfaceViaProperty(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingAnInterfaceViaProperty(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933244325767692
185824,"public void testInnerClass4() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerClass4() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9908925318761383
185825,"public void testInnerClass5() throws Exception {
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testInnerClass5() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9920760697305864
185826,"public void testMissingTypesForGeneratedBindingsGivesNPE_GRE273(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testMissingTypesForGeneratedBindingsGivesNPE_GRE273(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9987651271918992
185827,"public void testParsingDotTerminatedImportFollowedByModifierAndClassDeclaration_538() throws Exception {
  if (GroovyUtils.GROOVY_LEVEL < 18) {
    return;
  }
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}","public void testParsingDotTerminatedImportFollowedByModifierAndClassDeclaration_538() throws Exception {
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ModuleNode mn=getModuleNode(""String_Node_Str"");
  assertNotNull(mn);
  assertFalse(mn.encounteredUnrecoverableError());
  List<ImportNode> imports=mn.getStarImports();
  ImportNode brokenImportNode=imports.get(0);
  assertEquals(""String_Node_Str"",brokenImportNode.getPackageName());
  ClassNode cn=mn.getClasses().get(0);
  assertNotNull(cn);
  assertEquals(""String_Node_Str"",cn.getName());
}",0.960212201591512
185828,"public void testInvalidScripts_GRE323_3b(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_3b(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9913344887348352
185829,"public void testGroovyBug2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testGroovyBug2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9872773536895676
185830,"public void testNPE_GRE291(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNPE_GRE291(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9920760697305864
185831,"public void testPublicClassInWrongFile(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testPublicClassInWrongFile(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9899396378269618
185832,"public void testCallGroovyObjectMethods_invokeMethod(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testCallGroovyObjectMethods_invokeMethod(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9936788874841972
185833,"public void testStarImports_GRE421(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testStarImports_GRE421(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9904761904761904
185834,"public void testAbstractClass_GRE274(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testAbstractClass_GRE274(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9934640522875816
185835,"public void testInvokingVarargsCtors01_JtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargsCtors01_JtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9945945945945946
185836,"public void testExtendingGroovyInterfaceWithJava(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testExtendingGroovyInterfaceWithJava(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9920508744038156
185837,"public void testImplementingInterface_MethodWithParameters3_GextendsJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters3_GextendsJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933244325767692
185838,"public void testImportAliasingInnerClass(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImportAliasingInnerClass(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9937888198757764
185839,"public void _testGRE637(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
}","public void _testGRE637(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""});
}",0.996276991809382
185840,"public void testPrimitiveLikeTypeNames_GRE891(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  assertEquals(""String_Node_Str"",getReturnTypeOfMethod(""String_Node_Str"",""String_Node_Str""));
}","public void testPrimitiveLikeTypeNames_GRE891(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  assertEquals(""String_Node_Str"",getReturnTypeOfMethod(""String_Node_Str"",""String_Node_Str""));
}",0.993849938499385
185841,"public void testJDKClasses(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testJDKClasses(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9914821124361158
185842,"public void testInvalidScripts_GRE323_5b(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_5b(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9927641099855282
185843,"public void _testOverriding_GRE440_2(){
  if (GroovyUtils.isGroovy16())   return;
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"");
}","public void _testOverriding_GRE440_2(){
  if (GroovyUtils.isGroovy16())   return;
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"");
}",0.9928469241773964
185844,"public void testImplementingInterface_MethodWithParameters2_GextendsJ(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface_MethodWithParameters2_GextendsJ(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9933244325767692
185845,"public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_ArrayReferenceReturnType(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface_JavaExtendingGroovyAndImplementingMethod_ArrayReferenceReturnType(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9960906958561376
185846,"public void testMissingContext_GRE308_2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testMissingContext_GRE308_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9931787175989086
185847,"public void testBrokenPackage2(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testBrokenPackage2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9896907216494846
185848,"public void testInvalidScripts_GRE323_4b(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvalidScripts_GRE323_4b(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.995159728944821
185849,"/** 
 * WMTW: having a callback registered with groovy class generation that tracks which class file is created for which module node details: the groovy compilationunit provides a way to ask for the generated classes but it doesnt give a way to tell why they arose (which sourceunit caused them to come into existence).  I am using the callback mechanism to track this information, but I worry that we are causing groovy to perhaps do things too many times.  It also feels a little wierd that driving any single file through to CLASSGEN drives them all through.  It isn't necessarily a problem, but it conflicts with the model of dealing with one file at a time...
 */
public void testBuildingTwoGroovyFiles(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","/** 
 * WMTW: having a callback registered with groovy class generation that tracks which class file is created for which module node details: the groovy compilationunit provides a way to ask for the generated classes but it doesnt give a way to tell why they arose (which sourceunit caused them to come into existence).  I am using the callback mechanism to track this information, but I worry that we are causing groovy to perhaps do things too many times.  It also feels a little wierd that driving any single file through to CLASSGEN drives them all through.  It isn't necessarily a problem, but it conflicts with the model of dealing with one file at a time...
 */
public void testBuildingTwoGroovyFiles(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.997275204359673
185850,"public void testAliasing_GRE473(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testAliasing_GRE473(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9887640449438202
185851,"public void testBrokenPackage3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testBrokenPackage3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9933598937583
185852,"public void _testOverriding_GRE440(){
  if (GroovyUtils.isGroovy16())   return;
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"");
}","public void _testOverriding_GRE440(){
  if (GroovyUtils.isGroovy16())   return;
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
  checkGCUDeclaration(""String_Node_Str"",""String_Node_Str"");
}",0.9928057553956836
185853,"public void testProtectedType(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testProtectedType(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9929278642149928
185854,"public void testFieldPositioning01(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testFieldPositioning01(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9912434325744308
185855,"public void testStaticImports_JtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}","public void testStaticImports_JtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"");
}",0.9926144756277696
185856,"public void testImplementingInterface4(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface4(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992721979621543
185857,"public void _testGroovyPropertyAccessors_ErrorCases6(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void _testGroovyPropertyAccessors_ErrorCases6(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9936788874841972
185858,"public void testReferencingOtherTypesInSamePackage(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testReferencingOtherTypesInSamePackage(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9929676511954992
185859,"public void testImplementingInterface1(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface1(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9940828402366864
185860,"public void testImplementingInterface2(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testImplementingInterface2(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.992721979621543
185861,"public void testScript(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}","public void testScript(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
}",0.9785407725321889
185862,"public void testImplementingInterface3(){
  this.runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testImplementingInterface3(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9943374858437146
185863,"public void _testGroovyPropertyAccessors_ErrorCases5(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void _testGroovyPropertyAccessors_ErrorCases5(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9950738916256158
185864,"public void testInnerClass2() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerClass2() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9924585218702866
185865,"public void testInnerClass3() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerClass3() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9908925318761383
185866,"public void testTwoTopLevelTypesInAFile(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testTwoTopLevelTypesInAFile(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9906890130353816
185867,"public void testInvokingVarargs01_JtoG(){
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInvokingVarargs01_JtoG(){
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9953139643861292
185868,"public void testInnerClass1() throws Exception {
  this.runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}","public void testInnerClass1() throws Exception {
  runConformTest(new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""},""String_Node_Str"");
}",0.9894291754756872
185869,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185870,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185871,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.getName().equals(""String_Node_Str"") || ve.getName().equals(""String_Node_Str""));
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((StaticMethodCallExpression)ret).getMethod().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.getName().equals(""String_Node_Str"") || ve.getName().equals(""String_Node_Str""));
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((StaticMethodCallExpression)ret).getMethod().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9991964644435516
185872,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185873,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185874,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((StaticMethodCallExpression)ret).getMethod().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((StaticMethodCallExpression)ret).getMethod().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9992849481587416
185875,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185876,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185877,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9992869875222816
185878,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185879,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185880,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9992869875222816
185881,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185882,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185883,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9992869875222816
185884,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(getField(type,pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(getField(type,pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.putNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.9981818181818182
185885,"private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.setNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}","private Expression findStaticFieldOrPropAccessorImportFromModule(String name){
  ModuleNode module=currentClass.getModule();
  if (module == null)   return null;
  Map<String,ImportNode> importNodes=module.getStaticImports();
  Expression expression=null;
  String accessorName=getAccessorName(name);
  if (importNodes.containsKey(accessorName)) {
    ImportNode importNode=importNodes.get(accessorName);
    expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
    if (expression != null)     return expression;
    expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
    if (expression != null)     return expression;
  }
  if (accessorName.startsWith(""String_Node_Str"")) {
    accessorName=""String_Node_Str"" + accessorName.substring(3);
    if (importNodes.containsKey(accessorName)) {
      ImportNode importNode=importNodes.get(accessorName);
      expression=findStaticPropertyAccessorByFullName(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
      expression=findStaticPropertyAccessor(importNode.getType(),getPropNameForAccessor(importNode.getFieldName()));
      if (expression != null)       return expression;
    }
  }
  if (importNodes.containsKey(name)) {
    ImportNode importNode=importNodes.get(name);
    try {
      if (!isReconcile) {
        expression=findStaticPropertyAccessor(importNode.getType(),importNode.getFieldName());
        if (expression != null)         return expression;
      }
      expression=findStaticField(importNode.getType(),importNode.getFieldName());
      if (expression != null)       return expression;
    }
  finally {
      if (expression != null)       expression.putNodeMetaData(""String_Node_Str"",name);
    }
  }
  for (  ImportNode importNode : module.getStaticStarImports().values()) {
    ClassNode node=importNode.getType();
    expression=findStaticPropertyAccessor(node,name);
    if (expression != null)     return expression;
    expression=findStaticField(node,name);
    if (expression != null)     return expression;
  }
  return null;
}",0.9990762124711317
185886,"protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.setNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}","protected Expression transformMethodCallExpression(MethodCallExpression mce){
  Expression args=transform(mce.getArguments());
  Expression method=transform(mce.getMethod());
  Expression object=transform(mce.getObjectExpression());
  boolean isExplicitThisOrSuper=false;
  boolean isExplicitSuper=false;
  if (object instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)object;
    isExplicitThisOrSuper=!mce.isImplicitThis() && (ve.isThisExpression() || ve.isSuperExpression());
    isExplicitSuper=ve.isSuperExpression();
  }
  if (mce.isImplicitThis() || isExplicitThisOrSuper) {
    if (mce.isImplicitThis()) {
      Expression ret=findStaticMethodImportFromModule(method,args);
      if (ret != null) {
        if (!((MethodCall)ret).getMethodAsString().equals(method.getText())) {
          ret.putNodeMetaData(""String_Node_Str"",method.getText());
        }
        setSourcePosition(ret,mce);
        return ret;
      }
      if (method instanceof ConstantExpression && !inLeftExpression) {
        String methodName=(String)((ConstantExpression)method).getValue();
        ret=findStaticFieldOrPropAccessorImportFromModule(methodName);
        if (ret != null) {
          ret=new MethodCallExpression(ret,""String_Node_Str"",args);
          setSourcePosition(ret,mce);
          return ret;
        }
      }
    }
 else     if (currentMethod != null && currentMethod.isStatic() && isExplicitSuper) {
      MethodCallExpression ret=new MethodCallExpression(new ClassExpression(currentClass.getSuperClass()),method,args);
      setSourcePosition(ret,mce);
      return ret;
    }
    if (method instanceof ConstantExpression) {
      ConstantExpression ce=(ConstantExpression)method;
      Object value=ce.getValue();
      if (value instanceof String) {
        String methodName=(String)value;
        boolean lookForPossibleStaticMethod=!methodName.equals(""String_Node_Str"");
        if (currentMethod != null && !currentMethod.isStatic()) {
          if (currentClass.hasPossibleMethod(methodName,args)) {
            lookForPossibleStaticMethod=false;
          }
        }
        if (!inClosure && (inSpecialConstructorCall || (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName,args)))) {
          StaticMethodCallExpression smce=new StaticMethodCallExpression(currentClass,methodName,args);
          setSourcePosition(smce,mce);
          return smce;
        }
      }
    }
  }
  MethodCallExpression result=new MethodCallExpression(object,method,args);
  result.setSafe(mce.isSafe());
  result.setImplicitThis(mce.isImplicitThis());
  result.setSpreadSafe(mce.isSpreadSafe());
  result.setMethodTarget(mce.getMethodTarget());
  result.setGenericsTypes(mce.getGenericsTypes());
  setSourcePosition(result,mce);
  return result;
}",0.9992869875222816
185887,"public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9967336273068758
185888,"public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9967384213959556
185889,"public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=-1;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    sourceStart=typeReference.sourceStart;
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int end=retrieveEndOfElementTypeNamePosition(sourceStart,sourceStart + length);
if (end == -1) {
end=sourceStart + length - 1;
}
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
}
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
type.setSourceRange(sourceStart,length);
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
int end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
type=simpleType;
}
break;
default :
if (typeArguments != null) {
int numberOfEnclosingType=0;
int startingIndex=0;
int endingIndex=0;
for (int i=0, max=typeArguments.length; i < max; i++) {
if (typeArguments[i] != null) {
numberOfEnclosingType++;
}
 else if (numberOfEnclosingType == 0) {
endingIndex++;
}
}
Name name=null;
if (endingIndex - startingIndex == 0) {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
recordPendingNameScopeResolution(simpleName);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
simpleName.index=1;
name=simpleName;
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
}
}
 else {
name=this.setQualifiedNameNameAndSourceRanges(tokens,positions,endingIndex,typeReference);
}
SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(name);
int start=(int)(positions[startingIndex] >>> 32);
int end=(int)positions[endingIndex];
simpleType.setSourceRange(start,end - start + 1);
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
if (this.resolveBindings) {
recordNodes(simpleType,typeReference);
recordNodes(parameterizedType,typeReference);
}
start=simpleType.getStartPosition();
end=start + simpleType.getLength() - 1;
for (int i=0, max=typeArguments[endingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[endingIndex][i]);
parameterizedType.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
int indexOfEnclosingType=1;
parameterizedType.index=indexOfEnclosingType;
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType.setSourceRange(start,end - start + 1);
startingIndex=endingIndex + 1;
Type currentType=parameterizedType;
while (startingIndex < typeArguments.length) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(tokens[startingIndex]));
simpleName.index=startingIndex + 1;
start=(int)(positions[startingIndex] >>> 32);
end=(int)positions[startingIndex];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
indexOfEnclosingType++;
if (typeArguments[startingIndex] != null) {
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType2=new ParameterizedType(this.ast);
parameterizedType2.setType(qualifiedType);
parameterizedType2.index=indexOfEnclosingType;
if (this.resolveBindings) {
recordNodes(parameterizedType2,typeReference);
}
for (int i=0, max=typeArguments[startingIndex].length; i < max; i++) {
final Type type2=convertType(typeArguments[startingIndex][i]);
parameterizedType2.typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
length=end + 1;
parameterizedType2.setSourceRange(start,end - start + 1);
currentType=parameterizedType2;
}
 else {
currentType=qualifiedType;
qualifiedType.index=indexOfEnclosingType;
}
startingIndex++;
}
if (this.resolveBindings) {
this.recordNodes(currentType,typeReference);
}
type=currentType;
length-=sourceStart;
}
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
final Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
type=simpleType;
type.setSourceRange(sourceStart,length);
}
 else {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=this.ast.newArrayType(type,dimensions);
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
int end=retrieveEndOfDimensionsPosition(sourceStart + length,this.compilationUnitSourceLength);
if (end != -1) {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,length);
}
ArrayType subarrayType=(ArrayType)type;
int index=dimensions - 1;
while (index > 0) {
subarrayType=(ArrayType)subarrayType.getComponentType();
end=retrieveProperRightBracketPosition(index,sourceStart);
subarrayType.setSourceRange(sourceStart,end - sourceStart + 1);
index--;
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9967384213959556
185890,"public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9971992718106708
185891,"public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9971992718106708
185892,"public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9971992718106708
185893,"public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(sourceStart + simpleName.getLength());
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9959080893925086
185894,"public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
end=type2.getStartPosition() + type2.getLength() - 1;
}
end=retrieveClosingAngleBracketPosition(sourceStart + simpleName.getLength());
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}","public Type convertType(TypeReference typeReference){
  org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations;
  if (typeReference instanceof Wildcard) {
    final Wildcard wildcard=(Wildcard)typeReference;
    final WildcardType wildcardType=new WildcardType(this.ast);
    if (wildcard.bound != null) {
      final Type bound=convertType(wildcard.bound);
      wildcardType.setBound(bound,wildcard.kind == Wildcard.EXTENDS);
      int start=wildcard.sourceStart;
      wildcardType.setSourceRange(start,bound.getStartPosition() + bound.getLength() - start);
    }
 else {
      final int start=wildcard.sourceStart;
      final int end=wildcard.sourceEnd;
      wildcardType.setSourceRange(start,end - start + 1);
    }
    if (this.resolveBindings) {
      recordNodes(wildcardType,typeReference);
    }
    if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
      annotateType(wildcardType,annotations);
    }
    return wildcardType;
  }
  Type type=null;
  int sourceStart=typeReference.sourceStart;
  int length=0;
  int dimensions=typeReference.dimensions();
  if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.SingleTypeReference) {
    annotations=typeReference.annotations != null ? typeReference.annotations[0] : null;
    int annotationsEnd=annotations != null ? annotations[annotations.length - 1].declarationSourceEnd + 1 : -1;
    char[] name=((org.eclipse.jdt.internal.compiler.ast.SingleTypeReference)typeReference).getTypeName()[0];
    length=typeReference.sourceEnd - typeReference.sourceStart + 1;
    if (isPrimitiveType(name)) {
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      final PrimitiveType primitiveType=new PrimitiveType(this.ast);
      primitiveType.setPrimitiveTypeCode(getPrimitiveTypeCode(name));
      primitiveType.setSourceRange(sourceStart,end - sourceStart + 1);
      type=primitiveType;
      if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
        annotateType(primitiveType,annotations);
      }
    }
 else     if (typeReference instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference parameterizedSingleTypeReference=(ParameterizedSingleTypeReference)typeReference;
      final SimpleName simpleName=new SimpleName(this.ast);
      simpleName.internalSetIdentifier(new String(name));
      int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
      int end=positions[1];
      if (end == -1) {
        end=sourceStart + length - 1;
      }
      if (positions[0] != -1) {
        simpleName.setSourceRange(positions[0],end - positions[0] + 1);
      }
 else {
        simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
      }
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
        SimpleType simpleType=new SimpleType(this.ast);
      simpleType.setName(simpleName);
    simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
  simpleType.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
break;
default :
simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
simpleType.setSourceRange(simpleName.getStartPosition(),simpleName.getLength());
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
int newSourceStart=simpleType.getStartPosition();
if (newSourceStart > 0 && newSourceStart < sourceStart) sourceStart=newSourceStart;
final ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.setType(simpleType);
type=parameterizedType;
TypeReference[] typeArguments=parameterizedSingleTypeReference.typeArguments;
if (typeArguments != null) {
Type type2=null;
for (int i=0, max=typeArguments.length; i < max; i++) {
type2=convertType(typeArguments[i]);
((ParameterizedType)type).typeArguments().add(type2);
if (type2.getStartPosition() > 0) end=type2.getStartPosition() + type2.getLength() - 1;
 else end+=type2.toString().length();
}
end=retrieveClosingAngleBracketPosition(end + 1);
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
 else {
type.setSourceRange(sourceStart,end - sourceStart + 1);
}
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
this.recordNodes(simpleType,typeReference);
}
}
}
 else {
final SimpleName simpleName=new SimpleName(this.ast);
simpleName.internalSetIdentifier(new String(name));
int[] positions=retrieveEndOfElementTypeNamePosition(sourceStart < annotationsEnd ? annotationsEnd : sourceStart,sourceStart + length);
int end=positions[1];
if (end == -1) {
end=sourceStart + length - 1;
}
if (positions[0] != -1) {
simpleName.setSourceRange(positions[0],end - positions[0] + 1);
}
 else {
simpleName.setSourceRange(sourceStart,end - sourceStart + 1);
}
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(simpleName);
type=simpleType;
type.setSourceRange(sourceStart,end - sourceStart + 1);
type=simpleType;
if (this.resolveBindings) {
this.recordNodes(simpleName,typeReference);
}
if (typeReference.annotations != null && (annotations=typeReference.annotations[0]) != null) {
annotateType(simpleType,annotations);
}
}
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
 else {
if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference=(ParameterizedQualifiedTypeReference)typeReference;
char[][] tokens=parameterizedQualifiedTypeReference.tokens;
TypeReference[][] typeArguments=parameterizedQualifiedTypeReference.typeArguments;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=parameterizedQualifiedTypeReference.annotations;
TypeReference[] arguments=null;
int lenth=tokens.length;
int firstTypeIndex=lenth - 1;
long[] positions=parameterizedQualifiedTypeReference.sourcePositions;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
{
char[][] name=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).getTypeName();
int nameLength=name.length;
sourceStart=(int)(positions[0] >>> 32);
length=(int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
Name qualifiedName=this.setQualifiedNameNameAndSourceRanges(name,positions,typeReference);
final SimpleType simpleType=new SimpleType(this.ast);
simpleType.setName(qualifiedName);
simpleType.setSourceRange(sourceStart,length);
simpleType.setFlags(simpleType.getFlags() | ASTNode.MALFORMED);
type=simpleType;
}
break;
default :
boolean isTypeArgumentBased=false;
for (int i=0; i < lenth; ++i) {
if (typeArguments != null && typeArguments[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=true;
break;
}
if (typeAnnotations != null && typeAnnotations[i] != null) {
firstTypeIndex=i;
isTypeArgumentBased=false;
break;
}
}
int start=(int)(positions[0] >>> 32);
int end=(int)positions[firstTypeIndex];
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,isTypeArgumentBased);
int indexOfEnclosingType=1;
if (typeArguments != null && (arguments=typeArguments[firstTypeIndex]) != null) {
int arglen=arguments.length;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int i=0; i < arglen; ++i) {
type2=convertType(arguments[i]);
parameterizedType.typeArguments().add(type2);
}
if (type2 != null) {
if (type2.getLength() > 0) {
end=type2.getStartPosition() + type2.getLength() - 1;
}
 else if (type2.isSimpleType()) {
Name name=((SimpleType)type2).getName();
end+=name.toString().length() + 1;
System.err.println(""String_Node_Str"");
}
 else {
System.err.println(""String_Node_Str"");
}
}
end=retrieveClosingAngleBracketPosition(end + 1);
int baseStart=currentType.getStartPosition();
start=start <= baseStart ? start : baseStart;
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
SimpleName simpleName=new SimpleName(this.ast);
simpleName.setIdentifier(new String(tokens[i]));
simpleName.index=i + 1;
start=(int)(positions[i] >>> 32);
end=(int)positions[i];
simpleName.setSourceRange(start,end - start + 1);
recordPendingNameScopeResolution(simpleName);
QualifiedType qualifiedType=new QualifiedType(this.ast);
qualifiedType.setQualifier(currentType);
qualifiedType.setName(simpleName);
start=currentType.getStartPosition();
end=simpleName.getStartPosition() + simpleName.getLength() - 1;
qualifiedType.setSourceRange(start,end - start + 1);
if (typeAnnotations != null && (annotations=typeAnnotations[i]) != null) {
int nextPosition=annotateType(qualifiedType,annotations);
if (simpleName.getStartPosition() < nextPosition && nextPosition <= end) {
simpleName.setSourceRange(nextPosition,end - nextPosition + 1);
trimWhiteSpacesAndComments(simpleName);
}
}
if (this.resolveBindings) {
recordNodes(simpleName,typeReference);
recordNodes(qualifiedType,typeReference);
}
currentType=qualifiedType;
indexOfEnclosingType++;
if (typeArguments != null && (arguments=typeArguments[i]) != null) {
int arglen=arguments.length;
qualifiedType.index=indexOfEnclosingType;
ParameterizedType parameterizedType=new ParameterizedType(this.ast);
parameterizedType.index=indexOfEnclosingType;
parameterizedType.setType(currentType);
if (this.resolveBindings) {
recordNodes(parameterizedType,typeReference);
}
Type type2=null;
for (int j=0; j < arglen; ++j) {
type2=convertType(arguments[j]);
parameterizedType.typeArguments().add(type2);
}
end=type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
end=retrieveClosingAngleBracketPosition(end + 1);
parameterizedType.setSourceRange(start,end - start + 1);
currentType=parameterizedType;
}
 else {
qualifiedType.index=indexOfEnclosingType;
}
}
type=currentType;
}
}
 else if (typeReference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference) {
QualifiedTypeReference qualifiedTypeReference=(QualifiedTypeReference)typeReference;
long[] positions=((org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference)typeReference).sourcePositions;
org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations=typeReference.annotations;
char[][] tokens=qualifiedTypeReference.tokens;
int lenth=tokens.length;
int firstTypeIndex=lenth;
if (typeAnnotations != null) {
for (int i=0; i < lenth; ++i) {
if (typeAnnotations[i] != null) {
firstTypeIndex=i;
break;
}
}
}
Type currentType=createBaseType(typeReference,positions,typeAnnotations,tokens,lenth,firstTypeIndex,false);
for (int i=firstTypeIndex + 1; i < lenth; ++i) {
currentType=createQualifiedType(typeReference,positions,typeAnnotations,tokens,i,currentType);
}
type=currentType;
}
 else if (typeReference instanceof UnionTypeReference) {
TypeReference[] typeReferences=((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final UnionType unionType=new UnionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
unionType.types().add(this.convertType(typeReferences[i]));
}
type=unionType;
List types=unionType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
 else if (typeReference instanceof IntersectionCastTypeReference) {
TypeReference[] typeReferences=((IntersectionCastTypeReference)typeReference).typeReferences;
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
case AST.JLS4_INTERNAL:
type=this.convertType(typeReferences[0]);
int start=typeReference.sourceStart;
int endPosition=typeReference.sourceEnd;
length=endPosition - start + 1;
type.setSourceRange(start,length);
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
break;
default :
final IntersectionType castType=new IntersectionType(this.ast);
for (int i=0, max=typeReferences.length; i < max; i++) {
castType.types().add(this.convertType(typeReferences[i]));
}
type=castType;
List types=castType.types();
int size=types.size();
start=((Type)types.get(0)).getStartPosition();
Type lastType=(Type)types.get(size - 1);
endPosition=lastType.getStartPosition() + lastType.getLength();
length=endPosition - start;
type.setSourceRange(start,length);
}
}
length=typeReference.sourceEnd - sourceStart + 1;
if (dimensions != 0) {
type=convertToArray(type,sourceStart,length,dimensions,typeReference.getAnnotationsOnDimensions(true));
if (this.resolveBindings) {
completeRecord((ArrayType)type,typeReference);
}
}
}
if (this.resolveBindings) {
this.recordNodes(type,typeReference);
}
boolean sawDiamond=false;
if (typeReference instanceof ParameterizedSingleTypeReference) {
ParameterizedSingleTypeReference pstr=(ParameterizedSingleTypeReference)typeReference;
if (pstr.typeArguments == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
}
}
 else if (typeReference instanceof ParameterizedQualifiedTypeReference) {
ParameterizedQualifiedTypeReference pqtr=(ParameterizedQualifiedTypeReference)typeReference;
for (int i=0, len=pqtr.typeArguments.length; i < len; i++) {
if (pqtr.typeArguments[i] == TypeReference.NO_TYPE_ARGUMENTS) {
sawDiamond=true;
break;
}
}
}
if (sawDiamond) {
switch (this.ast.apiLevel) {
case AST.JLS2_INTERNAL:
case AST.JLS3_INTERNAL:
type.setFlags(type.getFlags() | ASTNode.MALFORMED);
}
}
return type;
}",0.9959080893925086
185895,"/** 
 * Use a SearchEngine to look for the types. <p> NOTE: This will not find inner types.
 * @see OrganizeImportsOperation.TypeReferenceProcessor#process(org.eclipse.core.runtime.IProgressMonitor)
 */
public void searchForTypes(GroovyCompilationUnit unit,Map<String,UnresolvedTypeData> missingTypes,IProgressMonitor monitor) throws JavaModelException {
  char[][] allTypes=new char[missingTypes.size()][];
  int i=0;
  for (  String simpleName : missingTypes.keySet()) {
    allTypes[i++]=simpleName.toCharArray();
  }
  final List<TypeNameMatch> typesFound=new ArrayList<TypeNameMatch>();
  TypeNameMatchCollector collector=new TypeNameMatchCollector(typesFound);
  IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{unit.getJavaProject()});
  int policy=(monitor == null ? IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH : IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH);
  new SearchEngine().searchAllTypeNames(null,allTypes,scope,collector,policy,monitor);
  for (  TypeNameMatch match : typesFound) {
    UnresolvedTypeData data=missingTypes.get(match.getSimpleTypeName());
    if (data == null) {
      GroovyCore.logException(""String_Node_Str"" + match.getFullyQualifiedName(),new Exception());
      continue;
    }
    if (isOfKind(match,data.isAnnotation)) {
      data.addInfo(match);
    }
  }
}","/** 
 * Use a SearchEngine to look for the types. <p> NOTE: This will not find inner types.
 * @see OrganizeImportsOperation.TypeReferenceProcessor#process(org.eclipse.core.runtime.IProgressMonitor)
 */
public void searchForTypes(GroovyCompilationUnit unit,Map<String,UnresolvedTypeData> missingTypes,IProgressMonitor monitor) throws JavaModelException, OperationCanceledException {
  char[][] allTypes=new char[missingTypes.size()][];
  int i=0;
  for (  String simpleName : missingTypes.keySet()) {
    allTypes[i++]=simpleName.toCharArray();
  }
  final List<TypeNameMatch> typesFound=new ArrayList<TypeNameMatch>();
  TypeNameMatchCollector collector=new TypeNameMatchCollector(typesFound);
  IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{unit.getJavaProject()});
  int policy=(monitor == null ? IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH : IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH);
  new SearchEngine().searchAllTypeNames(null,allTypes,scope,collector,policy,monitor);
  for (  TypeNameMatch match : typesFound) {
    UnresolvedTypeData data=missingTypes.get(match.getSimpleTypeName());
    if (data == null) {
      GroovyCore.logException(""String_Node_Str"" + match.getFullyQualifiedName(),new Exception());
      continue;
    }
    if (isOfKind(match,data.isAnnotation)) {
      data.addInfo(match);
    }
  }
}",0.9803485354097144
185896,"private boolean hasScriptStatements(BlockStatement statements){
  return statements != null && statements.getStatements() != null && statements.getStatements().size() > 0;
}","private boolean hasScriptStatements(BlockStatement statement){
  return statement != null && statement.getStatements() != null && !statement.getStatements().isEmpty();
}",0.9473684210526316
185897,"private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}","/** 
 * Returns the last ast node in the script, either a method or a statement. 
 */
private ASTNode getLast(BlockStatement statement,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statement) ? statement.getStatements().get(statement.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}",0.902088772845953
185898,"private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}","/** 
 * Returns the first ast node in the script, either a method or a statement. 
 */
private ASTNode getFirst(BlockStatement statement,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statement) ? statement.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}",0.9383561643835616
185899,"private boolean hasScriptMethods(List<MethodNode> methods){
  return methods != null && methods.size() > 0;
}","private boolean hasScriptMethods(List<MethodNode> methods){
  return methods != null && !methods.isEmpty();
}",0.9357798165137616
185900,"private void fixModuleNodeLocations(){
  output.setStart(0);
  output.setEnd(locations.getEnd());
  output.setLineNumber(1);
  output.setColumnNumber(1);
  output.setLastColumnNumber(locations.getEndColumn());
  output.setLastLineNumber(locations.getEndLine());
  BlockStatement statements=output.getStatementBlock();
  List<MethodNode> methods=output.getMethods();
  if (hasScriptMethodsOrStatements(statements,methods)) {
    ASTNode first=getFirst(statements,methods);
    ASTNode last=getLast(statements,methods);
    if (hasScriptStatements(statements)) {
      statements.setStart(first.getStart());
      statements.setLineNumber(first.getLineNumber());
      statements.setColumnNumber(first.getColumnNumber());
      statements.setEnd(last.getEnd());
      statements.setLastLineNumber(last.getLastLineNumber());
      statements.setLastColumnNumber(last.getLastColumnNumber());
    }
    if (output.getClasses().size() > 0) {
      ClassNode scriptClass=output.getClasses().get(0);
      scriptClass.setStart(first.getStart());
      scriptClass.setLineNumber(first.getLineNumber());
      scriptClass.setColumnNumber(first.getColumnNumber());
      scriptClass.setEnd(last.getEnd());
      scriptClass.setLastLineNumber(last.getLastLineNumber());
      scriptClass.setLastColumnNumber(last.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",new Parameter[0]);
      runMethod.setStart(first.getStart());
      runMethod.setLineNumber(first.getLineNumber());
      runMethod.setColumnNumber(first.getColumnNumber());
      runMethod.setEnd(last.getEnd());
      runMethod.setLastLineNumber(last.getLastLineNumber());
      runMethod.setLastColumnNumber(last.getLastColumnNumber());
    }
  }
}","private void fixModuleNodeLocations(){
  output.setStart(0);
  output.setEnd(locations.getEnd());
  output.setLineNumber(1);
  output.setColumnNumber(1);
  output.setLastColumnNumber(locations.getEndColumn());
  output.setLastLineNumber(locations.getEndLine());
  BlockStatement statement=output.getStatementBlock();
  List<MethodNode> methods=output.getMethods();
  if (hasScriptStatements(statement) || hasScriptMethods(methods)) {
    ASTNode first=getFirst(statement,methods);
    ASTNode last=getLast(statement,methods);
    if (hasScriptStatements(statement)) {
      statement.setStart(first.getStart());
      statement.setLineNumber(first.getLineNumber());
      statement.setColumnNumber(first.getColumnNumber());
      statement.setEnd(last.getEnd());
      statement.setLastLineNumber(last.getLastLineNumber());
      statement.setLastColumnNumber(last.getLastColumnNumber());
    }
    if (!output.getClasses().isEmpty()) {
      ClassNode scriptClass=output.getClasses().get(0);
      scriptClass.setStart(first.getStart());
      scriptClass.setLineNumber(first.getLineNumber());
      scriptClass.setColumnNumber(first.getColumnNumber());
      scriptClass.setEnd(last.getEnd());
      scriptClass.setLastLineNumber(last.getLastLineNumber());
      scriptClass.setLastColumnNumber(last.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",new Parameter[0]);
      runMethod.setStart(first.getStart());
      runMethod.setLineNumber(first.getLineNumber());
      runMethod.setColumnNumber(first.getColumnNumber());
      runMethod.setEnd(last.getEnd());
      runMethod.setLastLineNumber(last.getLastLineNumber());
      runMethod.setLastColumnNumber(last.getLastColumnNumber());
    }
  }
}",0.9283471310305452
185901,"private Statement createSyntheticAfterImports(){
  ASTNode target=null;
  Statement synthetic=ReturnStatement.RETURN_NULL_OR_VOID;
  if (output.getImports() != null && output.getImports().size() > 0) {
    target=output.getImports().get(output.getImports().size() - 1);
  }
 else   if (output.hasPackage()) {
    target=output.getPackage();
  }
  if (target != null) {
    synthetic=new ReturnStatement(ConstantExpression.NULL);
    synthetic.setStart(target.getEnd() + 1);
    synthetic.setEnd(target.getEnd() + 1);
    synthetic.setLineNumber(target.getLastLineNumber());
    synthetic.setLastLineNumber(target.getLineNumber());
    synthetic.setColumnNumber(target.getLastColumnNumber() + 1);
    synthetic.setLastColumnNumber(target.getColumnNumber() + 1);
  }
  return synthetic;
}","/** 
 * Creates a synthetic statement that starts after the last import or package statement. 
 */
private Statement createSyntheticAfterImports(){
  Statement synthetic=ReturnStatement.RETURN_NULL_OR_VOID;
  ASTNode target=null;
  if (output.getImports() != null && !output.getImports().isEmpty()) {
    target=output.getImports().get(output.getImports().size() - 1);
  }
 else   if (output.hasPackage()) {
    target=output.getPackage();
  }
  if (target != null) {
    int off=Math.min(locations.findOffset(target.getLastLineNumber() + 1,1),locations.getEnd() - 1);
    int[] row_col=locations.getRowCol(off);
    synthetic=new ReturnStatement(ConstantExpression.NULL);
    synthetic.setStart(off);
    synthetic.setEnd(off);
    synthetic.setLineNumber(row_col[0]);
    synthetic.setColumnNumber(row_col[1]);
    synthetic.setLastLineNumber(row_col[0]);
    synthetic.setLastColumnNumber(row_col[1]);
  }
  return synthetic;
}",0.5303030303030303
185902,"private boolean hasScriptStatements(BlockStatement statements){
  return statements != null && statements.getStatements() != null && statements.getStatements().size() > 0;
}","private boolean hasScriptStatements(BlockStatement statement){
  return statement != null && statement.getStatements() != null && !statement.getStatements().isEmpty();
}",0.9473684210526316
185903,"private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}","/** 
 * Returns the last ast node in the script, either a method or a statement. 
 */
private ASTNode getLast(BlockStatement statement,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statement) ? statement.getStatements().get(statement.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}",0.902088772845953
185904,"private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}","/** 
 * Returns the first ast node in the script, either a method or a statement. 
 */
private ASTNode getFirst(BlockStatement statement,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statement) ? statement.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}",0.9383561643835616
185905,"private boolean hasScriptMethods(List<MethodNode> methods){
  return methods != null && methods.size() > 0;
}","private boolean hasScriptMethods(List<MethodNode> methods){
  return methods != null && !methods.isEmpty();
}",0.9357798165137616
185906,"private void fixModuleNodeLocations(){
  output.setStart(0);
  output.setEnd(locations.getEnd());
  output.setLineNumber(1);
  output.setColumnNumber(1);
  output.setLastColumnNumber(locations.getEndColumn());
  output.setLastLineNumber(locations.getEndLine());
  BlockStatement statements=output.getStatementBlock();
  List<MethodNode> methods=output.getMethods();
  if (hasScriptMethodsOrStatements(statements,methods)) {
    ASTNode first=getFirst(statements,methods);
    ASTNode last=getLast(statements,methods);
    if (hasScriptStatements(statements)) {
      statements.setStart(first.getStart());
      statements.setLineNumber(first.getLineNumber());
      statements.setColumnNumber(first.getColumnNumber());
      statements.setEnd(last.getEnd());
      statements.setLastLineNumber(last.getLastLineNumber());
      statements.setLastColumnNumber(last.getLastColumnNumber());
    }
    if (output.getClasses().size() > 0) {
      ClassNode scriptClass=output.getClasses().get(0);
      scriptClass.setStart(first.getStart());
      scriptClass.setLineNumber(first.getLineNumber());
      scriptClass.setColumnNumber(first.getColumnNumber());
      scriptClass.setEnd(last.getEnd());
      scriptClass.setLastLineNumber(last.getLastLineNumber());
      scriptClass.setLastColumnNumber(last.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",new Parameter[0]);
      runMethod.setStart(first.getStart());
      runMethod.setLineNumber(first.getLineNumber());
      runMethod.setColumnNumber(first.getColumnNumber());
      runMethod.setEnd(last.getEnd());
      runMethod.setLastLineNumber(last.getLastLineNumber());
      runMethod.setLastColumnNumber(last.getLastColumnNumber());
    }
  }
}","private void fixModuleNodeLocations(){
  output.setStart(0);
  output.setEnd(locations.getEnd());
  output.setLineNumber(1);
  output.setColumnNumber(1);
  output.setLastColumnNumber(locations.getEndColumn());
  output.setLastLineNumber(locations.getEndLine());
  BlockStatement statement=output.getStatementBlock();
  List<MethodNode> methods=output.getMethods();
  if (hasScriptStatements(statement) || hasScriptMethods(methods)) {
    ASTNode first=getFirst(statement,methods);
    ASTNode last=getLast(statement,methods);
    if (hasScriptStatements(statement)) {
      statement.setStart(first.getStart());
      statement.setLineNumber(first.getLineNumber());
      statement.setColumnNumber(first.getColumnNumber());
      statement.setEnd(last.getEnd());
      statement.setLastLineNumber(last.getLastLineNumber());
      statement.setLastColumnNumber(last.getLastColumnNumber());
    }
    if (!output.getClasses().isEmpty()) {
      ClassNode scriptClass=output.getClasses().get(0);
      scriptClass.setStart(first.getStart());
      scriptClass.setLineNumber(first.getLineNumber());
      scriptClass.setColumnNumber(first.getColumnNumber());
      scriptClass.setEnd(last.getEnd());
      scriptClass.setLastLineNumber(last.getLastLineNumber());
      scriptClass.setLastColumnNumber(last.getLastColumnNumber());
      MethodNode runMethod=scriptClass.getDeclaredMethod(""String_Node_Str"",new Parameter[0]);
      runMethod.setStart(first.getStart());
      runMethod.setLineNumber(first.getLineNumber());
      runMethod.setColumnNumber(first.getColumnNumber());
      runMethod.setEnd(last.getEnd());
      runMethod.setLastLineNumber(last.getLastLineNumber());
      runMethod.setLastColumnNumber(last.getLastColumnNumber());
    }
  }
}",0.9283471310305452
185907,"private Statement createSyntheticAfterImports(){
  ASTNode target=null;
  Statement synthetic=ReturnStatement.RETURN_NULL_OR_VOID;
  if (output.getImports() != null && output.getImports().size() > 0) {
    target=output.getImports().get(output.getImports().size() - 1);
  }
 else   if (output.hasPackage()) {
    target=output.getPackage();
  }
  if (target != null) {
    synthetic=new ReturnStatement(ConstantExpression.NULL);
    synthetic.setStart(target.getEnd() + 1);
    synthetic.setEnd(target.getEnd() + 1);
    synthetic.setLineNumber(target.getLastLineNumber());
    synthetic.setLastLineNumber(target.getLineNumber());
    synthetic.setColumnNumber(target.getLastColumnNumber() + 1);
    synthetic.setLastColumnNumber(target.getColumnNumber() + 1);
  }
  return synthetic;
}","/** 
 * Creates a synthetic statement that starts after the last import or package statement. 
 */
private Statement createSyntheticAfterImports(){
  Statement synthetic=ReturnStatement.RETURN_NULL_OR_VOID;
  ASTNode target=null;
  if (output.getImports() != null && !output.getImports().isEmpty()) {
    target=output.getImports().get(output.getImports().size() - 1);
  }
 else   if (output.hasPackage()) {
    target=output.getPackage();
  }
  if (target != null) {
    int off=Math.min(locations.findOffset(target.getLastLineNumber() + 1,1),locations.getEnd() - 1);
    int[] row_col=locations.getRowCol(off);
    synthetic=new ReturnStatement(ConstantExpression.NULL);
    synthetic.setStart(off);
    synthetic.setEnd(off);
    synthetic.setLineNumber(row_col[0]);
    synthetic.setColumnNumber(row_col[1]);
    synthetic.setLastLineNumber(row_col[0]);
    synthetic.setLastColumnNumber(row_col[1]);
  }
  return synthetic;
}",0.5303030303030303
185908,"protected String printProposals(ICompletionProposal[] proposals){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  for (  ICompletionProposal proposal : proposals) {
    sb.append(proposal.getDisplayString() + ""String_Node_Str"");
  }
  return sb.toString();
}","protected String printProposals(ICompletionProposal[] proposals){
  StringBuilder sb=new StringBuilder();
  for (  ICompletionProposal proposal : proposals) {
    sb.append('\n').append(proposal.getDisplayString());
    if (proposal instanceof IJavaCompletionProposal) {
      sb.append(""String_Node_Str"").append(((IJavaCompletionProposal)proposal).getRelevance()).append(')');
    }
  }
  return sb.toString();
}",0.4246771879483501
185909,"protected void proposalExists(ICompletionProposal[] proposals,String name,int expectedCount,boolean isType){
  int foundCount=0;
  for (  ICompletionProposal proposal : proposals) {
    String propName=proposal.getDisplayString();
    if (propName.startsWith(name + ""String_Node_Str"")) {
      foundCount+=1;
    }
 else     if (propName.startsWith(name + ""String_Node_Str"")) {
      foundCount+=1;
    }
 else     if (isType && propName.startsWith(name)) {
      foundCount+=1;
    }
  }
  if (foundCount != expectedCount) {
    StringBuffer sb=new StringBuffer();
    for (    ICompletionProposal proposal : proposals) {
      sb.append(""String_Node_Str"" + proposal.toString());
    }
    fail(""String_Node_Str"" + name + ""String_Node_Str""+ expectedCount+ ""String_Node_Str""+ foundCount+ ""String_Node_Str""+ sb);
  }
}","protected void proposalExists(ICompletionProposal[] proposals,String name,int expectedCount,boolean isType){
  int foundCount=0;
  for (  ICompletionProposal proposal : proposals) {
    String propName=proposal.getDisplayString();
    if (propName.startsWith(name + ""String_Node_Str"")) {
      foundCount+=1;
    }
 else     if (propName.startsWith(name + ""String_Node_Str"")) {
      foundCount+=1;
    }
 else     if (isType && propName.startsWith(name)) {
      foundCount+=1;
    }
  }
  if (foundCount != expectedCount) {
    fail(""String_Node_Str"" + name + ""String_Node_Str""+ expectedCount+ ""String_Node_Str""+ foundCount+ ""String_Node_Str""+ printProposals(proposals));
  }
}",0.7192513368983957
185910,"protected void assertProposalOrdering(ICompletionProposal[] proposals,String... order){
  int startFrom=0;
  for (  String propName : order) {
    startFrom=findProposal(proposals,propName,false,startFrom) + 1;
    if (startFrom == 0) {
      fail(""String_Node_Str"" + propName + ""String_Node_Str""+ printProposals(proposals));
    }
  }
}","protected void assertProposalOrdering(ICompletionProposal[] proposals,String... order){
  int prev=-1;
  for (int i=0, n=order.length; i < n; i+=1) {
    int next=findProposal(proposals,order[i],false,prev + 1);
    String message;
    if (i == 0) {
      message=String.format(""String_Node_Str"",order[i]);
    }
 else {
      message=String.format(""String_Node_Str"",order[i - 1],order[i]);
    }
    assertTrue(message + printProposals(proposals),next > prev);
    prev=next;
  }
}",0.5225885225885226
185911,"protected void checkProposalApplication(String contents,int proposalLocation,String[] expecteds,String[] proposalNames) throws Exception {
  ICompletionProposal[] proposals=createProposalsAtOffset(contents,proposalLocation);
  for (int i=0; i < expecteds.length; i++) {
    ICompletionProposal firstProposal=findFirstProposal(proposals,proposalNames[i],false);
    if (firstProposal == null) {
      fail(""String_Node_Str"");
    }
    applyProposalAndCheck(new Document(contents),firstProposal,expecteds[i]);
  }
}","protected void checkProposalApplication(String contents,int proposalLocation,String[] expecteds,String[] proposalNames) throws Exception {
  ICompletionProposal[] proposals=createProposalsAtOffset(contents,proposalLocation);
  for (int i=0; i < expecteds.length; i++) {
    ICompletionProposal firstProposal=findFirstProposal(proposals,proposalNames[i],false);
    assertNotNull(""String_Node_Str"",firstProposal);
    applyProposalAndCheck(new Document(contents),firstProposal,expecteds[i]);
  }
}",0.9306930693069309
185912,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null)       return constant;
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.8162618796198522
185913,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null)       return constant;
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.8162618796198522
185914,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null)       return constant;
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.8162618796198522
185915,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null)       return constant;
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.8162618796198522
185916,"private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null)       return constant;
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}","private Expression transformInlineConstants(Expression exp){
  if (exp instanceof PropertyExpression) {
    PropertyExpression pe=(PropertyExpression)exp;
    if (pe.getObjectExpression() instanceof ClassExpression) {
      ClassExpression ce=(ClassExpression)pe.getObjectExpression();
      ClassNode type=ce.getType();
      if (type.isEnum())       return exp;
      Expression constant=findConstant(type.getField(pe.getPropertyAsString()));
      if (constant != null) {
        String name=pe.getText().replace('$','.');
        Object alias=pe.getNodeMetaData(""String_Node_Str"");
        if (alias != null && !alias.equals(pe.getPropertyAsString())) {
          name+=""String_Node_Str"" + alias;
        }
        constant.setNodeMetaData(""String_Node_Str"",name);
        return constant;
      }
    }
  }
 else   if (exp instanceof ListExpression) {
    ListExpression le=(ListExpression)exp;
    ListExpression result=new ListExpression();
    for (    Expression e : le.getExpressions()) {
      result.addExpression(transformInlineConstants(e));
    }
    return result;
  }
  return exp;
}",0.8162618796198522
185917,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    if (tagBits != 0) {
switch (this.recipient.kind()) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
}
}
if (scope.compilationUnitScope().checkTargetCompatibility()) {
checkTargetCompatibility: {
long metaTagBits=annotationType.getAnnotationTagBits();
if ((metaTagBits & TagBits.AnnotationTargetMASK) == 0) break checkTargetCompatibility;
switch (this.recipient.kind()) {
case Binding.PACKAGE:
if ((metaTagBits & TagBits.AnnotationForPackage) != 0) break checkTargetCompatibility;
break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
if (((ReferenceBinding)this.recipient).isAnnotationType()) {
if ((metaTagBits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType)) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForType) != 0) {
break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForPackage) != 0) {
if (CharOperation.equals(((ReferenceBinding)this.recipient).sourceName,TypeConstants.PACKAGE_INFO_NAME)) break checkTargetCompatibility;
}
break;
case Binding.METHOD:
if (((MethodBinding)this.recipient).isConstructor()) {
if ((metaTagBits & TagBits.AnnotationForConstructor) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForMethod) != 0) break checkTargetCompatibility;
break;
case Binding.FIELD:
if ((metaTagBits & TagBits.AnnotationForField) != 0) break checkTargetCompatibility;
break;
case Binding.LOCAL:
if ((((LocalVariableBinding)this.recipient).tagBits & TagBits.IsArgument) != 0) {
if ((metaTagBits & TagBits.AnnotationForParameter) != 0) break checkTargetCompatibility;
}
 else if ((annotationType.tagBits & TagBits.AnnotationForLocalVariable) != 0) break checkTargetCompatibility;
break;
}
scope.problemReporter().disallowedTargetForAnnotation(this);
}
}
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    if (tagBits != 0) {
switch (this.recipient.kind()) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
}
}
if (scope.compilationUnitScope().checkTargetCompatibility()) {
checkTargetCompatibility: {
long metaTagBits=annotationType.getAnnotationTagBits();
if ((metaTagBits & TagBits.AnnotationTargetMASK) == 0) break checkTargetCompatibility;
switch (this.recipient.kind()) {
case Binding.PACKAGE:
if ((metaTagBits & TagBits.AnnotationForPackage) != 0) break checkTargetCompatibility;
break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
if (((ReferenceBinding)this.recipient).isAnnotationType()) {
if ((metaTagBits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType)) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForType) != 0) {
break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForPackage) != 0) {
if (CharOperation.equals(((ReferenceBinding)this.recipient).sourceName,TypeConstants.PACKAGE_INFO_NAME)) break checkTargetCompatibility;
}
break;
case Binding.METHOD:
if (((MethodBinding)this.recipient).isConstructor()) {
if ((metaTagBits & TagBits.AnnotationForConstructor) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForMethod) != 0) break checkTargetCompatibility;
break;
case Binding.FIELD:
if ((metaTagBits & TagBits.AnnotationForField) != 0) break checkTargetCompatibility;
break;
case Binding.LOCAL:
if ((((LocalVariableBinding)this.recipient).tagBits & TagBits.IsArgument) != 0) {
if ((metaTagBits & TagBits.AnnotationForParameter) != 0) break checkTargetCompatibility;
}
 else if ((annotationType.tagBits & TagBits.AnnotationForLocalVariable) != 0) break checkTargetCompatibility;
break;
}
scope.problemReporter().disallowedTargetForAnnotation(this);
}
}
}
return this.resolvedType;
}",0.9967182987660804
185918,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    if (tagBits != 0) {
switch (this.recipient.kind()) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
}
}
if (scope.compilationUnitScope().checkTargetCompatibility()) {
checkTargetCompatibility: {
long metaTagBits=annotationType.getAnnotationTagBits();
if ((metaTagBits & TagBits.AnnotationTargetMASK) == 0) break checkTargetCompatibility;
switch (this.recipient.kind()) {
case Binding.PACKAGE:
if ((metaTagBits & TagBits.AnnotationForPackage) != 0) break checkTargetCompatibility;
break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
if (((ReferenceBinding)this.recipient).isAnnotationType()) {
if ((metaTagBits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType)) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForType) != 0) {
break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForPackage) != 0) {
if (CharOperation.equals(((ReferenceBinding)this.recipient).sourceName,TypeConstants.PACKAGE_INFO_NAME)) break checkTargetCompatibility;
}
break;
case Binding.METHOD:
if (((MethodBinding)this.recipient).isConstructor()) {
if ((metaTagBits & TagBits.AnnotationForConstructor) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForMethod) != 0) break checkTargetCompatibility;
break;
case Binding.FIELD:
if ((metaTagBits & TagBits.AnnotationForField) != 0) break checkTargetCompatibility;
break;
case Binding.LOCAL:
if ((((LocalVariableBinding)this.recipient).tagBits & TagBits.IsArgument) != 0) {
if ((metaTagBits & TagBits.AnnotationForParameter) != 0) break checkTargetCompatibility;
}
 else if ((annotationType.tagBits & TagBits.AnnotationForLocalVariable) != 0) break checkTargetCompatibility;
break;
}
scope.problemReporter().disallowedTargetForAnnotation(this);
}
}
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    if (tagBits != 0) {
switch (this.recipient.kind()) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TAGBITS_NULLABLE_OR_NONNULL;
}
break;
}
}
if (scope.compilationUnitScope().checkTargetCompatibility()) {
checkTargetCompatibility: {
long metaTagBits=annotationType.getAnnotationTagBits();
if ((metaTagBits & TagBits.AnnotationTargetMASK) == 0) break checkTargetCompatibility;
switch (this.recipient.kind()) {
case Binding.PACKAGE:
if ((metaTagBits & TagBits.AnnotationForPackage) != 0) break checkTargetCompatibility;
break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
if (((ReferenceBinding)this.recipient).isAnnotationType()) {
if ((metaTagBits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType)) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForType) != 0) {
break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForPackage) != 0) {
if (CharOperation.equals(((ReferenceBinding)this.recipient).sourceName,TypeConstants.PACKAGE_INFO_NAME)) break checkTargetCompatibility;
}
break;
case Binding.METHOD:
if (((MethodBinding)this.recipient).isConstructor()) {
if ((metaTagBits & TagBits.AnnotationForConstructor) != 0) break checkTargetCompatibility;
}
 else if ((metaTagBits & TagBits.AnnotationForMethod) != 0) break checkTargetCompatibility;
break;
case Binding.FIELD:
if ((metaTagBits & TagBits.AnnotationForField) != 0) break checkTargetCompatibility;
break;
case Binding.LOCAL:
if ((((LocalVariableBinding)this.recipient).tagBits & TagBits.IsArgument) != 0) {
if ((metaTagBits & TagBits.AnnotationForParameter) != 0) break checkTargetCompatibility;
}
 else if ((annotationType.tagBits & TagBits.AnnotationForLocalVariable) != 0) break checkTargetCompatibility;
break;
}
scope.problemReporter().disallowedTargetForAnnotation(this);
}
}
}
return this.resolvedType;
}",0.996803477816136
185919,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
checkAnnotationTarget(this,scope,annotationType,kind);
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
checkAnnotationTarget(this,scope,annotationType,kind);
}
return this.resolvedType;
}",0.5984358550157919
185920,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
checkAnnotationTarget(this,scope,annotationType,kind);
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().typeMismatchError(typeBinding,scope.getJavaLangAnnotationAnnotation(),this.type,null);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd);
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
checkAnnotationTarget(this,scope,annotationType,kind);
}
return this.resolvedType;
}",0.6115798661623509
185921,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().notAnnotationType(typeBinding,this.type);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd,scope.referenceContext());
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
if (kind == Binding.TYPE) {
SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
if (CharOperation.equals(sourceType.sourceName,TypeConstants.PACKAGE_INFO_NAME)) kind=Binding.PACKAGE;
}
checkAnnotationTarget(this,scope,annotationType,kind,this.recipient,tagBits & TagBits.AnnotationNullMASK);
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().notAnnotationType(typeBinding,this.type);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd,scope.referenceContext());
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
if (kind == Binding.TYPE) {
SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
if (CharOperation.equals(sourceType.sourceName,TypeConstants.PACKAGE_INFO_NAME)) kind=Binding.PACKAGE;
}
checkAnnotationTarget(this,scope,annotationType,kind,this.recipient,tagBits & TagBits.AnnotationNullMASK);
}
return this.resolvedType;
}",0.996480360411094
185922,"public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,computeElementValuePairs());
    }
 else {
      scope.problemReporter().notAnnotationType(typeBinding,this.type);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd,scope.referenceContext());
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
if (kind == Binding.TYPE) {
SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
if (CharOperation.equals(sourceType.sourceName,TypeConstants.PACKAGE_INFO_NAME)) kind=Binding.PACKAGE;
}
checkAnnotationTarget(this,scope,annotationType,kind,this.recipient,tagBits & TagBits.AnnotationNullMASK);
}
return this.resolvedType;
}","public TypeBinding resolveType(BlockScope scope){
  if (this.compilerAnnotation != null)   return this.resolvedType;
  this.constant=Constant.NotAConstant;
  TypeBinding typeBinding=this.type.resolveType(scope);
  if (typeBinding == null) {
    return null;
  }
  this.resolvedType=typeBinding;
  boolean isGroovyAlias=isFakeGroovyAnnotation(typeBinding);
  if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
    if (isGroovyAlias) {
      this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,Binding.NO_ELEMENT_VALUE_PAIRS);
    }
 else {
      scope.problemReporter().notAnnotationType(typeBinding,this.type);
    }
    return null;
  }
  ReferenceBinding annotationType=(ReferenceBinding)this.resolvedType;
  MethodBinding[] methods=annotationType.methods();
  MemberValuePair[] originalValuePairs=memberValuePairs();
  MemberValuePair valueAttribute=null;
  MemberValuePair[] pairs;
  int pairsLength=originalValuePairs.length;
  if (pairsLength > 0) {
    System.arraycopy(originalValuePairs,0,pairs=new MemberValuePair[pairsLength],0,pairsLength);
  }
 else {
    pairs=originalValuePairs;
  }
  nextMember:   for (int i=0, requiredLength=methods.length; i < requiredLength; i++) {
    MethodBinding method=methods[i];
    char[] selector=method.selector;
    boolean foundValue=false;
    nextPair:     for (int j=0; j < pairsLength; j++) {
      MemberValuePair pair=pairs[j];
      if (pair == null)       continue nextPair;
      char[] name=pair.name;
      if (CharOperation.equals(name,selector)) {
        if (valueAttribute == null && CharOperation.equals(name,TypeConstants.VALUE)) {
          valueAttribute=pair;
        }
        pair.binding=method;
        pair.resolveTypeExpecting(scope,method.returnType);
        pairs[j]=null;
        foundValue=true;
        boolean foundDuplicate=false;
        for (int k=j + 1; k < pairsLength; k++) {
          MemberValuePair otherPair=pairs[k];
          if (otherPair == null)           continue;
          if (CharOperation.equals(otherPair.name,selector)) {
            foundDuplicate=true;
            scope.problemReporter().duplicateAnnotationValue(annotationType,otherPair);
            otherPair.binding=method;
            otherPair.resolveTypeExpecting(scope,method.returnType);
            pairs[k]=null;
          }
        }
        if (foundDuplicate) {
          scope.problemReporter().duplicateAnnotationValue(annotationType,pair);
          continue nextMember;
        }
      }
    }
    if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 && (this.bits & IsRecovered) == 0 && annotationType.isValidBinding()) {
      scope.problemReporter().missingValueForAnnotationMember(this,selector);
    }
  }
  if (!isGroovyAlias)   for (int i=0; i < pairsLength; i++) {
    if (pairs[i] != null) {
      if (annotationType.isValidBinding()) {
        scope.problemReporter().undefinedAnnotationValue(annotationType,pairs[i]);
      }
      pairs[i].resolveTypeExpecting(scope,null);
    }
  }
  this.compilerAnnotation=scope.environment().createAnnotation((ReferenceBinding)this.resolvedType,isGroovyAlias ? Binding.NO_ELEMENT_VALUE_PAIRS : computeElementValuePairs());
  long tagBits=detectStandardAnnotation(scope,annotationType,valueAttribute);
  int defaultNullness=(int)(tagBits & Binding.NullnessDefaultMASK);
  tagBits&=~Binding.NullnessDefaultMASK;
  scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS,null,this.sourceStart,this.declarationSourceEnd,scope.referenceContext());
  if (this.recipient != null) {
    int kind=this.recipient.kind();
    if (tagBits != 0 || defaultNullness != 0) {
switch (kind) {
case Binding.PACKAGE:
        ((PackageBinding)this.recipient).tagBits|=tagBits;
      break;
case Binding.TYPE:
case Binding.GENERIC_TYPE:
    SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
  if ((tagBits & TagBits.AnnotationRepeatable) == 0 || sourceType.isAnnotationType())   sourceType.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
  TypeDeclaration typeDeclaration=sourceType.scope.referenceContext;
  int start;
  if (scope.referenceCompilationUnit().types[0] == typeDeclaration) {
    start=0;
  }
 else {
    start=typeDeclaration.declarationSourceStart;
  }
  recordSuppressWarnings(scope,start,typeDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
sourceType.defaultNullness|=defaultNullness;
break;
case Binding.METHOD:
MethodBinding sourceMethod=(MethodBinding)this.recipient;
sourceMethod.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceMethod.declaringClass;
AbstractMethodDeclaration methodDeclaration=sourceType.scope.referenceContext.declarationOf(sourceMethod);
recordSuppressWarnings(scope,methodDeclaration.declarationSourceStart,methodDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
long nullBits=sourceMethod.tagBits & TagBits.AnnotationNullMASK;
if (nullBits == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
if (nullBits != 0 && sourceMethod.isConstructor()) {
if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) scope.problemReporter().nullAnnotationUnsupportedLocation(this);
sourceMethod.tagBits&=~TagBits.AnnotationNullMASK;
}
sourceMethod.defaultNullness|=defaultNullness;
break;
case Binding.FIELD:
FieldBinding sourceField=(FieldBinding)this.recipient;
sourceField.tagBits|=tagBits;
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
sourceType=(SourceTypeBinding)sourceField.declaringClass;
FieldDeclaration fieldDeclaration=sourceType.scope.referenceContext.declarationOf(sourceField);
recordSuppressWarnings(scope,fieldDeclaration.declarationSourceStart,fieldDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
sourceField.tagBits&=~TagBits.AnnotationNullMASK;
}
break;
case Binding.LOCAL:
LocalVariableBinding variable=(LocalVariableBinding)this.recipient;
variable.tagBits|=tagBits;
if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
scope.problemReporter().contradictoryNullAnnotations(this);
variable.tagBits&=~TagBits.AnnotationNullMASK;
}
if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
LocalDeclaration localDeclaration=variable.declaration;
recordSuppressWarnings(scope,localDeclaration.declarationSourceStart,localDeclaration.declarationSourceEnd,scope.compilerOptions().suppressWarnings);
}
break;
}
}
if (kind == Binding.TYPE) {
SourceTypeBinding sourceType=(SourceTypeBinding)this.recipient;
if (CharOperation.equals(sourceType.sourceName,TypeConstants.PACKAGE_INFO_NAME)) kind=Binding.PACKAGE;
}
checkAnnotationTarget(this,scope,annotationType,kind,this.recipient,tagBits & TagBits.AnnotationNullMASK);
}
return this.resolvedType;
}",0.996480360411094
185923,"public ClassNode lookupClassNodeForBinary(String typename,JDTResolver jdtResolver){
  char[][] compoundName=CharOperation.splitOn('.',typename.toCharArray());
  TypeBinding jdtBinding=getType(compoundName,compoundName.length);
  if (jdtBinding != null && (jdtBinding instanceof BinaryTypeBinding)) {
    ClassNode classNode=jdtResolver.convertToClassNode(jdtBinding);
    return classNode;
  }
  if (jdtBinding != null && (jdtBinding instanceof ProblemReferenceBinding)) {
    ProblemReferenceBinding prBinding=(ProblemReferenceBinding)jdtBinding;
    if (prBinding.problemId() == ProblemReasons.InternalNameProvided) {
      jdtBinding=prBinding.closestMatch();
      if (jdtBinding != null && (jdtBinding instanceof BinaryTypeBinding)) {
        return jdtResolver.convertToClassNode(jdtBinding);
      }
    }
  }
  return null;
}","public ClassNode lookupClassNodeForBinary(String typename,JDTResolver jdtResolver){
  char[][] compoundName=CharOperation.splitOn('.',typename.toCharArray());
  TypeBinding jdtBinding=getType(compoundName,compoundName.length);
  if (jdtBinding instanceof BinaryTypeBinding) {
    return jdtResolver.convertToClassNode(jdtBinding);
  }
  if (jdtBinding instanceof ProblemReferenceBinding) {
    ProblemReferenceBinding prBinding=(ProblemReferenceBinding)jdtBinding;
    if (prBinding.problemId() == ProblemReasons.InternalNameProvided) {
      jdtBinding=prBinding.closestMatch();
      if (jdtBinding instanceof BinaryTypeBinding) {
        return jdtResolver.convertToClassNode(jdtBinding);
      }
    }
  }
  return null;
}",0.809493264913406
185924,"/** 
 * Look in the local cache, if we don't find it then ask JDT. If JDT responds with a SourceTypeBinding then it has been found. If JDT responds with some other kind of binding, we consider that 'not found as source' and return null. Not quite the right name for this method, because on an incremental build it will find BinaryTypeBindings for types that were SourceTypeBindings during the full build
 */
public ClassNode lookupClassNodeForSource(String typename,JDTResolver jdtResolver){
  ClassNode node=typenameToClassNodeCache.get(typename);
  if (node != null) {
    return node;
  }
  char[][] compoundName=CharOperation.splitOn('.',typename.toCharArray());
  TypeBinding jdtBinding=null;
  try {
    jdtBinding=getType(compoundName,compoundName.length);
  }
 catch (  AbortCompilation t) {
    if (t.silentException instanceof AbortIncrementalBuildException) {
      jdtBinding=null;
    }
 else {
      throw t;
    }
  }
  if (jdtBinding != null) {
    if (jdtBinding instanceof SourceTypeBinding) {
      ClassNode classNode=jdtResolver.convertToClassNode(jdtBinding);
      if (classNode != null) {
        typenameToClassNodeCache.put(typename,classNode);
      }
      return classNode;
    }
 else     if (jdtBinding instanceof BinaryTypeBinding) {
      ClassNode newNode=jdtResolver.convertToClassNode(jdtBinding);
      if (newNode != null) {
        typenameToClassNodeCache.put(typename,newNode);
      }
      return newNode;
    }
  }
  if (jdtBinding != null && (jdtBinding instanceof ProblemReferenceBinding)) {
    ProblemReferenceBinding prBinding=(ProblemReferenceBinding)jdtBinding;
    if (prBinding.problemId() == ProblemReasons.InternalNameProvided) {
      jdtBinding=prBinding.closestMatch();
      if (jdtBinding != null && (jdtBinding instanceof SourceTypeBinding)) {
        return jdtResolver.convertToClassNode(jdtBinding);
      }
      if (jdtBinding != null && (jdtBinding instanceof BinaryTypeBinding)) {
        return jdtResolver.convertToClassNode(jdtBinding);
      }
    }
  }
  return null;
}","public ClassNode lookupClassNodeForSource(String typename,JDTResolver jdtResolver){
  char[][] compoundName=CharOperation.splitOn('.',typename.toCharArray());
  TypeBinding jdtBinding=null;
  try {
    jdtBinding=getType(compoundName,compoundName.length);
  }
 catch (  AbortCompilation t) {
    if (t.silentException instanceof AbortIncrementalBuildException) {
      jdtBinding=null;
    }
 else {
      throw t;
    }
  }
  if (jdtBinding instanceof SourceTypeBinding || jdtBinding instanceof BinaryTypeBinding) {
    return jdtResolver.convertToClassNode(jdtBinding);
  }
  if (jdtBinding instanceof ProblemReferenceBinding) {
    ProblemReferenceBinding prBinding=(ProblemReferenceBinding)jdtBinding;
    if (prBinding.problemId() == ProblemReasons.InternalNameProvided) {
      jdtBinding=prBinding.closestMatch();
      if (jdtBinding instanceof SourceTypeBinding || jdtBinding instanceof BinaryTypeBinding) {
        return jdtResolver.convertToClassNode(jdtBinding);
      }
    }
  }
  return null;
}",0.5131061598951507
185925,"/** 
 * Grabs the explicit declaring type of the   {@link AnnotatedNode}.  This will not return the expected value for   {@link MethodCallExpression}s.
 */
@Override protected Collection<ClassNode> explodeObject(Object toMatch){
  if (toMatch instanceof AnnotatedNode) {
    return Collections.singleton(((AnnotatedNode)toMatch).getDeclaringClass());
  }
  return null;
}","/** 
 * Grabs the explicit declaring type of the   {@link AnnotatedNode}. This will not return the expected value for   {@link MethodCallExpression}s.
 */
@Override protected Collection<ClassNode> explodeObject(Object toMatch){
  if (toMatch instanceof AnnotatedNode) {
    return Collections.singleton(((AnnotatedNode)toMatch).getDeclaringClass());
  }
  return null;
}",0.9986504723346828
185926,"private String readClassDeclaration(ClassNode node){
  String code=(String)node.getNodeMetaData(""String_Node_Str"");
  if (code == null) {
    code=String.valueOf(GroovyUtils.readSourceRange(module.getContext(),node.getStart(),node.getLength()));
    node.setNodeMetaData(""String_Node_Str"",code);
  }
  return code.substring(0,code.indexOf('{'));
}","private String readClassDeclaration(ClassNode node){
  String code=(String)node.getNodeMetaData(""String_Node_Str"");
  if (code == null) {
    code=String.valueOf(GroovyUtils.readSourceRange(module.getContext(),node.getStart(),node.getLength()));
    node.putNodeMetaData(""String_Node_Str"",code);
  }
  return code.substring(0,code.indexOf('{'));
}",0.9942363112391932
185927,"public void testDoubleAttributeWithBigDecimalValue(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testDoubleAttributeWithBigDecimalValue(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9673539518900344
185928,"public void testJava7(){
  if (isEclipse36() || complianceLevel < ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runConformTest(sources);
}","public void testJava7(){
  if (complianceLevel < ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runConformTest(sources);
}",0.980963045912654
185929,"public void testHalfFinishedGenericsProgramWithMultipleSuppressionValues(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"");
}","public void testHalfFinishedGenericsProgramWithMultipleSuppressionValues(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""};
  Version v=Platform.getBundle(""String_Node_Str"").getVersion();
  runNegativeTest(sources,(v.getMajor() == 3 && v.getMinor() < 13) ? ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.6390041493775933
185930,"public void testJava7_3(){
  if (isEclipse36() || complianceLevel >= ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testJava7_3(){
  if (complianceLevel >= ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.983284169124877
185931,"public void testJava7_2(){
  if (isEclipse36() || complianceLevel >= ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testJava7_2(){
  if (complianceLevel >= ClassFileConstants.JDK1_7)   return;
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9854576561163388
185932,"private void recordProblems(List<?> errors){
  List<Message> errorsRecorded=new ArrayList<Message>();
  for (Iterator<?> iterator=errors.iterator(); iterator.hasNext(); ) {
    SyntaxException syntaxException=null;
    Message message=(Message)iterator.next();
    StringWriter sw=new StringWriter();
    message.write(new PrintWriter(sw));
    String msg=sw.toString();
    CategorizedProblem p=null;
    int line=0;
    int sev=0;
    int scol=0;
    int ecol=0;
    if (message instanceof LocatedMessage) {
      CSTNode context=((LocatedMessage)message).getContext();
      if (context instanceof Token) {
        line=context.getStartLine();
        scol=context.getStartColumn();
        String text=((Token)context).getText();
        ecol=scol + (text == null ? 1 : (text.length() - 1));
      }
    }
    if (message instanceof SimpleMessage) {
      SimpleMessage simpleMessage=(SimpleMessage)message;
      sev|=ProblemSeverities.Error;
      String simpleText=simpleMessage.getMessage();
      if (simpleText.length() > 1 && simpleText.charAt(0) == '\n') {
        simpleText=simpleText.substring(1);
      }
      msg=""String_Node_Str"" + simpleText;
      if (msg.indexOf(""String_Node_Str"") != -1) {
        msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
      }
    }
    if (message instanceof SyntaxErrorMessage) {
      SyntaxErrorMessage errorMessage=(SyntaxErrorMessage)message;
      syntaxException=errorMessage.getCause();
      sev|=ProblemSeverities.Error;
      String actualMessage=syntaxException.getMessage();
      if (actualMessage.length() > 1 && actualMessage.charAt(0) == '\n') {
        actualMessage=actualMessage.substring(1);
      }
      msg=""String_Node_Str"" + actualMessage;
      if (msg.indexOf(""String_Node_Str"") != -1) {
        msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
      }
      line=syntaxException.getLine();
      scol=errorMessage.getCause().getStartColumn();
      ecol=errorMessage.getCause().getEndColumn() - 1;
    }
    int soffset=-1;
    int eoffset=-1;
    if (message instanceof ExceptionMessage) {
      ExceptionMessage em=(ExceptionMessage)message;
      sev|=ProblemSeverities.Error;
      if (em.getCause() instanceof RuntimeParserException) {
        RuntimeParserException rpe=(RuntimeParserException)em.getCause();
        sev|=ProblemSeverities.Error;
        msg=""String_Node_Str"" + rpe.getMessage();
        if (msg.indexOf(""String_Node_Str"") != -1) {
          msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
        }
        ModuleNode errorModuleNode=rpe.getModule();
        ModuleNode thisModuleNode=this.getModuleNode();
        if (!errorModuleNode.equals(thisModuleNode)) {
          continue;
        }
        soffset=rpe.getNode().getStart();
        eoffset=rpe.getNode().getEnd() - 1;
        line=0;
        while (compilationResult.lineSeparatorPositions[line] < soffset && line < compilationResult.lineSeparatorPositions.length) {
          line++;
        }
        line++;
      }
    }
    if (syntaxException instanceof PreciseSyntaxException) {
      soffset=((PreciseSyntaxException)syntaxException).getStartOffset();
      eoffset=((PreciseSyntaxException)syntaxException).getEndOffset();
      line=0;
      while (line < compilationResult.lineSeparatorPositions.length && compilationResult.lineSeparatorPositions[line] < soffset) {
        line++;
      }
      ;
      line++;
    }
 else {
      if (soffset == -1) {
        soffset=getOffset(compilationResult.lineSeparatorPositions,line,scol);
      }
      if (eoffset == -1) {
        eoffset=getOffset(compilationResult.lineSeparatorPositions,line,ecol);
      }
    }
    if (soffset > eoffset) {
      eoffset=soffset;
    }
    if (soffset > sourceEnd) {
      soffset=sourceEnd;
      eoffset=sourceEnd;
    }
    char[] filename=getFileName();
    p=new DefaultProblemFactory().createProblem(filename,0,new String[]{msg},0,new String[]{msg},sev,soffset,eoffset,line,scol);
    this.problemReporter.record(p,compilationResult,this,false);
    errorsRecorded.add(message);
    log(String.valueOf(compilationResult.getFileName()) + ""String_Node_Str"" + line+ ""String_Node_Str""+ msg);
  }
  errors.removeAll(errorsRecorded);
}","private void recordProblems(List<?> errors){
  List<Message> errorsRecorded=new ArrayList<Message>();
  for (Iterator<?> iterator=errors.iterator(); iterator.hasNext(); ) {
    SyntaxException syntaxException=null;
    Message message=(Message)iterator.next();
    StringWriter sw=new StringWriter();
    message.write(new PrintWriter(sw));
    String msg=sw.toString();
    CategorizedProblem p=null;
    int line=0;
    int sev=0;
    int scol=0;
    int ecol=0;
    if (message instanceof LocatedMessage) {
      CSTNode context=((LocatedMessage)message).getContext();
      if (context instanceof Token) {
        line=context.getStartLine();
        scol=context.getStartColumn();
        String text=((Token)context).getText();
        ecol=scol + (text == null ? 1 : (text.length() - 1));
      }
    }
    if (message instanceof SimpleMessage) {
      SimpleMessage simpleMessage=(SimpleMessage)message;
      sev|=ProblemSeverities.Error;
      String simpleText=simpleMessage.getMessage();
      if (simpleText.length() > 1 && simpleText.charAt(0) == '\n') {
        simpleText=simpleText.substring(1);
      }
      msg=""String_Node_Str"" + simpleText;
      if (msg.indexOf(""String_Node_Str"") != -1) {
        msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
      }
    }
    if (message instanceof SyntaxErrorMessage) {
      SyntaxErrorMessage errorMessage=(SyntaxErrorMessage)message;
      syntaxException=errorMessage.getCause();
      sev|=ProblemSeverities.Error;
      String actualMessage=syntaxException.getMessage();
      if (actualMessage.length() > 1 && actualMessage.charAt(0) == '\n') {
        actualMessage=actualMessage.substring(1);
      }
      msg=""String_Node_Str"" + actualMessage;
      if (msg.indexOf(""String_Node_Str"") != -1) {
        msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
      }
      line=syntaxException.getLine();
      scol=errorMessage.getCause().getStartColumn();
      ecol=errorMessage.getCause().getEndColumn() - 1;
    }
    int soffset=-1;
    int eoffset=-1;
    if (message instanceof ExceptionMessage) {
      ExceptionMessage em=(ExceptionMessage)message;
      sev|=ProblemSeverities.Error;
      if (em.getCause() instanceof RuntimeParserException) {
        RuntimeParserException rpe=(RuntimeParserException)em.getCause();
        sev|=ProblemSeverities.Error;
        msg=""String_Node_Str"" + rpe.getMessage();
        if (msg.indexOf(""String_Node_Str"") != -1) {
          msg=msg.substring(0,msg.indexOf(""String_Node_Str""));
        }
        ModuleNode errorModuleNode=rpe.getModule();
        ModuleNode thisModuleNode=this.getModuleNode();
        if (!errorModuleNode.equals(thisModuleNode)) {
          continue;
        }
        soffset=rpe.getNode().getStart();
        eoffset=rpe.getNode().getEnd() - 1;
        line=0;
        while (compilationResult.lineSeparatorPositions[line] < soffset && line < compilationResult.lineSeparatorPositions.length) {
          line++;
        }
        line++;
      }
    }
    if (syntaxException instanceof PreciseSyntaxException) {
      soffset=((PreciseSyntaxException)syntaxException).getStartOffset();
      eoffset=((PreciseSyntaxException)syntaxException).getEndOffset();
      line=0;
      while (line < compilationResult.lineSeparatorPositions.length && compilationResult.lineSeparatorPositions[line] < soffset) {
        line++;
      }
      ;
      line++;
    }
 else {
      if (soffset == -1) {
        soffset=getOffset(compilationResult.lineSeparatorPositions,line,scol);
      }
      if (eoffset == -1) {
        eoffset=getOffset(compilationResult.lineSeparatorPositions,line,ecol);
      }
    }
    if (soffset > eoffset) {
      eoffset=soffset;
    }
    if (soffset > sourceEnd) {
      soffset=sourceEnd;
      eoffset=sourceEnd;
    }
    p=new DefaultProblemFactory().createProblem(getFileName(),0,new String[]{msg},0,new String[]{msg},sev,soffset,eoffset,line,scol);
    problemReporter.record(p,compilationResult,this,false);
    errorsRecorded.add(message);
    log(String.valueOf(compilationResult.getFileName()) + ""String_Node_Str"" + line+ ""String_Node_Str""+ msg);
  }
  errors.removeAll(errorsRecorded);
}",0.9846006923719708
185933,"public void contentTypeChanged(ContentTypeChangeEvent event){
  GROOVY_LIKE_EXTENSIONS=null;
  JAVA_LIKE_BUT_NOT_GROOVY_LIKE_EXTENSIONS=null;
}","public void contentTypeChanged(ContentTypeChangeEvent event){
  GROOVY_FILE_NAMES=null;
  GROOVY_LIKE_EXTENSIONS=null;
  JAVA_LIKE_BUT_NOT_GROOVY_LIKE_EXTENSIONS=null;
}",0.9166666666666666
185934,"/** 
 * Returns the registered Java like extensions. Taken from org.eclipse.jdt.internal.core.util.Util.getJavaLikeExtensions
 */
public static char[][] getGroovyLikeExtensions(){
  if (GROOVY_LIKE_EXTENSIONS == null) {
    IContentTypeManager contentTypeManager=Platform.getContentTypeManager();
    if (contentTypeManager == null) {
      GROOVY_LIKE_EXTENSIONS=new char[][]{""String_Node_Str"".toCharArray()};
      return GROOVY_LIKE_EXTENSIONS;
    }
    IContentType groovyContentType=contentTypeManager.getContentType(GROOVY_SOURCE_CONTENT_TYPE);
    HashSet<String> fileExtensions=new HashSet<String>();
    IContentType[] contentTypes=contentTypeManager.getAllContentTypes();
    for (int i=0, length=contentTypes.length; i < length; i++) {
      if (contentTypes[i].isKindOf(groovyContentType)) {
        String[] fileExtension=contentTypes[i].getFileSpecs(IContentType.FILE_EXTENSION_SPEC);
        for (int j=0, length2=fileExtension.length; j < length2; j++) {
          fileExtensions.add(fileExtension[j]);
        }
      }
    }
    int length=fileExtensions.size();
    if (length == 0) {
      if (!noGroovyContentTypesErrorLogged) {
        noGroovyContentTypesErrorLogged=true;
        Util.log(new IllegalStateException(""String_Node_Str""));
      }
      return new char[][]{""String_Node_Str"".toCharArray()};
    }
 else {
      char[][] extensions=new char[length][];
      extensions[0]=""String_Node_Str"".toCharArray();
      int index=1;
      Iterator<String> iterator=fileExtensions.iterator();
      while (iterator.hasNext()) {
        String fileExtension=iterator.next();
        if (""String_Node_Str"".equals(fileExtension))         continue;
        extensions[index++]=fileExtension.toCharArray();
      }
      GROOVY_LIKE_EXTENSIONS=extensions;
    }
  }
  return GROOVY_LIKE_EXTENSIONS;
}","/** 
 * Returns the registered Java like extensions. Taken from org.eclipse.jdt.internal.core.util.Util.getJavaLikeExtensions
 */
public static char[][] getGroovyLikeExtensions(){
  if (GROOVY_LIKE_EXTENSIONS == null) {
    Set<String> fileExtensions=loadGroovyFileExtensions();
    if (fileExtensions.isEmpty()) {
      if (!noGroovyContentTypesErrorLogged) {
        noGroovyContentTypesErrorLogged=true;
        Util.log(new IllegalStateException(""String_Node_Str""));
      }
      return new char[][]{""String_Node_Str"".toCharArray()};
    }
 else {
      int length=fileExtensions.size();
      char[][] extensions=new char[length][];
      extensions[0]=""String_Node_Str"".toCharArray();
      int index=1;
      for (      String fileExtension : fileExtensions) {
        if (""String_Node_Str"".equals(fileExtension))         continue;
        extensions[index++]=fileExtension.toCharArray();
      }
      GROOVY_LIKE_EXTENSIONS=extensions;
    }
  }
  return GROOVY_LIKE_EXTENSIONS;
}",0.2254623044096728
185935,"public static int indexOfGroovyLikeExtension(String fileName){
  int fileNameLength=fileName.length();
  char[][] groovyLikeExtensions=getGroovyLikeExtensions();
  extensions:   for (int i=0, length=groovyLikeExtensions.length; i < length; i++) {
    char[] extension=groovyLikeExtensions[i];
    int extensionLength=extension.length;
    int extensionStart=fileNameLength - extensionLength;
    int dotIndex=extensionStart - 1;
    if (dotIndex < 0)     continue;
    if (fileName.charAt(dotIndex) != '.')     continue;
    for (int j=0; j < extensionLength; j++) {
      if (fileName.charAt(extensionStart + j) != extension[j])       continue extensions;
    }
    return dotIndex;
  }
  return -1;
}","/** 
 * Returns the index of the Groovy like extension of the given file name or -1 if it doesn't end with a known Java like extension. Note this is the index of the '.' even if it is not considered part of the extension. Adapted from  {@link org.eclipse.jdt.internal.core.util.Util#indexOfJavaLikeExtension}.
 */
public static int indexOfGroovyLikeExtension(String fileName){
  if (fileName != null) {
    int fileNameLength=fileName.length();
    if (fileNameLength > 0) {
      for (      char[] extension : getGroovyLikeExtensions()) {
        int offset=(fileNameLength - extension.length);
        if (offset < 1 || fileName.charAt(offset - 1) != '.')         continue;
        if (Arrays.equals(extension,fileName.substring(offset).toCharArray()))         return (offset - 1);
      }
    }
  }
  return -1;
}",0.2674571805006587
185936,"/** 
 * Uses the Eclipse content type extension point to determine if a file is a groovy file. Taken from org.eclipse.jdt.internal.core.util.Util.isJavaLikeExtension
 * @param file name (absolute path or simple name is fine)
 * @return true iff the file name is Groovy-like.
 */
public final static boolean isGroovyLikeFileName(char[] fileName){
  if (fileName == null)   return false;
  int fileNameLength=fileName.length;
  char[][] javaLikeExtensions=getGroovyLikeExtensions();
  extensions:   for (int i=0, length=javaLikeExtensions.length; i < length; i++) {
    char[] extension=javaLikeExtensions[i];
    int extensionLength=extension.length;
    int extensionStart=fileNameLength - extensionLength;
    if (extensionStart - 1 < 0)     continue;
    if (fileName[extensionStart - 1] != '.')     continue;
    for (int j=0; j < extensionLength; j++) {
      if (fileName[extensionStart + j] != extension[j])       continue extensions;
    }
    return true;
  }
  return false;
}","/** 
 * Uses the Eclipse content type extension point to determine if a file is a groovy file.
 * @param fileName (absolute path or simple name is fine)
 * @return {@code true} iff the file name is Groovy-like
 */
public static boolean isGroovyLikeFileName(String fileName){
  if (fileName != null && fileName.length() > 0 && !fileName.endsWith(""String_Node_Str"")) {
    if (indexOfGroovyLikeExtension(fileName) != -1) {
      return true;
    }
    if (GROOVY_FILE_NAMES == null) {
      GROOVY_FILE_NAMES=loadGroovyFileNames();
    }
    fileName=fileName.substring(fileName.lastIndexOf('/') + 1);
    return GROOVY_FILE_NAMES.contains(fileName);
  }
  return false;
}",0.3444108761329305
185937,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set accumulatedPathEntries=new LinkedHashSet();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      StringBuilder sb=new StringBuilder();
      Iterator iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append((String)iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.7050963924413056
185938,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185939,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185940,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185941,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set accumulatedPathEntries=new LinkedHashSet();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      StringBuilder sb=new StringBuilder();
      Iterator iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append((String)iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.7050963924413056
185942,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185943,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185944,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185945,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set accumulatedPathEntries=new LinkedHashSet();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      StringBuilder sb=new StringBuilder();
      Iterator iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append((String)iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.7050963924413056
185946,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185947,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185948,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185949,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set accumulatedPathEntries=new LinkedHashSet();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      StringBuilder sb=new StringBuilder();
      Iterator iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append((String)iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.7050963924413056
185950,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185951,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185952,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185953,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      Iterator<String> iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append(iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.9041616301156968
185954,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185955,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185956,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185957,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      Iterator<String> iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append(iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.9041616301156968
185958,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185959,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185960,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185961,"public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (int i=0, max=cpes.length; i < max; i++) {
        IClasspathEntry cpe=cpes[i];
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else {
            if (pathElement == null) {
              pathElement=cpe.getPath().toOSString();
            }
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      Iterator<String> iter=accumulatedPathEntries.iterator();
      while (iter.hasNext()) {
        sb.append(iter.next());
        sb.append(File.pathSeparator);
      }
      String classpath=sb.toString();
      return classpath;
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ""String_Node_Str"");
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String calculateClasspath(IJavaProject javaProject){
  try {
    Set<String> accumulatedPathEntries=new LinkedHashSet<String>();
    IProject project=javaProject.getProject();
    String projectName=project.getName();
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    IClasspathEntry[] cpes=javaProject.getResolvedClasspath(true);
    if (cpes != null) {
      for (      IClasspathEntry cpe : cpes) {
        if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
          continue;
        }
        IPath cpePath=cpe.getPath();
        String pathElement=null;
        String segmentZero=cpePath.segment(0);
        if (segmentZero.equals(projectName)) {
          pathElement=project.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            try {
              IProject iproject=project.getWorkspace().getRoot().getProject(segmentZero);
              if (iproject != null) {
                IFile ifile=iproject.getFile(cpePath.removeFirstSegments(1));
                IPath ipath=(ifile == null ? null : ifile.getRawLocation());
                pathElement=(ipath == null ? null : ipath.toOSString());
              }
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(project,segmentZero,accumulatedPathEntries);
          }
 else           if (pathElement == null) {
            pathElement=cpe.getPath().toOSString();
          }
        }
        if (pathElement != null) {
          accumulatedPathEntries.add(pathElement);
        }
      }
      accumulatedPathEntries.add(defaultOutputLocation);
      try {
        if (isGroovyNaturedProject(project)) {
          for (          IClasspathEntry entry : javaProject.getRawClasspath()) {
            if (entry.getOutputLocation() != null) {
              String location=pathToString(entry.getOutputLocation(),project);
              if (!defaultOutputLocation.equals(location)) {
                accumulatedPathEntries.add(location);
              }
            }
          }
        }
      }
 catch (      CoreException e) {
        System.err.println(""String_Node_Str"");
      }
      StringBuilder sb=new StringBuilder();
      for (      String entry : accumulatedPathEntries) {
        sb.append(entry).append(File.pathSeparator);
      }
      return sb.toString();
    }
  }
 catch (  JavaModelException jme) {
    System.err.println(""String_Node_Str"" + javaProject.getProject().getName() + ':');
    jme.printStackTrace();
  }
  return ""String_Node_Str"";
}",0.9041616301156968
185962,"/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project.  If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}","/** 
 * Configure an options map (usually retrieved from a CompilerOptions object) based on the project. If anything goes wrong it will configure the options to just build java.
 */
public static void configureOptionsBasedOnNature(Map<String,String> optionMap,IJavaProject javaProject){
  IProject project=javaProject.getProject();
  try {
    if (isGroovyNaturedProject(project)) {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.ENABLED);
      setGroovyClasspath(optionMap,javaProject);
      if (isProbablyGrailsProject(project)) {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,Integer.toString(IsGrails));
      }
 else {
        optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
      }
    }
 else {
      optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
      optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    optionMap.put(CompilerOptions.OPTIONG_BuildGroovyFiles,CompilerOptions.DISABLED);
    optionMap.put(CompilerOptions.OPTIONG_GroovyFlags,""String_Node_Str"");
  }
}",0.9930675909878682
185963,"public static void setGroovyClasspath(Map optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=(String)e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}","public static void setGroovyClasspath(Map<String,String> optionMap,IJavaProject javaProject){
  IFile file=javaProject.getProject().getFile(""String_Node_Str"");
  if (file.exists()) {
    try {
      PropertyResourceBundle prb=new PropertyResourceBundle(file.getContents());
      Enumeration<String> e=prb.getKeys();
      while (e.hasMoreElements()) {
        String k=e.nextElement();
        String v=(String)prb.getObject(k);
        v=fixup(v,javaProject);
        if (k.equals(CompilerOptions.OPTIONG_GroovyClassLoaderPath)) {
          optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,v);
        }
      }
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"");
      ioe.printStackTrace();
    }
catch (    CoreException ce) {
      System.err.println(""String_Node_Str"");
      ce.printStackTrace();
    }
catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
 else {
    try {
      String classpath=calculateClasspath(javaProject);
      optionMap.put(CompilerOptions.OPTIONG_GroovyClassLoaderPath,classpath);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
    }
  }
  IProject project=javaProject.getProject();
  try {
    IPath defaultOutputPath=javaProject.getOutputLocation();
    String defaultOutputLocation=pathToString(defaultOutputPath,project);
    optionMap.put(CompilerOptions.OPTIONG_GroovyExcludeGlobalASTScan,defaultOutputLocation);
  }
 catch (  Throwable t) {
    System.err.println(""String_Node_Str"");
    t.printStackTrace();
  }
  optionMap.put(CompilerOptions.OPTIONG_GroovyProjectName,project.getName());
}",0.9907765545968462
185964,"/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject ijp=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(ijp.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=ijp.getResolvedClasspath(true);
  if (cpes != null) {
    for (int j=0; j < cpes.length; j++) {
      IClasspathEntry cpe=cpes[j];
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
        continue;
      }
      if (cpe.isExported()) {
        IPath cpePath=cpes[j].getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else {
          if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
          }
 else {
            String otherPathElement=null;
            if (segmentZero != null && segmentZero.equals(iproject.getName())) {
              otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
            }
 else {
              otherPathElement=cpePath.toOSString();
            }
            accumulatedPathEntries.add(otherPathElement);
          }
        }
      }
    }
  }
}","/** 
 * Determine the exposed (exported) dependencies from the project named 'otherProject' and add them to the accumulatedPathEntries String Set. This will include the output location of the project plus other kinds of entry that are re-exported.  If dependent on another project and that project is re-exported, the method will recurse.
 * @param baseProject the original project for which the classpath is being computed
 * @param otherProject a project something in the dependency chain for the original project
 * @param accumulatedPathEntries a String set of classpath entries, into which new entries should be added
 */
private static void computeDependenciesFromProject(IProject baseProject,String otherProject,Set<String> accumulatedPathEntries) throws JavaModelException {
  IProject iproject=baseProject.getWorkspace().getRoot().getProject(otherProject);
  IJavaProject iJavaProject=JavaCore.create(iproject);
  accumulatedPathEntries.add(pathToString(iJavaProject.getOutputLocation(),iproject));
  IClasspathEntry[] cpes=iJavaProject.getResolvedClasspath(true);
  if (cpes != null) {
    for (    IClasspathEntry cpe : cpes) {
      if (cpe.getEntryKind() == IClasspathEntry.CPE_SOURCE && cpe.getOutputLocation() != null) {
        accumulatedPathEntries.add(pathToString(cpe.getOutputLocation(),iproject));
      }
 else       if (cpe.isExported()) {
        IPath cpePath=cpe.getPath();
        String segmentZero=cpePath.segment(0);
        if (segmentZero != null && segmentZero.equals(otherProject)) {
          accumulatedPathEntries.add(iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString());
        }
 else         if (cpe.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
          computeDependenciesFromProject(baseProject,segmentZero,accumulatedPathEntries);
        }
 else {
          String otherPathElement=null;
          if (segmentZero != null && segmentZero.equals(iproject.getName())) {
            otherPathElement=iproject.getFile(cpePath.removeFirstSegments(1)).getRawLocation().toOSString();
          }
 else {
            otherPathElement=cpePath.toOSString();
          }
          accumulatedPathEntries.add(otherPathElement);
        }
      }
    }
  }
}",0.940100594421582
185965,"private void myRemoveOccurrenceAnnotations(){
  ReflectionUtils.executePrivateMethod(JavaEditor.class,""String_Node_Str"",ReflectionUtils.NO_TYPES,this,ReflectionUtils.NO_ARGS);
}","private void myRemoveOccurrenceAnnotations(){
  ReflectionUtils.executePrivateMethod(JavaEditor.class,""String_Node_Str"",new Class[]{},this,new Object[]{});
}",0.8203592814371258
185966,"/** 
 * Ensure that the Java breakpoint updater is removed because we need to use Groovy's breakpoint updater instead
 */
private void unsetJavaBreakpointUpdater(){
  try {
    ISourceViewer viewer=getSourceViewer();
    if (viewer != null) {
      IAnnotationModel model=viewer.getAnnotationModel();
      if (model instanceof AbstractMarkerAnnotationModel) {
        ReflectionUtils.executePrivateMethod(AbstractMarkerAnnotationModel.class,""String_Node_Str"",ReflectionUtils.NO_TYPES,model,ReflectionUtils.NO_ARGS);
        @SuppressWarnings(""String_Node_Str"") List<IConfigurationElement> updaterSpecs=(List<IConfigurationElement>)ReflectionUtils.getPrivateField(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model);
        for (Iterator<IConfigurationElement> specIter=updaterSpecs.iterator(); specIter.hasNext(); ) {
          IConfigurationElement spec=specIter.next();
          if (spec.getAttribute(""String_Node_Str"").equals(BreakpointMarkerUpdater.class.getCanonicalName())) {
            specIter.remove();
            break;
          }
        }
      }
    }
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logException(""String_Node_Str"",e);
  }
}","/** 
 * Ensure that the Java breakpoint updater is removed because we need to use Groovy's breakpoint updater instead
 */
private void unsetJavaBreakpointUpdater(){
  try {
    ISourceViewer viewer=getSourceViewer();
    if (viewer != null) {
      IAnnotationModel model=viewer.getAnnotationModel();
      if (model instanceof AbstractMarkerAnnotationModel) {
        ReflectionUtils.executePrivateMethod(AbstractMarkerAnnotationModel.class,""String_Node_Str"",new Class[]{},model,new Object[]{});
        @SuppressWarnings(""String_Node_Str"") List<IConfigurationElement> updaterSpecs=(List<IConfigurationElement>)ReflectionUtils.getPrivateField(AbstractMarkerAnnotationModel.class,""String_Node_Str"",model);
        for (Iterator<IConfigurationElement> specIter=updaterSpecs.iterator(); specIter.hasNext(); ) {
          IConfigurationElement spec=specIter.next();
          if (spec.getAttribute(""String_Node_Str"").equals(BreakpointMarkerUpdater.class.getCanonicalName())) {
            specIter.remove();
            break;
          }
        }
      }
    }
  }
 catch (  Exception e) {
    GroovyPlugin.getDefault().logException(""String_Node_Str"",e);
  }
}",0.9692044482463644
185967,"/** 
 * Returns true if:<ul> <li>the given type is an existing class and the flag's <code>ACCEPT_CLASSES</code> bit is on <li>the given type is an existing interface and the <code>ACCEPT_INTERFACES</code> bit is on <li>neither the <code>ACCEPT_CLASSES</code> or <code>ACCEPT_INTERFACES</code> bit is on </ul> Otherwise, false is returned.
 */
protected boolean acceptType(IType type,int acceptFlags,boolean isSourceType){
  if (acceptFlags == 0 || acceptFlags == ACCEPT_ALL)   return true;
  if (kind == TypeDeclaration.CLASS_DECL && (acceptFlags & ACCEPT_CLASSES) == 0 && (acceptFlags & ACCEPT_ANNOTATIONS) != 0) {
    IAnnotation[] annos=type.getAnnotations();
    if (annos != null && annos.length > 0) {
      for (      IAnnotation anno : annos) {
        if (anno != null && ""String_Node_Str"".equals(anno.getElementName())) {
          kind=TypeDeclaration.ANNOTATION_TYPE_DECL;
          break;
        }
      }
    }
  }
  try {
    int kind=isSourceType ? TypeDeclaration.kind(((SourceTypeElementInfo)((SourceType)type).getElementInfo()).getModifiers()) : TypeDeclaration.kind(((IBinaryType)((BinaryType)type).getElementInfo()).getModifiers());
switch (kind) {
case TypeDeclaration.CLASS_DECL:
      return (acceptFlags & ACCEPT_CLASSES) != 0;
case TypeDeclaration.INTERFACE_DECL:
    return (acceptFlags & ACCEPT_INTERFACES) != 0;
case TypeDeclaration.ENUM_DECL:
  return (acceptFlags & ACCEPT_ENUMS) != 0;
default :
return (acceptFlags & ACCEPT_ANNOTATIONS) != 0;
}
}
 catch (JavaModelException npe) {
return false;
}
}","/** 
 * Returns true if:<ul> <li>the given type is an existing class and the flag's <code>ACCEPT_CLASSES</code> bit is on <li>the given type is an existing interface and the <code>ACCEPT_INTERFACES</code> bit is on <li>neither the <code>ACCEPT_CLASSES</code> or <code>ACCEPT_INTERFACES</code> bit is on </ul> Otherwise, false is returned.
 */
protected boolean acceptType(IType type,int acceptFlags,boolean isSourceType){
  if (acceptFlags == 0 || acceptFlags == ACCEPT_ALL)   return true;
  try {
    int kind=isSourceType ? TypeDeclaration.kind(((SourceTypeElementInfo)((SourceType)type).getElementInfo()).getModifiers()) : TypeDeclaration.kind(((IBinaryType)((BinaryType)type).getElementInfo()).getModifiers());
    if (kind == TypeDeclaration.CLASS_DECL && (acceptFlags & ACCEPT_CLASSES) == 0 && (acceptFlags & ACCEPT_ANNOTATIONS) != 0) {
      IAnnotation[] annos=type.getAnnotations();
      if (annos != null && annos.length > 0) {
        for (        IAnnotation anno : annos) {
          if (anno != null && ""String_Node_Str"".equals(anno.getElementName())) {
            kind=TypeDeclaration.ANNOTATION_TYPE_DECL;
            break;
          }
        }
      }
    }
switch (kind) {
case TypeDeclaration.CLASS_DECL:
      return (acceptFlags & ACCEPT_CLASSES) != 0;
case TypeDeclaration.INTERFACE_DECL:
    return (acceptFlags & ACCEPT_INTERFACES) != 0;
case TypeDeclaration.ENUM_DECL:
  return (acceptFlags & ACCEPT_ENUMS) != 0;
default :
return (acceptFlags & ACCEPT_ANNOTATIONS) != 0;
}
}
 catch (JavaModelException npe) {
return false;
}
}",0.846403110823072
185968,"/** 
 * Returns true if:<ul> <li>the given type is an existing class and the flag's <code>ACCEPT_CLASSES</code> bit is on <li>the given type is an existing interface and the <code>ACCEPT_INTERFACES</code> bit is on <li>neither the <code>ACCEPT_CLASSES</code> or <code>ACCEPT_INTERFACES</code> bit is on </ul> Otherwise, false is returned.
 */
protected boolean acceptType(IType type,int acceptFlags,boolean isSourceType){
  if (acceptFlags == 0 || acceptFlags == ACCEPT_ALL)   return true;
  if (kind == TypeDeclaration.CLASS_DECL && (acceptFlags & ACCEPT_CLASSES) == 0 && (acceptFlags & ACCEPT_ANNOTATIONS) != 0) {
    IAnnotation[] annos=type.getAnnotations();
    if (annos != null && annos.length > 0) {
      for (      IAnnotation anno : annos) {
        if (anno != null && ""String_Node_Str"".equals(anno.getElementName())) {
          kind=TypeDeclaration.ANNOTATION_TYPE_DECL;
          break;
        }
      }
    }
  }
  try {
    int kind=isSourceType ? TypeDeclaration.kind(((SourceTypeElementInfo)((SourceType)type).getElementInfo()).getModifiers()) : TypeDeclaration.kind(((IBinaryType)((BinaryType)type).getElementInfo()).getModifiers());
switch (kind) {
case TypeDeclaration.CLASS_DECL:
      return (acceptFlags & ACCEPT_CLASSES) != 0;
case TypeDeclaration.INTERFACE_DECL:
    return (acceptFlags & ACCEPT_INTERFACES) != 0;
case TypeDeclaration.ENUM_DECL:
  return (acceptFlags & ACCEPT_ENUMS) != 0;
default :
return (acceptFlags & ACCEPT_ANNOTATIONS) != 0;
}
}
 catch (JavaModelException npe) {
return false;
}
}","/** 
 * Returns true if:<ul> <li>the given type is an existing class and the flag's <code>ACCEPT_CLASSES</code> bit is on <li>the given type is an existing interface and the <code>ACCEPT_INTERFACES</code> bit is on <li>neither the <code>ACCEPT_CLASSES</code> or <code>ACCEPT_INTERFACES</code> bit is on </ul> Otherwise, false is returned.
 */
protected boolean acceptType(IType type,int acceptFlags,boolean isSourceType){
  if (acceptFlags == 0 || acceptFlags == ACCEPT_ALL)   return true;
  try {
    int kind=isSourceType ? TypeDeclaration.kind(((SourceTypeElementInfo)((SourceType)type).getElementInfo()).getModifiers()) : TypeDeclaration.kind(((IBinaryType)((BinaryType)type).getElementInfo()).getModifiers());
    if (kind == TypeDeclaration.CLASS_DECL && (acceptFlags & ACCEPT_CLASSES) == 0 && (acceptFlags & ACCEPT_ANNOTATIONS) != 0) {
      IAnnotation[] annos=type.getAnnotations();
      if (annos != null && annos.length > 0) {
        for (        IAnnotation anno : annos) {
          if (anno != null && ""String_Node_Str"".equals(anno.getElementName())) {
            kind=TypeDeclaration.ANNOTATION_TYPE_DECL;
            break;
          }
        }
      }
    }
switch (kind) {
case TypeDeclaration.CLASS_DECL:
      return (acceptFlags & ACCEPT_CLASSES) != 0;
case TypeDeclaration.INTERFACE_DECL:
    return (acceptFlags & ACCEPT_INTERFACES) != 0;
case TypeDeclaration.ENUM_DECL:
  return (acceptFlags & ACCEPT_ENUMS) != 0;
default :
return (acceptFlags & ACCEPT_ANNOTATIONS) != 0;
}
}
 catch (JavaModelException npe) {
return false;
}
}",0.846403110823072
185969,"public void testGRE1773() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  IPath class1=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IPath class2=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IPath class3=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClassesV(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
  class1=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingProblemsFor(class1,""String_Node_Str"");
  expectingProblemsFor(class2,""String_Node_Str"");
  expectingProblemsFor(class3,""String_Node_Str"");
  env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClassesV(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
}","public void testGRE1773() throws Exception {
  IPath projectPath=env.addProject(""String_Node_Str"");
  env.addExternalJars(projectPath,Util.getJavaClassLibs());
  env.addGroovyJars(projectPath);
  fullBuild(projectPath);
  env.removePackageFragmentRoot(projectPath,""String_Node_Str"");
  IPath root=env.addPackageFragmentRoot(projectPath,""String_Node_Str"");
  env.setOutputFolder(projectPath,""String_Node_Str"");
  IPath class1=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IPath class2=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IPath class3=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClassesV(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
  class1=env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingProblemsFor(class1,""String_Node_Str"");
  if (GroovyUtils.isAtLeastGroovy(20)) {
    expectingProblemsFor(class2,""String_Node_Str"");
    expectingProblemsFor(class3,""String_Node_Str"");
  }
  env.addGroovyClass(root,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  incrementalBuild(projectPath);
  expectingCompiledClassesV(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  expectingNoProblems();
}",0.9896863818143548
185970,"public void testBadCodeCategory_STS3822(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testBadCodeCategory_STS3822(){
  String[] sources={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  runNegativeTest(sources,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ (GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ (!GroovyUtils.isAtLeastGroovy(20) ? ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}",0.9015668943350744
185971,"protected void visitAnnotations(AnnotatedNode node,int target){
  if (node.getAnnotations().isEmpty()) {
    return;
  }
  this.currentClass.setAnnotated(true);
  if (!isAnnotationCompatible()) {
    addError(""String_Node_Str"" + JVM_ERROR_MESSAGE,node);
    return;
  }
  for (  AnnotationNode unvisited : node.getAnnotations()) {
    AnnotationNode visited=visitAnnotation(unvisited);
    boolean isTargetAnnotation=visited.getClassNode().isResolved() && visited.getClassNode().getName().equals(""String_Node_Str"");
    if (!isTargetAnnotation && !visited.isTargetAllowed(target)) {
      addError(""String_Node_Str"" + visited.getClassNode().getName() + ""String_Node_Str""+ AnnotationNode.targetToName(target),visited);
    }
    visitDeprecation(node,visited);
    visitOverride(node,visited);
  }
}","protected void visitAnnotations(AnnotatedNode node,int target){
  if (node.getAnnotations().isEmpty()) {
    return;
  }
  this.currentClass.setAnnotated(true);
  if (!isAnnotationCompatible()) {
    addError(""String_Node_Str"" + JVM_ERROR_MESSAGE,node);
    return;
  }
  for (  AnnotationNode unvisited : node.getAnnotations()) {
    AnnotationNode visited=visitAnnotation(unvisited);
    boolean isTargetAnnotation=visited.getClassNode().isResolved() && visited.getClassNode().getName().equals(""String_Node_Str"");
    if (!isTargetAnnotation && !visited.isTargetAllowed(target)) {
      addError(""String_Node_Str"" + visited.getClassNode().getName() + ""String_Node_Str""+ AnnotationNode.targetToName(target),visited);
    }
    visitDeprecation(node,visited);
  }
}",0.9788867562380038
185972,"public void testDuplicateClassesUnnecessaryExceptions_GRE796_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + File.separator + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testDuplicateClassesUnnecessaryExceptions_GRE796_2(){
  runNegativeTest(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""},""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + File.separator + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8129423660262892
185973,"@Override protected void performRefactoring(ICompilationUnit[] cus,ICleanUp[] cleanUps) throws InvocationTargetException {
}","@Override protected void performRefactoring(ICompilationUnit[] cus,ICleanUp[] cleanUps){
}",0.8411214953271028
185974,"private static File createMemLogFile(){
  if (STORE_MEMORY == null || MEM_LOG_DIR == null) {
    return null;
  }
  File logFile=new File(MEM_LOG_DIR,STORE_MEMORY + ""String_Node_Str"");
  PrintStream stream=null;
  try {
    boolean fileExist=logFile.exists();
    stream=new PrintStream(new FileOutputStream(logFile,true));
    if (stream != null) {
      if (fileExist) {
        stream.println();
      }
      Date date=new Date(System.currentTimeMillis());
      stream.println(""String_Node_Str"" + STORE_MEMORY);
      stream.println(""String_Node_Str"" + DateFormat.getDateInstance(3).format(date));
      stream.println(""String_Node_Str"" + DateFormat.getTimeInstance(3).format(date));
      stream.print(""String_Node_Str"");
      if (ALL_TESTS_LOG)       stream.print(""String_Node_Str"");
      stream.print(""String_Node_Str"");
      stream.println();
      stream.close();
      System.out.println(""String_Node_Str"" + logFile.getPath() + ""String_Node_Str"");
      return logFile;
    }
  }
 catch (  FileNotFoundException e) {
  }
 finally {
    if (stream != null) {
      stream.close();
    }
  }
  return null;
}","private static File createMemLogFile(){
  if (STORE_MEMORY == null || MEM_LOG_DIR == null) {
    return null;
  }
  File logFile=new File(MEM_LOG_DIR,STORE_MEMORY + ""String_Node_Str"");
  PrintStream stream=null;
  try {
    boolean fileExist=logFile.exists();
    stream=new PrintStream(new FileOutputStream(logFile,true));
    if (fileExist) {
      stream.println();
    }
    Date date=new Date(System.currentTimeMillis());
    stream.println(""String_Node_Str"" + STORE_MEMORY);
    stream.println(""String_Node_Str"" + DateFormat.getDateInstance(3).format(date));
    stream.println(""String_Node_Str"" + DateFormat.getTimeInstance(3).format(date));
    stream.print(""String_Node_Str"");
    if (ALL_TESTS_LOG)     stream.print(""String_Node_Str"");
    stream.print(""String_Node_Str"");
    stream.println();
    System.out.println(""String_Node_Str"" + logFile.getPath() + ""String_Node_Str"");
    return logFile;
  }
 catch (  FileNotFoundException e) {
    System.err.println(""String_Node_Str"" + logFile.getPath());
  }
 finally {
    if (stream != null) {
      stream.close();
    }
  }
  return null;
}",0.8887888338586223
185975,"/** 
 * Build a test suite with all tests computed from public methods starting with ""test"" found in the given test class. Test suite name is the given name. Note that this lis maybe reduced using some mechanisms detailed in   {@link #buildTestsList(Class)} method.
 * @param evaluationTestClass
 * @param suiteName
 * @return a test suite ({@link Test})
 */
public static Test buildTestSuite(Class<? extends Test> evaluationTestClass,String suiteName){
  TestSuite suite=new TestSuite(suiteName == null ? evaluationTestClass.getName() : suiteName);
  List<Test> tests=buildTestsList(evaluationTestClass);
  for (int index=0, size=tests.size(); index < size; index++) {
    suite.addTest(tests.get(index));
  }
  return suite;
}","/** 
 * Build a test suite with all tests computed from public methods starting with ""test"" found in the given test class. Test suite name is the given name. Note that this lis maybe reduced using some mechanisms detailed in   {@link #buildTestsList(Class)} method.
 * @return a test suite ({@link Test})
 */
public static Test buildTestSuite(Class<? extends Test> evaluationTestClass,String suiteName){
  TestSuite suite=new TestSuite(suiteName == null ? evaluationTestClass.getName() : suiteName);
  List<Test> tests=buildTestsList(evaluationTestClass);
  for (int index=0, size=tests.size(); index < size; index++) {
    suite.addTest(tests.get(index));
  }
  return suite;
}",0.9644381223328592
185976,"private String createConstantText() throws MalformedTreeException, BadLocationException {
  StringBuilder sb=new StringBuilder();
  IJavaProject javaProject=getCu().getJavaProject();
  sb.append(CodeFormatterUtil.createIndentString(getIndentLevel(),javaProject));
  if (!getVisibility().isEmpty()) {
    sb.append(getVisibility()).append(""String_Node_Str"");
  }
  sb.append(MODIFIER).append(""String_Node_Str"").append(getConstantTypeName()).append(constantName).append(""String_Node_Str"").append(createExpressionText());
  IDocument doc=new Document(sb.toString());
  DefaultGroovyFormatter formatter=new DefaultGroovyFormatter(doc,new FormatterPreferences(unit),getIndentLevel());
  TextEdit edit=formatter.format();
  edit.apply(doc);
  return getDefaultNewlineCharacterTwice() + doc.get();
}","private String createConstantText() throws MalformedTreeException, BadLocationException {
  StringBuilder sb=new StringBuilder();
  IJavaProject javaProject=getCu().getJavaProject();
  sb.append(CodeFormatterUtil.createIndentString(getIndentLevel(),javaProject));
  if (getVisibility().length() > 0) {
    sb.append(getVisibility()).append(""String_Node_Str"");
  }
  sb.append(MODIFIER).append(""String_Node_Str"").append(getConstantTypeName()).append(constantName).append(""String_Node_Str"").append(createExpressionText());
  IDocument doc=new Document(sb.toString());
  DefaultGroovyFormatter formatter=new DefaultGroovyFormatter(doc,new FormatterPreferences(unit),getIndentLevel());
  TextEdit edit=formatter.format();
  edit.apply(doc);
  return getDefaultNewlineCharacterTwice() + doc.get();
}",0.9861286254728878
185977,"private void addEdit(TextEdit edit){
  if (edit instanceof DeleteEdit && edit.getLength() == 0) {
    return;
  }
  if (edit instanceof ReplaceEdit && edit.getLength() == 0 && ((ReplaceEdit)edit).getText().isEmpty()) {
    return;
  }
  if (edit instanceof InsertEdit && ((InsertEdit)edit).getText().isEmpty()) {
    return;
  }
  if (edit != null && edit.getOffset() >= formatter.formatOffset && edit.getOffset() + edit.getLength() <= formatter.formatOffset + formatter.formatLength) {
    if (edit instanceof DeleteEdit) {
      debug(""String_Node_Str"" + edit.getOffset() + ""String_Node_Str""+ edit.getLength());
      debug(""String_Node_Str"");
      IDocument doc=formatter.getProgressDocument();
      try {
        debug(doc.get(0,edit.getOffset()) + ""String_Node_Str"" + doc.get(edit.getOffset(),edit.getLength())+ ""String_Node_Str""+ doc.get(edit.getOffset() + edit.getLength(),doc.getLength() - (edit.getOffset() + edit.getLength())));
      }
 catch (      BadLocationException e) {
        e.printStackTrace();
      }
      debug(""String_Node_Str"");
    }
    try {
      indentationEdits.addChild(edit);
    }
 catch (    MalformedTreeException e) {
      debug(""String_Node_Str"" + edit);
      GroovyCore.logException(""String_Node_Str"",e);
    }
  }
}","private void addEdit(TextEdit edit){
  if (edit instanceof DeleteEdit && edit.getLength() == 0) {
    return;
  }
  if (edit instanceof ReplaceEdit && edit.getLength() == 0 && ((ReplaceEdit)edit).getText().length() < 1) {
    return;
  }
  if (edit instanceof InsertEdit && ((InsertEdit)edit).getText().length() < 1) {
    return;
  }
  if (edit != null && edit.getOffset() >= formatter.formatOffset && edit.getOffset() + edit.getLength() <= formatter.formatOffset + formatter.formatLength) {
    if (edit instanceof DeleteEdit) {
      debug(""String_Node_Str"" + edit.getOffset() + ""String_Node_Str""+ edit.getLength());
      debug(""String_Node_Str"");
      IDocument doc=formatter.getProgressDocument();
      try {
        debug(doc.get(0,edit.getOffset()) + ""String_Node_Str"" + doc.get(edit.getOffset(),edit.getLength())+ ""String_Node_Str""+ doc.get(edit.getOffset() + edit.getLength(),doc.getLength() - (edit.getOffset() + edit.getLength())));
      }
 catch (      BadLocationException e) {
        e.printStackTrace();
      }
      debug(""String_Node_Str"");
    }
    try {
      indentationEdits.addChild(edit);
    }
 catch (    MalformedTreeException e) {
      debug(""String_Node_Str"" + edit);
      GroovyCore.logException(""String_Node_Str"",e);
    }
  }
}",0.9833860759493672
185978,"/** 
 * Finds a method with the given name in the declaring type. Will prioritize methods with the same number of arguments, but if multiple methods exist with same name, then will return an arbitrary one.
 * @param name
 * @param declaringType
 * @param methodCallArgumentTypes
 * @param checkSuperInterfaces potentially look through super interfaces for a declaration to this method
 * @return
 */
private AnnotatedNode findMethodDeclaration(String name,ClassNode declaringType,List<ClassNode> methodCallArgumentTypes,boolean checkSuperInterfaces){
  if (checkSuperInterfaces && declaringType.isInterface()) {
    LinkedHashSet<ClassNode> allInterfaces=new LinkedHashSet<ClassNode>();
    VariableScope.findAllInterfaces(declaringType,allInterfaces,true);
    for (    ClassNode interf : allInterfaces) {
      AnnotatedNode candidate=findMethodDeclaration(name,interf,methodCallArgumentTypes,false);
      if (candidate != null) {
        return candidate;
      }
    }
    return null;
  }
  List<MethodNode> maybeMethods=declaringType.getMethods(name);
  if (maybeMethods != null && maybeMethods.size() > 0) {
    if (methodCallArgumentTypes != null && methodCallArgumentTypes.size() >= 0) {
      for (Iterator<MethodNode> iterator=maybeMethods.iterator(); iterator.hasNext(); ) {
        MethodNode maybeMethod=iterator.next();
        Parameter[] parameters=maybeMethod.getParameters();
        if ((parameters == null || parameters.length == 0) && methodCallArgumentTypes.size() == 0) {
          return maybeMethod.getOriginal();
        }
        if (parameters != null && parameters.length == methodCallArgumentTypes.size()) {
          boolean found=true;
          boolean exactMatchFound=true;
          for (int i=0; i < parameters.length; i++) {
            if (!methodCallArgumentTypes.get(i).equals(parameters[i].getType())) {
              exactMatchFound=false;
            }
            if (parameters[i].getType().isInterface()) {
              if (!methodCallArgumentTypes.get(i).declaresInterface(parameters[i].getType())) {
                found=false;
                break;
              }
            }
 else {
              if (!methodCallArgumentTypes.get(i).isDerivedFrom(parameters[i].getType())) {
                found=false;
                break;
              }
            }
          }
          if (exactMatchFound) {
            return maybeMethod.getOriginal();
          }
          if (!found) {
            iterator.remove();
          }
        }
 else {
          iterator.remove();
        }
      }
    }
    return maybeMethods.get(0);
  }
  if (methodCallArgumentTypes == null) {
    return AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false);
  }
 else {
    return null;
  }
}","/** 
 * Finds a method with the given name in the declaring type. Will prioritize methods with the same number of arguments, but if multiple methods exist with same name, then will return an arbitrary one.
 * @param name
 * @param declaringType
 * @param methodCallArgumentTypes
 * @param checkSuperInterfaces potentially look through super interfaces for a declaration to this method
 * @return
 */
private AnnotatedNode findMethodDeclaration(String name,ClassNode declaringType,List<ClassNode> methodCallArgumentTypes,boolean checkSuperInterfaces){
  if (checkSuperInterfaces && declaringType.isInterface()) {
    LinkedHashSet<ClassNode> allInterfaces=new LinkedHashSet<ClassNode>();
    VariableScope.findAllInterfaces(declaringType,allInterfaces,true);
    for (    ClassNode interf : allInterfaces) {
      AnnotatedNode candidate=findMethodDeclaration(name,interf,methodCallArgumentTypes,false);
      if (candidate != null) {
        return candidate;
      }
    }
    return null;
  }
  List<MethodNode> maybeMethods=declaringType.getMethods(name);
  if (maybeMethods != null && maybeMethods.size() > 0) {
    if (methodCallArgumentTypes != null && methodCallArgumentTypes.size() >= 0) {
      for (Iterator<MethodNode> iterator=maybeMethods.iterator(); iterator.hasNext(); ) {
        MethodNode maybeMethod=iterator.next();
        Parameter[] parameters=maybeMethod.getParameters();
        if ((parameters == null || parameters.length == 0) && methodCallArgumentTypes.size() == 0) {
          return maybeMethod.getOriginal();
        }
        if (parameters != null && parameters.length == methodCallArgumentTypes.size()) {
          boolean found=true;
          boolean exactMatchFound=true;
          for (int i=0; i < parameters.length; i++) {
            if (!methodCallArgumentTypes.get(i).equals(parameters[i].getType())) {
              exactMatchFound=false;
            }
            if (parameters[i].getType().isInterface()) {
              if (!methodCallArgumentTypes.get(i).declaresInterface(parameters[i].getType())) {
                found=false;
                break;
              }
            }
 else {
              if (!methodCallArgumentTypes.get(i).isDerivedFrom(parameters[i].getType())) {
                found=false;
                break;
              }
            }
          }
          if (exactMatchFound) {
            return maybeMethod.getOriginal();
          }
          if (!found) {
            iterator.remove();
          }
        }
 else {
          iterator.remove();
        }
      }
    }
    return maybeMethods.size() > 0 ? maybeMethods.get(0) : null;
  }
  if (methodCallArgumentTypes == null) {
    return AccessorSupport.findAccessorMethodForPropertyName(name,declaringType,false);
  }
 else {
    return null;
  }
}",0.9922424679776296
185979,"private void visitUnaryExpression(Expression node,Expression expression,String operation){
  scopes.peek().setCurrentNode(node);
  completeExpressionStack.push(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.pop();
  }
  expression.visit(this);
  ClassNode primaryType=primaryTypeStack.pop();
  String associatedMethod=findUnaryOperatorName(operation);
  ClassNode completeExprType;
  if (associatedMethod == null && primaryType.equals(VariableScope.NUMBER_CLASS_NODE) || primaryType.isDerivedFrom(VariableScope.NUMBER_CLASS_NODE)) {
    completeExprType=primaryType;
  }
 else {
    TypeLookupResult result=lookupExpressionType(new ConstantExpression(associatedMethod),primaryType,false,scopes.peek());
    completeExprType=result.type;
  }
  completeExpressionStack.pop();
  handleCompleteExpression(node,completeExprType,null);
}","private void visitUnaryExpression(Expression node,Expression expression,String operation){
  scopes.peek().setCurrentNode(node);
  completeExpressionStack.push(node);
  if (isDependentExpression(node)) {
    primaryTypeStack.pop();
  }
  expression.visit(this);
  ClassNode primaryType=primaryTypeStack.pop();
  String associatedMethod=findUnaryOperatorName(operation);
  ClassNode completeExprType;
  if (associatedMethod == null && primaryType.equals(VariableScope.NUMBER_CLASS_NODE) || ClassHelper.getWrapper(primaryType).isDerivedFrom(VariableScope.NUMBER_CLASS_NODE)) {
    completeExprType=primaryType;
  }
 else {
    TypeLookupResult result=lookupExpressionType(new ConstantExpression(associatedMethod),primaryType,false,scopes.peek());
    completeExprType=result.type;
  }
  completeExpressionStack.pop();
  handleCompleteExpression(node,completeExprType,null);
}",0.9732868757259
185980,"/** 
 * Finds argument types of the current method call. Returns null if not a method call.
 * @return
 */
private List<ClassNode> getMethodCallArgs(){
  ASTNode peek=completeExpressionStack.peek();
  if (peek instanceof MethodCallExpression) {
    MethodCallExpression call=(MethodCallExpression)peek;
    Expression arguments=call.getArguments();
    if (arguments instanceof ArgumentListExpression) {
      ArgumentListExpression list=(ArgumentListExpression)arguments;
      List<Expression> expressions=list.getExpressions();
      List<ClassNode> types=new ArrayList<ClassNode>();
      for (      Expression expression : expressions) {
        types.add(expression.getType());
      }
      return types;
    }
  }
  return null;
}","/** 
 * Finds argument types of the current method call. Returns null if not a method call.
 * @return
 */
private List<ClassNode> getMethodCallArgs(){
  ASTNode peek=completeExpressionStack.peek();
  if (peek instanceof MethodCallExpression) {
    MethodCallExpression call=(MethodCallExpression)peek;
    Expression arguments=call.getArguments();
    if (arguments instanceof ArgumentListExpression) {
      ArgumentListExpression list=(ArgumentListExpression)arguments;
      List<Expression> expressions=list.getExpressions();
      List<ClassNode> types=new ArrayList<ClassNode>();
      for (      Expression expression : expressions) {
        types.add(expression.getType());
      }
      return types;
    }
 else {
      return new ArrayList<ClassNode>();
    }
  }
  return null;
}",0.947093403004572
185981,"private void doInitialize(BundleContext context) throws BundleException {
  SpecifiedVersion specifiedVersion=findSysPropVersion();
  if (specifiedVersion == SpecifiedVersion.UNSPECIFIED) {
    specifiedVersion=getVersionFromPrefenences(context);
  }
  System.out.println(""String_Node_Str"" + specifiedVersion.toReadableVersionString());
  Bundle[] bundles=Platform.getBundles(GROOVY_PLUGIN_ID,null);
  if (bundles == null || bundles.length == 0) {
    System.out.println(""String_Node_Str"");
    bundles=new Bundle[0];
  }
  allVersions=new Version[bundles.length];
  allSpecifiedVersions=new SpecifiedVersion[bundles.length];
  if (specifiedVersion != SpecifiedVersion.UNSPECIFIED) {
    boolean found=false;
    for (int i=0; i < bundles.length; i++) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
      if (allSpecifiedVersions[i] == specifiedVersion && !found) {
        activeIndex=i;
        found=true;
      }
    }
    if (found && activeIndex > 0) {
      for (int i=0; i < bundles.length; i++) {
        if (i != activeIndex) {
          Bundle bundle=bundles[i];
          bundle.uninstall();
        }
      }
      PackageAdmin pkgAdmin=context.getService(context.getServiceReference(org.osgi.service.packageadmin.PackageAdmin.class));
      try {
        Method method=pkgAdmin.getClass().getMethod(""String_Node_Str"",Bundle[].class,boolean.class,FrameworkListener[].class);
        if (method == null) {
          pkgAdmin.refreshPackages(bundles);
        }
 else {
          method.setAccessible(true);
          method.invoke(pkgAdmin,bundles,true,null);
        }
      }
 catch (      Exception e) {
        pkgAdmin.refreshPackages(bundles);
      }
    }
 else {
      if (!found) {
        System.out.println(""String_Node_Str"" + allVersions[0] + ""String_Node_Str"");
      }
    }
  }
 else {
    for (int i=0; i < bundles.length; i++) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
    }
  }
}","private void doInitialize(BundleContext context) throws BundleException {
  SpecifiedVersion specifiedVersion=findSysPropVersion();
  if (specifiedVersion == SpecifiedVersion.UNSPECIFIED) {
    specifiedVersion=getVersionFromPrefenences(context);
  }
  System.out.println(""String_Node_Str"" + specifiedVersion.toReadableVersionString());
  Bundle[] bundles=Platform.getBundles(GROOVY_PLUGIN_ID,null);
  if (bundles == null || bundles.length == 0) {
    System.out.println(""String_Node_Str"");
    bundles=new Bundle[0];
  }
  allVersions=new Version[bundles.length];
  allSpecifiedVersions=new SpecifiedVersion[bundles.length];
  if (specifiedVersion != SpecifiedVersion.UNSPECIFIED) {
    boolean found=false;
    for (int i=0; i < bundles.length; i++) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
      if (allSpecifiedVersions[i] == specifiedVersion && !found) {
        activeIndex=i;
        found=true;
      }
    }
    if (found) {
      for (int i=0; i < bundles.length; i++) {
        if (i != activeIndex) {
          Bundle bundle=bundles[i];
          bundle.uninstall();
        }
      }
      PackageAdmin pkgAdmin=context.getService(context.getServiceReference(org.osgi.service.packageadmin.PackageAdmin.class));
      try {
        Method method=pkgAdmin.getClass().getMethod(""String_Node_Str"",Bundle[].class,boolean.class,FrameworkListener[].class);
        if (method == null) {
          pkgAdmin.refreshPackages(bundles);
        }
 else {
          method.setAccessible(true);
          method.invoke(pkgAdmin,bundles,true,null);
        }
      }
 catch (      Exception e) {
        pkgAdmin.refreshPackages(bundles);
      }
    }
 else {
      if (!found) {
        System.out.println(""String_Node_Str"" + allVersions[0] + ""String_Node_Str"");
      }
    }
  }
 else {
    for (int i=0; i < bundles.length; i++) {
      Bundle bundle=bundles[i];
      allVersions[i]=bundle.getVersion();
      allSpecifiedVersions[i]=SpecifiedVersion.findVersion(bundle.getVersion());
    }
  }
}",0.9955304634203715
185982,"public void testDefaultAndStaticMethodInInterface(){
  assertTrue(""String_Node_Str"",GroovyUtils.GROOVY_LEVEL >= 23);
  assertTrue(""String_Node_Str"",isJRELevel(AbstractCompilerTest.F_1_8));
  Map customOptions=getCompilerOptions();
  customOptions.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_8);
  this.runConformTest(true,new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},null,customOptions,""String_Node_Str"",""String_Node_Str"",null,new JavacTestOptions(""String_Node_Str""));
}","public void testDefaultAndStaticMethodInInterface(){
  assertTrue(""String_Node_Str"",GroovyUtils.GROOVY_LEVEL >= 23);
  assertTrue(""String_Node_Str"",isJRELevel(AbstractCompilerTest.F_1_8));
  Map customOptions=getCompilerOptions();
  customOptions.put(CompilerOptions.OPTION_Source,""String_Node_Str"");
  this.runConformTest(true,new String[]{""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""},null,customOptions,""String_Node_Str"",""String_Node_Str"",null,new JavacTestOptions(""String_Node_Str""));
}",0.967551622418879
185983,"public static Test suite(){
  return buildUniqueComplianceTestSuite(testClass(),ClassFileConstants.JDK1_8);
}","public static Test suite(){
  return buildUniqueComplianceTestSuite(testClass(),JDK1_8);
}",0.9045226130653268
185984,"protected void setUp() throws Exception {
  super.setUp();
  complianceLevel=ClassFileConstants.JDK1_8;
}","protected void setUp() throws Exception {
  super.setUp();
  complianceLevel=JDK1_8;
}",0.900523560209424
185985,"public static <T>Object throwableExecutePrivateMethod(Class<T> clazz,String methodName,Class<?>[] types,Object target,Object[] args) throws Exception {
  Method method=clazz.getDeclaredMethod(methodName,types);
  method.setAccessible(true);
  return method.invoke(target,args);
}","public static <T>Object throwableExecutePrivateMethod(Class<T> clazz,String methodName,Class<?>[] types,T target,Object[] args) throws Exception {
  Method method=clazz.getDeclaredMethod(methodName,types);
  method.setAccessible(true);
  return method.invoke(target,args);
}",0.9873417721518988
185986,"/** 
 * Create type name taking into account inner types
 */
private String createName(IType type){
  StringBuilder sb=new StringBuilder();
  while (type != null) {
    if (sb.length() > 0) {
      sb.insert(0,'$');
    }
    if (type instanceof SourceType && type.getElementName().isEmpty()) {
      sb.insert(0,((SourceType)type).localOccurrenceCount);
    }
 else {
      sb.insert(0,type.getElementName());
    }
    type=(IType)type.getParent().getAncestor(IJavaElement.TYPE);
  }
  return sb.toString();
}","/** 
 * Create type name taking into account inner types
 */
private String createName(IType type){
  StringBuilder sb=new StringBuilder();
  while (type != null) {
    if (sb.length() > 0) {
      sb.insert(0,'$');
    }
    if (type instanceof SourceType && type.getElementName().isEmpty()) {
      int count;
      try {
        count=(Integer)ReflectionUtils.throwableGetPrivateField(SourceType.class,""String_Node_Str"",(SourceType)type);
      }
 catch (      Exception e) {
        count=type.getOccurrenceCount();
      }
      sb.insert(0,count);
    }
 else {
      sb.insert(0,type.getElementName());
    }
    type=(IType)type.getParent().getAncestor(IJavaElement.TYPE);
  }
  return sb.toString();
}",0.7796887796887797
185987,"/** 
 * Grails 2.0 adds automatic imports to classes in test/unit folder. See org.codehaus.groovy.grails.test.compiler.GrailsTestCompiler and the _TestApp.groovy script.
 */
public void addGrailsTestCompilerCustomizers(CompilationUnit groovyCompilationUnit){
  if (GroovySystem.getVersion().startsWith(""String_Node_Str"")) {
    ImportCustomizer importCustomizer=new ImportCustomizer(){
      @Override public void call(      SourceUnit source,      GeneratorContext context,      ClassNode classNode) throws CompilationFailedException {
        if (isInGrailsUnitTestSourceFolder(source)) {
          super.call(source,context,classNode);
        }
      }
    }
;
    importCustomizer.addStarImports(""String_Node_Str"");
    importCustomizer.addStarImports(""String_Node_Str"");
    importCustomizer.addStaticStars(""String_Node_Str"");
    groovyCompilationUnit.addPhaseOperation(importCustomizer,importCustomizer.getPhase().getPhaseNumber());
    @SuppressWarnings(""String_Node_Str"") Class testForClass=null;
    try {
      testForClass=Class.forName(""String_Node_Str"",false,gcl);
      if (testForClass != null) {
        ASTTransformationCustomizer astTransformationCustomizer=new ASTTransformationCustomizer(testForClass){
          @Override public void call(          SourceUnit source,          GeneratorContext context,          ClassNode classNode) throws CompilationFailedException {
            if (isInGrailsUnitTestSourceFolder(source)) {
              super.call(source,context,classNode);
            }
          }
        }
;
        groovyCompilationUnit.addPhaseOperation(astTransformationCustomizer,astTransformationCustomizer.getPhase().getPhaseNumber());
        ensureGrailsBuildSettings();
      }
    }
 catch (    LinkageError e) {
    }
catch (    ClassNotFoundException e) {
    }
catch (    Exception e) {
      e.printStackTrace(System.err);
    }
  }
}","/** 
 * Grails 2.0 adds automatic imports to classes in test/unit folder. See org.codehaus.groovy.grails.test.compiler.GrailsTestCompiler and the _TestApp.groovy script.
 */
public void addGrailsTestCompilerCustomizers(CompilationUnit groovyCompilationUnit){
  String groovyVersion=GroovySystem.getVersion();
  if (groovyVersion.startsWith(""String_Node_Str"") || groovyVersion.startsWith(""String_Node_Str"")) {
    ImportCustomizer importCustomizer=new ImportCustomizer(){
      @Override public void call(      SourceUnit source,      GeneratorContext context,      ClassNode classNode) throws CompilationFailedException {
        if (isInGrailsUnitTestSourceFolder(source)) {
          super.call(source,context,classNode);
        }
      }
    }
;
    importCustomizer.addStarImports(""String_Node_Str"");
    importCustomizer.addStarImports(""String_Node_Str"");
    importCustomizer.addStaticStars(""String_Node_Str"");
    groovyCompilationUnit.addPhaseOperation(importCustomizer,importCustomizer.getPhase().getPhaseNumber());
    @SuppressWarnings(""String_Node_Str"") Class testForClass=null;
    try {
      testForClass=Class.forName(""String_Node_Str"",false,gcl);
      if (testForClass != null) {
        ASTTransformationCustomizer astTransformationCustomizer=new ASTTransformationCustomizer(testForClass){
          @Override public void call(          SourceUnit source,          GeneratorContext context,          ClassNode classNode) throws CompilationFailedException {
            if (isInGrailsUnitTestSourceFolder(source)) {
              super.call(source,context,classNode);
            }
          }
        }
;
        groovyCompilationUnit.addPhaseOperation(astTransformationCustomizer,astTransformationCustomizer.getPhase().getPhaseNumber());
        ensureGrailsBuildSettings();
      }
    }
 catch (    LinkageError e) {
    }
catch (    ClassNotFoundException e) {
    }
catch (    Exception e) {
      e.printStackTrace(System.err);
    }
  }
}",0.9747724317295188
185988,"public static boolean isNumberType(ClassNode cn){
  return cn == Byte_TYPE || cn == Short_TYPE || cn == Integer_TYPE || cn == Long_TYPE || cn == Float_TYPE || cn == Double_TYPE || cn == byte_TYPE || cn == short_TYPE || cn == int_TYPE || cn == long_TYPE || cn == float_TYPE || cn == double_TYPE;
}","public static boolean isNumberType(ClassNode cn){
  return cn.equals(Byte_TYPE) || cn.equals(Short_TYPE) || cn.equals(Integer_TYPE)|| cn.equals(Long_TYPE)|| cn.equals(Float_TYPE)|| cn.equals(Double_TYPE)|| cn == byte_TYPE || cn == short_TYPE || cn == int_TYPE || cn == long_TYPE || cn == float_TYPE || cn == double_TYPE;
}",0.7799352750809061
185989,"@Override public void start(BundleContext context) throws Exception {
  super.start(context);
  try {
    GROOVY_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.GROOVY_JAR));
    GROOVY_ALL_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.GROOVY_ALL_JAR));
    ASM_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.ASM_JAR));
    GROOVY_GPP_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.GROOVY_GPP_JAR));
  }
 catch (  Exception e) {
    getLog().log(new Status(IStatus.ERROR,PLUGIN_ID,""String_Node_Str"",e));
  }
}","@Override public void start(BundleContext context) throws Exception {
  super.start(context);
  try {
    GROOVY_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.GROOVY_JAR));
    GROOVY_ALL_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.GROOVY_ALL_JAR));
    ASM_JAR_URL=FileLocator.resolve(context.getBundle().getEntry(GroovyActivator.ASM_JAR));
  }
 catch (  Exception e) {
    getLog().log(new Status(IStatus.ERROR,PLUGIN_ID,""String_Node_Str"",e));
  }
}",0.9086021505376344
185990,"/** 
 * @see IEditorActionDelegate#setActiveEditor(bIAction,IEditorPart)
 */
public void setActiveEditor(IAction callerAction,IEditorPart targetEditor){
  fEditorPart=targetEditor;
  super.setActiveEditor(callerAction,targetEditor);
}","/** 
 * @see IEditorActionDelegate#setActiveEditor(bIAction,IEditorPart)
 */
@Override public void setActiveEditor(IAction callerAction,IEditorPart targetEditor){
  fEditorPart=targetEditor;
  super.setActiveEditor(callerAction,targetEditor);
}",0.9790794979079498
185991,"/** 
 * @see AbstractRulerActionDelegate#createAction()
 */
protected IAction createAction(ITextEditor editor,IVerticalRulerInfo rulerInfo){
  IResource resource;
  IEditorInput editorInput=editor.getEditorInput();
  if (editorInput instanceof IFileEditorInput) {
    resource=((IFileEditorInput)editorInput).getFile();
    if (GroovyNature.hasGroovyNature(resource.getProject())) {
      return new GroovyBreakpointRulerAction(rulerInfo,editor,fEditorPart);
    }
  }
  return super.createAction(editor,rulerInfo);
}","/** 
 * @see AbstractRulerActionDelegate#createAction()
 */
@Override protected IAction createAction(ITextEditor editor,IVerticalRulerInfo rulerInfo){
  IResource resource;
  IEditorInput editorInput=editor.getEditorInput();
  if (editorInput instanceof IFileEditorInput) {
    resource=((IFileEditorInput)editorInput).getFile();
    if (GroovyNature.hasGroovyNature(resource.getProject())) {
      groovyDelegate=new GroovyBreakpointRulerAction(rulerInfo,editor,fEditorPart);
      return groovyDelegate;
    }
  }
  return super.createAction(editor,rulerInfo);
}",0.9435707678075856
185992,"public List<IJavaCompletionProposal> getQuickFixProposals(){
  Collection<ICommandAccess> proposals=new ArrayList<ICommandAccess>(2);
  LocalCorrectionsSubProcessor.addUnimplementedMethodsProposals(getQuickFixProblem().getContext(),getQuickFixProblem().getLocation(),proposals);
  List<IJavaCompletionProposal> newProposals=new ArrayList<IJavaCompletionProposal>();
  for (  ICommandAccess command : proposals) {
    if (command instanceof IJavaCompletionProposal) {
      newProposals.add((IJavaCompletionProposal)command);
    }
  }
  return newProposals;
}","public List<IJavaCompletionProposal> getQuickFixProposals(){
  Collection<IJavaCompletionProposal> proposals=new ArrayList<IJavaCompletionProposal>(2);
  addUnimplementedMethodsProposals(getQuickFixProblem().getContext(),getQuickFixProblem().getLocation(),proposals);
  List<IJavaCompletionProposal> newProposals=new ArrayList<IJavaCompletionProposal>();
  for (  Object command : proposals) {
    if (command instanceof IJavaCompletionProposal) {
      newProposals.add((IJavaCompletionProposal)command);
    }
  }
  return newProposals;
}",0.89171974522293
185993,"public static Bundle getActiveGroovyBundle(){
  String version17=""String_Node_Str"";
  String version18=""String_Node_Str"";
  String version20=""String_Node_Str"";
  String versionToUse=version20;
  if (isGroovy20DisabledOrMissing()) {
    if (isGroovy18DisabledOrMissing()) {
      versionToUse=version17;
    }
 else {
      versionToUse=version18;
    }
  }
  Bundle[] active=Platform.getBundles(""String_Node_Str"",version20);
  return active != null && active.length > 0 ? active[0] : null;
}","public static Bundle getActiveGroovyBundle(){
  String version17=""String_Node_Str"";
  String version18=""String_Node_Str"";
  String version20=""String_Node_Str"";
  String versionToUse=version20;
  if (isGroovy20DisabledOrMissing()) {
    if (isGroovy18DisabledOrMissing()) {
      versionToUse=version17;
    }
 else {
      versionToUse=version18;
    }
  }
  Bundle[] active=Platform.getBundles(""String_Node_Str"",versionToUse);
  return active != null && active.length > 0 ? active[0] : null;
}",0.9928934010152284
185994,"@Override protected IPreferenceStore doGetPreferenceStore(){
  IProject project=getProject();
  ScopedPreferenceStore store;
  if (project == null) {
    preferences=InstanceScope.INSTANCE.getNode(Activator.PLUGIN_ID);
    store=new ScopedPreferenceStore(InstanceScope.INSTANCE,Activator.PLUGIN_ID);
  }
 else {
    IScopeContext projectScope=new ProjectScope(project);
    preferences=projectScope.getNode(Activator.PLUGIN_ID);
    store=new ScopedPreferenceStore(projectScope,Activator.PLUGIN_ID);
  }
  return store;
}","@Override protected IPreferenceStore doGetPreferenceStore(){
  IProject project=getProject();
  ScopedPreferenceStore store;
  if (project == null) {
    IScopeContext scope=new InstanceScope();
    preferences=scope.getNode(Activator.PLUGIN_ID);
    store=new ScopedPreferenceStore(scope,Activator.PLUGIN_ID);
  }
 else {
    IScopeContext projectScope=new ProjectScope(project);
    preferences=projectScope.getNode(Activator.PLUGIN_ID);
    store=new ScopedPreferenceStore(projectScope,Activator.PLUGIN_ID);
  }
  return store;
}",0.9078822412155746
185995,"public GroovyImageDecorator(){
  problemsDecorator=new TreeHierarchyLayoutProblemsDecorator();
  decman=WorkbenchPlugin.getDefault().getDecoratorManager();
  listener=new PreferenceChangeListener();
  InstanceScope.INSTANCE.getNode(Activator.PLUGIN_ID).addPreferenceChangeListener(listener);
  scriptFolderSelector=new ScriptFolderSelector(null);
}","public GroovyImageDecorator(){
  problemsDecorator=new TreeHierarchyLayoutProblemsDecorator();
  decman=WorkbenchPlugin.getDefault().getDecoratorManager();
  listener=new PreferenceChangeListener();
  new InstanceScope().getNode(Activator.PLUGIN_ID).addPreferenceChangeListener(listener);
  scriptFolderSelector=new ScriptFolderSelector(null);
}",0.9783549783549784
185996,"@Override public void configure(ProjectConfigurationRequest request,IProgressMonitor monitor) throws CoreException {
  super.configure(request,monitor);
  IProject project=request.getProject();
  if (getSourceType(request.getMavenProjectFacade()) != null) {
    if (!project.hasNature(GroovyNature.GROOVY_NATURE)) {
      if (!project.hasNature(JavaCore.NATURE_ID)) {
        addJavaNature(project);
      }
      GroovyRuntime.addGroovyNature(project);
    }
    IJavaProject javaProject=JavaCore.create(project);
    if (!GroovyRuntime.hasClasspathContainer(javaProject,GroovyRuntime.DSLD_CONTAINER_ID)) {
      GroovyRuntime.addLibraryToClasspath(javaProject,GroovyRuntime.DSLD_CONTAINER_ID);
    }
  }
 else {
    GroovyRuntime.removeGroovyNature(project);
  }
}","@Override public void configure(ProjectConfigurationRequest request,IProgressMonitor monitor) throws CoreException {
  super.configure(request,monitor);
  IProject project=request.getProject();
  if (getSourceType(request.getMavenProjectFacade()) != null) {
    if (!project.hasNature(GroovyNature.GROOVY_NATURE)) {
      if (!project.hasNature(JavaCore.NATURE_ID)) {
        addJavaNature(project);
      }
      GroovyRuntime.addGroovyNature(project);
    }
    IJavaProject javaProject=JavaCore.create(project);
    if (!GroovyRuntime.hasClasspathContainer(javaProject,GroovyRuntime.DSLD_CONTAINER_ID)) {
      GroovyRuntime.addLibraryToClasspath(javaProject,GroovyRuntime.DSLD_CONTAINER_ID,false);
    }
  }
 else {
    GroovyRuntime.removeGroovyNature(project);
  }
}",0.9960988296488946
185997,"private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}","private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}",0.8609583660644148
185998,"private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}","private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}",0.847571189279732
185999,"protected void importDef(AST importNode){
  boolean isStatic=importNode.getType() == STATIC_IMPORT;
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=importNode.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  String alias=null;
  if (isType(LITERAL_as,node)) {
    node=node.getFirstChild();
    AST aliasNode=node.getNextSibling();
    alias=identifier(aliasNode);
  }
  if (node.getNumberOfChildren() == 0) {
    String name=identifier(node);
    ClassNode type=ClassHelper.make(name);
    configureAST(type,importNode);
    addImport(type,name,alias,annotations);
    return;
  }
  AST packageNode=node.getFirstChild();
  String packageName=qualifiedName(packageNode);
  AST nameNode=packageNode.getNextSibling();
  if (isType(STAR,nameNode)) {
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticStarImport(type,packageName,annotations);
      ASTNode imp=(ASTNode)output.getStaticStarImports().get(packageName);
      configureAST(imp,importNode);
    }
 else {
      addStarImport(packageName,annotations);
      ASTNode imp=(ASTNode)output.getStarImports().get(output.getStarImports().size() - 1);
      configureAST(imp,importNode);
    }
    if (alias != null)     throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    String name=identifier(nameNode);
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticImport(type,name,alias,annotations);
      ASTNode imp=(ASTNode)output.getStaticImports().get(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
 else {
      ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
      configureAST(type,nameNode);
      addImport(type,name,alias,annotations);
    }
  }
}","protected void importDef(AST importNode){
  boolean isStatic=importNode.getType() == STATIC_IMPORT;
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=importNode.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  String alias=null;
  if (isType(LITERAL_as,node)) {
    node=node.getFirstChild();
    AST aliasNode=node.getNextSibling();
    alias=identifier(aliasNode);
  }
  if (node.getNumberOfChildren() == 0) {
    String name=identifier(node);
    ClassNode type=ClassHelper.make(name);
    configureAST(type,importNode);
    addImport(type,name,alias,annotations);
    return;
  }
  AST packageNode=node.getFirstChild();
  String packageName=qualifiedName(packageNode);
  AST nameNode=packageNode.getNextSibling();
  if (isType(STAR,nameNode)) {
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticStarImport(type,packageName,annotations);
      ASTNode imp=(ASTNode)output.getStaticStarImports().get(packageName);
      configureAST(imp,importNode);
    }
 else {
      addStarImport(packageName,annotations);
      ASTNode imp=(ASTNode)output.getStarImports().get(output.getStarImports().size() - 1);
      configureAST(imp,importNode);
    }
    if (alias != null)     throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    String name=identifier(nameNode);
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticImport(type,name,alias,annotations);
      ASTNode imp=(ASTNode)output.getStaticImports().get(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
 else {
      ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
      configureAST(type,nameNode);
      addImport(type,name,alias,annotations);
      ImportNode imp=output.getImport(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
  }
}",0.9736908043096968
186000,"private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}","private ASTNode getLast(BlockStatement statements,List<MethodNode> methods){
  Statement lastStatement=hasScriptStatements(statements) ? statements.getStatements().get(statements.getStatements().size() - 1) : null;
  MethodNode lastMethod=hasScriptMethods(methods) ? methods.get(methods.size() - 1) : null;
  if (lastMethod == null && (lastStatement == null || (lastStatement.getStart() == 0 && lastStatement.getLength() == 0))) {
    lastStatement=createSyntheticAfterImports();
  }
  int statementStart=lastStatement != null ? lastStatement.getEnd() : Integer.MIN_VALUE;
  int methodStart=lastMethod != null ? lastMethod.getStart() : Integer.MIN_VALUE;
  return statementStart >= methodStart ? lastStatement : lastMethod;
}",0.8609583660644148
