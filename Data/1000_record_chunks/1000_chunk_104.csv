record_number,buggy_code,fixed_code,code_similarity
103001,"/** 
 * Sets the new rolefor the local user in the context of this chatroom.
 * @param role the new role to be set for the local user
 */
public void setLocalUserRole(ChatRoomMemberRole role){
  fireLocalUserRoleEvent(getUserRole(),role);
  this.role=role;
}","/** 
 * Sets the new rolefor the local user in the context of this chatroom.
 * @param role the new role to be set for the local user
 * @param isInitial if <tt>true</tt> this is initial role set.
 */
public void setLocalUserRole(ChatRoomMemberRole role,boolean isInitial){
  fireLocalUserRoleEvent(getUserRole(),role,isInitial);
  this.role=role;
}",0.8500823723228995
103002,"/** 
 * Creates the corresponding ChatRoomLocalUserRoleChangeEvent and notifies all <tt>ChatRoomLocalUserRoleListener</tt>s that local user's role has been changed in this <tt>ChatRoom</tt>.
 * @param previousRole the previous role that local user had
 * @param newRole the new role the local user gets
 */
private void fireLocalUserRoleEvent(ChatRoomMemberRole previousRole,ChatRoomMemberRole newRole){
  ChatRoomLocalUserRoleChangeEvent evt=new ChatRoomLocalUserRoleChangeEvent(this,previousRole,newRole);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + evt);
  Iterable<ChatRoomLocalUserRoleListener> listeners;
synchronized (localUserRoleListeners) {
    listeners=new ArrayList<ChatRoomLocalUserRoleListener>(localUserRoleListeners);
  }
  for (  ChatRoomLocalUserRoleListener listener : listeners)   listener.localUserRoleChanged(evt);
}","/** 
 * Creates the corresponding ChatRoomLocalUserRoleChangeEvent and notifies all <tt>ChatRoomLocalUserRoleListener</tt>s that local user's role has been changed in this <tt>ChatRoom</tt>.
 * @param previousRole the previous role that local user had
 * @param newRole the new role the local user gets
 * @param isInitial if <tt>true</tt> this is initial role set.
 */
private void fireLocalUserRoleEvent(ChatRoomMemberRole previousRole,ChatRoomMemberRole newRole,boolean isInitial){
  ChatRoomLocalUserRoleChangeEvent evt=new ChatRoomLocalUserRoleChangeEvent(this,previousRole,newRole,isInitial);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + evt);
  Iterable<ChatRoomLocalUserRoleListener> listeners;
synchronized (localUserRoleListeners) {
    listeners=new ArrayList<ChatRoomLocalUserRoleListener>(localUserRoleListeners);
  }
  for (  ChatRoomLocalUserRoleListener listener : listeners)   listener.localUserRoleChanged(evt);
}",0.9498069498069498
103003,"/** 
 * Creates a <tt>ChatRoomLocalUserRoleChangeEvent</tt> representing that a change in local participant role in the source chat room has occured.
 * @param sourceRoom the <tt>ChatRoom</tt> that produced the event
 * @param previousRole the previous role that local participant had
 * @param newRole the new role that local participant get
 */
public ChatRoomLocalUserRoleChangeEvent(ChatRoom sourceRoom,ChatRoomMemberRole previousRole,ChatRoomMemberRole newRole){
  super(sourceRoom);
  this.previousRole=previousRole;
  this.newRole=newRole;
}","/** 
 * Creates a <tt>ChatRoomLocalUserRoleChangeEvent</tt> representing that a change in local participant role in the source chat room has occured.
 * @param sourceRoom the <tt>ChatRoom</tt> that produced the event
 * @param previousRole the previous role that local participant had
 * @param newRole the new role that local participant get
 * @param isInitial if <tt>true</tt> this is initial role set.
 */
public ChatRoomLocalUserRoleChangeEvent(ChatRoom sourceRoom,ChatRoomMemberRole previousRole,ChatRoomMemberRole newRole,boolean isInitial){
  super(sourceRoom);
  this.previousRole=previousRole;
  this.newRole=newRole;
  this.isInitial=isInitial;
}",0.9095435684647304
103004,"/** 
 * The OtrContactMenu constructor.
 * @param otrContact the OtrContact this menu refers to.
 * @param inMacOSXScreenMenuBar <tt>true</tt> if the new menu is to bedisplayed in the Mac OS X screen menu bar; <tt>false</tt>, otherwise
 * @param menu the parent menu
 */
public OtrContactMenu(OtrContact otrContact,boolean inMacOSXScreenMenuBar,JMenu menu,boolean isSeparateMenu){
  this.contact=otrContact;
  this.inMacOSXScreenMenuBar=inMacOSXScreenMenuBar;
  this.parentMenu=menu;
  String resourceName=otrContact.resource != null ? ""String_Node_Str"" + otrContact.resource.getResourceName() : ""String_Node_Str"";
  separateMenu=isSeparateMenu ? new SIPCommMenu(otrContact.contact.getDisplayName() + resourceName) : null;
  new OtrWeakListener<OtrContactMenu>(this,OtrActivator.scOtrEngine,OtrActivator.scOtrKeyManager);
  setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(this.contact));
  setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(otrContact.contact));
  buildMenu();
}","/** 
 * The OtrContactMenu constructor.
 * @param otrContact the OtrContact this menu refers to.
 * @param inMacOSXScreenMenuBar <tt>true</tt> if the new menu is to bedisplayed in the Mac OS X screen menu bar; <tt>false</tt>, otherwise
 * @param menu the parent menu
 */
public OtrContactMenu(OtrContact otrContact,boolean inMacOSXScreenMenuBar,JMenu menu,boolean isSeparateMenu){
  this.contact=otrContact;
  this.inMacOSXScreenMenuBar=inMacOSXScreenMenuBar;
  this.parentMenu=menu;
  String resourceName=otrContact.resource != null ? ""String_Node_Str"" + otrContact.resource.getResourceName() : ""String_Node_Str"";
  separateMenu=isSeparateMenu ? new SIPCommMenu(otrContact.contact.getDisplayName() + resourceName) : null;
  new OtrWeakListener<OtrContactMenu>(this,OtrActivator.scOtrEngine,OtrActivator.scOtrKeyManager);
  OtrPolicy policy=OtrActivator.scOtrEngine.getContactPolicy(otrContact.contact);
  if (policy.getAllowV1() && policy.getAllowV2())   policy.setAllowV3(true);
 else   policy.setAllowV3(false);
  OtrActivator.scOtrEngine.setContactPolicy(contact.contact,policy);
  policy=OtrActivator.scOtrEngine.getGlobalPolicy();
  if (policy.getAllowV1() && policy.getAllowV2())   policy.setAllowV3(true);
 else   policy.setAllowV3(false);
  OtrActivator.scOtrEngine.setGlobalPolicy(policy);
  setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(this.contact));
  setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(otrContact.contact));
  buildMenu();
}",0.7923763179237632
103005,"/** 
 * Creates an instance of <tt>CallHistoryContactQuery</tt> based on the given <tt>callHistoryQuery</tt>.
 * @param callHistoryQuery the query used to track the call history
 */
public CallHistoryContactQuery(CallHistoryQuery callHistoryQuery){
  this.callHistoryQuery=callHistoryQuery;
  callHistoryQuery.addQueryListener(new CallHistoryQueryListener(){
    public void callRecordReceived(    CallRecordEvent event){
      if (getStatus() == ContactQuery.QUERY_CANCELED)       return;
      SourceContact contact=new CallHistorySourceContact(CallHistoryContactSource.this,event.getCallRecord());
      sourceContacts.add(contact);
      fireQueryEvent(contact);
    }
    public void queryStatusChanged(    CallHistoryQueryStatusEvent event){
      status=event.getEventType();
      fireQueryStatusEvent(status);
    }
  }
);
  Iterator<CallRecord> callRecords=callHistoryQuery.getCallRecords().iterator();
  while (callRecords.hasNext()) {
    SourceContact contact=new CallHistorySourceContact(CallHistoryContactSource.this,callRecords.next());
    sourceContacts.add(contact);
  }
}","/** 
 * Creates an instance of <tt>CallHistoryContactQuery</tt> based on the given <tt>callHistoryQuery</tt>.
 * @param callHistoryQuery the query used to track the call history
 */
public CallHistoryContactQuery(CallHistoryQuery callHistoryQuery){
  this.callHistoryQuery=callHistoryQuery;
}",0.4222704266088214
103006,"/** 
 * Tries to resolves a peer address into a display name, by reqesting the <tt>ContactSourceService</tt>s. This function returns only the first match.
 * @param peerAddress The peer address.
 * @return The corresponding display name, if there is a match. Nullotherwise.
 */
private static String resolveContactSource(String peerAddress){
  String displayName=null;
  if (!StringUtils.isNullOrEmpty(peerAddress)) {
    Vector<ResolveAddressToDisplayNameContactQueryListener> resolvers=new Vector<ResolveAddressToDisplayNameContactQueryListener>(1,1);
    int index=peerAddress.indexOf(""String_Node_Str"");
    String peerUserID=(index > -1) ? peerAddress.substring(0,index) : peerAddress;
    peerUserID=Pattern.quote(peerUserID);
    Pattern pattern=Pattern.compile(""String_Node_Str"" + peerUserID + ""String_Node_Str""+ peerUserID+ ""String_Node_Str"");
    for (    ContactSourceService contactSourceService : GuiActivator.getContactSources()) {
      if (!(contactSourceService instanceof ExtendedContactSourceService))       continue;
      ContactQuery query=((ExtendedContactSourceService)contactSourceService).queryContactSource(pattern);
      resolvers.add(new ResolveAddressToDisplayNameContactQueryListener(query));
    }
    long startTime=System.currentTimeMillis();
    long currentTime=startTime;
    long timeout=500;
    while (displayName == null && currentTime - startTime < timeout) {
      for (int i=0; i < resolvers.size() && displayName == null; ++i) {
        ResolveAddressToDisplayNameContactQueryListener resolver=resolvers.get(i);
        if (!resolver.isRunning()) {
          if (resolver.isFound()) {
            displayName=resolver.getResolvedName();
            if (displayName.equals(peerAddress)) {
              displayName=null;
            }
          }
        }
      }
      Thread.yield();
      currentTime=System.currentTimeMillis();
    }
    for (int i=0; i < resolvers.size(); ++i) {
      ResolveAddressToDisplayNameContactQueryListener resolver=resolvers.get(i);
      if (resolver.isRunning()) {
        resolver.stop();
      }
    }
  }
  return displayName;
}","/** 
 * Tries to resolves a peer address into a display name, by reqesting the <tt>ContactSourceService</tt>s. This function returns only the first match.
 * @param peerAddress The peer address.
 * @return The corresponding display name, if there is a match. Nullotherwise.
 */
private static String resolveContactSource(String peerAddress){
  String displayName=null;
  if (!StringUtils.isNullOrEmpty(peerAddress)) {
    Vector<ResolveAddressToDisplayNameContactQueryListener> resolvers=new Vector<ResolveAddressToDisplayNameContactQueryListener>(1,1);
    int index=peerAddress.indexOf(""String_Node_Str"");
    String peerUserID=(index > -1) ? peerAddress.substring(0,index) : peerAddress;
    peerUserID=Pattern.quote(peerUserID);
    Pattern pattern=Pattern.compile(""String_Node_Str"" + peerUserID + ""String_Node_Str""+ peerUserID+ ""String_Node_Str"");
    for (    ContactSourceService contactSourceService : GuiActivator.getContactSources()) {
      if (!(contactSourceService instanceof ExtendedContactSourceService))       continue;
      ContactQuery query=((ExtendedContactSourceService)contactSourceService).createContactQuery(pattern);
      resolvers.add(new ResolveAddressToDisplayNameContactQueryListener(query));
      query.start();
    }
    long startTime=System.currentTimeMillis();
    long currentTime=startTime;
    long timeout=500;
    while (displayName == null && currentTime - startTime < timeout) {
      for (int i=0; i < resolvers.size() && displayName == null; ++i) {
        ResolveAddressToDisplayNameContactQueryListener resolver=resolvers.get(i);
        if (!resolver.isRunning()) {
          if (resolver.isFound()) {
            displayName=resolver.getResolvedName();
            if (displayName.equals(peerAddress)) {
              displayName=null;
            }
          }
        }
      }
      Thread.yield();
      currentTime=System.currentTimeMillis();
    }
    for (int i=0; i < resolvers.size(); ++i) {
      ResolveAddressToDisplayNameContactQueryListener resolver=resolvers.get(i);
      if (resolver.isRunning()) {
        resolver.stop();
      }
    }
  }
  return displayName;
}",0.9493521790341578
103007,"/** 
 * Applies this filter and stores the result in the given <tt>treeModel</tt>.
 * @param filterQuery the <tt>FilterQuery</tt> that tracks the results ofthis filtering
 */
public void applyFilter(FilterQuery filterQuery){
  NotificationContactSource notificationSource=TreeContactList.getNotificationContactSource();
  if (notificationSource != null)   addMatching(notificationSource);
  Collection<UIContactSource> contactSources=GuiActivator.getContactList().getContactSources(ContactSourceService.HISTORY_TYPE);
  for (  UIContactSource contactSource : contactSources) {
    ContactQuery query=contactSource.getContactSourceService().queryContactSource(""String_Node_Str"",50);
    filterQuery.addContactQuery(query);
    addMatching(query.getQueryResults(),contactSource);
    filterQuery.removeQuery(query);
  }
  filterQuery.close();
}","/** 
 * Applies this filter and stores the result in the given <tt>treeModel</tt>.
 * @param filterQuery the <tt>FilterQuery</tt> that tracks the results ofthis filtering
 */
public void applyFilter(FilterQuery filterQuery){
  NotificationContactSource notificationSource=TreeContactList.getNotificationContactSource();
  if (notificationSource != null)   addMatching(notificationSource);
  Collection<UIContactSource> contactSources=GuiActivator.getContactList().getContactSources(ContactSourceService.HISTORY_TYPE);
  for (  UIContactSource contactSource : contactSources) {
    ContactQuery query=contactSource.getContactSourceService().createContactQuery(""String_Node_Str"",50);
    query.start();
    filterQuery.addContactQuery(query);
    addMatching(query.getQueryResults(),contactSource);
    filterQuery.removeQuery(query);
  }
  filterQuery.close();
}",0.9348209042865532
103008,"/** 
 * Adds matching notification contacts to the result tree model.
 * @param notifSource
 */
private void addMatching(NotificationContactSource notifSource){
  Iterator<? extends UIGroup> notifGroups=notifSource.getNotificationGroups();
  while (notifGroups.hasNext()) {
    UIGroup uiGroup=notifGroups.next();
    Iterator<? extends UIContact> notfications=notifSource.getNotifications(uiGroup);
    while (notfications.hasNext()) {
      GuiActivator.getContactList().addContact(notfications.next(),uiGroup,false,true);
    }
  }
}","/** 
 * Adds matching <tt>sourceContacts</tt> to the result tree model.
 * @param sourceContacts the list of <tt>SourceContact</tt>s to add
 * @param uiSource the <tt>ExternalContactSource</tt>, which contactswe're adding
 */
private void addMatching(List<SourceContact> sourceContacts,UIContactSource uiSource){
  Iterator<SourceContact> contactsIter=sourceContacts.iterator();
  while (contactsIter.hasNext()) {
    GuiActivator.getContactList().addContact(uiSource.createUIContact(contactsIter.next()),uiSource.getUIGroup(),false,true);
  }
}",0.2294172062904718
103009,"/** 
 * Adds all contacts contained in the given <tt>MetaContactGroup</tt> matching the current filter and not contained in the contact list.
 * @param metaGroup the <tt>MetaContactGroup</tt>, which matching contactsto add
 * @param query the <tt>MetaContactQuery</tt> that notifies interestedlisteners of the results of this matching
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
private void addMatching(MetaContactGroup metaGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=metaGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
synchronized (metaGroup) {
          uiGroup=MetaContactListSource.getUIGroup(metaGroup);
        }
        if (!MetaContactListSource.isRootGroup(metaGroup)) {
synchronized (metaGroup) {
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(metaGroup);
          }
        }
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + metaContact.getDisplayName());
        UIContact newUIContact;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.createUIContact(metaContact);
        }
        GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
        query.setInitialResultCount(resultCount);
      }
 else       query.fireQueryEvent(metaContact);
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=metaGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    if (isMatching(subgroup)) {
      UIGroup uiGroup;
synchronized (subgroup) {
        uiGroup=MetaContactListSource.getUIGroup(subgroup);
        if (uiGroup == null)         uiGroup=MetaContactListSource.createUIGroup(subgroup);
      }
      GuiActivator.getContactList().addGroup(uiGroup,true);
      addMatching(subgroup,query,resultCount);
    }
  }
}","/** 
 * Adds all contacts contained in the given <tt>MetaContactGroup</tt> matching the current filter and not contained in the contact list.
 * @param metaGroup the <tt>MetaContactGroup</tt>, which matching contactsto add
 * @param query the <tt>MetaContactQuery</tt> that notifies interestedlisteners of the results of this matching
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
private void addMatching(MetaContactGroup metaGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=metaGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
synchronized (metaGroup) {
          uiGroup=MetaContactListSource.getUIGroup(metaGroup);
        }
        if (!MetaContactListSource.isRootGroup(metaGroup)) {
synchronized (metaGroup) {
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(metaGroup);
          }
        }
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + metaContact.getDisplayName());
        UIContact newUIContact;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.getUIContact(metaContact);
          if (newUIContact == null) {
            newUIContact=MetaContactListSource.createUIContact(metaContact);
            GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
          }
        }
        query.setInitialResultCount(resultCount);
      }
 else {
synchronized (metaContact) {
          if (MetaContactListSource.getUIContact(metaContact) == null) {
            query.fireQueryEvent(metaContact);
          }
        }
      }
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=metaGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    if (isMatching(subgroup)) {
      UIGroup uiGroup;
synchronized (subgroup) {
        uiGroup=MetaContactListSource.getUIGroup(subgroup);
        if (uiGroup == null)         uiGroup=MetaContactListSource.createUIGroup(subgroup);
      }
      GuiActivator.getContactList().addGroup(uiGroup,true);
      addMatching(subgroup,query,resultCount);
    }
  }
}",0.918032786885246
103010,"/** 
 * Removes the UI group associated with the root meta contact group.
 */
private void removeMetaUIRootGroup(){
  MetaContactGroup rootGroup=GuiActivator.getContactListService().getRoot();
  UIGroup uiGroup=MetaContactListSource.getUIGroup(rootGroup);
  if (uiGroup == null)   return;
  GroupNode parentNode=treeModel.getRoot();
  Iterator<MetaContact> i=rootGroup.getChildContacts();
  while (i.hasNext()) {
    MetaContact contact=i.next();
    UIContact uiContact=MetaContactListSource.getUIContact(contact);
    removeContact(uiContact);
    uiContact=MetaContactListSource.createUIContact(contact);
    if (currentFilter.isMatching(uiContact))     addContact(uiContact,treeModel.getRoot().getGroupDescriptor(),true,true);
 else     MetaContactListSource.removeUIContact(contact);
  }
  parentNode.removeContactGroup((UIGroupImpl)uiGroup);
}","/** 
 * Removes the UI group associated with the root meta contact group.
 */
private void removeMetaUIRootGroup(){
  MetaContactGroup rootGroup=GuiActivator.getContactListService().getRoot();
  UIGroup uiGroup;
synchronized (rootGroup) {
    uiGroup=MetaContactListSource.getUIGroup(rootGroup);
    if (uiGroup == null)     return;
  }
  GroupNode parentNode=treeModel.getRoot();
  Iterator<MetaContact> i=rootGroup.getChildContacts();
  while (i.hasNext()) {
    MetaContact contact=i.next();
    UIContact uiContact;
synchronized (contact) {
      uiContact=MetaContactListSource.getUIContact(contact);
      if (uiContact == null)       continue;
      removeContact(uiContact);
      uiContact=MetaContactListSource.createUIContact(contact);
    }
    if (currentFilter.isMatching(uiContact))     addContact(uiContact,treeModel.getRoot().getGroupDescriptor(),true,true);
 else     MetaContactListSource.removeUIContact(contact);
  }
  parentNode.removeContactGroup((UIGroupImpl)uiGroup);
}",0.9137276180141074
103011,"/** 
 * Creates UI group for the root meta contact group.
 */
private void createMetaUIRootGroup(){
  MetaContactGroup rootGroup=GuiActivator.getContactListService().getRoot();
  UIGroup uiGroup=MetaContactListSource.getUIGroup(rootGroup);
  if (uiGroup != null)   return;
  uiGroup=MetaContactListSource.createUIGroup(rootGroup);
  treeModel.getRoot().sortedAddContactGroup((UIGroupImpl)uiGroup);
  Iterator<MetaContact> i=rootGroup.getChildContacts();
  while (i.hasNext()) {
    MetaContact contact=i.next();
    UIContact uiContact=MetaContactListSource.getUIContact(contact);
    removeContact(uiContact);
    uiContact=MetaContactListSource.createUIContact(contact);
    if (currentFilter.isMatching(uiContact))     addContact(uiContact,uiGroup,true,true);
 else     MetaContactListSource.removeUIContact(contact);
  }
}","/** 
 * Creates UI group for the root meta contact group.
 */
private void createMetaUIRootGroup(){
  MetaContactGroup rootGroup=GuiActivator.getContactListService().getRoot();
  UIGroup uiGroup;
synchronized (rootGroup) {
    uiGroup=MetaContactListSource.getUIGroup(rootGroup);
    if (uiGroup != null)     return;
    uiGroup=MetaContactListSource.createUIGroup(rootGroup);
  }
  treeModel.getRoot().sortedAddContactGroup((UIGroupImpl)uiGroup);
  Iterator<MetaContact> i=rootGroup.getChildContacts();
  while (i.hasNext()) {
    MetaContact contact=i.next();
    UIContact uiContact;
synchronized (contact) {
      uiContact=MetaContactListSource.getUIContact(contact);
      if (uiContact == null)       continue;
      removeContact(uiContact);
      uiContact=MetaContactListSource.createUIContact(contact);
    }
    if (currentFilter.isMatching(uiContact))     addContact(uiContact,uiGroup,true,true);
 else     MetaContactListSource.removeUIContact(contact);
  }
}",0.9093941078376876
103012,"/** 
 * Filters the children in the given <tt>MetaContactGroup</tt> to match the given <tt>filterPattern</tt> and stores the result in the given <tt>treeModel</tt>.
 * @param filterPattern the pattern to filter through
 * @param parentGroup the <tt>MetaContactGroup</tt> to filter
 * @param query the object that tracks the query
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
public void queryMetaContactSource(Pattern filterPattern,MetaContactGroup parentGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=parentGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(filterPattern,metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
synchronized (parentGroup) {
          uiGroup=MetaContactListSource.getUIGroup(parentGroup);
        }
        if (!MetaContactListSource.isRootGroup(parentGroup)) {
synchronized (parentGroup) {
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(parentGroup);
          }
        }
        UIContact newUIContact;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.createUIContact(metaContact);
        }
        GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
        query.setInitialResultCount(resultCount);
      }
 else       query.fireQueryEvent(metaContact);
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=parentGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    queryMetaContactSource(filterPattern,subgroup,query,resultCount);
  }
}","/** 
 * Filters the children in the given <tt>MetaContactGroup</tt> to match the given <tt>filterPattern</tt> and stores the result in the given <tt>treeModel</tt>.
 * @param filterPattern the pattern to filter through
 * @param parentGroup the <tt>MetaContactGroup</tt> to filter
 * @param query the object that tracks the query
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
public void queryMetaContactSource(Pattern filterPattern,MetaContactGroup parentGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=parentGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(filterPattern,metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
synchronized (parentGroup) {
          uiGroup=MetaContactListSource.getUIGroup(parentGroup);
        }
        if (!MetaContactListSource.isRootGroup(parentGroup)) {
synchronized (parentGroup) {
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(parentGroup);
          }
        }
        UIContact newUIContact;
        boolean uiContactCreated=false;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.getUIContact(metaContact);
          if (newUIContact == null) {
            newUIContact=MetaContactListSource.createUIContact(metaContact);
            GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
          }
        }
        query.setInitialResultCount(resultCount);
      }
 else {
synchronized (metaContact) {
          if (MetaContactListSource.getUIContact(metaContact) == null) {
            query.fireQueryEvent(metaContact);
          }
        }
      }
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=parentGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    queryMetaContactSource(filterPattern,subgroup,query,resultCount);
  }
}",0.8951048951048951
103013,"/** 
 * Loads the tooltip with the data for current metacontact.
 * @param tip the tooltip to fill.
 */
private void loadTooltip(final ExtendedTooltip tip){
  Iterator<Contact> i=metaContact.getContacts();
  MetaContactPhoneUtil contactPhoneUtil=MetaContactPhoneUtil.getPhoneUtil(metaContact);
  String statusMessage=null;
  Contact protocolContact;
  boolean isLoading=false;
  while (i.hasNext()) {
    protocolContact=i.next();
    if (statusMessage == null && protocolContact.getStatusMessage() != null && protocolContact.getStatusMessage().length() > 0)     statusMessage=protocolContact.getStatusMessage();
    if (ConfigurationUtils.isHideAccountStatusSelectorsEnabled())     break;
    ImageIcon protocolStatusIcon=ImageLoader.getIndexedProtocolIcon(ImageUtils.getBytesInImage(protocolContact.getPresenceStatus().getStatusIcon()),protocolContact.getProtocolProvider());
    String contactAddress=protocolContact.getAddress();
    tip.addLine(protocolStatusIcon,contactAddress);
    addContactResourceTooltipLines(tip,protocolContact);
    if (!protocolContact.getProtocolProvider().isRegistered())     continue;
    List<String> phones=contactPhoneUtil.getPhones(protocolContact,new OperationSetServerStoredContactInfo.DetailsResponseListener(){
      public void detailsRetrieved(      final Iterator<GenericDetail> details){
        if (!SwingUtilities.isEventDispatchThread()) {
          SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              detailsRetrieved(details);
            }
          }
);
          return;
        }
        tip.removeAllLines();
        loadTooltip(tip);
      }
    }
,true);
    if (phones != null) {
      addPhoneTooltipLines(tip,phones.iterator());
    }
 else     isLoading=true;
  }
  if (isLoading)   tip.addLine(null,GuiActivator.getResources().getI18NString(""String_Node_Str""));
  if (statusMessage != null)   tip.setBottomText(statusMessage);
}","/** 
 * Loads the tooltip with the data for current metacontact.
 * @param tip the tooltip to fill.
 */
private void loadTooltip(final ExtendedTooltip tip){
  Iterator<Contact> i=metaContact.getContacts();
  MetaContactPhoneUtil contactPhoneUtil=MetaContactPhoneUtil.getPhoneUtil(metaContact);
  String statusMessage=null;
  Contact protocolContact;
  boolean isLoading=false;
  while (i.hasNext()) {
    protocolContact=i.next();
    if (statusMessage == null) {
      statusMessage=protocolContact.getStatusMessage();
      if ((statusMessage != null) && (statusMessage.length() == 0))       statusMessage=null;
    }
    if (ConfigurationUtils.isHideAccountStatusSelectorsEnabled())     break;
    ImageIcon protocolStatusIcon=getContactPresenceStatusIcon(protocolContact);
    if (protocolStatusIcon != null) {
      protocolStatusIcon=ImageLoader.getIndexedProtocolIcon(protocolStatusIcon.getImage(),protocolContact.getProtocolProvider());
    }
    String contactAddress=protocolContact.getAddress();
    tip.addLine(protocolStatusIcon,contactAddress);
    addContactResourceTooltipLines(tip,protocolContact);
    if (!protocolContact.getProtocolProvider().isRegistered())     continue;
    List<String> phones=contactPhoneUtil.getPhones(protocolContact,new OperationSetServerStoredContactInfo.DetailsResponseListener(){
      public void detailsRetrieved(      final Iterator<GenericDetail> details){
        if (!SwingUtilities.isEventDispatchThread()) {
          SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              detailsRetrieved(details);
            }
          }
);
          return;
        }
        tip.removeAllLines();
        loadTooltip(tip);
      }
    }
,true);
    if (phones != null) {
      addPhoneTooltipLines(tip,phones.iterator());
    }
 else     isLoading=true;
  }
  if (isLoading)   tip.addLine(null,GuiActivator.getResources().getI18NString(""String_Node_Str""));
  if (statusMessage != null)   tip.setBottomText(statusMessage);
}",0.827691524560957
103014,"/** 
 * Creates an instance of <tt>MetaContactDetail</tt> by specifying the underlying protocol <tt>Contact</tt>.
 * @param contact the protocol contact, on which this implementationis based
 */
public MetaContactDetail(Contact contact){
  super(contact.getAddress(),contact.getDisplayName(),new ImageIcon(contact.getPresenceStatus().getStatusIcon()),contact);
  this.contact=contact;
  ProtocolProviderService parentProvider=contact.getProtocolProvider();
  Iterator<Class<? extends OperationSet>> opSetClasses=parentProvider.getSupportedOperationSetClasses().iterator();
  while (opSetClasses.hasNext()) {
    Class<? extends OperationSet> opSetClass=opSetClasses.next();
    addPreferredProtocolProvider(opSetClass,parentProvider);
    addPreferredProtocol(opSetClass,parentProvider.getProtocolName());
  }
}","/** 
 * Creates an instance of <tt>MetaContactDetail</tt> by specifying the underlying protocol <tt>Contact</tt>.
 * @param contact the protocol contact, on which this implementationis based
 */
public MetaContactDetail(Contact contact){
  super(contact.getAddress(),contact.getDisplayName(),getContactPresenceStatusIcon(contact),contact);
  this.contact=contact;
  ProtocolProviderService parentProvider=contact.getProtocolProvider();
  Iterator<Class<? extends OperationSet>> opSetClasses=parentProvider.getSupportedOperationSetClasses().iterator();
  while (opSetClasses.hasNext()) {
    Class<? extends OperationSet> opSetClass=opSetClasses.next();
    addPreferredProtocolProvider(opSetClass,parentProvider);
    addPreferredProtocol(opSetClass,parentProvider.getProtocolName());
  }
}",0.94316052467208
103015,"/** 
 * Returns the icon for the provider.
 * @param providerService the provider
 * @param customProviderImage set custom provider image
 * @return the image.
 */
private static Image getIconForProvider(ProtocolProviderService providerService,Image customProviderImage,ImageObserver imageObserver){
  Image left=null;
  if (isAutoAnswerEnabled(providerService))   left=ImageLoader.getImage(ImageLoader.AUTO_ANSWER_CHECK);
  if (customProviderImage == null)   customProviderImage=ImageUtils.getBytesInImage(providerService.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16));
  return ImageUtils.getComposedImage(left,customProviderImage,imageObserver);
}","/** 
 * Returns the icon for the provider.
 * @param providerService the provider
 * @param customProviderImage set custom provider image
 * @return the image.
 */
private static Image getIconForProvider(ProtocolProviderService providerService,Image customProviderImage,ImageObserver imageObserver){
  Image left=isAutoAnswerEnabled(providerService) ? ImageLoader.getImage(ImageLoader.AUTO_ANSWER_CHECK) : null;
  if (customProviderImage == null) {
    byte[] bytes=providerService.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16);
    if (bytes != null)     customProviderImage=ImageUtils.getBytesInImage(bytes);
  }
  return ImageUtils.getComposedImage(left,customProviderImage,imageObserver);
}",0.8651026392961877
103016,"/** 
 * Creates the menu item.
 * @param provider the provider.
 * @param displayName the display name of the item.
 * @param onlineImage the icon to display
 * @param parentMenu the parent menu.
 */
private AutoAnswerMenuItem(ProtocolProviderService provider,String displayName,Image onlineImage,SIPCommMenu parentMenu){
  super(displayName,new ImageIcon(onlineImage));
  this.providerService=provider;
  this.parentMenu=parentMenu;
  this.addActionListener(this);
}","/** 
 * Creates the menu item.
 * @param provider the provider.
 * @param displayName the display name of the item.
 * @param onlineImage the icon to display
 * @param parentMenu the parent menu.
 */
private AutoAnswerMenuItem(ProtocolProviderService provider,String displayName,Image onlineImage,SIPCommMenu parentMenu){
  super(displayName,(onlineImage == null) ? null : new ImageIcon(onlineImage));
  this.providerService=provider;
  this.parentMenu=parentMenu;
  this.addActionListener(this);
}",0.9678756476683936
103017,"/** 
 * Adds an item to the ""choice list"" of this selector box.
 * @param text The text of the item.
 * @param icon The icon of the item.
 * @param actionListener The <tt>ActionListener</tt>, which handles thecase, when the item is selected.
 */
@Override public void addItem(String text,Icon icon,ActionListener actionListener){
  JCheckBoxMenuItem item=new JCheckBoxMenuItem(text,icon);
  item.setName(text);
  group.add(item);
  item.addActionListener(actionListener);
  this.add(item);
}","/** 
 * Adds an item to the ""choice list"" of this selector box.
 * @param text The text of the item.
 * @param icon The icon of the item.
 * @param actionListener The <tt>ActionListener</tt>, which handles thecase, when the item is selected.
 */
@Override public void addItem(String text,Icon icon,ActionListener actionListener){
  JCheckBoxMenuItem item=new JCheckBoxMenuItem(text,icon);
  item.setName(text);
  group.add(item);
  item.addActionListener(actionListener);
  add(item);
}",0.9948822927328556
103018,"/** 
 * Initializes a new <tt>PresenceStatusMenu</tt> instance which is to depict and change the presence status of a specific <tt>ProtocolProviderService</tt>.
 * @param protocolProvider the <tt>ProtocolProviderService</tt> which is tohave its presence status depicted and changed by the new instance
 */
public PresenceStatusMenu(ProtocolProviderService protocolProvider){
  super(protocolProvider.getAccountID().getDisplayName(),ImageLoader.getAccountStatusImage(protocolProvider),protocolProvider);
  this.presence=protocolProvider.getOperationSet(OperationSetPresence.class);
  Iterator<PresenceStatus> statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getDisplayName() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleArea=new JEditorPane();
  titleArea.setContentType(""String_Node_Str"");
  Constants.loadSimpleStyle(((HTMLDocument)titleArea.getDocument()).getStyleSheet(),titleArea.getFont());
  titleArea.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleArea.setOpaque(false);
  titleArea.setEditable(false);
  titleArea.setAlignmentX(Component.RIGHT_ALIGNMENT);
  statusMessageMenu=new StatusMessageMenu(protocolProvider,true);
  statusMessageMenu.addPropertyChangeListener(this);
  updateTitleArea();
  this.add(titleArea);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=statusIterator.next();
    this.addItem(status.getStatusName(),new ImageIcon(status.getStatusIcon()),this);
  }
  this.addSeparator();
  this.add((JMenu)statusMessageMenu.getMenu());
  this.setSelectedStatus(getOfflineStatus());
  updateStatus(getOfflineStatus());
}","/** 
 * Initializes a new <tt>PresenceStatusMenu</tt> instance which is to depict and change the presence status of a specific <tt>ProtocolProviderService</tt>.
 * @param protocolProvider the <tt>ProtocolProviderService</tt> which is tohave its presence status depicted and changed by the new instance
 */
public PresenceStatusMenu(ProtocolProviderService protocolProvider){
  super(protocolProvider.getAccountID().getDisplayName(),ImageLoader.getAccountStatusImage(protocolProvider),protocolProvider);
  this.presence=protocolProvider.getOperationSet(OperationSetPresence.class);
  Iterator<PresenceStatus> statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getDisplayName() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleArea=new JEditorPane();
  titleArea.setContentType(""String_Node_Str"");
  Constants.loadSimpleStyle(((HTMLDocument)titleArea.getDocument()).getStyleSheet(),titleArea.getFont());
  titleArea.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleArea.setOpaque(false);
  titleArea.setEditable(false);
  titleArea.setAlignmentX(Component.RIGHT_ALIGNMENT);
  statusMessageMenu=new StatusMessageMenu(protocolProvider,true);
  statusMessageMenu.addPropertyChangeListener(this);
  updateTitleArea();
  this.add(titleArea);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=statusIterator.next();
    byte[] statusIcon=status.getStatusIcon();
    addItem(status.getStatusName(),(statusIcon == null) ? null : new ImageIcon(statusIcon),this);
  }
  this.addSeparator();
  this.add((JMenu)statusMessageMenu.getMenu());
  this.setSelectedStatus(getOfflineStatus());
  updateStatus(getOfflineStatus());
}",0.9710610932475884
103019,"/** 
 * Loads resources for this component.
 */
@Override public void loadSkin(){
  super.loadSkin();
  setIcon(new ImageIcon(ImageUtils.getBytesInImage(protocolProvider.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16))));
  if (onlineItem != null)   onlineItem.setIcon(getIcon());
  if (offlineItem != null)   offlineItem.setIcon(new ImageIcon(LightGrayFilter.createDisabledImage(ImageUtils.getBytesInImage(protocolProvider.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16)))));
}","/** 
 * Loads resources for this component.
 */
@Override public void loadSkin(){
  super.loadSkin();
  Image image=getProtocolImage(protocolProvider,ProtocolIcon.ICON_SIZE_16x16);
  if (image != null)   setIcon(new ImageIcon(image));
  if (onlineItem != null)   onlineItem.setIcon(getIcon());
  if ((offlineItem != null) && (image != null)) {
    offlineItem.setIcon(new ImageIcon(LightGrayFilter.createDisabledImage(image)));
  }
}",0.6084142394822006
103020,"private JCheckBoxMenuItem createMenuItem(String textKey,Icon icon,String name){
  JCheckBoxMenuItem menuItem=new JCheckBoxMenuItem(GuiActivator.getResources().getI18NString(textKey),icon);
  menuItem.setName(name);
  menuItem.addActionListener(this);
  this.add(menuItem);
  return menuItem;
}","private JCheckBoxMenuItem createMenuItem(String textKey,Icon icon,String name){
  JCheckBoxMenuItem menuItem=new JCheckBoxMenuItem(GuiActivator.getResources().getI18NString(textKey),icon);
  menuItem.setName(name);
  menuItem.addActionListener(this);
  add(menuItem);
  return menuItem;
}",0.991394148020654
103021,"/** 
 * Creates an instance of <tt>SimpleStatusMenu</tt>.
 * @param protocolProvider the protocol provider
 * @param displayName the display name for the menu
 * @param onlineImage the image used for the online state
 */
private SimpleStatusMenu(ProtocolProviderService protocolProvider,String displayName,Image onlineImage){
  super(displayName,new ImageIcon(onlineImage),protocolProvider);
  this.setToolTipText(""String_Node_Str"" + displayName + ""String_Node_Str"");
  JLabel titleLabel=new JLabel(displayName);
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  onlineItem=createMenuItem(""String_Node_Str"",getIcon(),GlobalStatusEnum.ONLINE_STATUS);
  offlineItem=createMenuItem(""String_Node_Str"",new ImageIcon(LightGrayFilter.createDisabledImage(onlineImage)),GlobalStatusEnum.OFFLINE_STATUS);
  group.add(onlineItem);
  group.add(offlineItem);
  updateStatus(null);
}","/** 
 * Creates an instance of <tt>SimpleStatusMenu</tt>.
 * @param protocolProvider the protocol provider
 * @param displayName the display name for the menu
 * @param onlineImage the image used for the online state
 */
private SimpleStatusMenu(ProtocolProviderService protocolProvider,String displayName,Image onlineImage){
  super(displayName,(onlineImage == null) ? null : new ImageIcon(onlineImage),protocolProvider);
  setToolTipText(""String_Node_Str"" + displayName + ""String_Node_Str"");
  JLabel titleLabel=new JLabel(displayName);
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  add(titleLabel);
  addSeparator();
  onlineItem=createMenuItem(""String_Node_Str"",getIcon(),GlobalStatusEnum.ONLINE_STATUS);
  offlineItem=createMenuItem(""String_Node_Str"",(onlineImage == null) ? null : new ImageIcon(LightGrayFilter.createDisabledImage(onlineImage)),GlobalStatusEnum.OFFLINE_STATUS);
  group.add(onlineItem);
  group.add(offlineItem);
  updateStatus(null);
}",0.9623839765510503
103022,"/** 
 * Obtains the indexed status image for the given protocol provider.
 * @param pps the protocol provider for which to create the image
 * @return the indexed status image
 */
public static ImageIcon getAccountStatusImage(ProtocolProviderService pps){
  ImageIcon statusIcon;
  OperationSetPresence presence=pps.getOperationSet(OperationSetPresence.class);
  Image statusImage;
  byte[] protocolStatusIcon=null;
  if (presence != null)   protocolStatusIcon=presence.getPresenceStatus().getStatusIcon();
  if (presence != null && protocolStatusIcon != null) {
    statusImage=ImageUtils.getBytesInImage(protocolStatusIcon);
  }
 else {
    statusImage=ImageUtils.getBytesInImage(pps.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16));
    if (!pps.isRegistered()) {
      statusImage=LightGrayFilter.createDisabledImage(statusImage);
    }
  }
  statusIcon=new ImageIcon(getIndexedProtocolImage(statusImage,pps));
  return statusIcon;
}","/** 
 * Obtains the indexed status image for the given protocol provider.
 * @param pps the protocol provider for which to create the image
 * @return the indexed status image
 */
public static ImageIcon getAccountStatusImage(ProtocolProviderService pps){
  OperationSetPresence presence=pps.getOperationSet(OperationSetPresence.class);
  byte[] protocolStatusIcon=(presence == null) ? null : presence.getPresenceStatus().getStatusIcon();
  Image statusImage;
  if (presence != null && protocolStatusIcon != null) {
    statusImage=ImageUtils.getBytesInImage(protocolStatusIcon);
  }
 else {
    byte[] bytes=pps.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16);
    statusImage=(bytes == null) ? null : ImageUtils.getBytesInImage(bytes);
    if (!pps.isRegistered() && (statusImage != null)) {
      statusImage=LightGrayFilter.createDisabledImage(statusImage);
    }
  }
  return (statusImage == null) ? null : new ImageIcon(getIndexedProtocolImage(statusImage,pps));
}",0.7696307852314093
103023,"public void updateStatus(PresenceStatus presenceStatus){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + provider.getAccountID().getAccountAddress() + ""String_Node_Str""+ presenceStatus.getStatusName());
  if (menu instanceof AbstractButton)   ((AbstractButton)menu).setIcon(new ImageIcon(presenceStatus.getStatusIcon()));
  if (menu instanceof Menu) {
    Menu theMenu=(Menu)menu;
    for (int i=0; i < theMenu.getItemCount(); i++) {
      MenuItem item=theMenu.getItem(i);
      if (item instanceof CheckboxMenuItem) {
        if (item.getLabel().equals(presenceStatus.getStatusName())) {
          ((CheckboxMenuItem)item).setState(true);
        }
 else {
          ((CheckboxMenuItem)item).setState(false);
        }
      }
    }
  }
 else   if (menu instanceof JMenu) {
    JMenu theMenu=(JMenu)menu;
    for (int i=0; i < theMenu.getItemCount(); i++) {
      JMenuItem item=theMenu.getItem(i);
      if (item instanceof JCheckBoxMenuItem) {
        if (item.getText().equals(presenceStatus.getStatusName()))         item.setSelected(true);
 else         item.setSelected(false);
      }
    }
  }
}","public void updateStatus(PresenceStatus presenceStatus){
  String presenceStatusName=presenceStatus.getStatusName();
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + provider.getAccountID().getAccountAddress() + ""String_Node_Str""+ presenceStatusName);
  }
  if (menu instanceof AbstractButton) {
    byte[] bytes=presenceStatus.getStatusIcon();
    if (bytes != null)     ((AbstractButton)menu).setIcon(new ImageIcon());
  }
  if (menu instanceof Menu) {
    Menu theMenu=(Menu)menu;
    for (int i=0, count=theMenu.getItemCount(); i < count; i++) {
      MenuItem item=theMenu.getItem(i);
      if (item instanceof CheckboxMenuItem) {
        ((CheckboxMenuItem)item).setState(item.getLabel().equals(presenceStatusName));
      }
    }
  }
 else   if (menu instanceof JMenu) {
    JMenu theMenu=(JMenu)menu;
    for (int i=0, count=theMenu.getItemCount(); i < count; i++) {
      JMenuItem item=theMenu.getItem(i);
      if (item instanceof JCheckBoxMenuItem)       item.setSelected(item.getText().equals(presenceStatusName));
    }
  }
}",0.7072835547411819
103024,"/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>String</tt> URI.
 * @param uri the address of the callee who we should invite to a new<tt>Call</tt>
 * @param calleeResource the specific resource to which the invite should besent
 * @param conference the <tt>CallConference</tt> in which the newly-created<tt>Call</tt> is to participate
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 */
public Call createCall(String uri,String calleeResource,CallConference conference) throws OperationFailedException {
  CallJabberImpl call=new CallJabberImpl(jabberTelephony);
  if (conference != null)   call.setConference(conference);
  String fullCalleeUri=(!StringUtils.isNullOrEmpty(calleeResource)) ? uri + ""String_Node_Str"" + calleeResource : uri;
  CallPeer callPeer=jabberTelephony.createOutgoingCall(call,uri,fullCalleeUri,null);
  if (callPeer == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  Call callOfCallPeer=callPeer.getCall();
  if (callOfCallPeer == call)   return call;
 else {
    if (conference != null)     callOfCallPeer.setConference(conference);
    return callOfCallPeer;
  }
}","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>String</tt> URI.
 * @param uri the address of the callee who we should invite to a new<tt>Call</tt>
 * @param calleeResource the specific resource to which the invite should besent
 * @param conference the <tt>CallConference</tt> in which the newly-created<tt>Call</tt> is to participate
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 */
public Call createCall(String uri,String calleeResource,CallConference conference) throws OperationFailedException {
  CallJabberImpl call=new CallJabberImpl(jabberTelephony);
  if (conference != null)   call.setConference(conference);
  String fullCalleeUri=StringUtils.isNullOrEmpty(calleeResource) ? uri : uri + ""String_Node_Str"" + calleeResource;
  CallPeer callPeer=jabberTelephony.createOutgoingCall(call,uri,fullCalleeUri,null);
  if (callPeer == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  Call callOfCallPeer=callPeer.getCall();
  if ((callOfCallPeer != call) && (conference != null))   callOfCallPeer.setConference(conference);
  return callOfCallPeer;
}",0.963150289017341
103025,"/** 
 * Gets the telephony conference-related state of this <tt>Call</tt>. Since a non-conference <tt>Call</tt> may be converted into a conference <tt>Call</tt> at any time, every <tt>Call</tt> instance maintains a <tt>CallConference</tt> instance regardless of whether the <tt>Call</tt> in question is participating in a telephony conference.
 * @return a <tt>CallConference</tt> instance which represents thetelephony conference-related state of this <tt>Call</tt>.
 */
public CallConference getConference(){
  if (conference == null) {
    CallConference newValue=createConference();
    if (newValue == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else     setConference(newValue);
  }
  return conference;
}","/** 
 * Gets the telephony conference-related state of this <tt>Call</tt>. Since a non-conference <tt>Call</tt> may be converted into a conference <tt>Call</tt> at any time, every <tt>Call</tt> instance maintains a <tt>CallConference</tt> instance regardless of whether the <tt>Call</tt> in question is participating in a telephony conference.
 * @return a <tt>CallConference</tt> instance which represents thetelephony conference-related state of this <tt>Call</tt>.
 */
public CallConference getConference(){
  if (conference == null) {
    CallConference newValue=createConference();
    if (newValue == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      setConference(newValue);
    }
  }
  return conference;
}",0.9932885906040269
103026,"public void callPeerAdded(CallPeerEvent ev){
  CallConference.this.onCallPeerEvent(ev);
}","@Override public void callPeerAdded(CallPeerEvent ev){
  CallConference.this.onCallPeerEvent(ev);
}",0.946808510638298
103027,"public void callPeerRemoved(CallPeerEvent ev){
  CallConference.this.onCallPeerEvent(ev);
}","@Override public void callPeerRemoved(CallPeerEvent ev){
  CallConference.this.onCallPeerEvent(ev);
}",0.9479166666666666
103028,"/** 
 * Notifies this instance that a value of a specific property of the <tt>Call</tt> of   {@link #peer} has changed from a specific old value to aspecific new value.
 * @param event a <tt>PropertyChangeEvent</tt> which specified the propertywhich had its value changed and the old and new values of that property
 */
private void callPropertyChange(PropertyChangeEvent event){
  String propertyName=event.getPropertyName();
  if (MediaAwareCall.CONFERENCE.equals(propertyName) || MediaAwareCall.DEFAULT_DEVICE.equals(propertyName)) {
    MediaAwareCall<?,?,?> call=getPeer().getCall();
    if (call == null)     return;
    for (    MediaType mediaType : MediaType.values()) {
      MediaStream stream=getStream(mediaType);
      if (stream == null)       continue;
      MediaDevice oldDevice=stream.getDevice();
      if (oldDevice != null) {
        if (oldDevice instanceof MediaDeviceWrapper) {
          oldDevice=((MediaDeviceWrapper)oldDevice).getWrappedDevice();
        }
        MediaDevice newDevice=getDefaultDevice(mediaType);
        MediaDevice newWrappedDevice=newDevice;
        if (newDevice instanceof MediaDeviceWrapper) {
          newWrappedDevice=((MediaDeviceWrapper)newDevice).getWrappedDevice();
        }
        if (oldDevice != newWrappedDevice)         stream.setDevice(newDevice);
      }
      stream.setRTPTranslator(call.getRTPTranslator(mediaType));
    }
  }
}","/** 
 * Notifies this instance that a value of a specific property of the <tt>Call</tt> of   {@link #peer} has changed from a specific old value to aspecific new value.
 * @param ev a <tt>PropertyChangeEvent</tt> which specified the propertywhich had its value changed and the old and new values of that property
 */
private void callPropertyChange(PropertyChangeEvent ev){
  String propertyName=ev.getPropertyName();
  boolean callConferenceChange=MediaAwareCall.CONFERENCE.equals(propertyName);
  if (callConferenceChange || MediaAwareCall.DEFAULT_DEVICE.equals(propertyName)) {
    MediaAwareCall<?,?,?> call=getPeer().getCall();
    if (call == null)     return;
    for (    MediaType mediaType : MediaType.values()) {
      MediaStream stream=getStream(mediaType);
      if (stream == null)       continue;
      MediaDevice oldDevice=stream.getDevice();
      if (oldDevice != null) {
        MediaDevice oldValue=(!callConferenceChange && (oldDevice instanceof MediaDeviceWrapper)) ? ((MediaDeviceWrapper)oldDevice).getWrappedDevice() : oldDevice;
        MediaDevice newDevice=getDefaultDevice(mediaType);
        MediaDevice newValue=(!callConferenceChange && (newDevice instanceof MediaDeviceWrapper)) ? ((MediaDeviceWrapper)newDevice).getWrappedDevice() : newDevice;
        if (oldValue != newValue)         stream.setDevice(newDevice);
      }
      stream.setRTPTranslator(call.getRTPTranslator(mediaType));
    }
  }
}",0.7452364149611856
103029,"/** 
 * {@inheritDoc}Notifies this instance about a <tt>PropertyChangeEvent</tt> fired by  {@link #notifier}.
 */
public void propertyChange(PropertyChangeEvent ev){
  PropertyChangeListener[] ls;
  int n;
synchronized (this) {
    Iterator<WeakReference<PropertyChangeListener>> i=listeners.iterator();
    ls=new PropertyChangeListener[listeners.size()];
    n=0;
    while (i.hasNext()) {
      PropertyChangeListener l=i.next().get();
      if (l == null)       i.remove();
 else       ls[n++]=l;
    }
    if ((n == 0) && this.added) {
      removeThisFromNotifier();
      this.added=false;
    }
  }
  if (n != 0) {
    for (    PropertyChangeListener l : ls) {
      if (l == null)       break;
 else       l.propertyChange(ev);
    }
  }
}","/** 
 * {@inheritDoc}Notifies this instance about a <tt>PropertyChangeEvent</tt> fired by  {@link #notifier}.
 */
@Override public void propertyChange(PropertyChangeEvent ev){
  PropertyChangeListener[] ls;
  int n;
synchronized (this) {
    Iterator<WeakReference<PropertyChangeListener>> i=listeners.iterator();
    ls=new PropertyChangeListener[listeners.size()];
    n=0;
    while (i.hasNext()) {
      PropertyChangeListener l=i.next().get();
      if (l == null)       i.remove();
 else       ls[n++]=l;
    }
    if ((n == 0) && this.added) {
      removeThisFromNotifier();
      this.added=false;
    }
  }
  if (n != 0) {
    for (    PropertyChangeListener l : ls) {
      if (l == null)       break;
 else       l.propertyChange(ev);
    }
  }
}",0.9933598937583
103030,"/** 
 * Removes the protocol specific group from the specified meta contact group and removes from meta contacts all proto contacts that belong to the same provider as the group which is being removed.
 * @param metaContainer the MetaContactGroup that we'd like to remove acontact group from.
 * @param groupToRemove the ContactGroup that we'd like removed.
 * @param sourceProvider the ProtocolProvider that the contact group belongsto.
 */
public void removeContactGroupFromMetaContactGroup(MetaContactGroupImpl metaContainer,ContactGroup groupToRemove,ProtocolProviderService sourceProvider){
  if (metaContainer == null) {
    return;
  }
  locallyRemoveAllContactsForProvider(metaContainer,groupToRemove);
  fireMetaContactGroupEvent(metaContainer,sourceProvider,groupToRemove,MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP);
}","/** 
 * Removes the protocol specific group from the specified meta contact group and removes from meta contacts all proto contacts that belong to the same provider as the group which is being removed.
 * @param metaContainer the MetaContactGroup that we'd like to remove acontact group from.
 * @param groupToRemove the ContactGroup that we'd like removed.
 * @param sourceProvider the ProtocolProvider that the contact group belongsto.
 */
public void removeContactGroupFromMetaContactGroup(MetaContactGroupImpl metaContainer,ContactGroup groupToRemove,ProtocolProviderService sourceProvider){
  if (metaContainer == null) {
    logger.warn(""String_Node_Str"" + groupToRemove);
    return;
  }
  locallyRemoveAllContactsForProvider(metaContainer,groupToRemove);
  fireMetaContactGroupEvent(metaContainer,sourceProvider,groupToRemove,MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP);
}",0.9701492537313432
103031,"/** 
 * Removes the specified provider from the list of currently known providers and ignores all the contacts that it has registered locally.
 * @param provider the ProtocolProviderService that has been unregistered.
 */
private void handleProviderRemoved(ProtocolProviderService provider){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + provider.getProtocolName());
  this.currentlyInstalledProviders.remove(provider.getAccountID().getAccountUniqueID());
  OperationSetPersistentPresence persPresOpSet=provider.getOperationSet(OperationSetPersistentPresence.class);
  if (persPresOpSet != null) {
    persPresOpSet.removeContactPresenceStatusListener(this);
    persPresOpSet.removeSubscriptionListener(clSubscriptionEventHandler);
    persPresOpSet.removeServerStoredGroupChangeListener(clGroupEventHandler);
    ContactGroup rootGroup=persPresOpSet.getServerStoredContactListRoot();
    Iterator<ContactGroup> subgroups=rootGroup.subgroups();
    while (subgroups.hasNext()) {
      ContactGroup group=subgroups.next();
      this.removeContactGroupFromMetaContactGroup((MetaContactGroupImpl)findMetaContactGroupByContactGroup(group),group,provider);
    }
    this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup,rootGroup,provider);
  }
  OperationSetContactCapabilities capOpSet=provider.getOperationSet(OperationSetContactCapabilities.class);
  if (capOpSet != null)   capOpSet.removeContactCapabilitiesListener(this);
}","/** 
 * Removes the specified provider from the list of currently known providers and ignores all the contacts that it has registered locally.
 * @param provider the ProtocolProviderService that has been unregistered.
 */
private void handleProviderRemoved(ProtocolProviderService provider){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + provider);
  this.currentlyInstalledProviders.remove(provider.getAccountID().getAccountUniqueID());
  OperationSetPersistentPresence persPresOpSet=provider.getOperationSet(OperationSetPersistentPresence.class);
  if (persPresOpSet != null) {
    persPresOpSet.removeContactPresenceStatusListener(this);
    persPresOpSet.removeSubscriptionListener(clSubscriptionEventHandler);
    persPresOpSet.removeServerStoredGroupChangeListener(clGroupEventHandler);
    ContactGroup rootGroup=persPresOpSet.getServerStoredContactListRoot();
    Iterator<ContactGroup> subgroups=rootGroup.subgroups();
    while (subgroups.hasNext()) {
      ContactGroup group=subgroups.next();
      this.removeContactGroupFromMetaContactGroup((MetaContactGroupImpl)findMetaContactGroupByContactGroup(group),group,provider);
    }
    this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup,rootGroup,provider);
  }
  OperationSetContactCapabilities capOpSet=provider.getOperationSet(OperationSetContactCapabilities.class);
  if (capOpSet != null)   capOpSet.removeContactCapabilitiesListener(this);
}",0.9937845303867404
103032,"/** 
 * Indicates whether some other object is ""equal to"" this group.
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null || !(obj instanceof ContactGroupJabberImpl))   return false;
  if (!((ContactGroup)obj).getGroupName().equals(getGroupName()))   return false;
  return true;
}","/** 
 * Indicates whether some other object is ""equal to"" this group.
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null || !(obj instanceof ContactGroupJabberImpl))   return false;
  if (!((ContactGroup)obj).getGroupName().equals(getGroupName()))   return false;
  if (getProtocolProvider() != ((ContactGroup)obj).getProtocolProvider())   return false;
  return true;
}",0.897003745318352
103033,"/** 
 * Creating the configuration form
 */
private void init(){
  TransparentPanel centerPanel=new TransparentPanel(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.insets=new Insets(5,10,0,0);
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=1;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=2;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=3;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.gridwidth=3;
  typeCombo=new JComboBox(ProxyInfo.ProxyType.values());
  typeCombo.setEditable(false);
  centerPanel.add(typeCombo,constraints);
  constraints.gridy=1;
  constraints.gridwidth=1;
  centerPanel.add(serverAddressField,constraints);
  constraints.gridx=2;
  constraints.weightx=0;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridx=3;
  constraints.weightx=1;
  centerPanel.add(portField,constraints);
  constraints.gridx=1;
  constraints.gridwidth=3;
  constraints.gridy=2;
  centerPanel.add(usernameField,constraints);
  constraints.gridy=3;
  centerPanel.add(passwordField,constraints);
  constraints.gridx=0;
  constraints.gridy=4;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  constraints.insets=new Insets(15,15,0,15);
  JTextPane pane=new JTextPane();
  pane.setEditable(false);
  pane.setOpaque(false);
  pane.setText(Resources.getResources().getI18NString(""String_Node_Str"",new String[]{Resources.getResources().getSettingsString(""String_Node_Str"")}));
  centerPanel.add(pane,constraints);
  constraints.gridx=0;
  constraints.gridy=6;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  constraints.insets=new Insets(20,20,20,20);
  JEditorPane table=new JEditorPane();
  table.setContentType(""String_Node_Str"");
  table.setEditable(false);
  table.setOpaque(false);
  table.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,Boolean.TRUE);
  table.setText(Resources.getString(""String_Node_Str""));
  centerPanel.add(table,constraints);
  constraints.weightx=0;
  constraints.gridx=0;
  constraints.gridy=9;
  constraints.gridwidth=4;
  constraints.gridheight=1;
  constraints.insets=new Insets(5,10,0,0);
  dnsForwardCheck.setText(Resources.getResources().getI18NString(""String_Node_Str""));
  centerPanel.add(dnsForwardCheck,constraints);
  constraints.gridy=10;
  constraints.insets=new Insets(0,38,0,0);
  String dnsForwardLabelText=Resources.getResources().getI18NString(""String_Node_Str"");
  JTextPane dnspane=new JTextPane();
  dnspane.setEditable(false);
  dnspane.setOpaque(false);
  dnspane.setText(dnsForwardLabelText);
  dnspane.setForeground(Color.GRAY);
  dnspane.setFont(dnspane.getFont().deriveFont(8));
  centerPanel.add(dnspane,constraints);
  constraints.gridy=11;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  dnsAddressPane=new TransparentPanel(new GridLayout(2,2));
  dnsAddressPane.add(new JLabel(Resources.getResources().getI18NString(""String_Node_Str"")));
  dnsAddressPane.add(dnsForwardServerAddressField);
  dnsAddressPane.add(new JLabel(Resources.getResources().getI18NString(""String_Node_Str"")));
  dnsAddressPane.add(dnsForwardPortField);
  dnsAddressPane.setVisible(false);
  centerPanel.add(dnsAddressPane,constraints);
  add(centerPanel,BorderLayout.NORTH);
  loadValues();
  serverAddressField.addKeyListener(this);
  portField.addKeyListener(this);
  usernameField.addKeyListener(this);
  passwordField.addKeyListener(this);
  typeCombo.addActionListener(this);
  dnsForwardServerAddressField.addKeyListener(this);
  dnsForwardPortField.addKeyListener(this);
  dnsForwardCheck.addActionListener(this);
}","/** 
 * Creating the configuration form
 */
private void init(){
  TransparentPanel centerPanel=new TransparentPanel(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.insets=new Insets(5,10,0,0);
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=1;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=2;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridy=3;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.gridwidth=3;
  typeCombo=new JComboBox(ProxyInfo.ProxyType.values());
  typeCombo.setEditable(false);
  centerPanel.add(typeCombo,constraints);
  constraints.gridy=1;
  constraints.gridwidth=1;
  centerPanel.add(serverAddressField,constraints);
  constraints.gridx=2;
  constraints.weightx=0;
  centerPanel.add(new JLabel(Resources.getString(""String_Node_Str"")),constraints);
  constraints.gridx=3;
  constraints.weightx=1;
  centerPanel.add(portField,constraints);
  constraints.gridx=1;
  constraints.gridwidth=3;
  constraints.gridy=2;
  centerPanel.add(usernameField,constraints);
  constraints.gridy=3;
  centerPanel.add(passwordField,constraints);
  constraints.gridx=0;
  constraints.gridy=4;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  constraints.insets=new Insets(15,15,0,15);
  JTextPane pane=new JTextPane();
  pane.setEditable(false);
  pane.setOpaque(false);
  pane.setText(Resources.getResources().getI18NString(""String_Node_Str"",new String[]{Resources.getResources().getSettingsString(""String_Node_Str"")}));
  centerPanel.add(pane,constraints);
  constraints.gridx=0;
  constraints.gridy=6;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  constraints.insets=new Insets(0,20,0,20);
  JEditorPane table=new JEditorPane();
  table.setContentType(""String_Node_Str"");
  table.setEditable(false);
  table.setOpaque(false);
  table.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,Boolean.TRUE);
  table.setText(Resources.getString(""String_Node_Str""));
  centerPanel.add(table,constraints);
  constraints.weightx=0;
  constraints.gridx=0;
  constraints.gridy=9;
  constraints.gridwidth=4;
  constraints.gridheight=1;
  constraints.insets=new Insets(5,10,0,0);
  dnsForwardCheck.setText(Resources.getResources().getI18NString(""String_Node_Str""));
  centerPanel.add(dnsForwardCheck,constraints);
  constraints.gridy=10;
  constraints.insets=new Insets(0,38,0,0);
  String dnsForwardLabelText=Resources.getResources().getI18NString(""String_Node_Str"");
  JTextPane dnspane=new JTextPane();
  dnspane.setEditable(false);
  dnspane.setOpaque(false);
  dnspane.setText(dnsForwardLabelText);
  dnspane.setForeground(Color.GRAY);
  dnspane.setFont(dnspane.getFont().deriveFont(8));
  centerPanel.add(dnspane,constraints);
  constraints.gridy=11;
  constraints.gridwidth=4;
  constraints.gridheight=2;
  dnsAddressPane=new TransparentPanel(new GridLayout(2,2));
  dnsAddressPane.add(new JLabel(Resources.getResources().getI18NString(""String_Node_Str"")));
  dnsAddressPane.add(dnsForwardServerAddressField);
  dnsAddressPane.add(new JLabel(Resources.getResources().getI18NString(""String_Node_Str"")));
  dnsAddressPane.add(dnsForwardPortField);
  dnsAddressPane.setVisible(false);
  centerPanel.add(dnsAddressPane,constraints);
  add(centerPanel,BorderLayout.NORTH);
  loadValues();
  serverAddressField.addKeyListener(this);
  portField.addKeyListener(this);
  usernameField.addKeyListener(this);
  passwordField.addKeyListener(this);
  typeCombo.addActionListener(this);
  dnsForwardServerAddressField.addKeyListener(this);
  dnsForwardPortField.addKeyListener(this);
  dnsForwardCheck.addActionListener(this);
}",0.999753937007874
103034,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(okButton)) {
    if ((chatRoomNameField.getText() != null && chatRoomNameField.getText().trim().length() > 0) && (nicknameField.getText() != null && nicknameField.getText().trim().length() > 0)) {
      ChatRoomWrapper chatRoomWrapper=GuiActivator.getMUCService().createChatRoom(chatRoomNameField.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,false);
      String nickName=nicknameField.getText().trim();
      ConfigurationUtils.updateChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"",nickName);
      subject=this.subject.getText();
      if (nickName == null)       return;
      GuiActivator.getMUCService().joinChatRoom(chatRoomWrapper,nickName,null,subject);
      ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
      ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
      chatWindowManager.openChat(chatPanel,true);
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
 else   if (sourceButton.equals(listButton)) {
    if (serverChatRoomsChoiceDialog == null) {
      serverChatRoomsChoiceDialog=new ServerChatRoomsChoiceDialog(getTitle(),getSelectedProvider());
    }
    serverChatRoomsChoiceDialog.setVisible(true);
  }
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(okButton)) {
    if ((chatRoomNameField.getText() != null && chatRoomNameField.getText().trim().length() > 0) && (nicknameField.getText() != null && nicknameField.getText().trim().length() > 0)) {
      ChatRoomWrapper chatRoomWrapper=GuiActivator.getMUCService().createChatRoom(chatRoomNameField.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,false);
      String nickName=nicknameField.getText().trim();
      if (!chatRoomWrapper.isPersistent()) {
        chatRoomWrapper.setPersistent(true);
        ConfigurationUtils.saveChatRoom(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),chatRoomWrapper.getChatRoomID(),chatRoomWrapper.getChatRoomName());
      }
      ConfigurationUtils.updateChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"",nickName);
      subject=this.subject.getText();
      if (nickName == null)       return;
      GuiActivator.getMUCService().joinChatRoom(chatRoomWrapper,nickName,null,subject);
      ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
      ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
      chatWindowManager.openChat(chatPanel,true);
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
 else   if (sourceButton.equals(listButton)) {
    if (serverChatRoomsChoiceDialog == null) {
      serverChatRoomsChoiceDialog=new ServerChatRoomsChoiceDialog(getTitle(),getSelectedProvider());
    }
    serverChatRoomsChoiceDialog.setVisible(true);
  }
}",0.9164313946922644
103035,"/** 
 * Cleans the contactsMap when <tt>ProtocolProviderService</tt> gets unregistered.
 */
public void serviceChanged(ServiceEvent ev){
  Object service=OtrActivator.bundleContext.getService(ev.getServiceReference());
  if (!(service instanceof ProtocolProviderService))   return;
  if (ev.getType() == ServiceEvent.UNREGISTERING) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    ProtocolProviderService provider=(ProtocolProviderService)service;
synchronized (contactsMap) {
      Iterator<Contact> i=contactsMap.values().iterator();
      while (i.hasNext()) {
        if (provider.equals(i.next().getProtocolProvider()))         i.remove();
      }
    }
    Iterator<Contact> i=progressDialogMap.keySet().iterator();
    while (i.hasNext()) {
      if (provider.equals(i.next().getProtocolProvider()))       i.remove();
    }
  }
}","/** 
 * Cleans the contactsMap when <tt>ProtocolProviderService</tt> gets unregistered.
 */
public void serviceChanged(ServiceEvent ev){
  Object service=OtrActivator.bundleContext.getService(ev.getServiceReference());
  if (!(service instanceof ProtocolProviderService))   return;
  if (ev.getType() == ServiceEvent.UNREGISTERING) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    ProtocolProviderService provider=(ProtocolProviderService)service;
synchronized (contactsMap) {
      Iterator<Contact> i=contactsMap.values().iterator();
      while (i.hasNext()) {
        Contact contact=i.next();
        if (provider.equals(contact.getProtocolProvider())) {
          scSessionStatusMap.remove(getSessionID(contact));
          i.remove();
        }
      }
    }
    Iterator<Contact> i=progressDialogMap.keySet().iterator();
    while (i.hasNext()) {
      if (provider.equals(i.next().getProtocolProvider()))       i.remove();
    }
    scheduler.serviceChanged(ev);
  }
}",0.8880195599022005
103036,"/** 
 * Creates an instance of <tt>ConferenceChatSession</tt>, by specifying the sessionRenderer to be used for communication with the UI and the chatRoom corresponding to this conference session.
 * @param sessionRenderer the renderer to be used for communication with theUI.
 * @param chatRoomWrapper the chat room corresponding to this conferencesession.
 */
public ConferenceChatSession(ChatSessionRenderer sessionRenderer,ChatRoomWrapper chatRoomWrapper){
  this.sessionRenderer=sessionRenderer;
  this.chatRoomWrapper=chatRoomWrapper;
  currentChatTransport=new ConferenceChatTransport(this,chatRoomWrapper.getChatRoom());
  chatTransports.add(currentChatTransport);
  this.initChatParticipants();
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  chatRoom.addMemberPresenceListener(this);
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addConferencePublishedListener(this);
}","/** 
 * Creates an instance of <tt>ConferenceChatSession</tt>, by specifying the sessionRenderer to be used for communication with the UI and the chatRoom corresponding to this conference session.
 * @param sessionRenderer the renderer to be used for communication with theUI.
 * @param chatRoomWrapper the chat room corresponding to this conferencesession.
 */
public ConferenceChatSession(ChatSessionRenderer sessionRenderer,ChatRoomWrapper chatRoomWrapper){
  this.sessionRenderer=sessionRenderer;
  this.chatRoomWrapper=chatRoomWrapper;
  currentChatTransport=new ConferenceChatTransport(this,chatRoomWrapper.getChatRoom());
  chatTransports.add(currentChatTransport);
synchronized (this.chatParticipants) {
    this.initChatParticipants();
  }
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  chatRoom.addMemberPresenceListener(this);
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addConferencePublishedListener(this);
}",0.9754232659748772
103037,"/** 
 * Initializes the list of participants.
 */
private void initChatParticipants(){
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  if ((chatRoom != null) && chatRoom.isJoined())   for (  ChatRoomMember member : chatRoom.getMembers())   chatParticipants.add(new ConferenceChatContact(member));
}","/** 
 * Initializes the list of participants.(It is assumed that <tt>chatParticipants</tt> is locked.)
 */
private void initChatParticipants(){
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  if ((chatRoom != null) && chatRoom.isJoined())   for (  ChatRoomMember member : chatRoom.getMembers())   chatParticipants.add(new ConferenceChatContact(member));
}",0.9140271493212668
103038,"/** 
 * Loads the given chat room in the this chat conference panel. Loads all members and adds all corresponding listeners.
 * @param chatRoom the <tt>ChatRoom</tt> to load
 */
public void loadChatRoom(ChatRoom chatRoom){
  currentChatTransport=new ConferenceChatTransport(this,chatRoomWrapper.getChatRoom());
  chatTransports.clear();
  chatTransports.add(currentChatTransport);
  sessionRenderer.removeAllChatContacts();
  for (  ChatRoomMember member : chatRoom.getMembers()) {
    sessionRenderer.addChatContact(new ConferenceChatContact(member));
  }
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addMemberPresenceListener(this);
  sessionRenderer.setChatSubject(chatRoom.getSubject());
}","/** 
 * Loads the given chat room in the this chat conference panel. Loads all members and adds all corresponding listeners.
 * @param chatRoom the <tt>ChatRoom</tt> to load
 */
public void loadChatRoom(ChatRoom chatRoom){
  currentChatTransport=new ConferenceChatTransport(this,chatRoomWrapper.getChatRoom());
  chatTransports.clear();
  chatTransports.add(currentChatTransport);
synchronized (this.chatParticipants) {
    sessionRenderer.removeAllChatContacts();
    this.chatParticipants.clear();
    for (    ChatRoomMember member : chatRoom.getMembers()) {
      ConferenceChatContact contact=new ConferenceChatContact(member);
      chatParticipants.add(contact);
      sessionRenderer.addChatContact(contact);
    }
  }
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addMemberPresenceListener(this);
  sessionRenderer.setChatSubject(chatRoom.getSubject());
}",0.850253807106599
103039,"/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(final ChatRoomMemberPresenceChangeEvent evt){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        memberPresenceChanged(evt);
      }
    }
);
    return;
  }
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
synchronized (chatParticipants) {
      if (!chatParticipants.contains(chatContact))       chatParticipants.add(chatContact);
      sessionRenderer.addChatContact(chatContact);
    }
    ChatRoom room=chatRoomWrapper.getChatRoom();
    if (room != null) {
      room.updatePrivateContactPresenceStatus(chatRoomMember.getName());
    }
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact<?> chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        ChatRoom room=chatRoomWrapper.getChatRoom();
        if (room != null) {
          room.updatePrivateContactPresenceStatus(chatRoomMember.getName());
        }
        break;
      }
    }
  }
}","/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(final ChatRoomMemberPresenceChangeEvent evt){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        memberPresenceChanged(evt);
      }
    }
);
    return;
  }
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
synchronized (chatParticipants) {
      if (!chatParticipants.contains(chatContact))       chatParticipants.add(chatContact);
      sessionRenderer.addChatContact(chatContact);
    }
    ChatRoom room=chatRoomWrapper.getChatRoom();
    if (room != null) {
      room.updatePrivateContactPresenceStatus(chatRoomMember.getName());
    }
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    ChatContact<?> contact=null;
    for (    ChatContact<?> chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        contact=chatContact;
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        ChatRoom room=chatRoomWrapper.getChatRoom();
        if (room != null) {
          room.updatePrivateContactPresenceStatus(chatRoomMember.getName());
        }
        break;
      }
    }
    if (contact != null) {
synchronized (chatParticipants) {
        chatParticipants.remove(contact);
      }
    }
  }
}",0.9675613370657008
103040,"public ContactSearchFieldUI(){
  String callButtonEnabledString=UtilActivator.getResources().getSettingsString(""String_Node_Str"");
  if ((callButtonEnabledString != null) && (callButtonEnabledString.length() > 0)) {
    isCallButtonEnabled=!Boolean.parseBoolean(callButtonEnabledString);
  }
  loadSkin();
}","public ContactSearchFieldUI(){
  String callButtonEnabledString=UtilActivator.getResources().getSettingsString(""String_Node_Str"");
  if ((callButtonEnabledString != null) && (callButtonEnabledString.length() > 0)) {
    setCallButtonEnabled(!Boolean.parseBoolean(callButtonEnabledString));
  }
  loadSkin();
}",0.987012987012987
103041,"/** 
 * Paints the background of the associated component.
 * @param g the <tt>Graphics</tt> object used for painting
 */
@Override protected void customPaintBackground(Graphics g){
  isCallButtonEnabled=CallManager.getTelephonyProviders().size() > 0;
  setSMSButtonEnabled(GuiActivator.getUIService().getMainFrame().hasOperationSet(OperationSetSmsMessaging.class));
  super.customPaintBackground(g);
}","/** 
 * Paints the background of the associated component.
 * @param g the <tt>Graphics</tt> object used for painting
 */
@Override protected void customPaintBackground(Graphics g){
  setSMSButtonEnabled(GuiActivator.getUIService().getMainFrame().hasOperationSet(OperationSetSmsMessaging.class));
  super.customPaintBackground(g);
}",0.888283378746594
103042,"/** 
 * Creates the <tt>SearchField</tt>.
 * @param frame the main application window
 * @param searchFilter the filter to apply on search
 * @param isCallButtonEnabled indicates if the call button should beenabled in this search field
 */
public SearchField(MainFrame frame,ContactListSearchFilter searchFilter,boolean isCallButtonEnabled){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=frame;
  this.searchFilter=searchFilter;
  if (getUI() instanceof ContactSearchFieldUI) {
    ((ContactSearchFieldUI)getUI()).setDeleteButtonEnabled(true);
    ((ContactSearchFieldUI)getUI()).setCallButtonEnabled(isCallButtonEnabled);
  }
  this.setBorder(null);
  this.setOpaque(false);
  this.setDragEnabled(true);
  this.addTextChangeListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      if (SearchField.this.mainFrame != null)       SearchField.this.mainFrame.requestFocusInContactList();
    }
  }
);
  loadSkin();
}","/** 
 * Creates the <tt>SearchField</tt>.
 * @param frame the main application window
 * @param searchFilter the filter to apply on search
 * @param isCallButtonEnabled indicates if the call button should beenabled in this search field
 */
public SearchField(MainFrame frame,ContactListSearchFilter searchFilter,boolean isCallButtonEnabled){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=frame;
  this.searchFilter=searchFilter;
  if (getUI() instanceof ContactSearchFieldUI) {
    ((ContactSearchFieldUI)getUI()).setupListeners();
    ((ContactSearchFieldUI)getUI()).setDeleteButtonEnabled(true);
    ((ContactSearchFieldUI)getUI()).setCallButtonEnabled(isCallButtonEnabled);
  }
  this.setBorder(null);
  this.setOpaque(false);
  this.setDragEnabled(true);
  this.addTextChangeListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      if (SearchField.this.mainFrame != null)       SearchField.this.mainFrame.requestFocusInContactList();
    }
  }
);
  loadSkin();
}",0.9787066246056784
103043,"/** 
 * Paints the background of the associated component.
 * @param g the <tt>Graphics</tt> object used for painting
 */
@Override protected void customPaintBackground(Graphics g){
  Graphics2D g2=(Graphics2D)g.create();
  try {
    AntialiasingManager.activateAntialiasing(g2);
    super.customPaintBackground(g2);
    JTextComponent c=this.getComponent();
    int dy=(c.getY() + c.getHeight()) / 2 - searchIcon.getIconHeight() / 2;
    g2.drawImage(searchIcon.getImage(),3,dy,null);
    if (c.getText() != null && c.getText().length() > 0 && isSMSButtonEnabled) {
      Rectangle smsRect=getSMSButtonRect();
      int dx=smsRect.x;
      dy=smsRect.y;
      if (isSMSMousePressed)       g2.drawImage(smsPressedIcon,dx,dy,null);
 else       if (isSMSMouseOver) {
        g2.drawImage(smsRolloverIcon,dx,dy,null);
      }
 else       g2.drawImage(smsIcon,dx,dy,null);
      isSMSIconVisible=true;
    }
 else     isSMSIconVisible=false;
    if (c.getText() != null && c.getText().length() > 0 && isCallButtonEnabled) {
      Rectangle callRect=getCallButtonRect();
      int dx=callRect.x;
      dy=callRect.y;
      if (isCallMousePressed)       g2.drawImage(callPressedIcon,dx,dy,null);
 else       if (isCallMouseOver)       g2.drawImage(callRolloverIcon,dx,dy,null);
 else       g2.drawImage(callIcon,dx,dy,null);
      g2.drawImage(separatorIcon,dx + callRect.width + 3,dy + (callRect.height - separatorIcon.getHeight(null)) / 2,null);
      isCallIconVisible=true;
    }
 else     isCallIconVisible=false;
  }
  finally {
    g2.dispose();
  }
}","/** 
 * Paints the background of the associated component.
 * @param g the <tt>Graphics</tt> object used for painting
 */
@Override protected void customPaintBackground(Graphics g){
  Graphics2D g2=(Graphics2D)g.create();
  try {
    AntialiasingManager.activateAntialiasing(g2);
    super.customPaintBackground(g2);
    JTextComponent c=this.getComponent();
    int dy=c.getHeight() / 2 - searchIcon.getIconHeight() / 2;
    g2.drawImage(searchIcon.getImage(),3,dy,null);
    if (c.getText() != null && c.getText().length() > 0 && isSMSButtonEnabled) {
      Rectangle smsRect=getSMSButtonRect();
      int dx=smsRect.x;
      dy=smsRect.y;
      if (isSMSMousePressed)       g2.drawImage(smsPressedIcon,dx,dy,null);
 else       if (isSMSMouseOver) {
        g2.drawImage(smsRolloverIcon,dx,dy,null);
      }
 else       g2.drawImage(smsIcon,dx,dy,null);
      isSMSIconVisible=true;
    }
 else     isSMSIconVisible=false;
    if (c.getText() != null && c.getText().length() > 0 && isCallButtonEnabled) {
      Rectangle callRect=getCallButtonRect();
      int dx=callRect.x;
      dy=callRect.y;
      if (isCallMousePressed)       g2.drawImage(callPressedIcon,dx,dy,null);
 else       if (isCallMouseOver)       g2.drawImage(callRolloverIcon,dx,dy,null);
 else       g2.drawImage(callIcon,dx,dy,null);
      g2.drawImage(separatorIcon,dx + callRect.width + 3,dy + (callRect.height - separatorIcon.getHeight(null)) / 2,null);
      isCallIconVisible=true;
    }
 else     isCallIconVisible=false;
  }
  finally {
    g2.dispose();
  }
}",0.9957942413458428
103044,"/** 
 * Calculates the call button rectangle.
 * @return the call button rectangle
 */
protected Rectangle getCallButtonRect(){
  Component c=getComponent();
  Rectangle rect=c.getBounds();
  int dx=getDeleteButtonRect().x - callRolloverIcon.getWidth(null) - 8;
  int dy=(rect.y + rect.height) / 2 - callRolloverIcon.getHeight(null) / 2;
  return new Rectangle(dx,dy,callRolloverIcon.getWidth(null),callRolloverIcon.getHeight(null));
}","/** 
 * Calculates the call button rectangle.
 * @return the call button rectangle
 */
protected Rectangle getCallButtonRect(){
  Component c=getComponent();
  Rectangle rect=c.getBounds();
  int dx=getDeleteButtonRect().x - callRolloverIcon.getWidth(null) - 8;
  int dy=(rect.height) / 2 - callRolloverIcon.getHeight(null) / 2;
  return new Rectangle(dx,dy,callRolloverIcon.getWidth(null),callRolloverIcon.getHeight(null));
}",0.989547038327526
103045,"/** 
 * Enables/disabled the call button in the search field.
 * @param isEnabled indicates if the call button is enabled
 */
public void setCallButtonEnabled(boolean isEnabled){
  this.isCallButtonEnabled=isEnabled;
}","/** 
 * Enables/disabled the call button in the search field.
 * @param isEnabled indicates if the call button is enabled
 */
public void setCallButtonEnabled(boolean isEnabled){
  JTextComponent c=this.getComponent();
  if (isCallButtonEnabled != isEnabled) {
    this.isCallButtonEnabled=isEnabled;
    loadSkin();
    if (c != null && c.isVisible())     c.repaint();
  }
}",0.718381112984823
103046,"/** 
 * Gets the SSRCs of RTP streams with a specific <tt>MediaType</tt> known to be received by a <tt>MediaStream</tt> associated with this instance. <p> <b>Warning</b>: The method may return only one of the many possible remote SSRCs in the case of no utilization of the Jitsi Videobridge server-side technology because the super implementation does not currently provide support for keeping track of multiple remote SSRCs. </p>
 * @param mediaType the <tt>MediaType</tt> of the RTP streams the SSRCs ofwhich are to be returned
 * @return an array of <tt>long</tt> values which represent the SSRCs of RTPstreams with the specified <tt>mediaType</tt> known to be received by a <tt>MediaStream</tt> associated with this instance
 */
public long[] getRemoteSSRCs(MediaType mediaType){
  ColibriConferenceIQ.Channel channel=getColibriChannel(mediaType);
  if (channel != null)   return channel.getSSRCs();
  long ssrc=super.getRemoteSSRC(mediaType);
  return (ssrc == SSRC_UNKNOWN) ? ColibriConferenceIQ.NO_SSRCS : new long[]{ssrc};
}","/** 
 * Gets the SSRCs of RTP streams with a specific <tt>MediaType</tt> known to be received by a <tt>MediaStream</tt> associated with this instance. <p> <b>Warning</b>: The method may return only one of the many possible remote SSRCs in the case of no utilization of the Jitsi Videobridge server-side technology because the super implementation does not currently provide support for keeping track of multiple remote SSRCs. </p>
 * @param mediaType the <tt>MediaType</tt> of the RTP streams the SSRCs ofwhich are to be returned
 * @return an array of <tt>int</tt> values which represent the SSRCs of RTPstreams with the specified <tt>mediaType</tt> known to be received by a <tt>MediaStream</tt> associated with this instance
 */
private int[] getRemoteSSRCs(MediaType mediaType){
  ColibriConferenceIQ.Channel channel=getColibriChannel(mediaType);
  if (channel != null)   return channel.getSSRCs();
  long ssrc=super.getRemoteSSRC(mediaType);
  return (ssrc == SSRC_UNKNOWN) ? ColibriConferenceIQ.NO_SSRCS : new int[]{(int)ssrc};
}",0.981132075471698
103047,"/** 
 * {@inheritDoc}In the case of a telephony conference organized by the local peer/user via the Jitsi Videobridge server-side technology, returns an SSRC reported by the server as received on the channel allocated by the local peer/user for the purposes of communicating with the <tt>CallPeer</tt> associated with this instance.
 */
@Override public long getRemoteSSRC(MediaType mediaType){
  long[] ssrcs=getRemoteSSRCs(mediaType);
  for (int i=ssrcs.length - 1; i >= 0; i--) {
    long ssrc=ssrcs[i];
    if (ssrc != SSRC_UNKNOWN)     return ssrc;
  }
  return getPeer().isJitsiVideobridge() ? SSRC_UNKNOWN : super.getRemoteSSRC(mediaType);
}","/** 
 * {@inheritDoc}In the case of a telephony conference organized by the local peer/user via the Jitsi Videobridge server-side technology, returns an SSRC reported by the server as received on the channel allocated by the local peer/user for the purposes of communicating with the <tt>CallPeer</tt> associated with this instance.
 */
@Override public long getRemoteSSRC(MediaType mediaType){
  int[] ssrcs=getRemoteSSRCs(mediaType);
  if (ssrcs.length != 0)   return 0xFFFFFFFFL & ssrcs[ssrcs.length - 1];
  return getPeer().isJitsiVideobridge() ? SSRC_UNKNOWN : super.getRemoteSSRC(mediaType);
}",0.8179631114675221
103048,"/** 
 * {@inheritDoc}In the case of utilization of the Jitsi Videobridge server-side technology, returns the visual <tt>Component</tt>s which display RTP video streams reported by the server to be sent by the remote peer represented by this instance.
 */
@Override public List<Component> getVisualComponents(){
  CallJabberImpl call;
  MediaAwareCallConference conference;
  if (((call=getPeer().getCall()) != null) && ((conference=call.getConference()) != null) && conference.isJitsiVideobridge()) {
    MediaStream stream=getStream(MediaType.VIDEO);
    if (stream == null)     return Collections.emptyList();
 else {
      long[] remoteSSRCs=getRemoteSSRCs(MediaType.VIDEO);
      if (remoteSSRCs.length == 0)       return Collections.emptyList();
 else {
        VideoMediaStream videoStream=(VideoMediaStream)stream;
        List<Component> visualComponents=new LinkedList<Component>();
        for (        long remoteSSRC : remoteSSRCs) {
          if (remoteSSRC != -1) {
            Component visualComponent=videoStream.getVisualComponent(remoteSSRC);
            if (visualComponent != null)             visualComponents.add(visualComponent);
          }
        }
        return visualComponents;
      }
    }
  }
  return super.getVisualComponents();
}","/** 
 * {@inheritDoc}In the case of utilization of the Jitsi Videobridge server-side technology, returns the visual <tt>Component</tt>s which display RTP video streams reported by the server to be sent by the remote peer represented by this instance.
 */
@Override public List<Component> getVisualComponents(){
  CallJabberImpl call;
  MediaAwareCallConference conference;
  if (((call=getPeer().getCall()) != null) && ((conference=call.getConference()) != null) && conference.isJitsiVideobridge()) {
    MediaStream stream=getStream(MediaType.VIDEO);
    if (stream == null)     return Collections.emptyList();
 else {
      int[] remoteSSRCs=getRemoteSSRCs(MediaType.VIDEO);
      if (remoteSSRCs.length == 0)       return Collections.emptyList();
 else {
        VideoMediaStream videoStream=(VideoMediaStream)stream;
        List<Component> visualComponents=new LinkedList<Component>();
        for (int i=0; i < remoteSSRCs.length; i++) {
          int remoteSSRC=remoteSSRCs[i];
          Component visualComponent=videoStream.getVisualComponent(0xFFFFFFFFL & remoteSSRC);
          if (visualComponent != null)           visualComponents.add(visualComponent);
        }
        return visualComponents;
      }
    }
  }
  return super.getVisualComponents();
}",0.941966048164232
103049,"/** 
 * Notifies this instance that a specific <tt>ColibriConferenceIQ</tt> has been received. This <tt>CallPeerMediaHandler</tt> uses the part of the information provided in the specified <tt>conferenceIQ</tt> which concerns it only.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> which has beenreceived
 */
void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){
  TransportManagerJabberImpl transportManager=this.transportManager;
  if (transportManager != null) {
    long oldAudioRemoteSSRC=getRemoteSSRC(MediaType.AUDIO);
    long oldVideoRemoteSSRC=getRemoteSSRC(MediaType.VIDEO);
    for (    MediaType mediaType : MediaType.values()) {
      ColibriConferenceIQ.Channel dst=transportManager.getColibriChannel(mediaType,false);
      if (dst != null) {
        ColibriConferenceIQ.Content content=conferenceIQ.getContent(mediaType.toString());
        if (content != null) {
          ColibriConferenceIQ.Channel src=content.getChannel(dst.getID());
          if (src != null) {
            long[] ssrcs=src.getSSRCs();
            long[] dstSsrcs=dst.getSSRCs();
            if (!Arrays.equals(dstSsrcs,ssrcs)) {
              dst.setSSRCs(ssrcs);
              if (logger.isDebugEnabled()) {
                logger.debug(""String_Node_Str"" + mediaType.toString() + ""String_Node_Str""+ dst.getID()+ ""String_Node_Str""+ Arrays.toString(dstSsrcs)+ ""String_Node_Str""+ Arrays.toString(ssrcs));
              }
            }
          }
        }
      }
    }
    long newAudioRemoteSSRC=getRemoteSSRC(MediaType.AUDIO);
    long newVideoRemoteSSRC=getRemoteSSRC(MediaType.VIDEO);
    if (oldAudioRemoteSSRC != newAudioRemoteSSRC) {
      firePropertyChange(AUDIO_REMOTE_SSRC,oldAudioRemoteSSRC,newAudioRemoteSSRC);
    }
    if (oldVideoRemoteSSRC != newVideoRemoteSSRC) {
      firePropertyChange(VIDEO_REMOTE_SSRC,oldVideoRemoteSSRC,newVideoRemoteSSRC);
    }
  }
}","/** 
 * Notifies this instance that a specific <tt>ColibriConferenceIQ</tt> has been received. This <tt>CallPeerMediaHandler</tt> uses the part of the information provided in the specified <tt>conferenceIQ</tt> which concerns it only.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> which has beenreceived
 */
void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){
  TransportManagerJabberImpl transportManager=this.transportManager;
  if (transportManager != null) {
    long oldAudioRemoteSSRC=getRemoteSSRC(MediaType.AUDIO);
    long oldVideoRemoteSSRC=getRemoteSSRC(MediaType.VIDEO);
    for (    MediaType mediaType : MediaType.values()) {
      ColibriConferenceIQ.Channel dst=transportManager.getColibriChannel(mediaType,false);
      if (dst != null) {
        ColibriConferenceIQ.Content content=conferenceIQ.getContent(mediaType.toString());
        if (content != null) {
          ColibriConferenceIQ.Channel src=content.getChannel(dst.getID());
          if (src != null) {
            int[] ssrcs=src.getSSRCs();
            int[] dstSSRCs=dst.getSSRCs();
            if (!Arrays.equals(dstSSRCs,ssrcs))             dst.setSSRCs(ssrcs);
          }
        }
      }
    }
    long newAudioRemoteSSRC=getRemoteSSRC(MediaType.AUDIO);
    long newVideoRemoteSSRC=getRemoteSSRC(MediaType.VIDEO);
    if (oldAudioRemoteSSRC != newAudioRemoteSSRC) {
      firePropertyChange(AUDIO_REMOTE_SSRC,oldAudioRemoteSSRC,newAudioRemoteSSRC);
    }
    if (oldVideoRemoteSSRC != newVideoRemoteSSRC) {
      firePropertyChange(VIDEO_REMOTE_SSRC,oldVideoRemoteSSRC,newVideoRemoteSSRC);
    }
  }
}",0.9146445903511276
103050,"/** 
 * Gets the <tt>direction</tt> of this <tt>Channel</tt>.
 * @return the <tt>direction</tt> of this <tt>Channel</tt>.
 */
public MediaDirection getDirection(){
  return direction == null ? MediaDirection.SENDRECV : direction;
}","/** 
 * Gets the <tt>direction</tt> of this <tt>Channel</tt>.
 * @return the <tt>direction</tt> of this <tt>Channel</tt>.
 */
public MediaDirection getDirection(){
  return (direction == null) ? MediaDirection.SENDRECV : direction;
}",0.9956896551724138
103051,"/** 
 * Sets the list of (RTP) SSRCs seen/received on this <tt>Channel</tt>.
 * @param ssrcs the list of (RTP) SSRCs to be set as seen/received onthis <tt>Channel</tt>
 */
public void setSSRCs(long[] ssrcs){
  this.ssrcs=((ssrcs == null) || (ssrcs.length == 0)) ? NO_SSRCS : ssrcs.clone();
}","/** 
 * Sets the list of (RTP) SSRCs seen/received on this <tt>Channel</tt>.
 * @param ssrcs the list of (RTP) SSRCs to be set as seen/received onthis <tt>Channel</tt>
 */
public void setSSRCs(int[] ssrcs){
  this.ssrcs=((ssrcs == null) || (ssrcs.length == 0)) ? NO_SSRCS : ssrcs.clone();
}",0.9879518072289156
103052,"/** 
 * Removes a specific (RTP) SSRC from the list of SSRCs seen/received on this <tt>Channel</tt>. Invoked by the Jitsi Videobridge server, not its clients.
 * @param ssrc the (RTP) SSRC to be removed from the list of SSRCsseen/received on this <tt>Channel</tt>
 * @return <tt>true</tt> if the list of SSRCs seen/received on this<tt>Channel</tt> has been modified as part of the method call; otherwise, <tt>false</tt>
 */
public synchronized boolean removeSSRC(long ssrc){
  if (ssrcs.length == 1) {
    if (ssrcs[0] == ssrc) {
      ssrcs=NO_SSRCS;
      return true;
    }
 else     return false;
  }
 else {
    for (int i=0; i < ssrcs.length; i++) {
      if (ssrcs[i] == ssrc) {
        long[] newSSRCs=new long[ssrcs.length - 1];
        if (i != 0)         System.arraycopy(ssrcs,0,newSSRCs,0,i);
        if (i != newSSRCs.length) {
          System.arraycopy(ssrcs,i + 1,newSSRCs,i,newSSRCs.length - i);
        }
        ssrcs=newSSRCs;
        return true;
      }
    }
    return false;
  }
}","/** 
 * Removes a specific (RTP) SSRC from the list of SSRCs seen/received on this <tt>Channel</tt>. Invoked by the Jitsi Videobridge server, not its clients.
 * @param ssrc the (RTP) SSRC to be removed from the list of SSRCsseen/received on this <tt>Channel</tt>
 * @return <tt>true</tt> if the list of SSRCs seen/received on this<tt>Channel</tt> has been modified as part of the method call; otherwise, <tt>false</tt>
 */
public synchronized boolean removeSSRC(int ssrc){
  if (ssrcs.length == 1) {
    if (ssrcs[0] == ssrc) {
      ssrcs=NO_SSRCS;
      return true;
    }
 else     return false;
  }
 else {
    for (int i=0; i < ssrcs.length; i++) {
      if (ssrcs[i] == ssrc) {
        int[] newSSRCs=new int[ssrcs.length - 1];
        if (i != 0)         System.arraycopy(ssrcs,0,newSSRCs,0,i);
        if (i != newSSRCs.length) {
          System.arraycopy(ssrcs,i + 1,newSSRCs,i,newSSRCs.length - i);
        }
        ssrcs=newSSRCs;
        return true;
      }
    }
    return false;
  }
}",0.989547038327526
103053,"/** 
 * Gets (a copy of) the list of (RTP) SSRCs seen/received on this <tt>Channel</tt>.
 * @return an array of <tt>long</tt>s which represents (a copy of) thelist of (RTP) SSRCs seen/received on this <tt>Channel</tt>
 */
public synchronized long[] getSSRCs(){
  return (ssrcs.length == 0) ? NO_SSRCS : ssrcs.clone();
}","/** 
 * Gets (a copy of) the list of (RTP) SSRCs seen/received on this <tt>Channel</tt>.
 * @return an array of <tt>int</tt>s which represents (a copy of) thelist of (RTP) SSRCs seen/received on this <tt>Channel</tt>
 */
public synchronized int[] getSSRCs(){
  return (ssrcs.length == 0) ? NO_SSRCS : ssrcs.clone();
}",0.9779874213836478
103054,"/** 
 * Adds a specific (RTP) SSRC to the list of SSRCs seen/received on this <tt>Channel</tt>. Invoked by the Jitsi Videobridge server, not its clients.
 * @param ssrc the (RTP) SSRC to be added to the list of SSRCsseen/received on this <tt>Channel</tt>
 * @return <tt>true</tt> if the list of SSRCs seen/received on this<tt>Channel</tt> has been modified as part of the method call; otherwise, <tt>false</tt>
 */
public synchronized boolean addSSRC(long ssrc){
  for (  long element : ssrcs)   if (element == ssrc)   return false;
  long[] newSSRCs=new long[ssrcs.length + 1];
  System.arraycopy(ssrcs,0,newSSRCs,0,ssrcs.length);
  newSSRCs[ssrcs.length]=ssrc;
  ssrcs=newSSRCs;
  return true;
}","/** 
 * Adds a specific (RTP) SSRC to the list of SSRCs seen/received on this <tt>Channel</tt>. Invoked by the Jitsi Videobridge server, not its clients.
 * @param ssrc the (RTP) SSRC to be added to the list of SSRCsseen/received on this <tt>Channel</tt>
 * @return <tt>true</tt> if the list of SSRCs seen/received on this<tt>Channel</tt> has been modified as part of the method call; otherwise, <tt>false</tt>
 */
public synchronized boolean addSSRC(int ssrc){
  for (int i=0; i < ssrcs.length; i++)   if (ssrcs[i] == ssrc)   return false;
  int[] newSSRCs=new int[ssrcs.length + 1];
  System.arraycopy(ssrcs,0,newSSRCs,0,ssrcs.length);
  newSSRCs[ssrcs.length]=ssrc;
  ssrcs=newSSRCs;
  return true;
}",0.94
103055,"/** 
 * Parses an IQ sub-document and creates an <tt>org.jivesoftware.smack.packet.IQ</tt> instance.
 * @param parser an <tt>XmlPullParser</tt> which specifies the IQsub-document to be parsed into a new <tt>IQ</tt> instance
 * @return a new <tt>IQ</tt> instance parsed from the specified IQsub-document
 * @see IQProvider#parseIQ(XmlPullParser)
 */
@SuppressWarnings(""String_Node_Str"") public IQ parseIQ(XmlPullParser parser) throws Exception {
  String namespace=parser.getNamespace();
  IQ iq;
  if (ColibriConferenceIQ.ELEMENT_NAME.equals(parser.getName()) && ColibriConferenceIQ.NAMESPACE.equals(namespace)) {
    ColibriConferenceIQ conference=new ColibriConferenceIQ();
    String conferenceID=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.ID_ATTR_NAME);
    if ((conferenceID != null) && (conferenceID.length() != 0))     conference.setID(conferenceID);
    boolean done=false;
    ColibriConferenceIQ.Channel channel=null;
    ColibriConferenceIQ.Content content=null;
    StringBuilder ssrc=null;
    while (!done) {
switch (parser.next()) {
case XmlPullParser.END_TAG:
{
          String name=parser.getName();
          if (ColibriConferenceIQ.ELEMENT_NAME.equals(name)) {
            done=true;
          }
 else           if (ColibriConferenceIQ.Channel.ELEMENT_NAME.equals(name)) {
            content.addChannel(channel);
            channel=null;
          }
 else           if (ColibriConferenceIQ.Channel.SSRC_ELEMENT_NAME.equals(name)) {
            channel.addSSRC(Long.parseLong(ssrc.toString().trim()));
            ssrc=null;
          }
 else           if (ColibriConferenceIQ.Content.ELEMENT_NAME.equals(name)) {
            conference.addContent(content);
            content=null;
          }
          break;
        }
case XmlPullParser.START_TAG:
{
        String name=parser.getName();
        if (ColibriConferenceIQ.Channel.ELEMENT_NAME.equals(name)) {
          channel=new ColibriConferenceIQ.Channel();
          String direction=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.DIRECTION_ATTR_NAME);
          if ((direction != null) && (direction.length() != 0)) {
            channel.setDirection(MediaDirection.parseString(direction));
          }
          String expire=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.EXPIRE_ATTR_NAME);
          if ((expire != null) && (expire.length() != 0))           channel.setExpire(Integer.parseInt(expire));
          String host=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.HOST_ATTR_NAME);
          if ((host != null) && (host.length() != 0))           channel.setHost(host);
          String channelID=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.ID_ATTR_NAME);
          if ((channelID != null) && (channelID.length() != 0))           channel.setID(channelID);
          String initiator=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.INITIATOR_ATTR_NAME);
          if ((initiator != null) && (initiator.length() != 0))           channel.setInitiator(Boolean.valueOf(initiator));
          String rtcpPort=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTCP_PORT_ATTR_NAME);
          if ((rtcpPort != null) && (rtcpPort.length() != 0))           channel.setRTCPPort(Integer.parseInt(rtcpPort));
          String rtpLevelRelayType=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTP_LEVEL_RELAY_TYPE_ATTR_NAME);
          if ((rtpLevelRelayType != null) && (rtpLevelRelayType.length() != 0)) {
            channel.setRTPLevelRelayType(rtpLevelRelayType);
          }
          String rtpPort=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTP_PORT_ATTR_NAME);
          if ((rtpPort != null) && (rtpPort.length() != 0))           channel.setRTPPort(Integer.parseInt(rtpPort));
        }
 else         if (ColibriConferenceIQ.Channel.SSRC_ELEMENT_NAME.equals(name)) {
          ssrc=new StringBuilder();
        }
 else         if (ColibriConferenceIQ.Content.ELEMENT_NAME.equals(name)) {
          content=new ColibriConferenceIQ.Content();
          String contentName=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Content.NAME_ATTR_NAME);
          if ((contentName != null) && (contentName.length() != 0))           content.setName(contentName);
        }
 else         if (channel != null) {
          String peName=null;
          String peNamespace=null;
          if (IceUdpTransportPacketExtension.ELEMENT_NAME.equals(name) && IceUdpTransportPacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=IceUdpTransportPacketExtension.NAMESPACE;
          }
 else           if (PayloadTypePacketExtension.ELEMENT_NAME.equals(name)) {
            peName=name;
            peNamespace=namespace;
          }
 else           if (RawUdpTransportPacketExtension.ELEMENT_NAME.equals(name) && RawUdpTransportPacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=RawUdpTransportPacketExtension.NAMESPACE;
          }
 else           if (SourcePacketExtension.ELEMENT_NAME.equals(name) && SourcePacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=SourcePacketExtension.NAMESPACE;
          }
          if (peName == null) {
            throwAway(parser,name);
          }
 else {
            PacketExtension extension=parseExtension(parser,peName,peNamespace);
            if (extension != null)             addChildExtension(channel,extension);
          }
        }
        break;
      }
case XmlPullParser.TEXT:
{
      if (ssrc != null)       ssrc.append(parser.getText());
      break;
    }
}
}
iq=conference;
}
 else iq=null;
return iq;
}","/** 
 * Parses an IQ sub-document and creates an <tt>org.jivesoftware.smack.packet.IQ</tt> instance.
 * @param parser an <tt>XmlPullParser</tt> which specifies the IQsub-document to be parsed into a new <tt>IQ</tt> instance
 * @return a new <tt>IQ</tt> instance parsed from the specified IQsub-document
 * @see IQProvider#parseIQ(XmlPullParser)
 */
@SuppressWarnings(""String_Node_Str"") public IQ parseIQ(XmlPullParser parser) throws Exception {
  String namespace=parser.getNamespace();
  IQ iq;
  if (ColibriConferenceIQ.ELEMENT_NAME.equals(parser.getName()) && ColibriConferenceIQ.NAMESPACE.equals(namespace)) {
    ColibriConferenceIQ conference=new ColibriConferenceIQ();
    String conferenceID=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.ID_ATTR_NAME);
    if ((conferenceID != null) && (conferenceID.length() != 0))     conference.setID(conferenceID);
    boolean done=false;
    ColibriConferenceIQ.Channel channel=null;
    ColibriConferenceIQ.Content content=null;
    StringBuilder ssrc=null;
    while (!done) {
switch (parser.next()) {
case XmlPullParser.END_TAG:
{
          String name=parser.getName();
          if (ColibriConferenceIQ.ELEMENT_NAME.equals(name)) {
            done=true;
          }
 else           if (ColibriConferenceIQ.Channel.ELEMENT_NAME.equals(name)) {
            content.addChannel(channel);
            channel=null;
          }
 else           if (ColibriConferenceIQ.Channel.SSRC_ELEMENT_NAME.equals(name)) {
            String s=ssrc.toString().trim();
            if (s.length() != 0) {
              int i;
              if (s.startsWith(""String_Node_Str""))               i=Integer.parseInt(s);
 else               i=(int)Long.parseLong(s);
              channel.addSSRC(i);
            }
            ssrc=null;
          }
 else           if (ColibriConferenceIQ.Content.ELEMENT_NAME.equals(name)) {
            conference.addContent(content);
            content=null;
          }
          break;
        }
case XmlPullParser.START_TAG:
{
        String name=parser.getName();
        if (ColibriConferenceIQ.Channel.ELEMENT_NAME.equals(name)) {
          channel=new ColibriConferenceIQ.Channel();
          String direction=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.DIRECTION_ATTR_NAME);
          if ((direction != null) && (direction.length() != 0)) {
            channel.setDirection(MediaDirection.parseString(direction));
          }
          String expire=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.EXPIRE_ATTR_NAME);
          if ((expire != null) && (expire.length() != 0))           channel.setExpire(Integer.parseInt(expire));
          String host=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.HOST_ATTR_NAME);
          if ((host != null) && (host.length() != 0))           channel.setHost(host);
          String channelID=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.ID_ATTR_NAME);
          if ((channelID != null) && (channelID.length() != 0))           channel.setID(channelID);
          String initiator=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.INITIATOR_ATTR_NAME);
          if ((initiator != null) && (initiator.length() != 0))           channel.setInitiator(Boolean.valueOf(initiator));
          String rtcpPort=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTCP_PORT_ATTR_NAME);
          if ((rtcpPort != null) && (rtcpPort.length() != 0))           channel.setRTCPPort(Integer.parseInt(rtcpPort));
          String rtpLevelRelayType=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTP_LEVEL_RELAY_TYPE_ATTR_NAME);
          if ((rtpLevelRelayType != null) && (rtpLevelRelayType.length() != 0)) {
            channel.setRTPLevelRelayType(rtpLevelRelayType);
          }
          String rtpPort=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Channel.RTP_PORT_ATTR_NAME);
          if ((rtpPort != null) && (rtpPort.length() != 0))           channel.setRTPPort(Integer.parseInt(rtpPort));
        }
 else         if (ColibriConferenceIQ.Channel.SSRC_ELEMENT_NAME.equals(name)) {
          ssrc=new StringBuilder();
        }
 else         if (ColibriConferenceIQ.Content.ELEMENT_NAME.equals(name)) {
          content=new ColibriConferenceIQ.Content();
          String contentName=parser.getAttributeValue(""String_Node_Str"",ColibriConferenceIQ.Content.NAME_ATTR_NAME);
          if ((contentName != null) && (contentName.length() != 0))           content.setName(contentName);
        }
 else         if (channel != null) {
          String peName=null;
          String peNamespace=null;
          if (IceUdpTransportPacketExtension.ELEMENT_NAME.equals(name) && IceUdpTransportPacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=IceUdpTransportPacketExtension.NAMESPACE;
          }
 else           if (PayloadTypePacketExtension.ELEMENT_NAME.equals(name)) {
            peName=name;
            peNamespace=namespace;
          }
 else           if (RawUdpTransportPacketExtension.ELEMENT_NAME.equals(name) && RawUdpTransportPacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=RawUdpTransportPacketExtension.NAMESPACE;
          }
 else           if (SourcePacketExtension.ELEMENT_NAME.equals(name) && SourcePacketExtension.NAMESPACE.equals(parser.getNamespace())) {
            peName=name;
            peNamespace=SourcePacketExtension.NAMESPACE;
          }
          if (peName == null) {
            throwAway(parser,name);
          }
 else {
            PacketExtension extension=parseExtension(parser,peName,peNamespace);
            if (extension != null)             addChildExtension(channel,extension);
          }
        }
        break;
      }
case XmlPullParser.TEXT:
{
      if (ssrc != null)       ssrc.append(parser.getText());
      break;
    }
}
}
iq=conference;
}
 else iq=null;
return iq;
}",0.975185685347738
103056,"/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  boolean isSelected=path.equals(getSelectionPath());
  if (!isSelected && (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  if (isRightButtonMenuEnabled) {
    if (lastComponent instanceof ContactNode) {
      UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
      if (((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) && !(((SourceContact)uiContact.getDescriptor()).getContactDetails(OperationSetMultiUserChat.class) != null)) {
        rightButtonMenu=uiContact.getRightButtonMenu();
        openRightButtonMenu(e.getPoint());
      }
    }
 else     if (lastComponent instanceof GroupNode) {
      UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
        rightButtonMenu=uiGroup.getRightButtonMenu();
        openRightButtonMenu(e.getPoint());
      }
    }
  }
  if (isSelected && e.getClickCount() < 2)   dispatchEventToButtons(e);
}","/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  boolean isSelected=path.equals(getSelectionPath());
  if (!isSelected && (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  if (isRightButtonMenuEnabled) {
    if (lastComponent instanceof ContactNode) {
      UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
      if (((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown()))) {
        rightButtonMenu=uiContact.getRightButtonMenu();
        openRightButtonMenu(e.getPoint());
      }
    }
 else     if (lastComponent instanceof GroupNode) {
      UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
        rightButtonMenu=uiGroup.getRightButtonMenu();
        openRightButtonMenu(e.getPoint());
      }
    }
  }
  if (isSelected && e.getClickCount() < 2)   dispatchEventToButtons(e);
}",0.971291866028708
103057,"/** 
 * Adds a <tt>ConferenceDescription</tt> to the list of conferences.
 * @param chatConference the <tt>ConferenceDescription</tt> to add
 */
public void addConference(ConferenceDescription conferenceDescription){
  chatConferenceListPanel.addConference(conferenceDescription);
}","/** 
 * Adds a <tt>ConferenceDescription</tt> to the list of conferences.
 * @param conferenceDescription the <tt>ConferenceDescription</tt> to add
 */
public void addConference(ConferenceDescription conferenceDescription){
  chatConferenceListPanel.addConference(conferenceDescription);
}",0.9422066549912436
103058,"/** 
 * Joins an existing chat room conference call.
 */
private void joinConference(){
  ConferenceDescription chatConference=(ConferenceDescription)chatConferenceListPanel.getSelectedValue();
  if (chatConference != null)   CallManager.call(chatPanel.getChatSession().getCurrentChatTransport().getProtocolProvider(),chatConference,chatRoom);
}","/** 
 * Joins an existing chat room conference call.
 */
private void joinConference(){
  ConferenceDescription chatConference=chatConferenceListPanel.getSelectedValue();
  if (chatConference != null)   CallManager.call(chatPanel.getChatSession().getCurrentChatTransport().getProtocolProvider(),chatConference,chatRoom);
}",0.9655172413793104
103059,"/** 
 * Creates an instance of <tt>ChatRoomQuery</tt> by specifying the parent contact source, the query string to match and the maximum result contacts to return.
 * @param contactSource the parent contact source
 * @param queryString the query string to match
 * @param contactCount the maximum result contact count
 */
public ChatRoomQuery(String queryString,int count,ChatRoomContactSourceService contactSource){
  super(contactSource,Pattern.compile(queryString,Pattern.CASE_INSENSITIVE | Pattern.LITERAL),true);
  this.count=count;
  this.queryString=queryString;
  for (  ProtocolProviderService pps : MUCActivator.getChatRoomProviders()) {
    OperationSetMultiUserChat opSetMUC=(OperationSetMultiUserChat)pps.getOperationSet(OperationSetMultiUserChat.class);
    if (opSetMUC != null) {
      opSetMUC.addPresenceListener(this);
    }
  }
  MUCActivator.getMUCService().addChatRoomListChangeListener(this);
}","/** 
 * Creates an instance of <tt>ChatRoomQuery</tt> by specifying the parent contact source, the query string to match and the maximum result contacts to return.
 * @param contactSource the parent contact source
 * @param queryString the query string to match
 * @param count the maximum result contact count
 */
public ChatRoomQuery(String queryString,int count,ChatRoomContactSourceService contactSource){
  super(contactSource,Pattern.compile(queryString,Pattern.CASE_INSENSITIVE | Pattern.LITERAL),true);
  this.count=count;
  this.queryString=queryString;
  for (  ProtocolProviderService pps : MUCActivator.getChatRoomProviders()) {
    OperationSetMultiUserChat opSetMUC=pps.getOperationSet(OperationSetMultiUserChat.class);
    if (opSetMUC != null) {
      opSetMUC.addPresenceListener(this);
    }
  }
  MUCActivator.getMUCService().addChatRoomListChangeListener(this);
}",0.9811111111111112
103060,"@Override protected void run(){
  ConfigurationService configService=MUCActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  for (  ProtocolProviderService pps : MUCActivator.getChatRoomProviders()) {
    for (    String accountRootPropName : accounts) {
      String accountUID=configService.getString(accountRootPropName);
      if (accountUID.equals(pps.getAccountID().getAccountUniqueID())) {
        List<String> chatRooms=configService.getPropertyNamesByPrefix(accountRootPropName + ""String_Node_Str"",true);
        for (        String chatRoomPropName : chatRooms) {
          if (count > 0 && getQueryResultCount() > count) {
            if (getStatus() != QUERY_CANCELED)             setStatus(QUERY_COMPLETED);
            return;
          }
          addChatRoom(pps,configService.getString(chatRoomPropName + ""String_Node_Str""),configService.getString(chatRoomPropName));
        }
      }
    }
  }
  if (getStatus() != QUERY_CANCELED)   setStatus(QUERY_COMPLETED);
}","@Override protected void run(){
  Iterator<ChatRoomProviderWrapper> chatRoomProviders=MUCActivator.getMUCService().getChatRoomList().getChatRoomProviders();
  while (chatRoomProviders.hasNext()) {
    ChatRoomProviderWrapper provider=chatRoomProviders.next();
    for (int i=0; i < provider.countChatRooms(); i++) {
      if (count > 0 && getQueryResultCount() > count) {
        if (getStatus() != QUERY_CANCELED)         setStatus(QUERY_COMPLETED);
        return;
      }
      ChatRoomWrapper chatRoom=provider.getChatRoom(i);
      addChatRoom(provider.getProtocolProvider(),chatRoom.getChatRoomName(),chatRoom.getChatRoomID());
    }
  }
  if (getStatus() != QUERY_CANCELED)   setStatus(QUERY_COMPLETED);
}",0.1474036850921273
103061,"/** 
 * Returns a reference to a CredentialsStorageService implementation currently registered in the bundle context or null if no such implementation was found.
 * @return a currently valid implementation of theCredentialsStorageService.
 */
public static CredentialsStorageService getCredentialsStorageService(){
  if (credentialsService == null) {
    credentialsService=(CredentialsStorageService)ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
  }
  return credentialsService;
}","/** 
 * Returns a reference to a CredentialsStorageService implementation currently registered in the bundle context or null if no such implementation was found.
 * @return a currently valid implementation of theCredentialsStorageService.
 */
public static CredentialsStorageService getCredentialsStorageService(){
  if (credentialsService == null) {
    credentialsService=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
  }
  return credentialsService;
}",0.972644376899696
103062,"/** 
 * @override {@link SwingWorker}{@link #doInBackground()} to performall asynchronous tasks.
 * @return SUCCESS if success, otherwise the error code
 */
@Override public void run(){
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  try {
    if (password != null && password.length > 0)     chatRoom.joinAs(nickName,password);
 else     if (nickName != null)     chatRoom.joinAs(nickName);
 else     chatRoom.join();
    done(SUCCESS);
  }
 catch (  OperationFailedException e) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + chatRoom.getName(),e);
switch (e.getErrorCode()) {
case OperationFailedException.AUTHENTICATION_FAILED:
      done(AUTHENTICATION_FAILED);
case OperationFailedException.REGISTRATION_REQUIRED:
    done(REGISTRATION_REQUIRED);
case OperationFailedException.PROVIDER_NOT_REGISTERED:
  done(PROVIDER_NOT_REGISTERED);
case OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS:
done(SUBSCRIPTION_ALREADY_EXISTS);
default :
done(UNKNOWN_ERROR);
}
}
}","/** 
 * @override {@link Thread}{@link #run()} to perform all asynchronous tasks.
 */
@Override public void run(){
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  try {
    if (password != null && password.length > 0)     chatRoom.joinAs(nickName,password);
 else     if (nickName != null)     chatRoom.joinAs(nickName);
 else     chatRoom.join();
    done(SUCCESS);
  }
 catch (  OperationFailedException e) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + chatRoom.getName(),e);
switch (e.getErrorCode()) {
case OperationFailedException.AUTHENTICATION_FAILED:
      done(AUTHENTICATION_FAILED);
    break;
case OperationFailedException.REGISTRATION_REQUIRED:
  done(REGISTRATION_REQUIRED);
break;
case OperationFailedException.PROVIDER_NOT_REGISTERED:
done(PROVIDER_NOT_REGISTERED);
break;
case OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS:
done(SUBSCRIPTION_ALREADY_EXISTS);
break;
default :
done(UNKNOWN_ERROR);
}
}
}",0.6162493612672458
103063,"/** 
 * @override {@link SwingWorker}{@link #done()} to perform UI changesafter the chat room join task has finished.
 */
private void done(String returnCode){
  ConfigurationUtils.updateChatRoomStatus(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),GlobalStatusEnum.ONLINE_STATUS);
  String errorMessage=null;
  if (AUTHENTICATION_FAILED.equals(returnCode)) {
    chatRoomWrapper.removePassword();
    AuthenticationWindowService authWindowsService=ServiceUtils.getService(MUCActivator.bundleContext,AuthenticationWindowService.class);
    AuthenticationWindowService.AuthenticationWindow authWindow=authWindowsService.create(null,null,null,false,chatRoomWrapper.isPersistent(),ImageLoader.getAuthenticationWindowIcon(chatRoomWrapper.getParentProvider().getProtocolProvider()),resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getParentProvider().getName()}),resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}),""String_Node_Str"",null,isFirstAttempt ? null : resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}),null);
    authWindow.setVisible(true);
    if (!authWindow.isCanceled()) {
      joinChatRoom(chatRoomWrapper,nickName,new String(authWindow.getPassword()).getBytes(),authWindow.isRememberPassword(),false,subject);
    }
  }
 else   if (REGISTRATION_REQUIRED.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (PROVIDER_NOT_REGISTERED.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (SUBSCRIPTION_ALREADY_EXISTS.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
  if (!SUCCESS.equals(returnCode) && !AUTHENTICATION_FAILED.equals(returnCode)) {
    MUCActivator.getAlertUIService().showAlertDialog(resources.getI18NString(""String_Node_Str""),errorMessage);
  }
  if (SUCCESS.equals(returnCode)) {
    if (rememberPassword) {
      chatRoomWrapper.savePassword(new String(password));
    }
    if (subject != null) {
      try {
        chatRoomWrapper.getChatRoom().setSubject(subject);
      }
 catch (      OperationFailedException ex) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Performs UI changes after the chat room join task has finished.
 * @param returnCode the result code from the chat room join task.
 */
private void done(String returnCode){
  ConfigurationUtils.updateChatRoomStatus(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),GlobalStatusEnum.ONLINE_STATUS);
  String errorMessage=null;
  if (AUTHENTICATION_FAILED.equals(returnCode)) {
    chatRoomWrapper.removePassword();
    AuthenticationWindowService authWindowsService=ServiceUtils.getService(MUCActivator.bundleContext,AuthenticationWindowService.class);
    AuthenticationWindowService.AuthenticationWindow authWindow=authWindowsService.create(null,null,null,false,chatRoomWrapper.isPersistent(),ImageLoader.getAuthenticationWindowIcon(chatRoomWrapper.getParentProvider().getProtocolProvider()),resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getParentProvider().getName()}),resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}),""String_Node_Str"",null,isFirstAttempt ? null : resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}),null);
    authWindow.setVisible(true);
    if (!authWindow.isCanceled()) {
      joinChatRoom(chatRoomWrapper,nickName,new String(authWindow.getPassword()).getBytes(),authWindow.isRememberPassword(),false,subject);
    }
  }
 else   if (REGISTRATION_REQUIRED.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (PROVIDER_NOT_REGISTERED.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (SUBSCRIPTION_ALREADY_EXISTS.equals(returnCode)) {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else {
    errorMessage=resources.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
  if (!SUCCESS.equals(returnCode) && !AUTHENTICATION_FAILED.equals(returnCode)) {
    MUCActivator.getAlertUIService().showAlertDialog(resources.getI18NString(""String_Node_Str""),errorMessage);
  }
  if (SUCCESS.equals(returnCode)) {
    if (rememberPassword) {
      chatRoomWrapper.savePassword(new String(password));
    }
    if (subject != null) {
      try {
        chatRoomWrapper.getChatRoom().setSubject(subject);
      }
 catch (      OperationFailedException ex) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}",0.9544832975190468
103064,"/** 
 * Updates the <tt>SrtpControls</tt> of this instance in accord with a specific <tt>MediaDescription</tt> presented by a remote peer.
 * @param mediaType the <tt>MediaType</tt> of the specified<tt>MediaDescription</tt> to be analyzed
 * @param localMd the <tt>MediaDescription</tt> of the local peer that isthe answer to the offer presented by a remote peer represented by <tt>remoteMd</tt> or <tt>null</tt> if the specified <tt>remoteMd</tt> is an answer to an offer of the local peer
 * @param remoteMd the <tt>MediaDescription</tt> presented by a remote peerto be analyzed
 */
private void updateSrtpControlsForDtls(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){
  SrtpControls srtpControls=getSrtpControls();
  DtlsControl dtlsControl=(DtlsControl)srtpControls.get(mediaType,SrtpControlType.DTLS_SRTP);
  if (dtlsControl == null)   return;
  Media remoteMedia=remoteMd.getMedia();
  boolean dtls=false;
  if (remoteMedia != null) {
    String proto;
    try {
      proto=remoteMedia.getProtocol();
    }
 catch (    SdpParseException e) {
      proto=null;
    }
    dtls=DtlsControl.UDP_TLS_RTP_SAVP.equals(proto) || DtlsControl.UDP_TLS_RTP_SAVPF.equals(proto);
  }
  if (dtls) {
    if (localMd == null) {
      String setup;
      try {
        setup=remoteMd.getAttribute(DTLS_SRTP_SETUP_ATTR);
      }
 catch (      SdpParseException spe) {
        setup=null;
      }
      if (DTLS_SRTP_SETUP_PASSIVE.equals(setup)) {
        dtlsControl.setDtlsProtocol(DtlsControl.DTLS_CLIENT_PROTOCOL);
      }
    }
    @SuppressWarnings(""String_Node_Str"") Vector<Attribute> attrs=remoteMd.getAttributes(false);
    Map<String,String> remoteFingerprints=new LinkedHashMap<String,String>();
    if (attrs != null) {
      for (      Attribute attr : attrs) {
        String fingerprint;
        try {
          if (DTLS_SRTP_FINGERPRINT_ATTR.equals(attr.getName())) {
            fingerprint=attr.getValue();
            if (fingerprint == null)             continue;
 else             fingerprint=fingerprint.trim();
          }
 else {
            continue;
          }
        }
 catch (        SdpParseException spe) {
          continue;
        }
        int spIndex=fingerprint.indexOf(' ');
        if ((spIndex > 0) && (spIndex < fingerprint.length() - 1)) {
          String hashFunction=fingerprint.substring(0,spIndex);
          fingerprint=fingerprint.substring(spIndex + 1);
          remoteFingerprints.put(hashFunction,fingerprint);
        }
      }
    }
    dtlsControl.setRemoteFingerprints(remoteFingerprints);
    removeAndCleanupOtherSrtpControls(mediaType,SrtpControlType.DTLS_SRTP);
  }
 else {
    srtpControls.remove(mediaType,SrtpControlType.DTLS_SRTP);
    dtlsControl.cleanup();
  }
}","/** 
 * Updates the <tt>SrtpControls</tt> of this instance in accord with a specific <tt>MediaDescription</tt> presented by a remote peer.
 * @param mediaType the <tt>MediaType</tt> of the specified<tt>MediaDescription</tt> to be analyzed
 * @param localMd the <tt>MediaDescription</tt> of the local peer that isthe answer to the offer presented by a remote peer represented by <tt>remoteMd</tt> or <tt>null</tt> if the specified <tt>remoteMd</tt> is an answer to an offer of the local peer
 * @param remoteMd the <tt>MediaDescription</tt> presented by a remote peerto be analyzed
 */
private void updateSrtpControlsForDtls(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){
  SrtpControls srtpControls=getSrtpControls();
  DtlsControl dtlsControl=(DtlsControl)srtpControls.get(mediaType,SrtpControlType.DTLS_SRTP);
  if (dtlsControl == null)   return;
  boolean dtls=isDtlsMediaDescription(remoteMd);
  if (dtls) {
    if (localMd == null) {
      String setup;
      try {
        setup=remoteMd.getAttribute(DTLS_SRTP_SETUP_ATTR);
      }
 catch (      SdpParseException spe) {
        setup=null;
      }
      if (DTLS_SRTP_SETUP_PASSIVE.equals(setup)) {
        dtlsControl.setDtlsProtocol(DtlsControl.DTLS_CLIENT_PROTOCOL);
      }
    }
    @SuppressWarnings(""String_Node_Str"") Vector<Attribute> attrs=remoteMd.getAttributes(false);
    Map<String,String> remoteFingerprints=new LinkedHashMap<String,String>();
    if (attrs != null) {
      for (      Attribute attr : attrs) {
        String fingerprint;
        try {
          if (DTLS_SRTP_FINGERPRINT_ATTR.equals(attr.getName())) {
            fingerprint=attr.getValue();
            if (fingerprint == null)             continue;
 else             fingerprint=fingerprint.trim();
          }
 else {
            continue;
          }
        }
 catch (        SdpParseException spe) {
          continue;
        }
        int spIndex=fingerprint.indexOf(' ');
        if ((spIndex > 0) && (spIndex < fingerprint.length() - 1)) {
          String hashFunction=fingerprint.substring(0,spIndex);
          fingerprint=fingerprint.substring(spIndex + 1);
          remoteFingerprints.put(hashFunction,fingerprint);
        }
      }
    }
    dtlsControl.setRemoteFingerprints(remoteFingerprints);
    removeAndCleanupOtherSrtpControls(mediaType,SrtpControlType.DTLS_SRTP);
  }
 else {
    srtpControls.remove(mediaType,SrtpControlType.DTLS_SRTP);
    dtlsControl.cleanup();
  }
}",0.9341524284891534
103065,"/** 
 * Gets a list of (RTP) transport protocols (i.e. <tt>&lt;proto&gt;</tt>) to be announced in a SDP media description (i.e. <tt>m=</tt> line).
 * @return a <tt>List</tt> of (RTP) transport protocols to be announced in aSDP media description
 * @throws OperationFailedException if the value of the <tt>AccountID</tt>property  {@link ProtocolProviderFactory#SAVP_OPTION} is invalid
 */
private List<String> getRtpTransports() throws OperationFailedException {
  AccountID accountID=getPeer().getProtocolProvider().getAccountID();
  int savpOption=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true) ? accountID.getAccountPropertyInt(ProtocolProviderFactory.SAVP_OPTION,ProtocolProviderFactory.SAVP_OFF) : ProtocolProviderFactory.SAVP_OFF;
  List<String> result=new ArrayList<String>(3);
  if (savpOption == ProtocolProviderFactory.SAVP_OFF) {
    result.add(SdpConstants.RTP_AVP);
  }
 else {
    List<String> encryptionProtocols=accountID.getSortedEnabledEncryptionProtocolList();
    int encryptionProtocolCount=encryptionProtocols.size();
    for (int i=encryptionProtocolCount - 1; i >= 0; i--) {
      String encryptionProtocol=encryptionProtocols.get(i);
      String protoName=encryptionProtocol.substring(ProtocolProviderFactory.ENCRYPTION_PROTOCOL.length() + 1);
      String proto;
      if (DtlsControl.PROTO_NAME.equals(protoName)) {
        proto=DtlsControl.UDP_TLS_RTP_SAVP;
      }
 else {
        proto=SrtpControl.RTP_SAVP;
      }
      int protoIndex=result.indexOf(proto);
      if (protoIndex > 0)       result.remove(protoIndex);
      result.add(0,proto);
    }
    if (savpOption == ProtocolProviderFactory.SAVP_OPTIONAL)     result.add(SdpConstants.RTP_AVP);
  }
  return result;
}","/** 
 * Gets a list of (RTP) transport protocols (i.e. <tt>&lt;proto&gt;</tt>) to be announced in a SDP media description (i.e. <tt>m=</tt> line).
 * @return a <tt>List</tt> of (RTP) transport protocols to be announced in aSDP media description
 * @throws OperationFailedException if the value of the <tt>AccountID</tt>property  {@link ProtocolProviderFactory#SAVP_OPTION} is invalid
 */
private List<String> getRtpTransports() throws OperationFailedException {
  AccountID accountID=getPeer().getProtocolProvider().getAccountID();
  int savpOption=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true) ? accountID.getAccountPropertyInt(ProtocolProviderFactory.SAVP_OPTION,ProtocolProviderFactory.SAVP_OFF) : ProtocolProviderFactory.SAVP_OFF;
  List<String> result=new ArrayList<String>(3);
  if (savpOption == ProtocolProviderFactory.SAVP_OFF) {
    result.add(SdpConstants.RTP_AVP);
  }
 else {
    List<String> encryptionProtocols=accountID.getSortedEnabledEncryptionProtocolList();
    for (int epi=encryptionProtocols.size() - 1; epi >= 0; epi--) {
      String encryptionProtocol=encryptionProtocols.get(epi);
      String protoName=encryptionProtocol.substring(ProtocolProviderFactory.ENCRYPTION_PROTOCOL.length() + 1);
      String[] protos;
      if (DtlsControl.PROTO_NAME.equals(protoName)) {
        protos=new String[]{DtlsControl.UDP_TLS_RTP_SAVP,SrtpControl.RTP_SAVPF};
      }
 else {
        protos=new String[]{SrtpControl.RTP_SAVP};
      }
      for (int pi=protos.length - 1; pi >= 0; pi--) {
        String proto=protos[pi];
        int ri=result.indexOf(proto);
        if (ri > 0)         result.remove(ri);
        result.add(0,proto);
      }
    }
    if (savpOption == ProtocolProviderFactory.SAVP_OPTIONAL)     result.add(SdpConstants.RTP_AVP);
  }
  return result;
}",0.8826001681143177
103066,"/** 
 * Updates a specific local <tt>MediaDescription</tt> and the state of this instance for the purposes of DTLS-SRTP.
 * @param mediaType the <tt>MediaType</tt> of the media described by<tt>localMd</tt> and <tt>remoteMd</tt>
 * @param localMd the local <tt>MediaDescription</tt> to be updated
 * @param remoteMd the remote <tt>MediaDescription</tt>, if any, associatedwith <tt>localMd</tt>
 * @return <tt>true</tt> if the specified <tt>localMd</tt> and/or the stateof this instance was updated for the purposes of DTLS-SRTP or <tt>false</tt> if the specified <tt>localMd</tt> (and <tt>remoteMd</tt>) did not concern DTLS-SRTP
 */
private boolean updateMediaDescriptionForDtls(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){
  AccountID accountID=getPeer().getProtocolProvider().getAccountID();
  boolean b=false;
  if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true) && accountID.isEncryptionProtocolEnabled(DtlsControl.PROTO_NAME)) {
    Media localMedia=localMd.getMedia();
    if (localMedia != null) {
      String proto;
      try {
        proto=localMedia.getProtocol();
      }
 catch (      SdpParseException e) {
        proto=null;
      }
      boolean dtls=DtlsControl.UDP_TLS_RTP_SAVP.equals(proto) || DtlsControl.UDP_TLS_RTP_SAVPF.equals(proto);
      SrtpControls srtpControls=getSrtpControls();
      if (dtls) {
        DtlsControl dtlsControl=(DtlsControl)srtpControls.getOrCreate(mediaType,SrtpControlType.DTLS_SRTP);
        @SuppressWarnings(""String_Node_Str"") Vector<Attribute> attrs=localMd.getAttributes(true);
        String setup=(remoteMd == null) ? DTLS_SRTP_SETUP_ACTPASS : DTLS_SRTP_SETUP_ACTIVE;
        Attribute setupAttr=SdpUtils.createAttribute(DTLS_SRTP_SETUP_ATTR,setup);
        attrs.add(setupAttr);
        String hashFunction=dtlsControl.getLocalFingerprintHashFunction();
        String fingerprint=dtlsControl.getLocalFingerprint();
        Attribute fingerprintAttr=SdpUtils.createAttribute(DTLS_SRTP_FINGERPRINT_ATTR,hashFunction + ""String_Node_Str"" + fingerprint);
        attrs.add(fingerprintAttr);
        int dtlsProtocol=DTLS_SRTP_SETUP_ACTIVE.equals(setup) ? DtlsControl.DTLS_CLIENT_PROTOCOL : DtlsControl.DTLS_SERVER_PROTOCOL;
        dtlsControl.setDtlsProtocol(dtlsProtocol);
        if (remoteMd != null)         updateSrtpControlsForDtls(mediaType,localMd,remoteMd);
        b=true;
      }
 else       if (remoteMd != null) {
        SrtpControl dtlsControl=srtpControls.remove(mediaType,SrtpControlType.DTLS_SRTP);
        if (dtlsControl != null)         dtlsControl.cleanup();
      }
    }
  }
  return b;
}","/** 
 * Updates a specific local <tt>MediaDescription</tt> and the state of this instance for the purposes of DTLS-SRTP.
 * @param mediaType the <tt>MediaType</tt> of the media described by<tt>localMd</tt> and <tt>remoteMd</tt>
 * @param localMd the local <tt>MediaDescription</tt> to be updated
 * @param remoteMd the remote <tt>MediaDescription</tt>, if any, associatedwith <tt>localMd</tt>
 * @return <tt>true</tt> if the specified <tt>localMd</tt> and/or the stateof this instance was updated for the purposes of DTLS-SRTP or <tt>false</tt> if the specified <tt>localMd</tt> (and <tt>remoteMd</tt>) did not concern DTLS-SRTP
 */
private boolean updateMediaDescriptionForDtls(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){
  AccountID accountID=getPeer().getProtocolProvider().getAccountID();
  boolean b=false;
  if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true) && accountID.isEncryptionProtocolEnabled(DtlsControl.PROTO_NAME)) {
    Media localMedia=localMd.getMedia();
    if (localMedia != null) {
      String proto;
      try {
        proto=localMedia.getProtocol();
      }
 catch (      SdpParseException e) {
        proto=null;
      }
      boolean dtls=DtlsControl.UDP_TLS_RTP_SAVP.equals(proto) || DtlsControl.UDP_TLS_RTP_SAVPF.equals(proto) || SrtpControl.RTP_SAVPF.equals(proto);
      if (dtls && (remoteMd != null))       dtls=isDtlsMediaDescription(remoteMd);
      SrtpControls srtpControls=getSrtpControls();
      if (dtls) {
        DtlsControl dtlsControl=(DtlsControl)srtpControls.getOrCreate(mediaType,SrtpControlType.DTLS_SRTP);
        @SuppressWarnings(""String_Node_Str"") Vector<Attribute> attrs=localMd.getAttributes(true);
        String setup=(remoteMd == null) ? DTLS_SRTP_SETUP_ACTPASS : DTLS_SRTP_SETUP_ACTIVE;
        Attribute setupAttr=SdpUtils.createAttribute(DTLS_SRTP_SETUP_ATTR,setup);
        attrs.add(setupAttr);
        String hashFunction=dtlsControl.getLocalFingerprintHashFunction();
        String fingerprint=dtlsControl.getLocalFingerprint();
        Attribute fingerprintAttr=SdpUtils.createAttribute(DTLS_SRTP_FINGERPRINT_ATTR,hashFunction + ""String_Node_Str"" + fingerprint);
        attrs.add(fingerprintAttr);
        int dtlsProtocol=DTLS_SRTP_SETUP_ACTIVE.equals(setup) ? DtlsControl.DTLS_CLIENT_PROTOCOL : DtlsControl.DTLS_SERVER_PROTOCOL;
        dtlsControl.setDtlsProtocol(dtlsProtocol);
        if (remoteMd != null)         updateSrtpControlsForDtls(mediaType,localMd,remoteMd);
        b=true;
      }
 else       if (remoteMd != null) {
        SrtpControl dtlsControl=srtpControls.remove(mediaType,SrtpControlType.DTLS_SRTP);
        if (dtlsControl != null)         dtlsControl.cleanup();
      }
    }
  }
  return b;
}",0.977373887240356
103067,"/** 
 * Creates a <tt>Vector</tt> containing the <tt>MediaDescription</tt>s of streams that this handler is prepared to initiate depending on available <tt>MediaDevice</tt>s and local on-hold and video transmission preferences.
 * @return a <tt>Vector</tt> containing the <tt>MediaDescription</tt>s ofstreams that this handler is prepared to initiate.
 * @throws OperationFailedException if we fail to create the descriptionsfor reasons like - problems with device interaction, allocating ports, etc.
 */
private Vector<MediaDescription> createMediaDescriptions() throws OperationFailedException {
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  QualityPreset sendQualityPreset=null;
  QualityPreset receiveQualityPreset=null;
  if (qualityControls != null) {
    sendQualityPreset=qualityControls.getRemoteReceivePreset();
    receiveQualityPreset=qualityControls.getRemoteSendMaxPreset();
  }
  for (  MediaType mediaType : MediaType.values()) {
    MediaDevice dev=getDefaultDevice(mediaType);
    if (!isDeviceActive(dev,sendQualityPreset,receiveQualityPreset))     continue;
    MediaDirection direction=dev.getDirection().and(getDirectionUserPreference(mediaType));
    if (isLocallyOnHold())     direction=direction.and(MediaDirection.SENDONLY);
    if (direction != MediaDirection.INACTIVE) {
      for (      String proto : getRtpTransports()) {
        QualityPreset effectiveSendQualityPreset=direction.allowsSending() ? sendQualityPreset : null;
        MediaDescription md=createMediaDescription(proto,getLocallySupportedFormats(dev,effectiveSendQualityPreset,receiveQualityPreset),getTransportManager().getStreamConnector(mediaType),direction,dev.getSupportedExtensions());
        try {
          if (mediaType.equals(MediaType.VIDEO) && (receiveQualityPreset != null)) {
            int frameRate=(int)receiveQualityPreset.getFameRate();
            if (frameRate > 0) {
              md.setAttribute(""String_Node_Str"",String.valueOf(frameRate));
            }
          }
        }
 catch (        SdpException e) {
        }
        if (DtlsControl.UDP_TLS_RTP_SAVP.equals(proto) || DtlsControl.UDP_TLS_RTP_SAVPF.equals(proto)) {
          updateMediaDescriptionForDtls(mediaType,md,null);
        }
 else {
          updateMediaDescriptionForZrtp(mediaType,md,null);
          if (SrtpControl.RTP_SAVP.equals(proto) || SrtpControl.RTP_SAVPF.equals(proto)) {
            updateMediaDescriptionForSDes(mediaType,md,null);
          }
        }
        mediaDescs.add(md);
      }
    }
  }
  if (mediaDescs.isEmpty()) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR,null,logger);
  }
  return mediaDescs;
}","/** 
 * Creates a <tt>Vector</tt> containing the <tt>MediaDescription</tt>s of streams that this handler is prepared to initiate depending on available <tt>MediaDevice</tt>s and local on-hold and video transmission preferences.
 * @return a <tt>Vector</tt> containing the <tt>MediaDescription</tt>s ofstreams that this handler is prepared to initiate.
 * @throws OperationFailedException if we fail to create the descriptionsfor reasons like - problems with device interaction, allocating ports, etc.
 */
private Vector<MediaDescription> createMediaDescriptions() throws OperationFailedException {
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  QualityPreset sendQualityPreset=null;
  QualityPreset receiveQualityPreset=null;
  if (qualityControls != null) {
    sendQualityPreset=qualityControls.getRemoteReceivePreset();
    receiveQualityPreset=qualityControls.getRemoteSendMaxPreset();
  }
  for (  MediaType mediaType : MediaType.values()) {
    MediaDevice dev=getDefaultDevice(mediaType);
    if (!isDeviceActive(dev,sendQualityPreset,receiveQualityPreset))     continue;
    MediaDirection direction=dev.getDirection().and(getDirectionUserPreference(mediaType));
    if (isLocallyOnHold())     direction=direction.and(MediaDirection.SENDONLY);
    if (direction != MediaDirection.INACTIVE) {
      for (      String proto : getRtpTransports()) {
        QualityPreset effectiveSendQualityPreset=direction.allowsSending() ? sendQualityPreset : null;
        MediaDescription md=createMediaDescription(proto,getLocallySupportedFormats(dev,effectiveSendQualityPreset,receiveQualityPreset),getTransportManager().getStreamConnector(mediaType),direction,dev.getSupportedExtensions());
        try {
          if (mediaType.equals(MediaType.VIDEO) && (receiveQualityPreset != null)) {
            int frameRate=(int)receiveQualityPreset.getFameRate();
            if (frameRate > 0) {
              md.setAttribute(""String_Node_Str"",String.valueOf(frameRate));
            }
          }
        }
 catch (        SdpException e) {
        }
        if (DtlsControl.UDP_TLS_RTP_SAVP.equals(proto) || DtlsControl.UDP_TLS_RTP_SAVPF.equals(proto)) {
          updateMediaDescriptionForDtls(mediaType,md,null);
        }
 else {
          updateMediaDescriptionForZrtp(mediaType,md,null);
          if (SrtpControl.RTP_SAVP.equals(proto) || SrtpControl.RTP_SAVPF.equals(proto)) {
            updateMediaDescriptionForSDes(mediaType,md,null);
          }
          if (SrtpControl.RTP_SAVPF.equals(proto)) {
            updateMediaDescriptionForDtls(mediaType,md,null);
          }
        }
        mediaDescs.add(md);
      }
    }
  }
  if (mediaDescs.isEmpty()) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR,null,logger);
  }
  return mediaDescs;
}",0.977373953322644
103068,"/** 
 * Installs the account defined in this wizard.
 * @param userName the user name to sign in with
 * @param password the password to sign in with
 * @return the created <tt>ProtocolProviderService</tt> corresponding to thenew account
 * @throws OperationFailedException if the operation didn't succeed
 */
public ProtocolProviderService signin(final String userName,final String password) throws OperationFailedException {
  final AccountPanel accPanel=(AccountPanel)firstWizardPage.getSimpleForm();
  String accPanelUsername=accPanel.getUsername();
  boolean equals=false;
  final boolean rememberPassword=(password != null);
  if (StringUtils.isEquals(accPanelUsername,userName)) {
    char[] accPanelPasswordChars=accPanel.getPassword();
    char[] passwordChars=(password == null) ? null : password.toCharArray();
    if (accPanelPasswordChars == null)     equals=((passwordChars == null) || passwordChars.length == 0);
 else     if (passwordChars == null)     equals=(accPanelPasswordChars.length == 0);
 else     equals=Arrays.equals(accPanelPasswordChars,passwordChars);
    if (equals) {
      boolean accPanelRememberPassword=accPanel.isRememberPassword();
      equals=(accPanelRememberPassword == rememberPassword);
    }
  }
  if (!equals) {
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          accPanel.setUsername(userName);
          accPanel.setPassword(password);
          accPanel.setRememberPassword(rememberPassword);
        }
      }
);
    }
 catch (    Exception e) {
      if (e instanceof OperationFailedException) {
        throw (OperationFailedException)e;
      }
 else {
        throw new OperationFailedException(""String_Node_Str"" + accPanel.getClass().getName(),OperationFailedException.INTERNAL_ERROR,e);
      }
    }
  }
  if (!firstWizardPage.isCommitted())   firstWizardPage.commitPage();
  if (!firstWizardPage.isCommitted()) {
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  ProtocolProviderFactory factory=JabberAccRegWizzActivator.getJabberProtocolProviderFactory();
  return installAccount(factory,registration.getUserID(),password);
}","/** 
 * Installs the account defined in this wizard.
 * @param userName the user name to sign in with
 * @param password the password to sign in with
 * @return the created <tt>ProtocolProviderService</tt> corresponding to thenew account
 * @throws OperationFailedException if the operation didn't succeed
 */
public ProtocolProviderService signin(final String userName,final String password) throws OperationFailedException {
  final AccountPanel accPanel=(AccountPanel)firstWizardPage.getSimpleForm();
  String accPanelUsername=accPanel.getUsername();
  boolean equals=false;
  final boolean rememberPassword=(password != null);
  if (StringUtils.isEquals(accPanelUsername,userName)) {
    char[] accPanelPasswordChars=accPanel.getPassword();
    char[] passwordChars=(password == null) ? null : password.toCharArray();
    if (accPanelPasswordChars == null)     equals=((passwordChars == null) || passwordChars.length == 0);
 else     if (passwordChars == null)     equals=(accPanelPasswordChars.length == 0);
 else     equals=Arrays.equals(accPanelPasswordChars,passwordChars);
    if (equals) {
      boolean accPanelRememberPassword=accPanel.isRememberPassword();
      equals=(accPanelRememberPassword == rememberPassword);
    }
  }
  if (!equals) {
    try {
      if (SwingUtilities.isEventDispatchThread()) {
        accPanel.setUsername(userName);
        accPanel.setPassword(password);
        accPanel.setRememberPassword(rememberPassword);
      }
 else {
        SwingUtilities.invokeAndWait(new Runnable(){
          public void run(){
            accPanel.setUsername(userName);
            accPanel.setPassword(password);
            accPanel.setRememberPassword(rememberPassword);
          }
        }
);
      }
    }
 catch (    Exception e) {
      if (e instanceof OperationFailedException) {
        throw (OperationFailedException)e;
      }
 else {
        throw new OperationFailedException(""String_Node_Str"" + accPanel.getClass().getName(),OperationFailedException.INTERNAL_ERROR,e);
      }
    }
  }
  if (!firstWizardPage.isCommitted())   firstWizardPage.commitPage();
  if (!firstWizardPage.isCommitted()) {
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  ProtocolProviderFactory factory=JabberAccRegWizzActivator.getJabberProtocolProviderFactory();
  return installAccount(factory,registration.getUserID(),password);
}",0.9503700478885504
103069,"/** 
 * Initializes a new <tt>ChatRoomConferenceCallsListPanel</tt> instance  which is to depict the conferences of a chat specified by its  <tt>ChatPanel</tt>.
 * @param chatPanel the <tt>ChatPanel</tt> which specifies the chat.
 */
public ChatRoomConferenceCallsListPanel(final ChatPanel chatPanel){
  super(new BorderLayout());
  this.chatPanel=chatPanel;
  this.conferenceCallsListModel=new ChatConferenceCallsListModels(chatPanel.getChatSession());
  this.conferenceCallList=new JList<ConferenceDescription>(conferenceCallsListModel);
  this.conferenceCallList.addKeyListener(new CListKeySearchListener(conferenceCallList));
  this.conferenceCallList.setCellRenderer(new ChatConferenceCallsListRenderer());
  JScrollPane conferenceCallsScrollPane=new SIPCommScrollPane();
  conferenceCallsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  conferenceCallsScrollPane.setOpaque(false);
  conferenceCallsScrollPane.setBorder(null);
  JViewport viewport=conferenceCallsScrollPane.getViewport();
  viewport.setOpaque(false);
  viewport.add(conferenceCallList);
  this.add(conferenceCallsScrollPane);
}","/** 
 * Initializes a new <tt>ChatRoomConferenceCallsListPanel</tt> instance  which is to depict the conferences of a chat specified by its  <tt>ChatPanel</tt>.
 * @param chatPanel the <tt>ChatPanel</tt> which specifies the chat.
 */
public ChatRoomConferenceCallsListPanel(final ChatPanel chatPanel){
  super(new BorderLayout());
  this.chatPanel=chatPanel;
  this.conferenceCallsListModel=new ChatConferenceCallsListModels(chatPanel.getChatSession());
  this.conferenceCallList=new JList(conferenceCallsListModel);
  this.conferenceCallList.addKeyListener(new CListKeySearchListener(conferenceCallList));
  this.conferenceCallList.setCellRenderer(new ChatConferenceCallsListRenderer());
  JScrollPane conferenceCallsScrollPane=new SIPCommScrollPane();
  conferenceCallsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  conferenceCallsScrollPane.setOpaque(false);
  conferenceCallsScrollPane.setBorder(null);
  JViewport viewport=conferenceCallsScrollPane.getViewport();
  viewport.setOpaque(false);
  viewport.add(conferenceCallList);
  this.add(conferenceCallsScrollPane);
}",0.9897458760588498
103070,"/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 * @param e the <tt>ActionEvent</tt> that notified us
 */
@Override public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemText=menuItem.getName();
  if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    ChatRoomTableDialog.showChatRoomTableDialog();
  }
 else   if (itemText.equals(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    ChatPanel chatPanel=this.chatWindow.getCurrentChat();
    ChatSession chatSession=chatPanel.getChatSession();
    if (historyWindowManager.containsHistoryWindowForContact(chatSession.getDescriptor())) {
      history=historyWindowManager.getHistoryWindowForContact(chatSession.getDescriptor());
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(chatPanel.getChatSession().getDescriptor());
      history.setVisible(true);
      historyWindowManager.addHistoryWindowForContact(chatSession.getDescriptor(),history);
    }
  }
 else   if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    this.chatWindow.setVisible(false);
    this.chatWindow.dispose();
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 * @param e the <tt>ActionEvent</tt> that notified us
 */
@Override public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemText=menuItem.getName();
  if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    this.chatWindow.setVisible(false);
    this.chatWindow.dispose();
    return;
  }
  super.actionPerformed(e);
  if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    ChatRoomTableDialog.showChatRoomTableDialog();
  }
 else   if (itemText.equals(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    ChatPanel chatPanel=this.chatWindow.getCurrentChat();
    ChatSession chatSession=chatPanel.getChatSession();
    if (historyWindowManager.containsHistoryWindowForContact(chatSession.getDescriptor())) {
      history=historyWindowManager.getHistoryWindowForContact(chatSession.getDescriptor());
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(chatPanel.getChatSession().getDescriptor());
      history.setVisible(true);
      historyWindowManager.addHistoryWindowForContact(chatSession.getDescriptor(),history);
    }
  }
}",0.8794740686632578
103071,"/** 
 * Initializes the dialog.
 */
private void init(){
  this.accountLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.accountCombo=new JComboBox();
  this.groupLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.contactAddressLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.displayNameLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.contactAddressField=new JTextField();
  this.displayNameField=new JTextField();
  this.addButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.cancelButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.imageLabel=new JLabel();
  this.groupCombo=createGroupCombo(this);
  if (metaContact != null) {
    groupCombo.setEnabled(false);
    this.setSelectedGroup(metaContact.getParentMetaContactGroup());
  }
  TransparentPanel labelsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  TransparentPanel fieldsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  initAccountCombo();
  accountCombo.setRenderer(new AccountComboRenderer());
  if (accountCombo.getItemCount() > 2 || (accountCombo.getItemCount() == 2 && !ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled())) {
    labelsPanel.add(accountLabel);
    fieldsPanel.add(accountCombo);
  }
  labelsPanel.add(groupLabel);
  fieldsPanel.add(groupCombo);
  labelsPanel.add(contactAddressLabel);
  fieldsPanel.add(contactAddressField);
  labelsPanel.add(displayNameLabel);
  fieldsPanel.add(displayNameField);
  contactAddressField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent e){
    }
    public void insertUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
    public void removeUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
  }
);
  TransparentPanel dataPanel=new TransparentPanel(new BorderLayout());
  dataPanel.add(labelsPanel,BorderLayout.WEST);
  dataPanel.add(fieldsPanel);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,10));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  mainPanel.add(imageLabel,BorderLayout.WEST);
  mainPanel.add(dataPanel,BorderLayout.CENTER);
  mainPanel.add(createButtonsPanel(),BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel,BorderLayout.CENTER);
  if (ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled())   this.setPreferredSize(new Dimension(450,205));
 else   this.setPreferredSize(new Dimension(450,250));
  this.setResizable(false);
  this.addWindowFocusListener(this);
  loadSkin();
  this.initialized=true;
}","/** 
 * Initializes the dialog.
 */
private void init(){
  this.accountLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.accountCombo=new JComboBox();
  this.groupLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.contactAddressLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.displayNameLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.contactAddressField=new JTextField();
  this.displayNameField=new JTextField();
  this.addButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.cancelButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.imageLabel=new JLabel();
  this.groupCombo=createGroupCombo(this);
  if (metaContact != null) {
    groupCombo.setEnabled(false);
    groupCombo.setSelectedItem(metaContact.getParentMetaContactGroup());
  }
  TransparentPanel labelsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  TransparentPanel fieldsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  initAccountCombo();
  accountCombo.setRenderer(new AccountComboRenderer());
  if (accountCombo.getItemCount() > 2 || (accountCombo.getItemCount() == 2 && !ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled())) {
    labelsPanel.add(accountLabel);
    fieldsPanel.add(accountCombo);
  }
  labelsPanel.add(groupLabel);
  fieldsPanel.add(groupCombo);
  labelsPanel.add(contactAddressLabel);
  fieldsPanel.add(contactAddressField);
  labelsPanel.add(displayNameLabel);
  fieldsPanel.add(displayNameField);
  contactAddressField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent e){
    }
    public void insertUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
    public void removeUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
  }
);
  TransparentPanel dataPanel=new TransparentPanel(new BorderLayout());
  dataPanel.add(labelsPanel,BorderLayout.WEST);
  dataPanel.add(fieldsPanel);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,10));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  mainPanel.add(imageLabel,BorderLayout.WEST);
  mainPanel.add(dataPanel,BorderLayout.CENTER);
  mainPanel.add(createButtonsPanel(),BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel,BorderLayout.CENTER);
  if (ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled())   this.setPreferredSize(new Dimension(450,205));
 else   this.setPreferredSize(new Dimension(450,250));
  this.setResizable(false);
  this.addWindowFocusListener(this);
  loadSkin();
  this.initialized=true;
}",0.9916651888632736
103072,"/** 
 * Checks whether metaContact has mobile indicator. Needs all of the contacts to have it to indicate it.
 * @param metaContact the metacontact to check for mobile indicator
 * @return whether to indicate contact as mobile one.
 */
private boolean isMobile(MetaContact metaContact){
  Iterator<Contact> iter=metaContact.getContacts();
  while (iter.hasNext()) {
    Contact contact=iter.next();
    if (contact.getPresenceStatus().isOnline() && !contact.isMobile())     return false;
  }
  return metaContact.getContactCount() > 0 ? true : false;
}","/** 
 * Checks whether metaContact has mobile indicator. Needs all of the contacts to have it to indicate it.
 * @param metaContact the metacontact to check for mobile indicator
 * @return whether to indicate contact as mobile one.
 */
private boolean isMobile(MetaContact metaContact){
  boolean hasConnectedStatus=false;
  Iterator<Contact> iter=metaContact.getContacts();
  while (iter.hasNext()) {
    Contact contact=iter.next();
    boolean isConnected=contact.getPresenceStatus().isOnline();
    if (isConnected)     hasConnectedStatus=true;
    if (isConnected && !contact.isMobile())     return false;
  }
  if (!hasConnectedStatus)   return false;
 else   return metaContact.getContactCount() > 0 ? true : false;
}",0.8589341692789969
103073,"/** 
 * Update mobile indicator for contact, searching in contact caps.
 * @param user the contact address with or without resource.
 */
private void updateMobileIndicatorUsingCaps(String user){
  ContactJabberImpl contact=ssclCallback.findContactById(StringUtils.parseBareAddress(user));
  if (contact == null)   return;
  int currentMostConnectedStatus=0;
  List<ContactResource> mostAvailableResources=new ArrayList<ContactResource>();
  for (  ContactResource res : contact.getResources()) {
    if (!res.getPresenceStatus().isOnline())     continue;
    int status=res.getPresenceStatus().getStatus();
    if (status > currentMostConnectedStatus) {
      if (currentMostConnectedStatus != status)       mostAvailableResources.clear();
      currentMostConnectedStatus=status;
      mostAvailableResources.add(res);
    }
  }
  boolean allMobile=false;
  for (  ContactResource res : mostAvailableResources) {
    if (res.isMobile())     allMobile=true;
 else {
      allMobile=false;
      break;
    }
  }
  if (mostAvailableResources.size() > 0)   contact.setMobile(allMobile);
 else   contact.setMobile(false);
}","/** 
 * Update mobile indicator for contact, searching in contact caps.
 * @param user the contact address with or without resource.
 */
private void updateMobileIndicatorUsingCaps(String user){
  ContactJabberImpl contact=ssclCallback.findContactById(StringUtils.parseBareAddress(user));
  if (contact == null)   return;
  int currentMostConnectedStatus=0;
  List<ContactResource> mostAvailableResources=new ArrayList<ContactResource>();
  for (  Map.Entry<String,ContactResourceJabberImpl> resEntry : contact.getResourcesMap().entrySet()) {
    ContactResourceJabberImpl res=resEntry.getValue();
    if (!res.getPresenceStatus().isOnline())     continue;
    boolean oldIndicator=res.isMobile();
    res.setMobile(isMobileResource(res.getResourceName(),res.getFullJid()));
    if (oldIndicator != res.isMobile()) {
      contact.fireContactResourceEvent(new ContactResourceEvent(contact,res,ContactResourceEvent.RESOURCE_MODIFIED));
    }
    int status=res.getPresenceStatus().getStatus();
    if (status > currentMostConnectedStatus) {
      if (currentMostConnectedStatus != status)       mostAvailableResources.clear();
      currentMostConnectedStatus=status;
      mostAvailableResources.add(res);
    }
  }
  boolean allMobile=false;
  for (  ContactResource res : mostAvailableResources) {
    if (res.isMobile())     allMobile=true;
 else {
      allMobile=false;
      break;
    }
  }
  if (mostAvailableResources.size() > 0)   contact.setMobile(allMobile);
 else   contact.setMobile(false);
}",0.7562833206397562
103074,"/** 
 * Updates the resources for the contact.
 * @param contact the contact which resources to update.
 * @param removeUnavailable whether to remove unavailable resources.
 */
private void updateResources(ContactJabberImpl contact,boolean removeUnavailable){
  if (!contact.isResolved() || (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl)contact).isPrivateMessagingContact()))   return;
  Map<String,ContactResourceJabberImpl> resources=contact.getResourcesMap();
  Iterator<Presence> it=parentProvider.getConnection().getRoster().getPresences(contact.getAddress());
  while (it.hasNext()) {
    Presence presence=it.next();
    String resource=StringUtils.parseResource(presence.getFrom());
    if (resource != null && resource.length() > 0) {
      String fullJid=presence.getFrom();
      ContactResourceJabberImpl contactResource=resources.get(fullJid);
      PresenceStatus newPresenceStatus=OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence,parentProvider);
      if (contactResource == null) {
        contactResource=new ContactResourceJabberImpl(fullJid,contact,resource,newPresenceStatus,presence.getPriority(),mobileIndicator.isMobileResource(resource,fullJid));
        resources.put(fullJid,contactResource);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_ADDED));
      }
 else {
        if (contactResource.getPresenceStatus().getStatus() != newPresenceStatus.getStatus()) {
          contactResource.setPresenceStatus(newPresenceStatus);
          contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_MODIFIED));
        }
      }
    }
  }
  if (!removeUnavailable)   return;
  Iterator<String> resourceIter=resources.keySet().iterator();
  while (resourceIter.hasNext()) {
    String fullJid=resourceIter.next();
    if (!parentProvider.getConnection().getRoster().getPresenceResource(fullJid).isAvailable()) {
      ContactResource removedResource=resources.get(fullJid);
      if (resources.containsKey(fullJid)) {
        resources.remove(fullJid);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,removedResource,ContactResourceEvent.RESOURCE_REMOVED));
      }
    }
  }
}","/** 
 * Updates the resources for the contact.
 * @param contact the contact which resources to update.
 * @param removeUnavailable whether to remove unavailable resources.
 */
private void updateResources(ContactJabberImpl contact,boolean removeUnavailable){
  if (!contact.isResolved() || (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl)contact).isPrivateMessagingContact()))   return;
  Map<String,ContactResourceJabberImpl> resources=contact.getResourcesMap();
  Iterator<Presence> it=parentProvider.getConnection().getRoster().getPresences(contact.getAddress());
  while (it.hasNext()) {
    Presence presence=it.next();
    String resource=StringUtils.parseResource(presence.getFrom());
    if (resource != null && resource.length() > 0) {
      String fullJid=presence.getFrom();
      ContactResourceJabberImpl contactResource=resources.get(fullJid);
      PresenceStatus newPresenceStatus=OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence,parentProvider);
      if (contactResource == null) {
        contactResource=new ContactResourceJabberImpl(fullJid,contact,resource,newPresenceStatus,presence.getPriority(),mobileIndicator.isMobileResource(resource,fullJid));
        resources.put(fullJid,contactResource);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_ADDED));
      }
 else {
        boolean oldIndicator=contactResource.isMobile();
        boolean newIndicator=mobileIndicator.isMobileResource(resource,fullJid);
        contactResource.setMobile(newIndicator);
        if (contactResource.getPresenceStatus().getStatus() != newPresenceStatus.getStatus() || (oldIndicator != newIndicator)) {
          contactResource.setPresenceStatus(newPresenceStatus);
          contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_MODIFIED));
        }
      }
    }
  }
  if (!removeUnavailable)   return;
  Iterator<String> resourceIter=resources.keySet().iterator();
  while (resourceIter.hasNext()) {
    String fullJid=resourceIter.next();
    if (!parentProvider.getConnection().getRoster().getPresenceResource(fullJid).isAvailable()) {
      ContactResource removedResource=resources.get(fullJid);
      if (resources.containsKey(fullJid)) {
        resources.remove(fullJid);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,removedResource,ContactResourceEvent.RESOURCE_REMOVED));
      }
    }
  }
}",0.9543671278133388
103075,"public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  if (evt.getOldStatus() == evt.getNewStatus())   return;
  final Contact sourceContact=evt.getSourceContact();
  final MetaContact metaContact=GuiActivator.getContactListService().findMetaContactByContact(sourceContact);
  if (metaContact == null)   return;
  boolean uiContactCreated=false;
  UIContactImpl uiContact;
synchronized (metaContact) {
    uiContact=getUIContact(metaContact);
    if (uiContact == null) {
      uiContact=createUIContact(metaContact);
      uiContactCreated=true;
    }
  }
  ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
  if (uiContactCreated) {
    if (currentFilter != null && currentFilter.isMatching(uiContact)) {
      MetaContactGroup parentGroup=metaContact.getParentMetaContactGroup();
      UIGroup uiGroup=null;
      if (!MetaContactListSource.isRootGroup(parentGroup)) {
synchronized (parentGroup) {
          uiGroup=MetaContactListSource.getUIGroup(parentGroup);
          if (uiGroup == null)           uiGroup=MetaContactListSource.createUIGroup(parentGroup);
        }
      }
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
      GuiActivator.getContactList().addContact(uiContact,uiGroup,true,true);
    }
 else     removeUIContact(metaContact);
  }
 else {
    if (currentFilter != null && !currentFilter.isMatching(uiContact)) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
      GuiActivator.getContactList().removeContact(uiContact);
    }
 else     GuiActivator.getContactList().nodeChanged(uiContact.getContactNode());
  }
}","public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  if (evt.getOldStatus() == evt.getNewStatus() && !evt.isResourceChanged()) {
    return;
  }
  final Contact sourceContact=evt.getSourceContact();
  final MetaContact metaContact=GuiActivator.getContactListService().findMetaContactByContact(sourceContact);
  if (metaContact == null)   return;
  boolean uiContactCreated=false;
  UIContactImpl uiContact;
synchronized (metaContact) {
    uiContact=getUIContact(metaContact);
    if (uiContact == null) {
      uiContact=createUIContact(metaContact);
      uiContactCreated=true;
    }
  }
  ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
  if (uiContactCreated) {
    if (currentFilter != null && currentFilter.isMatching(uiContact)) {
      MetaContactGroup parentGroup=metaContact.getParentMetaContactGroup();
      UIGroup uiGroup=null;
      if (!MetaContactListSource.isRootGroup(parentGroup)) {
synchronized (parentGroup) {
          uiGroup=MetaContactListSource.getUIGroup(parentGroup);
          if (uiGroup == null)           uiGroup=MetaContactListSource.createUIGroup(parentGroup);
        }
      }
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
      GuiActivator.getContactList().addContact(uiContact,uiGroup,true,true);
    }
 else     removeUIContact(metaContact);
  }
 else {
    if (currentFilter != null && !currentFilter.isMatching(uiContact)) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
      GuiActivator.getContactList().removeContact(uiContact);
    }
 else     GuiActivator.getContactList().nodeChanged(uiContact.getContactNode());
  }
}",0.9832175925925926
103076,"/** 
 * Fires the status change, respecting resource priorities.
 * @param presence the presence changed.
 */
void firePresenceStatusChanged(Presence presence){
  if (storeEvents && storedPresences != null) {
    storedPresences.add(presence);
    return;
  }
  try {
    String userID=StringUtils.parseBareAddress(presence.getFrom());
    List<ChatRoom> chatRooms=parentProvider.getOperationSet(OperationSetMultiUserChat.class).getCurrentlyJoinedChatRooms();
    for (    ChatRoom chatRoom : chatRooms) {
      if (chatRoom.getName().equals(userID)) {
        userID=presence.getFrom();
        break;
      }
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + userID);
    TreeSet<Presence> userStats=statuses.get(userID);
    if (userStats == null) {
      userStats=new TreeSet<Presence>(new Comparator<Presence>(){
        public int compare(        Presence o1,        Presence o2){
          int res=o2.getPriority() - o1.getPriority();
          if (res == 0) {
            res=jabberStatusToPresenceStatus(o2,parentProvider).getStatus() - jabberStatusToPresenceStatus(o1,parentProvider).getStatus();
          }
          return res;
        }
      }
);
      statuses.put(userID,userStats);
    }
 else {
      String resource=StringUtils.parseResource(presence.getFrom());
      for (Iterator<Presence> iter=userStats.iterator(); iter.hasNext(); ) {
        Presence p=iter.next();
        if (StringUtils.parseResource(p.getFrom()).equals(resource))         iter.remove();
      }
    }
    if (!jabberStatusToPresenceStatus(presence,parentProvider).equals(parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE))) {
      userStats.add(presence);
    }
    Presence currentPresence;
    if (userStats.size() == 0) {
      currentPresence=presence;
      statuses.remove(userID);
    }
 else     currentPresence=userStats.first();
    ContactJabberImpl sourceContact=ssContactList.findContactById(userID);
    if (sourceContact == null) {
      logger.warn(""String_Node_Str"" + userID);
      return;
    }
    sourceContact.setStatusMessage(currentPresence.getStatus());
    updateResources(sourceContact,true);
    mobileIndicator.resourcesUpdated(sourceContact);
    PresenceStatus oldStatus=sourceContact.getPresenceStatus();
    PresenceStatus newStatus=jabberStatusToPresenceStatus(currentPresence,parentProvider);
    if (oldStatus.equals(newStatus))     return;
    sourceContact.updatePresenceStatus(newStatus);
    ContactGroup parent=ssContactList.findContactGroup(sourceContact);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    fireContactPresenceStatusChangeEvent(sourceContact,parent,oldStatus,newStatus);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}","/** 
 * Fires the status change, respecting resource priorities.
 * @param presence the presence changed.
 */
void firePresenceStatusChanged(Presence presence){
  if (storeEvents && storedPresences != null) {
    storedPresences.add(presence);
    return;
  }
  try {
    String userID=StringUtils.parseBareAddress(presence.getFrom());
    List<ChatRoom> chatRooms=parentProvider.getOperationSet(OperationSetMultiUserChat.class).getCurrentlyJoinedChatRooms();
    for (    ChatRoom chatRoom : chatRooms) {
      if (chatRoom.getName().equals(userID)) {
        userID=presence.getFrom();
        break;
      }
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + userID);
    TreeSet<Presence> userStats=statuses.get(userID);
    if (userStats == null) {
      userStats=new TreeSet<Presence>(new Comparator<Presence>(){
        public int compare(        Presence o1,        Presence o2){
          int res=o2.getPriority() - o1.getPriority();
          if (res == 0) {
            res=jabberStatusToPresenceStatus(o2,parentProvider).getStatus() - jabberStatusToPresenceStatus(o1,parentProvider).getStatus();
          }
          return res;
        }
      }
);
      statuses.put(userID,userStats);
    }
 else {
      String resource=StringUtils.parseResource(presence.getFrom());
      for (Iterator<Presence> iter=userStats.iterator(); iter.hasNext(); ) {
        Presence p=iter.next();
        if (StringUtils.parseResource(p.getFrom()).equals(resource))         iter.remove();
      }
    }
    if (!jabberStatusToPresenceStatus(presence,parentProvider).equals(parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE))) {
      userStats.add(presence);
    }
    Presence currentPresence;
    if (userStats.size() == 0) {
      currentPresence=presence;
      statuses.remove(userID);
    }
 else     currentPresence=userStats.first();
    ContactJabberImpl sourceContact=ssContactList.findContactById(userID);
    if (sourceContact == null) {
      logger.warn(""String_Node_Str"" + userID);
      return;
    }
    sourceContact.setStatusMessage(currentPresence.getStatus());
    boolean oldMobileIndicator=sourceContact.isMobile();
    boolean resourceUpdated=updateResources(sourceContact,true);
    mobileIndicator.resourcesUpdated(sourceContact);
    PresenceStatus oldStatus=sourceContact.getPresenceStatus();
    PresenceStatus newStatus=jabberStatusToPresenceStatus(currentPresence,parentProvider);
    if (oldStatus.equals(newStatus) && oldMobileIndicator == sourceContact.isMobile()) {
      return;
    }
    sourceContact.updatePresenceStatus(newStatus);
    ContactGroup parent=ssContactList.findContactGroup(sourceContact);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    fireContactPresenceStatusChangeEvent(sourceContact,parent,oldStatus,newStatus,resourceUpdated);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.9689777928462452
103077,"/** 
 * Updates the resources for the contact.
 * @param contact the contact which resources to update.
 * @param removeUnavailable whether to remove unavailable resources.
 */
private void updateResources(ContactJabberImpl contact,boolean removeUnavailable){
  if (!contact.isResolved() || (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl)contact).isPrivateMessagingContact()))   return;
  Map<String,ContactResourceJabberImpl> resources=contact.getResourcesMap();
  Iterator<Presence> it=parentProvider.getConnection().getRoster().getPresences(contact.getAddress());
  while (it.hasNext()) {
    Presence presence=it.next();
    String resource=StringUtils.parseResource(presence.getFrom());
    if (resource != null && resource.length() > 0) {
      String fullJid=presence.getFrom();
      ContactResourceJabberImpl contactResource=resources.get(fullJid);
      PresenceStatus newPresenceStatus=OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence,parentProvider);
      if (contactResource == null) {
        contactResource=new ContactResourceJabberImpl(fullJid,contact,resource,newPresenceStatus,presence.getPriority(),mobileIndicator.isMobileResource(resource,fullJid));
        resources.put(fullJid,contactResource);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_ADDED));
      }
 else {
        boolean oldIndicator=contactResource.isMobile();
        boolean newIndicator=mobileIndicator.isMobileResource(resource,fullJid);
        contactResource.setMobile(newIndicator);
        if (contactResource.getPresenceStatus().getStatus() != newPresenceStatus.getStatus() || (oldIndicator != newIndicator)) {
          contactResource.setPresenceStatus(newPresenceStatus);
          contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_MODIFIED));
        }
      }
    }
  }
  if (!removeUnavailable)   return;
  Iterator<String> resourceIter=resources.keySet().iterator();
  while (resourceIter.hasNext()) {
    String fullJid=resourceIter.next();
    if (!parentProvider.getConnection().getRoster().getPresenceResource(fullJid).isAvailable()) {
      ContactResource removedResource=resources.get(fullJid);
      if (resources.containsKey(fullJid)) {
        resources.remove(fullJid);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,removedResource,ContactResourceEvent.RESOURCE_REMOVED));
      }
    }
  }
}","/** 
 * Updates the resources for the contact.
 * @param contact the contact which resources to update.
 * @param removeUnavailable whether to remove unavailable resources.
 * @return whether resource has been updated
 */
private boolean updateResources(ContactJabberImpl contact,boolean removeUnavailable){
  if (!contact.isResolved() || (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl)contact).isPrivateMessagingContact()))   return false;
  boolean eventFired=false;
  Map<String,ContactResourceJabberImpl> resources=contact.getResourcesMap();
  Iterator<Presence> it=parentProvider.getConnection().getRoster().getPresences(contact.getAddress());
  while (it.hasNext()) {
    Presence presence=it.next();
    String resource=StringUtils.parseResource(presence.getFrom());
    if (resource != null && resource.length() > 0) {
      String fullJid=presence.getFrom();
      ContactResourceJabberImpl contactResource=resources.get(fullJid);
      PresenceStatus newPresenceStatus=OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence,parentProvider);
      if (contactResource == null) {
        contactResource=new ContactResourceJabberImpl(fullJid,contact,resource,newPresenceStatus,presence.getPriority(),mobileIndicator.isMobileResource(resource,fullJid));
        resources.put(fullJid,contactResource);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_ADDED));
        eventFired=true;
      }
 else {
        boolean oldIndicator=contactResource.isMobile();
        boolean newIndicator=mobileIndicator.isMobileResource(resource,fullJid);
        int oldPriority=contactResource.getPriority();
        contactResource.setMobile(newIndicator);
        contactResource.setPriority(presence.getPriority());
        if (oldPriority != contactResource.getPriority()) {
          mobileIndicator.resourcesUpdated(contact);
        }
        if (contactResource.getPresenceStatus().getStatus() != newPresenceStatus.getStatus() || (oldIndicator != newIndicator) || (oldPriority != contactResource.getPriority())) {
          contactResource.setPresenceStatus(newPresenceStatus);
          contact.fireContactResourceEvent(new ContactResourceEvent(contact,contactResource,ContactResourceEvent.RESOURCE_MODIFIED));
          eventFired=true;
        }
      }
    }
  }
  if (!removeUnavailable)   return eventFired;
  Iterator<String> resourceIter=resources.keySet().iterator();
  while (resourceIter.hasNext()) {
    String fullJid=resourceIter.next();
    if (!parentProvider.getConnection().getRoster().getPresenceResource(fullJid).isAvailable()) {
      ContactResource removedResource=resources.get(fullJid);
      if (resources.containsKey(fullJid)) {
        resources.remove(fullJid);
        contact.fireContactResourceEvent(new ContactResourceEvent(contact,removedResource,ContactResourceEvent.RESOURCE_REMOVED));
        eventFired=true;
      }
    }
  }
  return eventFired;
}",0.8957431457431457
103078,"public void fireContactPresenceStatusChangeEvent(Contact source,ContactGroup parentGroup,PresenceStatus oldValue,PresenceStatus newValue){
  ContactPresenceStatusChangeEvent evt=new ContactPresenceStatusChangeEvent(source,parentProvider,parentGroup,oldValue,newValue);
  Collection<ContactPresenceStatusListener> listeners;
synchronized (contactPresenceStatusListeners) {
    listeners=new ArrayList<ContactPresenceStatusListener>(contactPresenceStatusListeners);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + listeners.size() + ""String_Node_Str""+ evt);
  for (  ContactPresenceStatusListener listener : listeners)   listener.contactPresenceStatusChanged(evt);
}","public void fireContactPresenceStatusChangeEvent(Contact source,ContactGroup parentGroup,PresenceStatus oldValue,PresenceStatus newValue,boolean isResourceChange){
  ContactPresenceStatusChangeEvent evt=new ContactPresenceStatusChangeEvent(source,parentProvider,parentGroup,oldValue,newValue,isResourceChange);
  Collection<ContactPresenceStatusListener> listeners;
synchronized (contactPresenceStatusListeners) {
    listeners=new ArrayList<ContactPresenceStatusListener>(contactPresenceStatusListeners);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + listeners.size() + ""String_Node_Str""+ evt);
  for (  ContactPresenceStatusListener listener : listeners)   listener.contactPresenceStatusChanged(evt);
}",0.9702970297029704
103079,"/** 
 * Creates an event instance indicating that the specified source contact has changed status from <tt>oldValue</tt> to <tt>newValue</tt>.
 * @param source the provider that generated the event
 * @param sourceProvider the protocol provider that the contact belongs to.
 * @param parentGroup the group containing the contact that caused thisevent (to be set as null in cases where groups are not supported);
 * @param oldValue the status the source countact was in before eneteringthe new state.
 * @param newValue the status the source contact is currently in.
 */
public ContactPresenceStatusChangeEvent(Contact source,ProtocolProviderService sourceProvider,ContactGroup parentGroup,PresenceStatus oldValue,PresenceStatus newValue){
  super(source,ContactPresenceStatusChangeEvent.class.getName(),oldValue,newValue);
  this.sourceProvider=sourceProvider;
  this.parentGroup=parentGroup;
}","/** 
 * Creates an event instance indicating that the specified source contact has changed status from <tt>oldValue</tt> to <tt>newValue</tt>.
 * @param source the provider that generated the event
 * @param sourceProvider the protocol provider that the contact belongs to.
 * @param parentGroup the group containing the contact that caused thisevent (to be set as null in cases where groups are not supported);
 * @param oldValue the status the source countact was in before eneteringthe new state.
 * @param newValue the status the source contact is currently in.
 */
public ContactPresenceStatusChangeEvent(Contact source,ProtocolProviderService sourceProvider,ContactGroup parentGroup,PresenceStatus oldValue,PresenceStatus newValue,boolean resourceChanged){
  super(source,ContactPresenceStatusChangeEvent.class.getName(),oldValue,newValue);
  this.sourceProvider=sourceProvider;
  this.parentGroup=parentGroup;
  this.resourceChanged=resourceChanged;
}",0.9654427645788336
103080,"/** 
 * Connects to the chosen server and creates a new account with Smack.
 * @param server the server domain
 * @param port TCP port to connect
 * @param username the account username
 * @param password the account password
 */
private boolean createJabberAccount(String server,int port,String username,String password){
  try {
    ConnectionConfiguration config=new ConnectionConfiguration(server,port);
    xmppConnection=new XMPPConnection(config);
    xmppConnection.connect();
    accountManager=new AccountManager(xmppConnection);
    accountManager.createAccount(username,password);
    return true;
  }
 catch (  XMPPException exc) {
    logger.error(exc);
    if (exc.getXMPPError().getCode() == 409) {
      showErrorMessage(Resources.getString(""String_Node_Str""));
      logger.error(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      showErrorMessage(Resources.getResources().getI18NString(""String_Node_Str"",new String[]{exc.getMessage()}));
    }
    return false;
  }
}","/** 
 * Connects to the chosen server and creates a new account with Smack.
 * @param server the server domain
 * @param port TCP port to connect
 * @param username the account username
 * @param password the account password
 */
private boolean createJabberAccount(String server,int port,String username,String password){
  try {
    ConnectionConfiguration config=new ConnectionConfiguration(server,port);
    xmppConnection=new XMPPConnection(config);
    xmppConnection.connect();
    accountManager=new AccountManager(xmppConnection);
    accountManager.createAccount(username,password);
    return true;
  }
 catch (  XMPPException exc) {
    logger.error(exc);
    if (exc.getXMPPError() != null && exc.getXMPPError().getCode() == 409) {
      showErrorMessage(Resources.getString(""String_Node_Str""));
      logger.error(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      showErrorMessage(Resources.getResources().getI18NString(""String_Node_Str"",new String[]{exc.getMessage()}));
    }
    return false;
  }
}",0.9851485148514852
103081,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String[] joinOptions;
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(addButton)) {
    String chatRoomName=editor.getText();
    if (StringUtils.isNullOrEmpty(chatRoomName))     return;
    ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName.trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
    chatRoomWrapper.getJoinOptions(true);
  }
 else   if (sourceButton.equals(removeButton)) {
    chatRoomsTableUI.removeSelectedRoom();
  }
 else   if (sourceButton.equals(okButton)) {
    ChatRoomWrapper selectedRoom=chatRoomsTableUI.getSelectedRoom();
    if (selectedRoom == null) {
      if (editor.getText() != null && editor.getText().trim().length() > 0) {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(editor.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,false);
        joinOptions=chatRoomWrapper.getJoinOptions();
        String nickName=joinOptions[0];
        subject=joinOptions[1];
        if (nickName == null)         return;
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,subject);
        ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
        ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
        chatWindowManager.openChat(chatPanel,true);
      }
    }
 else {
      if (selectedRoom.getChatRoom() != null) {
        if (!selectedRoom.getChatRoom().isJoined()) {
          String savedNick=ConfigurationUtils.getChatRoomProperty(selectedRoom.getParentProvider().getProtocolProvider(),selectedRoom.getChatRoomID(),""String_Node_Str"");
          if (savedNick == null) {
            joinOptions=selectedRoom.getJoinOptions();
            savedNick=joinOptions[0];
            subject=joinOptions[1];
            if (savedNick == null)             return;
          }
          GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(selectedRoom,savedNick,null,subject);
        }
 else         chatRoomsTableUI.openChatForSelection();
      }
 else {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(selectedRoom.getChatRoomName(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
        String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
        if (savedNick == null) {
          joinOptions=selectedRoom.getJoinOptions();
          savedNick=joinOptions[0];
          subject=joinOptions[1];
          if (savedNick == null)           return;
        }
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null,subject);
      }
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String[] joinOptions;
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(addButton)) {
    String chatRoomName=editor.getText();
    if (StringUtils.isNullOrEmpty(chatRoomName))     return;
    ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName.trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,true,true);
    chatRoomWrapper.getJoinOptions(true);
  }
 else   if (sourceButton.equals(removeButton)) {
    chatRoomsTableUI.removeSelectedRoom();
  }
 else   if (sourceButton.equals(okButton)) {
    ChatRoomWrapper selectedRoom=chatRoomsTableUI.getSelectedRoom();
    if (selectedRoom == null) {
      if (editor.getText() != null && editor.getText().trim().length() > 0) {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(editor.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,false);
        joinOptions=chatRoomWrapper.getJoinOptions();
        String nickName=joinOptions[0];
        subject=joinOptions[1];
        if (nickName == null)         return;
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,subject);
        ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
        ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
        chatWindowManager.openChat(chatPanel,true);
      }
    }
 else {
      if (selectedRoom.getChatRoom() != null) {
        if (!selectedRoom.getChatRoom().isJoined()) {
          String savedNick=ConfigurationUtils.getChatRoomProperty(selectedRoom.getParentProvider().getProtocolProvider(),selectedRoom.getChatRoomID(),""String_Node_Str"");
          if (savedNick == null) {
            joinOptions=selectedRoom.getJoinOptions();
            savedNick=joinOptions[0];
            subject=joinOptions[1];
            if (savedNick == null)             return;
          }
          GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(selectedRoom,savedNick,null,subject);
        }
 else         chatRoomsTableUI.openChatForSelection();
      }
 else {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(selectedRoom.getChatRoomName(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
        String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
        if (savedNick == null) {
          joinOptions=selectedRoom.getJoinOptions();
          savedNick=joinOptions[0];
          subject=joinOptions[1];
          if (savedNick == null)           return;
        }
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null,subject);
      }
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
}",0.9989440337909188
103082,"/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and makes the appropriate operations.
 * @param e the event.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  ConferenceChatManager conferenceManager=GuiActivator.getUIService().getConferenceChatManager();
  String[] joinOptions;
  String subject=null;
  if (itemName.equals(""String_Node_Str"")) {
    conferenceManager.removeChatRoom(chatRoomWrapper);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    conferenceManager.leaveChatRoom(chatRoomWrapper);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    String nickName=null;
    nickName=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
    if (nickName == null) {
      joinOptions=chatRoomWrapper.getJoinOptions();
      nickName=joinOptions[0];
      subject=joinOptions[1];
    }
    if (nickName != null)     conferenceManager.joinChatRoom(chatRoomWrapper,nickName,null,subject);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    if (chatRoomWrapper.getChatRoom() == null) {
      chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomWrapper.getChatRoomName(),chatRoomWrapper.getParentProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,true);
    }
    if (!chatRoomWrapper.getChatRoom().isJoined()) {
      String nickName=null;
      nickName=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
      if (nickName == null) {
        joinOptions=chatRoomWrapper.getJoinOptions();
        nickName=joinOptions[0];
        subject=joinOptions[1];
      }
      if (nickName != null)       conferenceManager.joinChatRoom(chatRoomWrapper,nickName,null,subject);
 else       return;
    }
    ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
    ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
    chatWindowManager.openChat(chatPanel,true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    joinOptions=chatRoomWrapper.getJoinOptions();
    if (joinOptions[0] == null)     return;
    GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,joinOptions[0],null,joinOptions[1]);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    chatRoomWrapper.getJoinOptions(true);
  }
}","/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and makes the appropriate operations.
 * @param e the event.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  ConferenceChatManager conferenceManager=GuiActivator.getUIService().getConferenceChatManager();
  String[] joinOptions;
  String subject=null;
  if (itemName.equals(""String_Node_Str"")) {
    conferenceManager.removeChatRoom(chatRoomWrapper);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    conferenceManager.leaveChatRoom(chatRoomWrapper);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    String nickName=null;
    nickName=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
    if (nickName == null) {
      joinOptions=chatRoomWrapper.getJoinOptions();
      nickName=joinOptions[0];
      subject=joinOptions[1];
    }
    if (nickName != null)     conferenceManager.joinChatRoom(chatRoomWrapper,nickName,null,subject);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    if (chatRoomWrapper.getChatRoom() == null) {
      chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomWrapper.getChatRoomName(),chatRoomWrapper.getParentProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
    }
    if (!chatRoomWrapper.getChatRoom().isJoined()) {
      String nickName=null;
      nickName=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
      if (nickName == null) {
        joinOptions=chatRoomWrapper.getJoinOptions();
        nickName=joinOptions[0];
        subject=joinOptions[1];
      }
      if (nickName != null)       conferenceManager.joinChatRoom(chatRoomWrapper,nickName,null,subject);
 else       return;
    }
    ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
    ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
    chatWindowManager.openChat(chatPanel,true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    joinOptions=chatRoomWrapper.getJoinOptions();
    if (joinOptions[0] == null)     return;
    GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,joinOptions[0],null,joinOptions[1]);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    chatRoomWrapper.getJoinOptions(true);
  }
}",0.9988434849653044
103083,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String[] joinOptions;
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(addButton)) {
    String chatRoomName=editor.getText();
    if (StringUtils.isNullOrEmpty(chatRoomName))     return;
    ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName.trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,true);
    chatRoomWrapper.getJoinOptions(true);
  }
 else   if (sourceButton.equals(removeButton)) {
    chatRoomsTableUI.removeSelectedRoom();
  }
 else   if (sourceButton.equals(okButton)) {
    ChatRoomWrapper selectedRoom=chatRoomsTableUI.getSelectedRoom();
    if (selectedRoom == null) {
      if (editor.getText() != null && editor.getText().trim().length() > 0) {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(editor.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false);
        joinOptions=chatRoomWrapper.getJoinOptions();
        String nickName=joinOptions[0];
        subject=joinOptions[1];
        if (nickName == null)         return;
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,subject);
        ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
        ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
        chatWindowManager.openChat(chatPanel,true);
      }
    }
 else {
      if (selectedRoom.getChatRoom() != null) {
        if (!selectedRoom.getChatRoom().isJoined()) {
          String savedNick=ConfigurationUtils.getChatRoomProperty(selectedRoom.getParentProvider().getProtocolProvider(),selectedRoom.getChatRoomID(),""String_Node_Str"");
          if (savedNick == null) {
            joinOptions=selectedRoom.getJoinOptions();
            savedNick=joinOptions[0];
            subject=joinOptions[1];
            if (savedNick == null)             return;
          }
          GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(selectedRoom,savedNick,null,subject);
        }
 else         chatRoomsTableUI.openChatForSelection();
      }
 else {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(selectedRoom.getChatRoomName(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,true);
        String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
        if (savedNick == null) {
          joinOptions=selectedRoom.getJoinOptions();
          savedNick=joinOptions[0];
          subject=joinOptions[1];
          if (savedNick == null)           return;
        }
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null,subject);
      }
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 * @param e the action event.
 */
public void actionPerformed(ActionEvent e){
  String[] joinOptions;
  String subject=null;
  JButton sourceButton=(JButton)e.getSource();
  if (sourceButton.equals(addButton)) {
    String chatRoomName=editor.getText();
    if (StringUtils.isNullOrEmpty(chatRoomName))     return;
    ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName.trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
    chatRoomWrapper.getJoinOptions(true);
  }
 else   if (sourceButton.equals(removeButton)) {
    chatRoomsTableUI.removeSelectedRoom();
  }
 else   if (sourceButton.equals(okButton)) {
    ChatRoomWrapper selectedRoom=chatRoomsTableUI.getSelectedRoom();
    if (selectedRoom == null) {
      if (editor.getText() != null && editor.getText().trim().length() > 0) {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(editor.getText().trim(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,false);
        joinOptions=chatRoomWrapper.getJoinOptions();
        String nickName=joinOptions[0];
        subject=joinOptions[1];
        if (nickName == null)         return;
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,subject);
        ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
        ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
        chatWindowManager.openChat(chatPanel,true);
      }
    }
 else {
      if (selectedRoom.getChatRoom() != null) {
        if (!selectedRoom.getChatRoom().isJoined()) {
          String savedNick=ConfigurationUtils.getChatRoomProperty(selectedRoom.getParentProvider().getProtocolProvider(),selectedRoom.getChatRoomID(),""String_Node_Str"");
          if (savedNick == null) {
            joinOptions=selectedRoom.getJoinOptions();
            savedNick=joinOptions[0];
            subject=joinOptions[1];
            if (savedNick == null)             return;
          }
          GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(selectedRoom,savedNick,null,subject);
        }
 else         chatRoomsTableUI.openChatForSelection();
      }
 else {
        ChatRoomWrapper chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(selectedRoom.getChatRoomName(),getSelectedProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
        String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
        if (savedNick == null) {
          joinOptions=selectedRoom.getJoinOptions();
          savedNick=joinOptions[0];
          subject=joinOptions[1];
          if (savedNick == null)           return;
        }
        GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null,subject);
      }
    }
    dispose();
  }
 else   if (sourceButton.equals(cancelButton)) {
    dispose();
  }
}",0.9972776769509982
103084,"/** 
 * Opens the currently selected chat.
 */
void openChatForSelection(){
  Object selectedValue=this.chatRoomsTableModel.getValueAt(this.chatRoomList.getSelectedRow());
  ChatRoomWrapper chatRoomWrapper;
  if (selectedValue instanceof ChatRoomWrapper)   chatRoomWrapper=(ChatRoomWrapper)selectedValue;
 else   return;
  if (chatRoomWrapper.getChatRoom() == null) {
    chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomWrapper.getChatRoomName(),chatRoomWrapper.getParentProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,true);
    if (chatRoomWrapper.getChatRoom().isJoined())     chatRoomWrapper.getChatRoom().leave();
    this.chatRoomsTableModel.setValueAt(chatRoomWrapper,this.chatRoomList.getSelectedRow(),this.chatRoomList.getSelectedColumn());
  }
  String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
  if (savedNick == null) {
    String[] joinOptions=chatRoomWrapper.getJoinOptions();
    String nickName=joinOptions[0];
    if (nickName == null)     return;
    if (!chatRoomWrapper.getChatRoom().isJoined()) {
      GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,joinOptions[1]);
    }
  }
 else {
    if (!chatRoomWrapper.getChatRoom().isJoined())     GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null);
  }
  ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
  ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
  chatWindowManager.openChat(chatPanel,true);
}","/** 
 * Opens the currently selected chat.
 */
void openChatForSelection(){
  Object selectedValue=this.chatRoomsTableModel.getValueAt(this.chatRoomList.getSelectedRow());
  ChatRoomWrapper chatRoomWrapper;
  if (selectedValue instanceof ChatRoomWrapper)   chatRoomWrapper=(ChatRoomWrapper)selectedValue;
 else   return;
  if (chatRoomWrapper.getChatRoom() == null) {
    chatRoomWrapper=GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomWrapper.getChatRoomName(),chatRoomWrapper.getParentProvider().getProtocolProvider(),new ArrayList<String>(),""String_Node_Str"",false,false,true);
    if (chatRoomWrapper.getChatRoom().isJoined())     chatRoomWrapper.getChatRoom().leave();
    this.chatRoomsTableModel.setValueAt(chatRoomWrapper,this.chatRoomList.getSelectedRow(),this.chatRoomList.getSelectedColumn());
  }
  String savedNick=ConfigurationUtils.getChatRoomProperty(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),""String_Node_Str"");
  if (savedNick == null) {
    String[] joinOptions=chatRoomWrapper.getJoinOptions();
    String nickName=joinOptions[0];
    if (nickName == null)     return;
    if (!chatRoomWrapper.getChatRoom().isJoined()) {
      GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,nickName,null,joinOptions[1]);
    }
  }
 else {
    if (!chatRoomWrapper.getChatRoom().isJoined())     GuiActivator.getUIService().getConferenceChatManager().joinChatRoom(chatRoomWrapper,savedNick,null);
  }
  ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
  ChatPanel chatPanel=chatWindowManager.getMultiChat(chatRoomWrapper,true);
  chatWindowManager.openChat(chatPanel,true);
}",0.9982648930017352
103085,"/** 
 * Creates an account.
 * @return the created account
 */
public NewAccount createAccount(){
  String userID=userIDField.getText();
  char[] password=passField.getPassword();
  char[] password2=pass2Field.getPassword();
  String server=serverField.getText();
  String port=portField.getText();
  if (new String(password).equals(new String(password2))) {
    boolean result=createJabberAccount(server,5222,userID,new String(password));
    if (result == true) {
      return new NewAccount(getCompleteUserID(userID,server),password,server,port);
    }
  }
 else {
    showErrorMessage(Resources.getString(""String_Node_Str""));
  }
  return null;
}","/** 
 * Creates an account.
 * @return the created account
 */
public NewAccount createAccount(){
  String userID=userIDField.getText();
  char[] password=passField.getPassword();
  char[] password2=pass2Field.getPassword();
  String server=serverField.getText();
  int port=5222;
  try {
    port=Integer.parseInt(portField.getText());
  }
 catch (  NumberFormatException e) {
  }
  if (new String(password).equals(new String(password2))) {
    boolean result=createJabberAccount(server,port,userID,new String(password));
    if (result == true) {
      return new NewAccount(getCompleteUserID(userID,server),password,server,String.valueOf(port));
    }
  }
 else {
    showErrorMessage(Resources.getString(""String_Node_Str""));
  }
  return null;
}",0.7248034310221587
103086,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode reason code in case of reconnect.
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority,int reasonCode) throws OperationFailedException {
synchronized (initializationLock) {
    ProtocolProviderFactoryIcqImpl protocolProviderFactory=null;
    if (USING_ICQ)     protocolProviderFactory=IcqActivator.getIcqProtocolProviderFactory();
 else     protocolProviderFactory=IcqActivator.getAimProtocolProviderFactory();
    String password=protocolProviderFactory.loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(this.getAccountID().getUserID());
      credentials=authority.obtainCredentials(accountID.getDisplayName(),credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        protocolProviderFactory.storePassword(getAccountID(),password);
      }
    }
    if (USING_ICQ && password.length() > 8)     password=password.substring(0,8);
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(getAccountID().getUserID()));
    String globalProxyType=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
    if (globalProxyType != null && globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
      String globalProxyAddress=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
      String globalProxyPortStr=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
      int proxyPort;
      try {
        proxyPort=Integer.parseInt(globalProxyPortStr);
      }
 catch (      NumberFormatException ex) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
      }
      String globalProxyUsername=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
      String globalProxyPassword=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
      if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
      }
      AimConnectionProperties connProps=new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password);
      if (USING_ICQ)       connProps.setLoginHost(ICQ_DEFAULT_LOGIN_SERVER);
 else       connProps.setLoginHost(AIM_DEFAULT_LOGIN_SERVER);
      connProps.setLoginPort(443);
      aimConnection=aimSession.openConnection(connProps);
      aimConnection.setProxy(AimProxyInfo.forHttp(globalProxyAddress,proxyPort,globalProxyUsername,globalProxyPassword));
    }
 else {
      AimConnectionProperties connProps=new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password);
      if (USING_ICQ)       connProps.setLoginHost(ICQ_DEFAULT_LOGIN_SERVER);
 else       connProps.setLoginHost(AIM_DEFAULT_LOGIN_SERVER);
      aimConnection=aimSession.openConnection(connProps);
    }
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimConnection.connect();
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode reason code in case of reconnect.
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority,int reasonCode) throws OperationFailedException {
synchronized (initializationLock) {
    ProtocolProviderFactoryIcqImpl protocolProviderFactory=null;
    if (USING_ICQ)     protocolProviderFactory=IcqActivator.getIcqProtocolProviderFactory();
 else     protocolProviderFactory=IcqActivator.getAimProtocolProviderFactory();
    String password=protocolProviderFactory.loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(this.getAccountID().getUserID());
      credentials=authority.obtainCredentials(accountID.getDisplayName(),credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        protocolProviderFactory.storePassword(getAccountID(),password);
      }
    }
    if (USING_ICQ && password.length() > 8)     password=password.substring(0,8);
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(getAccountID().getUserID()));
    String globalProxyType=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);
    if (globalProxyType != null && globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
      String globalProxyAddress=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);
      String globalProxyPortStr=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);
      int proxyPort;
      try {
        proxyPort=Integer.parseInt(globalProxyPortStr);
      }
 catch (      NumberFormatException ex) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
      }
      String globalProxyUsername=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
      String globalProxyPassword=IcqActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
      if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
      }
      AimConnectionProperties connProps=new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password);
      if (USING_ICQ)       connProps.setLoginHost(ICQ_DEFAULT_LOGIN_SERVER);
 else       connProps.setLoginHost(AIM_DEFAULT_LOGIN_SERVER);
      connProps.setLoginPort(443);
      aimConnection=aimSession.openConnection(connProps);
      aimConnection.setProxy(AimProxyInfo.forHttp(globalProxyAddress,proxyPort,globalProxyUsername,globalProxyPassword));
    }
 else {
      AimConnectionProperties connProps=new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password);
      if (USING_ICQ)       connProps.setLoginHost(ICQ_DEFAULT_LOGIN_SERVER);
 else       connProps.setLoginHost(AIM_DEFAULT_LOGIN_SERVER);
      aimConnection=aimSession.openConnection(connProps);
    }
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimConnection.connect();
  }
}",0.9993662061097732
103087,"/** 
 * Sets the global proxy information based on the configuration
 * @throws OperationFailedException
 */
private void loadProxy() throws OperationFailedException {
  String globalProxyType=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
  if (globalProxyType == null || globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
    proxy=org.jivesoftware.smack.proxy.ProxyInfo.forNoProxy();
  }
 else {
    String globalProxyAddress=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
    String globalProxyPortStr=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
    int globalProxyPort;
    try {
      globalProxyPort=Integer.parseInt(globalProxyPortStr);
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"" + globalProxyPortStr + ""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
    String globalProxyUsername=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
    String globalProxyPassword=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
    if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
    }
    try {
      proxy=new org.jivesoftware.smack.proxy.ProxyInfo(Enum.valueOf(org.jivesoftware.smack.proxy.ProxyInfo.ProxyType.class,globalProxyType),globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
    }
 catch (    IllegalArgumentException e) {
      logger.error(""String_Node_Str"",e);
      proxy=null;
    }
  }
}","/** 
 * Sets the global proxy information based on the configuration
 * @throws OperationFailedException
 */
private void loadProxy() throws OperationFailedException {
  String globalProxyType=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);
  if (globalProxyType == null || globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
    proxy=org.jivesoftware.smack.proxy.ProxyInfo.forNoProxy();
  }
 else {
    String globalProxyAddress=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);
    String globalProxyPortStr=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);
    int globalProxyPort;
    try {
      globalProxyPort=Integer.parseInt(globalProxyPortStr);
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"" + globalProxyPortStr + ""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
    String globalProxyUsername=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
    String globalProxyPassword=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
    if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
    }
    try {
      proxy=new org.jivesoftware.smack.proxy.ProxyInfo(Enum.valueOf(org.jivesoftware.smack.proxy.ProxyInfo.ProxyType.class,globalProxyType),globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
    }
 catch (    IllegalArgumentException e) {
      logger.error(""String_Node_Str"",e);
      proxy=null;
    }
  }
}",0.9986357435197816
103088,"/** 
 * Function which save values onto configuration file after save button is clicked
 */
private void saveValues(){
  ConfigurationService configService=GlobalProxyPluginActivator.getConfigurationService();
  if (typeCombo.getSelectedItem().equals(ProxyInfo.ProxyType.NONE)) {
    configService.setProperty(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME,ProxyInfo.ProxyType.NONE.name());
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
    return;
  }
  configService.setProperty(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME,((ProxyInfo.ProxyType)typeCombo.getSelectedItem()).name());
  String serverAddress=serverAddressField.getText();
  if (serverAddress != null && serverAddress.length() > 0)   configService.setProperty(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME,serverAddress);
  String port=portField.getText();
  if (port != null && port.length() > 0)   configService.setProperty(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME,port);
  String username=usernameField.getText();
  if (username != null && username.length() > 0) {
    configService.setProperty(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME,username);
  }
 else {
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
  }
  char[] password=passwordField.getPassword();
  if (password.length > 0) {
    configService.setProperty(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME,new String(password));
  }
 else {
    configService.removeProperty(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
  }
  GlobalProxyPluginActivator.initProperties();
}","/** 
 * Function which save values onto configuration file after save button is clicked
 */
private void saveValues(){
  ConfigurationService configService=GlobalProxyPluginActivator.getConfigurationService();
  if (typeCombo.getSelectedItem().equals(ProxyInfo.ProxyType.NONE)) {
    configService.setProperty(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME,ProxyInfo.ProxyType.NONE.name());
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
    return;
  }
  configService.setProperty(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME,((ProxyInfo.ProxyType)typeCombo.getSelectedItem()).name());
  String serverAddress=serverAddressField.getText();
  if (serverAddress != null && serverAddress.length() > 0)   configService.setProperty(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME,serverAddress);
  String port=portField.getText();
  if (port != null && port.length() > 0)   configService.setProperty(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME,port);
  String username=usernameField.getText();
  if (username != null && username.length() > 0) {
    configService.setProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME,username);
  }
 else {
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
  }
  char[] password=passwordField.getPassword();
  if (password.length > 0) {
    configService.setProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME,new String(password));
  }
 else {
    configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
  }
  GlobalProxyPluginActivator.initProperties();
}",0.9967479674796748
103089,"/** 
 * Loading the values stored onto configuration form
 */
private void loadValues(){
  ConfigurationService configService=GlobalProxyPluginActivator.getConfigurationService();
  String serverAddress=configService.getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
  if (serverAddress != null)   serverAddressField.setText(serverAddress);
  String port=configService.getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
  if (port != null)   portField.setText(port);
  String username=configService.getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
  if (username != null)   usernameField.setText(username);
  String password=configService.getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
  if (password != null)   passwordField.setText(password);
  try {
    String type=configService.getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
    if (type != null)     typeCombo.setSelectedItem(ProxyInfo.ProxyType.valueOf(type));
  }
 catch (  IllegalArgumentException e) {
  }
  if (typeCombo.getSelectedItem().equals(ProxyInfo.ProxyType.NONE)) {
    serverAddressField.setEnabled(false);
    portField.setEnabled(false);
    usernameField.setEnabled(false);
    passwordField.setEnabled(false);
  }
}","/** 
 * Loading the values stored onto configuration form
 */
private void loadValues(){
  ConfigurationService configService=GlobalProxyPluginActivator.getConfigurationService();
  String serverAddress=configService.getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);
  if (serverAddress != null)   serverAddressField.setText(serverAddress);
  String port=configService.getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);
  if (port != null)   portField.setText(port);
  String username=configService.getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
  if (username != null)   usernameField.setText(username);
  String password=configService.getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
  if (password != null)   passwordField.setText(password);
  try {
    String type=configService.getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);
    if (type != null)     typeCombo.setSelectedItem(ProxyInfo.ProxyType.valueOf(type));
  }
 catch (  IllegalArgumentException e) {
  }
  if (typeCombo.getSelectedItem().equals(ProxyInfo.ProxyType.NONE)) {
    serverAddressField.setEnabled(false);
    portField.setEnabled(false);
    usernameField.setEnabled(false);
    passwordField.setEnabled(false);
  }
}",0.9979911611088792
103090,"/** 
 * Init system properties that corresponds to proxy settings.
 */
static void initProperties(){
  String globalProxyType=getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
  if (globalProxyType != null && !globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
    String globalProxyAddress=getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
    String globalProxyPortStr=getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
    int globalProxyPort=-1;
    try {
      globalProxyPort=Integer.parseInt(globalProxyPortStr);
    }
 catch (    NumberFormatException ex) {
    }
    String globalProxyUsername=getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
    String globalProxyPassword=getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
    if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
      return;
    }
    String type=null;
    if (globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
      type=""String_Node_Str"";
      System.setProperty(""String_Node_Str"",globalProxyAddress);
      if (globalProxyPortStr != null) {
        System.setProperty(""String_Node_Str"",globalProxyPortStr);
      }
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS4.name()) || globalProxyType.equals(ProxyInfo.ProxyType.SOCKS5.name())) {
      type=""String_Node_Str"";
      System.setProperty(""String_Node_Str"",globalProxyAddress);
      if (globalProxyPortStr != null) {
        System.setProperty(""String_Node_Str"",globalProxyPortStr);
      }
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    Authenticator.setDefault(new AuthenticatorImpl(globalProxyAddress,globalProxyPort,type,globalProxyUsername,globalProxyPassword));
  }
 else   Authenticator.setDefault(null);
}","/** 
 * Init system properties that corresponds to proxy settings.
 */
static void initProperties(){
  String globalProxyType=getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);
  if (globalProxyType != null && !globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
    String globalProxyAddress=getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);
    String globalProxyPortStr=getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);
    int globalProxyPort=-1;
    try {
      globalProxyPort=Integer.parseInt(globalProxyPortStr);
    }
 catch (    NumberFormatException ex) {
    }
    String globalProxyUsername=getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);
    String globalProxyPassword=getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);
    if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
      return;
    }
    String type=null;
    if (globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
      type=""String_Node_Str"";
      System.setProperty(""String_Node_Str"",globalProxyAddress);
      if (globalProxyPortStr != null) {
        System.setProperty(""String_Node_Str"",globalProxyPortStr);
      }
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS4.name()) || globalProxyType.equals(ProxyInfo.ProxyType.SOCKS5.name())) {
      type=""String_Node_Str"";
      System.setProperty(""String_Node_Str"",globalProxyAddress);
      if (globalProxyPortStr != null) {
        System.setProperty(""String_Node_Str"",globalProxyPortStr);
      }
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    Authenticator.setDefault(new AuthenticatorImpl(globalProxyAddress,globalProxyPort,type,globalProxyUsername,globalProxyPassword));
  }
 else   Authenticator.setDefault(null);
}",0.998731930002536
103091,"/** 
 * Creates a new   {@link Lookup} instance using our own {@link ParallelResolverImpl} if it is enabled and DNSSEC is not active.
 * @param domain the domain we will be resolving
 * @param type the type of the record we will be trying to obtain.
 * @return the newly created {@link Lookup} instance.
 * @throws TextParseException if <tt>domain</tt> is not a valid domain name.
 */
private static Lookup createLookup(String domain,int type) throws TextParseException {
  if (UtilActivator.getConfigurationService().getBoolean(PNAME_DNS_ALWAYS_ABSOLUTE,PDEFAULT_DNS_ALWAYS_ABSOLUTE)) {
    if (!Name.fromString(domain).isAbsolute())     domain=domain + ""String_Node_Str"";
  }
  Lookup lookup=new Lookup(domain,type);
  if (logger.isTraceEnabled()) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    for (    String s : ResolverConfig.getCurrentConfig().servers()) {
      sb.append(s);
      sb.append(""String_Node_Str"");
    }
    logger.trace(sb.toString());
  }
  return lookup;
}","/** 
 * Creates a new   {@link Lookup} instance.
 * @param domain the domain we will be resolving
 * @param type the type of the record we will be trying to obtain.
 * @return the newly created {@link Lookup} instance.
 * @throws TextParseException if <tt>domain</tt> is not a valid domain name.
 */
private static Lookup createLookup(String domain,int type) throws TextParseException {
  if (UtilActivator.getConfigurationService().getBoolean(PNAME_DNS_ALWAYS_ABSOLUTE,PDEFAULT_DNS_ALWAYS_ABSOLUTE)) {
    if (!Name.fromString(domain).isAbsolute())     domain=domain + ""String_Node_Str"";
  }
  Lookup lookup=new Lookup(domain,type);
  if (logger.isTraceEnabled()) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    for (    String s : ResolverConfig.getCurrentConfig().servers()) {
      sb.append(s);
      sb.append(""String_Node_Str"");
    }
    logger.trace(sb.toString());
  }
  return lookup;
}",0.9563430919363124
103092,"/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public OperationSetAutoAnswerJabberImpl(ProtocolProviderServiceJabberImpl protocolProvider){
  super(protocolProvider);
}","/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public OperationSetAutoAnswerJabberImpl(ProtocolProviderServiceJabberImpl protocolProvider){
  super(protocolProvider);
  this.load();
}",0.9734513274336284
103093,"/** 
 * Makes a check after creating call locally, should we answer it.
 * @param call The new incoming call to auto-answer if needed.
 * @param isVideoCall Indicates if the remote peer which has created thiscall wish to have a video call.
 * @return <tt>true</tt> if we have processed and no further processing isneeded, <tt>false</tt> otherwise.
 */
public boolean autoAnswer(Call call){
  if (answerUnconditional || satisfyAutoAnswerConditions(call)) {
    boolean isVideoCall=doesRequestContainsActiveVideoMediaType(call);
    this.answerCall(call,isVideoCall);
    return true;
  }
  return false;
}","/** 
 * Makes a check after creating call locally, should we answer it.
 * @param call The new incoming call to auto-answer if needed.
 * @return <tt>true</tt> if we have processed and no further processing isneeded, <tt>false</tt> otherwise.
 */
public boolean autoAnswer(Call call){
  if (answerUnconditional || satisfyAutoAnswerConditions(call)) {
    boolean isVideoCall=doesRequestContainsActiveVideoMediaType(call);
    this.answerCall(call,isVideoCall);
    return true;
  }
  return false;
}",0.9048050770625566
103094,"/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public OperationSetAutoAnswerSipImpl(ProtocolProviderServiceSipImpl protocolProvider){
  super(protocolProvider);
}","/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public OperationSetAutoAnswerSipImpl(ProtocolProviderServiceSipImpl protocolProvider){
  super(protocolProvider);
  this.load();
}",0.972875226039783
103095,"/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public AbstractOperationSetBasicAutoAnswer(ProtocolProviderService protocolProvider){
  this.protocolProvider=protocolProvider;
  load();
}","/** 
 * Creates this operation set, loads stored values, populating local variable settings.
 * @param protocolProvider the parent Protocol Provider.
 */
public AbstractOperationSetBasicAutoAnswer(ProtocolProviderService protocolProvider){
  this.protocolProvider=protocolProvider;
}",0.9826388888888888
103096,"/** 
 * Adds a <tt>user</tt> element to <tt>confInfo</tt> which describes <tt>callPeer</tt>, or the local peer if <tt>remote</tt> is <tt>false</tt>.
 * @param confInfo the <tt>ConferenceInformationDocument</tt> to which toadd a <tt>user</tt> element
 * @param callPeer the <tt>CallPeer</tt> which should be described
 * @param remote <tt>true</tt> to describe <tt>callPeer</tt>, or<tt>false</tt> to describe the local peer.
 */
private void addPeerToConferenceInfo(ConferenceInfoDocument confInfo,MediaAwareCallPeer<?,?,?> callPeer,boolean remote){
  String entity=remote ? callPeer.getEntity() : getLocalEntity(callPeer);
  ConferenceInfoDocument.User user=confInfo.addNewUser(entity);
  String displayName=remote ? callPeer.getDisplayName() : getLocalDisplayName();
  user.setDisplayText(displayName);
  ConferenceInfoDocument.Endpoint endpoint=user.addNewEndpoint(entity);
  endpoint.setStatus(remote ? getEndpointStatus(callPeer) : ConferenceInfoDocument.EndpointStatusType.connected);
  CallPeerMediaHandler<?> mediaHandler=callPeer.getMediaHandler();
  for (  MediaType mediaType : MediaType.values()) {
    MediaStream stream=mediaHandler.getStream(mediaType);
    if (stream != null) {
      ConferenceInfoDocument.Media media=endpoint.addNewMedia(mediaType.toString());
      long srcId=remote ? getRemoteSourceID(callPeer,mediaType) : stream.getLocalSourceID();
      if (srcId != -1)       media.setSrcId(Long.toString(srcId));
      media.setType(mediaType.toString());
      MediaDirection direction=MediaDirection.INACTIVE;
      if (remote)       direction=callPeer.getDirection(mediaType).getReverseDirection();
 else {
        if (mediaType == MediaType.AUDIO && callPeer.getMediaHandler().isLocalAudioTransmissionEnabled())         direction=direction.or(MediaDirection.SENDONLY);
 else         if (mediaType == MediaType.VIDEO && callPeer.isLocalVideoStreaming())         direction=direction.or(MediaDirection.SENDONLY);
        if (callPeer.getDirection(mediaType).allowsReceiving())         direction=direction.or(MediaDirection.RECVONLY);
      }
      if (direction == null)       direction=MediaDirection.INACTIVE;
      media.setStatus(direction.toString());
    }
  }
}","/** 
 * Adds a <tt>user</tt> element to <tt>confInfo</tt> which describes <tt>callPeer</tt>, or the local peer if <tt>remote</tt> is <tt>false</tt>.
 * @param confInfo the <tt>ConferenceInformationDocument</tt> to which toadd a <tt>user</tt> element
 * @param callPeer the <tt>CallPeer</tt> which should be described
 * @param remote <tt>true</tt> to describe <tt>callPeer</tt>, or<tt>false</tt> to describe the local peer.
 */
private void addPeerToConferenceInfo(ConferenceInfoDocument confInfo,MediaAwareCallPeer<?,?,?> callPeer,boolean remote){
  String entity=remote ? callPeer.getEntity() : getLocalEntity(callPeer);
  ConferenceInfoDocument.User user=confInfo.addNewUser(entity);
  String displayName=remote ? callPeer.getDisplayName() : getLocalDisplayName();
  user.setDisplayText(displayName);
  ConferenceInfoDocument.Endpoint endpoint=user.addNewEndpoint(entity);
  endpoint.setStatus(remote ? getEndpointStatus(callPeer) : ConferenceInfoDocument.EndpointStatusType.connected);
  CallPeerMediaHandler<?> mediaHandler=callPeer.getMediaHandler();
  for (  MediaType mediaType : MediaType.values()) {
    MediaStream stream=mediaHandler.getStream(mediaType);
    if (stream != null || !remote) {
      long srcId=-1;
      if (remote)       srcId=getRemoteSourceID(callPeer,mediaType);
 else       if (stream != null) {
        srcId=stream.getLocalSourceID();
      }
 else {
        for (        MediaAwareCallPeer otherCallPeer : callPeer.getCall().getCallPeerList()) {
          MediaStream otherStream=otherCallPeer.getMediaHandler().getStream(mediaType);
          if (otherStream != null) {
            srcId=otherStream.getLocalSourceID();
            break;
          }
        }
      }
      MediaDirection direction=MediaDirection.INACTIVE;
      if (remote)       direction=callPeer.getDirection(mediaType).getReverseDirection();
 else {
        if (mediaType == MediaType.AUDIO && callPeer.getMediaHandler().isLocalAudioTransmissionEnabled())         direction=direction.or(MediaDirection.SENDONLY);
 else         if (mediaType == MediaType.VIDEO && callPeer.isLocalVideoStreaming())         direction=direction.or(MediaDirection.SENDONLY);
        if (callPeer.getDirection(mediaType).allowsReceiving())         direction=direction.or(MediaDirection.RECVONLY);
      }
      if ((srcId != -1) || (direction != MediaDirection.INACTIVE)) {
        ConferenceInfoDocument.Media media=endpoint.addNewMedia(mediaType.toString());
        media.setType(mediaType.toString());
        if (srcId != -1)         media.setSrcId(Long.toString(srcId));
        media.setStatus(direction.toString());
      }
    }
  }
}",0.7973476999585578
103097,"/** 
 * Processes the content-modify   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer wants to be modified
 */
public void processContentModify(JingleIQ content){
  ContentPacketExtension ext=content.getContentList().get(0);
  MediaType mediaType=getMediaType(ext);
  try {
    boolean modify=(ext.getFirstChildOfType(RtpDescriptionPacketExtension.class) != null);
    getMediaHandler().reinitContent(ext.getName(),ext,modify);
    setSenders(mediaType,ext.getSenders());
    if (MediaType.VIDEO.equals(mediaType))     ;
    getCall().modifyVideoContent();
  }
 catch (  Exception e) {
    logger.info(""String_Node_Str"",e);
    String reason=""String_Node_Str"" + e.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(getProtocolProvider().getOurJID(),peerJID,sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,reason);
    setState(CallPeerState.FAILED,reason);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}","/** 
 * Processes the content-modify   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer wants to be modified
 */
public void processContentModify(JingleIQ content){
  ContentPacketExtension ext=content.getContentList().get(0);
  MediaType mediaType=getMediaType(ext);
  try {
    boolean modify=(ext.getFirstChildOfType(RtpDescriptionPacketExtension.class) != null);
    getMediaHandler().reinitContent(ext.getName(),ext,modify);
    setSenders(mediaType,ext.getSenders());
    if (MediaType.VIDEO.equals(mediaType))     getCall().modifyVideoContent();
  }
 catch (  Exception e) {
    logger.info(""String_Node_Str"",e);
    String reason=""String_Node_Str"" + e.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(getProtocolProvider().getOurJID(),peerJID,sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,reason);
    setState(CallPeerState.FAILED,reason);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}",0.9970443349753696
103098,"public void incomingCallReceived(CallEvent event){
}","public void incomingCallReceived(CallEvent ev){
}",0.9702970297029704
103099,"/** 
 * Implements CallListener.callEnded. Disposes the frame related to the ended call.
 * @param event the <tt>CallEvent</tt> that notified us
 */
public void callEnded(CallEvent event){
  Call call=event.getSourceCall();
  JFrame desktopFrame=callDesktopFrames.get(call);
  if (desktopFrame != null) {
    desktopFrame.dispose();
    callDesktopFrames.remove(call);
  }
}","/** 
 * Implements   {@link CallListener#callEnded(CallEvent)}. Disposes of the frame related to the ended call.
 * @param ev a <tt>CallEvent</tt> which identifies theended call 
 */
public void callEnded(CallEvent ev){
  Call call=ev.getSourceCall();
  JFrame desktopFrame=callDesktopFrames.get(call);
  if (desktopFrame != null) {
    desktopFrame.dispose();
    callDesktopFrames.remove(call);
  }
}",0.9020618556701032
103100,"/** 
 * Adds the desktop sharing listener.
 * @param call the call, for which we're registering a listener
 * @param frame the frame to be closed on call ended
 */
private static void addDesktopSharingListener(final Call call,JFrame frame){
  OperationSetVideoTelephony videoOpSet=call.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);
  videoOpSet.addPropertyChangeListener(call,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(evt.getPropertyName()) && evt.getNewValue().equals(MediaDirection.RECVONLY)) {
        JFrame desktopFrame=callDesktopFrames.get(call);
        if (desktopFrame != null) {
          desktopFrame.dispose();
          callDesktopFrames.remove(call);
        }
      }
    }
  }
);
}","/** 
 * Adds the desktop sharing listener.
 * @param call the call, for which we're registering a listener
 * @param frame the frame to be closed on call ended
 */
private static void addDesktopSharingListener(final Call call,JFrame frame){
  OperationSetVideoTelephony videoTelephony=call.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);
  videoTelephony.addPropertyChangeListener(call,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent ev){
      if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(ev.getPropertyName()) && MediaDirection.RECVONLY.equals(ev.getNewValue())) {
        JFrame desktopFrame=callDesktopFrames.get(call);
        if (desktopFrame != null) {
          desktopFrame.dispose();
          callDesktopFrames.remove(call);
        }
      }
    }
  }
);
}",0.9068249258160236
103101,"/** 
 * Get the frame for a <tt>Call</tt>.
 * @param call the <tt>Call</tt>
 * @return JFrame for the call or null if not found
 */
public static JFrame getFrameForCall(Call call){
  if (callDesktopFrames.containsKey(call)) {
    return callDesktopFrames.get(call);
  }
  return null;
}","/** 
 * Get the frame for a <tt>Call</tt>.
 * @param call the <tt>Call</tt>
 * @return JFrame for the call or null if not found
 */
public static JFrame getFrameForCall(Call call){
  return callDesktopFrames.get(call);
}",0.8695652173913043
103102,"public void outgoingCallCreated(CallEvent event){
}","public void outgoingCallCreated(CallEvent ev){
}",0.9696969696969696
103103,"public void propertyChange(PropertyChangeEvent evt){
  if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(evt.getPropertyName()) && evt.getNewValue().equals(MediaDirection.RECVONLY)) {
    JFrame desktopFrame=callDesktopFrames.get(call);
    if (desktopFrame != null) {
      desktopFrame.dispose();
      callDesktopFrames.remove(call);
    }
  }
}","public void propertyChange(PropertyChangeEvent ev){
  if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(ev.getPropertyName()) && MediaDirection.RECVONLY.equals(ev.getNewValue())) {
    JFrame desktopFrame=callDesktopFrames.get(call);
    if (desktopFrame != null) {
      desktopFrame.dispose();
      callDesktopFrames.remove(call);
    }
  }
}",0.9284712482468443
103104,"/** 
 * Adds a call listener, which listens for call ended events and would close any related desktop sharing frames when a call is ended.
 * @param call the call, for which we're registering a listener
 * @param frame the frame to be closed on call ended
 */
private static void addCallListener(Call call,JFrame frame){
  OperationSetBasicTelephony<?> telOpSet=call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);
  if (telOpSet != null) {
    telOpSet.addCallListener(new CallListener(){
      /** 
 * Implements CallListener.callEnded. Disposes the frame related to the ended call.
 * @param event the <tt>CallEvent</tt> that notified us
 */
      public void callEnded(      CallEvent event){
        Call call=event.getSourceCall();
        JFrame desktopFrame=callDesktopFrames.get(call);
        if (desktopFrame != null) {
          desktopFrame.dispose();
          callDesktopFrames.remove(call);
        }
      }
      public void incomingCallReceived(      CallEvent event){
      }
      public void outgoingCallCreated(      CallEvent event){
      }
    }
);
  }
}","/** 
 * Adds a call listener, which listens for call ended events and would close any related desktop sharing frames when a call is ended.
 * @param call the call, for which we're registering a listener
 * @param frame the frame to be closed on call ended
 */
private static void addCallListener(Call call,JFrame frame){
  OperationSetBasicTelephony<?> basicTelephony=call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);
  if (basicTelephony != null) {
    basicTelephony.addCallListener(new CallListener(){
      /** 
 * Implements   {@link CallListener#callEnded(CallEvent)}. Disposes of the frame related to the ended call.
 * @param ev a <tt>CallEvent</tt> which identifies theended call 
 */
      public void callEnded(      CallEvent ev){
        Call call=ev.getSourceCall();
        JFrame desktopFrame=callDesktopFrames.get(call);
        if (desktopFrame != null) {
          desktopFrame.dispose();
          callDesktopFrames.remove(call);
        }
      }
      public void incomingCallReceived(      CallEvent ev){
      }
      public void outgoingCallCreated(      CallEvent ev){
      }
    }
);
  }
}",0.8853333333333333
103105,"/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice specific video device to use (null to use defaultdevice)
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  boolean supported=false;
  String fullCalleeURI=null;
  if (calleeAddress.indexOf('/') > 0) {
    fullCalleeURI=calleeAddress;
  }
 else {
    fullCalleeURI=parentProvider.getConnection().getRoster().getPresence(calleeAddress).getFrom();
  }
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  DiscoverInfo di=null;
  try {
    di=parentProvider.getDiscoveryManager().discoverInfo(fullCalleeURI);
    if (di.containsFeature(InputEvtIQ.NAMESPACE_CLIENT)) {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
      supported=true;
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(fullCalleeURI + ""String_Node_Str"");
      }
    }
  }
 catch (  XMPPException ex) {
    logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
  }
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  if (videoDevice != null)   call.setVideoDevice(videoDevice);
  call.setLocalVideoAllowed(true,getMediaUseCase());
  call.setLocalInputEvtAware(supported);
  basicTelephony.createOutgoingCall(call,calleeAddress);
  new CallPeerJabberImpl(calleeAddress,call);
  return call;
}","/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice specific video device to use (null to use defaultdevice)
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  boolean supported=false;
  String fullCalleeURI=null;
  if (calleeAddress.indexOf('/') > 0) {
    fullCalleeURI=calleeAddress;
  }
 else {
    fullCalleeURI=parentProvider.getConnection().getRoster().getPresence(calleeAddress).getFrom();
  }
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  DiscoverInfo di=null;
  try {
    di=parentProvider.getDiscoveryManager().discoverInfo(fullCalleeURI);
    if (di.containsFeature(InputEvtIQ.NAMESPACE_CLIENT)) {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
      supported=true;
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(fullCalleeURI + ""String_Node_Str"");
      }
    }
  }
 catch (  XMPPException ex) {
    logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
  }
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  MediaUseCase useCase=getMediaUseCase();
  if (videoDevice != null)   call.setVideoDevice(videoDevice,useCase);
  call.setLocalVideoAllowed(true,useCase);
  call.setLocalInputEvtAware(supported);
  basicTelephony.createOutgoingCall(call,calleeAddress);
  new CallPeerJabberImpl(calleeAddress,call);
  return call;
}",0.9793641940881204
103106,"/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice <tt>MediaDevice</tt> used
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  if (videoDevice != null)   call.setVideoDevice(videoDevice);
  call.setLocalVideoAllowed(true,getMediaUseCase());
  basicTelephony.createOutgoingCall(call,calleeAddress);
  origin=getOriginForMediaDevice(videoDevice);
  return call;
}","/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice <tt>MediaDevice</tt> used
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  MediaUseCase useCase=getMediaUseCase();
  if (videoDevice != null)   call.setVideoDevice(videoDevice,useCase);
  call.setLocalVideoAllowed(true,useCase);
  basicTelephony.createOutgoingCall(call,calleeAddress);
  origin=getOriginForMediaDevice(videoDevice);
  return call;
}",0.9596510359869138
103107,"/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming.If the device is null, the default device is used.
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  AbstractCallJabberGTalkImpl<?> callImpl=(AbstractCallJabberGTalkImpl<?>)call;
  if (mediaDevice == null) {
    MediaService mediaService=ProtocolMediaActivator.getMediaService();
    mediaDevice=mediaService.getDefaultDevice(MediaType.VIDEO,getMediaUseCase());
  }
  callImpl.setVideoDevice(mediaDevice);
  callImpl.setLocalVideoAllowed(allowed,getMediaUseCase());
  MediaFormat mediaDeviceFormat=mediaDevice.getFormat();
  size=(mediaDeviceFormat == null) ? null : ((VideoMediaFormat)mediaDeviceFormat).getSize();
  callImpl.modifyVideoContent();
  origin=getOriginForMediaDevice(mediaDevice);
}","/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming.If the device is null, the default device is used.
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  AbstractCallJabberGTalkImpl<?> callImpl=(AbstractCallJabberGTalkImpl<?>)call;
  MediaUseCase useCase=getMediaUseCase();
  if (mediaDevice == null) {
    MediaService mediaService=ProtocolMediaActivator.getMediaService();
    mediaDevice=mediaService.getDefaultDevice(MediaType.VIDEO,useCase);
  }
  callImpl.setVideoDevice(mediaDevice,useCase);
  callImpl.setLocalVideoAllowed(allowed,useCase);
  MediaFormat mediaDeviceFormat=mediaDevice.getFormat();
  size=(mediaDeviceFormat == null) ? null : ((VideoMediaFormat)mediaDeviceFormat).getSize();
  callImpl.modifyVideoContent();
  origin=getOriginForMediaDevice(mediaDevice);
}",0.914850136239782
103108,"/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  CallSipImpl sipCall=(CallSipImpl)call;
  sipCall.setVideoDevice(mediaDevice);
  sipCall.setLocalVideoAllowed(allowed,MediaUseCase.DESKTOP);
  size=(((VideoMediaFormat)sipCall.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=getOriginForMediaDevice(mediaDevice);
  sipCall.reInvite();
}","/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  CallSipImpl sipCall=(CallSipImpl)call;
  MediaUseCase useCase=MediaUseCase.DESKTOP;
  sipCall.setVideoDevice(mediaDevice,useCase);
  sipCall.setLocalVideoAllowed(allowed,useCase);
  size=(((VideoMediaFormat)sipCall.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=getOriginForMediaDevice(mediaDevice);
  sipCall.reInvite();
}",0.9150442477876106
103109,"/** 
 * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call, boolean). Modifies the local media setup to reflect the requested setting for the streaming of the local video and then re-invites all CallPeers to re-negotiate the modified media setup.
 * @param call    the call where we'd like to allow sending local video.
 * @param allowed <tt>true</tt> if local video transmission is allowed and<tt>false</tt> otherwise.
 * @throws OperationFailedException if video initialization fails.
 */
public void setLocalVideoAllowed(Call call,boolean allowed) throws OperationFailedException {
  MediaAwareCall<?,?,?> mediaAwareCall=(MediaAwareCall<?,?,?>)call;
  mediaAwareCall.setVideoDevice(null);
  mediaAwareCall.setLocalVideoAllowed(allowed,MediaUseCase.CALL);
}","/** 
 * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call, boolean). Modifies the local media setup to reflect the requested setting for the streaming of the local video and then re-invites all CallPeers to re-negotiate the modified media setup.
 * @param call    the call where we'd like to allow sending local video.
 * @param allowed <tt>true</tt> if local video transmission is allowed and<tt>false</tt> otherwise.
 * @throws OperationFailedException if video initialization fails.
 */
public void setLocalVideoAllowed(Call call,boolean allowed) throws OperationFailedException {
  MediaAwareCall<?,?,?> mediaAwareCall=(MediaAwareCall<?,?,?>)call;
  MediaUseCase useCase=MediaUseCase.CALL;
  mediaAwareCall.setVideoDevice(null,useCase);
  mediaAwareCall.setLocalVideoAllowed(allowed,useCase);
}",0.8712121212121212
103110,"/** 
 * Notifies this instance that a value of a specific property of the <tt>Call</tt> of   {@link #peer} has changed from a specific old value to aspecific new value.
 * @param event a <tt>PropertyChangeEvent</tt> which specified the propertywhich had its value changed and the old and new values of that property
 */
private void callPropertyChange(PropertyChangeEvent event){
  String propertyName=event.getPropertyName();
  if (MediaAwareCall.CONFERENCE.equals(propertyName) || MediaAwareCall.DEFAULT_DEVICE.equals(propertyName)) {
    MediaAwareCall<?,?,?> call=getPeer().getCall();
    if (call == null)     return;
    for (    MediaType mediaType : MediaType.values()) {
      MediaStream stream=getStream(mediaType);
      if (stream == null)       continue;
      MediaDevice oldDevice=stream.getDevice();
      if (oldDevice != null) {
        if (oldDevice instanceof MediaDeviceWrapper)         oldDevice=((MediaDeviceWrapper)oldDevice).getWrappedDevice();
        MediaDevice newDevice=getDefaultDevice(mediaType);
        MediaDevice wrappedNewDevice=newDevice;
        if (newDevice instanceof MediaDeviceWrapper)         wrappedNewDevice=((MediaDeviceWrapper)newDevice).getWrappedDevice();
        if (oldDevice != wrappedNewDevice)         stream.setDevice(newDevice);
      }
      stream.setRTPTranslator(call.getRTPTranslator(mediaType));
    }
  }
}","/** 
 * Notifies this instance that a value of a specific property of the <tt>Call</tt> of   {@link #peer} has changed from a specific old value to aspecific new value.
 * @param event a <tt>PropertyChangeEvent</tt> which specified the propertywhich had its value changed and the old and new values of that property
 */
private void callPropertyChange(PropertyChangeEvent event){
  String propertyName=event.getPropertyName();
  if (MediaAwareCall.CONFERENCE.equals(propertyName) || MediaAwareCall.DEFAULT_DEVICE.equals(propertyName)) {
    MediaAwareCall<?,?,?> call=getPeer().getCall();
    if (call == null)     return;
    for (    MediaType mediaType : MediaType.values()) {
      MediaStream stream=getStream(mediaType);
      if (stream == null)       continue;
      MediaDevice oldDevice=stream.getDevice();
      if (oldDevice != null) {
        if (oldDevice instanceof MediaDeviceWrapper) {
          oldDevice=((MediaDeviceWrapper)oldDevice).getWrappedDevice();
        }
        MediaDevice newDevice=getDefaultDevice(mediaType);
        MediaDevice newWrappedDevice=newDevice;
        if (newDevice instanceof MediaDeviceWrapper) {
          newWrappedDevice=((MediaDeviceWrapper)newDevice).getWrappedDevice();
        }
        if (MediaAwareCall.DEFAULT_DEVICE.equals(propertyName))         System.err.println(CallPeerMediaHandler.class.getName() + ""String_Node_Str"" + oldDevice+ ""String_Node_Str""+ newDevice+ ""String_Node_Str""+ newWrappedDevice);
        if (oldDevice != newWrappedDevice)         stream.setDevice(newDevice);
      }
      stream.setRTPTranslator(call.getRTPTranslator(mediaType));
    }
  }
}",0.8123958680439853
103111,"/** 
 * Stores an account represented in the form of an <tt>AccountID</tt> created by a specific <tt>ProtocolProviderFactory</tt>.
 * @param factory the <tt>ProtocolProviderFactory</tt> which created theaccount to be stored
 * @param accountID the account in the form of <tt>AccountID</tt> to bestored
 * @throws OperationFailedException if anything goes wrong while storing theaccount
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID) throws OperationFailedException {
synchronized (storedAccounts) {
    if (!storedAccounts.contains(accountID))     storedAccounts.add(accountID);
  }
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  String accountNodeName=getAccountNodeName(factory,accountID.getAccountUniqueID());
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=ACCOUNT_UID_PREFIX + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    String secureStorePrefix=null;
    if (property.equals(ProtocolProviderFactory.PASSWORD)) {
      String accountPrefix=factoryPackage + ""String_Node_Str"" + accountNodeName;
      secureStorePrefix=accountPrefix;
    }
 else     if (property.endsWith(""String_Node_Str"" + ProtocolProviderFactory.PASSWORD)) {
      secureStorePrefix=factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property.substring(0,property.lastIndexOf(""String_Node_Str""));
    }
    if (secureStorePrefix != null) {
      CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
      if ((value != null) && (value.length() != 0) && !credentialsStorage.storePassword(secureStorePrefix,value)) {
        throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
      }
    }
 else {
      configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
    }
  }
  if (!accountProperties.containsKey(ProtocolProviderFactory.PASSWORD)) {
    CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
    credentialsStorage.removePassword(factoryPackage + ""String_Node_Str"" + accountNodeName);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}","/** 
 * Stores an account represented in the form of an <tt>AccountID</tt> created by a specific <tt>ProtocolProviderFactory</tt>.
 * @param factory the <tt>ProtocolProviderFactory</tt> which created theaccount to be stored
 * @param accountID the account in the form of <tt>AccountID</tt> to bestored
 * @throws OperationFailedException if anything goes wrong while storing theaccount
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID) throws OperationFailedException {
synchronized (storedAccounts) {
    if (!storedAccounts.contains(accountID))     storedAccounts.add(accountID);
  }
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  String accountNodeName=getAccountNodeName(factory,accountID.getAccountUniqueID());
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=ACCOUNT_UID_PREFIX + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    String secureStorePrefix=null;
    if (property.equals(ProtocolProviderFactory.PASSWORD)) {
      String accountPrefix=factoryPackage + ""String_Node_Str"" + accountNodeName;
      secureStorePrefix=accountPrefix;
    }
 else     if (property.endsWith(""String_Node_Str"" + ProtocolProviderFactory.PASSWORD)) {
      secureStorePrefix=factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property.substring(0,property.lastIndexOf(""String_Node_Str""));
    }
    if (secureStorePrefix != null) {
      CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
      if ((value != null) && (value.length() != 0) && !credentialsStorage.storePassword(secureStorePrefix,value)) {
        throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
      }
    }
 else {
      configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
    }
  }
  if (!accountProperties.containsKey(ProtocolProviderFactory.PASSWORD) && !configurationProperties.containsKey(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str"")) {
    CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
    credentialsStorage.removePassword(factoryPackage + ""String_Node_Str"" + accountNodeName);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}",0.9821850859214882
103112,"/** 
 * Saves the password for the specified account after scrambling it a bit so that it is not visible from first sight (Method remains highly insecure). <p> TODO Delegate the implementation to   {@link AccountManager} because itknows the format in which the password (among the other account properties) is to be saved. </p>
 * @param bundleContext a currently valid bundle context.
 * @param accountID the <tt>AccountID</tt> of the account whose password isto be stored
 * @param password the password to be stored
 * @throws IllegalArgumentException if no account corresponding to<tt>accountID</tt> has been previously stored.
 * @throws OperationFailedException if anything goes wrong while storing thespecified <tt>password</tt>
 */
protected void storePassword(BundleContext bundleContext,AccountID accountID,String password) throws IllegalArgumentException, OperationFailedException {
  String accountPrefix=findAccountPrefix(bundleContext,accountID,getFactoryImplPackageName());
  if (accountPrefix == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ getFactoryImplPackageName());
  }
  CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
  if (!credentialsStorage.storePassword(accountPrefix,password)) {
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
}","/** 
 * Saves the password for the specified account after scrambling it a bit so that it is not visible from first sight (Method remains highly insecure). <p> TODO Delegate the implementation to   {@link AccountManager} because itknows the format in which the password (among the other account properties) is to be saved. </p>
 * @param bundleContext a currently valid bundle context.
 * @param accountID the <tt>AccountID</tt> of the account whose password isto be stored
 * @param password the password to be stored
 * @throws IllegalArgumentException if no account corresponding to<tt>accountID</tt> has been previously stored.
 * @throws OperationFailedException if anything goes wrong while storing thespecified <tt>password</tt>
 */
protected void storePassword(BundleContext bundleContext,AccountID accountID,String password) throws IllegalArgumentException, OperationFailedException {
  String accountPrefix=findAccountPrefix(bundleContext,accountID,getFactoryImplPackageName());
  if (accountPrefix == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ getFactoryImplPackageName());
  }
  CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
  if (!credentialsStorage.storePassword(accountPrefix,password)) {
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  accountID.setPassword(password);
}",0.9881073734284744
103113,"/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param resource and the resource.
 * @param loginStrategy the login strategy to use
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(InetSocketAddress address,String serviceName,String userName,String resource,JabberLoginStrategy loginStrategy) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address.getAddress().getHostAddress(),address.getPort(),serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=loginStrategy.isTlsRequired();
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      SSLContext sslContext=loginStrategy.createSslContext(cvs,getTrustManager(cvs,serviceName));
      connection.setCustomSslContext(sslContext);
    }
 else     if (tlsRequired)     throw new XMPPException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  setTrafficClass();
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  if (!connection.isConnected()) {
    disconnectAndCleanConnection();
    logger.error(""String_Node_Str"");
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,null);
    return ConnectState.ABORT_CONNECTING;
  }
 else {
    connection.addConnectionListener(connectionListener);
  }
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  if (!loginStrategy.login(connection,userName,resource)) {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,loginStrategy.getClass().getName() + ""String_Node_Str"");
    return ConnectState.ABORT_CONNECTING;
  }
  if (connection.isAuthenticated()) {
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}","/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param resource and the resource.
 * @param loginStrategy the login strategy to use
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(InetSocketAddress address,String serviceName,String userName,String resource,JabberLoginStrategy loginStrategy) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address.getAddress().getHostAddress(),address.getPort(),serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=loginStrategy.isTlsRequired();
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      SSLContext sslContext=loginStrategy.createSslContext(cvs,getTrustManager(cvs,serviceName));
      connection.setCustomSslContext(sslContext);
    }
 else     if (tlsRequired)     throw new XMPPException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  setTrafficClass();
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  if (!connection.isConnected()) {
    disconnectAndCleanConnection();
    logger.error(""String_Node_Str"");
    eventDuringLogin=null;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,null);
    return ConnectState.ABORT_CONNECTING;
  }
 else {
    connection.addConnectionListener(connectionListener);
  }
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  if (!loginStrategy.login(connection,userName,resource)) {
    disconnectAndCleanConnection();
    eventDuringLogin=null;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,loginStrategy.getClass().getName() + ""String_Node_Str"");
    return ConnectState.ABORT_CONNECTING;
  }
  if (connection.isAuthenticated()) {
    eventDuringLogin=null;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    eventDuringLogin=null;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}",0.98744769874477
103114,"/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    connectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}","/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    initializeConnectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}",0.995847750865052
103115,"/** 
 * Unregister and fire the event if requested
 * @param fireEvent boolean
 */
public void unregister(boolean fireEvent){
synchronized (initializationLock) {
    if (fireEvent) {
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    }
    disconnectAndCleanConnection();
    RegistrationState currRegState=getRegistrationState();
    if (fireEvent) {
      fireRegistrationStateChanged(currRegState,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
    }
  }
}","/** 
 * Unregister and fire the event if requested
 * @param fireEvent boolean
 */
public void unregister(boolean fireEvent){
synchronized (initializationLock) {
    if (fireEvent) {
      eventDuringLogin=null;
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    }
    disconnectAndCleanConnection();
    RegistrationState currRegState=getRegistrationState();
    if (fireEvent) {
      eventDuringLogin=null;
      fireRegistrationStateChanged(currRegState,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
    }
  }
}",0.9537480063795852
103116,"/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    connectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}","/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    initializeConnectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}",0.9964200477326968
103117,"/** 
 * Unregisters the ProtocolProvider. Make sure to do it in separate thread so we don't block other processing.
 * @param pp the protocol provider to unregister.
 * @param reconnect if the protocol provider does not need unregisteringshall we trigger reconnect. Its true when call called from reconnect.
 * @param listener the listener used in reconnect method.
 * @param task the task to use for reconnection.
 */
private void unregister(final ProtocolProviderService pp,final boolean reconnect,final RegistrationStateChangeListener listener,final ReconnectTask task){
  unregisteringProviders.add(pp);
  new Thread(new Runnable(){
    public void run(){
      try {
        if (pp.getRegistrationState().equals(RegistrationState.UNREGISTERING) || pp.getRegistrationState().equals(RegistrationState.UNREGISTERED) || pp.getRegistrationState().equals(RegistrationState.CONNECTION_FAILED)) {
          if (reconnect) {
            if (listener != null)             pp.removeRegistrationStateChangeListener(listener);
            if (timer == null || task == null)             return;
            if (currentlyReconnecting.containsKey(pp))             currentlyReconnecting.remove(pp).cancel();
            currentlyReconnecting.put(pp,task);
            if (logger.isTraceEnabled())             logger.trace(""String_Node_Str"" + pp + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
            timer.schedule(task,task.delay);
          }
          return;
        }
        pp.unregister();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"" + pp,t);
      }
    }
  }
).start();
}","/** 
 * Unregisters the ProtocolProvider. Make sure to do it in separate thread so we don't block other processing.
 * @param pp the protocol provider to unregister.
 * @param reconnect if the protocol provider does not need unregisteringshall we trigger reconnect. Its true when call called from reconnect.
 * @param listener the listener used in reconnect method.
 * @param task the task to use for reconnection.
 */
private void unregister(final ProtocolProviderService pp,final boolean reconnect,final RegistrationStateChangeListener listener,final ReconnectTask task){
  unregisteringProviders.add(pp);
  new Thread(new Runnable(){
    public void run(){
      try {
        if (pp.getRegistrationState().equals(RegistrationState.UNREGISTERING) || pp.getRegistrationState().equals(RegistrationState.UNREGISTERED) || pp.getRegistrationState().equals(RegistrationState.CONNECTION_FAILED)) {
          if (reconnect) {
            if (listener != null)             pp.removeRegistrationStateChangeListener(listener);
            if (timer == null || task == null)             return;
            if (currentlyReconnecting.containsKey(pp))             currentlyReconnecting.remove(pp).cancel();
            currentlyReconnecting.put(pp,task);
            if (logger.isInfoEnabled())             logger.info(""String_Node_Str"" + pp.getAccountID().getDisplayName() + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
            timer.schedule(task,task.delay);
          }
          return;
        }
        pp.unregister();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"" + pp,t);
      }
    }
  }
).start();
}",0.9846248462484624
103118,"/** 
 * Method to schedule a reconnect for a protocol provider.
 * @param pp the provider.
 */
private void reconnect(final ProtocolProviderService pp){
  long delay;
  if (currentlyReconnecting.containsKey(pp)) {
    delay=currentlyReconnecting.get(pp).delay;
    delay=Math.min(delay * 2,MAX_RECONNECT_DELAY * 1000);
  }
 else {
    delay=(long)(RECONNECT_DELAY_MIN + Math.random() * RECONNECT_DELAY_MAX) * 1000;
  }
  final ReconnectTask task=new ReconnectTask(pp);
  task.delay=delay;
  RegistrationStateChangeListener listener=new RegistrationStateChangeListener(){
    public void registrationStateChanged(    RegistrationStateChangeEvent evt){
      if (evt.getSource() instanceof ProtocolProviderService) {
        if (evt.getNewState().equals(RegistrationState.UNREGISTERED) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
synchronized (this) {
            pp.removeRegistrationStateChangeListener(this);
            if (timer == null)             return;
            if (connectedInterfaces.size() == 0) {
              needsReconnection.add(pp);
              if (currentlyReconnecting.containsKey(pp))               currentlyReconnecting.remove(pp).cancel();
              return;
            }
            if (currentlyReconnecting.containsKey(pp))             currentlyReconnecting.remove(pp).cancel();
            currentlyReconnecting.put(pp,task);
            if (logger.isTraceEnabled())             logger.trace(""String_Node_Str"" + pp + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
            timer.schedule(task,task.delay);
          }
        }
      }
    }
  }
;
  pp.addRegistrationStateChangeListener(listener);
  unregister(pp,true,listener,task);
}","/** 
 * Method to schedule a reconnect for a protocol provider.
 * @param pp the provider.
 */
private void reconnect(final ProtocolProviderService pp){
  long delay;
  if (currentlyReconnecting.containsKey(pp)) {
    delay=currentlyReconnecting.get(pp).delay;
    delay=Math.min(delay * 2,MAX_RECONNECT_DELAY * 1000);
  }
 else {
    delay=(long)(RECONNECT_DELAY_MIN + Math.random() * RECONNECT_DELAY_MAX) * 1000;
  }
  final ReconnectTask task=new ReconnectTask(pp);
  task.delay=delay;
  RegistrationStateChangeListener listener=new RegistrationStateChangeListener(){
    public void registrationStateChanged(    RegistrationStateChangeEvent evt){
      if (evt.getSource() instanceof ProtocolProviderService) {
        if (evt.getNewState().equals(RegistrationState.UNREGISTERED) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
synchronized (this) {
            pp.removeRegistrationStateChangeListener(this);
            if (timer == null)             return;
            if (connectedInterfaces.size() == 0) {
              needsReconnection.add(pp);
              if (currentlyReconnecting.containsKey(pp))               currentlyReconnecting.remove(pp).cancel();
              return;
            }
            if (currentlyReconnecting.containsKey(pp))             currentlyReconnecting.remove(pp).cancel();
            currentlyReconnecting.put(pp,task);
            if (logger.isInfoEnabled())             logger.info(""String_Node_Str"" + pp.getAccountID().getDisplayName() + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
            timer.schedule(task,task.delay);
          }
        }
      }
    }
  }
;
  pp.addRegistrationStateChangeListener(listener);
  unregister(pp,true,listener,task);
}",0.9854481955762514
103119,"public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getSource() instanceof ProtocolProviderService) {
    if (evt.getNewState().equals(RegistrationState.UNREGISTERED) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
synchronized (this) {
        pp.removeRegistrationStateChangeListener(this);
        if (timer == null)         return;
        if (connectedInterfaces.size() == 0) {
          needsReconnection.add(pp);
          if (currentlyReconnecting.containsKey(pp))           currentlyReconnecting.remove(pp).cancel();
          return;
        }
        if (currentlyReconnecting.containsKey(pp))         currentlyReconnecting.remove(pp).cancel();
        currentlyReconnecting.put(pp,task);
        if (logger.isTraceEnabled())         logger.trace(""String_Node_Str"" + pp + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
        timer.schedule(task,task.delay);
      }
    }
  }
}","public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getSource() instanceof ProtocolProviderService) {
    if (evt.getNewState().equals(RegistrationState.UNREGISTERED) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
synchronized (this) {
        pp.removeRegistrationStateChangeListener(this);
        if (timer == null)         return;
        if (connectedInterfaces.size() == 0) {
          needsReconnection.add(pp);
          if (currentlyReconnecting.containsKey(pp))           currentlyReconnecting.remove(pp).cancel();
          return;
        }
        if (currentlyReconnecting.containsKey(pp))         currentlyReconnecting.remove(pp).cancel();
        currentlyReconnecting.put(pp,task);
        if (logger.isInfoEnabled())         logger.info(""String_Node_Str"" + pp.getAccountID().getDisplayName() + ""String_Node_Str""+ task.delay+ ""String_Node_Str"");
        timer.schedule(task,task.delay);
      }
    }
  }
}",0.9739311783107404
103120,"/** 
 * Notifies a specific <tt>CallPeer</tt> about changes in the telephony conference-related information.
 * @param callPeer the <tt>CallPeer</tt> to notify.
 */
private void notify(CallPeer callPeer){
  if (!(callPeer instanceof CallPeerJabberImpl))   return;
  final CallPeerJabberImpl callPeerJabber=(CallPeerJabberImpl)callPeer;
  final long timeSinceLastCoin=System.currentTimeMillis() - callPeerJabber.getLastConferenceInfoSentTimestamp();
  if (timeSinceLastCoin < COIN_MIN_INTERVAL) {
    if (callPeerJabber.isCoinScheduled())     return;
    logger.info(""String_Node_Str"" + callPeerJabber);
    callPeerJabber.setCoinScheduled(true);
    new Thread(new Runnable(){
      @Override public void run(){
        try {
          Thread.sleep(1 + COIN_MIN_INTERVAL - timeSinceLastCoin);
        }
 catch (        InterruptedException ie) {
        }
        OperationSetTelephonyConferencingJabberImpl.this.notify(callPeerJabber);
      }
    }
).start();
    return;
  }
  String to=getBasicTelephony().getFullCalleeURI(callPeer.getAddress());
  try {
    DiscoverInfo discoverInfo=parentProvider.getDiscoveryManager().discoverInfo(to);
    if (!discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE_COIN)) {
      logger.info(callPeer.getAddress() + ""String_Node_Str"");
      callPeerJabber.setCoinScheduled(false);
      return;
    }
  }
 catch (  XMPPException xmppe) {
    logger.warn(""String_Node_Str"" + to,xmppe);
  }
  ConferenceInfoDocument currentConfInfo=getCurrentConferenceInfo(callPeer);
  ConferenceInfoDocument lastSentConfInfo=callPeerJabber.getLastConferenceInfoSent();
  ConferenceInfoDocument diff=getConferenceInfoDiff(lastSentConfInfo,currentConfInfo);
  if (diff != null) {
    int newVersion=lastSentConfInfo == null ? 1 : lastSentConfInfo.getVersion() + 1;
    diff.setVersion(newVersion);
    IQ iq=getConferenceInfo(callPeerJabber,diff);
    if (iq != null) {
      parentProvider.getConnection().sendPacket(iq);
      currentConfInfo.setVersion(newVersion);
      callPeerJabber.setLastConferenceInfoSent(currentConfInfo);
      callPeerJabber.setLastConferenceInfoSentTimestamp(System.currentTimeMillis());
    }
  }
  callPeerJabber.setCoinScheduled(false);
}","/** 
 * Notifies a specific <tt>CallPeer</tt> about changes in the telephony conference-related information.
 * @param callPeer the <tt>CallPeer</tt> to notify.
 */
private void notify(CallPeer callPeer){
  if (!(callPeer instanceof CallPeerJabberImpl))   return;
  final CallPeerJabberImpl callPeerJabber=(CallPeerJabberImpl)callPeer;
  final long timeSinceLastCoin=System.currentTimeMillis() - callPeerJabber.getLastConferenceInfoSentTimestamp();
  if (timeSinceLastCoin < COIN_MIN_INTERVAL) {
    if (callPeerJabber.isCoinScheduled())     return;
    logger.info(""String_Node_Str"" + callPeerJabber);
    callPeerJabber.setCoinScheduled(true);
    new Thread(new Runnable(){
      @Override public void run(){
        try {
          Thread.sleep(1 + COIN_MIN_INTERVAL - timeSinceLastCoin);
        }
 catch (        InterruptedException ie) {
        }
        OperationSetTelephonyConferencingJabberImpl.this.notify(callPeerJabber);
      }
    }
).start();
    return;
  }
  String to=getBasicTelephony().getFullCalleeURI(callPeer.getAddress());
  try {
    DiscoverInfo discoverInfo=parentProvider.getDiscoveryManager().discoverInfo(to);
    if (!discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE_COIN)) {
      logger.info(callPeer.getAddress() + ""String_Node_Str"");
      callPeerJabber.setCoinScheduled(false);
      return;
    }
  }
 catch (  XMPPException xmppe) {
    logger.warn(""String_Node_Str"" + to,xmppe);
  }
  ConferenceInfoDocument currentConfInfo=getCurrentConferenceInfo(callPeer);
  ConferenceInfoDocument lastSentConfInfo=callPeerJabber.getLastConferenceInfoSent();
  ConferenceInfoDocument diff;
  if (lastSentConfInfo == null)   diff=currentConfInfo;
 else   diff=getConferenceInfoDiff(lastSentConfInfo,currentConfInfo);
  if (diff != null) {
    int newVersion=lastSentConfInfo == null ? 1 : lastSentConfInfo.getVersion() + 1;
    diff.setVersion(newVersion);
    IQ iq=getConferenceInfo(callPeerJabber,diff);
    if (iq != null) {
      parentProvider.getConnection().sendPacket(iq);
      currentConfInfo.setVersion(newVersion);
      callPeerJabber.setLastConferenceInfoSent(currentConfInfo);
      callPeerJabber.setLastConferenceInfoSentTimestamp(System.currentTimeMillis());
    }
  }
  callPeerJabber.setCoinScheduled(false);
}",0.9844858156028368
103121,"/** 
 * @param a A document with state <tt>full</tt> which to compare to<tt>b</tt>
 * @param b A document with state <tt>full</tt> which to compare to<tt>a</tt>
 * @return <tt>false</tt> if the two documents are found to be different,<tt>true</tt> otherwise (that is, it can return true for non-identical documents).
 */
private boolean conferenceInfoDocumentsMatch(ConferenceInfoDocument a,ConferenceInfoDocument b){
  if (a.getState() != ConferenceInfoDocument.State.FULL)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  if (b.getState() != ConferenceInfoDocument.State.FULL)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  if (stringsMatch(a.getEntity(),b.getEntity()))   return false;
 else   if (a.getUserCount() != b.getUserCount())   return false;
 else   if (a.getUsers().size() != b.getUsers().size())   return false;
  for (  ConferenceInfoDocument.User aUser : a.getUsers()) {
    if (!usersMatch(aUser,b.getUser(aUser.getEntity())))     return false;
  }
  return true;
}","/** 
 * @param a A document with state <tt>full</tt> which to compare to<tt>b</tt>
 * @param b A document with state <tt>full</tt> which to compare to<tt>a</tt>
 * @return <tt>false</tt> if the two documents are found to be different,<tt>true</tt> otherwise (that is, it can return true for non-identical documents).
 */
private boolean conferenceInfoDocumentsMatch(ConferenceInfoDocument a,ConferenceInfoDocument b){
  if (a.getState() != ConferenceInfoDocument.State.FULL)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  if (b.getState() != ConferenceInfoDocument.State.FULL)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  if (!stringsMatch(a.getEntity(),b.getEntity()))   return false;
 else   if (a.getUserCount() != b.getUserCount())   return false;
 else   if (a.getUsers().size() != b.getUsers().size())   return false;
  for (  ConferenceInfoDocument.User aUser : a.getUsers()) {
    if (!usersMatch(aUser,b.getUser(aUser.getEntity())))     return false;
  }
  return true;
}",0.9995217599234816
103122,"/** 
 * Installs the account defined in this wizard.
 * @param userName the user name to sign in with
 * @param password the password to sign in with
 * @return the created <tt>ProtocolProviderService</tt> corresponding to thenew account
 * @throws OperationFailedException if the operation didn't succeed
 */
@Override public ProtocolProviderService signin(String userName,String password) throws OperationFailedException {
  if (firstWizardPage == null) {
    firstWizardPage=new FirstWizardPage(this);
    AccountPanel accPanel=(AccountPanel)firstWizardPage.getSimpleForm();
    accPanel.setUsername(userName);
    accPanel.setPassword(password);
    accPanel.setRememberPassword(true);
  }
  if (!firstWizardPage.isCommitted())   firstWizardPage.commitPage();
  if (!firstWizardPage.isCommitted())   throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  ProtocolProviderFactory factory=JabberAccRegWizzActivator.getJabberProtocolProviderFactory();
  return this.installAccount(factory,registration.getUserID(),password);
}","/** 
 * Installs the account defined in this wizard.
 * @param userName the user name to sign in with
 * @param password the password to sign in with
 * @return the created <tt>ProtocolProviderService</tt> corresponding to thenew account
 * @throws OperationFailedException if the operation didn't succeed
 */
@Override public ProtocolProviderService signin(String userName,String password) throws OperationFailedException {
  AccountPanel accPanel=(AccountPanel)firstWizardPage.getSimpleForm();
  accPanel.setUsername(userName);
  accPanel.setPassword(password);
  accPanel.setRememberPassword(password != null);
  if (!firstWizardPage.isCommitted())   firstWizardPage.commitPage();
  if (!firstWizardPage.isCommitted())   throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  ProtocolProviderFactory factory=JabberAccRegWizzActivator.getJabberProtocolProviderFactory();
  return this.installAccount(factory,registration.getUserID(),password);
}",0.7976653696498055
103123,"/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException if the operation didn't succeed
 */
protected ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + userName);
  }
  Hashtable<String,String> accountProperties=new Hashtable<String,String>();
  accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,Boolean.toString(isPreferredProtocol()));
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  String accountIconPath=getAccountIconPath();
  registration.storeProperties(userName,passwd,protocolIconPath,accountIconPath,accountProperties);
  if (isModification()) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + userName + ""String_Node_Str""+ accountProperties);
    }
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)JabberAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT);
  }
catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Throwable exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}","/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException if the operation didn't succeed
 */
protected ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + userName);
  }
  Hashtable<String,String> accountProperties=new Hashtable<String,String>();
  String protocolIconPath=getProtocolIconPath();
  String accountIconPath=getAccountIconPath();
  registration.storeProperties(userName,passwd,protocolIconPath,accountIconPath,accountProperties);
  accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,Boolean.toString(isPreferredProtocol()));
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  if (isModification()) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + userName + ""String_Node_Str""+ accountProperties);
    }
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)JabberAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT);
  }
catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Throwable exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}",0.9099264705882352
103124,"/** 
 * Loads given registration object.
 * @param accountReg the account registration object that will be loaded.
 */
public void loadAccount(JabberAccountRegistration accountReg){
  accountPanel.setUsername(accountReg.getUserID());
  String password=accountReg.getPassword();
  if (password != null) {
    accountPanel.setPassword(password);
    accountPanel.setRememberPassword(true);
  }
 else {
    accountPanel.setPassword(null);
  }
  String serverAddress=accountReg.getServerAddress();
  accountPanel.showChangePasswordPanel(true);
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setClientTlsCertificateId(accountReg.getTlsClientCertificate());
  String serverPort=String.valueOf(accountReg.getServerPort());
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setSendKeepAlive(accountReg.isSendKeepAlive());
  connectionPanel.setGmailNotificationsEnabled(accountReg.isGmailNotificationEnabled());
  connectionPanel.setGoogleContactsEnabled(accountReg.isGoogleContactsEnabled());
  connectionPanel.setResource(accountReg.getResource());
  connectionPanel.setAutogenerateResource(accountReg.isResourceAutogenerated());
  connectionPanel.setPriority(String.valueOf(accountReg.getPriority()));
  connectionPanel.setDTMFMethod(accountReg.getDTMFMethod());
  connectionPanel.setDtmfMinimalToneDuration(accountReg.getDtmfMinimalToneDuration());
  securityPanel.loadAccount(accountReg.getSecurityRegistration());
  iceConfigPanel.setUseIce(accountReg.isUseIce());
  iceConfigPanel.setUseGoogleIce(accountReg.isUseGoogleIce());
  iceConfigPanel.setAutoDiscoverStun(accountReg.isAutoDiscoverStun());
  iceConfigPanel.setUseDefaultStunServer(accountReg.isUseDefaultStunServer());
  List<StunServerDescriptor> stunServers=accountReg.getAdditionalStunServers();
  iceConfigPanel.removeAllStunServer();
  for (  StunServerDescriptor stunServer : stunServers) {
    iceConfigPanel.addStunServer(stunServer);
  }
  iceConfigPanel.setUseJingleNodes(accountReg.isUseJingleNodes());
  iceConfigPanel.setAutoDiscoverJingleNodes(accountReg.isAutoDiscoverJingleNodes());
  iceConfigPanel.removeAllJingleNodes();
  List<JingleNodeDescriptor> jingleNodes=accountReg.getAdditionalJingleNodes();
  for (  JingleNodeDescriptor jingleNode : jingleNodes) {
    iceConfigPanel.addJingleNodes(jingleNode);
  }
  iceConfigPanel.setUseUPNP(accountReg.isUseUPNP());
  connectionPanel.setAllowNonSecure(accountReg.isAllowNonSecure());
  connectionPanel.setServerOverridden(accountReg.isServerOverridden());
  telephonyConfigPanel.setDisableJingle(accountReg.isJingleDisabled());
  telephonyConfigPanel.setTelephonyDomain(accountReg.getOverridePhoneSuffix());
  telephonyConfigPanel.setTelephonyDomainBypassCaps(accountReg.getTelephonyDomainBypassCaps());
  encodingsPanel.loadAccount(accountReg.getEncodingsRegistration());
}","/** 
 * Loads given registration object.
 * @param accountReg the account registration object that will be loaded.
 */
public void loadAccount(JabberAccountRegistration accountReg){
  accountPanel.setUsername(accountReg.getUserID());
  String password=accountReg.getPassword();
  accountPanel.setPassword(password);
  accountPanel.setRememberPassword(password != null);
  String serverAddress=accountReg.getServerAddress();
  accountPanel.showChangePasswordPanel(true);
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setClientTlsCertificateId(accountReg.getTlsClientCertificate());
  String serverPort=String.valueOf(accountReg.getServerPort());
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setSendKeepAlive(accountReg.isSendKeepAlive());
  connectionPanel.setGmailNotificationsEnabled(accountReg.isGmailNotificationEnabled());
  connectionPanel.setGoogleContactsEnabled(accountReg.isGoogleContactsEnabled());
  connectionPanel.setResource(accountReg.getResource());
  connectionPanel.setAutogenerateResource(accountReg.isResourceAutogenerated());
  connectionPanel.setPriority(String.valueOf(accountReg.getPriority()));
  connectionPanel.setDTMFMethod(accountReg.getDTMFMethod());
  connectionPanel.setDtmfMinimalToneDuration(accountReg.getDtmfMinimalToneDuration());
  securityPanel.loadAccount(accountReg.getSecurityRegistration());
  iceConfigPanel.setUseIce(accountReg.isUseIce());
  iceConfigPanel.setUseGoogleIce(accountReg.isUseGoogleIce());
  iceConfigPanel.setAutoDiscoverStun(accountReg.isAutoDiscoverStun());
  iceConfigPanel.setUseDefaultStunServer(accountReg.isUseDefaultStunServer());
  List<StunServerDescriptor> stunServers=accountReg.getAdditionalStunServers();
  iceConfigPanel.removeAllStunServer();
  for (  StunServerDescriptor stunServer : stunServers) {
    iceConfigPanel.addStunServer(stunServer);
  }
  iceConfigPanel.setUseJingleNodes(accountReg.isUseJingleNodes());
  iceConfigPanel.setAutoDiscoverJingleNodes(accountReg.isAutoDiscoverJingleNodes());
  iceConfigPanel.removeAllJingleNodes();
  List<JingleNodeDescriptor> jingleNodes=accountReg.getAdditionalJingleNodes();
  for (  JingleNodeDescriptor jingleNode : jingleNodes) {
    iceConfigPanel.addJingleNodes(jingleNode);
  }
  iceConfigPanel.setUseUPNP(accountReg.isUseUPNP());
  connectionPanel.setAllowNonSecure(accountReg.isAllowNonSecure());
  connectionPanel.setServerOverridden(accountReg.isServerOverridden());
  telephonyConfigPanel.setDisableJingle(accountReg.isJingleDisabled());
  telephonyConfigPanel.setTelephonyDomain(accountReg.getOverridePhoneSuffix());
  telephonyConfigPanel.setTelephonyDomainBypassCaps(accountReg.getTelephonyDomainBypassCaps());
  encodingsPanel.loadAccount(accountReg.getEncodingsRegistration());
}",0.9620886981402004
103125,"/** 
 * Modify an existing account.
 * @param protocolProvider the <tt>ProtocolProviderService</tt> responsibleof the account
 * @param accountProperties modified properties to be set
 */
@Override public void modifyAccount(ProtocolProviderService protocolProvider,Map<String,String> accountProperties) throws NullPointerException {
  BundleContext context=JabberActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  JabberAccountID accountID=(JabberAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=registeredAccounts.get(accountID);
  if (registration != null) {
    try {
      if (protocolProvider.isRegistered()) {
        protocolProvider.unregister();
        protocolProvider.shutdown();
      }
    }
 catch (    Throwable e) {
    }
    registration.unregister();
  }
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  accountProperties.put(USER_ID,accountID.getUserID());
  String serverAddress=accountProperties.get(SERVER_ADDRESS);
  if (serverAddress == null)   throw new NullPointerException(""String_Node_Str"");
  if (accountProperties.get(SERVER_PORT) == null) {
    accountProperties.put(SERVER_PORT,""String_Node_Str"");
  }
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.JABBER);
  accountID.setAccountProperties(accountProperties);
  this.storeAccount(accountID);
  Hashtable<String,String> properties=new Hashtable<String,String>();
  properties.put(PROTOCOL,ProtocolNames.JABBER);
  properties.put(USER_ID,accountID.getUserID());
  ((ProtocolProviderServiceJabberImpl)protocolProvider).initialize(accountID.getUserID(),accountID);
  this.storeAccount(accountID);
  registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
  registeredAccounts.put(accountID,registration);
}","/** 
 * Modify an existing account.
 * @param protocolProvider the <tt>ProtocolProviderService</tt> responsibleof the account
 * @param accountProperties modified properties to be set
 */
@Override public void modifyAccount(ProtocolProviderService protocolProvider,Map<String,String> accountProperties) throws NullPointerException {
  BundleContext context=JabberActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  JabberAccountID accountID=(JabberAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=registeredAccounts.get(accountID);
  if (registration != null) {
    try {
      if (protocolProvider.isRegistered()) {
        protocolProvider.unregister();
        protocolProvider.shutdown();
      }
    }
 catch (    Throwable e) {
    }
    registration.unregister();
  }
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  accountProperties.put(USER_ID,accountID.getUserID());
  String serverAddress=accountProperties.get(SERVER_ADDRESS);
  if (serverAddress == null)   throw new NullPointerException(""String_Node_Str"");
  if (accountProperties.get(SERVER_PORT) == null) {
    accountProperties.put(SERVER_PORT,""String_Node_Str"");
  }
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.JABBER);
  accountID.setAccountProperties(accountProperties);
  AccountManager accManager=getAccountManager();
  ConfigurationService configSrvc=JabberActivator.getConfigurationService();
  String accountNodeName=getAccountManager().getAccountNodeName(this,accountID);
  String factoryPackage=accManager.getFactoryImplPackageName(this);
  String accountPrefix=factoryPackage + ""String_Node_Str"" + accountNodeName;
  List<String> allProperties=configSrvc.getAllPropertyNames();
  String stunPrefix=accountPrefix + ""String_Node_Str"" + ProtocolProviderFactory.STUN_PREFIX;
  String jinglePrefix=accountPrefix + ""String_Node_Str"" + JingleNodeDescriptor.JN_PREFIX;
  for (  String property : allProperties) {
    if (property.startsWith(stunPrefix) || property.startsWith(jinglePrefix)) {
      configSrvc.removeProperty(property);
    }
  }
  this.storeAccount(accountID);
  Hashtable<String,String> properties=new Hashtable<String,String>();
  properties.put(PROTOCOL,ProtocolNames.JABBER);
  properties.put(USER_ID,accountID.getUserID());
  ((ProtocolProviderServiceJabberImpl)protocolProvider).initialize(accountID.getUserID(),accountID);
  this.storeAccount(accountID);
  registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
  registeredAccounts.put(accountID,registration);
}",0.8413510747185261
103126,"/** 
 * Stores an account represented in the form of an <tt>AccountID</tt> created by a specific <tt>ProtocolProviderFactory</tt>.
 * @param factory the <tt>ProtocolProviderFactory</tt> which created theaccount to be stored
 * @param accountID the account in the form of <tt>AccountID</tt> to bestored
 * @throws OperationFailedException if anything goes wrong while storing theaccount
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID) throws OperationFailedException {
synchronized (storedAccounts) {
    if (!storedAccounts.contains(accountID))     storedAccounts.add(accountID);
  }
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configurationService.getPropertyNamesByPrefix(factoryPackage,true);
  String accountUID=accountID.getAccountUniqueID();
  String accountNodeName=null;
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    int dotIndex=storedAccount.lastIndexOf(""String_Node_Str"");
    if (!storedAccount.substring(dotIndex + 1).startsWith(ACCOUNT_UID_PREFIX))     continue;
    String storedAccountUID=configurationService.getString(storedAccount + ""String_Node_Str"" + ProtocolProviderFactory.ACCOUNT_UID);
    if (storedAccountUID.equals(accountUID))     accountNodeName=configurationService.getString(storedAccount);
  }
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=ACCOUNT_UID_PREFIX + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    String secureStorePrefix=null;
    if (property.equals(ProtocolProviderFactory.PASSWORD)) {
      String accountPrefix=factoryPackage + ""String_Node_Str"" + accountNodeName;
      secureStorePrefix=accountPrefix;
    }
 else     if (property.endsWith(""String_Node_Str"" + ProtocolProviderFactory.PASSWORD)) {
      secureStorePrefix=factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property.substring(0,property.lastIndexOf(""String_Node_Str""));
    }
    if (secureStorePrefix != null) {
      CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
      if ((value != null) && (value.length() != 0) && !credentialsStorage.storePassword(secureStorePrefix,value)) {
        throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
      }
    }
 else {
      configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
    }
  }
  if (!accountProperties.containsKey(ProtocolProviderFactory.PASSWORD)) {
    CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
    credentialsStorage.removePassword(factoryPackage + ""String_Node_Str"" + accountNodeName);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}","/** 
 * Stores an account represented in the form of an <tt>AccountID</tt> created by a specific <tt>ProtocolProviderFactory</tt>.
 * @param factory the <tt>ProtocolProviderFactory</tt> which created theaccount to be stored
 * @param accountID the account in the form of <tt>AccountID</tt> to bestored
 * @throws OperationFailedException if anything goes wrong while storing theaccount
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID) throws OperationFailedException {
synchronized (storedAccounts) {
    if (!storedAccounts.contains(accountID))     storedAccounts.add(accountID);
  }
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  String accountNodeName=getAccountNodeName(factory,accountID);
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=ACCOUNT_UID_PREFIX + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    String secureStorePrefix=null;
    if (property.equals(ProtocolProviderFactory.PASSWORD)) {
      String accountPrefix=factoryPackage + ""String_Node_Str"" + accountNodeName;
      secureStorePrefix=accountPrefix;
    }
 else     if (property.endsWith(""String_Node_Str"" + ProtocolProviderFactory.PASSWORD)) {
      secureStorePrefix=factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property.substring(0,property.lastIndexOf(""String_Node_Str""));
    }
    if (secureStorePrefix != null) {
      CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
      if ((value != null) && (value.length() != 0) && !credentialsStorage.storePassword(secureStorePrefix,value)) {
        throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
      }
    }
 else {
      configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
    }
  }
  if (!accountProperties.containsKey(ProtocolProviderFactory.PASSWORD)) {
    CredentialsStorageService credentialsStorage=ServiceUtils.getService(bundleContext,CredentialsStorageService.class);
    credentialsStorage.removePassword(factoryPackage + ""String_Node_Str"" + accountNodeName);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}",0.888532711642139
103127,"/** 
 * Returns the package name of the <tt>factory</tt>.
 * @param factory the factory which package will be returned.
 * @return the package name of the <tt>factory</tt>.
 */
private String getFactoryImplPackageName(ProtocolProviderFactory factory){
  String className=factory.getClass().getName();
  return className.substring(0,className.lastIndexOf('.'));
}","/** 
 * Returns the package name of the <tt>factory</tt>.
 * @param factory the factory which package will be returned.
 * @return the package name of the <tt>factory</tt>.
 */
public String getFactoryImplPackageName(ProtocolProviderFactory factory){
  String className=factory.getClass().getName();
  return className.substring(0,className.lastIndexOf('.'));
}",0.9847856154910096
103128,"/** 
 * Get the <tt>AccountManager</tt> of the protocol.
 * @return <tt>AccountManager</tt> of the protocol
 */
private AccountManager getAccountManager(){
  BundleContext bundleContext=getBundleContext();
  ServiceReference serviceReference=bundleContext.getServiceReference(AccountManager.class.getName());
  return (AccountManager)bundleContext.getService(serviceReference);
}","/** 
 * Get the <tt>AccountManager</tt> of the protocol.
 * @return <tt>AccountManager</tt> of the protocol
 */
protected AccountManager getAccountManager(){
  BundleContext bundleContext=getBundleContext();
  ServiceReference serviceReference=bundleContext.getServiceReference(AccountManager.class.getName());
  return (AccountManager)bundleContext.getService(serviceReference);
}",0.9842105263157894
103129,"/** 
 * Stores configuration properties held by this object into given <tt>accountProperties</tt> map.
 * @param protocolIconPath  the path to the protocol icon is used
 * @param accountIconPath   the path to the account icon if used
 * @param accountProperties output properties map
 */
public void storeProperties(String protocolIconPath,String accountIconPath,Map<String,String> accountProperties){
  putAccountProperty(ProtocolProviderFactory.PROTOCOL,getProtocolName());
  if (protocolIconPath != null)   setProtocolIconPath(protocolIconPath);
  if (accountIconPath != null)   setAccountIconPath(accountIconPath);
  ensureDefaultValuePresent(ProtocolProviderFactory.DTMF_METHOD);
  ensureDefaultValuePresent(ProtocolProviderFactory.DTMF_MINIMAL_TONE_DURATION);
  mergeProperties(this.accountProperties,accountProperties);
}","/** 
 * Stores configuration properties held by this object into given <tt>accountProperties</tt> map.
 * @param protocolIconPath  the path to the protocol icon is used
 * @param accountIconPath   the path to the account icon if used
 * @param accountProperties output properties map
 */
public void storeProperties(String protocolIconPath,String accountIconPath,Map<String,String> accountProperties){
  if (protocolIconPath != null)   setProtocolIconPath(protocolIconPath);
  if (accountIconPath != null)   setAccountIconPath(accountIconPath);
  ensureDefaultValuePresent(ProtocolProviderFactory.DTMF_METHOD);
  ensureDefaultValuePresent(ProtocolProviderFactory.DTMF_MINIMAL_TONE_DURATION);
  mergeProperties(this.accountProperties,accountProperties);
  accountProperties.remove(""String_Node_Str"");
}",0.9257213014119092
103130,"/** 
 * On mac, asks FileManager to open the the url, on Windows uses FileProtocolHandler to do so, on Linux, loops through a list of known browsers until we find one that seems to work.
 */
@Override public void run(){
  try {
    String osName=System.getProperty(""String_Node_Str"");
    if ((osName != null) && osName.startsWith(""String_Node_Str"")) {
      FileManager.openURL(url);
    }
 else     if ((osName != null) && osName.startsWith(""String_Node_Str"")) {
      Runtime.getRuntime().exec(""String_Node_Str"" + url);
    }
 else {
      String[] browsers={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      String browser=null;
      for (int i=0; i < browsers.length && browser == null; i++) {
        if (Runtime.getRuntime().exec(new String[]{""String_Node_Str"",browsers[i]}).waitFor() == 0)         browser=browsers[i];
      }
      if (browser == null)       throw new Exception(""String_Node_Str"");
 else       Runtime.getRuntime().exec(new String[]{browser,url});
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * On mac, asks FileManager to open the the url, on Windows uses FileProtocolHandler to do so, on Linux, loops through a list of known browsers until we find one that seems to work.
 */
public void run(){
  try {
    String osName=System.getProperty(""String_Node_Str"");
    if ((osName != null) && osName.startsWith(""String_Node_Str"")) {
      FileManager.openURL(url);
    }
 else     if ((osName != null) && osName.startsWith(""String_Node_Str"")) {
      Runtime.getRuntime().exec(""String_Node_Str"" + url);
    }
 else {
      String[] browsers={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      String browser=null;
      for (int i=0; i < browsers.length && browser == null; i++) {
        if (Runtime.getRuntime().exec(new String[]{""String_Node_Str"",browsers[i]}).waitFor() == 0)         browser=browsers[i];
      }
      if (browser == null)       throw new Exception(""String_Node_Str"");
 else       Runtime.getRuntime().exec(new String[]{browser,url});
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9955317247542448
103131,"/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallConference</tt>, the participating <tt>Call</tt>s, and their associated <tt>CallPeer</tt>s). Invoked by <tt>CallManager</tt> when it determines that this <tt>CallPanel</tt> is no longer necessary.
 */
void dispose(){
  disposed=true;
  callConference.removeCallChangeListener(callConferenceListener);
  callConference.removeCallPeerConferenceListener(callConferenceListener);
  callConference.removePropertyChangeListener(callConferenceListener);
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
  uiVideoHandler.dispose();
  callWindow.getFrame().removePropertyChangeListener(CallContainer.PROP_FULL_SCREEN,callConferenceListener);
  if (callPanel != null)   ((CallRenderer)callPanel).dispose();
}","/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallConference</tt>, the participating <tt>Call</tt>s, and their associated <tt>CallPeer</tt>s). Invoked by <tt>CallManager</tt> when it determines that this <tt>CallPanel</tt> is no longer necessary.
 */
void dispose(){
  disposed=true;
  callConference.removeCallChangeListener(callConferenceListener);
  callConference.removeCallPeerConferenceListener(callConferenceListener);
  callConference.removePropertyChangeListener(callConferenceListener);
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
  uiVideoHandler.dispose();
  callWindow.getFrame().removePropertyChangeListener(CallContainer.PROP_FULL_SCREEN,callConferenceListener);
  if (callPanel != null) {
    if (callPanel instanceof BasicConferenceCallPanel) {
      ((BasicConferenceCallPanel)callPanel).removePeerViewListener(this);
    }
    ((CallRenderer)callPanel).dispose();
  }
}",0.9209809264305178
103132,"/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>. The update is performed in the AWT event dispatching thread.
 */
private void doUpdateViewFromModelInEventDispatchThread(){
  if (callConference.isEnded() || (callConference.getCallPeerCount() == 0)) {
    updateSettingsPanelInEventDispatchThread(true);
    return;
  }
  boolean isConference=isConference();
  boolean isVideo=CallManager.isVideoStreaming(callConference);
  CallPeer callPeer=null;
  boolean validateAndRepaint=false;
  if (callPanel != null) {
    boolean removeCallPanel;
    if (isConference) {
      if (callPanel instanceof BasicConferenceCallPanel) {
        if (isVideo) {
          removeCallPanel=!(callPanel instanceof VideoConferenceCallPanel);
        }
 else {
          removeCallPanel=(callPanel instanceof VideoConferenceCallPanel);
        }
      }
 else {
        removeCallPanel=true;
      }
    }
 else {
      if (callPanel instanceof OneToOneCallPanel) {
        if (callPeer == null) {
          List<CallPeer> callPeers=callConference.getCallPeers();
          if (!callPeers.isEmpty())           callPeer=callPeers.get(0);
        }
        removeCallPanel=!((OneToOneCallPanel)callPanel).getCallPeer().equals(callPeer);
      }
 else       removeCallPanel=true;
    }
    if (removeCallPanel) {
      remove(callPanel);
      validateAndRepaint=true;
      try {
        ((CallRenderer)callPanel).dispose();
      }
  finally {
        callPanel=null;
      }
    }
  }
  if (callPanel == null) {
    if (isConference) {
      if (isVideo) {
        callPanel=new VideoConferenceCallPanel(this,callConference,uiVideoHandler);
      }
 else {
        callPanel=new AudioConferenceCallPanel(this,callConference);
      }
    }
 else {
      if (callPeer == null) {
        List<CallPeer> callPeers=callConference.getCallPeers();
        if (!callPeers.isEmpty())         callPeer=callPeers.get(0);
      }
      if (callPeer != null) {
        callPanel=new OneToOneCallPanel(this,callPeer,uiVideoHandler);
      }
    }
    if (callPanel != null) {
      add(callPanel,BorderLayout.CENTER);
      validateAndRepaint=true;
    }
  }
  try {
    updateSettingsPanelInEventDispatchThread(false);
  }
  finally {
    if (validateAndRepaint) {
      if (isDisplayable()) {
        validate();
        repaint();
      }
 else       doLayout();
    }
  }
}","/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>. The update is performed in the AWT event dispatching thread.
 */
private void doUpdateViewFromModelInEventDispatchThread(){
  if (callConference.isEnded() || (callConference.getCallPeerCount() == 0)) {
    updateSettingsPanelInEventDispatchThread(true);
    return;
  }
  boolean isConference=isConference();
  boolean isVideo=CallManager.isVideoStreaming(callConference);
  CallPeer callPeer=null;
  boolean validateAndRepaint=false;
  if (callPanel != null) {
    boolean removeCallPanel;
    if (isConference) {
      if (callPanel instanceof BasicConferenceCallPanel) {
        if (isVideo) {
          removeCallPanel=!(callPanel instanceof VideoConferenceCallPanel);
        }
 else {
          removeCallPanel=(callPanel instanceof VideoConferenceCallPanel);
        }
      }
 else {
        removeCallPanel=true;
      }
    }
 else {
      if (callPanel instanceof OneToOneCallPanel) {
        if (callPeer == null) {
          List<CallPeer> callPeers=callConference.getCallPeers();
          if (!callPeers.isEmpty())           callPeer=callPeers.get(0);
        }
        removeCallPanel=!((OneToOneCallPanel)callPanel).getCallPeer().equals(callPeer);
      }
 else {
        if ((callPanel instanceof BasicConferenceCallPanel) && ((BasicConferenceCallPanel)callPanel).hasDelayedCallPeers()) {
          removeCallPanel=false;
        }
 else {
          removeCallPanel=true;
        }
      }
    }
    if (removeCallPanel) {
      remove(callPanel);
      validateAndRepaint=true;
      try {
        ((CallRenderer)callPanel).dispose();
      }
  finally {
        callPanel=null;
      }
    }
  }
  if (callPanel == null) {
    if (isConference) {
      if (isVideo) {
        callPanel=new VideoConferenceCallPanel(this,callConference,uiVideoHandler);
      }
 else {
        callPanel=new AudioConferenceCallPanel(this,callConference);
      }
      ((BasicConferenceCallPanel)callPanel).addPeerViewlListener(this);
    }
 else {
      if (callPeer == null) {
        List<CallPeer> callPeers=callConference.getCallPeers();
        if (!callPeers.isEmpty())         callPeer=callPeers.get(0);
      }
      if (callPeer != null) {
        callPanel=new OneToOneCallPanel(this,callPeer,uiVideoHandler);
      }
    }
    if (callPanel != null) {
      add(callPanel,BorderLayout.CENTER);
      validateAndRepaint=true;
    }
  }
  try {
    updateSettingsPanelInEventDispatchThread(false);
  }
  finally {
    if (validateAndRepaint) {
      if (isDisplayable()) {
        validate();
        repaint();
      }
 else       doLayout();
    }
  }
}",0.946690099589924
103133,"/** 
 * Decrypts the cyphertext using the key.
 * @param ciphertext base64 encoded encrypted data
 * @return decrypted data
 * @throws CryptoException when the ciphertext cannot be decrypted with thekey or on decryption error.
 */
public String decrypt(String ciphertext) throws CryptoException {
  try {
    decryptCipher.init(Cipher.DECRYPT_MODE,key);
    return new String(decryptCipher.doFinal(Base64.decode(ciphertext)));
  }
 catch (  BadPaddingException e) {
    throw new CryptoException(CryptoException.WRONG_KEY,e);
  }
catch (  Exception e) {
    throw new CryptoException(CryptoException.DECRYPTION_ERROR,e);
  }
}","/** 
 * Decrypts the cyphertext using the key.
 * @param ciphertext base64 encoded encrypted data
 * @return decrypted data
 * @throws CryptoException when the ciphertext cannot be decrypted with thekey or on decryption error.
 */
public String decrypt(String ciphertext) throws CryptoException {
  try {
    decryptCipher.init(Cipher.DECRYPT_MODE,key);
    return new String(decryptCipher.doFinal(Base64.decode(ciphertext)),""String_Node_Str"");
  }
 catch (  BadPaddingException e) {
    throw new CryptoException(CryptoException.WRONG_KEY,e);
  }
catch (  Exception e) {
    throw new CryptoException(CryptoException.DECRYPTION_ERROR,e);
  }
}",0.9858267716535432
103134,"/** 
 * Indicates that a contact has been clicked in the contact list. Show some more contacts after the ""show more"" has been clicked
 * @param evt the <tt>ContactListEvent</tt> that notified us
 */
public void contactClicked(ContactListEvent evt){
  if (evt.getSourceContact().equals(this)) {
    List<SourceContact> contacts=new ArrayList<SourceContact>(queryResults);
    int newCount=shownResultsCount + maxResultCount;
    int resultSize=contacts.size();
    int maxCount=(resultSize > newCount) ? newCount : resultSize;
    GuiActivator.getContactList().removeContact(this);
    for (int i=shownResultsCount; i < maxCount; i++) {
      GuiActivator.getContactList().contactReceived(new ContactReceivedEvent(contactQuery,contacts.get(i)));
    }
    shownResultsCount=maxCount;
    if (shownResultsCount < resultSize || contactQuery.getStatus() != ContactQuery.QUERY_COMPLETED)     GuiActivator.getContactList().addContact(contactQuery,this,GuiActivator.getContactList().getContactSource(contactQuery.getContactSource()).getUIGroup(),false);
  }
}","/** 
 * Indicates that a contact has been clicked in the contact list. Show some more contacts after the ""show more"" has been clicked
 * @param evt the <tt>ContactListEvent</tt> that notified us
 */
public void contactClicked(ContactListEvent evt){
  if (evt.getSourceContact().equals(this)) {
    List<SourceContact> contacts=new ArrayList<SourceContact>(queryResults);
    int newCount=shownResultsCount + maxResultCount;
    int resultSize=contacts.size();
    int maxCount=(resultSize > newCount) ? newCount : resultSize;
    GuiActivator.getContactList().removeContact(this);
    for (int i=shownResultsCount; i < maxCount; i++) {
      GuiActivator.getContactList().contactReceived(new ContactReceivedEvent(contactQuery,contacts.get(i)));
    }
    shownResultsCount=maxCount;
    if (shownResultsCount < resultSize || (contactQuery.getStatus() != ContactQuery.QUERY_COMPLETED && contactQuery.getStatus() != ContactQuery.QUERY_ERROR)) {
      GuiActivator.getContactList().addContact(contactQuery,this,GuiActivator.getContactList().getContactSource(contactQuery.getContactSource()).getUIGroup(),false);
      GuiActivator.getContactList().addContactListListener(this);
    }
  }
}",0.93923145665773
103135,"/** 
 * Creates an instance of <tt>MoreInfoContact</tt>.
 * @param contactQuery the contact query
 * @param queryResults the result list
 * @param maxResultCount the maximum result count
 */
public ShowMoreContact(ContactQuery contactQuery,List<SourceContact> queryResults,int maxResultCount){
  this.contactQuery=contactQuery;
  this.queryResults=queryResults;
  this.maxResultCount=maxResultCount;
  GuiActivator.getContactList().addContactListListener(this);
}","/** 
 * Creates an instance of <tt>MoreInfoContact</tt>.
 * @param contactQuery the contact query
 * @param queryResults the result list
 * @param maxResultCount the maximum result count
 */
public ShowMoreContact(ContactQuery contactQuery,List<SourceContact> queryResults,int maxResultCount){
  this.contactQuery=contactQuery;
  this.queryResults=queryResults;
  this.maxResultCount=maxResultCount;
  this.shownResultsCount=maxResultCount;
  GuiActivator.getContactList().addContactListListener(this);
}",0.9576008273009308
103136,"/** 
 * Process LDAP event.
 * @param evt LDAP event
 */
private void processLdapResponse(LdapEvent evt){
  if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ACHIEVED || evt.getCause() == LdapEvent.LdapEventCause.SEARCH_CANCELLED) {
synchronized (objLock) {
      objLock.notify();
    }
  }
  if (evt.getCause() == LdapEvent.LdapEventCause.NEW_SEARCH_RESULT) {
    LdapPersonFound person=(LdapPersonFound)evt.getContent();
    String displayName=null;
    if (person == null) {
      return;
    }
    if (person.getDisplayName() != null) {
      displayName=person.getDisplayName();
    }
 else {
      displayName=person.getFirstName() + ""String_Node_Str"" + person.getSurname();
    }
    List<ContactDetail> contactDetails=getContactDetails(person);
    if (!contactDetails.isEmpty()) {
      GenericSourceContact sourceContact=new GenericSourceContact(getContactSource(),displayName,contactDetails);
      try {
        sourceContact.setImage(person.fetchPhoto());
      }
 catch (      OutOfMemoryError oome) {
      }
      if (person.getOrganization() != null) {
        sourceContact.setDisplayDetails(person.getOrganization());
      }
      addQueryResult(sourceContact);
    }
  }
 else   if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_AUTH_ERROR) {
synchronized (objLock) {
      objLock.notify();
    }
    new Thread(){
      public void run(){
        LdapDirectorySettingsImpl ldapSettings=(LdapDirectorySettingsImpl)getContactSource().getLdapDirectory().getSettings();
        AuthenticationWindow authWindow=new AuthenticationWindow(ldapSettings.getUserName(),ldapSettings.getPassword().toCharArray(),ldapSettings.getName(),false,LdapActivator.getResourceService().getImage(""String_Node_Str""),LdapActivator.getResourceService().getI18NString(""String_Node_Str"",new String[]{ldapSettings.getName()}));
        authWindow.setVisible(true);
        if (!authWindow.isCanceled()) {
          LdapDirectorySettings newSettings=new LdapDirectorySettingsImpl(ldapSettings);
          LdapService ldapService=LdapActivator.getLdapService();
          LdapFactory factory=ldapService.getFactory();
          LdapDirectory ldapDir=getContactSource().getLdapDirectory();
          LdapActivator.unregisterContactSource(ldapDir);
          ldapService.getServerSet().removeServerWithName(ldapSettings.getName());
          newSettings.setPassword(new String(authWindow.getPassword()));
          ldapDir=factory.createServer(newSettings);
          ldapService.getServerSet().addServer(ldapDir);
          LdapActivator.registerContactSource(ldapDir);
        }
      }
    }
.start();
  }
}","/** 
 * Process LDAP event.
 * @param evt LDAP event
 */
private void processLdapResponse(LdapEvent evt){
  if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ACHIEVED || evt.getCause() == LdapEvent.LdapEventCause.SEARCH_CANCELLED) {
synchronized (objLock) {
      objLock.notify();
    }
  }
  if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ERROR) {
    setStatus(ContactQuery.QUERY_ERROR);
synchronized (objLock) {
      objLock.notify();
    }
  }
  if (evt.getCause() == LdapEvent.LdapEventCause.NEW_SEARCH_RESULT) {
    LdapPersonFound person=(LdapPersonFound)evt.getContent();
    String displayName=null;
    if (person == null) {
      return;
    }
    if (person.getDisplayName() != null) {
      displayName=person.getDisplayName();
    }
 else {
      displayName=person.getFirstName() + ""String_Node_Str"" + person.getSurname();
    }
    List<ContactDetail> contactDetails=getContactDetails(person);
    if (!contactDetails.isEmpty()) {
      GenericSourceContact sourceContact=new GenericSourceContact(getContactSource(),displayName,contactDetails);
      try {
        sourceContact.setImage(person.fetchPhoto());
      }
 catch (      OutOfMemoryError oome) {
      }
      if (person.getOrganization() != null) {
        sourceContact.setDisplayDetails(person.getOrganization());
      }
      addQueryResult(sourceContact);
    }
  }
 else   if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_AUTH_ERROR) {
synchronized (objLock) {
      objLock.notify();
    }
    new Thread(){
      public void run(){
        LdapDirectorySettingsImpl ldapSettings=(LdapDirectorySettingsImpl)getContactSource().getLdapDirectory().getSettings();
        AuthenticationWindow authWindow=new AuthenticationWindow(ldapSettings.getUserName(),ldapSettings.getPassword().toCharArray(),ldapSettings.getName(),false,LdapActivator.getResourceService().getImage(""String_Node_Str""),LdapActivator.getResourceService().getI18NString(""String_Node_Str"",new String[]{ldapSettings.getName()}));
        authWindow.setVisible(true);
        if (!authWindow.isCanceled()) {
          LdapDirectorySettings newSettings=new LdapDirectorySettingsImpl(ldapSettings);
          LdapService ldapService=LdapActivator.getLdapService();
          LdapFactory factory=ldapService.getFactory();
          LdapDirectory ldapDir=getContactSource().getLdapDirectory();
          LdapActivator.unregisterContactSource(ldapDir);
          ldapService.getServerSet().removeServerWithName(ldapSettings.getName());
          newSettings.setPassword(new String(authWindow.getPassword()));
          ldapDir=factory.createServer(newSettings);
          ldapService.getServerSet().addServer(ldapDir);
          LdapActivator.registerContactSource(ldapDir);
        }
      }
    }
.start();
  }
}",0.9693365545437652
103137,"/** 
 * Adds a <tt>ConferenceMemberPanel</tt> to depict a specific <tt>ConferenceMember</tt> if there is not one yet.
 * @param conferenceMember the <tt>ConferenceMember</tt> to be depicted
 */
private void addConferenceMemberPanel(ConferenceMember conferenceMember){
  if (CallManager.isLocalUser(conferenceMember))   return;
  if (CallManager.addressesAreEqual(conferenceMember.getAddress(),focusPeer.getAddress()))   return;
  if (conferenceMemberPanels.containsKey(conferenceMember))   return;
  ConferenceMemberPanel conferenceMemberPanel=new ConferenceMemberPanel(callRenderer,conferenceMember,false);
  conferenceMemberPanels.put(conferenceMember,conferenceMemberPanel);
  add(conferenceMemberPanel,cnstrnts);
  cnstrnts.gridy++;
  initSecuritySettings();
}","/** 
 * Adds a <tt>ConferenceMemberPanel</tt> to depict a specific <tt>ConferenceMember</tt> if there is not one yet.
 * @param conferenceMember the <tt>ConferenceMember</tt> to be depicted
 */
private void addConferenceMemberPanel(ConferenceMember conferenceMember){
  if (CallManager.isLocalUser(conferenceMember))   return;
  if (CallManager.addressesAreEqual(conferenceMember.getAddress(),focusPeer.getAddress()))   return;
  if (conferenceMemberPanels.containsKey(conferenceMember))   return;
  ConferenceMemberPanel conferenceMemberPanel=new ConferenceMemberPanel(callRenderer,conferenceMember,false);
  conferenceMemberPanels.put(conferenceMember,conferenceMemberPanel);
  add(conferenceMemberPanel,cnstrnts);
  cnstrnts.gridy++;
  initSecuritySettings();
  packWindow();
}",0.9896373056994818
103138,"/** 
 * Removes the <tt>ConferenceMemberPanel</tt> depicting a specific <tt>ConferenceMember</tt>.
 * @param conferenceMember the <tt>ConferenceMember</tt> whose depicting<tt>ConferenceMemberPanel</tt> is to be removed
 */
private void removeConferenceMemberPanel(ConferenceMember conferenceMember){
  ConferenceMemberPanel conferenceMemberPanel=conferenceMemberPanels.remove(conferenceMember);
  if (conferenceMemberPanel != null) {
    remove(conferenceMemberPanel);
    conferenceMemberPanel.dispose();
  }
}","/** 
 * Removes the <tt>ConferenceMemberPanel</tt> depicting a specific <tt>ConferenceMember</tt>.
 * @param conferenceMember the <tt>ConferenceMember</tt> whose depicting<tt>ConferenceMemberPanel</tt> is to be removed
 */
private void removeConferenceMemberPanel(ConferenceMember conferenceMember){
  ConferenceMemberPanel conferenceMemberPanel=conferenceMemberPanels.remove(conferenceMember);
  if (conferenceMemberPanel != null) {
    remove(conferenceMemberPanel);
    conferenceMemberPanel.dispose();
    packWindow();
  }
}",0.9826923076923076
103139,"/** 
 * Adds the <tt>ConferencePeerPanel</tt> which will depict  {@link #focusPeer} without the <tt>ConferenceMember</tt>s whichparticipate in the telephony conference that it is the focus of.
 */
private void addFocusPeerPanel(){
  focusPeerPanel=new ConferencePeerPanel(callRenderer,focusPeer);
  add(focusPeerPanel,cnstrnts);
  cnstrnts.gridy++;
}","/** 
 * Adds the <tt>ConferencePeerPanel</tt> which will depict  {@link #focusPeer} without the <tt>ConferenceMember</tt>s whichparticipate in the telephony conference that it is the focus of.
 */
private void addFocusPeerPanel(){
  focusPeerPanel=new ConferencePeerPanel(callRenderer,focusPeer);
  add(focusPeerPanel,cnstrnts);
  cnstrnts.gridy++;
  packWindow();
}",0.9776536312849162
103140,"/** 
 * Creates a contact list component.
 * @return the created <tt>ContactList</tt>
 */
public ContactList createContactListComponent(){
  return new TreeContactList();
}","/** 
 * Creates a contact list component.
 * @param clContainer the parent contact list container
 * @return the created <tt>ContactList</tt>
 */
public ContactList createContactListComponent(ContactListContainer clContainer){
  return new TreeContactList(clContainer);
}",0.7765237020316027
103141,"/** 
 * Initializes the contact list.
 * @param contactListService The MetaContactListService which will be usedfor a contact list data model.
 */
public void initList(MetaContactListService contactListService){
  this.contactList=new TreeContactList();
  GuiActivator.setContactList(contactList);
  contactList.applyFilter(TreeContactList.presenceFilter);
  TransparentPanel transparentPanel=new TransparentPanel(new BorderLayout());
  transparentPanel.add(contactList,BorderLayout.NORTH);
  this.setViewportView(transparentPanel);
  transparentPanel.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
  this.contactList.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.contactList.addContactListListener(this);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
        commonRightButtonMenu=new CommonRightButtonMenu(mainFrame);
        commonRightButtonMenu.setInvoker(ContactListPane.this);
        commonRightButtonMenu.setLocation(e.getX() + mainFrame.getX() + 5,e.getY() + mainFrame.getY() + 105);
        commonRightButtonMenu.setVisible(true);
      }
    }
  }
);
}","/** 
 * Initializes the contact list.
 * @param contactListService The MetaContactListService which will be usedfor a contact list data model.
 */
public void initList(MetaContactListService contactListService){
  this.contactList=new TreeContactList(mainFrame);
  GuiActivator.setContactList(contactList);
  contactList.applyFilter(TreeContactList.presenceFilter);
  TransparentPanel transparentPanel=new TransparentPanel(new BorderLayout());
  transparentPanel.add(contactList,BorderLayout.NORTH);
  this.setViewportView(transparentPanel);
  transparentPanel.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
  this.contactList.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.contactList.addContactListListener(this);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
        commonRightButtonMenu=new CommonRightButtonMenu(mainFrame);
        commonRightButtonMenu.setInvoker(ContactListPane.this);
        commonRightButtonMenu.setLocation(e.getX() + mainFrame.getX() + 5,e.getY() + mainFrame.getY() + 105);
        commonRightButtonMenu.setVisible(true);
      }
    }
  }
);
}",0.9962421711899792
103142,"/** 
 * Creates the <tt>TreeContactList</tt>.
 */
public TreeContactList(){
  originalMouseListeners=this.getMouseListeners();
  for (  MouseListener listener : originalMouseListeners)   this.removeMouseListener(listener);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addTreeExpansionListener(this);
  this.addTreeSelectionListener(this);
  GuiActivator.getContactListService().addMetaContactListListener(mclSource);
  treeModel=new ContactListTreeModel(this);
  setTreeModel(treeModel);
  if (isRootVisible())   setRootVisible(false);
  this.initKeyActions();
  this.initContactSources();
}","/** 
 * Creates the <tt>TreeContactList</tt>.
 * @param clContainer the container, where this contact list component isadded
 */
public TreeContactList(ContactListContainer clContainer){
  parentCLContainer=clContainer;
  originalMouseListeners=this.getMouseListeners();
  for (  MouseListener listener : originalMouseListeners)   this.removeMouseListener(listener);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addTreeExpansionListener(this);
  this.addTreeSelectionListener(this);
  GuiActivator.getContactListService().addMetaContactListListener(mclSource);
  treeModel=new ContactListTreeModel(this);
  setTreeModel(treeModel);
  if (isRootVisible())   setRootVisible(false);
  this.initKeyActions();
  this.initContactSources();
}",0.8961038961038961
103143,"/** 
 * Applies the default filter.
 * @return the filter query that keeps track of the filtering results
 */
public FilterQuery applyDefaultFilter(){
  FilterQuery filterQuery=null;
  final MainFrame mainFrame=GuiActivator.getUIService().getMainFrame();
  String currentSearchText=mainFrame.getCurrentSearchText();
  if (currentSearchText != null && currentSearchText.length() > 0) {
    if (!SwingUtilities.isEventDispatchThread())     SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        mainFrame.clearCurrentSearchText();
      }
    }
);
 else     mainFrame.clearCurrentSearchText();
  }
 else {
    filterQuery=applyFilter(defaultFilter);
  }
  return filterQuery;
}","/** 
 * Applies the default filter.
 * @return the filter query that keeps track of the filtering results
 */
public FilterQuery applyDefaultFilter(){
  FilterQuery filterQuery=null;
  String currentSearchText=parentCLContainer.getCurrentSearchText();
  if (currentSearchText != null && currentSearchText.length() > 0) {
    if (!SwingUtilities.isEventDispatchThread())     SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        parentCLContainer.clearCurrentSearchText();
      }
    }
);
 else     parentCLContainer.clearCurrentSearchText();
  }
 else {
    filterQuery=applyFilter(defaultFilter);
  }
  return filterQuery;
}",0.6264880952380952
103144,"/** 
 * Creates the destination contact list component.
 * @return the created contact list component
 */
private Component createDestContactListComponent(){
  destContactList=GuiActivator.getUIService().createContactListComponent();
  destContactList.setContactButtonsVisible(false);
  destContactList.setRightButtonMenuEnabled(false);
  destContactList.setMultipleSelectionEnabled(true);
  destContactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      if (evt.getClickCount() > 1)       moveContactFromRightToLeft(evt.getSourceContact());
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(destContactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}","/** 
 * Creates the destination contact list component.
 * @return the created contact list component
 */
private Component createDestContactListComponent(){
  destContactList=GuiActivator.getUIService().createContactListComponent(this);
  destContactList.setContactButtonsVisible(false);
  destContactList.setRightButtonMenuEnabled(false);
  destContactList.setMultipleSelectionEnabled(true);
  destContactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      if (evt.getClickCount() > 1)       moveContactFromRightToLeft(evt.getSourceContact());
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(destContactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}",0.9983606557377048
103145,"/** 
 * Creates the source contact list component.
 * @return the created contact list component
 */
private Component createSrcContactListComponent(){
  srcContactList=GuiActivator.getUIService().createContactListComponent();
  srcContactList.setDragEnabled(true);
  srcContactList.setRightButtonMenuEnabled(false);
  srcContactList.setContactButtonsVisible(false);
  srcContactList.setMultipleSelectionEnabled(true);
  srcContactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      if (evt.getClickCount() > 1)       moveContactFromLeftToRight(evt.getSourceContact());
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(srcContactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}","/** 
 * Creates the source contact list component.
 * @return the created contact list component
 */
private Component createSrcContactListComponent(){
  srcContactList=GuiActivator.getUIService().createContactListComponent(this);
  srcContactList.setDragEnabled(true);
  srcContactList.setRightButtonMenuEnabled(false);
  srcContactList.setContactButtonsVisible(false);
  srcContactList.setMultipleSelectionEnabled(true);
  srcContactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      if (evt.getClickCount() > 1)       moveContactFromLeftToRight(evt.getSourceContact());
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(srcContactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}",0.9983961507618284
103146,"/** 
 * Creates the contact list component.
 * @return the created contact list component
 */
private Component createContactListComponent(){
  contactList=GuiActivator.getUIService().createContactListComponent();
  contactList.setContactButtonsVisible(false);
  contactList.setRightButtonMenuEnabled(false);
  contactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      int clickCount=evt.getClickCount();
      if (clickCount > 1) {
        okButton.doClick();
      }
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(contactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}","/** 
 * Creates the contact list component.
 * @return the created contact list component
 */
private Component createContactListComponent(){
  contactList=GuiActivator.getUIService().createContactListComponent(this);
  contactList.setContactButtonsVisible(false);
  contactList.setRightButtonMenuEnabled(false);
  contactList.addContactListListener(new ContactListListener(){
    public void groupSelected(    ContactListEvent evt){
    }
    public void groupClicked(    ContactListEvent evt){
    }
    public void contactSelected(    ContactListEvent evt){
    }
    public void contactClicked(    ContactListEvent evt){
      int clickCount=evt.getClickCount();
      if (clickCount > 1) {
        okButton.doClick();
      }
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(contactList.getComponent());
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(null);
  return contactListScrollPane;
}",0.9982517482517482
103147,"/** 
 * Creates a contact list component.
 * @return the created <tt>ContactList</tt>
 */
public ContactList createContactListComponent();","/** 
 * Creates a contact list component.
 * @param clContainer the parent contact list container
 * @return the created <tt>ContactList</tt>
 */
public ContactList createContactListComponent(ContactListContainer clContainer);",0.7582417582417582
103148,"/** 
 * Updates   {@link #settingsPanel} from the model of this view. The update isperformed in the AWT event dispatching thread. <p> The center of this view is occupied by  {@link #callPanel}, the bottom of this view is dedicated to <tt>settingsPanel</tt>. The method  {@link #updateViewFromModelInEventDispatchThread()} updates<tt>callPanel</tt> from the model of this view and then invokes the method <tt>updateSettingsPanelInEventDispatchThread()</tt>. Thus this whole view is updated so that it depicts the current state of its model. </p>
 * @param callConferenceIsEnded <tt>true</tt> if the method<tt>updateViewFromModelInEventDispatchThread()</tt> considers the {@link #callConference} ended; otherwise, <tt>false</tt>. When the<tt>callConference</tt> is considered ended, the <tt>callPanel</tt> instance will not be switched to a specific type (one-to-one, audio-only, or audio/video) because, otherwise, the switch will leave it <tt>null</tt> and this view will remain blank. In such a case, <tt>settingsPanel</tt> may wish to do pretty much the same but disable and/or hide the buttons it contains.
 */
private void doUpdateSettingsPanelInEventDispatchThread(boolean callConferenceIsEnded){
  settingsPanel.setFullScreen(isFullScreen());
  boolean isConference=(callPanel instanceof BasicConferenceCallPanel);
  if (isConference) {
    settingsPanel.add(localLevel);
    settingsPanel.add(remoteLevel);
  }
 else {
    settingsPanel.remove(localLevel);
    settingsPanel.remove(remoteLevel);
  }
  chatButton.setVisible(!isConference && (getIMCapableCallPeers(1).size() == 1));
  updateHoldButtonState();
  updateMergeButtonState();
  List<Call> calls=callConference.getCalls();
  boolean advancedTelephony=!calls.isEmpty();
  boolean telephonyConferencing=false;
  boolean videoTelephony=false;
  boolean videoTelephonyIsLocalVideoAllowed=false;
  boolean videoTelephonyIsLocalVideoStreaming=false;
  boolean desktopSharing=false;
  boolean desktopSharingIsStreamed=false;
  for (  Call call : calls) {
    ProtocolProviderService pps=call.getProtocolProvider();
    if (advancedTelephony) {
      OperationSetAdvancedTelephony<?> osat=pps.getOperationSet(OperationSetAdvancedTelephony.class);
      if (osat == null)       advancedTelephony=false;
    }
    if (!telephonyConferencing) {
      OperationSetTelephonyConferencing ostc=pps.getOperationSet(OperationSetTelephonyConferencing.class);
      if (ostc != null)       telephonyConferencing=true;
    }
    if (!videoTelephony || !videoTelephonyIsLocalVideoAllowed || !videoTelephonyIsLocalVideoStreaming) {
      OperationSetVideoTelephony osvt=pps.getOperationSet(OperationSetVideoTelephony.class);
      if (osvt != null) {
        if (!videoTelephony)         videoTelephony=true;
        if (!videoTelephonyIsLocalVideoAllowed && osvt.isLocalVideoAllowed(call))         videoTelephonyIsLocalVideoAllowed=true;
        if (!videoTelephonyIsLocalVideoStreaming && osvt.isLocalVideoStreaming(call))         videoTelephonyIsLocalVideoStreaming=true;
      }
    }
    if (!desktopSharing) {
      OperationSetDesktopStreaming osds=pps.getOperationSet(OperationSetDesktopStreaming.class);
      if (osds != null) {
        desktopSharing=true;
        if (videoTelephonyIsLocalVideoStreaming && call instanceof MediaAwareCall && ((MediaAwareCall<?,?,?>)call).getMediaUseCase() == MediaUseCase.DESKTOP) {
          desktopSharingIsStreamed=true;
        }
      }
    }
  }
  conferenceButton.setEnabled(telephonyConferencing);
  transferCallButton.setEnabled(advancedTelephony);
  transferCallButton.setVisible(!callConference.isConferenceFocus());
  videoButton.setEnabled(videoTelephony);
  videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);
  showHideVideoButton.setEnabled(videoButton.isEnabled() && videoTelephonyIsLocalVideoAllowed);
  showHideVideoButton.setSelected(showHideVideoButton.isEnabled() && uiVideoHandler.isLocalVideoVisible());
  showHideVideoButton.setVisible(showHideVideoButton.isEnabled());
  desktopSharingButton.setEnabled(desktopSharing);
  desktopSharingButton.setSelected(desktopSharingIsStreamed);
  if (callPanel instanceof OneToOneCallPanel) {
    OneToOneCallPanel oneToOneCallPanel=(OneToOneCallPanel)callPanel;
    if (desktopSharingIsStreamed)     oneToOneCallPanel.addDesktopSharingComponents();
 else     oneToOneCallPanel.removeDesktopSharingComponents();
  }
}","/** 
 * Updates   {@link #settingsPanel} from the model of this view. The update isperformed in the AWT event dispatching thread. <p> The center of this view is occupied by  {@link #callPanel}, the bottom of this view is dedicated to <tt>settingsPanel</tt>. The method  {@link #updateViewFromModelInEventDispatchThread()} updates<tt>callPanel</tt> from the model of this view and then invokes the method <tt>updateSettingsPanelInEventDispatchThread()</tt>. Thus this whole view is updated so that it depicts the current state of its model. </p>
 * @param callConferenceIsEnded <tt>true</tt> if the method<tt>updateViewFromModelInEventDispatchThread()</tt> considers the {@link #callConference} ended; otherwise, <tt>false</tt>. When the<tt>callConference</tt> is considered ended, the <tt>callPanel</tt> instance will not be switched to a specific type (one-to-one, audio-only, or audio/video) because, otherwise, the switch will leave it <tt>null</tt> and this view will remain blank. In such a case, <tt>settingsPanel</tt> may wish to do pretty much the same but disable and/or hide the buttons it contains.
 */
private void doUpdateSettingsPanelInEventDispatchThread(boolean callConferenceIsEnded){
  settingsPanel.setFullScreen(isFullScreen());
  boolean isConference=(callPanel instanceof BasicConferenceCallPanel);
  if (isConference) {
    settingsPanel.add(localLevel);
    settingsPanel.add(remoteLevel);
  }
 else {
    settingsPanel.remove(localLevel);
    settingsPanel.remove(remoteLevel);
  }
  chatButton.setVisible(!isConference && (getIMCapableCallPeers(1).size() == 1));
  updateHoldButtonState();
  updateMergeButtonState();
  List<Call> calls=callConference.getCalls();
  boolean advancedTelephony=!calls.isEmpty();
  boolean telephonyConferencing=false;
  boolean videoTelephony=false;
  boolean videoTelephonyIsLocalVideoAllowed=false;
  boolean videoTelephonyIsLocalVideoStreaming=false;
  boolean desktopSharing=false;
  boolean desktopSharingIsStreamed=false;
  boolean allCallsConnected=true;
  for (  Call call : calls) {
    ProtocolProviderService pps=call.getProtocolProvider();
    if (advancedTelephony) {
      OperationSetAdvancedTelephony<?> osat=pps.getOperationSet(OperationSetAdvancedTelephony.class);
      if (osat == null)       advancedTelephony=false;
    }
    if (!telephonyConferencing) {
      OperationSetTelephonyConferencing ostc=pps.getOperationSet(OperationSetTelephonyConferencing.class);
      if (ostc != null)       telephonyConferencing=true;
    }
    if (!videoTelephony || !videoTelephonyIsLocalVideoAllowed || !videoTelephonyIsLocalVideoStreaming) {
      OperationSetVideoTelephony osvt=pps.getOperationSet(OperationSetVideoTelephony.class);
      if (osvt != null) {
        if (!videoTelephony)         videoTelephony=true;
        if (!videoTelephonyIsLocalVideoAllowed && osvt.isLocalVideoAllowed(call))         videoTelephonyIsLocalVideoAllowed=true;
        if (!videoTelephonyIsLocalVideoStreaming && osvt.isLocalVideoStreaming(call))         videoTelephonyIsLocalVideoStreaming=true;
      }
    }
    if (!desktopSharing) {
      OperationSetDesktopStreaming osds=pps.getOperationSet(OperationSetDesktopStreaming.class);
      if (osds != null) {
        desktopSharing=true;
        if (videoTelephonyIsLocalVideoStreaming && call instanceof MediaAwareCall && ((MediaAwareCall<?,?,?>)call).getMediaUseCase() == MediaUseCase.DESKTOP) {
          desktopSharingIsStreamed=true;
        }
      }
    }
    if (CallState.CALL_IN_PROGRESS != call.getCallState()) {
      allCallsConnected=false;
    }
  }
  conferenceButton.setEnabled(telephonyConferencing);
  transferCallButton.setEnabled(advancedTelephony);
  transferCallButton.setVisible(!callConference.isConferenceFocus());
  videoButton.setEnabled(allCallsConnected && videoTelephony);
  videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);
  showHideVideoButton.setEnabled(videoButton.isEnabled() && videoTelephonyIsLocalVideoAllowed);
  showHideVideoButton.setSelected(showHideVideoButton.isEnabled() && uiVideoHandler.isLocalVideoVisible());
  showHideVideoButton.setVisible(showHideVideoButton.isEnabled());
  desktopSharingButton.setEnabled(desktopSharing);
  desktopSharingButton.setSelected(desktopSharingIsStreamed);
  if (callPanel instanceof OneToOneCallPanel) {
    OneToOneCallPanel oneToOneCallPanel=(OneToOneCallPanel)callPanel;
    if (desktopSharingIsStreamed)     oneToOneCallPanel.addDesktopSharingComponents();
 else     oneToOneCallPanel.removeDesktopSharingComponents();
  }
}",0.9828263553709732
103149,"/** 
 * Shows/hides this dialog.
 * @param isVisible indicates if this dialog should be shown or hidden
 */
public void setVisible(boolean isVisible){
  if (isVisible) {
    preCallWindow.pack();
    preCallWindow.setLocationRelativeTo(null);
  }
  preCallWindow.setVisible(isVisible);
}","/** 
 * Shows/hides this dialog. Synchronized to ensure that only one window can update the global visibleWindows datastructure at a time.
 * @param isVisible indicates if this dialog should be shown or hidden
 */
public synchronized void setVisible(boolean isVisible){
  if (isVisible) {
    preCallWindow.pack();
    preCallWindow.setVisible(isVisible);
    if (visibleWindows.isEmpty()) {
      preCallWindow.setLocationRelativeTo(null);
    }
 else {
      Window last=visibleWindows.get(visibleWindows.size() - 1);
      int newX=last.getX();
      int newY=last.getY() + last.getHeight();
      preCallWindow.setLocation(newX,newY);
    }
    visibleWindows.add(preCallWindow);
  }
 else {
    visibleWindows.remove(preCallWindow);
    preCallWindow.setVisible(isVisible);
  }
}",0.5359477124183006
103150,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by pressing the call or the hangup buttons.
 * @param e The <tt>ActionEvent</tt> to handle.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    callButtonPressed();
  }
 else   if (buttonName.equals(CONF_CALL_BUTTON)) {
    mergeCallButtonPressed();
  }
 else   if (buttonName.equals(VIDEO_CALL_BUTTON)) {
    videoCallButtonPressed();
  }
 else   if (buttonName.equals(HANGUP_BUTTON)) {
    hangupButtonPressed();
  }
  preCallWindow.dispose();
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by pressing the call or the hangup buttons.
 * @param e The <tt>ActionEvent</tt> to handle.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    callButtonPressed();
  }
 else   if (buttonName.equals(CONF_CALL_BUTTON)) {
    mergeCallButtonPressed();
  }
 else   if (buttonName.equals(VIDEO_CALL_BUTTON)) {
    videoCallButtonPressed();
  }
 else   if (buttonName.equals(HANGUP_BUTTON)) {
    hangupButtonPressed();
  }
  dispose();
}",0.9835255354200988
103151,"/** 
 * Disposes this window.
 */
public void dispose(){
  preCallWindow.dispose();
}","/** 
 * Disposes this window.
 */
public void dispose(){
  visibleWindows.remove(preCallWindow);
  preCallWindow.dispose();
}",0.8095238095238095
103152,"/** 
 * Notifies this instance that a specific <tt>ColibriConferenceIQ</tt> has been received.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> which has beenreceived
 */
private void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){
  if (IQ.Type.SET.equals(conferenceIQ.getType()) && conferenceIQ.getID() != null) {
    OperationSetBasicTelephony<?> basicTelephony=protocolProvider.getOperationSet(OperationSetBasicTelephony.class);
    if (basicTelephony != null) {
      Iterator<? extends Call> i=basicTelephony.getActiveCalls();
      while (i.hasNext()) {
        Call call=i.next();
        if (call instanceof CallJabberImpl) {
          CallJabberImpl callJabberImpl=(CallJabberImpl)call;
          MediaAwareCallConference conference=callJabberImpl.getConference();
          if ((conference != null) && conference.isJitsiVideoBridge()) {
            callJabberImpl.processColibriConferenceIQ(conferenceIQ);
            break;
          }
        }
      }
    }
  }
}","/** 
 * Notifies this instance that a specific <tt>ColibriConferenceIQ</tt> has been received.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> which has beenreceived
 */
private void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){
  if (IQ.Type.SET.equals(conferenceIQ.getType()) && conferenceIQ.getID() != null) {
    OperationSetBasicTelephony<?> basicTelephony=protocolProvider.getOperationSet(OperationSetBasicTelephony.class);
    if (basicTelephony != null) {
      Iterator<? extends Call> i=basicTelephony.getActiveCalls();
      while (i.hasNext()) {
        Call call=i.next();
        if (call instanceof CallJabberImpl) {
          CallJabberImpl callJabberImpl=(CallJabberImpl)call;
          MediaAwareCallConference conference=callJabberImpl.getConference();
          if ((conference != null) && conference.isJitsiVideoBridge()) {
            if (callJabberImpl.processColibriConferenceIQ(conferenceIQ))             break;
          }
        }
      }
    }
  }
}",0.996
103153,"/** 
 * {@inheritDoc}Implements   {@link RegistrationStateChangeListener}. Notifies this instance that there has been a change in the <tt>RegistrationState</tt> of   {@link #protocolProvider}. Subscribes this instance to  {@link net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ}s as soon as <tt>protocolProvider</tt> is registered and unsubscribes it as soon as <tt>protocolProvider</tt> is unregistered.
 */
public void registrationStateChanged(RegistrationStateChangeEvent ev){
  RegistrationState registrationState=ev.getNewState();
  if (RegistrationState.REGISTERED.equals(registrationState)) {
    protocolProvider.getConnection().addPacketListener(this,this);
  }
 else   if (RegistrationState.UNREGISTERED.equals(registrationState)) {
    XMPPConnection connection=protocolProvider.getConnection();
    if (connection != null)     connection.removePacketListener(this);
  }
}","/** 
 * {@inheritDoc}Implements   {@link RegistrationStateChangeListener}. Notifies this instance that there has been a change in the <tt>RegistrationState</tt> of   {@link #protocolProvider}. Subscribes this instance to  {@link ColibriConferenceIQ}s as soon as <tt>protocolProvider</tt> is registered and unsubscribes it as soon as <tt>protocolProvider</tt> is unregistered.
 */
public void registrationStateChanged(RegistrationStateChangeEvent ev){
  RegistrationState registrationState=ev.getNewState();
  if (RegistrationState.REGISTERED.equals(registrationState)) {
    protocolProvider.getConnection().addPacketListener(this,this);
  }
 else   if (RegistrationState.UNREGISTERED.equals(registrationState)) {
    XMPPConnection connection=protocolProvider.getConnection();
    if (connection != null)     connection.removePacketListener(this);
  }
}",0.9627959413754228
103154,"/** 
 * Implements   {@link PacketFilter}. Determines whether this instance is interested in a specific   {@link Packet}. <tt>OperationSetVideoBridgeImpl</tt> returns <tt>true</tt> if the specified <tt>packet</tt> is a   {@link net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ}; otherwise, <tt>false</tt>. 
 * @param packet the <tt>Packet</tt> to be determined whether this instanceis interested in it
 * @return <tt>true</tt> if the specified <tt>packet</tt> is a<tt>ColibriConferenceIQ</tt>; otherwise, <tt>false</tt>
 */
public boolean accept(Packet packet){
  return (packet instanceof ColibriConferenceIQ);
}","/** 
 * Implements   {@link PacketFilter}. Determines whether this instance is interested in a specific   {@link Packet}. <tt>OperationSetVideoBridgeImpl</tt> returns <tt>true</tt> if the specified <tt>packet</tt> is a   {@link ColibriConferenceIQ}; otherwise, <tt>false</tt>. 
 * @param packet the <tt>Packet</tt> to be determined whether this instanceis interested in it
 * @return <tt>true</tt> if the specified <tt>packet</tt> is a<tt>ColibriConferenceIQ</tt>; otherwise, <tt>false</tt>
 */
public boolean accept(Packet packet){
  return (packet instanceof ColibriConferenceIQ);
}",0.946515397082658
103155,"/** 
 * Gets the   {@link net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.Channel} which belongs to a contentassociated with a specific <tt>MediaType</tt> and is to be either locally or remotely used. <p> <b>Note</b>: Modifications to the <tt>ColibriConferenceIQ.Channel</tt> instance returned by the method propagate to (the state of) this instance. </p>
 * @param mediaType the <tt>MediaType</tt> associated with the content whichcontains the <tt>ColibriConferenceIQ.Channel</tt> to get
 * @param local <tt>true</tt> if the <tt>ColibriConferenceIQ.Channel</tt>which is to be used locally is to be returned or <tt>false</tt> for the one which is to be used remotely
 * @return the <tt>ColibriConferenceIQ.Channel</tt> which belongs to a contentassociated with the specified <tt>mediaType</tt> and which is to be used in accord with the specified <tt>local</tt> indicator if such a channel exists; otherwise, <tt>null</tt>
 */
ColibriConferenceIQ.Channel getColibriChannel(MediaType mediaType,boolean local){
  ColibriConferenceIQ.Channel channel=null;
  if (colibri != null) {
    ColibriConferenceIQ.Content content=colibri.getContent(mediaType.toString());
    if (content != null) {
      List<ColibriConferenceIQ.Channel> channels=content.getChannels();
      if (channels.size() == 2)       channel=channels.get(local ? 0 : 1);
    }
  }
  return channel;
}","/** 
 * Gets the   {@link ColibriConferenceIQ.Channel} which belongs to a contentassociated with a specific <tt>MediaType</tt> and is to be either locally or remotely used. <p> <b>Note</b>: Modifications to the <tt>ColibriConferenceIQ.Channel</tt> instance returned by the method propagate to (the state of) this instance. </p>
 * @param mediaType the <tt>MediaType</tt> associated with the content whichcontains the <tt>ColibriConferenceIQ.Channel</tt> to get
 * @param local <tt>true</tt> if the <tt>ColibriConferenceIQ.Channel</tt>which is to be used locally is to be returned or <tt>false</tt> for the one which is to be used remotely
 * @return the <tt>ColibriConferenceIQ.Channel</tt> which belongs to a contentassociated with the specified <tt>mediaType</tt> and which is to be used in accord with the specified <tt>local</tt> indicator if such a channel exists; otherwise, <tt>null</tt>
 */
ColibriConferenceIQ.Channel getColibriChannel(MediaType mediaType,boolean local){
  ColibriConferenceIQ.Channel channel=null;
  if (colibri != null) {
    ColibriConferenceIQ.Content content=colibri.getContent(mediaType.toString());
    if (content != null) {
      List<ColibriConferenceIQ.Channel> channels=content.getChannels();
      if (channels.size() == 2)       channel=channels.get(local ? 0 : 1);
    }
  }
  return channel;
}",0.975877192982456
103156,"/** 
 * Implements   {@link TransportManagerJabberImpl#getStreamTarget(MediaType)}. Gets the <tt>MediaStreamTarget</tt> to be used as the <tt>target</tt> of the <tt>MediaStream</tt> with a specific <tt>MediaType</tt>.
 * @param mediaType the <tt>MediaType</tt> of the <tt>MediaStream</tt> whichis to have its <tt>target</tt> set to the returned <tt>MediaStreamTarget</tt>
 * @return the <tt>MediaStreamTarget</tt> to be used as the <tt>target</tt>of the <tt>MediaStream</tt> with the specified <tt>MediaType</tt>
 * @see TransportManagerJabberImpl#getStreamTarget(MediaType)
 */
public MediaStreamTarget getStreamTarget(MediaType mediaType){
  MediaStreamTarget streamTarget=null;
  for (  Iterable<ContentPacketExtension> remote : remotes) {
    for (    ContentPacketExtension content : remote) {
      RtpDescriptionPacketExtension rtpDescription=content.getFirstChildOfType(RtpDescriptionPacketExtension.class);
      MediaType contentMediaType=MediaType.parseString(rtpDescription.getMedia());
      if (mediaType.equals(contentMediaType)) {
        ColibriConferenceIQ.Channel channel=getColibriChannel(mediaType,true);
        if (channel == null) {
          streamTarget=JingleUtils.extractDefaultTarget(content);
        }
 else {
          streamTarget=new MediaStreamTarget(new InetSocketAddress(channel.getHost(),channel.getRTPPort()),new InetSocketAddress(channel.getHost(),channel.getRTPPort()));
        }
        break;
      }
    }
  }
  return streamTarget;
}","/** 
 * Implements   {@link TransportManagerJabberImpl#getStreamTarget(MediaType)}. Gets the <tt>MediaStreamTarget</tt> to be used as the <tt>target</tt> of the <tt>MediaStream</tt> with a specific <tt>MediaType</tt>.
 * @param mediaType the <tt>MediaType</tt> of the <tt>MediaStream</tt> whichis to have its <tt>target</tt> set to the returned <tt>MediaStreamTarget</tt>
 * @return the <tt>MediaStreamTarget</tt> to be used as the <tt>target</tt>of the <tt>MediaStream</tt> with the specified <tt>MediaType</tt>
 * @see TransportManagerJabberImpl#getStreamTarget(MediaType)
 */
public MediaStreamTarget getStreamTarget(MediaType mediaType){
  MediaStreamTarget streamTarget=null;
  for (  Iterable<ContentPacketExtension> remote : remotes) {
    for (    ContentPacketExtension content : remote) {
      RtpDescriptionPacketExtension rtpDescription=content.getFirstChildOfType(RtpDescriptionPacketExtension.class);
      MediaType contentMediaType=MediaType.parseString(rtpDescription.getMedia());
      if (mediaType.equals(contentMediaType)) {
        ColibriConferenceIQ.Channel channel=getColibriChannel(mediaType,true);
        if (channel == null) {
          streamTarget=JingleUtils.extractDefaultTarget(content);
        }
 else {
          streamTarget=new MediaStreamTarget(new InetSocketAddress(channel.getHost(),channel.getRTPPort()),new InetSocketAddress(channel.getHost(),channel.getRTCPPort()));
        }
        break;
      }
    }
  }
  return streamTarget;
}",0.9996620479891856
103157,"/** 
 * Implements <code>setVisible</code> in the UIService interface. Shows or hides the main application window depending on the parameter <code>visible</code>.
 * @param isVisible true if we are to show the main application frame andfalse otherwise.
 * @see UIService#setVisible(boolean)
 */
public void setFrameVisible(final boolean isVisible){
  ConfigurationUtils.setApplicationVisible(isVisible);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      if (isVisible) {
        MainFrame.this.addNativePlugins();
        Window focusedWindow=keyManager.getFocusedWindow();
        if (focusedWindow != null)         setFocusableWindowState(false);
        MainFrame.super.setVisible(isVisible);
        if (focusedWindow != null)         setFocusableWindowState(true);
        MainFrame.super.setExtendedState(MainFrame.NORMAL);
        MainFrame.super.toFront();
      }
 else {
        MainFrame.super.setVisible(isVisible);
      }
    }
  }
);
}","/** 
 * Implements <code>setVisible</code> in the UIService interface. Shows or hides the main application window depending on the parameter <code>visible</code>.
 * @param isVisible true if we are to show the main application frame andfalse otherwise.
 * @see UIService#setVisible(boolean)
 */
public void setFrameVisible(final boolean isVisible){
  if (this.isVisible() != isVisible) {
    ConfigurationUtils.setApplicationVisible(isVisible);
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (isVisible) {
          MainFrame.this.addNativePlugins();
          Window focusedWindow=keyManager.getFocusedWindow();
          if (focusedWindow != null)           setFocusableWindowState(false);
          MainFrame.super.setVisible(isVisible);
          if (focusedWindow != null)           setFocusableWindowState(true);
          MainFrame.super.setExtendedState(MainFrame.NORMAL);
          MainFrame.super.toFront();
        }
 else {
          MainFrame.super.setVisible(isVisible);
        }
      }
    }
);
  }
}",0.9610261470152937
103158,"/** 
 * Adds remote video specific components.
 * @param callPeer the <tt>CallPeer</tt>
 */
public void addRemoteVideoSpecificComponents(CallPeer callPeer){
  if (CallManager.isVideoQualityPresetSupported(callPeer)) {
    if (resizeVideoButton == null) {
      resizeVideoButton=new ResizeVideoButton(callPeer.getCall());
      resizeVideoButton.setIndex(9);
    }
    if (resizeVideoButton.countAvailableOptions() > 1)     settingsPanel.add(resizeVideoButton);
  }
  settingsPanel.revalidate();
  settingsPanel.repaint();
}","/** 
 * Adds remote video specific components.
 * @param callPeer the <tt>CallPeer</tt>
 */
public void addRemoteVideoSpecificComponents(CallPeer callPeer){
  if (CallManager.isVideoQualityPresetSupported(callPeer)) {
    if (resizeVideoButton == null) {
      resizeVideoButton=new ResizeVideoButton(callPeer.getCall());
      resizeVideoButton.setIndex(9);
    }
    if (resizeVideoButton.countAvailableOptions() > 1) {
      settingsPanel.add(resizeVideoButton);
      settingsPanel.revalidate();
      settingsPanel.repaint();
    }
  }
}",0.8799249530956847
103159,"/** 
 * Updates account information when a protocol provider is registered.
 * @param evt the <tt>RegistrationStateChangeEvent</tt> that notified usof the change
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    OperationSetServerStoredAccountInfo accountInfoOpSet=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (accountInfoOpSet != null) {
      new UpdateAccountInfo(protocolProvider,accountInfoOpSet).start();
    }
    OperationSetAvatar avatarOpSet=protocolProvider.getOperationSet(OperationSetAvatar.class);
    if (avatarOpSet != null)     avatarOpSet.addAvatarListener(this);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (serverStoredAccountInfo != null)     serverStoredAccountInfo.addServerStoredDetailsChangeListener(this);
  }
 else   if (evt.getNewState().equals(RegistrationState.UNREGISTERING) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    OperationSetAvatar avatarOpSet=protocolProvider.getOperationSet(OperationSetAvatar.class);
    if (avatarOpSet != null)     avatarOpSet.removeAvatarListener(this);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (serverStoredAccountInfo != null)     serverStoredAccountInfo.removeServerStoredDetailsChangeListener(this);
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERING)) {
    startConnecting(protocolProvider);
  }
}","/** 
 * Updates account information when a protocol provider is registered.
 * @param evt the <tt>RegistrationStateChangeEvent</tt> that notified usof the change
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  if (!evt.getNewState().equals(RegistrationState.REGISTERING))   this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    OperationSetServerStoredAccountInfo accountInfoOpSet=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (accountInfoOpSet != null) {
      new UpdateAccountInfo(protocolProvider,accountInfoOpSet).start();
    }
    OperationSetAvatar avatarOpSet=protocolProvider.getOperationSet(OperationSetAvatar.class);
    if (avatarOpSet != null)     avatarOpSet.addAvatarListener(this);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (serverStoredAccountInfo != null)     serverStoredAccountInfo.addServerStoredDetailsChangeListener(this);
  }
 else   if (evt.getNewState().equals(RegistrationState.UNREGISTERING) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    OperationSetAvatar avatarOpSet=protocolProvider.getOperationSet(OperationSetAvatar.class);
    if (avatarOpSet != null)     avatarOpSet.removeAvatarListener(this);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (serverStoredAccountInfo != null)     serverStoredAccountInfo.removeServerStoredDetailsChangeListener(this);
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERING)) {
    startConnecting(protocolProvider);
  }
}",0.9821029082774048
103160,"/** 
 * Implements ShutdownService#beginShutdown(). Disposes of the mainFrame (if it exists) and then instructs Felix to start shutting down the bundles so that the application can gracefully quit.
 */
public void beginShutdown(){
  try {
    if (mainFrame != null)     mainFrame.dispose();
  }
  finally {
    try {
      GuiActivator.bundleContext.getBundle(0).stop();
    }
 catch (    BundleException ex) {
      logger.error(""String_Node_Str"",ex);
      System.exit(0);
    }
  }
}","/** 
 * Implements ShutdownService#beginShutdown(). Disposes of the mainFrame (if it exists) and then instructs Felix to start shutting down the bundles so that the application can gracefully quit.
 */
public void beginShutdown(){
  try {
    if (mainFrame != null)     mainFrame.dispose();
  }
  finally {
    System.exit(0);
  }
}",0.7946210268948656
103161,"/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  Thread shutdownTimeoutThread=new Thread(){
    public void run(){
synchronized (this) {
        try {
          long shutDownTimeout=SHUTDOWN_TIMEOUT_DEFAULT;
          try {
            String shutdownCustomValue=System.getProperty(SHUTDOWN_TIMEOUT_PROP);
            if (shutdownCustomValue != null && shutdownCustomValue.length() > 0) {
              long custom=Long.valueOf(shutdownCustomValue);
              if (custom > 0)               shutDownTimeout=custom;
            }
          }
 catch (          Throwable t) {
          }
          if (logger.isTraceEnabled())           logger.trace(""String_Node_Str"" + shutDownTimeout + ""String_Node_Str"");
          wait(shutDownTimeout);
          logger.error(""String_Node_Str"");
          System.exit(SYSTEM_EXIT_CODE);
        }
 catch (        InterruptedException ex) {
          if (logger.isDebugEnabled())           logger.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  shutdownTimeoutThread.setDaemon(true);
  shutdownTimeoutThread.start();
}","/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  Thread shutdownTimeoutThread=new Thread(){
    public void run(){
synchronized (this) {
        try {
          long shutDownTimeout=SHUTDOWN_TIMEOUT_DEFAULT;
          try {
            String shutdownCustomValue=System.getProperty(SHUTDOWN_TIMEOUT_PROP);
            if (shutdownCustomValue != null && shutdownCustomValue.length() > 0) {
              long custom=Long.valueOf(shutdownCustomValue);
              if (custom > 0)               shutDownTimeout=custom;
            }
          }
 catch (          Throwable t) {
          }
          if (logger.isTraceEnabled())           logger.trace(""String_Node_Str"" + shutDownTimeout + ""String_Node_Str"");
          wait(shutDownTimeout);
          logger.error(""String_Node_Str"");
          Runtime.getRuntime().halt(SYSTEM_EXIT_CODE);
        }
 catch (        InterruptedException ex) {
          if (logger.isDebugEnabled())           logger.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  shutdownTimeoutThread.setDaemon(true);
  shutdownTimeoutThread.start();
}",0.99000624609619
103162,"public void run(){
synchronized (this) {
    try {
      long shutDownTimeout=SHUTDOWN_TIMEOUT_DEFAULT;
      try {
        String shutdownCustomValue=System.getProperty(SHUTDOWN_TIMEOUT_PROP);
        if (shutdownCustomValue != null && shutdownCustomValue.length() > 0) {
          long custom=Long.valueOf(shutdownCustomValue);
          if (custom > 0)           shutDownTimeout=custom;
        }
      }
 catch (      Throwable t) {
      }
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + shutDownTimeout + ""String_Node_Str"");
      wait(shutDownTimeout);
      logger.error(""String_Node_Str"");
      System.exit(SYSTEM_EXIT_CODE);
    }
 catch (    InterruptedException ex) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
    }
  }
}","public void run(){
synchronized (this) {
    try {
      long shutDownTimeout=SHUTDOWN_TIMEOUT_DEFAULT;
      try {
        String shutdownCustomValue=System.getProperty(SHUTDOWN_TIMEOUT_PROP);
        if (shutdownCustomValue != null && shutdownCustomValue.length() > 0) {
          long custom=Long.valueOf(shutdownCustomValue);
          if (custom > 0)           shutDownTimeout=custom;
        }
      }
 catch (      Throwable t) {
      }
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + shutDownTimeout + ""String_Node_Str"");
      wait(shutDownTimeout);
      logger.error(""String_Node_Str"");
      Runtime.getRuntime().halt(SYSTEM_EXIT_CODE);
    }
 catch (    InterruptedException ex) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
    }
  }
}",0.9787234042553192
103163,"/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>.
 */
private void updateViewFromModel(){
  if (SwingUtilities.isEventDispatchThread())   updateViewFromModelInEventDispatchThread();
 else {
    SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);
  }
}","/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>.
 */
private void updateViewFromModel(){
  if (!disposed) {
    if (SwingUtilities.isEventDispatchThread())     updateViewFromModelInEventDispatchThread();
 else {
      SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);
    }
  }
}",0.9574759945130316
103164,"/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallConference</tt>, the participating <tt>Call</tt>s, and their associated <tt>CallPeer</tt>s). Invoked by <tt>CallManager</tt> when it determines that this <tt>CallPanel</tt> is no longer necessary.
 */
void dispose(){
  callConference.removeCallChangeListener(callConferenceListener);
  callConference.removeCallPeerConferenceListener(callConferenceListener);
  callConference.removePropertyChangeListener(callConferenceListener);
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
  uiVideoHandler.dispose();
  if (callPanel != null)   ((CallRenderer)callPanel).dispose();
}","/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallConference</tt>, the participating <tt>Call</tt>s, and their associated <tt>CallPeer</tt>s). Invoked by <tt>CallManager</tt> when it determines that this <tt>CallPanel</tt> is no longer necessary.
 */
void dispose(){
  disposed=true;
  callConference.removeCallChangeListener(callConferenceListener);
  callConference.removeCallPeerConferenceListener(callConferenceListener);
  callConference.removePropertyChangeListener(callConferenceListener);
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
  uiVideoHandler.dispose();
  if (callPanel != null)   ((CallRenderer)callPanel).dispose();
}",0.9883161512027492
103165,"/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>. The update is performed in the AWT event dispatching thread.
 */
private void updateViewFromModelInEventDispatchThread(){
  Dimension oldPreferredSize=getPreferredSize();
  doUpdateViewFromModelInEventDispatchThread();
  Dimension newPreferredSize=getPreferredSize();
  if ((newPreferredSize != null) && ((newPreferredSize.height > getHeight()) || (newPreferredSize.width > getWidth()))) {
    int oldPreferredHeight, oldPreferredWidth;
    if (oldPreferredSize == null) {
      oldPreferredHeight=0;
      oldPreferredWidth=0;
    }
 else {
      oldPreferredHeight=oldPreferredSize.height;
      oldPreferredWidth=oldPreferredSize.width;
    }
    if ((newPreferredSize.height != oldPreferredHeight) || (newPreferredSize.width != oldPreferredWidth)) {
      ensureSize(this,newPreferredSize.width,newPreferredSize.height);
    }
  }
}","/** 
 * Updates this view i.e. <tt>CallPanel</tt> so that it depicts the current state of its model i.e. <tt>callConference</tt>. The update is performed in the AWT event dispatching thread.
 */
private void updateViewFromModelInEventDispatchThread(){
  if (disposed)   return;
  Dimension oldPreferredSize=getPreferredSize();
  doUpdateViewFromModelInEventDispatchThread();
  Dimension newPreferredSize=getPreferredSize();
  if ((newPreferredSize != null) && ((newPreferredSize.height > getHeight()) || (newPreferredSize.width > getWidth()))) {
    int oldPreferredHeight, oldPreferredWidth;
    if (oldPreferredSize == null) {
      oldPreferredHeight=0;
      oldPreferredWidth=0;
    }
 else {
      oldPreferredHeight=oldPreferredSize.height;
      oldPreferredWidth=oldPreferredSize.width;
    }
    if ((newPreferredSize.height != oldPreferredHeight) || (newPreferredSize.width != oldPreferredWidth)) {
      ensureSize(this,newPreferredSize.width,newPreferredSize.height);
    }
  }
}",0.9867211440245148
103166,"/** 
 * Updates this view i.e. <tt>OneToOneCallPeerPanel</tt> so that it depicts the current state of its model i.e. <tt>callPeer</tt>. The update is performed in the AWT event dispatching thread.
 */
private void updateViewFromModelInEventDispatchThread(){
  OperationSetVideoTelephony videoTelephony=callPeer.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);
  Component remoteVideo=null;
  Component localVideo=null;
  if (videoTelephony != null) {
    List<Component> remoteVideos=videoTelephony.getVisualComponents(callPeer);
    if ((remoteVideos != null) && !remoteVideos.isEmpty()) {
      remoteVideo=remoteVideos.get(0);
    }
    if (uiVideoHandler.isLocalVideoVisible()) {
      try {
        localVideo=videoTelephony.getLocalVisualComponent(callPeer);
      }
 catch (      OperationFailedException ofe) {
      }
    }
    boolean localVideoChanged=((localVideo != this.localVideo) || ((localVideo != null) && !UIVideoHandler2.isAncestor(center,localVideo)));
    boolean remoteVideoChanged=((remoteVideo != this.remoteVideo) || ((remoteVideo != null) && !UIVideoHandler2.isAncestor(center,remoteVideo)));
    if (localVideoChanged || remoteVideoChanged) {
      if (localVideoChanged && !remoteVideoChanged && (localVideo == null)) {
        if (this.localVideo != null) {
          center.remove(this.localVideo);
          this.localVideo=null;
          if (closeLocalVisualComponentButton != null)           center.remove(closeLocalVisualComponentButton);
        }
      }
 else {
        center.removeAll();
        if (remoteVideo != null)         center.add(remoteVideo,VideoLayout.CENTER_REMOTE,-1);
        this.remoteVideo=remoteVideo;
        if (localVideo != null) {
          center.add(localVideo,VideoLayout.LOCAL,-1);
          if (closeLocalVisualComponentButton == null) {
            closeLocalVisualComponentButton=new CloseLocalVisualComponentButton(uiVideoHandler);
          }
          center.add(closeLocalVisualComponentButton,VideoLayout.CLOSE_LOCAL_BUTTON,-1);
        }
        this.localVideo=localVideo;
      }
    }
  }
}","/** 
 * Updates this view i.e. <tt>OneToOneCallPeerPanel</tt> so that it depicts the current state of its model i.e. <tt>callPeer</tt>. The update is performed in the AWT event dispatching thread.
 */
private void updateViewFromModelInEventDispatchThread(){
  if (disposed)   return;
  OperationSetVideoTelephony videoTelephony=callPeer.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);
  Component remoteVideo=null;
  Component localVideo=null;
  if (videoTelephony != null) {
    List<Component> remoteVideos=videoTelephony.getVisualComponents(callPeer);
    if ((remoteVideos != null) && !remoteVideos.isEmpty()) {
      remoteVideo=remoteVideos.get(0);
    }
    if (uiVideoHandler.isLocalVideoVisible()) {
      try {
        localVideo=videoTelephony.getLocalVisualComponent(callPeer);
      }
 catch (      OperationFailedException ofe) {
        logger.warn(""String_Node_Str"",ofe);
      }
    }
    boolean localVideoChanged=((localVideo != this.localVideo) || ((localVideo != null) && !UIVideoHandler2.isAncestor(center,localVideo)));
    boolean remoteVideoChanged=((remoteVideo != this.remoteVideo) || ((remoteVideo != null) && !UIVideoHandler2.isAncestor(center,remoteVideo)));
    if (localVideoChanged || remoteVideoChanged) {
      if (localVideoChanged && !remoteVideoChanged && (localVideo == null)) {
        if (this.localVideo != null) {
          center.remove(this.localVideo);
          this.localVideo=null;
          if (closeLocalVisualComponentButton != null)           center.remove(closeLocalVisualComponentButton);
        }
      }
 else {
        center.removeAll();
        this.localVideo=null;
        this.remoteVideo=null;
        if (remoteVideo != null) {
          center.add(remoteVideo,VideoLayout.CENTER_REMOTE,-1);
          this.remoteVideo=remoteVideo;
        }
        if (localVideo != null) {
          center.add(localVideo,VideoLayout.LOCAL,-1);
          this.localVideo=localVideo;
          if (closeLocalVisualComponentButton == null) {
            closeLocalVisualComponentButton=new CloseLocalVisualComponentButton(uiVideoHandler);
          }
          center.add(closeLocalVisualComponentButton,VideoLayout.CLOSE_LOCAL_BUTTON,-1);
        }
      }
    }
  }
}",0.9490666052085734
103167,"/** 
 * Updates this view i.e. <tt>OneToOneCallPeerPanel</tt> so that it depicts the current state of its model i.e. <tt>callPeer</tt>.
 */
private void updateViewFromModel(){
  if (SwingUtilities.isEventDispatchThread())   updateViewFromModelInEventDispatchThread();
 else {
    SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);
  }
}","/** 
 * Updates this view i.e. <tt>OneToOneCallPeerPanel</tt> so that it depicts the current state of its model i.e. <tt>callPeer</tt>.
 */
private void updateViewFromModel(){
  if (!disposed) {
    if (SwingUtilities.isEventDispatchThread())     updateViewFromModelInEventDispatchThread();
 else {
      SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);
    }
  }
}",0.9581646423751689
103168,"/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallPeer</tt>. Invoked by <tt>OneToOneCallPanel</tt> when it determines that this <tt>OneToOneCallPeerPanel</tt> is no longer necessary. 
 */
public void dispose(){
  callPeerAdapter.dispose();
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
}","/** 
 * Releases the resources acquired by this instance which require explicit disposal (e.g. any listeners added to the depicted <tt>CallPeer</tt>. Invoked by <tt>OneToOneCallPanel</tt> when it determines that this <tt>OneToOneCallPeerPanel</tt> is no longer necessary. 
 */
public void dispose(){
  disposed=true;
  callPeerAdapter.dispose();
  uiVideoHandler.deleteObserver(uiVideoHandlerObserver);
}",0.9785082174462706
103169,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  MediaDevice mediaDevice=(MediaDevice)value;
  Dimension screenSize=null;
  if (mediaDevice != null)   screenSize=((VideoMediaFormat)mediaDevice.getFormat()).getSize();
  this.setText(screenSize.width + ""String_Node_Str"" + screenSize.height);
  return this;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  MediaDevice mediaDevice=(MediaDevice)value;
  Dimension screenSize=null;
  if (mediaDevice != null)   screenSize=((VideoMediaFormat)mediaDevice.getFormat()).getSize();
  this.setText(screenSize.width + ""String_Node_Str"" + screenSize.height);
  return this;
}",0.9892933618843684
103170,"/** 
 * Creates the ZRTP sas panel.
 * @return the created ZRTP SAS panel
 */
private JPanel createSasPanel(){
  sasVerified=getSecurityControl().isSecurityVerified();
  TransparentPanel sasPanel=new TransparentPanel(){
    public void paintComponent(    Graphics g){
      g=g.create();
      try {
        AntialiasingManager.activateAntialiasing(g);
        g.setColor(new Color(1f,1f,1f,0.1f));
        g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
        g.setColor(Color.WHITE);
        g.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,10,10);
      }
  finally {
        g.dispose();
      }
    }
  }
;
  sasPanel.setLayout(new BoxLayout(sasPanel,BoxLayout.Y_AXIS));
  initSasLabels();
  SIPCommButton infoButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.CALL_INFO));
  infoButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  compareLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
  JPanel stringPanel=new TransparentPanel(new FlowLayout(FlowLayout.CENTER,5,0));
  stringPanel.add(compareLabel);
  stringPanel.add(infoButton);
  initZidNameButton();
  stringPanel.add(zidNameButton);
  sasPanel.add(stringPanel);
  securityStringLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
  sasPanel.add(securityStringLabel);
  confirmButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (getSecurityControl() != null) {
        getSecurityControl().setSASVerification(!sasVerified);
        sasVerified=!sasVerified;
        securityStringLabel.setIcon(sasVerified ? encryptionVerifiedIcon : null);
        if (sasVerified)         peerRenderer.securityOn(null);
 else         peerRenderer.securityPending();
        initSasLabels();
      }
    }
  }
);
  confirmButton.setAlignmentX(Component.CENTER_ALIGNMENT);
  sasPanel.add(confirmButton);
  return sasPanel;
}","/** 
 * Creates the ZRTP sas panel.
 * @return the created ZRTP SAS panel
 */
private JPanel createSasPanel(){
  sasVerified=getSecurityControl().isSecurityVerified();
  TransparentPanel sasPanel=new TransparentPanel(){
    @Override public void paintComponent(    Graphics g){
      g=g.create();
      try {
        AntialiasingManager.activateAntialiasing(g);
        g.setColor(new Color(1f,1f,1f,0.1f));
        g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
        g.setColor(Color.WHITE);
        g.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,10,10);
      }
  finally {
        g.dispose();
      }
    }
  }
;
  sasPanel.setLayout(new BoxLayout(sasPanel,BoxLayout.Y_AXIS));
  initSasLabels();
  SIPCommButton infoButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.CALL_INFO));
  infoButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  compareLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
  JPanel stringPanel=new TransparentPanel(new FlowLayout(FlowLayout.CENTER,5,0));
  stringPanel.add(compareLabel);
  stringPanel.add(infoButton);
  initZidNameButton();
  stringPanel.add(zidNameButton);
  sasPanel.add(stringPanel);
  securityStringLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
  sasPanel.add(securityStringLabel);
  confirmButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (getSecurityControl() != null) {
        getSecurityControl().setSASVerification(!sasVerified);
        sasVerified=!sasVerified;
        securityStringLabel.setIcon(sasVerified ? encryptionVerifiedIcon : null);
        if (sasVerified)         peerRenderer.securityOn(null);
 else         peerRenderer.securityPending();
        initSasLabels();
      }
    }
  }
);
  confirmButton.setAlignmentX(Component.CENTER_ALIGNMENT);
  sasPanel.add(confirmButton);
  return sasPanel;
}",0.9973628691983122
103171,"public void paintComponent(Graphics g){
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    g.setColor(new Color(1f,1f,1f,0.1f));
    g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
    g.setColor(Color.WHITE);
    g.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,10,10);
  }
  finally {
    g.dispose();
  }
}","@Override public void paintComponent(Graphics g){
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    g.setColor(new Color(1f,1f,1f,0.1f));
    g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
    g.setColor(Color.WHITE);
    g.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,10,10);
  }
  finally {
    g.dispose();
  }
}",0.9863013698630136
103172,"public void securityTimeout(CallPeerSecurityTimeoutEvent evt){
}","public void securityTimeout(CallPeerSecurityTimeoutEvent ev){
}",0.9921259842519684
103173,"/** 
 * Plays this audio.
 */
public void play(){
  started=true;
  new Thread(){
    @Override public void run(){
      runInPlayThread();
    }
  }
.start();
}","/** 
 * Plays this audio.
 */
public void play(){
  started=true;
  new Thread(""String_Node_Str"" + this.getClass()){
    @Override public void run(){
      runInPlayThread();
    }
  }
.start();
}",0.9019607843137256
103174,"/** 
 * Returns a hashCode for this contact. The returned hashcode is actually that of the Contact's Address
 * @return the hashcode of this Contact
 */
@Override public int hashCode(){
  return getAddress().hashCode();
}","/** 
 * Returns a hashCode for this contact. The returned hashcode is actually that of the Contact's Address
 * @return the hashcode of this Contact
 */
@Override public int hashCode(){
  return getAddress().toLowerCase().hashCode();
}",0.9692982456140352
103175,"/** 
 * Schedules an update if necessary.
 */
private void updateContactListView(){
  String filterString=getText();
  FilterQuery filterQuery=null;
  boolean isDefaultFilter=false;
  searchFilter.setFilterString(filterString.trim());
  if (filterString != null && filterString.length() > 0) {
    filterQuery=contactList.applyFilter(searchFilter);
  }
 else {
    filterQuery=contactList.applyDefaultFilter();
    isDefaultFilter=true;
  }
  if (filterQuery != null && !filterQuery.isCanceled()) {
    if (isDefaultFilter || filterQuery.isSucceeded())     enableUnknownContactView(false);
 else     filterQuery.setQueryListener(this);
  }
 else {
    closeFilterQuery(filterQuery,!contactList.isEmpty());
  }
}","/** 
 * Schedules an update if necessary.
 */
private void updateContactListView(){
  String filterString=getText();
  boolean isDefaultFilter=false;
  searchFilter.setFilterString(filterString.trim());
  if (currentFilterQuery != null)   filterQueryFinished(currentFilterQuery,true);
  if (filterString != null && filterString.length() > 0) {
    currentFilterQuery=contactList.applyFilter(searchFilter);
  }
 else {
    currentFilterQuery=contactList.applyDefaultFilter();
    isDefaultFilter=true;
  }
  if (currentFilterQuery != null && !currentFilterQuery.isCanceled()) {
    if (isDefaultFilter || currentFilterQuery.isSucceeded())     enableUnknownContactView(false);
 else     currentFilterQuery.setQueryListener(this);
  }
 else {
    filterQueryFinished(currentFilterQuery,!contactList.isEmpty());
  }
}",0.8438320209973753
103176,"/** 
 * Indicates that the given <tt>query</tt> has finished with failure, i.e. no results for the filter were found.
 * @param query the <tt>FilterQuery</tt>, where this listener is registered
 */
public void filterQueryFailed(FilterQuery query){
  closeFilterQuery(query,!contactList.isEmpty());
}","/** 
 * Indicates that the given <tt>query</tt> has finished with failure, i.e. no results for the filter were found.
 * @param query the <tt>FilterQuery</tt>, where this listener is registered
 */
public void filterQueryFailed(FilterQuery query){
  if (currentFilterQuery.equals(query))   filterQueryFinished(query,false);
}",0.8397435897435898
103177,"/** 
 * Indicates that the given <tt>query</tt> has finished with success, i.e. the filter has returned results.
 * @param query the <tt>FilterQuery</tt>, where this listener is registered
 */
public void filterQuerySucceeded(FilterQuery query){
  closeFilterQuery(query,!contactList.isEmpty());
}","/** 
 * Indicates that the given <tt>query</tt> has finished with success, i.e. the filter has returned results.
 * @param query the <tt>FilterQuery</tt>, where this listener is registered
 */
public void filterQuerySucceeded(FilterQuery query){
  if (currentFilterQuery.equals(query))   filterQueryFinished(query,true);
}",0.8723747980613893
103178,"public void serviceChanged(ServiceEvent event){
  ServiceReference serviceRef=event.getServiceReference();
  if (serviceRef.getBundle().getState() == Bundle.STOPPING)   return;
  Object service=GuiActivator.bundleContext.getService(serviceRef);
  if (!(service instanceof ContactSourceService))   return;
  boolean changed=false;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    ExternalContactSource contactSource=new ExternalContactSource((ContactSourceService)service,TreeContactList.this);
  contactSources.add(contactSource);
changed=true;
break;
case ServiceEvent.UNREGISTERING:
UIContactSource cSource=getContactSource((ContactSourceService)service);
if (cSource != null) contactSources.remove(cSource);
changed=true;
break;
}
if (changed) {
if (currentFilter.equals(defaultFilter)) applyDefaultFilter();
 else applyFilter(currentFilter);
}
}","public void serviceChanged(ServiceEvent event){
  ServiceReference serviceRef=event.getServiceReference();
  if (serviceRef.getBundle().getState() == Bundle.STOPPING)   return;
  Object service=GuiActivator.bundleContext.getService(serviceRef);
  if (!(service instanceof ContactSourceService))   return;
  boolean changed=false;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    ExternalContactSource contactSource=new ExternalContactSource((ContactSourceService)service,TreeContactList.this);
  contactSources.add(contactSource);
changed=true;
break;
case ServiceEvent.UNREGISTERING:
UIContactSource cSource=getContactSource((ContactSourceService)service);
if (cSource != null) contactSources.remove(cSource);
changed=true;
break;
}
if (changed && !currentFilter.equals(presenceFilter)) {
if (currentFilter.equals(defaultFilter)) applyDefaultFilter();
 else applyFilter(currentFilter);
}
}",0.9767441860465116
103179,"public void metaGroupReceived(MetaGroupQueryEvent event){
}","public void metaGroupReceived(MetaGroupQueryEvent event){
  if (!isSucceeded() && event.getQuerySource().getResultCount() > 0)   setSucceeded(true);
  fireFilterQueryEvent();
}",0.502127659574468
103180,"/** 
 * Indicates that a contact has been received as a result of a query.
 * @param event the <tt>ContactReceivedEvent</tt> that notified us
 */
public void contactReceived(ContactReceivedEvent event){
  contactReceived(event.getQuerySource(),event.getContact());
}","/** 
 * Indicates that a contact has been received as a result of a query.
 * @param event the <tt>ContactReceivedEvent</tt> that notified us
 */
public void contactReceived(ContactReceivedEvent event){
  ContactQuery query=event.getQuerySource();
  SourceContact contact=event.getContact();
  if (!isSucceeded() && !query.getQueryResults().isEmpty())   setSucceeded(true);
  fireFilterQueryEvent();
  List<SourceContact> queryResults=filterQueries.get(query);
  queryResults.add(contact);
  if (getMaxResultShown() > -1 && queryResults.size() == getMaxResultShown()) {
    query.removeContactQueryListener(contactList);
    ShowMoreContact moreInfoContact=new ShowMoreContact(query,queryResults,getMaxResultShown());
    showMoreContactMap.put(query,moreInfoContact);
    ContactSourceService contactSource=query.getContactSource();
    contactList.addContact(query,moreInfoContact,contactList.getContactSource(contactSource).getUIGroup(),false);
  }
}",0.3806398687448728
103181,"public void metaContactReceived(MetaContactQueryEvent event){
}","public void metaContactReceived(MetaContactQueryEvent event){
  if (!isSucceeded() && event.getQuerySource().getResultCount() > 0)   setSucceeded(true);
  fireFilterQueryEvent();
}",0.5185185185185185
103182,"protected void layoutLabel(int tabPlacement,FontMetrics metrics,int tabIndex,String title,Icon icon,Rectangle tabRect,Rectangle iconRect,Rectangle textRect,boolean isSelected){
  textRect.x=textRect.y=iconRect.x=iconRect.y=0;
  View v=getTextViewForTab(tabIndex);
  if (v != null) {
    tabPane.putClientProperty(""String_Node_Str"",v);
  }
  SwingUtilities.layoutCompoundLabel((JComponent)tabPane,metrics,title,icon,SwingUtilities.CENTER,SwingUtilities.LEFT,SwingUtilities.CENTER,SwingUtilities.CENTER,tabRect,iconRect,textRect,0);
  tabPane.putClientProperty(""String_Node_Str"",null);
  iconRect.y=iconRect.y + 2;
  iconRect.x=tabRect.x + 7;
  textRect.y=textRect.y + 2;
  textRect.x=iconRect.x + iconRect.width + 5;
}","protected void layoutLabel(int tabPlacement,FontMetrics metrics,int tabIndex,String title,Icon icon,Rectangle tabRect,Rectangle iconRect,Rectangle textRect,boolean isSelected){
  textRect.x=textRect.y=iconRect.x=iconRect.y=0;
  View v=getTextViewForTab(tabIndex);
  if (v != null) {
    tabPane.putClientProperty(""String_Node_Str"",v);
  }
  SwingUtilities.layoutCompoundLabel((JComponent)tabPane,metrics,title,icon,SwingUtilities.CENTER,SwingUtilities.LEFT,SwingUtilities.CENTER,SwingUtilities.CENTER,tabRect,iconRect,textRect,0);
  tabPane.putClientProperty(""String_Node_Str"",null);
  if (icon != null) {
    iconRect.y=iconRect.y + 2;
    iconRect.x=tabRect.x + 7;
  }
  textRect.y=textRect.y + 2;
  if (icon != null)   textRect.x=iconRect.x + iconRect.width + 5;
 else   textRect.x=textRect.x + 8;
}",0.9440421329822252
103183,"protected Rectangle newCloseRect(Rectangle rect){
  int dx=rect.x + rect.width;
  int dy=(rect.y + rect.height) / 2 - 6;
  return new Rectangle(dx - BUTTONSIZE - WIDTHDELTA,dy,BUTTONSIZE,BUTTONSIZE);
}","protected Rectangle newCloseRect(Rectangle rect){
  int dx=rect.x + rect.width - BUTTONSIZE - WIDTHDELTA;
  int dy=rect.y + (rect.height - BUTTONSIZE) / 2 + 2;
  return new Rectangle(dx,dy,BUTTONSIZE,BUTTONSIZE);
}",0.7469879518072289
103184,"protected void paintTab(Graphics g,int tabPlacement,Rectangle[] rects,int tabIndex,Rectangle iconRect,Rectangle textRect){
  Rectangle tabRect=rects[tabIndex];
  int selectedIndex=tabPane.getSelectedIndex();
  boolean isSelected=selectedIndex == tabIndex;
  boolean isOver=overTabIndex == tabIndex;
  Graphics2D g2=null;
  Shape save=null;
  boolean cropShape=false;
  int cropx=0;
  int cropy=0;
  if (g instanceof Graphics2D) {
    g2=(Graphics2D)g;
    Rectangle viewRect=tabScroller.viewport.getViewRect();
    int cropline;
    cropline=viewRect.x + viewRect.width;
    if ((tabRect.x < cropline) && (tabRect.x + tabRect.width > cropline)) {
      cropx=cropline - 1;
      cropy=tabRect.y;
      cropShape=true;
    }
    if (cropShape) {
      save=g2.getClip();
      g2.clipRect(tabRect.x,tabRect.y,tabRect.width,tabRect.height);
    }
  }
  paintTabBackground(g,tabPlacement,tabIndex,tabRect.x,tabRect.y,tabRect.width,tabRect.height,isSelected);
  paintTabBorder(g,tabPlacement,tabIndex,tabRect.x,tabRect.y,tabRect.width,tabRect.height,isSelected);
  String title=tabPane.getTitleAt(tabIndex);
  Font font=tabPane.getFont();
  FontMetrics metrics=g.getFontMetrics(font);
  Icon icon=getIconForTab(tabIndex);
  layoutLabel(tabPlacement,metrics,tabIndex,title,icon,tabRect,iconRect,textRect,isSelected);
  paintText(g,tabPlacement,font,metrics,tabIndex,title,textRect,isSelected);
  paintIcon(g,tabPlacement,tabIndex,icon,iconRect,isSelected);
  paintFocusIndicator(g,tabPlacement,rects,tabIndex,iconRect,textRect,isSelected);
  if (cropShape) {
    paintCroppedTabEdge(g,tabPlacement,tabIndex,isSelected,cropx,cropy);
    g2.setClip(save);
  }
 else   if (isOver || isSelected) {
    int dx=tabRect.x + tabRect.width - BUTTONSIZE - WIDTHDELTA;
    int dy=(tabRect.y + tabRect.height) / 2 - 3;
    if (isCloseButtonEnabled)     paintCloseIcon(g2,dx,dy,isOver);
    if (isMaxButtonEnabled)     paintMaxIcon(g2,dx,dy,isOver);
  }
}","protected void paintTab(Graphics g,int tabPlacement,Rectangle[] rects,int tabIndex,Rectangle iconRect,Rectangle textRect){
  Rectangle tabRect=rects[tabIndex];
  int selectedIndex=tabPane.getSelectedIndex();
  boolean isSelected=selectedIndex == tabIndex;
  boolean isOver=overTabIndex == tabIndex;
  Graphics2D g2=null;
  Shape save=null;
  boolean cropShape=false;
  int cropx=0;
  int cropy=0;
  if (g instanceof Graphics2D) {
    g2=(Graphics2D)g;
    Rectangle viewRect=tabScroller.viewport.getViewRect();
    int cropline;
    cropline=viewRect.x + viewRect.width;
    if ((tabRect.x < cropline) && (tabRect.x + tabRect.width > cropline)) {
      cropx=cropline - 1;
      cropy=tabRect.y;
      cropShape=true;
    }
    if (cropShape) {
      save=g2.getClip();
      g2.clipRect(tabRect.x,tabRect.y,tabRect.width,tabRect.height);
    }
  }
  paintTabBackground(g,tabPlacement,tabIndex,tabRect.x,tabRect.y,tabRect.width,tabRect.height,isSelected);
  paintTabBorder(g,tabPlacement,tabIndex,tabRect.x,tabRect.y,tabRect.width,tabRect.height,isSelected);
  String title=tabPane.getTitleAt(tabIndex);
  Font font=tabPane.getFont();
  FontMetrics metrics=g.getFontMetrics(font);
  Icon icon=getIconForTab(tabIndex);
  layoutLabel(tabPlacement,metrics,tabIndex,title,icon,tabRect,iconRect,textRect,isSelected);
  paintText(g,tabPlacement,font,metrics,tabIndex,title,textRect,isSelected);
  paintIcon(g,tabPlacement,tabIndex,icon,iconRect,isSelected);
  paintFocusIndicator(g,tabPlacement,rects,tabIndex,iconRect,textRect,isSelected);
  if (cropShape) {
    paintCroppedTabEdge(g,tabPlacement,tabIndex,isSelected,cropx,cropy);
    g2.setClip(save);
  }
 else   if (isOver || isSelected) {
    Rectangle closeRect=newCloseRect(tabRect);
    int dx=closeRect.x;
    int dy=closeRect.y;
    if (isCloseButtonEnabled)     paintCloseIcon(g2,dx,dy,isOver);
    if (isMaxButtonEnabled)     paintMaxIcon(g2,dx,dy,isOver);
  }
}",0.9595435684647304
103185,"protected Rectangle newMaxRect(Rectangle rect){
  int dx=rect.x + rect.width;
  int dy=(rect.y + rect.height) / 2 - 6;
  if (isCloseButtonEnabled)   dx-=BUTTONSIZE;
  return new Rectangle(dx - BUTTONSIZE - WIDTHDELTA,dy,BUTTONSIZE,BUTTONSIZE);
}","protected Rectangle newMaxRect(Rectangle rect){
  int dx=rect.x + rect.width - BUTTONSIZE - WIDTHDELTA;
  int dy=rect.y + (rect.height - BUTTONSIZE) / 2 + 2;
  if (isCloseButtonEnabled)   dx-=BUTTONSIZE;
  return new Rectangle(dx,dy,BUTTONSIZE,BUTTONSIZE);
}",0.8548707753479126
103186,"/** 
 * Constructor.
 * @param dialog the invite dialog
 * @param selected if the column is the selected ones
 */
public InviteContactTransferHandler(ContactList srcContactList,ContactList destContactList,boolean selected){
  this.srcContactList=srcContactList;
  this.destContactList=destContactList;
  this.selected=selected;
}","/** 
 * Constructor.
 * @param contactList the contact list, this transfer handler is about
 * @param type the type of this transfer handler. Indicates if it's used fordragging from the source contact list, or dropping in the destination contact list. One of SOURCE_TRANSFER_HANDLER or DEST_TRANSFER_HANDLER
 * @param selected if the column is the selected ones
 */
public InviteContactTransferHandler(ContactList contactList,int type,boolean selected){
  this.contactList=contactList;
  this.type=type;
  this.selected=selected;
}",0.5534883720930233
103187,"/** 
 * Indicates whether a component will accept an import of the given set of data flavors prior to actually attempting to import it. We return <tt>true</tt> to indicate that the transfer with at least one of the given flavors would work and <tt>false</tt> to reject the transfer. <p>
 * @param comp component
 * @param flavor the data formats available
 * @return  true if the data can be inserted into the component, falseotherwise
 * @throws NullPointerException if <code>support</code> is {@code null}
 */
public boolean canImport(JComponent comp,DataFlavor flavor[]){
  for (int i=0, n=flavor.length; i < n; i++) {
    if (flavor[i].equals(uiContactDataFlavor)) {
      if (comp instanceof ContactList) {
        return true;
      }
      return false;
    }
  }
  return false;
}","/** 
 * Indicates whether a component will accept an import of the given set of data flavors prior to actually attempting to import it. We return <tt>true</tt> to indicate that the transfer with at least one of the given flavors would work and <tt>false</tt> to reject the transfer. <p>
 * @param comp component
 * @param flavor the data formats available
 * @return  true if the data can be inserted into the component, falseotherwise
 * @throws NullPointerException if <code>support</code> is {@code null}
 */
public boolean canImport(JComponent comp,DataFlavor flavor[]){
  if (type != DEST_TRANSFER_HANDLER)   return false;
  for (int i=0, n=flavor.length; i < n; i++) {
    if (flavor[i].equals(uiContactDataFlavor)) {
      if (comp instanceof ContactList) {
        return true;
      }
      return false;
    }
  }
  return false;
}",0.967464702271332
103188,"/** 
 * Handles transfers to the invite dialog.
 * @param comp  the component to receive the transfer;
 * @param t the data to import
 * @return  true if the data was inserted into the component and falseotherwise
 */
public boolean importData(JComponent comp,Transferable t){
  if (t.isDataFlavorSupported(uiContactDataFlavor)) {
    if (!selected)     return false;
    Object o=null;
    try {
      o=t.getTransferData(uiContactDataFlavor);
    }
 catch (    UnsupportedFlavorException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"",e);
    }
catch (    IOException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"",e);
    }
    if (o instanceof Collection) {
      Iterator<?> c=((Collection<?>)o).iterator();
      while (c.hasNext()) {
        Object nextO=c.next();
        if (nextO instanceof UIContact) {
          destContactList.addContact(new InviteUIContact((UIContact)nextO,backupProvider),null,false,false);
        }
      }
      return true;
    }
 else     if (o instanceof UIContact) {
      destContactList.addContact(new InviteUIContact((UIContact)o,backupProvider),null,false,false);
      return true;
    }
 else     if (o instanceof ContactNode) {
      UIContact uiContact=((ContactNode)o).getContactDescriptor();
      if (uiContact != null) {
        destContactList.addContact(new InviteUIContact(uiContact,backupProvider),null,false,false);
        return true;
      }
    }
  }
  return false;
}","/** 
 * Handles transfers to the invite dialog.
 * @param comp  the component to receive the transfer;
 * @param t the data to import
 * @return  true if the data was inserted into the component and falseotherwise
 */
public boolean importData(JComponent comp,Transferable t){
  if (t.isDataFlavorSupported(uiContactDataFlavor)) {
    if (!selected)     return false;
    Object o=null;
    try {
      o=t.getTransferData(uiContactDataFlavor);
    }
 catch (    UnsupportedFlavorException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"",e);
    }
catch (    IOException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"",e);
    }
    if (o instanceof Collection) {
      Iterator<?> c=((Collection<?>)o).iterator();
      while (c.hasNext()) {
        Object nextO=c.next();
        if (nextO instanceof UIContact) {
          contactList.addContact(new InviteUIContact((UIContact)nextO,backupProvider),null,false,false);
        }
      }
      return true;
    }
 else     if (o instanceof UIContact) {
      contactList.addContact(new InviteUIContact((UIContact)o,backupProvider),null,false,false);
      return true;
    }
 else     if (o instanceof ContactNode) {
      UIContact uiContact=((ContactNode)o).getContactDescriptor();
      if (uiContact != null) {
        contactList.addContact(new InviteUIContact(uiContact,backupProvider),null,false,false);
        return true;
      }
    }
  }
  return false;
}",0.9939271255060728
103189,"/** 
 * Creates a transferable for text pane components in order to enable drag and drop of text.
 * @param component the component for which to create a<tt>Transferable</tt>
 * @return the created <tt>Transferable</tt>
 */
@Override protected Transferable createTransferable(JComponent component){
  if (component instanceof ContactList) {
    List<UIContact> c=((ContactList)component).getSelectedContacts();
    if (c != null)     return new UIContactTransferable(c);
  }
  return super.createTransferable(component);
}","/** 
 * Creates a transferable for text pane components in order to enable drag and drop of text.
 * @param component the component for which to create a<tt>Transferable</tt>
 * @return the created <tt>Transferable</tt>
 */
@Override protected Transferable createTransferable(JComponent component){
  if (type != SOURCE_TRANSFER_HANDLER)   return null;
  if (component instanceof ContactList) {
    List<UIContact> c=((ContactList)component).getSelectedContacts();
    if (c != null)     return new UIContactTransferable(c);
  }
  return super.createTransferable(component);
}",0.9508196721311476
103190,"/** 
 * Initializes the transfer handler.
 */
private void initTransferHandler(){
  inviteContactTransferHandler=new InviteContactTransferHandler(srcContactList,destContactList,true);
  if (srcContactList.getComponent() instanceof JComponent)   ((JComponent)srcContactList).setTransferHandler(inviteContactTransferHandler);
  if (destContactList.getComponent() instanceof JComponent)   ((JComponent)destContactList).setTransferHandler(inviteContactTransferHandler);
}","/** 
 * Initializes the transfer handler.
 */
private void initTransferHandler(){
  inviteContactTransferHandler=new InviteContactTransferHandler(destContactList,InviteContactTransferHandler.DEST_TRANSFER_HANDLER,true);
  InviteContactTransferHandler srcContactTransferHandler=new InviteContactTransferHandler(srcContactList,InviteContactTransferHandler.SOURCE_TRANSFER_HANDLER,true);
  if (srcContactList.getComponent() instanceof JComponent)   ((JComponent)srcContactList).setTransferHandler(srcContactTransferHandler);
  if (destContactList.getComponent() instanceof JComponent)   ((JComponent)destContactList).setTransferHandler(inviteContactTransferHandler);
}",0.7826855123674912
103191,"/** 
 * Dispatches the given <tt>KeyEvent</tt>.
 * @param e the <tt>KeyEvent</tt> to dispatch
 * @return <tt>true</tt> if the KeyboardFocusManager should take nofurther action with regard to the KeyEvent; <tt>false</tt> otherwise
 */
public boolean dispatchKeyEvent(KeyEvent e){
  if (!contactListContainer.isFocused() || (e.getID() != KeyEvent.KEY_PRESSED && e.getID() != KeyEvent.KEY_TYPED) || (GuiActivator.getUIService().getSingleWindowContainer() != null) && GuiActivator.getUIService().getSingleWindowContainer().containsFocus())   return false;
  if (e.getKeyCode() == KeyEvent.VK_ENTER && (e.isControlDown() || e.isMetaDown())) {
    contactListContainer.ctrlEnterKeyTyped();
    return false;
  }
 else   if (e.getKeyCode() == KeyEvent.VK_ENTER && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    contactListContainer.enterKeyTyped();
    return false;
  }
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.getComponent().requestFocus();
    return false;
  }
  if (contactList.getComponent().isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelection();
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  UIGroup selectedGroup=contactList.getSelectedGroup();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectedGroup != null && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  boolean singleWindowRule=GuiActivator.getUIService().getSingleWindowContainer() == null || contactList.getComponent().isFocusOwner();
  if (!searchField.isFocusOwner() && keyManager.getFocusOwner() != null && singleWindowRule && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    searchField.requestFocusInWindow();
    keyManager.redispatchEvent(searchField,e);
    return true;
  }
  return false;
}","/** 
 * Dispatches the given <tt>KeyEvent</tt>.
 * @param e the <tt>KeyEvent</tt> to dispatch
 * @return <tt>true</tt> if the KeyboardFocusManager should take nofurther action with regard to the KeyEvent; <tt>false</tt> otherwise
 */
public boolean dispatchKeyEvent(KeyEvent e){
  if (!contactListContainer.isFocused() || (e.getID() != KeyEvent.KEY_PRESSED && e.getID() != KeyEvent.KEY_TYPED) || (GuiActivator.getUIService().getSingleWindowContainer() != null) && GuiActivator.getUIService().getSingleWindowContainer().containsFocus() || keyManager.getFocusOwner() instanceof JTextComponent)   return false;
  if (e.getKeyCode() == KeyEvent.VK_ENTER && (e.isControlDown() || e.isMetaDown())) {
    contactListContainer.ctrlEnterKeyTyped();
    return false;
  }
 else   if (e.getKeyCode() == KeyEvent.VK_ENTER && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    contactListContainer.enterKeyTyped();
    return false;
  }
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.getComponent().requestFocus();
    return false;
  }
  if (contactList.getComponent().isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelection();
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  UIGroup selectedGroup=contactList.getSelectedGroup();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectedGroup != null && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  boolean singleWindowRule=GuiActivator.getUIService().getSingleWindowContainer() == null || contactList.getComponent().isFocusOwner();
  if (!searchField.isFocusOwner() && keyManager.getFocusOwner() != null && singleWindowRule && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    searchField.requestFocusInWindow();
    keyManager.redispatchEvent(searchField,e);
    return true;
  }
  return false;
}",0.987783595113438
103192,"/** 
 * Creates AutoAway handler.
 * @param configurationService the config service.
 */
public AutoAwayWatcher(ConfigurationService configurationService){
  String enabledDefault=GeneralConfigPluginActivator.getResources().getSettingsString(Preferences.ENABLE);
  if (configurationService.getBoolean(Preferences.ENABLE,Boolean.parseBoolean(enabledDefault))) {
    start();
  }
  configurationService.addPropertyChangeListener(Preferences.ENABLE,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (Boolean.parseBoolean((String)evt.getNewValue()))       start();
 else       stopInner();
    }
  }
);
  configurationService.addPropertyChangeListener(Preferences.TIMER,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      stopInner();
      start();
    }
  }
);
  GeneralConfigPluginActivator.bundleContext.addServiceListener(this);
  ServiceReference[] protocolProviderRefs=null;
  try {
    protocolProviderRefs=GeneralConfigPluginActivator.bundleContext.getServiceReferences(ProtocolProviderService.class.getName(),null);
  }
 catch (  InvalidSyntaxException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
  if (protocolProviderRefs != null) {
    for (int i=0; i < protocolProviderRefs.length; i++) {
      ProtocolProviderService provider=(ProtocolProviderService)GeneralConfigPluginActivator.bundleContext.getService(protocolProviderRefs[i]);
      this.handleProviderAdded(provider);
    }
  }
}","/** 
 * Creates AutoAway handler.
 * @param configurationService the config service.
 */
public AutoAwayWatcher(ConfigurationService configurationService){
  String enabledDefault=GeneralConfigPluginActivator.getResources().getSettingsString(Preferences.ENABLE);
  if (configurationService.getBoolean(Preferences.ENABLE,Boolean.parseBoolean(enabledDefault))) {
    start();
  }
  configurationService.addPropertyChangeListener(Preferences.ENABLE,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (Boolean.parseBoolean((String)evt.getNewValue()))       start();
 else       stopInner();
    }
  }
);
  configurationService.addPropertyChangeListener(Preferences.TIMER,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      stopInner();
      start();
    }
  }
);
}",0.7233502538071066
103193,"/** 
 * Stops and removes the listeners, without the global service listener.
 */
private void stopInner(){
  if (idleListener != null) {
    SystemActivityNotificationsService systemActivityNotificationsService=getSystemActivityNotificationsService();
    systemActivityNotificationsService.removeIdleSystemChangeListener(idleListener);
    systemActivityNotificationsService.removeSystemActivityChangeListener(idleListener);
    idleListener=null;
  }
}","/** 
 * Stops and removes the listeners.
 */
private void stopInner(){
  if (idleListener != null) {
    SystemActivityNotificationsService systemActivityNotificationsService=getSystemActivityNotificationsService();
    systemActivityNotificationsService.removeIdleSystemChangeListener(idleListener);
    systemActivityNotificationsService.removeSystemActivityChangeListener(idleListener);
    stopListeningForNewProviders();
    idleListener=null;
  }
}",0.9196919691969196
103194,"/** 
 * Remove provider from list with last statuses. If this is the last provider stop listening for idle events.
 * @param provider
 */
private synchronized void removeProviderFromLastStates(ProtocolProviderService provider){
  lastStates.remove(provider);
  if (lastStates.size() == 0)   stopInner();
}","/** 
 * Remove provider from list with last statuses. If this is the last provider stop listening for idle events.
 * @param provider
 */
private synchronized void removeProviderFromLastStates(ProtocolProviderService provider){
  lastStates.remove(provider);
}",0.9203539823008848
103195,"/** 
 * Starts and add needed listeners.
 */
private void start(){
  if (idleListener == null) {
    idleListener=new IdleListener();
    SystemActivityNotificationsService systemActivityNotificationsService=getSystemActivityNotificationsService();
    systemActivityNotificationsService.addIdleSystemChangeListener(StatusUpdateThread.getTimer() * 60 * 1000,idleListener);
    systemActivityNotificationsService.addSystemActivityChangeListener(idleListener);
  }
}","/** 
 * Starts and add needed listeners.
 */
private void start(){
  if (idleListener == null) {
    idleListener=new IdleListener();
    SystemActivityNotificationsService systemActivityNotificationsService=getSystemActivityNotificationsService();
    systemActivityNotificationsService.addIdleSystemChangeListener(StatusUpdateThread.getTimer() * 60 * 1000,idleListener);
    systemActivityNotificationsService.addSystemActivityChangeListener(idleListener);
    startListeningForNewProviders();
  }
}",0.9616580310880828
103196,"/** 
 * Sets the system properties net.java.sip.communicator.SC_HOME_DIR_LOCATION and net.java.sip.communicator.SC_HOME_DIR_NAME (if they aren't already set) in accord with the OS conventions specified by the name of the OS. Please leave the access modifier as package (default) to allow launch- wrappers to call it.
 * @param osName the name of the OS according to which the SC_HOME_DIR_properties are to be set
 */
static void setScHomeDir(String osName){
  String location=System.getProperty(PNAME_SC_HOME_DIR_LOCATION);
  String name=System.getProperty(PNAME_SC_HOME_DIR_NAME);
  boolean isHomeDirnameForced=name != null;
  if ((location == null) || (name == null)) {
    String defaultLocation=System.getProperty(""String_Node_Str"");
    String defaultName=""String_Node_Str"";
    boolean chekLegacyDirNames=(name == null) || name.equals(overridableDirName);
    if (osName.startsWith(""String_Node_Str"")) {
      if (location == null)       location=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
      if (name == null)       name=""String_Node_Str"";
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      if (location == null)       location=System.getenv(""String_Node_Str"");
      if (name == null)       name=""String_Node_Str"";
    }
    if (location == null)     location=defaultLocation;
    if (name == null)     name=defaultName;
    if (!isHomeDirnameForced && (new File(location,name).isDirectory() == false) && new File(defaultLocation,defaultName).isDirectory()) {
      location=defaultLocation;
      name=defaultName;
    }
    if (chekLegacyDirNames && !new File(location,name).isDirectory()) {
      for (int i=0; i < legacyDirNames.length; i++) {
        if (new File(location,legacyDirNames[i]).isDirectory()) {
          name=legacyDirNames[i];
          break;
        }
        if (new File(defaultLocation,legacyDirNames[i]).isDirectory()) {
          name=legacyDirNames[i];
          location=defaultLocation;
          break;
        }
      }
    }
    System.setProperty(PNAME_SC_HOME_DIR_LOCATION,location);
    System.setProperty(PNAME_SC_HOME_DIR_NAME,name);
  }
  new File(location,name + File.separator + ""String_Node_Str"").mkdirs();
}","/** 
 * Sets the system properties net.java.sip.communicator.SC_HOME_DIR_LOCATION and net.java.sip.communicator.SC_HOME_DIR_NAME (if they aren't already set) in accord with the OS conventions specified by the name of the OS. Please leave the access modifier as package (default) to allow launch- wrappers to call it.
 * @param osName the name of the OS according to which the SC_HOME_DIR_properties are to be set
 */
static void setScHomeDir(String osName){
  String location=System.getProperty(PNAME_SC_HOME_DIR_LOCATION);
  String name=System.getProperty(PNAME_SC_HOME_DIR_NAME);
  boolean isHomeDirnameForced=name != null;
  if ((location == null) || (name == null)) {
    String defaultLocation=System.getProperty(""String_Node_Str"");
    String defaultName=""String_Node_Str"";
    boolean chekLegacyDirNames=(name == null) || name.equals(overridableDirName);
    if (osName.startsWith(""String_Node_Str"")) {
      if (location == null)       location=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
      if (name == null)       name=""String_Node_Str"";
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      if (location == null)       location=System.getenv(""String_Node_Str"");
      if (name == null)       name=""String_Node_Str"";
    }
    if (location == null)     location=defaultLocation;
    if (name == null)     name=defaultName;
    if (!isHomeDirnameForced && (new File(location,name).isDirectory() == false) && new File(defaultLocation,defaultName).isDirectory()) {
      location=defaultLocation;
      name=defaultName;
    }
    if (chekLegacyDirNames && !checkHomeFolderExist(location,name,osName)) {
      for (int i=0; i < legacyDirNames.length; i++) {
        if (checkHomeFolderExist(location,legacyDirNames[i],osName)) {
          name=legacyDirNames[i];
          break;
        }
        if (checkHomeFolderExist(defaultLocation,legacyDirNames[i],osName)) {
          name=legacyDirNames[i];
          location=defaultLocation;
          break;
        }
      }
    }
    System.setProperty(PNAME_SC_HOME_DIR_LOCATION,location);
    System.setProperty(PNAME_SC_HOME_DIR_NAME,name);
  }
  new File(location,name + File.separator + ""String_Node_Str"").mkdirs();
}",0.9278579356270812
103197,"/** 
 * Determines whether or not the <tt>iface</tt> interface is a loopback interface. We use this method as a replacement to the <tt>NetworkInterface.isLoopback()</tt> method that only comes with java 1.6.
 * @param iface the inteface that we'd like to determine as loopback or not.
 * @return true if <tt>iface</tt> contains at least one loopback addressand <tt>false</tt> otherwise.
 */
private boolean isLoopbackInterface(NetworkInterface iface){
  Enumeration<InetAddress> addresses=iface.getInetAddresses();
  return addresses.hasMoreElements() && addresses.nextElement().isLoopbackAddress();
}","/** 
 * Determines whether or not the <tt>iface</tt> interface is a loopback interface. We use this method as a replacement to the <tt>NetworkInterface.isLoopback()</tt> method that only comes with java 1.6.
 * @param iface the inteface that we'd like to determine as loopback or not.
 * @return true if <tt>iface</tt> contains at least one loopback addressand <tt>false</tt> otherwise.
 */
private boolean isLoopbackInterface(NetworkInterface iface){
  try {
    Method method=iface.getClass().getMethod(""String_Node_Str"");
    return ((Boolean)method.invoke(iface,new Object[]{})).booleanValue();
  }
 catch (  Throwable t) {
  }
  Enumeration<InetAddress> addresses=iface.getInetAddresses();
  if (addresses.hasMoreElements()) {
    InetAddress address=addresses.nextElement();
    if (address.isLoopbackAddress() || address.getHostAddress().startsWith(WEIRD_MACOSX_LOOPBACK_ADDRESS))     return true;
  }
  return false;
}",0.7727570399476097
103198,"/** 
 * Tries to lock the configuration directory. If lock-ing is not possible because a previous instance is already running, then it transmits the list of args to that running instance. <p> There are three possible outcomes of this method. 1. We lock successfully; 2. We fail to lock because another instance of SIP Communicator is already running; 3. We fail to lock for some unknown error. Each of these cases is represented by an error code returned as a result.
 * @param args the array of arguments that we are to submit in case an instance of SIP Communicator has already been started.
 * @return an error or success code indicating the outcome of the lockoperation.
 */
public int tryLock(String[] args){
  File lockFile=getLockFile();
  if (lockFile.exists()) {
    InetSocketAddress lockAddress=readLockFile(lockFile);
    if (lockAddress != null) {
      if (interInstanceConnect(lockAddress,args) == SUCCESS) {
        return ALREADY_STARTED;
      }
    }
    lockFile.delete();
  }
  try {
    lockFile.getParentFile().mkdirs();
    lockFile.createNewFile();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + lockFile,e);
  }
  lockFile.deleteOnExit();
  return lock(lockFile);
}","/** 
 * Tries to lock the configuration directory. If lock-ing is not possible because a previous instance is already running, then it transmits the list of args to that running instance. <p> There are three possible outcomes of this method. 1. We lock successfully; 2. We fail to lock because another instance of Jitsi is already running; 3. We fail to lock for some unknown error. Each of these cases is represented by an error code returned as a result.
 * @param args the array of arguments that we are to submit in case an instance of Jitsi has already been started.
 * @return an error or success code indicating the outcome of the lockoperation.
 */
public int tryLock(String[] args){
  File lockFile=getLockFile();
  if (lockFile.exists()) {
    InetSocketAddress lockAddress=readLockFileRetrying(lockFile);
    if (lockAddress != null) {
      if (interInstanceConnect(lockAddress,args) == SUCCESS) {
        return ALREADY_STARTED;
      }
    }
    lockFile.delete();
  }
  return lock(lockFile);
}",0.8815848716794237
103199,"/** 
 * Creates and binds a socket on <tt>lockAddress</tt> and then starts a <tt>LockServer</tt> instance so that we would start interacting with other instances of SIP Communicator that are trying to start.
 * @return the <tt>ERROR</tt> code if something goes wrong and<tt>SUCCESS</tt> otherwise.
 */
private int startLockServer(InetSocketAddress localAddress){
  try {
    instanceServerSocket=new ServerSocket();
  }
 catch (  IOException exc) {
    logger.error(""String_Node_Str"",exc);
    return LOCK_ERROR;
  }
  try {
    instanceServerSocket.bind(localAddress,16);
  }
 catch (  IOException exc) {
    logger.error(""String_Node_Str"",exc);
    return LOCK_ERROR;
  }
  LockServer lockServ=new LockServer(instanceServerSocket);
  lockServ.start();
  return SUCCESS;
}","/** 
 * Creates and binds a socket on <tt>lockAddress</tt> and then starts a <tt>LockServer</tt> instance so that we would start interacting with other instances of Jitsi that are trying to start.
 * @return the <tt>ERROR</tt> code if something goes wrong and<tt>SUCCESS</tt> otherwise.
 */
private int startLockServer(InetSocketAddress localAddress){
  try {
    instanceServerSocket=new ServerSocket();
  }
 catch (  IOException exc) {
    logger.error(""String_Node_Str"",exc);
    return LOCK_ERROR;
  }
  try {
    instanceServerSocket.bind(localAddress,16);
  }
 catch (  IOException exc) {
    logger.error(""String_Node_Str"",exc);
    return LOCK_ERROR;
  }
  LockServer lockServ=new LockServer(instanceServerSocket);
  lockServ.start();
  return SUCCESS;
}",0.9863192182410424
103200,"/** 
 * Creates an instance of <tt>LockServerConnectionProcessor</tt> that would handle parameters received through the <tt>connectionSocket</tt>.
 * @param connectionSocket the socket that we will be using to read arguments from the remote SIP Communicator instance.
 */
public LockServerConnectionProcessor(Socket connectionSocket){
  this.connectionSocket=connectionSocket;
}","/** 
 * Creates an instance of <tt>LockServerConnectionProcessor</tt> that would handle parameters received through the <tt>connectionSocket</tt>.
 * @param connectionSocket the socket that we will be using to read arguments from the remote Jitsi instance.
 */
public LockServerConnectionProcessor(Socket connectionSocket){
  this.connectionSocket=connectionSocket;
}",0.9718120805369128
103201,"/** 
 * Locks the configuration directory by binding our lock socket and recording the lock file into the configuration directory. Returns SUCCESS if everything goes well and ERROR if something fails. This method does not return the ALREADY_RUNNING code as it is assumed that this has already been checked before calling this method.
 * @param lockFile the file that we should use to lock the configuration directory.
 * @return the SUCCESS or ERROR codes defined by this class.
 */
private int lock(File lockFile){
  InetAddress lockAddress=getRandomBindAddress();
  if (lockAddress == null) {
    return LOCK_ERROR;
  }
  int port=getRandomPortNumber();
  InetSocketAddress serverSocketAddress=new InetSocketAddress(lockAddress,port);
  writeLockFile(lockFile,serverSocketAddress);
  startLockServer(serverSocketAddress);
  return SUCCESS;
}","/** 
 * Locks the configuration directory by binding our lock socket and recording the lock file into the configuration directory. Returns SUCCESS if everything goes well and ERROR if something fails. This method does not return the ALREADY_RUNNING code as it is assumed that this has already been checked before calling this method.
 * @param lockFile the file that we should use to lock the configuration directory.
 * @return the SUCCESS or ERROR codes defined by this class.
 */
private int lock(File lockFile){
  InetAddress lockAddress=getRandomBindAddress();
  if (lockAddress == null) {
    return LOCK_ERROR;
  }
  int retries=7;
  int port=getRandomPortNumber();
  InetSocketAddress serverSocketAddress;
  while (startLockServer(serverSocketAddress=new InetSocketAddress(lockAddress,port)) != SUCCESS && retries > 0) {
    port=getRandomPortNumber();
    retries--;
  }
  try {
    lockFile.getParentFile().mkdirs();
    lockFile.createNewFile();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + lockFile,e);
  }
  lockFile.deleteOnExit();
  writeLockFile(lockFile,serverSocketAddress);
  return SUCCESS;
}",0.7522750252780587
103202,"/** 
 * Parses the <tt>lockFile</tt> into a standard Properties Object and verifies it for completeness. The method also tries to validate the contents of <tt>lockFile</tt> and asserts presence of all properties mandated by this version.
 * @param lockFile the file that we are to parse.
 * @return the <tt>SocketAddress</tt> that we should use to communicate witha possibly already running version of SIP Communicator.
 */
private InetSocketAddress readLockFile(File lockFile){
  Properties lockProperties=new Properties();
  try {
    lockProperties.load(new FileInputStream(lockFile));
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"",exc);
    return null;
  }
  String lockAddressStr=lockProperties.getProperty(PNAME_LOCK_ADDRESS);
  if (lockAddressStr == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  String lockPort=lockProperties.getProperty(PNAME_LOCK_PORT);
  if (lockPort == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  InetAddress lockAddress=findLocalAddress(lockAddressStr);
  if (lockAddress == null) {
    logger.error(lockAddressStr + ""String_Node_Str"");
    return null;
  }
  int port;
  try {
    port=Integer.parseInt(lockPort);
  }
 catch (  NumberFormatException exc) {
    logger.error(lockPort + ""String_Node_Str"",exc);
    return null;
  }
  InetSocketAddress lockSocketAddress=new InetSocketAddress(lockAddress,port);
  return lockSocketAddress;
}","/** 
 * Parses the <tt>lockFile</tt> into a standard Properties Object and verifies it for completeness. The method also tries to validate the contents of <tt>lockFile</tt> and asserts presence of all properties mandated by this version.
 * @param lockFile the file that we are to parse.
 * @return the <tt>SocketAddress</tt> that we should use to communicate witha possibly already running version of Jitsi.
 */
private InetSocketAddress readLockFile(File lockFile){
  Properties lockProperties=new Properties();
  try {
    lockProperties.load(new FileInputStream(lockFile));
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"",exc);
    return null;
  }
  String lockAddressStr=lockProperties.getProperty(PNAME_LOCK_ADDRESS);
  if (lockAddressStr == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  String lockPort=lockProperties.getProperty(PNAME_LOCK_PORT);
  if (lockPort == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  InetAddress lockAddress=findLocalAddress(lockAddressStr);
  if (lockAddress == null) {
    logger.error(lockAddressStr + ""String_Node_Str"");
    return null;
  }
  int port;
  try {
    port=Integer.parseInt(lockPort);
  }
 catch (  NumberFormatException exc) {
    logger.error(lockPort + ""String_Node_Str"",exc);
    return null;
  }
  InetSocketAddress lockSocketAddress=new InetSocketAddress(lockAddress,port);
  return lockSocketAddress;
}",0.9926599091226844
103203,"/** 
 * Returns a reference to the file that we should be using to lock SIP Communicator's home directory, whether it exists or not.
 * @return a reference to the file that we should be using to lock SIPCommunicator's home directory.
 */
private File getLockFile(){
  String homeDirLocation=System.getProperty(SIPCommunicator.PNAME_SC_HOME_DIR_LOCATION);
  String homeDirName=System.getProperty(SIPCommunicator.PNAME_SC_HOME_DIR_NAME);
  String fileSeparator=System.getProperty(""String_Node_Str"");
  String fullLockFileName=homeDirLocation + fileSeparator + homeDirName+ fileSeparator+ LOCK_FILE_NAME;
  return new File(fullLockFileName);
}","/** 
 * Returns a reference to the file that we should be using to lock Jitsi's home directory, whether it exists or not.
 * @return a reference to the file that we should be using to lock Jitsi'shome directory.
 */
private File getLockFile(){
  String homeDirLocation=System.getProperty(SIPCommunicator.PNAME_SC_HOME_DIR_LOCATION);
  String homeDirName=System.getProperty(SIPCommunicator.PNAME_SC_HOME_DIR_NAME);
  String fileSeparator=System.getProperty(""String_Node_Str"");
  String fullLockFileName=homeDirLocation + fileSeparator + homeDirName+ fileSeparator+ LOCK_FILE_NAME;
  return new File(fullLockFileName);
}",0.9666136724960256
103204,"/** 
 * Indicates that the security is turned on. <p> Sets the secured status icon to the status panel and initializes/updates the corresponding security details.
 * @param evt Details about the event that caused this message.
 */
public void securityOn(CallPeerSecurityOnEvent evt){
  if (evt == null) {
    securityStatusLabel.setSecurityOn();
    return;
  }
  SrtpControl srtpControl=evt.getSecurityController();
  if ((srtpControl.requiresSecureSignalingTransport() && callPeer.getProtocolProvider().isSignalingTransportSecure()) || !srtpControl.requiresSecureSignalingTransport()) {
    if (srtpControl instanceof ZrtpControl) {
      securityStatusLabel.setText(""String_Node_Str"");
      if (!((ZrtpControl)srtpControl).isSecurityVerified())       securityStatusLabel.setSecurityPending();
 else       securityStatusLabel.setSecurityOn();
    }
 else     securityStatusLabel.setSecurityOn();
  }
  if (!srtpControl.getClass().isInstance(securityPanel.getSecurityControl()) || (securityPanel instanceof ParanoiaTimerSecurityPanel)) {
    setSecurityPanelVisible(false);
    securityPanel=SecurityPanel.create(this,callPeer,srtpControl);
    if (srtpControl instanceof ZrtpControl)     ((ZrtpSecurityPanel)securityPanel).setSecurityStatusLabel(securityStatusLabel);
  }
  securityPanel.securityOn(evt);
  boolean isSecurityLowPriority=Boolean.parseBoolean(GuiActivator.getResources().getSettingsString(""String_Node_Str""));
  if (srtpControl instanceof ZrtpControl && !isSecurityLowPriority && (!((ZrtpControl)srtpControl).isSecurityVerified() || ((ZrtpSecurityPanel)securityPanel).isZidAorMismatch()))   setSecurityPanelVisible(true);
}","/** 
 * Indicates that the security is turned on. <p> Sets the secured status icon to the status panel and initializes/updates the corresponding security details.
 * @param evt Details about the event that caused this message.
 */
public void securityOn(CallPeerSecurityOnEvent evt){
  if (evt == null) {
    securityStatusLabel.setSecurityOn();
    return;
  }
  SrtpControl srtpControl=evt.getSecurityController();
  if ((srtpControl.requiresSecureSignalingTransport() && callPeer.getProtocolProvider().isSignalingTransportSecure()) || !srtpControl.requiresSecureSignalingTransport()) {
    if (srtpControl instanceof ZrtpControl) {
      securityStatusLabel.setText(""String_Node_Str"");
      if (!((ZrtpControl)srtpControl).isSecurityVerified())       securityStatusLabel.setSecurityPending();
 else       securityStatusLabel.setSecurityOn();
    }
 else     securityStatusLabel.setSecurityOn();
  }
  if (!srtpControl.getClass().isInstance(securityPanel.getSecurityControl()) || (securityPanel instanceof ParanoiaTimerSecurityPanel)) {
    setSecurityPanelVisible(false);
    securityPanel=SecurityPanel.create(this,callPeer,srtpControl);
    if (srtpControl instanceof ZrtpControl)     ((ZrtpSecurityPanel)securityPanel).setSecurityStatusLabel(securityStatusLabel);
  }
  securityPanel.securityOn(evt);
  boolean isSecurityLowPriority=Boolean.parseBoolean(GuiActivator.getResources().getSettingsString(""String_Node_Str""));
  if (srtpControl instanceof ZrtpControl && !isSecurityLowPriority && (!((ZrtpControl)srtpControl).isSecurityVerified() || ((ZrtpSecurityPanel)securityPanel).isZidAorMismatch())) {
    setSecurityPanelVisible(true);
  }
  this.revalidate();
}",0.9912413168227122
103205,"/** 
 * {@inheritDoc}
 */
public void videoAdded(VideoEvent event){
  setVideoSecurityOn(isAudioSecurityOn);
}","/** 
 * {@inheritDoc}
 */
public void videoAdded(VideoEvent event){
  setVideoSecurityOn(isVideoSecurityOn);
}",0.9727272727272728
103206,"/** 
 * {@inheritDoc}
 */
public void videoRemoved(VideoEvent event){
  setVideoSecurityOn(isAudioSecurityOn);
}","/** 
 * {@inheritDoc}
 */
public void videoRemoved(VideoEvent event){
  setVideoSecurityOn(isVideoSecurityOn);
}",0.9732142857142856
103207,"/** 
 * {@inheritDoc}
 */
public void videoUpdate(VideoEvent event){
  setVideoSecurityOn(isAudioSecurityOn);
}","/** 
 * {@inheritDoc}
 */
public void videoUpdate(VideoEvent event){
  setVideoSecurityOn(isVideoSecurityOn);
}",0.972972972972973
103208,"/** 
 * {@inheritDoc}
 */
public void propertyChange(final PropertyChangeEvent event){
  if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(event.getPropertyName())) {
    setVideoSecurityOn(isAudioSecurityOn);
  }
}","/** 
 * {@inheritDoc}
 */
public void propertyChange(final PropertyChangeEvent event){
  if (OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING.equals(event.getPropertyName())) {
    setVideoSecurityOn(isVideoSecurityOn);
  }
}",0.9822222222222222
103209,"/** 
 * Handles the <tt>ActionEvent</tt>. In order to rename the contact invokes the <code>renameMetaContact</code> method of the current <tt>MetaContactListService</tt>.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    if (metaContact != null) {
      new Thread(){
        public void run(){
          clist.renameMetaContact(metaContact,renameContactPanel.getNewName());
        }
      }
.start();
    }
  }
 else   if (name.equals(""String_Node_Str"")) {
    clist.clearDisplayNameUserDefined(metaContact);
  }
  this.dispose();
}","/** 
 * Handles the <tt>ActionEvent</tt>. In order to rename the contact invokes the <code>renameMetaContact</code> method of the current <tt>MetaContactListService</tt>.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    if (metaContact != null) {
      new Thread(){
        public void run(){
          clist.renameMetaContact(metaContact,renameContactPanel.getNewName());
        }
      }
.start();
    }
  }
 else   if (name.equals(""String_Node_Str"")) {
    clist.clearUserDefinedDisplayName(metaContact);
  }
  this.dispose();
}",0.9830508474576272
103210,"/** 
 * Allocates cobri (conference) channels for asp ecific <tt>MediaType</tt> to be used by a specific <tt>CallPeer</tt>.
 * @param peer the <tt>CallPeer</tt> which is to use the allocated cobri(conference) channels
 * @param mediaTypes the <tt>MediaType</tt>s for which cobri (conference)channels are to be allocated
 * @return a <tt>CobriConferenceIQ</tt> which describes the allocated cobri(conference) channels for the specified <tt>mediaTypes</tt> which are to be used by the specified <tt>peer</tt>; otherwise, <tt>null</tt>
 */
public CobriConferenceIQ createCobriChannels(CallPeerJabberImpl peer,Iterable<MediaType> mediaTypes){
  if (!isConferenceFocus())   return null;
  CallPeerMediaHandler<?> peerMediaHandler=peer.getMediaHandler();
  if (peerMediaHandler.getMediaHandler() != cobriMediaHandler) {
    for (    MediaType mediaType : MediaType.values())     if (peerMediaHandler.getStream(mediaType) != null)     return null;
  }
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  String jitsiVideoBridge=(cobri == null) ? protocolProvider.getJitsiVideoBridge() : cobri.getFrom();
  if ((jitsiVideoBridge == null) || (jitsiVideoBridge.length() == 0))   return null;
  CobriConferenceIQ conferenceRequest=new CobriConferenceIQ();
  if (cobri != null)   conferenceRequest.setID(cobri.getID());
  for (  MediaType mediaType : mediaTypes) {
    String contentName=mediaType.toString();
    CobriConferenceIQ.Content contentRequest=new CobriConferenceIQ.Content(contentName);
    conferenceRequest.addContent(contentRequest);
    boolean requestLocalChannel=true;
    if (cobri != null) {
      CobriConferenceIQ.Content content=cobri.getContent(contentName);
      if ((content != null) && (content.getChannelCount() > 0))       requestLocalChannel=false;
    }
    if (requestLocalChannel) {
      CobriConferenceIQ.Channel localChannelRequest=new CobriConferenceIQ.Channel();
      contentRequest.addChannel(localChannelRequest);
    }
    CobriConferenceIQ.Channel remoteChannelRequest=new CobriConferenceIQ.Channel();
    contentRequest.addChannel(remoteChannelRequest);
  }
  XMPPConnection connection=protocolProvider.getConnection();
  PacketCollector packetCollector=connection.createPacketCollector(new PacketIDFilter(conferenceRequest.getPacketID()));
  conferenceRequest.setTo(jitsiVideoBridge);
  conferenceRequest.setType(IQ.Type.GET);
  connection.sendPacket(conferenceRequest);
  Packet response=packetCollector.nextResult(SmackConfiguration.getPacketReplyTimeout());
  packetCollector.cancel();
  if ((response == null) || (response.getError() != null) || !(response instanceof CobriConferenceIQ))   return null;
  CobriConferenceIQ conferenceResponse=(CobriConferenceIQ)response;
  String conferenceResponseID=conferenceResponse.getID();
  if (cobri == null) {
    cobri=conferenceResponse;
  }
 else {
    String cobriID=cobri.getID();
    if (cobriID == null)     cobri.setID(conferenceResponseID);
 else     if (!cobriID.equals(conferenceResponseID))     throw new IllegalStateException(""String_Node_Str"");
    for (    CobriConferenceIQ.Content contentResponse : conferenceResponse.getContents()) {
      CobriConferenceIQ.Content content=cobri.getOrCreateContent(contentResponse.getName());
      for (      CobriConferenceIQ.Channel channelResponse : contentResponse.getChannels())       content.addChannel(channelResponse);
    }
  }
  CobriConferenceIQ conferenceResult=new CobriConferenceIQ();
  conferenceResult.setID(conferenceResponseID);
  for (  MediaType mediaType : mediaTypes) {
    CobriConferenceIQ.Content contentResponse=conferenceResponse.getContent(mediaType.toString());
    if (contentResponse != null) {
      String contentName=contentResponse.getName();
      CobriConferenceIQ.Content contentResult=new CobriConferenceIQ.Content(contentName);
      conferenceResult.addContent(contentResult);
      CobriConferenceIQ.Content content=cobri.getContent(contentName);
      CobriConferenceIQ.Channel localChannel=null;
      if ((content != null) && (content.getChannelCount() > 0)) {
        localChannel=content.getChannel(0);
        contentResult.addChannel(localChannel);
      }
      String localChannelID=(localChannel == null) ? null : localChannel.getID();
      for (      CobriConferenceIQ.Channel channelResponse : contentResponse.getChannels()) {
        if ((localChannelID == null) || !localChannelID.equals(channelResponse.getID()))         contentResult.addChannel(channelResponse);
      }
    }
  }
  if (cobriMediaHandler == null)   cobriMediaHandler=new MediaHandler();
  peerMediaHandler.setMediaHandler(cobriMediaHandler);
  return conferenceResult;
}","/** 
 * Allocates cobri (conference) channels for a specific <tt>MediaType</tt> to be used by a specific <tt>CallPeer</tt>.
 * @param peer the <tt>CallPeer</tt> which is to use the allocated cobri(conference) channels
 * @param rdpes the <tt>RtpDescriptionPacketExtension</tt>s which specifythe <tt>MediaType</tt>s for which cobri (conference) channels are to be allocated
 * @return a <tt>CobriConferenceIQ</tt> which describes the allocated cobri(conference) channels for the specified <tt>mediaTypes</tt> which are to be used by the specified <tt>peer</tt>; otherwise, <tt>null</tt>
 */
public CobriConferenceIQ createCobriChannels(CallPeerJabberImpl peer,Iterable<RtpDescriptionPacketExtension> rdpes){
  if (!isConferenceFocus())   return null;
  CallPeerMediaHandler<?> peerMediaHandler=peer.getMediaHandler();
  if (peerMediaHandler.getMediaHandler() != cobriMediaHandler) {
    for (    MediaType mediaType : MediaType.values())     if (peerMediaHandler.getStream(mediaType) != null)     return null;
  }
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  String jitsiVideoBridge=(cobri == null) ? protocolProvider.getJitsiVideoBridge() : cobri.getFrom();
  if ((jitsiVideoBridge == null) || (jitsiVideoBridge.length() == 0))   return null;
  CobriConferenceIQ conferenceRequest=new CobriConferenceIQ();
  if (cobri != null)   conferenceRequest.setID(cobri.getID());
  for (  RtpDescriptionPacketExtension rdpe : rdpes) {
    MediaType mediaType=MediaType.parseString(rdpe.getMedia());
    String contentName=mediaType.toString();
    CobriConferenceIQ.Content contentRequest=new CobriConferenceIQ.Content(contentName);
    conferenceRequest.addContent(contentRequest);
    boolean requestLocalChannel=true;
    if (cobri != null) {
      CobriConferenceIQ.Content content=cobri.getContent(contentName);
      if ((content != null) && (content.getChannelCount() > 0))       requestLocalChannel=false;
    }
    if (requestLocalChannel) {
      CobriConferenceIQ.Channel localChannelRequest=new CobriConferenceIQ.Channel();
      for (      PayloadTypePacketExtension ptpe : rdpe.getPayloadTypes())       localChannelRequest.addPayloadType(ptpe);
      contentRequest.addChannel(localChannelRequest);
    }
    CobriConferenceIQ.Channel remoteChannelRequest=new CobriConferenceIQ.Channel();
    for (    PayloadTypePacketExtension ptpe : rdpe.getPayloadTypes())     remoteChannelRequest.addPayloadType(ptpe);
    contentRequest.addChannel(remoteChannelRequest);
  }
  XMPPConnection connection=protocolProvider.getConnection();
  PacketCollector packetCollector=connection.createPacketCollector(new PacketIDFilter(conferenceRequest.getPacketID()));
  conferenceRequest.setTo(jitsiVideoBridge);
  conferenceRequest.setType(IQ.Type.GET);
  connection.sendPacket(conferenceRequest);
  Packet response=packetCollector.nextResult(SmackConfiguration.getPacketReplyTimeout());
  packetCollector.cancel();
  if ((response == null) || (response.getError() != null) || !(response instanceof CobriConferenceIQ))   return null;
  CobriConferenceIQ conferenceResponse=(CobriConferenceIQ)response;
  String conferenceResponseID=conferenceResponse.getID();
  if (cobri == null) {
    cobri=conferenceResponse;
  }
 else {
    String cobriID=cobri.getID();
    if (cobriID == null)     cobri.setID(conferenceResponseID);
 else     if (!cobriID.equals(conferenceResponseID))     throw new IllegalStateException(""String_Node_Str"");
    for (    CobriConferenceIQ.Content contentResponse : conferenceResponse.getContents()) {
      CobriConferenceIQ.Content content=cobri.getOrCreateContent(contentResponse.getName());
      for (      CobriConferenceIQ.Channel channelResponse : contentResponse.getChannels())       content.addChannel(channelResponse);
    }
  }
  CobriConferenceIQ conferenceResult=new CobriConferenceIQ();
  conferenceResult.setID(conferenceResponseID);
  for (  RtpDescriptionPacketExtension rdpe : rdpes) {
    MediaType mediaType=MediaType.parseString(rdpe.getMedia());
    CobriConferenceIQ.Content contentResponse=conferenceResponse.getContent(mediaType.toString());
    if (contentResponse != null) {
      String contentName=contentResponse.getName();
      CobriConferenceIQ.Content contentResult=new CobriConferenceIQ.Content(contentName);
      conferenceResult.addContent(contentResult);
      CobriConferenceIQ.Content content=cobri.getContent(contentName);
      CobriConferenceIQ.Channel localChannel=null;
      if ((content != null) && (content.getChannelCount() > 0)) {
        localChannel=content.getChannel(0);
        contentResult.addChannel(localChannel);
      }
      String localChannelID=(localChannel == null) ? null : localChannel.getID();
      for (      CobriConferenceIQ.Channel channelResponse : contentResponse.getChannels()) {
        if ((localChannelID == null) || !localChannelID.equals(channelResponse.getID()))         contentResult.addChannel(channelResponse);
      }
    }
  }
  if (cobriMediaHandler == null)   cobriMediaHandler=new MediaHandler();
  peerMediaHandler.setMediaHandler(cobriMediaHandler);
  return conferenceResult;
}",0.9419473738097676
103211,"/** 
 * Puts this peer into a   {@link CallPeerState#DISCONNECTED}, indicating a reason to the user, if there is one.
 * @param jingleIQ the {@link JingleIQ} that's terminating our session.
 */
public void processSessionTerminate(JingleIQ jingleIQ){
  String reasonStr=""String_Node_Str"";
  ReasonPacketExtension reasonExt=jingleIQ.getReason();
  if (reasonStr != null) {
    Reason reason=reasonExt.getReason();
    if (reason != null)     reasonStr+=""String_Node_Str"" + reason.toString() + ""String_Node_Str"";
    String text=reasonExt.getText();
    if (text != null)     reasonStr+=""String_Node_Str"" + text;
  }
  getMediaHandler().getTransportManager().close();
  setState(CallPeerState.DISCONNECTED,reasonStr);
}","/** 
 * Puts this peer into a   {@link CallPeerState#DISCONNECTED}, indicating a reason to the user, if there is one.
 * @param jingleIQ the {@link JingleIQ} that's terminating our session.
 */
public void processSessionTerminate(JingleIQ jingleIQ){
  String reasonStr=""String_Node_Str"";
  ReasonPacketExtension reasonExt=jingleIQ.getReason();
  if (reasonStr != null) {
    Reason reason=reasonExt.getReason();
    if (reason != null)     reasonStr+=""String_Node_Str"" + reason.toString() + ""String_Node_Str"";
    String text=reasonExt.getText();
    if (text != null)     reasonStr+=""String_Node_Str"" + text;
  }
  setState(CallPeerState.DISCONNECTED,reasonStr);
}",0.9630702389572772
103212,"/** 
 * Ends the call with for this <tt>CallPeer</tt>. Depending on the state of the peer the method would send a CANCEL, BYE, or BUSY_HERE message and set the new state to DISCONNECTED.
 * @param failed indicates if the hangup is following to a call failure orsimply a disconnect
 * @param reasonText the text, if any, to be set on the<tt>ReasonPacketExtension</tt> as the value of its
 * @param reasonOtherExtension the <tt>PacketExtension</tt>, if any, to beset on the <tt>ReasonPacketExtension</tt> as the value of its <tt>otherExtension</tt> property
 */
public void hangup(boolean failed,String reasonText,PacketExtension reasonOtherExtension){
  if (CallPeerState.DISCONNECTED.equals(getState()) || CallPeerState.FAILED.equals(getState())) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerState prevPeerState=getState();
  getMediaHandler().getTransportManager().close();
  if (failed)   setState(CallPeerState.FAILED,reasonText);
 else   setState(CallPeerState.DISCONNECTED,reasonText);
  JingleIQ responseIQ=null;
  if (prevPeerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(prevPeerState)) {
    responseIQ=JinglePacketFactory.createBye(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (CallPeerState.CONNECTING.equals(prevPeerState) || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(prevPeerState) || CallPeerState.ALERTING_REMOTE_SIDE.equals(prevPeerState)) {
    String jingleSID=getJingleSID();
    if (jingleSID == null) {
synchronized (sidSyncRoot) {
        cancelled=true;
        return;
      }
    }
    responseIQ=JinglePacketFactory.createCancel(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.INCOMING_CALL)) {
    responseIQ=JinglePacketFactory.createBusy(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.BUSY) || prevPeerState.equals(CallPeerState.FAILED)) {
  }
 else {
    logger.info(""String_Node_Str"");
  }
  if (responseIQ != null) {
    if (reasonOtherExtension != null) {
      ReasonPacketExtension reason=(ReasonPacketExtension)responseIQ.getExtension(ReasonPacketExtension.ELEMENT_NAME,ReasonPacketExtension.NAMESPACE);
      if (reason != null) {
        reason.setOtherExtension(reasonOtherExtension);
      }
 else       if (reasonOtherExtension instanceof ReasonPacketExtension) {
        responseIQ.setReason((ReasonPacketExtension)reasonOtherExtension);
      }
    }
    getProtocolProvider().getConnection().sendPacket(responseIQ);
  }
}","/** 
 * Ends the call with for this <tt>CallPeer</tt>. Depending on the state of the peer the method would send a CANCEL, BYE, or BUSY_HERE message and set the new state to DISCONNECTED.
 * @param failed indicates if the hangup is following to a call failure orsimply a disconnect
 * @param reasonText the text, if any, to be set on the<tt>ReasonPacketExtension</tt> as the value of its
 * @param reasonOtherExtension the <tt>PacketExtension</tt>, if any, to beset on the <tt>ReasonPacketExtension</tt> as the value of its <tt>otherExtension</tt> property
 */
public void hangup(boolean failed,String reasonText,PacketExtension reasonOtherExtension){
  if (CallPeerState.DISCONNECTED.equals(getState()) || CallPeerState.FAILED.equals(getState())) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerState prevPeerState=getState();
  setState(failed ? CallPeerState.FAILED : CallPeerState.DISCONNECTED,reasonText);
  JingleIQ responseIQ=null;
  if (prevPeerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(prevPeerState)) {
    responseIQ=JinglePacketFactory.createBye(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (CallPeerState.CONNECTING.equals(prevPeerState) || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(prevPeerState) || CallPeerState.ALERTING_REMOTE_SIDE.equals(prevPeerState)) {
    String jingleSID=getJingleSID();
    if (jingleSID == null) {
synchronized (sidSyncRoot) {
        cancelled=true;
        return;
      }
    }
    responseIQ=JinglePacketFactory.createCancel(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.INCOMING_CALL)) {
    responseIQ=JinglePacketFactory.createBusy(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.BUSY) || prevPeerState.equals(CallPeerState.FAILED)) {
  }
 else {
    logger.info(""String_Node_Str"");
  }
  if (responseIQ != null) {
    if (reasonOtherExtension != null) {
      ReasonPacketExtension reason=(ReasonPacketExtension)responseIQ.getExtension(ReasonPacketExtension.ELEMENT_NAME,ReasonPacketExtension.NAMESPACE);
      if (reason != null) {
        reason.setOtherExtension(reasonOtherExtension);
      }
 else       if (reasonOtherExtension instanceof ReasonPacketExtension) {
        responseIQ.setReason((ReasonPacketExtension)reasonOtherExtension);
      }
    }
    getProtocolProvider().getConnection().sendPacket(responseIQ);
  }
}",0.9763106796116504
103213,"/** 
 * Processes the session initiation   {@link JingleIQ} that we were createdwith, passing its content to the media handler and then sends either a ""session-info/ringing"" or a ""session-terminate"" response.
 * @param sessionInitIQ The {@link JingleIQ} that created the session thatwe are handling here.
 */
public void processSessionAccept(JingleIQ sessionInitIQ){
  this.sessionInitIQ=sessionInitIQ;
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  List<ContentPacketExtension> answer=sessionInitIQ.getContentList();
  try {
    mediaHandler.getTransportManager().wrapupConnectivityEstablishment();
    mediaHandler.processAnswer(answer);
  }
 catch (  Exception exc) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,exc.getClass().getName() + ""String_Node_Str"" + exc.getMessage());
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  setState(CallPeerState.CONNECTED);
  mediaHandler.start();
}","/** 
 * Processes the session initiation   {@link JingleIQ} that we were createdwith, passing its content to the media handler and then sends either a ""session-info/ringing"" or a ""session-terminate"" response.
 * @param sessionInitIQ The {@link JingleIQ} that created the session thatwe are handling here.
 */
public void processSessionAccept(JingleIQ sessionInitIQ){
  this.sessionInitIQ=sessionInitIQ;
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  List<ContentPacketExtension> answer=sessionInitIQ.getContentList();
  try {
    mediaHandler.getTransportManager().wrapupConnectivityEstablishment();
    mediaHandler.processAnswer(answer);
  }
 catch (  Exception exc) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,exc.getClass().getName() + ""String_Node_Str"" + exc.getMessage());
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  setState(CallPeerState.CONNECTED);
  mediaHandler.start();
}",0.978516416700446
103214,"/** 
 * Processes the <tt>transport-info</tt>   {@link JingleIQ}.
 * @param jingleIQ the <tt>transport-info</tt> {@link JingleIQ} to process
 */
public void processTransportInfo(JingleIQ jingleIQ){
  try {
    if (isInitiator) {
synchronized (sessionInitiateSyncRoot) {
        if (!sessionInitiateProcessed) {
          try {
            sessionInitiateSyncRoot.wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
    getMediaHandler().processTransportInfo(jingleIQ.getContentList());
  }
 catch (  OperationFailedException ofe) {
    logger.warn(""String_Node_Str"",ofe);
    String reasonText=""String_Node_Str"" + ofe.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.GENERAL_ERROR,reasonText);
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
synchronized (candSyncRoot) {
    candSyncRoot.notify();
  }
}","/** 
 * Processes the <tt>transport-info</tt>   {@link JingleIQ}.
 * @param jingleIQ the <tt>transport-info</tt> {@link JingleIQ} to process
 */
public void processTransportInfo(JingleIQ jingleIQ){
  try {
    if (isInitiator) {
synchronized (sessionInitiateSyncRoot) {
        if (!sessionInitiateProcessed) {
          try {
            sessionInitiateSyncRoot.wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
    getMediaHandler().processTransportInfo(jingleIQ.getContentList());
  }
 catch (  OperationFailedException ofe) {
    logger.warn(""String_Node_Str"",ofe);
    String reasonText=""String_Node_Str"" + ofe.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.GENERAL_ERROR,reasonText);
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
synchronized (candSyncRoot) {
    candSyncRoot.notify();
  }
}",0.9750353273669335
103215,"/** 
 * Processes the content-modify   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer wants to be modified
 */
public void processContentModify(JingleIQ content){
  ContentPacketExtension ext=content.getContentList().get(0);
  try {
    boolean modify=false;
    if (ext.getFirstChildOfType(RtpDescriptionPacketExtension.class) != null) {
      modify=true;
    }
    getMediaHandler().reinitContent(ext.getName(),ext,modify);
  }
 catch (  Exception exc) {
    logger.info(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"" + exc.getMessage());
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}","/** 
 * Processes the content-modify   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer wants to be modified
 */
public void processContentModify(JingleIQ content){
  ContentPacketExtension ext=content.getContentList().get(0);
  try {
    boolean modify=false;
    if (ext.getFirstChildOfType(RtpDescriptionPacketExtension.class) != null) {
      modify=true;
    }
    getMediaHandler().reinitContent(ext.getName(),ext,modify);
  }
 catch (  Exception exc) {
    logger.info(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"" + exc.getMessage());
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}",0.9714593430263866
103216,"/** 
 * Processes the content-accept   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer has accepted
 */
public void processContentAccept(JingleIQ content){
  List<ContentPacketExtension> contents=content.getContentList();
  try {
    getMediaHandler().getTransportManager().wrapupConnectivityEstablishment();
    getMediaHandler().processAnswer(contents);
  }
 catch (  Exception exc) {
    logger.warn(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"" + exc.getMessage());
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  getMediaHandler().start();
}","/** 
 * Processes the content-accept   {@link JingleIQ}.
 * @param content The {@link JingleIQ} that contains content that remotepeer has accepted
 */
public void processContentAccept(JingleIQ content){
  List<ContentPacketExtension> contents=content.getContentList();
  try {
    getMediaHandler().getTransportManager().wrapupConnectivityEstablishment();
    getMediaHandler().processAnswer(contents);
  }
 catch (  Exception exc) {
    logger.warn(""String_Node_Str"",exc);
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"" + exc.getMessage());
    setState(CallPeerState.FAILED,""String_Node_Str"" + exc.getMessage());
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  getMediaHandler().start();
}",0.9700734048560136
103217,"/** 
 * Indicates a user request to answer an incoming call from this <tt>CallPeer</tt>. Sends an OK response to <tt>callPeer</tt>. Make sure that the call peer contains an SDP description when you call this method.
 * @throws OperationFailedException if we fail to create or send theresponse.
 */
public synchronized void answer() throws OperationFailedException {
  Iterable<ContentPacketExtension> answer;
  try {
    getMediaHandler().getTransportManager().wrapupConnectivityEstablishment();
    answer=getMediaHandler().generateSessionAccept();
  }
 catch (  Exception exc) {
    logger.info(""String_Node_Str"",exc);
    String reasonText=""String_Node_Str"" + exc.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.FAILED_APPLICATION,reasonText);
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  JingleIQ response=JinglePacketFactory.createSessionAccept(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),getJingleSID(),answer);
  getProtocolProvider().getConnection().sendPacket(response);
  try {
    getMediaHandler().start();
  }
 catch (  UndeclaredThrowableException e) {
    Throwable exc=e.getUndeclaredThrowable();
    logger.info(""String_Node_Str"",exc);
    String reasonText=""String_Node_Str"" + exc.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.GENERAL_ERROR,reasonText);
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  setState(CallPeerState.CONNECTED);
}","/** 
 * Indicates a user request to answer an incoming call from this <tt>CallPeer</tt>. Sends an OK response to <tt>callPeer</tt>. Make sure that the call peer contains an SDP description when you call this method.
 * @throws OperationFailedException if we fail to create or send theresponse.
 */
public synchronized void answer() throws OperationFailedException {
  Iterable<ContentPacketExtension> answer;
  try {
    getMediaHandler().getTransportManager().wrapupConnectivityEstablishment();
    answer=getMediaHandler().generateSessionAccept();
  }
 catch (  Exception exc) {
    logger.info(""String_Node_Str"",exc);
    String reasonText=""String_Node_Str"" + exc.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.FAILED_APPLICATION,reasonText);
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  JingleIQ response=JinglePacketFactory.createSessionAccept(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),getJingleSID(),answer);
  getProtocolProvider().getConnection().sendPacket(response);
  try {
    getMediaHandler().start();
  }
 catch (  UndeclaredThrowableException e) {
    Throwable exc=e.getUndeclaredThrowable();
    logger.info(""String_Node_Str"",exc);
    String reasonText=""String_Node_Str"" + exc.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.GENERAL_ERROR,reasonText);
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  setState(CallPeerState.CONNECTED);
}",0.984956003406188
103218,"/** 
 * Processes the content-reject   {@link JingleIQ}.
 * @param content The {@link JingleIQ}
 */
public void processContentReject(JingleIQ content){
  if (content.getContentList().isEmpty()) {
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"");
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,""String_Node_Str"");
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}","/** 
 * Processes the content-reject   {@link JingleIQ}.
 * @param content The {@link JingleIQ}
 */
public void processContentReject(JingleIQ content){
  if (content.getContentList().isEmpty()) {
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,""String_Node_Str"");
    setState(CallPeerState.FAILED,""String_Node_Str"");
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
}",0.9509713228492136
103219,"/** 
 * Notified when a call are added to a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callAdded(CallGroupEvent evt){
  Iterator<CallPeerJabberImpl> peers=getCallPeers();
  while (peers.hasNext()) {
    setConferenceFocus(true);
    CallPeerJabberImpl callPeer=peers.next();
    callPeer.sendCoinSessionInfo(true);
  }
  super.callAdded(evt);
}","/** 
 * Notified when a call are added to a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callAdded(CallGroupEvent evt){
  Iterator<CallPeerJabberImpl> peers=getCallPeers();
  while (peers.hasNext()) {
    setConferenceFocus(true);
    CallPeerJabberImpl callPeer=peers.next();
    if (callPeer.getState() == CallPeerState.CONNECTED)     callPeer.sendCoinSessionInfo(true);
  }
  super.callAdded(evt);
}",0.8831168831168831
103220,"/** 
 * Notified when a call are added to a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callAdded(CallGroupEvent evt){
  Iterator<CallPeerSipImpl> peers=getCallPeers();
  while (peers.hasNext()) {
    setConferenceFocus(true);
    CallPeerSipImpl callPeer=peers.next();
    try {
      if (callPeer.getDialog() != null && callPeer.getDialog().getState() == DialogState.CONFIRMED)       callPeer.sendReInvite();
    }
 catch (    OperationFailedException e) {
      logger.info(""String_Node_Str"" + callPeer.getAddress());
    }
  }
  super.callAdded(evt);
}","/** 
 * Notified when a call are added to a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callAdded(CallGroupEvent evt){
  Iterator<CallPeerSipImpl> peers=getCallPeers();
  setConferenceFocus(true);
  while (peers.hasNext()) {
    CallPeerSipImpl callPeer=peers.next();
    try {
      if (callPeer.getState() == CallPeerState.CONNECTED)       callPeer.sendReInvite();
    }
 catch (    OperationFailedException e) {
      logger.info(""String_Node_Str"" + callPeer.getAddress());
    }
  }
  super.callAdded(evt);
}",0.8864468864468864
103221,"/** 
 * Notifies this <tt>MethodProcessorListener</tt> that the procedure for handling an INVITE or reINVITE SIP <tt>Request</tt> has completed and it is appropriate to determine whether the remote <tt>CallPeer</tt> is a conference focus.
 * @param sourceCallPeer the <tt>CallPeer</tt> with which the procedure forhandling an INVITE or reINVITE SIP <tt>Request</tt> has finished negotiating
 * @param remoteMessage the remote SIP <tt>Message</tt> which was received,processed and which prompted sending a specific local SIP <tt>Message</tt>
 * @param localMessage the local SIP <tt>Message</tt> which was sent to the<tt>CallPeer</tt> as part of the processing of its remote SIP <tt>Message</tt>
 */
private void inviteCompleted(CallPeerSipImpl sourceCallPeer,Message remoteMessage,Message localMessage){
  ContactHeader contactHeader=(ContactHeader)remoteMessage.getHeader(ContactHeader.NAME);
  boolean conferenceFocus=false;
  if (contactHeader != null) {
    Iterator<?> parameterNameIter=contactHeader.getParameterNames();
    while (parameterNameIter.hasNext())     if (""String_Node_Str"".equalsIgnoreCase(parameterNameIter.next().toString())) {
      conferenceFocus=true;
      break;
    }
  }
  sourceCallPeer.setConferenceFocus(conferenceFocus);
  if (conferenceFocus) {
    ConferenceSubscriberSubscription subscription=new ConferenceSubscriberSubscription(sourceCallPeer);
    try {
      subscriber.subscribe(subscription);
    }
 catch (    OperationFailedException ofe) {
      logger.error(""String_Node_Str"" + sourceCallPeer,ofe);
    }
  }
}","/** 
 * Notifies this <tt>MethodProcessorListener</tt> that the procedure for handling an INVITE or reINVITE SIP <tt>Request</tt> has completed and it is appropriate to determine whether the remote <tt>CallPeer</tt> is a conference focus.
 * @param sourceCallPeer the <tt>CallPeer</tt> with which the procedure forhandling an INVITE or reINVITE SIP <tt>Request</tt> has finished negotiating
 * @param remoteMessage the remote SIP <tt>Message</tt> which was received,processed and which prompted sending a specific local SIP <tt>Message</tt>
 * @param localMessage the local SIP <tt>Message</tt> which was sent to the<tt>CallPeer</tt> as part of the processing of its remote SIP <tt>Message</tt>
 */
private void inviteCompleted(CallPeerSipImpl sourceCallPeer,Message remoteMessage,Message localMessage){
  ContactHeader contactHeader=(ContactHeader)remoteMessage.getHeader(ContactHeader.NAME);
  boolean conferenceFocus=false;
  if (contactHeader != null) {
    Iterator<?> parameterNameIter=contactHeader.getParameterNames();
    while (parameterNameIter.hasNext())     if (""String_Node_Str"".equalsIgnoreCase(parameterNameIter.next().toString())) {
      conferenceFocus=true;
      break;
    }
  }
  sourceCallPeer.addCallPeerListener(callPeerStateListener);
  sourceCallPeer.setConferenceFocus(conferenceFocus);
  if (sourceCallPeer.isConferenceFocus() && sourceCallPeer.getState() == CallPeerState.CONNECTED) {
    ConferenceSubscriberSubscription subscription=new ConferenceSubscriberSubscription(sourceCallPeer);
    try {
      subscriber.subscribe(subscription);
    }
 catch (    OperationFailedException ofe) {
      logger.error(""String_Node_Str"" + sourceCallPeer,ofe);
    }
  }
}",0.9575384615384616
103222,"/** 
 * Notified when a call is removed from a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callRemoved(CallGroupEvent evt){
  Call c=evt.getSourceCall();
  c.removeCallChangeListener(this);
  Iterator<? extends CallPeer> peers=c.getCallPeers();
  while (peers.hasNext()) {
    CallPeer p=peers.next();
    getCrossProtocolCallPeersVector().remove(p);
    fireCallPeerEvent(p,CallPeerEvent.CALL_PEER_REMOVED);
  }
}","/** 
 * Notified when a call is removed from a <tt>CallGroup</tt>.
 * @param evt event
 */
public void callRemoved(CallGroupEvent evt){
  Call c=evt.getSourceCall();
  c.removeCallChangeListener(this);
  Iterator<? extends CallPeer> peers=c.getCallPeers();
  while (peers.hasNext()) {
    CallPeer p=peers.next();
    getCrossProtocolCallPeersVector().remove(p);
    fireCallPeerEvent(p,CallPeerEvent.CALL_PEER_REMOVED);
  }
  if ((getCallPeerCount() + getCallGroup().getCalls().size()) < 2)   setConferenceFocus(false);
}",0.8987341772151899
103223,"/** 
 * Sets the indicator which determines whether the local peer represented by this <tt>Call</tt> is acting as a conference focus and thus may need to send the corresponding parameters in its outgoing signaling.
 * @param conferenceFocus <tt>true</tt> if the local peer represented bythis <tt>Call</tt> is to act as a conference focus; otherwise, <tt>false</tt>
 */
public void setConferenceFocus(boolean conferenceFocus){
  if (this.conferenceFocus != conferenceFocus) {
    this.conferenceFocus=conferenceFocus;
    if (!this.conferenceFocus) {
      conferenceAudioMixer=null;
      conferenceVideoMixer=null;
      if (videoRTPTranslator != null) {
        videoRTPTranslator.dispose();
        videoRTPTranslator=null;
      }
    }
    fireCallChangeEvent(CallChangeEvent.CALL_FOCUS_CHANGE,!this.conferenceFocus,this.conferenceFocus);
  }
}","/** 
 * Sets the indicator which determines whether the local peer represented by this <tt>Call</tt> is acting as a conference focus and thus may need to send the corresponding parameters in its outgoing signaling.
 * @param conferenceFocus <tt>true</tt> if the local peer represented bythis <tt>Call</tt> is to act as a conference focus; otherwise, <tt>false</tt>
 */
public synchronized void setConferenceFocus(boolean conferenceFocus){
  if (this.conferenceFocus != conferenceFocus) {
    this.conferenceFocus=conferenceFocus;
    if (!this.conferenceFocus) {
      conferenceAudioMixer=null;
      conferenceVideoMixer=null;
      if (videoRTPTranslator != null) {
        videoRTPTranslator.dispose();
        videoRTPTranslator=null;
      }
    }
    fireCallChangeEvent(CallChangeEvent.CALL_FOCUS_CHANGE,!this.conferenceFocus,this.conferenceFocus);
  }
}",0.9924021040327294
103224,"/** 
 * Sets the view of this JViewport.
 * @param view the view to set.
 */
public void setViewportView(JComponent view){
  view.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  view.setOpaque(false);
  super.setViewportView(view);
}","/** 
 * Sets the view of this JViewport.
 * @param view the view to set.
 */
@Override public void setViewportView(Component view){
  if (view instanceof JComponent) {
    JComponent viewAsJComponent=(JComponent)view;
    viewAsJComponent.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    viewAsJComponent.setOpaque(false);
  }
  super.setViewportView(view);
}",0.7611202635914333
103225,"/** 
 * Paints this viewport.
 * @param g the <tt>Graphics</tt> object used for painting
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    Graphics2D g2=(Graphics2D)g;
    int width=getWidth();
    int height=getHeight();
    if (bgImage != null) {
      if (texture != null) {
        g2.setPaint(texture);
        g2.fillRect(0,0,width,height);
      }
 else {
        g.setColor(color);
        g.fillRect(0,0,width,height);
        g2.drawImage(bgImage,width - bgImage.getWidth(),height - bgImage.getHeight(),this);
      }
    }
  }
  finally {
    g.dispose();
  }
}","/** 
 * Paints this viewport.
 * @param g the <tt>Graphics</tt> object used for painting
 */
@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    Graphics2D g2=(Graphics2D)g;
    int width=getWidth();
    int height=getHeight();
    if (bgImage != null) {
      if (texture != null) {
        g2.setPaint(texture);
        g2.fillRect(0,0,width,height);
      }
 else {
        g.setColor(color);
        g.fillRect(0,0,width,height);
        g2.drawImage(bgImage,width - bgImage.getWidth(),height - bgImage.getHeight(),this);
      }
    }
  }
  finally {
    g.dispose();
  }
}",0.9925925925925926
103226,"/** 
 * Returns the boolean value of the property given by <tt>key</tt>.
 * @param key the key of the property we look for
 * @return the boolean value of the searched property
 */
private boolean getSettingsBoolean(String key){
  return new Boolean(GuiActivator.getResources().getSettingsString(key)).booleanValue();
}","/** 
 * Returns the boolean value of the property given by <tt>key</tt>.
 * @param key the key of the property we look for
 * @return the boolean value of the searched property
 */
private boolean getSettingsBoolean(String key){
  return Boolean.parseBoolean(GuiActivator.getResources().getSettingsString(key));
}",0.9493670886075948
103227,"/** 
 * Update the sound level indicator component to fit the given values.
 * @param soundLevel the sound level to show
 */
public void updateSoundLevel(int soundLevel){
  int range=1;
  if ((minSoundLevel > -1) && (maxSoundLevel > -1) && (minSoundLevel < maxSoundLevel)) {
    range=maxSoundLevel - minSoundLevel;
    if (soundLevel < 40)     soundLevel=minSoundLevel;
 else     if (soundLevel > 85)     soundLevel=maxSoundLevel;
 else {
      soundLevel=(int)(((soundLevel - 40.0) / 45.0) * range);
      if (soundLevel < minSoundLevel)       soundLevel=minSoundLevel;
 else       if (soundLevel > maxSoundLevel)       soundLevel=maxSoundLevel;
    }
  }
  this.soundLevel=(int)(this.soundLevel * 0.8 + soundLevel * 0.2);
  int activeBarNumber=Math.round(this.soundLevel * soundBarNumber / (float)range);
  for (int i=0, count=getComponentCount(); i < count; i++) {
    Component c=getComponent(i);
    if (c instanceof JLabel) {
      ((JLabel)c).setIcon((i < activeBarNumber) ? soundLevelActiveImage : soundLevelInactiveImage);
    }
  }
  this.repaint();
}","/** 
 * Update the sound level indicator component to fit the given values.
 * @param soundLevel the sound level to show
 */
public void updateSoundLevel(int soundLevel){
  int range=1;
  if ((minSoundLevel > -1) && (maxSoundLevel > -1) && (minSoundLevel < maxSoundLevel)) {
    range=maxSoundLevel - minSoundLevel;
    if (soundLevel < 40)     soundLevel=minSoundLevel;
 else     if (soundLevel > 85)     soundLevel=maxSoundLevel;
 else {
      soundLevel=(int)(((soundLevel - 40.0) / 45.0) * range);
      if (soundLevel < minSoundLevel)       soundLevel=minSoundLevel;
 else       if (soundLevel > maxSoundLevel)       soundLevel=maxSoundLevel;
    }
  }
  this.soundLevel=(int)(this.soundLevel * 0.8 + soundLevel * 0.2);
  int activeBarNumber=Math.round(this.soundLevel * soundBarNumber / (float)range);
  Component[] components=getComponents();
  for (int i=0; i < components.length; i++) {
    Component c=getComponent(i);
    if (c instanceof JLabel) {
      ((JLabel)c).setIcon((i < activeBarNumber) ? soundLevelActiveImage : soundLevelInactiveImage);
    }
  }
  this.repaint();
}",0.9530450953045096
103228,"/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing and appends it at the end of the conversationPanel document.
 * @param chatMessage the message to append
 */
private void appendChatMessage(ChatMessage chatMessage){
  String processedMessage=this.conversationPanel.processMessage(chatMessage);
  if (chatSession instanceof ConferenceChatSession) {
    if (chatMessage.getMessageType().equals(Chat.INCOMING_MESSAGE)) {
      String keyWord=((ChatRoomWrapper)chatSession.getDescriptor()).getChatRoom().getUserNickname();
      processedMessage=this.conversationPanel.processChatRoomHighlight(processedMessage,chatMessage.getContentType(),keyWord);
    }
    String meCommandMsg=this.conversationPanel.processMeCommand(chatMessage);
    if (meCommandMsg.length() > 0) {
      processedMessage=meCommandMsg;
    }
  }
  this.conversationPanel.appendMessageToEnd(processedMessage,chatMessage.getContentType());
}","/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing and appends it at the end of the conversationPanel document.
 * @param chatMessage the message to append
 */
private void appendChatMessage(ChatMessage chatMessage){
  String processedMessage=this.conversationPanel.processMessage(chatMessage);
  if (chatSession instanceof ConferenceChatSession) {
    if (chatMessage.getMessageType().equals(Chat.INCOMING_MESSAGE)) {
      String keyWord=((ChatRoomWrapper)chatSession.getDescriptor()).getChatRoom().getUserNickname();
      processedMessage=this.conversationPanel.processChatRoomHighlight(processedMessage,chatMessage.getContentType(),keyWord);
    }
    String meCommandMsg=this.conversationPanel.processMeCommand(chatMessage);
    if (meCommandMsg.length() > 0)     processedMessage=meCommandMsg;
  }
  this.conversationPanel.appendMessageToEnd(processedMessage,chatMessage.getContentType());
}",0.9947145877378436
103229,"/** 
 * Copies either the selected write area content or the selected conversation panel content to the clipboard.
 */
public void copy(){
  JTextComponent textPane=this.conversationPanel.getChatTextPane();
  if (textPane.getSelectedText() == null) {
    textPane=this.writeMessagePanel.getEditorPane();
  }
  textPane.copy();
}","/** 
 * Copies either the selected write area content or the selected conversation panel content to the clipboard.
 */
public void copy(){
  JTextComponent textPane=this.conversationPanel.getChatTextPane();
  if (textPane.getSelectedText() == null)   textPane=this.writeMessagePanel.getEditorPane();
  textPane.copy();
}",0.9351851851851852
103230,"/** 
 * Notifies the user if any member of the chatroom changes nickname
 */
public void chatRoomPropertyChanged(ChatRoomMemberPropertyChangeEvent event){
  this.conversationPanel.appendMessageToEnd(""String_Node_Str"" + event.getOldValue() + ""String_Node_Str""+ event.getNewValue()+ ""String_Node_Str"",ChatConversationPanel.HTML_CONTENT_TYPE);
}","/** 
 * Notifies the user if any member of the chatroom changes nickname.
 * @param event a <tt>ChatRoomMemberPropertyChangeEvent</tt> which carriesthe specific of the change
 */
public void chatRoomPropertyChanged(ChatRoomMemberPropertyChangeEvent event){
  this.conversationPanel.appendMessageToEnd(""String_Node_Str"" + event.getOldValue() + ""String_Node_Str""+ event.getNewValue()+ ""String_Node_Str"",ChatConversationPanel.HTML_CONTENT_TYPE);
}",0.8702290076335878
103231,"/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing.
 * @param contactName The name of the contact sending the message.
 * @param date The time at which the message is sent or received.
 * @param messageType The type of the message. One of OUTGOING_MESSAGEor INCOMING_MESSAGE.
 * @param message The message text.
 * @param contentType the content type of the message (html or plain text)
 * @return a string containing the processed message.
 */
private String processHistoryMessage(String contactName,String contactDisplayName,long date,String messageType,String message,String contentType){
  ChatMessage chatMessage=new ChatMessage(contactName,contactDisplayName,date,messageType,null,message,contentType);
  String processedMessage=this.conversationPanel.processMessage(chatMessage);
  if (chatSession instanceof ConferenceChatSession) {
    String tempMessage=conversationPanel.processMeCommand(chatMessage);
    if (tempMessage.length() > 0) {
      processedMessage=tempMessage;
    }
  }
  return processedMessage;
}","/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing.
 * @param contactName The name of the contact sending the message.
 * @param contactDisplayName the display name of the contact sending themessage
 * @param date The time at which the message is sent or received.
 * @param messageType The type of the message. One of OUTGOING_MESSAGEor INCOMING_MESSAGE.
 * @param message The message text.
 * @param contentType the content type of the message (html or plain text)
 * @return a string containing the processed message.
 */
private String processHistoryMessage(String contactName,String contactDisplayName,long date,String messageType,String message,String contentType){
  ChatMessage chatMessage=new ChatMessage(contactName,contactDisplayName,date,messageType,null,message,contentType);
  String processedMessage=this.conversationPanel.processMessage(chatMessage);
  if (chatSession instanceof ConferenceChatSession) {
    String tempMessage=conversationPanel.processMeCommand(chatMessage);
    if (tempMessage.length() > 0)     processedMessage=tempMessage;
  }
  return processedMessage;
}",0.9364214350590372
103232,"/** 
 * @param chatTransport Currently unused
 */
public SmsMessageListener(ChatTransport chatTransport){
}","/** 
 * Initializes a new <tt>SmsMessageListener</tt> instance.
 * @param chatTransport Currently unused
 */
public SmsMessageListener(ChatTransport chatTransport){
}",0.7838827838827839
103233,"/** 
 * Interrupts transmission of a <tt>DTMFTone</tt> started with the <tt>startSendingDTMF()</tt> method. Has no effect if no tone is currently being sent.
 * @param dtmfMethod The kind of DTMF used (RTP, SIP-INOF or INBAND).
 * @see AudioMediaStream#stopSendingDTMF(DTMFEnum)
 */
public void stopSendingDTMF(DTMFEnum dtmfMethod){
switch (dtmfMethod) {
case RTP_DTMF:
    if (dtmfTransfrmEngine != null) {
      dtmfTransfrmEngine.stopSendingDTMF();
    }
  break;
case SIP_INFO_DTMF:
break;
case INBAND_DTMF:
break;
}
}","/** 
 * Interrupts transmission of a <tt>DTMFTone</tt> started with the <tt>startSendingDTMF()</tt> method. Has no effect if no tone is currently being sent.
 * @param dtmfMethod The kind of DTMF used (RTP, SIP-INOF or INBAND).
 * @see AudioMediaStream#stopSendingDTMF(DTMFMethod)
 */
public void stopSendingDTMF(DTMFMethod dtmfMethod){
switch (dtmfMethod) {
case RTP_DTMF:
    if (dtmfTransfrmEngine != null) {
      dtmfTransfrmEngine.stopSendingDTMF();
    }
  break;
case SIP_INFO_DTMF:
break;
case INBAND_DTMF:
break;
}
}",0.9809160305343512
103234,"/** 
 * Starts sending the specified <tt>DTMFTone</tt> until the <tt>stopSendingDTMF()</tt> method is called (Excepts for INBAND DTMF, which stops by itself this is why where there is no need to call the stopSendingDTMF). Callers should keep in mind the fact that calling this method would most likely interrupt all audio transmission until the corresponding stop method is called. Also, calling this method successively without invoking the corresponding stop method between the calls will simply replace the <tt>DTMFTone</tt> from the first call with that from the second.
 * @param tone the <tt>DTMFTone</tt> to start sending.
 * @param dtmfMethod The kind of DTMF used (RTP, SIP-INOF or INBAND).
 * @see AudioMediaStream#startSendingDTMF(DTMFTone,DTMFEnum)
 */
public void startSendingDTMF(DTMFTone tone,DTMFEnum dtmfMethod){
switch (dtmfMethod) {
case RTP_DTMF:
    if (dtmfTransfrmEngine != null) {
      DTMFRtpTone t=DTMFRtpTone.mapTone(tone);
      if (t != null) {
        dtmfTransfrmEngine.startSending(t);
      }
    }
  break;
case SIP_INFO_DTMF:
break;
case INBAND_DTMF:
MediaDeviceSession deviceSession=getDeviceSession();
if (deviceSession != null) {
deviceSession.addDTMF(DTMFInbandTone.mapTone(tone));
}
break;
}
}","/** 
 * Starts sending the specified <tt>DTMFTone</tt> until the <tt>stopSendingDTMF()</tt> method is called (Excepts for INBAND DTMF, which stops by itself this is why where there is no need to call the stopSendingDTMF). Callers should keep in mind the fact that calling this method would most likely interrupt all audio transmission until the corresponding stop method is called. Also, calling this method successively without invoking the corresponding stop method between the calls will simply replace the <tt>DTMFTone</tt> from the first call with that from the second.
 * @param tone the <tt>DTMFTone</tt> to start sending.
 * @param dtmfMethod The kind of DTMF used (RTP, SIP-INOF or INBAND).
 * @see AudioMediaStream#startSendingDTMF(DTMFTone,DTMFMethod)
 */
public void startSendingDTMF(DTMFTone tone,DTMFMethod dtmfMethod){
switch (dtmfMethod) {
case RTP_DTMF:
    if (dtmfTransfrmEngine != null) {
      DTMFRtpTone t=DTMFRtpTone.mapTone(tone);
      if (t != null) {
        dtmfTransfrmEngine.startSending(t);
      }
    }
  break;
case SIP_INFO_DTMF:
break;
case INBAND_DTMF:
MediaDeviceSession deviceSession=getDeviceSession();
if (deviceSession != null) {
deviceSession.addDTMF(DTMFInbandTone.mapTone(tone));
}
break;
}
}",0.9919093851132686
103235,"/** 
 * Starts this <tt>MediaService</tt> implementation and thus makes it operational.
 */
void start(){
  deviceConfiguration.initialize();
  encodingConfiguration.initializeFormatPreferences();
  encodingConfiguration.registerCustomPackages();
  encodingConfiguration.registerCustomCodecs();
  if (!OSUtils.IS_ANDROID) {
    try {
      final Component panel=MediaConfiguration.createBasicControls(DeviceConfigurationComboBoxModel.AUDIO,false);
      audioConfigDialog=new SIPCommDialog(){
        /** 
 * Serial version UID.
 */
        private static final long serialVersionUID=0L;
        /** 
 * {@inheritDoc}
 */
        @Override protected void close(        boolean isEscaped){
          setVisible(false);
        }
      }
;
      TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,5));
      TransparentPanel fieldsPanel=new TransparentPanel(new BorderLayout(10,5));
      mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
      TransparentPanel btnPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
      JButton btn=new JButton(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      btn.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          audioConfigDialog.setVisible(false);
        }
      }
);
      btnPanel.add(btn);
      JTextArea infoTextArea=new JTextArea();
      infoTextArea.setOpaque(false);
      infoTextArea.setEditable(false);
      infoTextArea.setWrapStyleWord(true);
      infoTextArea.setLineWrap(true);
      infoTextArea.setText(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      fieldsPanel.add(infoTextArea,BorderLayout.NORTH);
      fieldsPanel.add(panel,BorderLayout.CENTER);
      fieldsPanel.add(btnPanel,BorderLayout.SOUTH);
      TransparentPanel iconPanel=new TransparentPanel(new BorderLayout());
      iconPanel.add(new JLabel(NeomediaActivator.getResources().getImage(""String_Node_Str"")),BorderLayout.NORTH);
      mainPanel.add(iconPanel,BorderLayout.WEST);
      mainPanel.add(fieldsPanel,BorderLayout.CENTER);
      audioConfigDialog.setTitle(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      audioConfigDialog.add(mainPanel);
      audioConfigDialog.validate();
      audioConfigDialog.pack();
      PortAudio.addDeviceChangedCallback(this);
    }
 catch (    Throwable e) {
      logger.info(""String_Node_Str"",e);
    }
  }
}","/** 
 * Starts this <tt>MediaService</tt> implementation and thus makes it operational.
 */
void start(){
  deviceConfiguration.initialize();
  deviceConfiguration.addPropertyChangeListener(deviceConfigurationPropertyChangeListener);
  encodingConfiguration.initializeFormatPreferences();
  encodingConfiguration.registerCustomPackages();
  encodingConfiguration.registerCustomCodecs();
  if (!OSUtils.IS_ANDROID) {
    try {
      final Component panel=MediaConfiguration.createBasicControls(DeviceConfigurationComboBoxModel.AUDIO,false);
      audioConfigDialog=new SIPCommDialog(){
        /** 
 * Serial version UID.
 */
        private static final long serialVersionUID=0L;
        /** 
 * {@inheritDoc}
 */
        @Override protected void close(        boolean isEscaped){
          setVisible(false);
        }
      }
;
      TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,5));
      TransparentPanel fieldsPanel=new TransparentPanel(new BorderLayout(10,5));
      mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
      TransparentPanel btnPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
      JButton btn=new JButton(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      btn.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          audioConfigDialog.setVisible(false);
        }
      }
);
      btnPanel.add(btn);
      JTextArea infoTextArea=new JTextArea();
      infoTextArea.setOpaque(false);
      infoTextArea.setEditable(false);
      infoTextArea.setWrapStyleWord(true);
      infoTextArea.setLineWrap(true);
      infoTextArea.setText(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      fieldsPanel.add(infoTextArea,BorderLayout.NORTH);
      fieldsPanel.add(panel,BorderLayout.CENTER);
      fieldsPanel.add(btnPanel,BorderLayout.SOUTH);
      TransparentPanel iconPanel=new TransparentPanel(new BorderLayout());
      iconPanel.add(new JLabel(NeomediaActivator.getResources().getImage(""String_Node_Str"")),BorderLayout.NORTH);
      mainPanel.add(iconPanel,BorderLayout.WEST);
      mainPanel.add(fieldsPanel,BorderLayout.CENTER);
      audioConfigDialog.setTitle(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
      audioConfigDialog.add(mainPanel);
      audioConfigDialog.validate();
      audioConfigDialog.pack();
      PortAudio.addDeviceChangedCallback(this);
    }
 catch (    Throwable e) {
      logger.info(""String_Node_Str"",e);
    }
  }
}",0.9815852682145716
103236,"/** 
 * Stops this <tt>MediaService</tt> implementation and thus signals that its utilization should cease.
 */
void stop(){
  PortAudio.removeDeviceChangedCallback(this);
}","/** 
 * Stops this <tt>MediaService</tt> implementation and thus signals that its utilization should cease.
 */
void stop(){
  deviceConfiguration.removePropertyChangeListener(deviceConfigurationPropertyChangeListener);
  PortAudio.removeDeviceChangedCallback(this);
}",0.7845804988662132
103237,"public void run(){
  JScrollBar verticalScrollBar=getVerticalScrollBar();
  if (verticalScrollBar != null)   verticalScrollBar.setValue(verticalScrollBar.getMaximum());
}","public void run(){
  JScrollBar verticalScrollBar=getVerticalScrollBar();
  if (verticalScrollBar != null) {
    verticalScrollBar.setValue(verticalScrollBar.getMaximum());
    chatTextPane.setCaretPosition(document.getLength());
  }
}",0.8395061728395061
103238,"/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
 else   if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && currentHref != null && currentHref.length() != 0) {
    GuiActivator.getBrowserLauncher().openURL(currentHref);
  }
}","/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
 else   if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && currentHref != null && currentHref.length() != 0) {
    GuiActivator.getBrowserLauncher().openURL(currentHref);
    this.currentHref=""String_Node_Str"";
  }
}",0.9653379549393414
103239,"public void removeUpdate(DocumentEvent event){
  if (!this.isEnabled)   return;
  try {
    Document doc=event.getDocument();
    String text=doc.getText(0,doc.getLength());
    if (text.length() != 0) {
      Word changed;
      if (event.getOffset() == 0 || !Character.isLetter(text.charAt(event.getOffset() - 1))) {
        changed=Word.getWord(text,event.getOffset(),false);
      }
 else {
        changed=Word.getWord(text,event.getOffset() - 1,true);
      }
      format(changed);
    }
    promptRepaint();
  }
 catch (  BadLocationException exc) {
    String msg=""String_Node_Str"";
    logger.error(msg,exc);
  }
}","public void removeUpdate(DocumentEvent event){
  if (!this.isEnabled)   return;
  try {
    Document doc=event.getDocument();
    String text=doc.getText(0,doc.getLength());
    if (text.length() != 0) {
      Word changed;
      if (event.getOffset() == 0 || !Character.isLetter(text.charAt(event.getOffset() - 1))) {
        changed=Word.getWord(text,event.getOffset(),false);
      }
 else {
        changed=Word.getWord(text,event.getOffset() - 1,true);
      }
      format(changed);
    }
    promptRepaint();
  }
 catch (  BadLocationException exc) {
    String msg=""String_Node_Str"";
    logger.error(msg,exc);
  }
catch (  Throwable exc) {
    logger.error(""String_Node_Str"",exc);
  }
}",0.9461713419257012
103240,"public void insertUpdate(DocumentEvent event){
  if (!this.isEnabled)   return;
  try {
    Document doc=event.getDocument();
    String text=doc.getText(0,doc.getLength());
    if (event.getLength() == 1) {
      char changeChar=text.charAt(event.getOffset());
      if (getCaretPosition() == text.length() - 1) {
        if (!Character.isLetter(changeChar)) {
          Word last=Word.getWord(text,text.length() - 1,true);
          format(last);
        }
 else {
          clearUnderlining(event.getOffset(),event.getOffset() + 1);
        }
      }
 else {
        if (Character.isLetter(changeChar)) {
          Word changed;
          int previousIndex=Math.max(0,event.getOffset() - 1);
          if (Character.isLetter(text.charAt(previousIndex)))           changed=Word.getWord(text,event.getOffset(),true);
 else           changed=Word.getWord(text,event.getOffset(),false);
          format(changed);
        }
 else {
          Word firstWord=Word.getWord(text,event.getOffset(),true);
          Word secondWord=Word.getWord(text,event.getOffset() + 1,false);
          format(firstWord);
          format(secondWord);
        }
      }
    }
 else {
      Word changed=Word.getWord(text,event.getOffset(),true);
      int wordStart=changed.getStart();
      while (wordStart < event.getOffset() + event.getLength()) {
        format(changed);
        int end=Math.min(changed.getStart() + changed.getText().length() + 1,text.length());
        changed=Word.getWord(text,end,false);
        wordStart=end;
      }
    }
  }
 catch (  BadLocationException exc) {
    String msg=""String_Node_Str"";
    logger.error(msg,exc);
  }
  promptRepaint();
}","public void insertUpdate(DocumentEvent event){
  if (!this.isEnabled)   return;
  try {
    Document doc=event.getDocument();
    String text=doc.getText(0,doc.getLength());
    if (event.getLength() == 1) {
      char changeChar=text.charAt(event.getOffset());
      if (getCaretPosition() == text.length() - 1) {
        if (!Character.isLetter(changeChar)) {
          Word last=Word.getWord(text,text.length() - 1,true);
          format(last);
        }
 else {
          clearUnderlining(event.getOffset(),event.getOffset() + 1);
        }
      }
 else {
        if (Character.isLetter(changeChar)) {
          Word changed;
          int previousIndex=Math.max(0,event.getOffset() - 1);
          if (Character.isLetter(text.charAt(previousIndex)))           changed=Word.getWord(text,event.getOffset(),true);
 else           changed=Word.getWord(text,event.getOffset(),false);
          format(changed);
        }
 else {
          Word firstWord=Word.getWord(text,event.getOffset(),true);
          Word secondWord=Word.getWord(text,event.getOffset() + 1,false);
          format(firstWord);
          format(secondWord);
        }
      }
    }
 else {
      Word changed=Word.getWord(text,event.getOffset(),true);
      int wordStart=changed.getStart();
      while (wordStart < event.getOffset() + event.getLength()) {
        format(changed);
        int end=Math.min(changed.getStart() + changed.getText().length() + 1,text.length());
        changed=Word.getWord(text,end,false);
        wordStart=end;
      }
    }
  }
 catch (  BadLocationException exc) {
    String msg=""String_Node_Str"";
    logger.error(msg,exc);
  }
catch (  Throwable exc) {
    logger.error(""String_Node_Str"",exc);
  }
  promptRepaint();
}",0.9790622235328812
103241,"/** 
 * Handles changes in the state of a <code>Call</code> this policy applies to in order to detect when new calls become in-progress and when the other calls should be put on hold.
 * @param callChangeEvent a <code>CallChangeEvent</code> value which describes the <code>Call</code> and the change in its state
 */
private void callStateChanged(CallChangeEvent callChangeEvent){
  Call call=callChangeEvent.getSourceCall();
  if (CallState.CALL_INITIALIZATION.equals(callChangeEvent.getOldValue()) && CallState.CALL_IN_PROGRESS.equals(call.getCallState()) && ProtocolProviderActivator.getConfigurationService().getBoolean(PNAME_SINGLE_CALL_IN_PROGRESS_POLICY_ENABLED,true)) {
synchronized (calls) {
      for (      Call otherCall : calls) {
        if (!call.equals(otherCall) && CallState.CALL_IN_PROGRESS.equals(otherCall.getCallState())) {
          if ((call.getCallGroup() != null || otherCall.getCallGroup() != null) && call.getCallGroup() != otherCall.getCallGroup())           putOnHold(otherCall);
        }
      }
    }
  }
}","/** 
 * Handles changes in the state of a <code>Call</code> this policy applies to in order to detect when new calls become in-progress and when the other calls should be put on hold.
 * @param callChangeEvent a <code>CallChangeEvent</code> value which describes the <code>Call</code> and the change in its state
 */
private void callStateChanged(CallChangeEvent callChangeEvent){
  Call call=callChangeEvent.getSourceCall();
  if (CallState.CALL_INITIALIZATION.equals(callChangeEvent.getOldValue()) && CallState.CALL_IN_PROGRESS.equals(call.getCallState()) && ProtocolProviderActivator.getConfigurationService().getBoolean(PNAME_SINGLE_CALL_IN_PROGRESS_POLICY_ENABLED,true)) {
synchronized (calls) {
      for (      Call otherCall : calls) {
        if (!call.equals(otherCall) && CallState.CALL_IN_PROGRESS.equals(otherCall.getCallState())) {
          if ((call.getCallGroup() == null && otherCall.getCallGroup() == null) || (call.getCallGroup() != null || otherCall.getCallGroup() != null) && call.getCallGroup() != otherCall.getCallGroup())           putOnHold(otherCall);
        }
      }
    }
  }
}",0.9678621332091292
103242,"/** 
 * Determines the exact type of the change and acts accordingly by either updating group name or .
 * @param evt the MetaContactListEvent containing the corresponding contact
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  MetaContactGroup mcGroup=evt.getSourceMetaContactGroup();
  Element mcGroupNode=findMetaContactGroupNode(mcGroup.getMetaUID());
  if (mcGroupNode == null) {
    logger.error(""String_Node_Str"" + mcGroup);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",new Exception());
    return;
  }
switch (evt.getEventID()) {
case MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP:
    Node parentNode=mcGroupNode.getParentNode();
  parentNode.removeChild(mcGroupNode);
Element newGroupElement=createMetaContactGroupNode(mcGroup);
parentNode.appendChild(newGroupElement);
try {
scheduleContactListStorage();
}
 catch (IOException ex) {
logger.error(""String_Node_Str"" + mcGroup,ex);
}
break;
case MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED:
mcGroupNode.setAttribute(GROUP_NAME_ATTR_NAME,mcGroup.getGroupName());
break;
case MetaContactGroupEvent.CONTACT_GROUP_RENAMED_IN_META_GROUP:
break;
}
try {
scheduleContactListStorage();
}
 catch (IOException ex) {
logger.error(""String_Node_Str"" + mcGroup.getGroupName(),ex);
}
}","/** 
 * Determines the exact type of the change and acts accordingly by either updating group name or .
 * @param evt the MetaContactListEvent containing the corresponding contact
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  MetaContactGroup mcGroup=evt.getSourceMetaContactGroup();
  Element mcGroupNode=findMetaContactGroupNode(mcGroup.getMetaUID());
  if (mcGroupNode == null) {
    logger.error(""String_Node_Str"" + mcGroup);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",new Exception());
    return;
  }
switch (evt.getEventID()) {
case MetaContactGroupEvent.CONTACT_GROUP_RENAMED_IN_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP:
    Node parentNode=mcGroupNode.getParentNode();
  parentNode.removeChild(mcGroupNode);
Element newGroupElement=createMetaContactGroupNode(mcGroup);
parentNode.appendChild(newGroupElement);
try {
scheduleContactListStorage();
}
 catch (IOException ex) {
logger.error(""String_Node_Str"" + mcGroup,ex);
}
break;
case MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED:
mcGroupNode.setAttribute(GROUP_NAME_ATTR_NAME,mcGroup.getGroupName());
break;
}
try {
scheduleContactListStorage();
}
 catch (IOException ex) {
logger.error(""String_Node_Str"" + mcGroup.getGroupName(),ex);
}
}",0.6240295748613678
103243,"/** 
 * Determines whether or not this meta group contains only groups that are being stored by a server.
 * @return true if the meta group is persistent and false otherwise.
 */
public boolean isPersistent(){
  Iterator<ContactGroup> contactGroupsIter=getContactGroups();
  while (contactGroupsIter.hasNext()) {
    ContactGroup contactGroup=contactGroupsIter.next();
    if (contactGroup.isPersistent())     return true;
  }
  return false;
}","/** 
 * Determines whether or not this meta group contains only groups that are being stored by a server.
 * @return true if the meta group is persistent and false otherwise.
 */
public boolean isPersistent(){
  Iterator<ContactGroup> contactGroupsIter=getContactGroups();
  while (contactGroupsIter.hasNext()) {
    ContactGroup contactGroup=contactGroupsIter.next();
    if (contactGroup.isPersistent())     return true;
  }
  if (countContactGroups() == 0)   return true;
 else   return false;
}",0.921443736730361
103244,"/** 
 * Renames the specified <tt>MetaContactGroup</tt> as indicated by the <tt>newName</tt> param. The operation would only affect the local meta group and would not ""touch"" any encapsulated protocol specific group. <p>
 * @param group the group to rename.
 * @param newGroupName the new name of the <tt>MetaContactGroup</tt> torename.
 */
public void renameMetaContactGroup(MetaContactGroup group,String newGroupName){
  ((MetaContactGroupImpl)group).setGroupName(newGroupName);
  fireMetaContactGroupEvent(group,null,null,MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED);
}","/** 
 * Renames the specified <tt>MetaContactGroup</tt> as indicated by the <tt>newName</tt> param. The operation would only affect the local meta group and would not ""touch"" any encapsulated protocol specific group. <p>
 * @param group the group to rename.
 * @param newGroupName the new name of the <tt>MetaContactGroup</tt> torename.
 */
public void renameMetaContactGroup(MetaContactGroup group,String newGroupName){
  ((MetaContactGroupImpl)group).setGroupName(newGroupName);
  Iterator<ContactGroup> groups=group.getContactGroups();
  while (groups.hasNext()) {
    ContactGroup protoGroup=groups.next();
    OperationSetPersistentPresence opSetPresence=protoGroup.getProtocolProvider().getOperationSet(OperationSetPersistentPresence.class);
    if (opSetPresence != null) {
      try {
        opSetPresence.renameServerStoredContactGroup(protoGroup,newGroupName);
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"" + protoGroup,t);
      }
    }
  }
  fireMetaContactGroupEvent(group,null,null,MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED);
}",0.6968599033816425
103245,"public void run(){
  int resultCount=0;
  queryMetaContactSource(filterPattern,GuiActivator.getContactListService().getRoot(),query,resultCount);
  if (!query.isCanceled())   query.fireQueryEvent(MetaContactQueryStatusEvent.QUERY_COMPLETED);
 else   query.fireQueryEvent(MetaContactQueryStatusEvent.QUERY_CANCELED);
}","public void run(){
  metaContactMoved(evt);
}",0.2265193370165746
103246,"/** 
 * Performs needed operations, when a <tt>MetaContact</tt> has been moved in the <tt>MetaContactListService</tt> from one group to another.
 * @param evt the <tt>MetaContactMovedEvent</tt> that notified us
 */
public void metaContactMoved(final MetaContactMovedEvent evt){
  final MetaContact metaContact=evt.getSourceMetaContact();
  final MetaContactGroup oldParent=evt.getOldParent();
  final MetaContactGroup newParent=evt.getNewParent();
synchronized (metaContact) {
    UIContact uiContact=MetaContactListSource.getUIContact(metaContact);
    if (uiContact == null)     return;
    UIGroup oldUIGroup;
    if (MetaContactListSource.isRootGroup(oldParent))     oldUIGroup=GuiActivator.getContactList().getTreeModel().getRoot().getGroupDescriptor();
 else synchronized (oldParent) {
      oldUIGroup=MetaContactListSource.getUIGroup(oldParent);
    }
    if (oldUIGroup != null)     GuiActivator.getContactList().removeContact(uiContact);
    uiContact=MetaContactListSource.createUIContact(evt.getSourceMetaContact());
    UIGroup newUIGroup=null;
    if (!MetaContactListSource.isRootGroup(newParent)) {
synchronized (newParent) {
        newUIGroup=MetaContactListSource.getUIGroup(newParent);
        if (newUIGroup == null)         newUIGroup=MetaContactListSource.createUIGroup(newParent);
      }
    }
    ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
    if (currentFilter.isMatching(uiContact))     GuiActivator.getContactList().addContact(uiContact,newUIGroup,true,true);
 else     MetaContactListSource.removeUIContact(metaContact);
  }
}","/** 
 * Performs needed operations, when a <tt>MetaContact</tt> has been moved in the <tt>MetaContactListService</tt> from one group to another.
 * @param evt the <tt>MetaContactMovedEvent</tt> that notified us
 */
public void metaContactMoved(final MetaContactMovedEvent evt){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        metaContactMoved(evt);
      }
    }
);
    return;
  }
  final MetaContact metaContact=evt.getSourceMetaContact();
  final MetaContactGroup oldParent=evt.getOldParent();
  final MetaContactGroup newParent=evt.getNewParent();
synchronized (metaContact) {
    UIContact uiContact=MetaContactListSource.getUIContact(metaContact);
    if (uiContact == null)     return;
    UIGroup oldUIGroup;
    if (MetaContactListSource.isRootGroup(oldParent))     oldUIGroup=GuiActivator.getContactList().getTreeModel().getRoot().getGroupDescriptor();
 else synchronized (oldParent) {
      oldUIGroup=MetaContactListSource.getUIGroup(oldParent);
    }
    if (oldUIGroup != null)     GuiActivator.getContactList().removeContact(uiContact);
    uiContact=MetaContactListSource.createUIContact(metaContact);
    UIGroup newUIGroup=null;
    if (!MetaContactListSource.isRootGroup(newParent)) {
synchronized (newParent) {
        newUIGroup=MetaContactListSource.getUIGroup(newParent);
        if (newUIGroup == null)         newUIGroup=MetaContactListSource.createUIGroup(newParent);
      }
    }
    ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
    if (currentFilter.isMatching(uiContact))     GuiActivator.getContactList().addContact(uiContact,newUIGroup,true,true);
 else     MetaContactListSource.removeUIContact(metaContact);
  }
}",0.9339285714285714
103247,"/** 
 * Change the source group change the buddies
 * @param newGroup RosterGroup
 */
void setSourceGroup(RosterGroup newGroup){
  this.id=newGroup.getName();
  buddies.clear();
  for (  RosterEntry item : newGroup.getEntries())   addContact(new ContactJabberImpl(item,ssclCallback,true,true));
}","/** 
 * Change the source group, used when renaming groups.
 * @param newGroup RosterGroup
 */
void setSourceGroup(RosterGroup newGroup){
  this.id=newGroup.getName();
}",0.6408602150537634
103248,"/** 
 * Appends the given string at the end of the contained in this panel document.
 * @param chatString the string to append
 */
public void appendMessageToEnd(String chatString,String contentType){
synchronized (scrollToBottomRunnable) {
    Element root=document.getDefaultRootElement();
    scrollToBottomIsPending=true;
    try {
      document.insertAfterEnd(root.getElement(root.getElementCount() - 1),chatString);
    }
 catch (    BadLocationException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
    if (!isHistory)     ensureDocumentSize();
    final Element elem;
    if (!(root.getElementCount() < 2)) {
      elem=root.getElement(root.getElementCount() - 2);
    }
 else     elem=root.getElement(1);
    if (GuiActivator.getConfigurationService().getBoolean(ReplacementProperty.REPLACEMENT_ENABLE,true) || GuiActivator.getConfigurationService().getBoolean(ReplacementProperty.getPropertyName(""String_Node_Str""),true)) {
      processReplacement(elem,chatString,contentType);
    }
  }
}","/** 
 * Appends the given string at the end of the contained in this panel document.
 * @param chatString the string to append
 */
public void appendMessageToEnd(String chatString,String contentType){
synchronized (scrollToBottomRunnable) {
    Element root=document.getDefaultRootElement();
    try {
      document.insertAfterEnd(root.getElement(root.getElementCount() - 1),chatString);
      SwingUtilities.invokeLater(scrollToBottomRunnable);
    }
 catch (    BadLocationException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
    if (!isHistory)     ensureDocumentSize();
    final Element elem;
    if (!(root.getElementCount() < 2)) {
      elem=root.getElement(root.getElementCount() - 2);
    }
 else     elem=root.getElement(1);
    if (GuiActivator.getConfigurationService().getBoolean(ReplacementProperty.REPLACEMENT_ENABLE,true) || GuiActivator.getConfigurationService().getBoolean(ReplacementProperty.getPropertyName(""String_Node_Str""),true)) {
      processReplacement(elem,chatString,contentType);
    }
  }
}",0.9579908675799088
103249,"/** 
 * Adds all contacts contained in the given <tt>MetaContactGroup</tt> matching the current filter and not contained in the contact list.
 * @param metaGroup the <tt>MetaContactGroup</tt>, which matching contactsto add
 * @param query the <tt>MetaContactQuery</tt> that notifies interestedlisteners of the results of this matching
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
private void addMatching(MetaContactGroup metaGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=metaGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
        if (!MetaContactListSource.isRootGroup(metaGroup)) {
synchronized (metaGroup) {
            uiGroup=MetaContactListSource.getUIGroup(metaGroup);
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(metaGroup);
          }
        }
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + metaContact.getDisplayName());
        UIContact newUIContact;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.createUIContact(metaContact);
        }
        GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
        query.setInitialResultCount(resultCount);
      }
 else       query.fireQueryEvent(metaContact);
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=metaGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    if (isMatching(subgroup)) {
      GuiActivator.getContactList().addGroup(MetaContactListSource.createUIGroup(subgroup),true);
      addMatching(subgroup,query,resultCount);
    }
  }
}","/** 
 * Adds all contacts contained in the given <tt>MetaContactGroup</tt> matching the current filter and not contained in the contact list.
 * @param metaGroup the <tt>MetaContactGroup</tt>, which matching contactsto add
 * @param query the <tt>MetaContactQuery</tt> that notifies interestedlisteners of the results of this matching
 * @param resultCount the initial result count we would insert directly tothe contact list without firing events
 */
private void addMatching(MetaContactGroup metaGroup,MetaContactQuery query,int resultCount){
  Iterator<MetaContact> childContacts=metaGroup.getChildContacts();
  while (childContacts.hasNext() && !query.isCanceled()) {
    MetaContact metaContact=childContacts.next();
    if (isMatching(metaContact)) {
      resultCount++;
      if (resultCount <= INITIAL_CONTACT_COUNT) {
        UIGroup uiGroup=null;
        if (!MetaContactListSource.isRootGroup(metaGroup)) {
synchronized (metaGroup) {
            uiGroup=MetaContactListSource.getUIGroup(metaGroup);
            if (uiGroup == null)             uiGroup=MetaContactListSource.createUIGroup(metaGroup);
          }
        }
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + metaContact.getDisplayName());
        UIContact newUIContact;
synchronized (metaContact) {
          newUIContact=MetaContactListSource.createUIContact(metaContact);
        }
        GuiActivator.getContactList().addContact(newUIContact,uiGroup,true,true);
        query.setInitialResultCount(resultCount);
      }
 else       query.fireQueryEvent(metaContact);
    }
  }
  if (query.isCanceled())   return;
  Iterator<MetaContactGroup> subgroups=metaGroup.getSubgroups();
  while (subgroups.hasNext() && !query.isCanceled()) {
    MetaContactGroup subgroup=subgroups.next();
    if (isMatching(subgroup)) {
      UIGroup uiGroup;
synchronized (subgroup) {
        uiGroup=MetaContactListSource.getUIGroup(subgroup);
        if (uiGroup == null)         uiGroup=MetaContactListSource.createUIGroup(subgroup);
      }
      GuiActivator.getContactList().addGroup(uiGroup,true);
      addMatching(subgroup,query,resultCount);
    }
  }
}",0.9260964380906228
103250,"/** 
 * Adds the given group to this list.
 * @param group the <tt>UIGroup</tt> to add
 * @param isSorted indicates if the contact should be sorted regarding tothe <tt>GroupNode</tt> policy
 */
public void addGroup(final UIGroup group,final boolean isSorted){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        addGroup(group,isSorted);
      }
    }
);
    return;
  }
  GroupNode parentNode=treeModel.getRoot();
  if (isSorted)   parentNode.sortedAddContactGroup(group);
 else   parentNode.addContactGroup(group);
  expandGroup(treeModel.getRoot());
}","/** 
 * Adds the given group to this list.
 * @param group the <tt>UIGroup</tt> to add
 * @param isSorted indicates if the contact should be sorted regarding tothe <tt>GroupNode</tt> policy
 */
public void addGroup(final UIGroup group,final boolean isSorted){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        addGroup(group,isSorted);
      }
    }
);
    return;
  }
  GroupNode groupNode=group.getGroupNode();
  if (groupNode == null) {
    GroupNode parentNode=treeModel.getRoot();
    if (isSorted)     parentNode.sortedAddContactGroup(group);
 else     parentNode.addContactGroup(group);
  }
  expandGroup(treeModel.getRoot());
}",0.929368029739777
103251,"/** 
 * Adds a contact node corresponding to the parent <tt>MetaContact</tt> if this last is matching the current filter and wasn't previously contained in the contact list.
 * @param evt the <tt>ProtoContactEvent</tt> that notified us
 */
public void protoContactAdded(ProtoContactEvent evt){
  final MetaContact metaContact=evt.getNewParent();
  UIContact parentUIContact;
  boolean parentUIContactCreated=false;
synchronized (metaContact) {
    parentUIContact=MetaContactListSource.getUIContact(metaContact);
    if (parentUIContact == null) {
      parentUIContactCreated=true;
      parentUIContact=MetaContactListSource.createUIContact(metaContact);
    }
  }
  if (parentUIContact != null && parentUIContactCreated) {
    ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
    if (currentFilter.isMatching(parentUIContact)) {
      MetaContactGroup parentGroup=metaContact.getParentMetaContactGroup();
      UIGroup uiGroup=null;
      if (!MetaContactListSource.isRootGroup(parentGroup)) {
        uiGroup=MetaContactListSource.getUIGroup(parentGroup);
        if (uiGroup == null)         uiGroup=MetaContactListSource.createUIGroup(parentGroup);
      }
      GuiActivator.getContactList().addContact(parentUIContact,uiGroup,true,true);
    }
 else     MetaContactListSource.removeUIContact(metaContact);
  }
}","/** 
 * Adds a contact node corresponding to the parent <tt>MetaContact</tt> if this last is matching the current filter and wasn't previously contained in the contact list.
 * @param evt the <tt>ProtoContactEvent</tt> that notified us
 */
public void protoContactAdded(ProtoContactEvent evt){
  final MetaContact metaContact=evt.getNewParent();
  UIContact parentUIContact;
  boolean parentUIContactCreated=false;
synchronized (metaContact) {
    parentUIContact=MetaContactListSource.getUIContact(metaContact);
    if (parentUIContact == null) {
      parentUIContactCreated=true;
      parentUIContact=MetaContactListSource.createUIContact(metaContact);
    }
  }
  if (parentUIContact != null && parentUIContactCreated) {
    ContactListFilter currentFilter=GuiActivator.getContactList().getCurrentFilter();
    if (currentFilter.isMatching(parentUIContact)) {
      MetaContactGroup parentGroup=metaContact.getParentMetaContactGroup();
      UIGroup uiGroup=null;
      if (!MetaContactListSource.isRootGroup(parentGroup)) {
synchronized (parentGroup) {
          uiGroup=MetaContactListSource.getUIGroup(parentGroup);
          if (uiGroup == null)           uiGroup=MetaContactListSource.createUIGroup(parentGroup);
        }
      }
      GuiActivator.getContactList().addContact(parentUIContact,uiGroup,true,true);
    }
 else     MetaContactListSource.removeUIContact(metaContact);
  }
}",0.9836304110585667
103252,"/** 
 * Returns the quality control for video calls if any. Return null so protocols who supports it to override it.
 * @param peer the peer which this control operates on.
 * @return the implemented quality control.
 */
public QualityControl getQualityControl(CallPeer peer){
  return ((CallPeerJabberImpl)peer).getMediaHandler().getQualityControl();
}","/** 
 * Returns the quality control for video calls if any. Return null so protocols who supports it to override it.
 * @param peer the peer which this control operates on.
 * @return the implemented quality control.
 */
public QualityControl getQualityControl(CallPeer peer){
  if (peer instanceof CallPeerJabberImpl)   return ((CallPeerJabberImpl)peer).getMediaHandler().getQualityControl();
 else   return null;
}",0.8946684005201561
103253,"/** 
 * Returns the number of online <tt>MetaContact</tt>s that this group contains. <p>
 * @return the number of online <tt>MetaContact</tt>s that this groupcontains.
 */
public int countOnlineChildContacts(){
  int onlineContactsNumber=0;
  try {
    Iterator<MetaContact> itr=getChildContacts();
    while (itr.hasNext()) {
      if (itr.next().getDefaultContact().getPresenceStatus().isOnline()) {
        onlineContactsNumber++;
      }
    }
  }
 catch (  Exception e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  return onlineContactsNumber;
}","/** 
 * Returns the number of online <tt>MetaContact</tt>s that this group contains. <p>
 * @return the number of online <tt>MetaContact</tt>s that this groupcontains.
 */
public int countOnlineChildContacts(){
  int onlineContactsNumber=0;
  try {
    Iterator<MetaContact> itr=getChildContacts();
    while (itr.hasNext()) {
      Contact contact=itr.next().getDefaultContact();
      if (contact == null)       continue;
      if (contact.getPresenceStatus().isOnline()) {
        onlineContactsNumber++;
      }
    }
  }
 catch (  Exception e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  return onlineContactsNumber;
}",0.8890675241157556
103254,"public void run(){
  if (logger.isTraceEnabled()) {
    logger.trace(fromID + ""String_Node_Str"");
  }
  ContactJabberImpl srcContact=ssContactList.findContactById(fromID);
  if (srcContact == null)   srcContact=createVolatileContact(fromID);
  AuthorizationRequest req=new AuthorizationRequest();
  AuthorizationResponse response=handler.processAuthorisationRequest(req,srcContact);
  Presence.Type responsePresenceType=null;
  if (response != null) {
    if (response.getResponseCode().equals(AuthorizationResponse.ACCEPT)) {
      responsePresenceType=Presence.Type.subscribed;
      if (logger.isInfoEnabled())       logger.info(""String_Node_Str"");
    }
 else     if (response.getResponseCode().equals(AuthorizationResponse.REJECT)) {
      responsePresenceType=Presence.Type.unsubscribed;
      if (logger.isInfoEnabled())       logger.info(""String_Node_Str"");
    }
  }
  if (responsePresenceType == null)   return;
  Presence responsePacket=new Presence(responsePresenceType);
  responsePacket.setTo(fromID);
  parentProvider.getConnection().sendPacket(responsePacket);
}","public void run(){
  ssContactList.init();
  contactChangesListener=new ContactChangesListener();
  Roster roster=parentProvider.getConnection().getRoster();
  roster.addRosterListener(contactChangesListener);
  parentProvider.startJingleNodesDiscovery();
  parentProvider.getConnection().removePacketListener(this);
}",0.0343839541547277
103255,"/** 
 * Process packets.
 * @param packet packet received to be processed
 */
public void processPacket(Packet packet){
  Presence presence=(Presence)packet;
  if (presence == null)   return;
  Presence.Type presenceType=presence.getType();
  final String fromID=presence.getFrom();
  if (presenceType == Presence.Type.subscribe) {
    new Thread(new Runnable(){
      public void run(){
        if (logger.isTraceEnabled()) {
          logger.trace(fromID + ""String_Node_Str"");
        }
        ContactJabberImpl srcContact=ssContactList.findContactById(fromID);
        if (srcContact == null)         srcContact=createVolatileContact(fromID);
        AuthorizationRequest req=new AuthorizationRequest();
        AuthorizationResponse response=handler.processAuthorisationRequest(req,srcContact);
        Presence.Type responsePresenceType=null;
        if (response != null) {
          if (response.getResponseCode().equals(AuthorizationResponse.ACCEPT)) {
            responsePresenceType=Presence.Type.subscribed;
            if (logger.isInfoEnabled())             logger.info(""String_Node_Str"");
          }
 else           if (response.getResponseCode().equals(AuthorizationResponse.REJECT)) {
            responsePresenceType=Presence.Type.unsubscribed;
            if (logger.isInfoEnabled())             logger.info(""String_Node_Str"");
          }
        }
        if (responsePresenceType == null)         return;
        Presence responsePacket=new Presence(responsePresenceType);
        responsePacket.setTo(fromID);
        parentProvider.getConnection().sendPacket(responsePacket);
      }
    }
).start();
  }
 else   if (presenceType == Presence.Type.unsubscribed) {
    if (logger.isTraceEnabled())     logger.trace(fromID + ""String_Node_Str"");
    ContactJabberImpl contact=ssContactList.findContactById(fromID);
    if (contact != null) {
      AuthorizationResponse response=new AuthorizationResponse(AuthorizationResponse.REJECT,""String_Node_Str"");
      handler.processAuthorizationResponse(response,contact);
      try {
        ssContactList.removeContact(contact);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"");
      }
    }
  }
 else   if (presenceType == Presence.Type.subscribed) {
    ContactJabberImpl contact=ssContactList.findContactById(fromID);
    AuthorizationResponse response=new AuthorizationResponse(AuthorizationResponse.ACCEPT,""String_Node_Str"");
    handler.processAuthorizationResponse(response,contact);
  }
}","/** 
 * When roaster packet with no error is received we are ready to to dispatch the contact list, doing it in different thread to avoid blocking xmpp packet receiving.
 * @param packet the roaster packet
 */
public void processPacket(Packet packet){
  if (packet.getError() != null) {
    return;
  }
  new Thread(this,getClass().getName()).start();
}",0.0755244755244755
103256,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    contactChangesListener=new ContactChangesListener();
    parentProvider.getConnection().getRoster().addRosterListener(contactChangesListener);
    fireProviderStatusChangeEvent(currentStatus,parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE));
    ssContactList.init();
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    PresenceStatus offlineStatus=parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
    currentStatus=offlineStatus;
    fireProviderStatusChangeEvent(oldStatus,currentStatus);
    ssContactList.cleanup();
    subscribtionPacketListener=null;
    if (parentProvider.getConnection() != null && parentProvider.getConnection().getRoster() != null)     parentProvider.getConnection().getRoster().removeRosterListener(contactChangesListener);
    contactChangesListener=null;
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERING) {
    parentProvider.getConnection().addPacketListener(new ServerStoredListInit(),new PacketTypeFilter(RosterPacket.class));
  }
 else   if (evt.getNewState() == RegistrationState.REGISTERED) {
    fireProviderStatusChangeEvent(currentStatus,parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE));
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    PresenceStatus offlineStatus=parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
    currentStatus=offlineStatus;
    fireProviderStatusChangeEvent(oldStatus,currentStatus);
    ssContactList.cleanup();
    subscribtionPacketListener=null;
    if (parentProvider.getConnection() != null && parentProvider.getConnection().getRoster() != null)     parentProvider.getConnection().getRoster().removeRosterListener(contactChangesListener);
    contactChangesListener=null;
  }
}",0.8810916179337231
103257,"/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(InetSocketAddress address,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address.getAddress().getHostAddress(),address.getPort(),serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
 else     if (tlsRequired)     throw new XMPPException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  setTrafficClass();
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    startJingleNodesDiscovery();
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}","/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(InetSocketAddress address,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address.getAddress().getHostAddress(),address.getPort(),serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
 else     if (tlsRequired)     throw new XMPPException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  setTrafficClass();
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}",0.9858908727681358
103258,"/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    supportedFeatures.clear();
    this.clearRegistrationStateChangeListener();
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null)     protocolIconPath=""String_Node_Str"";
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(""String_Node_Str"");
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    addSupportedOperationSet(OperationSetPersistentPresence.class,persistentPresence);
    addSupportedOperationSet(OperationSetPresence.class,persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue == null || !keepAliveStrValue.equalsIgnoreCase(Boolean.FALSE.toString()))     new KeepAliveManager(this);
    addSupportedOperationSet(OperationSetBasicInstantMessaging.class,basicInstantMessaging);
    addSupportedOperationSet(OperationSetExtendedAuthorizations.class,new OperationSetExtendedAuthorizationsJabberImpl(this,persistentPresence));
    addSupportedOperationSet(OperationSetWhiteboarding.class,new OperationSetWhiteboardingJabberImpl(this));
    addSupportedOperationSet(OperationSetTypingNotifications.class,new OperationSetTypingNotificationsJabberImpl(this));
    addSupportedOperationSet(OperationSetMultiUserChat.class,new OperationSetMultiUserChatJabberImpl(this));
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    addSupportedOperationSet(OperationSetServerStoredContactInfo.class,new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver));
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    addSupportedOperationSet(OperationSetServerStoredAccountInfo.class,accountInfo);
    addSupportedOperationSet(OperationSetAvatar.class,new OperationSetAvatarJabberImpl(this,accountInfo));
    addSupportedOperationSet(OperationSetFileTransfer.class,new OperationSetFileTransferJabberImpl(this));
    addSupportedOperationSet(OperationSetInstantMessageTransform.class,new OperationSetInstantMessageTransformImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    addSupportedOperationSet(OperationSetThumbnailedFileFactory.class,new OperationSetThumbnailedFileFactoryImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);
    ProviderManager providerManager=ProviderManager.getInstance();
    providerManager.addIQProvider(JingleIQ.ELEMENT_NAME,JingleIQ.NAMESPACE,new JingleIQProvider());
    providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,InputEvtIQ.NAMESPACE,new InputEvtIQProvider());
    providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,CoinIQ.NAMESPACE,new CoinIQProvider());
    supportedFeatures.add(URN_XMPP_JINGLE_COIN);
    providerManager.addIQProvider(SessionIQ.ELEMENT_NAME,SessionIQ.NAMESPACE,new SessionIQProvider());
    providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,JingleInfoQueryIQ.NAMESPACE,new JingleInfoQueryIQProvider());
    boolean isCallingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED,false);
    boolean isCallingDisabledForAccount=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,false);
    if (!isCallingDisabled && !isCallingDisabledForAccount) {
      OperationSetBasicTelephonyJabberImpl basicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      addSupportedOperationSet(OperationSetAdvancedTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetBasicTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetSecureZrtpTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetVideoTelephony.class,new OperationSetVideoTelephonyJabberImpl(basicTelephony));
      addSupportedOperationSet(OperationSetTelephonyConferencing.class,new OperationSetTelephonyConferencingJabberImpl(this));
      addJingleFeatures();
      boolean isDesktopStreamingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED,false);
      boolean isAccountDesktopStreamingDisabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,false);
      if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {
        addSupportedOperationSet(OperationSetDesktopStreaming.class,new OperationSetDesktopStreamingJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingServer.class,new OperationSetDesktopSharingServerJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingClient.class,new OperationSetDesktopSharingClientJabberImpl(this));
        supportedFeatures.add(InputEvtIQ.NAMESPACE);
      }
    }
    opsetContactCapabilities=new OperationSetContactCapabilitiesJabberImpl(this);
    if (discoveryManager != null)     opsetContactCapabilities.setDiscoveryManager(discoveryManager);
    addSupportedOperationSet(OperationSetContactCapabilities.class,opsetContactCapabilities);
    addSupportedOperationSet(OperationSetGenericNotifications.class,new OperationSetGenericNotificationsJabberImpl(this));
    isInitialized=true;
  }
}","/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    supportedFeatures.clear();
    this.clearRegistrationStateChangeListener();
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null)     protocolIconPath=""String_Node_Str"";
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(ProtocolProviderFactory.KEEP_ALIVE_METHOD);
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    addSupportedOperationSet(OperationSetPersistentPresence.class,persistentPresence);
    addSupportedOperationSet(OperationSetPresence.class,persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue == null || keepAliveStrValue.equalsIgnoreCase(""String_Node_Str""))     new KeepAliveManager(this);
    addSupportedOperationSet(OperationSetBasicInstantMessaging.class,basicInstantMessaging);
    addSupportedOperationSet(OperationSetExtendedAuthorizations.class,new OperationSetExtendedAuthorizationsJabberImpl(this,persistentPresence));
    addSupportedOperationSet(OperationSetWhiteboarding.class,new OperationSetWhiteboardingJabberImpl(this));
    addSupportedOperationSet(OperationSetTypingNotifications.class,new OperationSetTypingNotificationsJabberImpl(this));
    addSupportedOperationSet(OperationSetMultiUserChat.class,new OperationSetMultiUserChatJabberImpl(this));
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    addSupportedOperationSet(OperationSetServerStoredContactInfo.class,new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver));
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    addSupportedOperationSet(OperationSetServerStoredAccountInfo.class,accountInfo);
    addSupportedOperationSet(OperationSetAvatar.class,new OperationSetAvatarJabberImpl(this,accountInfo));
    addSupportedOperationSet(OperationSetFileTransfer.class,new OperationSetFileTransferJabberImpl(this));
    addSupportedOperationSet(OperationSetInstantMessageTransform.class,new OperationSetInstantMessageTransformImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    addSupportedOperationSet(OperationSetThumbnailedFileFactory.class,new OperationSetThumbnailedFileFactoryImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);
    ProviderManager providerManager=ProviderManager.getInstance();
    providerManager.addIQProvider(JingleIQ.ELEMENT_NAME,JingleIQ.NAMESPACE,new JingleIQProvider());
    providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,InputEvtIQ.NAMESPACE,new InputEvtIQProvider());
    providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,CoinIQ.NAMESPACE,new CoinIQProvider());
    supportedFeatures.add(URN_XMPP_JINGLE_COIN);
    providerManager.addIQProvider(SessionIQ.ELEMENT_NAME,SessionIQ.NAMESPACE,new SessionIQProvider());
    providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,JingleInfoQueryIQ.NAMESPACE,new JingleInfoQueryIQProvider());
    boolean isCallingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED,false);
    boolean isCallingDisabledForAccount=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,false);
    if (!isCallingDisabled && !isCallingDisabledForAccount) {
      OperationSetBasicTelephonyJabberImpl basicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      addSupportedOperationSet(OperationSetAdvancedTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetBasicTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetSecureZrtpTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetVideoTelephony.class,new OperationSetVideoTelephonyJabberImpl(basicTelephony));
      addSupportedOperationSet(OperationSetTelephonyConferencing.class,new OperationSetTelephonyConferencingJabberImpl(this));
      addJingleFeatures();
      boolean isDesktopStreamingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED,false);
      boolean isAccountDesktopStreamingDisabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,false);
      if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {
        addSupportedOperationSet(OperationSetDesktopStreaming.class,new OperationSetDesktopStreamingJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingServer.class,new OperationSetDesktopSharingServerJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingClient.class,new OperationSetDesktopSharingClientJabberImpl(this));
        supportedFeatures.add(InputEvtIQ.NAMESPACE);
      }
    }
    opsetContactCapabilities=new OperationSetContactCapabilitiesJabberImpl(this);
    if (discoveryManager != null)     opsetContactCapabilities.setDiscoveryManager(discoveryManager);
    addSupportedOperationSet(OperationSetContactCapabilities.class,opsetContactCapabilities);
    addSupportedOperationSet(OperationSetGenericNotifications.class,new OperationSetGenericNotificationsJabberImpl(this));
    isInitialized=true;
  }
}",0.992626728110599
103259,"/** 
 * Sets a reference to the currently active and valid instance of roster that this list is to use for retrieving server stored information
 */
void init(){
  this.roster=jabberProvider.getConnection().getRoster();
  initRoster();
  rosterChangeListener=new ChangeListener();
  this.roster.addRosterListener(rosterChangeListener);
}","/** 
 * Sets a reference to the currently active and valid instance of roster that this list is to use for retrieving server stored information
 */
void init(){
  this.roster=jabberProvider.getConnection().getRoster();
  this.roster.setSubscriptionMode(Roster.SubscriptionMode.manual);
  initRoster();
  rosterChangeListener=new ChangeListener();
  this.roster.addRosterListener(rosterChangeListener);
}",0.8958051420838972
103260,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getConnection().removePacketListener(this);
    parentProvider.getConnection().addPacketListener(this,null);
    keepAliveSendTask=new KeepAliveSendTask();
    keepAliveCheckInterval=2 * SmackConfiguration.getKeepAliveInterval();
    if (keepAliveCheckInterval == 0)     keepAliveCheckInterval=60000;
    keepAliveTimer=new Timer(""String_Node_Str"" + parentProvider.getAccountID() + ""String_Node_Str"",true);
    keepAliveTimer.scheduleAtFixedRate(keepAliveSendTask,keepAliveCheckInterval,keepAliveCheckInterval);
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.CONNECTION_FAILED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED) {
    if (parentProvider.getConnection() != null)     parentProvider.getConnection().removePacketListener(this);
    if (keepAliveSendTask != null) {
      keepAliveSendTask.cancel();
      keepAliveSendTask=null;
    }
    if (keepAliveTimer != null) {
      keepAliveTimer.cancel();
      keepAliveTimer=null;
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getConnection().removePacketListener(this);
    parentProvider.getConnection().addPacketListener(this,null);
    keepAliveSendTask=new KeepAliveSendTask();
    keepAliveCheckInterval=SmackConfiguration.getKeepAliveInterval();
    if (keepAliveCheckInterval == 0)     keepAliveCheckInterval=30000;
    keepAliveTimer=new Timer(""String_Node_Str"" + parentProvider.getAccountID() + ""String_Node_Str"",true);
    keepAliveTimer.scheduleAtFixedRate(keepAliveSendTask,keepAliveCheckInterval,keepAliveCheckInterval);
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.CONNECTION_FAILED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED) {
    if (parentProvider.getConnection() != null)     parentProvider.getConnection().removePacketListener(this);
    if (keepAliveSendTask != null) {
      keepAliveSendTask.cancel();
      keepAliveSendTask=null;
    }
    if (keepAliveTimer != null) {
      keepAliveTimer.cancel();
      keepAliveTimer=null;
    }
  }
}",0.9980494148244472
103261,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState() == RegistrationState.UNREGISTERING || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    if (keepAliveTimer != null) {
      keepAliveTimer.cancel();
      keepAliveTimer=null;
    }
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    String keepAliveMethod=provider.getAccountID().getAccountPropertyString(ProtocolProviderServiceSipImpl.KEEP_ALIVE_METHOD);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + keepAliveMethod);
    if (keepAliveMethod != null && !keepAliveMethod.equalsIgnoreCase(""String_Node_Str""))     return;
    int keepAliveInterval=provider.getAccountID().getAccountPropertyInt(ProtocolProviderServiceSipImpl.KEEP_ALIVE_INTERVAL,-1);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + keepAliveInterval);
    if (keepAliveInterval > 0 && !provider.getRegistrarConnection().isRegistrarless()) {
      if (keepAliveTimer == null)       keepAliveTimer=new Timer();
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      keepAliveTimer.schedule(new KeepAliveTask(),0,keepAliveInterval * 1000);
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState() == RegistrationState.UNREGISTERING || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    if (keepAliveTimer != null) {
      keepAliveTimer.cancel();
      keepAliveTimer=null;
    }
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    String keepAliveMethod=provider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.KEEP_ALIVE_METHOD);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + keepAliveMethod);
    if (keepAliveMethod != null && !keepAliveMethod.equalsIgnoreCase(""String_Node_Str""))     return;
    int keepAliveInterval=provider.getAccountID().getAccountPropertyInt(ProtocolProviderFactory.KEEP_ALIVE_INTERVAL,-1);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + keepAliveInterval);
    if (keepAliveInterval > 0 && !provider.getRegistrarConnection().isRegistrarless()) {
      if (keepAliveTimer == null)       keepAliveTimer=new Timer();
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      keepAliveTimer.schedule(new KeepAliveTask(),0,keepAliveInterval * 1000);
    }
  }
}",0.9870769230769232
103262,"/** 
 * Creates an instance of <tt>ConnectionPanel</tt> by specifying the parent wizard, where it's contained.
 * @param parentForm the parent form
 */
public ConnectionPanel(JabberAccountRegistrationForm parentForm){
  super(new BorderLayout());
  this.parentForm=parentForm;
  parentForm.addValidatingPanel(this);
  mainPanel.setLayout(new BoxLayout(mainPanel,BoxLayout.Y_AXIS));
  portField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent evt){
    }
    public void insertUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
    public void removeUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
  }
);
  priorityField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent evt){
    }
    public void insertUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
    public void removeUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
  }
);
  labelsAdvOpPanel.add(serverLabel);
  labelsAdvOpPanel.add(portLabel);
  valuesAdvOpPanel.add(serverField);
  valuesAdvOpPanel.add(portField);
  JPanel checkBoxesPanel=new TransparentPanel(new GridLayout(0,1,10,10));
  checkBoxesPanel.add(sendKeepAliveBox);
  checkBoxesPanel.add(gmailNotificationsBox);
  checkBoxesPanel.add(googleContactsBox);
  checkBoxesPanel.add(allowNonSecureBox);
  final JPanel resourcePanel=new TransparentPanel(new BorderLayout(10,10));
  resourcePanel.setBorder(BorderFactory.createTitledBorder(Resources.getString(""String_Node_Str"")));
  resourcePanel.add(autoGenerateResource,BorderLayout.NORTH);
  JPanel resSubPanelLabel=new TransparentPanel(new GridLayout(0,1,10,10));
  JPanel resSubPanelValue=new TransparentPanel(new GridLayout(0,1,10,10));
  resSubPanelLabel.add(resourceLabel);
  resSubPanelLabel.add(priorityLabel);
  resSubPanelValue.add(resourceField);
  resSubPanelValue.add(priorityField);
  resourcePanel.add(resSubPanelLabel,BorderLayout.WEST);
  resourcePanel.add(resSubPanelValue,BorderLayout.CENTER);
  googleContactsBox.setSelected(true);
  advancedOpPanel.add(checkBoxesPanel,BorderLayout.NORTH);
  advancedOpPanel.add(labelsAdvOpPanel,BorderLayout.WEST);
  advancedOpPanel.add(valuesAdvOpPanel,BorderLayout.CENTER);
  advancedOpPanel.add(resourcePanel,BorderLayout.SOUTH);
  if (autoGenerateResource.isSelected()) {
    resourceField.setEnabled(false);
  }
  autoGenerateResource.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      resourceField.setEnabled(!autoGenerateResource.isSelected());
    }
  }
);
  mainPanel.add(advancedOpPanel);
  String serverAddress=parentForm.getServerAddress();
  if (serverAddress != null)   serverField.setText(serverAddress);
  add(mainPanel,BorderLayout.NORTH);
}","/** 
 * Creates an instance of <tt>ConnectionPanel</tt> by specifying the parent wizard, where it's contained.
 * @param parentForm the parent form
 */
public ConnectionPanel(JabberAccountRegistrationForm parentForm){
  super(new BorderLayout());
  this.parentForm=parentForm;
  parentForm.addValidatingPanel(this);
  mainPanel.setLayout(new BoxLayout(mainPanel,BoxLayout.Y_AXIS));
  portField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent evt){
    }
    public void insertUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
    public void removeUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
  }
);
  priorityField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent evt){
    }
    public void insertUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
    public void removeUpdate(    DocumentEvent evt){
      setNextButtonAccordingToPortAndPriority();
    }
  }
);
  labelsAdvOpPanel.add(serverLabel);
  labelsAdvOpPanel.add(portLabel);
  valuesAdvOpPanel.add(serverField);
  valuesAdvOpPanel.add(portField);
  JPanel checkBoxesPanel=new TransparentPanel(new GridLayout(0,1,10,10));
  checkBoxesPanel.add(gmailNotificationsBox);
  checkBoxesPanel.add(googleContactsBox);
  checkBoxesPanel.add(allowNonSecureBox);
  final JPanel resourcePanel=new TransparentPanel(new BorderLayout(10,10));
  resourcePanel.setBorder(BorderFactory.createTitledBorder(Resources.getString(""String_Node_Str"")));
  resourcePanel.add(autoGenerateResource,BorderLayout.NORTH);
  JPanel resSubPanelLabel=new TransparentPanel(new GridLayout(0,1,10,10));
  JPanel resSubPanelValue=new TransparentPanel(new GridLayout(0,1,10,10));
  resSubPanelLabel.add(resourceLabel);
  resSubPanelLabel.add(priorityLabel);
  resSubPanelValue.add(resourceField);
  resSubPanelValue.add(priorityField);
  resourcePanel.add(resSubPanelLabel,BorderLayout.WEST);
  resourcePanel.add(resSubPanelValue,BorderLayout.CENTER);
  googleContactsBox.setSelected(true);
  advancedOpPanel.add(checkBoxesPanel,BorderLayout.NORTH);
  advancedOpPanel.add(labelsAdvOpPanel,BorderLayout.WEST);
  advancedOpPanel.add(valuesAdvOpPanel,BorderLayout.CENTER);
  advancedOpPanel.add(resourcePanel,BorderLayout.SOUTH);
  if (autoGenerateResource.isSelected()) {
    resourceField.setEnabled(false);
  }
  autoGenerateResource.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      resourceField.setEnabled(!autoGenerateResource.isSelected());
    }
  }
);
  mainPanel.add(advancedOpPanel);
  String serverAddress=parentForm.getServerAddress();
  if (serverAddress != null)   serverField.setText(serverAddress);
  add(mainPanel,BorderLayout.NORTH);
}",0.9928558982401116
103263,"/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException if the operation didn't succeed
 */
protected ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + userName);
  }
  Hashtable<String,String> accountProperties=new Hashtable<String,String>();
  accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,Boolean.toString(isPreferredProtocol()));
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.isSendKeepAlive()));
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.isGmailNotificationEnabled()));
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.isGoogleContactsEnabled()));
  String serverName=null;
  if (registration.getServerAddress() != null && registration.getServerAddress().length() > 0) {
    serverName=registration.getServerAddress();
    if (userName.indexOf(serverName) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
 else {
    serverName=getServerFromUserName(userName);
  }
  if (serverName == null || serverName.length() <= 0)   throw new OperationFailedException(""String_Node_Str"" + userName + ""String_Node_Str"",OperationFailedException.SERVER_NOT_SPECIFIED);
  if (userName.indexOf('@') < 0 && registration.getDefaultUserSufix() != null)   userName=userName + '@' + registration.getDefaultUserSufix();
  if (registration.getOverridePhoneSuffix() != null) {
    accountProperties.put(""String_Node_Str"",registration.getOverridePhoneSuffix());
  }
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.getBypassGtalkCaps()));
  if (registration.getTelephonyDomainBypassCaps() != null) {
    accountProperties.put(""String_Node_Str"",registration.getTelephonyDomainBypassCaps());
  }
  accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverName);
  String smsServerAddress=registration.getSmsServerAddress();
  if (smsServerAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SMS_SERVER_ADDRESS,smsServerAddress);
  }
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,String.valueOf(registration.getPort()));
  accountProperties.put(ProtocolProviderFactory.AUTO_GENERATE_RESOURCE,String.valueOf(registration.isResourceAutogenerated()));
  accountProperties.put(ProtocolProviderFactory.RESOURCE,registration.getResource());
  accountProperties.put(ProtocolProviderFactory.RESOURCE_PRIORITY,String.valueOf(registration.getPriority()));
  accountProperties.put(ProtocolProviderFactory.IS_USE_ICE,String.valueOf(registration.isUseIce()));
  accountProperties.put(ProtocolProviderFactory.IS_USE_GOOGLE_ICE,String.valueOf(registration.isUseGoogleIce()));
  accountProperties.put(ProtocolProviderFactory.AUTO_DISCOVER_STUN,String.valueOf(registration.isAutoDiscoverStun()));
  accountProperties.put(ProtocolProviderFactory.USE_DEFAULT_STUN_SERVER,String.valueOf(registration.isUseDefaultStunServer()));
  String accountDisplayName=registration.getAccountDisplayName();
  if (accountDisplayName != null && accountDisplayName.length() > 0)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_DISPLAY_NAME,accountDisplayName);
  List<StunServerDescriptor> stunServers=registration.getAdditionalStunServers();
  int serverIndex=-1;
  for (  StunServerDescriptor stunServer : stunServers) {
    serverIndex++;
    stunServer.storeDescriptor(accountProperties,ProtocolProviderFactory.STUN_PREFIX + serverIndex);
  }
  accountProperties.put(ProtocolProviderFactory.IS_USE_JINGLE_NODES,String.valueOf(registration.isUseJingleNodes()));
  accountProperties.put(ProtocolProviderFactory.AUTO_DISCOVER_JINGLE_NODES,String.valueOf(registration.isAutoDiscoverJingleNodes()));
  List<JingleNodeDescriptor> jnRelays=registration.getAdditionalJingleNodes();
  serverIndex=-1;
  for (  JingleNodeDescriptor jnRelay : jnRelays) {
    serverIndex++;
    jnRelay.storeDescriptor(accountProperties,JingleNodeDescriptor.JN_PREFIX + serverIndex);
  }
  accountProperties.put(ProtocolProviderFactory.IS_USE_UPNP,String.valueOf(registration.isUseUPNP()));
  accountProperties.put(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,String.valueOf(registration.isAllowNonSecure()));
  if (isModification()) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + userName + ""String_Node_Str""+ accountProperties);
    }
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)JabberAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT);
  }
catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Throwable exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}","/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException if the operation didn't succeed
 */
protected ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + userName);
  }
  Hashtable<String,String> accountProperties=new Hashtable<String,String>();
  accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,Boolean.toString(isPreferredProtocol()));
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.isGmailNotificationEnabled()));
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.isGoogleContactsEnabled()));
  String serverName=null;
  if (registration.getServerAddress() != null && registration.getServerAddress().length() > 0) {
    serverName=registration.getServerAddress();
    if (userName.indexOf(serverName) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
 else {
    serverName=getServerFromUserName(userName);
  }
  if (serverName == null || serverName.length() <= 0)   throw new OperationFailedException(""String_Node_Str"" + userName + ""String_Node_Str"",OperationFailedException.SERVER_NOT_SPECIFIED);
  if (userName.indexOf('@') < 0 && registration.getDefaultUserSufix() != null)   userName=userName + '@' + registration.getDefaultUserSufix();
  if (registration.getOverridePhoneSuffix() != null) {
    accountProperties.put(""String_Node_Str"",registration.getOverridePhoneSuffix());
  }
  accountProperties.put(""String_Node_Str"",String.valueOf(registration.getBypassGtalkCaps()));
  if (registration.getTelephonyDomainBypassCaps() != null) {
    accountProperties.put(""String_Node_Str"",registration.getTelephonyDomainBypassCaps());
  }
  accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverName);
  String smsServerAddress=registration.getSmsServerAddress();
  if (smsServerAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SMS_SERVER_ADDRESS,smsServerAddress);
  }
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,String.valueOf(registration.getPort()));
  accountProperties.put(ProtocolProviderFactory.AUTO_GENERATE_RESOURCE,String.valueOf(registration.isResourceAutogenerated()));
  accountProperties.put(ProtocolProviderFactory.RESOURCE,registration.getResource());
  accountProperties.put(ProtocolProviderFactory.RESOURCE_PRIORITY,String.valueOf(registration.getPriority()));
  accountProperties.put(ProtocolProviderFactory.IS_USE_ICE,String.valueOf(registration.isUseIce()));
  accountProperties.put(ProtocolProviderFactory.IS_USE_GOOGLE_ICE,String.valueOf(registration.isUseGoogleIce()));
  accountProperties.put(ProtocolProviderFactory.AUTO_DISCOVER_STUN,String.valueOf(registration.isAutoDiscoverStun()));
  accountProperties.put(ProtocolProviderFactory.USE_DEFAULT_STUN_SERVER,String.valueOf(registration.isUseDefaultStunServer()));
  String accountDisplayName=registration.getAccountDisplayName();
  if (accountDisplayName != null && accountDisplayName.length() > 0)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_DISPLAY_NAME,accountDisplayName);
  List<StunServerDescriptor> stunServers=registration.getAdditionalStunServers();
  int serverIndex=-1;
  for (  StunServerDescriptor stunServer : stunServers) {
    serverIndex++;
    stunServer.storeDescriptor(accountProperties,ProtocolProviderFactory.STUN_PREFIX + serverIndex);
  }
  accountProperties.put(ProtocolProviderFactory.IS_USE_JINGLE_NODES,String.valueOf(registration.isUseJingleNodes()));
  accountProperties.put(ProtocolProviderFactory.AUTO_DISCOVER_JINGLE_NODES,String.valueOf(registration.isAutoDiscoverJingleNodes()));
  List<JingleNodeDescriptor> jnRelays=registration.getAdditionalJingleNodes();
  serverIndex=-1;
  for (  JingleNodeDescriptor jnRelay : jnRelays) {
    serverIndex++;
    jnRelay.storeDescriptor(accountProperties,JingleNodeDescriptor.JN_PREFIX + serverIndex);
  }
  accountProperties.put(ProtocolProviderFactory.IS_USE_UPNP,String.valueOf(registration.isUseUPNP()));
  accountProperties.put(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,String.valueOf(registration.isAllowNonSecure()));
  if (isModification()) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + userName + ""String_Node_Str""+ accountProperties);
    }
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)JabberAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT);
  }
catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Throwable exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}",0.9926226185650588
103264,"/** 
 * Loads the account with the given identifier.
 * @param accountID the account identifier
 */
public void loadAccount(AccountID accountID){
  String password=SIPAccRegWizzActivator.getSIPProtocolProviderFactory().loadPassword(accountID);
  String serverAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  String displayName=accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);
  String authName=accountID.getAccountPropertyString(ProtocolProviderFactory.AUTHORIZATION_NAME);
  String serverPort=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED,false);
  boolean forceP2P=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE,false);
  String clientTlsCertificateId=accountID.getAccountPropertyString(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE);
  boolean proxyAutoConfigureEnabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false);
  String pollingPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=accountID.getAccountPropertyString(""String_Node_Str"");
  String keepAliveInterval=accountID.getAccountPropertyString(""String_Node_Str"");
  String voicemailURI=accountID.getAccountPropertyString(ProtocolProviderFactory.VOICEMAIL_URI);
  boolean xCapEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean xivoEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean isServerOverridden=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,false);
  connectionPanel.setServerOverridden(isServerOverridden);
  accountPanel.setUserIDEnabled(false);
  accountPanel.setUserID((serverAddress == null) ? accountID.getUserID() : accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID));
  if (password != null) {
    accountPanel.setPassword(password);
    accountPanel.setRememberPassword(true);
  }
 else {
    accountPanel.setRememberPassword(false);
  }
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setServerEnabled(isServerOverridden);
  if (displayName != null && displayName.length() > 0)   accountPanel.setDisplayName(displayName);
  if (authName != null && authName.length() > 0)   connectionPanel.setAuthenticationName(authName);
  connectionPanel.setCertificateId(clientTlsCertificateId);
  connectionPanel.enablesProxyAutoConfigure(proxyAutoConfigureEnabled);
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setProxy(proxyAddress);
  connectionPanel.setSelectedTransport(preferredTransport);
  connectionPanel.setProxyPort(proxyPort);
  securityPanel.loadAccount(accountID);
  presencePanel.setPresenceEnabled(enablePresence);
  presencePanel.setForcePeerToPeerMode(forceP2P);
  presencePanel.setPollPeriod(pollingPeriod);
  presencePanel.setSubscriptionExpiration(subscriptionPeriod);
  if (!enablePresence) {
    presencePanel.setPresenceOptionsEnabled(enablePresence);
  }
  connectionPanel.setKeepAliveMethod(keepAliveMethod);
  connectionPanel.setKeepAliveInterval(keepAliveInterval);
  if (voicemailURI != null && voicemailURI.length() > 0)   connectionPanel.setVoicemailURI(voicemailURI);
  if (xCapEnable) {
    boolean xCapUseSipCredentials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
    presencePanel.setXCapEnable(xCapEnable);
    presencePanel.setClistOptionEnableEnabled(xCapEnable);
    presencePanel.setClistOptionUseSipCredentials(xCapUseSipCredentials);
    presencePanel.setClistOptionUseSipCredentialsEnabled(xCapUseSipCredentials);
    presencePanel.setClistOptionServerUri(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionUser(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionPassword(accountID.getAccountPropertyString(""String_Node_Str""));
  }
 else   if (xivoEnable) {
    boolean xCapUseSipCredentials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
    presencePanel.setXiVOEnable(xivoEnable);
    presencePanel.setClistOptionEnableEnabled(xivoEnable);
    presencePanel.setClistOptionUseSipCredentials(xCapUseSipCredentials);
    presencePanel.setClistOptionUseSipCredentialsEnabled(xCapUseSipCredentials);
    presencePanel.setClistOptionServerUri(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionUser(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionPassword(accountID.getAccountPropertyString(""String_Node_Str""));
  }
}","/** 
 * Loads the account with the given identifier.
 * @param accountID the account identifier
 */
public void loadAccount(AccountID accountID){
  String password=SIPAccRegWizzActivator.getSIPProtocolProviderFactory().loadPassword(accountID);
  String serverAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  String displayName=accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);
  String authName=accountID.getAccountPropertyString(ProtocolProviderFactory.AUTHORIZATION_NAME);
  String serverPort=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED,false);
  boolean forceP2P=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE,false);
  String clientTlsCertificateId=accountID.getAccountPropertyString(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE);
  boolean proxyAutoConfigureEnabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false);
  String pollingPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=accountID.getAccountPropertyString(ProtocolProviderFactory.KEEP_ALIVE_METHOD);
  String keepAliveInterval=accountID.getAccountPropertyString(ProtocolProviderFactory.KEEP_ALIVE_INTERVAL);
  String voicemailURI=accountID.getAccountPropertyString(ProtocolProviderFactory.VOICEMAIL_URI);
  boolean xCapEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean xivoEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean isServerOverridden=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,false);
  connectionPanel.setServerOverridden(isServerOverridden);
  accountPanel.setUserIDEnabled(false);
  accountPanel.setUserID((serverAddress == null) ? accountID.getUserID() : accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID));
  if (password != null) {
    accountPanel.setPassword(password);
    accountPanel.setRememberPassword(true);
  }
 else {
    accountPanel.setRememberPassword(false);
  }
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setServerEnabled(isServerOverridden);
  if (displayName != null && displayName.length() > 0)   accountPanel.setDisplayName(displayName);
  if (authName != null && authName.length() > 0)   connectionPanel.setAuthenticationName(authName);
  connectionPanel.setCertificateId(clientTlsCertificateId);
  connectionPanel.enablesProxyAutoConfigure(proxyAutoConfigureEnabled);
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setProxy(proxyAddress);
  connectionPanel.setSelectedTransport(preferredTransport);
  connectionPanel.setProxyPort(proxyPort);
  securityPanel.loadAccount(accountID);
  presencePanel.setPresenceEnabled(enablePresence);
  presencePanel.setForcePeerToPeerMode(forceP2P);
  presencePanel.setPollPeriod(pollingPeriod);
  presencePanel.setSubscriptionExpiration(subscriptionPeriod);
  if (!enablePresence) {
    presencePanel.setPresenceOptionsEnabled(enablePresence);
  }
  connectionPanel.setKeepAliveMethod(keepAliveMethod);
  connectionPanel.setKeepAliveInterval(keepAliveInterval);
  if (voicemailURI != null && voicemailURI.length() > 0)   connectionPanel.setVoicemailURI(voicemailURI);
  if (xCapEnable) {
    boolean xCapUseSipCredentials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
    presencePanel.setXCapEnable(xCapEnable);
    presencePanel.setClistOptionEnableEnabled(xCapEnable);
    presencePanel.setClistOptionUseSipCredentials(xCapUseSipCredentials);
    presencePanel.setClistOptionUseSipCredentialsEnabled(xCapUseSipCredentials);
    presencePanel.setClistOptionServerUri(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionUser(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionPassword(accountID.getAccountPropertyString(""String_Node_Str""));
  }
 else   if (xivoEnable) {
    boolean xCapUseSipCredentials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
    presencePanel.setXiVOEnable(xivoEnable);
    presencePanel.setClistOptionEnableEnabled(xivoEnable);
    presencePanel.setClistOptionUseSipCredentials(xCapUseSipCredentials);
    presencePanel.setClistOptionUseSipCredentialsEnabled(xCapUseSipCredentials);
    presencePanel.setClistOptionServerUri(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionUser(accountID.getAccountPropertyString(""String_Node_Str""));
    presencePanel.setClistOptionPassword(accountID.getAccountPropertyString(""String_Node_Str""));
  }
}",0.9760878087024696
103265,"/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException problem installing account
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  HashMap<String,String> accountProperties=new HashMap<String,String>();
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
 else {
    registration.setPassword(null);
  }
  String serverAddress=null;
  String serverFromUsername=SIPAccountRegistrationForm.getServerFromUserName(userName);
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
  if (serverFromUsername == null && registration.getDefaultDomain() != null) {
    userName=userName + ""String_Node_Str"" + registration.getDefaultDomain();
    if (serverAddress == null)     serverAddress=registration.getDefaultDomain();
  }
 else   if (serverAddress == null && serverFromUsername != null) {
    serverAddress=serverFromUsername;
  }
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
    if (userName.indexOf(serverAddress) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
  accountProperties.put(ProtocolProviderFactory.DISPLAY_NAME,registration.getDisplayName());
  accountProperties.put(ProtocolProviderFactory.AUTHORIZATION_NAME,registration.getAuthorizationName());
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  if (registration.isProxyAutoConfigure()) {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.TRUE.toString());
  }
 else {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.FALSE.toString());
    accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,registration.getProxy());
    accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
    accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  }
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  }
 else {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.TRUE.toString());
  }
  accountProperties.put(ProtocolProviderFactory.DEFAULT_ENCRYPTION,Boolean.toString(registration.isDefaultEncryption()));
  accountProperties.put(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,Boolean.toString(registration.isSipZrtpAttribute()));
  accountProperties.put(ProtocolProviderFactory.SAVP_OPTION,Integer.toString(registration.getSavpOption()));
  accountProperties.put(ProtocolProviderFactory.SDES_ENABLED,Boolean.toString(registration.isSDesEnabled()));
  accountProperties.put(ProtocolProviderFactory.SDES_CIPHER_SUITES,registration.getSDesCipherSuites());
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  accountProperties.put(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE,registration.getTlsClientCertificate());
  if (registration.getKeepAliveMethod() != null)   accountProperties.put(""String_Node_Str"",registration.getKeepAliveMethod());
 else   accountProperties.put(""String_Node_Str"",registration.getDefaultKeepAliveMethod());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveInterval());
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXiVOEnable()));
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapEnable()));
  if (registration.isXCapEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isClistOptionUseSipCredentials()));
    if (registration.getClistOptionServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionServerUri());
    }
    if (registration.getClistOptionUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionUser());
    }
    if (registration.getClistOptionPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionPassword());
    }
  }
 else   if (registration.isXiVOEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isClistOptionUseSipCredentials()));
    if (registration.getClistOptionServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionServerUri());
    }
    if (registration.getClistOptionUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionUser());
    }
    if (registration.getClistOptionPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionPassword());
    }
  }
  if (!StringUtils.isNullOrEmpty(registration.getVoicemailURI(),true))   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,registration.getVoicemailURI());
 else   if (isModification())   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,""String_Node_Str"");
  if (isModification()) {
    accountProperties.put(ProtocolProviderFactory.USER_ID,userName);
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Exception exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(exc.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}","/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException problem installing account
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  HashMap<String,String> accountProperties=new HashMap<String,String>();
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
 else {
    registration.setPassword(null);
  }
  String serverAddress=null;
  String serverFromUsername=SIPAccountRegistrationForm.getServerFromUserName(userName);
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
  if (serverFromUsername == null && registration.getDefaultDomain() != null) {
    userName=userName + ""String_Node_Str"" + registration.getDefaultDomain();
    if (serverAddress == null)     serverAddress=registration.getDefaultDomain();
  }
 else   if (serverAddress == null && serverFromUsername != null) {
    serverAddress=serverFromUsername;
  }
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
    if (userName.indexOf(serverAddress) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
  accountProperties.put(ProtocolProviderFactory.DISPLAY_NAME,registration.getDisplayName());
  accountProperties.put(ProtocolProviderFactory.AUTHORIZATION_NAME,registration.getAuthorizationName());
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  if (registration.isProxyAutoConfigure()) {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.TRUE.toString());
  }
 else {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.FALSE.toString());
    accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,registration.getProxy());
    accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
    accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  }
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  }
 else {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.TRUE.toString());
  }
  accountProperties.put(ProtocolProviderFactory.DEFAULT_ENCRYPTION,Boolean.toString(registration.isDefaultEncryption()));
  accountProperties.put(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,Boolean.toString(registration.isSipZrtpAttribute()));
  accountProperties.put(ProtocolProviderFactory.SAVP_OPTION,Integer.toString(registration.getSavpOption()));
  accountProperties.put(ProtocolProviderFactory.SDES_ENABLED,Boolean.toString(registration.isSDesEnabled()));
  accountProperties.put(ProtocolProviderFactory.SDES_CIPHER_SUITES,registration.getSDesCipherSuites());
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  accountProperties.put(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE,registration.getTlsClientCertificate());
  if (registration.getKeepAliveMethod() != null)   accountProperties.put(ProtocolProviderFactory.KEEP_ALIVE_METHOD,registration.getKeepAliveMethod());
 else   accountProperties.put(ProtocolProviderFactory.KEEP_ALIVE_METHOD,registration.getDefaultKeepAliveMethod());
  accountProperties.put(ProtocolProviderFactory.KEEP_ALIVE_INTERVAL,registration.getKeepAliveInterval());
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXiVOEnable()));
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapEnable()));
  if (registration.isXCapEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isClistOptionUseSipCredentials()));
    if (registration.getClistOptionServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionServerUri());
    }
    if (registration.getClistOptionUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionUser());
    }
    if (registration.getClistOptionPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionPassword());
    }
  }
 else   if (registration.isXiVOEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isClistOptionUseSipCredentials()));
    if (registration.getClistOptionServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionServerUri());
    }
    if (registration.getClistOptionUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionUser());
    }
    if (registration.getClistOptionPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getClistOptionPassword());
    }
  }
  if (!StringUtils.isNullOrEmpty(registration.getVoicemailURI(),true))   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,registration.getVoicemailURI());
 else   if (isModification())   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,""String_Node_Str"");
  if (isModification()) {
    accountProperties.put(ProtocolProviderFactory.USER_ID,userName);
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    setModification(false);
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Exception exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(exc.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}",0.968068198237249
103266,"/** 
 * Creates a <tt>CallPeerGTalkImpl</tt> from <tt>calleeJID</tt> and sends them <tt>initiate</tt> IQ request.
 * @param calleeJID the party that we would like to invite to this call.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>initiate</tt> {@link SessionIQ} which is to init this <tt>CallJabberImpl</tt>
 * @return the newly created <tt>Call</tt> corresponding to<tt>calleeJID</tt>. All following state change events will be delivered through this call peer.
 * @throws OperationFailedException  with the corresponding code if we failto create the call.
 */
public CallPeerGTalkImpl initiateGTalkSession(String calleeJID,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  CallPeerGTalkImpl callPeer=new CallPeerGTalkImpl(calleeJID,this);
  addCallPeer(callPeer);
  callPeer.setState(CallPeerState.INITIATING_CALL);
  if (getCallPeerCount() == 1)   parentOpSet.fireCallEvent(CallEvent.CALL_INITIATED,this);
  CallPeerMediaHandlerGTalkImpl mediaHandler=callPeer.getMediaHandler();
  mediaHandler.setLocalVideoTransmissionEnabled(localVideoAllowed);
  callPeer.setState(CallPeerState.CONNECTING);
  callPeer.initiateSession(sessionInitiateExtensions);
  return callPeer;
}","/** 
 * Creates a <tt>CallPeerGTalkImpl</tt> from <tt>calleeJID</tt> and sends them <tt>initiate</tt> IQ request.
 * @param calleeJID the party that we would like to invite to this call.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>initiate</tt> {@link SessionIQ} which is to init this <tt>CallJabberImpl</tt>
 * @return the newly created <tt>Call</tt> corresponding to<tt>calleeJID</tt>. All following state change events will be delivered through this call peer.
 * @throws OperationFailedException  with the corresponding code if we failto create the call.
 */
public CallPeerGTalkImpl initiateGTalkSession(String calleeJID,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  CallPeerGTalkImpl callPeer=new CallPeerGTalkImpl(calleeJID,this);
  if (!firstCallPeerIsGV)   firstCallPeerIsGV=calleeJID.endsWith(ProtocolProviderServiceJabberImpl.GOOGLE_VOICE_DOMAIN);
  addCallPeer(callPeer);
  callPeer.setState(CallPeerState.INITIATING_CALL);
  if (getCallPeerCount() == 1 && !calleeJID.endsWith(ProtocolProviderServiceJabberImpl.GOOGLE_VOICE_DOMAIN) || getCallPeerCount() == 2 && firstCallPeerIsGV) {
    if (firstCallPeerIsGV) {
      firstCallPeerIsGV=false;
      Iterator<CallPeerGTalkImpl> it=getCallPeersVector().iterator();
      String sub=calleeJID.substring(0,calleeJID.indexOf(""String_Node_Str""));
      while (it.hasNext()) {
        CallPeer p=it.next();
        if (p.getAddress().equals(sub)) {
          it.remove();
          break;
        }
      }
    }
    parentOpSet.fireCallEvent(CallEvent.CALL_INITIATED,this);
  }
  CallPeerMediaHandlerGTalkImpl mediaHandler=callPeer.getMediaHandler();
  mediaHandler.setLocalVideoTransmissionEnabled(localVideoAllowed);
  callPeer.setState(CallPeerState.CONNECTING);
  callPeer.initiateSession(sessionInitiateExtensions);
  return callPeer;
}",0.8038605230386052
103267,"/** 
 * Initiate a Google Talk session   {@link SessionIQ}.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>initiate</tt> {@link SessionIQ} which is to initiate the session with this<tt>CallPeerGTalkImpl</tt>
 * @throws OperationFailedException exception
 */
protected synchronized void initiateSession(Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  sid=SessionIQ.generateSID();
  isInitiator=false;
  RtpDescriptionPacketExtension offer=getMediaHandler().createDescription();
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  sessionInitIQ=GTalkPacketFactory.createSessionInitiate(protocolProvider.getOurJID(),this.peerJID,sid,offer);
  if (sessionInitiateExtensions != null) {
    for (    PacketExtension sessionInitiateExtension : sessionInitiateExtensions) {
      sessionInitIQ.addExtension(sessionInitiateExtension);
    }
  }
  protocolProvider.getConnection().sendPacket(sessionInitIQ);
  getMediaHandler().harvestCandidates(offer.getPayloadTypes(),new CandidatesSender(){
    public void sendCandidates(    Iterable<GTalkCandidatePacketExtension> candidates){
      CallPeerGTalkImpl.this.sendCandidates(candidates);
    }
  }
);
}","/** 
 * Initiate a Google Talk session   {@link SessionIQ}.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>initiate</tt> {@link SessionIQ} which is to initiate the session with this<tt>CallPeerGTalkImpl</tt>
 * @throws OperationFailedException exception
 */
protected synchronized void initiateSession(Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  sid=SessionIQ.generateSID();
  isInitiator=false;
  RtpDescriptionPacketExtension offer=getMediaHandler().createDescription();
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  sessionInitIQ=GTalkPacketFactory.createSessionInitiate(protocolProvider.getOurJID(),this.peerJID,sid,offer);
  if (sessionInitiateExtensions != null) {
    for (    PacketExtension sessionInitiateExtension : sessionInitiateExtensions) {
      sessionInitIQ.addExtension(sessionInitiateExtension);
    }
  }
  protocolProvider.getConnection().sendPacket(sessionInitIQ);
  if (getAddress().endsWith(ProtocolProviderServiceJabberImpl.GOOGLE_VOICE_DOMAIN)) {
    return;
  }
  getMediaHandler().harvestCandidates(offer.getPayloadTypes(),new CandidatesSender(){
    public void sendCandidates(    Iterable<GTalkCandidatePacketExtension> candidates){
      CallPeerGTalkImpl.this.sendCandidates(candidates);
    }
  }
);
}",0.9618834080717488
103268,"/** 
 * Returns whether or not the <tt>CallPeer</tt> is an Android phone or a call pass throught Google Voice or uses Google Talk client. We base the detection of the JID's resource which in the case of Android is android/Vtok/Talk.vXXXXXXX (where XXXXXX is a suite of numbers/letters).
 */
private static boolean isAndroidOrVtokOrTalkClient(String fullJID){
  int idx=fullJID.indexOf('/');
  if (idx != -1) {
    String res=fullJID.substring(idx + 1);
    if (res.startsWith(""String_Node_Str"") || res.startsWith(""String_Node_Str"") || res.startsWith(""String_Node_Str"")) {
      return true;
    }
  }
  if (fullJID.contains(""String_Node_Str""))   return true;
  return false;
}","/** 
 * Returns whether or not the <tt>CallPeer</tt> is an Android phone or a call pass throught Google Voice or uses Google Talk client. We base the detection of the JID's resource which in the case of Android is android/Vtok/Talk.vXXXXXXX (where XXXXXX is a suite of numbers/letters).
 */
private static boolean isAndroidOrVtokOrTalkClient(String fullJID){
  int idx=fullJID.indexOf('/');
  if (idx != -1) {
    String res=fullJID.substring(idx + 1);
    if (res.startsWith(""String_Node_Str"") || res.startsWith(""String_Node_Str"") || res.startsWith(""String_Node_Str"")) {
      return true;
    }
  }
  if (fullJID.contains(""String_Node_Str"" + ProtocolProviderServiceJabberImpl.GOOGLE_VOICE_DOMAIN))   return true;
  return false;
}",0.9602272727272728
103269,"/** 
 * Analyzes the <tt>sessionIQ</tt>'s action and passes it to the corresponding handler.
 * @param sessionIQ the {@link SessionIQ} packet we need to be analyzing.
 */
private void processSessionIQ(SessionIQ sessionIQ){
  CallPeerGTalkImpl callPeer=activeGTalkCallsRepository.findCallPeer(sessionIQ.getID());
  IQ.Type type=sessionIQ.getType();
  if (type == Type.RESULT) {
    return;
  }
  if (type == Type.ERROR) {
    logger.error(""String_Node_Str"");
    XMPPError error=sessionIQ.getError();
    RedirectPacketExtension redirect=null;
    if (error != null) {
      for (      PacketExtension e : error.getExtensions()) {
        if (e.getElementName().equals(RedirectPacketExtension.ELEMENT_NAME)) {
          redirect=(RedirectPacketExtension)e;
        }
      }
    }
    if (redirect != null) {
      CallGTalkImpl call=callPeer.getCall();
      try {
        String redir=redirect.getRedir();
        callPeer.setState(CallPeerState.DISCONNECTED);
        if (redir.startsWith(""String_Node_Str""))         redir=redir.substring(5);
        call.initiateGTalkSession(redir,null);
      }
 catch (      Exception e) {
        logger.info(""String_Node_Str"");
      }
      return;
    }
    String message=""String_Node_Str"";
    if (error != null) {
      logger.error(""String_Node_Str"" + error.getCode() + ""String_Node_Str""+ error.getMessage());
      if (error.getMessage() != null)       message=error.getMessage();
    }
    if (callPeer != null)     callPeer.setState(CallPeerState.FAILED,message);
    return;
  }
  GTalkType action=sessionIQ.getGTalkType();
  if (action == GTalkType.INITIATE) {
    CallGTalkImpl call=null;
    if (call == null) {
      call=new CallGTalkImpl(this);
    }
    call.processGTalkInitiate(sessionIQ);
    return;
  }
 else   if (callPeer == null) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    return;
  }
 else   if (action == GTalkType.CANDIDATES) {
    callPeer.processCandidates(sessionIQ);
  }
 else   if (action == GTalkType.REJECT) {
    callPeer.processSessionReject(sessionIQ);
  }
 else   if (action == GTalkType.TERMINATE) {
    callPeer.processSessionTerminate(sessionIQ);
  }
 else   if (action == GTalkType.ACCEPT) {
    callPeer.processSessionAccept(sessionIQ);
  }
}","/** 
 * Analyzes the <tt>sessionIQ</tt>'s action and passes it to the corresponding handler.
 * @param sessionIQ the {@link SessionIQ} packet we need to be analyzing.
 */
private void processSessionIQ(SessionIQ sessionIQ){
  final CallPeerGTalkImpl callPeer=activeGTalkCallsRepository.findCallPeer(sessionIQ.getID());
  IQ.Type type=sessionIQ.getType();
  if (type == Type.RESULT) {
    return;
  }
  if (type == Type.ERROR) {
    logger.error(""String_Node_Str"");
    XMPPError error=sessionIQ.getError();
    RedirectPacketExtension redirect=null;
    if (error != null) {
      for (      PacketExtension e : error.getExtensions()) {
        if (e.getElementName().equals(RedirectPacketExtension.ELEMENT_NAME)) {
          redirect=(RedirectPacketExtension)e;
        }
      }
    }
    if (redirect != null) {
      final CallGTalkImpl call=callPeer.getCall();
      final String redirAddr;
      String redir=redirect.getRedir();
      if (redir.startsWith(""String_Node_Str""))       redirAddr=redir.substring(5);
 else       redirAddr=null;
      if (redirAddr == null)       return;
      new Thread(){
        public void run(){
          try {
            call.initiateGTalkSession(redirAddr,null);
            callPeer.setState(CallPeerState.DISCONNECTED);
          }
 catch (          Exception e) {
            logger.info(""String_Node_Str"");
          }
        }
      }
.start();
      return;
    }
    String message=""String_Node_Str"";
    if (error != null) {
      logger.error(""String_Node_Str"" + error.getCode() + ""String_Node_Str""+ error.getMessage());
      if (error.getMessage() != null)       message=error.getMessage();
    }
    if (callPeer != null)     callPeer.setState(CallPeerState.FAILED,message);
    return;
  }
  GTalkType action=sessionIQ.getGTalkType();
  if (action == GTalkType.INITIATE) {
    CallGTalkImpl call=null;
    if (call == null) {
      call=new CallGTalkImpl(this);
    }
    call.processGTalkInitiate(sessionIQ);
    return;
  }
 else   if (callPeer == null) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    return;
  }
 else   if (action == GTalkType.CANDIDATES) {
    callPeer.processCandidates(sessionIQ);
  }
 else   if (action == GTalkType.REJECT) {
    callPeer.processSessionReject(sessionIQ);
  }
 else   if (action == GTalkType.TERMINATE) {
    callPeer.processSessionTerminate(sessionIQ);
  }
 else   if (action == GTalkType.ACCEPT) {
    callPeer.processSessionAccept(sessionIQ);
  }
}",0.86787674124103
103270,"/** 
 * Initializes this chat room dialog.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout(5,5));
  JPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(15,15,5,15));
  JPanel labels=new TransparentPanel(new GridLayout(2,2,5,5));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(2,2,5,5));
  providersCombo=createProvidersCombobox();
  roomsCombo=new JComboBox();
  roomsCombo.setEditable(true);
  roomsCombo.setPreferredSize(providersCombo.getPreferredSize());
  editor=((JTextField)roomsCombo.getEditor().getEditorComponent());
  providersCombo.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED)       loadProviderRooms();
    }
  }
);
  valuesPanel.add(providersCombo);
  valuesPanel.add(roomsCombo);
  northPanel.add(labels,BorderLayout.WEST);
  northPanel.add(valuesPanel,BorderLayout.CENTER);
  JPanel buttonPanel=new TransparentPanel(new BorderLayout(5,5));
  buttonPanel.setBorder(BorderFactory.createEmptyBorder(0,15,10,15));
  JPanel westButtonPanel=new TransparentPanel();
  JPanel eastButtonPanel=new TransparentPanel();
  addButton.addActionListener(this);
  removeButton.addActionListener(this);
  okButton.addActionListener(this);
  cancelButton.addActionListener(this);
  addButton.setEnabled(false);
  removeButton.setEnabled(false);
  westButtonPanel.add(addButton);
  westButtonPanel.add(removeButton);
  eastButtonPanel.add(cancelButton);
  eastButtonPanel.add(okButton);
  buttonPanel.add(westButtonPanel,BorderLayout.WEST);
  buttonPanel.add(eastButtonPanel,BorderLayout.EAST);
  chatRoomsTableUI=new ChatRoomTableUI(this);
  chatRoomsTableUI.setOpaque(false);
  chatRoomsTableUI.setBorder(BorderFactory.createEmptyBorder(5,15,5,15));
  northPanel.setPreferredSize(new Dimension(600,80));
  this.getContentPane().add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsTableUI,BorderLayout.CENTER);
  loadProviderRooms();
  editor.addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
      chatRoomsTableUI.clearSelection();
      if (editor.getText().trim().length() > 0) {
        okButton.setEnabled(true);
        addButton.setEnabled(true);
      }
 else {
        okButton.setEnabled(false);
        addButton.setEnabled(false);
      }
    }
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
    }
  }
);
  chatRoomsTableUI.addSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
        if (room != null) {
          editor.setText(room.getChatRoomName());
          providersCombo.setSelectedItem(room.getParentProvider());
          okButton.setEnabled(true);
          removeButton.setEnabled(true);
        }
 else         removeButton.setEnabled(false);
      }
    }
  }
);
  GuiActivator.getUIService().getConferenceChatManager().getChatRoomList().addChatRoomProviderWrapperListener(new ChatRoomList.ChatRoomProviderWrapperListener(){
    public void chatRoomProviderWrapperAdded(    ChatRoomProviderWrapper provider){
      providersCombo.addItem(provider);
    }
    public void chatRoomProviderWrapperRemoved(    ChatRoomProviderWrapper provider){
      providersCombo.removeItem(provider);
    }
  }
);
}","/** 
 * Initializes this chat room dialog.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout(5,5));
  JPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(15,15,5,15));
  JPanel labels=new TransparentPanel(new GridLayout(2,2,5,5));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(2,2,5,5));
  providersCombo=createProvidersCombobox();
  roomsCombo=new JComboBox();
  roomsCombo.setEditable(true);
  roomsCombo.setPreferredSize(providersCombo.getPreferredSize());
  editor=((JTextField)roomsCombo.getEditor().getEditorComponent());
  providersCombo.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED)       loadProviderRooms();
    }
  }
);
  roomsCombo.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED && roomsCombo.getSelectedIndex() != -1) {
        okButton.setEnabled(true);
        addButton.setEnabled(true);
      }
    }
  }
);
  valuesPanel.add(providersCombo);
  valuesPanel.add(roomsCombo);
  northPanel.add(labels,BorderLayout.WEST);
  northPanel.add(valuesPanel,BorderLayout.CENTER);
  JPanel buttonPanel=new TransparentPanel(new BorderLayout(5,5));
  buttonPanel.setBorder(BorderFactory.createEmptyBorder(0,15,10,15));
  JPanel westButtonPanel=new TransparentPanel();
  JPanel eastButtonPanel=new TransparentPanel();
  addButton.addActionListener(this);
  removeButton.addActionListener(this);
  okButton.addActionListener(this);
  cancelButton.addActionListener(this);
  addButton.setEnabled(false);
  removeButton.setEnabled(false);
  westButtonPanel.add(addButton);
  westButtonPanel.add(removeButton);
  eastButtonPanel.add(cancelButton);
  eastButtonPanel.add(okButton);
  buttonPanel.add(westButtonPanel,BorderLayout.WEST);
  buttonPanel.add(eastButtonPanel,BorderLayout.EAST);
  chatRoomsTableUI=new ChatRoomTableUI(this);
  chatRoomsTableUI.setOpaque(false);
  chatRoomsTableUI.setBorder(BorderFactory.createEmptyBorder(5,15,5,15));
  northPanel.setPreferredSize(new Dimension(600,80));
  this.getContentPane().add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsTableUI,BorderLayout.CENTER);
  loadProviderRooms();
  editor.addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
    }
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
      chatRoomsTableUI.clearSelection();
      if (editor.getText().trim().length() > 0) {
        okButton.setEnabled(true);
        addButton.setEnabled(true);
      }
 else {
        okButton.setEnabled(false);
        addButton.setEnabled(false);
      }
    }
  }
);
  chatRoomsTableUI.addSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
        if (room != null) {
          editor.setText(room.getChatRoomName());
          providersCombo.setSelectedItem(room.getParentProvider());
          okButton.setEnabled(true);
          removeButton.setEnabled(true);
        }
 else         removeButton.setEnabled(false);
      }
    }
  }
);
  GuiActivator.getUIService().getConferenceChatManager().getChatRoomList().addChatRoomProviderWrapperListener(new ChatRoomList.ChatRoomProviderWrapperListener(){
    public void chatRoomProviderWrapperAdded(    ChatRoomProviderWrapper provider){
      providersCombo.addItem(provider);
    }
    public void chatRoomProviderWrapperRemoved(    ChatRoomProviderWrapper provider){
      providersCombo.removeItem(provider);
    }
  }
);
}",0.9367778787485396
103271,"public void itemStateChanged(ItemEvent e){
  if (e.getStateChange() == ItemEvent.SELECTED)   loadProviderRooms();
}","public void itemStateChanged(ItemEvent e){
  if (e.getStateChange() == ItemEvent.SELECTED && roomsCombo.getSelectedIndex() != -1) {
    okButton.setEnabled(true);
    addButton.setEnabled(true);
  }
}",0.6158730158730159
103272,"public void keyTyped(KeyEvent e){
  chatRoomsTableUI.clearSelection();
  if (editor.getText().trim().length() > 0) {
    okButton.setEnabled(true);
    addButton.setEnabled(true);
  }
 else {
    okButton.setEnabled(false);
    addButton.setEnabled(false);
  }
}","public void keyTyped(KeyEvent e){
}",0.2356902356902357
103273,"public void keyReleased(KeyEvent e){
}","public void keyReleased(KeyEvent e){
  chatRoomsTableUI.clearSelection();
  if (editor.getText().trim().length() > 0) {
    okButton.setEnabled(true);
    addButton.setEnabled(true);
  }
 else {
    okButton.setEnabled(false);
    addButton.setEnabled(false);
  }
}",0.2508250825082508
103274,"/** 
 * Adds new <tt>NetworkConfigurationChangeListener</tt> which will be informed for network configuration changes.
 * @param listener the listener.
 */
public void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  if (networkConfigurationWatcher == null)   networkConfigurationWatcher=new NetworkConfigurationWatcher();
  networkConfigurationWatcher.addNetworkConfigurationChangeListener(listener);
}","/** 
 * Adds new <tt>NetworkConfigurationChangeListener</tt> which will be informed for network configuration changes.
 * @param listener the listener.
 */
public synchronized void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  if (networkConfigurationWatcher == null)   networkConfigurationWatcher=new NetworkConfigurationWatcher();
  networkConfigurationWatcher.addNetworkConfigurationChangeListener(listener);
}",0.9854423292273236
103275,"/** 
 * Remove <tt>NetworkConfigurationChangeListener</tt>.
 * @param listener the listener.
 */
public void removeNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  if (networkConfigurationWatcher != null)   networkConfigurationWatcher.removeNetworkConfigurationChangeListener(listener);
}","/** 
 * Remove <tt>NetworkConfigurationChangeListener</tt>.
 * @param listener the listener.
 */
public synchronized void removeNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  if (networkConfigurationWatcher != null)   networkConfigurationWatcher.removeNetworkConfigurationChangeListener(listener);
}",0.9802130898021308
103276,"/** 
 * Specifies whether or not this contact group is to be considered resolved against the server. Note that no actions are to be undertaken against group buddies in this method.
 * @param resolved true if this group hase been resolved against the serverand false otherwise.
 */
void setResolved(boolean resolved){
  this.isResolved=resolved;
}","/** 
 * Specifies whether or not this contact group is to be considered resolved against the server. Note that no actions are to be undertaken against group buddies in this method.
 * @param resolved true if this group hase been resolved against the serverand false otherwise.
 */
void setResolved(boolean resolved){
  this.isResolved=resolved;
  this.isPersistent=true;
}",0.9637883008356546
103277,"/** 
 * Determines whether or not this contact group is being stored by the server. Non persistent contact groups exist for the sole purpose of containing non persistent contacts.
 * @return true if the contact group is persistent and false otherwise.
 */
public boolean isPersistent(){
  return !(joustSimSourceGroup instanceof VolatileGroup);
}","/** 
 * Determines whether or not this contact group is being stored by the server. Non persistent contact groups exist for the sole purpose of containing non persistent contacts.
 * @return true if the contact group is persistent and false otherwise.
 */
public boolean isPersistent(){
  return isPersistent;
}",0.9101978691019786
103278,"/** 
 * Creates an ICQ group using the specified <tt>joustSimGroup</tt> as a source. The newly created group will always return the name of the underlying joustSimGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl. <p> Note that we MUST NOT use the list of buddies obtained through the getBuddiesCopy() of the joustSimGroup arg as we'd later need to be able to directly compare ( == ) instances of buddies we've stored and others that are returned by the framework. <p>
 * @param joustSimGroup the JoustSIM Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupIcqImpl(MutableGroup joustSimGroup,Iterable<? extends Buddy> groupMembers,ServerStoredContactListIcqImpl ssclCallback,boolean isResolved){
  this.joustSimSourceGroup=joustSimGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  initNameCopy();
  if (groupMembers != null)   for (  Buddy buddy : groupMembers) {
    if (ssclCallback.findContactByJoustSimBuddy(buddy) != null) {
      continue;
    }
    addContact(new ContactIcqImpl(buddy,ssclCallback,true,true));
  }
}","/** 
 * Creates an ICQ group using the specified <tt>joustSimGroup</tt> as a source. The newly created group will always return the name of the underlying joustSimGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl. <p> Note that we MUST NOT use the list of buddies obtained through the getBuddiesCopy() of the joustSimGroup arg as we'd later need to be able to directly compare ( == ) instances of buddies we've stored and others that are returned by the framework. <p>
 * @param joustSimGroup the JoustSIM Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupIcqImpl(MutableGroup joustSimGroup,Iterable<? extends Buddy> groupMembers,ServerStoredContactListIcqImpl ssclCallback,boolean isResolved,boolean isPersistent){
  this.joustSimSourceGroup=joustSimGroup;
  this.isResolved=isResolved;
  this.isPersistent=isPersistent;
  this.ssclCallback=ssclCallback;
  initNameCopy();
  if (groupMembers != null)   for (  Buddy buddy : groupMembers) {
    if (ssclCallback.findContactByJoustSimBuddy(buddy) != null) {
      continue;
    }
    addContact(new ContactIcqImpl(buddy,ssclCallback,true,true));
  }
}",0.9817336433078712
103279,"/** 
 * Called by joustsim as a notification of the fact that the server has sent the specified group and that it is actually a member from our contact list. We copy the group locally and generate the corresponding sip-communicator events
 * @param list the BuddyList where this is happening.
 * @param oldItems we don't use it
 * @param newItems we don't use it
 * @param group the new Group that has been added
 * @param buddies the members of the new group.
 */
public void groupAdded(BuddyList list,List<? extends Group> oldItems,List<? extends Group> newItems,Group group,List<? extends Buddy> buddies){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + group.getName());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + buddies);
  ContactGroupIcqImpl newGroup=findContactGroup(group.getName());
  if (newGroup == null) {
    newGroup=new ContactGroupIcqImpl((MutableGroup)group,buddies,ServerStoredContactListIcqImpl.this,true);
    rootGroup.addSubGroup(newGroup);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    List<Contact> newContacts=new ArrayList<Contact>();
    List<ContactIcqImpl> deletedContacts=new ArrayList<ContactIcqImpl>();
    newGroup.updateGroup((MutableGroup)group,buddies,newContacts,deletedContacts);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    for (    ContactIcqImpl contact : deletedContacts)     fireContactRemoved(newGroup,contact);
    Iterator<Contact> contactsIter=newGroup.contacts();
    while (contactsIter.hasNext()) {
      Contact contact=contactsIter.next();
      if (newContacts.contains(contact))       fireContactAdded(newGroup,contact);
 else       fireContactResolved(newGroup,contact);
    }
  }
  for (  Buddy buddy : buddies)   buddy.addBuddyListener(jsimBuddyListener);
  group.addGroupListener(jsimGroupChangeListener);
}","/** 
 * Called by joustsim as a notification of the fact that the server has sent the specified group and that it is actually a member from our contact list. We copy the group locally and generate the corresponding sip-communicator events
 * @param list the BuddyList where this is happening.
 * @param oldItems we don't use it
 * @param newItems we don't use it
 * @param group the new Group that has been added
 * @param buddies the members of the new group.
 */
public void groupAdded(BuddyList list,List<? extends Group> oldItems,List<? extends Group> newItems,Group group,List<? extends Buddy> buddies){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + group.getName());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + buddies);
  ContactGroupIcqImpl newGroup=findContactGroup(group.getName());
  if (newGroup == null) {
    newGroup=new ContactGroupIcqImpl((MutableGroup)group,buddies,ServerStoredContactListIcqImpl.this,true,true);
    rootGroup.addSubGroup(newGroup);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    List<Contact> newContacts=new ArrayList<Contact>();
    List<ContactIcqImpl> deletedContacts=new ArrayList<ContactIcqImpl>();
    newGroup.updateGroup((MutableGroup)group,buddies,newContacts,deletedContacts);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    for (    ContactIcqImpl contact : deletedContacts)     fireContactRemoved(newGroup,contact);
    Iterator<Contact> contactsIter=newGroup.contacts();
    while (contactsIter.hasNext()) {
      Contact contact=contactsIter.next();
      if (newContacts.contains(contact))       fireContactAdded(newGroup,contact);
 else       fireContactResolved(newGroup,contact);
    }
  }
  for (  Buddy buddy : buddies)   buddy.addBuddyListener(jsimBuddyListener);
  group.addGroupListener(jsimGroupChangeListener);
}",0.998674794593162
103280,"/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param screenname the UIN/Screenname of the contact to create.
 * @return the newly created volatile <tt>ContactIcqImpl</tt>
 */
ContactIcqImpl createVolatileContact(Screenname screenname){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + screenname);
  Buddy volatileBuddy=new VolatileBuddy(screenname);
  ContactIcqImpl newVolatileContact=new ContactIcqImpl(volatileBuddy,this,false,false);
  ContactGroupIcqImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    List<Buddy> emptyBuddies=new LinkedList<Buddy>();
    theVolatileGroup=new ContactGroupIcqImpl(new VolatileGroup(),emptyBuddies,this,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}","/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param screenname the UIN/Screenname of the contact to create.
 * @return the newly created volatile <tt>ContactIcqImpl</tt>
 */
ContactIcqImpl createVolatileContact(Screenname screenname){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + screenname);
  Buddy volatileBuddy=new VolatileBuddy(screenname);
  ContactIcqImpl newVolatileContact=new ContactIcqImpl(volatileBuddy,this,false,false);
  ContactGroupIcqImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    List<Buddy> emptyBuddies=new LinkedList<Buddy>();
    theVolatileGroup=new ContactGroupIcqImpl(new VolatileGroup(),emptyBuddies,this,false,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}",0.997626582278481
103281,"/** 
 * Creates a non resolved contact group for the specified name. The newly created group would be added to the local contact list as any other group but when an event is received from the server concerning this group, then it will be reused and only its isResolved field would be updated instead of creating the whole group again. <p>
 * @param groupName the name of the group to create.
 * @return the newly created unresolved <tt>ContactGroupIcqImpl</tt>
 */
ContactGroupIcqImpl createUnresolvedContactGroup(String groupName){
  List<Buddy> emptyBuddies=new LinkedList<Buddy>();
  ContactGroupIcqImpl newUnresolvedGroup=new ContactGroupIcqImpl(new VolatileGroup(groupName),emptyBuddies,this,false);
  this.rootGroup.addSubGroup(newUnresolvedGroup);
  fireGroupEvent(newUnresolvedGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  return newUnresolvedGroup;
}","/** 
 * Creates a non resolved contact group for the specified name. The newly created group would be added to the local contact list as any other group but when an event is received from the server concerning this group, then it will be reused and only its isResolved field would be updated instead of creating the whole group again. <p>
 * @param groupName the name of the group to create.
 * @return the newly created unresolved <tt>ContactGroupIcqImpl</tt>
 */
ContactGroupIcqImpl createUnresolvedContactGroup(String groupName){
  List<Buddy> emptyBuddies=new LinkedList<Buddy>();
  ContactGroupIcqImpl newUnresolvedGroup=new ContactGroupIcqImpl(new VolatileGroup(groupName),emptyBuddies,this,false,true);
  this.rootGroup.addSubGroup(newUnresolvedGroup);
  fireGroupEvent(newUnresolvedGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  return newUnresolvedGroup;
}",0.9971214738054116
103282,"/** 
 * Resolve this contact group against the specified group
 * @param msnGroup the server stored group
 */
void setResolved(MsnGroup msnGroup){
  if (isResolved)   return;
  this.isResolved=true;
  this.msnGroup=msnGroup;
  MsnContact[] contacts=msnGroup.getContacts();
  for (int i=0; i < contacts.length; i++) {
    MsnContact item=contacts[i];
    ContactMsnImpl contact=ssclCallback.findContactById(item.getEmail().getEmailAddress());
    if (contact != null) {
      contact.setResolved(item);
      ssclCallback.fireContactResolved(this,contact);
    }
 else {
      ContactMsnImpl newContact=new ContactMsnImpl(item,ssclCallback,true,true);
      addContact(newContact);
      ssclCallback.fireContactAdded(this,newContact);
    }
  }
}","/** 
 * Resolve this contact group against the specified group
 * @param msnGroup the server stored group
 */
void setResolved(MsnGroup msnGroup){
  if (isResolved)   return;
  this.isResolved=true;
  this.isPersistent=true;
  this.msnGroup=msnGroup;
  MsnContact[] contacts=msnGroup.getContacts();
  for (int i=0; i < contacts.length; i++) {
    MsnContact item=contacts[i];
    ContactMsnImpl contact=ssclCallback.findContactById(item.getEmail().getEmailAddress());
    if (contact != null) {
      contact.setResolved(item);
      ssclCallback.fireContactResolved(this,contact);
    }
 else {
      ContactMsnImpl newContact=new ContactMsnImpl(item,ssclCallback,true,true);
      addContact(newContact);
      ssclCallback.fireContactAdded(this,newContact);
    }
  }
}",0.9828722002635046
103283,"/** 
 * Creates an Msn group using the specified <tt>RosterGroup</tt> as a source. The newly created group will always return the name of the underlying RosterGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl update will only be done if source group is changed.
 * @param msnGroup the Msn Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupMsnImpl(MsnGroup msnGroup,MsnContact[] groupMembers,ServerStoredContactListMsnImpl ssclCallback,boolean isResolved){
  this.msnGroup=msnGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  for (  MsnContact groupMember : groupMembers) {
    if (ssclCallback.findContactById(groupMember.getEmail().getEmailAddress()) == null)     addContact(new ContactMsnImpl(groupMember,ssclCallback,true,true));
  }
}","/** 
 * Creates an Msn group using the specified <tt>RosterGroup</tt> as a source. The newly created group will always return the name of the underlying RosterGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl update will only be done if source group is changed.
 * @param msnGroup the Msn Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupMsnImpl(MsnGroup msnGroup,MsnContact[] groupMembers,ServerStoredContactListMsnImpl ssclCallback,boolean isResolved,boolean isPersistent){
  this.msnGroup=msnGroup;
  this.isResolved=isResolved;
  this.isPersistent=isPersistent;
  this.ssclCallback=ssclCallback;
  for (  MsnContact groupMember : groupMembers) {
    if (ssclCallback.findContactById(groupMember.getEmail().getEmailAddress()) == null)     addContact(new ContactMsnImpl(groupMember,ssclCallback,true,true));
  }
}",0.9774866966844044
103284,"/** 
 * Determines whether or not this contact group is being stored by the server. Non persistent contact groups exist for the sole purpose of containing non persistent contacts.
 * @return true if the contact group is persistent and false otherwise.
 */
public boolean isPersistent(){
  return !(msnGroup instanceof VolatileGroup);
}","/** 
 * Determines whether or not this contact group is being stored by the server. Non persistent contact groups exist for the sole purpose of containing non persistent contacts.
 * @return true if the contact group is persistent and false otherwise.
 */
public boolean isPersistent(){
  return isPersistent;
}",0.9256965944272446
103285,"public void contactListInitCompleted(MsnMessenger messenger){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  isInitialized=true;
  if (logger.isDebugEnabled())   printList();
  MsnContactList contactList=messenger.getContactList();
  MsnGroup[] groups=contactList.getGroups();
  for (int i=0; i < groups.length; i++) {
    MsnGroup item=groups[i];
    if (item.isDefaultGroup())     continue;
    ContactGroupMsnImpl group=findContactGroup(item.getGroupName());
    if (group == null) {
      ContactGroupMsnImpl newGroup=new ContactGroupMsnImpl(item,item.getContacts(),ServerStoredContactListMsnImpl.this,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
 else {
      group.setResolved(item);
      fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    }
  }
  MsnContact[] contacts=messenger.getContactList().getContactsInList(MsnList.FL);
  for (int i=0; i < contacts.length; i++) {
    MsnContact item=contacts[i];
    if (item.getBelongGroups().length == 0) {
      ContactMsnImpl contact=findContactById(item.getEmail().getEmailAddress());
      if (contact == null) {
        contact=new ContactMsnImpl(item,ServerStoredContactListMsnImpl.this,true,true);
        rootGroup.addContact(contact);
        fireContactAdded(rootGroup,contact);
      }
 else {
        contact.setResolved(item);
      }
    }
  }
  parentOperationSet.earlyStatusesDispatch();
  messenger.retreiveOfflineMessages();
}","public void contactListInitCompleted(MsnMessenger messenger){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  isInitialized=true;
  if (logger.isDebugEnabled())   printList();
  MsnContactList contactList=messenger.getContactList();
  MsnGroup[] groups=contactList.getGroups();
  for (int i=0; i < groups.length; i++) {
    MsnGroup item=groups[i];
    if (item.isDefaultGroup())     continue;
    ContactGroupMsnImpl group=findContactGroup(item.getGroupName());
    if (group == null) {
      ContactGroupMsnImpl newGroup=new ContactGroupMsnImpl(item,item.getContacts(),ServerStoredContactListMsnImpl.this,true,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
 else {
      group.setResolved(item);
      fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    }
  }
  MsnContact[] contacts=messenger.getContactList().getContactsInList(MsnList.FL);
  for (int i=0; i < contacts.length; i++) {
    MsnContact item=contacts[i];
    if (item.getBelongGroups().length == 0) {
      ContactMsnImpl contact=findContactById(item.getEmail().getEmailAddress());
      if (contact == null) {
        contact=new ContactMsnImpl(item,ServerStoredContactListMsnImpl.this,true,true);
        rootGroup.addContact(contact);
        fireContactAdded(rootGroup,contact);
      }
 else {
        contact.setResolved(item);
      }
    }
  }
  parentOperationSet.earlyStatusesDispatch();
  messenger.retreiveOfflineMessages();
}",0.9983558040118382
103286,"/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param id the id of the contact to create
 * @param email the e-mail address of the contact to create
 * @param displayName the display name of the contact to create
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
ContactMsnImpl createVolatileContact(String id,Email email,String displayName){
  VolatileContact volatileBuddy=new VolatileContact(id,email,displayName);
  ContactMsnImpl newVolatileContact=new ContactMsnImpl(volatileBuddy,this,false,false);
  ContactGroupMsnImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    MsnContact[] emptyBuddies=new MsnContact[]{};
    theVolatileGroup=new ContactGroupMsnImpl(new VolatileGroup(),emptyBuddies,this,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}","/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param id the id of the contact to create
 * @param email the e-mail address of the contact to create
 * @param displayName the display name of the contact to create
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
ContactMsnImpl createVolatileContact(String id,Email email,String displayName){
  VolatileContact volatileBuddy=new VolatileContact(id,email,displayName);
  ContactMsnImpl newVolatileContact=new ContactMsnImpl(volatileBuddy,this,false,false);
  ContactGroupMsnImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    MsnContact[] emptyBuddies=new MsnContact[]{};
    theVolatileGroup=new ContactGroupMsnImpl(new VolatileGroup(),emptyBuddies,this,false,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}",0.9977307110438728
103287,"/** 
 * Creates a non resolved contact group for the specified name. The newly created group would be added to the local contact list as any other group but when an event is received from the server concerning this group, then it will be reused and only its isResolved field would be updated instead of creating the whole group again. <p>
 * @param groupName the name of the group to create.
 * @return the newly created unresolved <tt>ContactGroupImpl</tt>
 */
ContactGroupMsnImpl createUnresolvedContactGroup(String groupName){
  MsnContact[] emptyBuddies=new MsnContact[]{};
  ContactGroupMsnImpl newUnresolvedGroup=new ContactGroupMsnImpl(new VolatileGroup(groupName),emptyBuddies,this,false);
  this.rootGroup.addSubGroup(newUnresolvedGroup);
  fireGroupEvent(newUnresolvedGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  return newUnresolvedGroup;
}","/** 
 * Creates a non resolved contact group for the specified name. The newly created group would be added to the local contact list as any other group but when an event is received from the server concerning this group, then it will be reused and only its isResolved field would be updated instead of creating the whole group again. <p>
 * @param groupName the name of the group to create.
 * @return the newly created unresolved <tt>ContactGroupImpl</tt>
 */
ContactGroupMsnImpl createUnresolvedContactGroup(String groupName){
  MsnContact[] emptyBuddies=new MsnContact[]{};
  ContactGroupMsnImpl newUnresolvedGroup=new ContactGroupMsnImpl(new VolatileGroup(groupName),emptyBuddies,this,false,true);
  this.rootGroup.addSubGroup(newUnresolvedGroup);
  fireGroupEvent(newUnresolvedGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  return newUnresolvedGroup;
}",0.9970980847359258
103288,"public void groupAddCompleted(MsnMessenger messenger,MsnGroup group){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + group);
  ContactGroupMsnImpl newGroup=new ContactGroupMsnImpl(group,new MsnContact[]{},ServerStoredContactListMsnImpl.this,true);
  rootGroup.addSubGroup(newGroup);
  fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
}","public void groupAddCompleted(MsnMessenger messenger,MsnGroup group){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + group);
  ContactGroupMsnImpl newGroup=new ContactGroupMsnImpl(group,new MsnContact[]{},ServerStoredContactListMsnImpl.this,true,true);
  rootGroup.addSubGroup(newGroup);
  fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
}",0.9933598937583
103289,"/** 
 * Renames the specified group according to the specified new name..
 * @param groupToRename the group that we'd like removed.
 * @param newName the new name of the group
 */
public void renameGroup(ContactGroupMsnImpl groupToRename,String newName){
  printList();
  msnProvider.getMessenger().renameGroup(groupToRename.getSourceGroup().getGroupId(),newName);
}","/** 
 * Renames the specified group according to the specified new name..
 * @param groupToRename the group that we'd like removed.
 * @param newName the new name of the group
 */
public void renameGroup(ContactGroupMsnImpl groupToRename,String newName){
  msnProvider.getMessenger().renameGroup(groupToRename.getSourceGroup().getGroupId(),newName);
}",0.7280334728033473
103290,"/** 
 * Sends local candidate addresses from the local peer to the remote peer using the <tt>candidates</tt>   {@link SessionIQ}.
 * @param candidates the local candidate addresses to be sent from the localpeer to the remote peer using the <tt>candidates</tt> {@link SessionIQ}
 */
protected void sendCandidates(Iterable<GTalkCandidatePacketExtension> candidates){
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  SessionIQ candidatesIQ=new SessionIQ();
  candidatesIQ.setGTalkType(GTalkType.CANDIDATES);
  candidatesIQ.setFrom(protocolProvider.getOurJID());
  candidatesIQ.setInitiator(isInitiator() ? getAddress() : protocolProvider.getOurJID());
  candidatesIQ.setID(getSessionID());
  candidatesIQ.setTo(getAddress());
  candidatesIQ.setType(IQ.Type.SET);
  for (  GTalkCandidatePacketExtension candidate : candidates) {
    if (isAndroid(getAddress()) && NetworkUtils.isIPv6Address(candidate.getAddress()))     continue;
    candidatesIQ.addExtension(candidate);
  }
  protocolProvider.getConnection().sendPacket(candidatesIQ);
}","/** 
 * Sends local candidate addresses from the local peer to the remote peer using the <tt>candidates</tt>   {@link SessionIQ}.
 * @param candidates the local candidate addresses to be sent from the localpeer to the remote peer using the <tt>candidates</tt> {@link SessionIQ}
 */
protected void sendCandidates(Iterable<GTalkCandidatePacketExtension> candidates){
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  SessionIQ candidatesIQ=new SessionIQ();
  candidatesIQ.setGTalkType(GTalkType.CANDIDATES);
  candidatesIQ.setFrom(protocolProvider.getOurJID());
  candidatesIQ.setInitiator(isInitiator() ? getAddress() : protocolProvider.getOurJID());
  candidatesIQ.setID(getSessionID());
  candidatesIQ.setTo(getAddress());
  candidatesIQ.setType(IQ.Type.SET);
  for (  GTalkCandidatePacketExtension candidate : candidates) {
    if (isAndroidOrVtokOrTalkClient(getAddress()) && NetworkUtils.isIPv6Address(candidate.getAddress()))     continue;
    candidatesIQ.addExtension(candidate);
  }
  protocolProvider.getConnection().sendPacket(candidatesIQ);
}",0.9916044776119404
103291,"/** 
 * Resolve this contact against the given entry
 * @param entry the server stored entry
 */
void setResolved(RosterEntry entry){
  if (isResolved)   return;
  this.isResolved=true;
  this.jid=entry.getUser();
}","/** 
 * Resolve this contact against the given entry
 * @param entry the server stored entry
 */
void setResolved(RosterEntry entry){
  if (isResolved)   return;
  this.isResolved=true;
  this.isPersistent=true;
  this.jid=entry.getUser();
}",0.9429824561403508
103292,"/** 
 * Adds the entry to our local contactlist. If contact exists and is persistent but not resolved, we resolve it and return it without adding new contact. If the contact exists and is not persistent, we remove it, to avoid duplicate contacts and add the new one. All entries must be displayable before we done anything with them.
 * @param rosterEntryID the entry id.
 * @return the newly created contact.
 */
private ContactJabberImpl addEntryToContactList(String rosterEntryID){
  RosterEntry entry=roster.getEntry(rosterEntryID);
  if (!isEntryDisplayable(entry))   return null;
  ContactJabberImpl contact=findContactById(entry.getUser());
  if (contact != null) {
    if (contact.isPersistent()) {
      contact.setResolved(entry);
      return contact;
    }
 else {
      ContactGroup oldParentGroup=contact.getParentContactGroup();
      if (oldParentGroup instanceof ContactGroupJabberImpl && !oldParentGroup.isPersistent()) {
        ((ContactGroupJabberImpl)oldParentGroup).removeContact(contact);
        fireContactRemoved(oldParentGroup,contact);
      }
    }
  }
  contact=new ContactJabberImpl(entry,ServerStoredContactListJabberImpl.this,true,true);
  if (entry.getGroups() == null || entry.getGroups().size() == 0) {
    rootGroup.addContact(contact);
    fireContactAdded(rootGroup,contact);
    return contact;
  }
  for (  RosterGroup group : entry.getGroups()) {
    ContactGroupJabberImpl parentGroup=findContactGroup(group.getName());
    if (parentGroup != null) {
      parentGroup.addContact(contact);
      fireContactAdded(findContactGroup(contact),contact);
    }
 else {
      ContactGroupJabberImpl newGroup=new ContactGroupJabberImpl(group,group.getEntries().iterator(),ServerStoredContactListJabberImpl.this,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    return contact;
  }
  return contact;
}","/** 
 * Adds the entry to our local contactlist. If contact exists and is persistent but not resolved, we resolve it and return it without adding new contact. If the contact exists and is not persistent, we remove it, to avoid duplicate contacts and add the new one. All entries must be displayable before we done anything with them.
 * @param rosterEntryID the entry id.
 * @return the newly created contact.
 */
private ContactJabberImpl addEntryToContactList(String rosterEntryID){
  RosterEntry entry=roster.getEntry(rosterEntryID);
  if (!isEntryDisplayable(entry))   return null;
  ContactJabberImpl contact=findContactById(entry.getUser());
  if (contact != null) {
    if (contact.isPersistent()) {
      contact.setResolved(entry);
      return contact;
    }
 else     if (contact instanceof VolatileContactJabberImpl) {
      ContactGroup oldParentGroup=contact.getParentContactGroup();
      if (oldParentGroup instanceof ContactGroupJabberImpl && !oldParentGroup.isPersistent()) {
        ((ContactGroupJabberImpl)oldParentGroup).removeContact(contact);
        fireContactRemoved(oldParentGroup,contact);
      }
    }
 else     return contact;
  }
  contact=new ContactJabberImpl(entry,ServerStoredContactListJabberImpl.this,true,true);
  if (entry.getGroups() == null || entry.getGroups().size() == 0) {
    rootGroup.addContact(contact);
    fireContactAdded(rootGroup,contact);
    return contact;
  }
  for (  RosterGroup group : entry.getGroups()) {
    ContactGroupJabberImpl parentGroup=findContactGroup(group.getName());
    if (parentGroup != null) {
      parentGroup.addContact(contact);
      fireContactAdded(findContactGroup(contact),contact);
    }
 else {
      ContactGroupJabberImpl newGroup=new ContactGroupJabberImpl(group,group.getEntries().iterator(),ServerStoredContactListJabberImpl.this,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    return contact;
  }
  return contact;
}",0.9299948901379664
103293,"/** 
 * Receive a key press event.
 * @param keycode keycode received
 * @param modifiers modifiers received (ALT or CTRL + letter, ...)
 */
public void receiveKey(int keycode,int modifiers){
synchronized (mapActions) {
    for (    Map.Entry<GlobalShortcutListener,List<AWTKeyStroke>> entry : mapActions.entrySet()) {
      List<AWTKeyStroke> lst=entry.getValue();
      for (      AWTKeyStroke l : lst) {
        if (l.getKeyCode() == keycode && getModifiers(l) == modifiers) {
          GlobalShortcutEvent evt=new GlobalShortcutEvent(l);
          entry.getKey().shortcutReceived(evt);
          return;
        }
      }
    }
  }
}","/** 
 * Receive a key press event.
 * @param keycode keycode received
 * @param modifiers modifiers received (ALT or CTRL + letter, ...)
 */
public synchronized void receiveKey(int keycode,int modifiers){
synchronized (mapActions) {
    for (    Map.Entry<GlobalShortcutListener,List<AWTKeyStroke>> entry : mapActions.entrySet()) {
      List<AWTKeyStroke> lst=entry.getValue();
      for (      AWTKeyStroke l : lst) {
        if (l.getKeyCode() == keycode && getModifiers(l) == modifiers) {
          GlobalShortcutEvent evt=new GlobalShortcutEvent(l);
          entry.getKey().shortcutReceived(evt);
          return;
        }
      }
    }
  }
}",0.98989898989899
103294,"/** 
 * Callback when an shortcut is typed
 * @param evt <tt>GlobalShortcutEvent</tt>
 */
public void shortcutReceived(GlobalShortcutEvent evt){
  AWTKeyStroke keystroke=evt.getKeyStroke();
  GlobalKeybindingSet set=keybindingsService.getGlobalBindings();
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    for (    AWTKeyStroke ks : entry.getValue()) {
      if (ks == null)       continue;
      if (entry.getKey().equals(""String_Node_Str"") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {
        ExportedWindow window=GlobalShortcutActivator.getUIService().getExportedWindow(ExportedWindow.MAIN_WINDOW);
        if (window == null)         return;
        if (!window.isVisible()) {
          window.bringToFront();
          window.setVisible(true);
          if (window instanceof Window) {
            ((Window)window).setAlwaysOnTop(true);
            ((Window)window).setAlwaysOnTop(false);
          }
        }
 else {
          window.setVisible(false);
        }
      }
    }
  }
}","/** 
 * Callback when an shortcut is typed
 * @param evt <tt>GlobalShortcutEvent</tt>
 */
public synchronized void shortcutReceived(GlobalShortcutEvent evt){
  AWTKeyStroke keystroke=evt.getKeyStroke();
  GlobalKeybindingSet set=keybindingsService.getGlobalBindings();
  if (keystroke == null)   return;
  try {
    for (    Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
      for (      AWTKeyStroke ks : entry.getValue()) {
        if (ks == null)         continue;
        if (entry.getKey().equals(""String_Node_Str"") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {
          ExportedWindow window=GlobalShortcutActivator.getUIService().getExportedWindow(ExportedWindow.MAIN_WINDOW);
          if (window == null)           return;
          setVisible(window,window.isVisible());
        }
      }
    }
  }
 catch (  Throwable t) {
    if (t instanceof ThreadDeath)     throw (ThreadDeath)t;
    System.out.println(""String_Node_Str"" + t);
  }
}",0.7219327333017527
103295,"/** 
 * Adds the entry to our local contactlist.
 * @param rosterEntryID the entry id.
 * @return the newly created contact.
 */
private ContactJabberImpl addEntryToContactList(String rosterEntryID){
  RosterEntry entry=roster.getEntry(rosterEntryID);
  ContactJabberImpl contact=new ContactJabberImpl(entry,ServerStoredContactListJabberImpl.this,true,true);
  if (entry.getGroups() == null || entry.getGroups().size() == 0) {
    rootGroup.addContact(contact);
    fireContactAdded(rootGroup,contact);
    return contact;
  }
  for (  RosterGroup group : entry.getGroups()) {
    ContactGroupJabberImpl parentGroup=findContactGroup(group.getName());
    if (parentGroup != null) {
      parentGroup.addContact(contact);
      fireContactAdded(findContactGroup(contact),contact);
    }
 else {
      ContactGroupJabberImpl newGroup=new ContactGroupJabberImpl(group,group.getEntries().iterator(),ServerStoredContactListJabberImpl.this,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    return contact;
  }
  return contact;
}","/** 
 * Adds the entry to our local contactlist. If contact exists and is persistent but not resolved, we resolve it and return it without adding new contact. If the contact exists and is not persistent, we remove it, to avoid duplicate contacts and add the new one. All entries must be displayable before we done anything with them.
 * @param rosterEntryID the entry id.
 * @return the newly created contact.
 */
private ContactJabberImpl addEntryToContactList(String rosterEntryID){
  RosterEntry entry=roster.getEntry(rosterEntryID);
  if (!isEntryDisplayable(entry))   return null;
  ContactJabberImpl contact=findContactById(entry.getUser());
  if (contact != null) {
    if (contact.isPersistent()) {
      contact.setResolved(entry);
      return contact;
    }
 else {
      ContactGroup oldParentGroup=contact.getParentContactGroup();
      if (oldParentGroup instanceof ContactGroupJabberImpl && !oldParentGroup.isPersistent()) {
        ((ContactGroupJabberImpl)oldParentGroup).removeContact(contact);
        fireContactRemoved(oldParentGroup,contact);
      }
    }
  }
  contact=new ContactJabberImpl(entry,ServerStoredContactListJabberImpl.this,true,true);
  if (entry.getGroups() == null || entry.getGroups().size() == 0) {
    rootGroup.addContact(contact);
    fireContactAdded(rootGroup,contact);
    return contact;
  }
  for (  RosterGroup group : entry.getGroups()) {
    ContactGroupJabberImpl parentGroup=findContactGroup(group.getName());
    if (parentGroup != null) {
      parentGroup.addContact(contact);
      fireContactAdded(findContactGroup(contact),contact);
    }
 else {
      ContactGroupJabberImpl newGroup=new ContactGroupJabberImpl(group,group.getEntries().iterator(),ServerStoredContactListJabberImpl.this,true);
      rootGroup.addSubGroup(newGroup);
      fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    return contact;
  }
  return contact;
}",0.730883813306852
103296,"/** 
 * Received event when entry is added to the server stored list
 * @param addresses Collection
 */
public void entriesAdded(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String id : addresses) {
    RosterEntry entry=roster.getEntry(id);
    if (!isEntryDisplayable(entry))     continue;
    ContactJabberImpl contact=findContactById(entry.getUser());
    if (contact != null) {
      if (contact.isPersistent()) {
        contact.setResolved(entry);
        continue;
      }
 else {
        ContactGroup oldParentGroup=contact.getParentContactGroup();
        if (oldParentGroup instanceof ContactGroupJabberImpl && !oldParentGroup.isPersistent()) {
          ((ContactGroupJabberImpl)oldParentGroup).removeContact(contact);
          fireContactRemoved(oldParentGroup,contact);
        }
      }
    }
    contact=addEntryToContactList(id);
  }
}","/** 
 * Received event when entry is added to the server stored list
 * @param addresses Collection
 */
public void entriesAdded(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String id : addresses) {
    addEntryToContactList(id);
  }
}",0.4991896272285251
103297,"/** 
 * Event when an entry is updated. Something for the entry data or have been added to a new group or removed from one
 * @param addresses Collection
 */
public void entriesUpdated(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String contactID : addresses) {
    RosterEntry entry=roster.getEntry(contactID);
    ContactJabberImpl contact=findContactById(contactID);
    if (contact != null && (contact instanceof VolatileContactJabberImpl)) {
      contact=null;
    }
    if (contact == null && isEntryDisplayable(entry)) {
      contact=addEntryToContactList(contactID);
    }
    for (    RosterGroup gr : entry.getGroups()) {
      if (findContactGroup(gr.getName()) == null) {
        ContactGroupJabberImpl group=findContactGroupByNameCopy(gr.getName());
        if (group != null) {
          group.setSourceGroup(gr);
          fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RENAMED_EVENT);
        }
 else {
        }
      }
 else {
        ContactGroup contactGroup=contact.getParentContactGroup();
        if (!gr.getName().equals(contactGroup.getGroupName())) {
          if (contactGroup instanceof ContactGroupJabberImpl)           ((ContactGroupJabberImpl)contactGroup).removeContact(contact);
 else           if (contactGroup instanceof RootContactGroupJabberImpl)           ((RootContactGroupJabberImpl)contactGroup).removeContact(contact);
          ContactGroupJabberImpl newParentGroup=findContactGroup(gr.getName());
          newParentGroup.addContact(contact);
          fireContactMoved(contactGroup,newParentGroup,contact);
        }
      }
    }
  }
}","/** 
 * Event when an entry is updated. Something for the entry data or have been added to a new group or removed from one
 * @param addresses Collection
 */
public void entriesUpdated(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String contactID : addresses) {
    RosterEntry entry=roster.getEntry(contactID);
    ContactJabberImpl contact=addEntryToContactList(contactID);
    for (    RosterGroup gr : entry.getGroups()) {
      if (findContactGroup(gr.getName()) == null) {
        ContactGroupJabberImpl group=findContactGroupByNameCopy(gr.getName());
        if (group != null) {
          group.setSourceGroup(gr);
          fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RENAMED_EVENT);
        }
 else {
        }
      }
 else {
        ContactGroup contactGroup=contact.getParentContactGroup();
        if (!gr.getName().equals(contactGroup.getGroupName())) {
          if (contactGroup instanceof ContactGroupJabberImpl)           ((ContactGroupJabberImpl)contactGroup).removeContact(contact);
 else           if (contactGroup instanceof RootContactGroupJabberImpl)           ((RootContactGroupJabberImpl)contactGroup).removeContact(contact);
          ContactGroupJabberImpl newParentGroup=findContactGroup(gr.getName());
          newParentGroup.addContact(contact);
          fireContactMoved(contactGroup,newParentGroup,contact);
        }
      }
    }
  }
}",0.9206043072966892
103298,"/** 
 * Stop the service.
 */
public void stop(){
  Collection<List<AWTKeyStroke>> lst=mapActions.values();
  isRunning=false;
  for (  List<AWTKeyStroke> kss : lst) {
    for (    AWTKeyStroke e : kss) {
      unregisterShortcut(callShortcut,e);
      unregisterShortcut(uiShortcut,e);
    }
  }
  if (keyboardHook != null) {
    keyboardHook.setDelegate(null);
    keyboardHook.stop();
  }
}","/** 
 * Stop the service.
 */
public void stop(){
  isRunning=false;
  for (  Map.Entry<GlobalShortcutListener,List<AWTKeyStroke>> entry : mapActions.entrySet()) {
    GlobalShortcutListener l=entry.getKey();
    for (    AWTKeyStroke e : entry.getValue()) {
      unregisterShortcut(l,e);
    }
  }
  if (keyboardHook != null) {
    keyboardHook.setDelegate(null);
    keyboardHook.stop();
  }
}",0.5830164765525983
103299,"/** 
 * Reload global shortcuts.
 */
public synchronized void reloadGlobalShortcuts(){
  GlobalKeybindingSet set=GlobalShortcutActivator.getKeybindingsService().getGlobalBindings();
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    for (    AWTKeyStroke e : entry.getValue()) {
      unregisterShortcut(callShortcut,e);
      unregisterShortcut(uiShortcut,e);
    }
  }
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"") || entry.getKey().equals(""String_Node_Str"")) {
      for (      AWTKeyStroke e : entry.getValue()) {
        registerShortcut(callShortcut,e);
      }
    }
 else     if (entry.getKey().equals(""String_Node_Str"")) {
      for (      AWTKeyStroke e : entry.getValue()) {
        registerShortcut(uiShortcut,e);
      }
    }
  }
}","/** 
 * Reload global shortcuts.
 */
public synchronized void reloadGlobalShortcuts(){
  GlobalKeybindingSet set=GlobalShortcutActivator.getKeybindingsService().getGlobalBindings();
  for (  Map.Entry<GlobalShortcutListener,List<AWTKeyStroke>> entry : mapActions.entrySet()) {
    GlobalShortcutListener l=entry.getKey();
    for (    AWTKeyStroke e : entry.getValue()) {
      unregisterShortcut(l,e);
    }
  }
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"") || entry.getKey().equals(""String_Node_Str"")) {
      for (      AWTKeyStroke e : entry.getValue()) {
        registerShortcut(callShortcut,e);
      }
    }
 else     if (entry.getKey().equals(""String_Node_Str"")) {
      for (      AWTKeyStroke e : entry.getValue()) {
        registerShortcut(uiShortcut,e);
      }
    }
  }
}",0.9125214408233276
103300,"/** 
 * Callback when an shortcut is typed
 * @param evt <tt>GlobalShortcutEvent</tt>
 */
public void shortcutReceived(GlobalShortcutEvent evt){
  AWTKeyStroke keystroke=evt.getKeyStroke();
  GlobalKeybindingSet set=keybindingsService.getGlobalBindings();
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    for (    AWTKeyStroke ks : entry.getValue()) {
      if (entry.getKey().equals(""String_Node_Str"") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {
        ExportedWindow window=GlobalShortcutActivator.getUIService().getExportedWindow(ExportedWindow.MAIN_WINDOW);
        if (window == null)         return;
        window.bringToFront();
        window.setVisible(true);
        if (window instanceof Window) {
          ((Window)window).setAlwaysOnTop(true);
          ((Window)window).setAlwaysOnTop(false);
        }
      }
    }
  }
}","/** 
 * Callback when an shortcut is typed
 * @param evt <tt>GlobalShortcutEvent</tt>
 */
public void shortcutReceived(GlobalShortcutEvent evt){
  AWTKeyStroke keystroke=evt.getKeyStroke();
  GlobalKeybindingSet set=keybindingsService.getGlobalBindings();
  for (  Map.Entry<String,List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {
    for (    AWTKeyStroke ks : entry.getValue()) {
      if (entry.getKey().equals(""String_Node_Str"") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {
        ExportedWindow window=GlobalShortcutActivator.getUIService().getExportedWindow(ExportedWindow.MAIN_WINDOW);
        if (window == null)         return;
        if (!window.isVisible()) {
          window.bringToFront();
          window.setVisible(true);
          if (window instanceof Window) {
            ((Window)window).setAlwaysOnTop(true);
            ((Window)window).setAlwaysOnTop(false);
          }
        }
 else {
          window.setVisible(false);
        }
      }
    }
  }
}",0.943854324734446
103301,"@Override public void keyPressed(KeyEvent event){
  this.buffer=event;
}","@Override public void keyPressed(KeyEvent event){
  if (currentRow == -1 || currentColumn == -1)   return;
  if (event.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
    GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
    List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
    if (currentColumn == 1) {
      kss.add(null);
      kss.add(en.getShortcut2());
    }
 else     if (currentColumn == 2) {
      kss.add(en.getShortcut());
      kss.add(null);
    }
    currentRow=-1;
    currentColumn=-1;
    en.setShortcuts(kss);
    en.setEditShortcut1(false);
    en.setEditShortcut2(false);
    GlobalShortcutConfigForm.this.saveConfig();
    GlobalShortcutConfigForm.this.refresh();
  }
 else {
    this.buffer=event;
  }
}",0.1342925659472422
103302,"/** 
 * Required by ListSelectionListener.
 * @param e event triggered
 */
public void valueChanged(ListSelectionEvent e){
  if (shortcutsTable.getSelectedRow() == -1) {
    currentRow=-1;
    currentColumn=-1;
  }
}","/** 
 * Required by ListSelectionListener.
 * @param e event triggered
 */
public void valueChanged(ListSelectionEvent e){
  if (shortcutsTable.getSelectedRow() == -1) {
  }
}",0.8951406649616368
103303,"@Override public void mouseClicked(MouseEvent e){
  if (e.getClickCount() >= 1) {
    int row=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedRow();
    int column=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedColumn();
    if (row >= 0 && column >= 1) {
      currentRow=row;
      currentColumn=column;
    }
  }
}","@Override public void mouseClicked(MouseEvent e){
  if (e.getClickCount() >= 1) {
    int row=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedRow();
    int column=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedColumn();
    if (currentRow != -1 && currentColumn != -1)     return;
    if (row >= 0 && column >= 1) {
      currentRow=row;
      currentColumn=column;
      if (column == 1)       GlobalShortcutConfigForm.this.tableModel.getEntryAt(row).setEditShortcut1(true);
 else       if (column == 2)       GlobalShortcutConfigForm.this.tableModel.getEntryAt(row).setEditShortcut2(true);
      refresh();
      shortcutsTable.setRowSelectionInterval(row,row);
    }
  }
}",0.6251217137293087
103304,"@Override public void keyReleased(KeyEvent event){
  if (buffer != null) {
    AWTKeyStroke input=KeyStroke.getKeyStrokeForEvent(buffer);
    buffer=null;
    if (currentRow != -1) {
      GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
      List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
      if (currentColumn == 1) {
        kss.add(input);
        kss.add(en.getShortcut2());
      }
 else       if (currentColumn == 2) {
        kss.add(en.getShortcut());
        kss.add(input);
      }
 else {
        return;
      }
      en.setShortcuts(kss);
      GlobalShortcutConfigForm.this.refresh();
      GlobalShortcutConfigForm.this.saveConfig();
    }
  }
}","@Override public void keyReleased(KeyEvent event){
  if (buffer != null) {
    AWTKeyStroke input=KeyStroke.getKeyStrokeForEvent(buffer);
    buffer=null;
    if (currentRow != -1) {
      GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
      List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
      if (currentColumn == 1) {
        kss.add(input);
        kss.add(en.getShortcut2());
      }
 else       if (currentColumn == 2) {
        kss.add(en.getShortcut());
        kss.add(input);
      }
 else {
        return;
      }
      currentRow=-1;
      currentColumn=-1;
      en.setShortcuts(kss);
      en.setEditShortcut1(false);
      en.setEditShortcut2(false);
      GlobalShortcutConfigForm.this.saveConfig();
      GlobalShortcutConfigForm.this.refresh();
    }
  }
}",0.8793215916503587
103305,"/** 
 * Initialize the swing components.
 */
private void initComponents(){
  shortcutsTable.setRowHeight(22);
  shortcutsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  shortcutsTable.setShowHorizontalLines(false);
  shortcutsTable.setShowVerticalLines(false);
  shortcutsTable.setModel(tableModel);
  shortcutsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
  shortcutsTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() >= 1) {
        int row=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedRow();
        int column=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedColumn();
        if (row >= 0 && column >= 1) {
          currentRow=row;
          currentColumn=column;
        }
      }
    }
  }
);
  shortcutsTable.addKeyListener(new KeyAdapter(){
    private KeyEvent buffer=null;
    @Override public void keyPressed(    KeyEvent event){
      this.buffer=event;
    }
    @Override public void keyReleased(    KeyEvent event){
      if (buffer != null) {
        AWTKeyStroke input=KeyStroke.getKeyStrokeForEvent(buffer);
        buffer=null;
        if (currentRow != -1) {
          GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
          List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
          if (currentColumn == 1) {
            kss.add(input);
            kss.add(en.getShortcut2());
          }
 else           if (currentColumn == 2) {
            kss.add(en.getShortcut());
            kss.add(input);
          }
 else {
            return;
          }
          en.setShortcuts(kss);
          GlobalShortcutConfigForm.this.refresh();
          GlobalShortcutConfigForm.this.saveConfig();
        }
      }
    }
  }
);
  scrollPane.getViewport().add(this.shortcutsTable);
  mainPanel.add(this.scrollPane,BorderLayout.CENTER);
  mainPanel.setPreferredSize(new Dimension(500,400));
  shortcutsTable.getSelectionModel().addListSelectionListener(this);
  loadConfig();
}","/** 
 * Initialize the swing components.
 */
private void initComponents(){
  shortcutsTable.setRowHeight(22);
  shortcutsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  shortcutsTable.setShowHorizontalLines(false);
  shortcutsTable.setShowVerticalLines(false);
  shortcutsTable.setModel(tableModel);
  shortcutsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
  shortcutsTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() >= 1) {
        int row=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedRow();
        int column=GlobalShortcutConfigForm.this.shortcutsTable.getSelectedColumn();
        if (currentRow != -1 && currentColumn != -1)         return;
        if (row >= 0 && column >= 1) {
          currentRow=row;
          currentColumn=column;
          if (column == 1)           GlobalShortcutConfigForm.this.tableModel.getEntryAt(row).setEditShortcut1(true);
 else           if (column == 2)           GlobalShortcutConfigForm.this.tableModel.getEntryAt(row).setEditShortcut2(true);
          refresh();
          shortcutsTable.setRowSelectionInterval(row,row);
        }
      }
    }
  }
);
  shortcutsTable.addKeyListener(new KeyAdapter(){
    private KeyEvent buffer=null;
    @Override public void keyPressed(    KeyEvent event){
      if (currentRow == -1 || currentColumn == -1)       return;
      if (event.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
        GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
        List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
        if (currentColumn == 1) {
          kss.add(null);
          kss.add(en.getShortcut2());
        }
 else         if (currentColumn == 2) {
          kss.add(en.getShortcut());
          kss.add(null);
        }
        currentRow=-1;
        currentColumn=-1;
        en.setShortcuts(kss);
        en.setEditShortcut1(false);
        en.setEditShortcut2(false);
        GlobalShortcutConfigForm.this.saveConfig();
        GlobalShortcutConfigForm.this.refresh();
      }
 else {
        this.buffer=event;
      }
    }
    @Override public void keyReleased(    KeyEvent event){
      if (buffer != null) {
        AWTKeyStroke input=KeyStroke.getKeyStrokeForEvent(buffer);
        buffer=null;
        if (currentRow != -1) {
          GlobalShortcutEntry en=GlobalShortcutConfigForm.this.tableModel.getEntryAt(currentRow);
          List<AWTKeyStroke> kss=new ArrayList<AWTKeyStroke>();
          if (currentColumn == 1) {
            kss.add(input);
            kss.add(en.getShortcut2());
          }
 else           if (currentColumn == 2) {
            kss.add(en.getShortcut());
            kss.add(input);
          }
 else {
            return;
          }
          currentRow=-1;
          currentColumn=-1;
          en.setShortcuts(kss);
          en.setEditShortcut1(false);
          en.setEditShortcut2(false);
          GlobalShortcutConfigForm.this.saveConfig();
          GlobalShortcutConfigForm.this.refresh();
        }
      }
    }
  }
);
  scrollPane.getViewport().add(this.shortcutsTable);
  mainPanel.add(this.scrollPane,BorderLayout.CENTER);
  mainPanel.setPreferredSize(new Dimension(500,400));
  shortcutsTable.getSelectionModel().addListSelectionListener(this);
  loadConfig();
}",0.6426193118756937
103306,"/** 
 * Returns the text for the given cell of the table
 * @param row cell row
 * @param column cell column
 * @return object at the row/column
 * @see javax.swing.table.AbstractTableModel#getValueAt
 */
public Object getValueAt(int row,int column){
switch (column) {
case 0:
    return getEntryAt(row).getAction();
case 1:
  return GlobalShortcutEntry.getShortcutText(getEntryAt(row).getShortcut());
case 2:
return GlobalShortcutEntry.getShortcutText(getEntryAt(row).getShortcut2());
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","/** 
 * Returns the text for the given cell of the table
 * @param row cell row
 * @param column cell column
 * @return object at the row/column
 * @see javax.swing.table.AbstractTableModel#getValueAt
 */
public Object getValueAt(int row,int column){
switch (column) {
case 0:
    return getEntryAt(row).getAction();
case 1:
  return getEntryAt(row).getEditShortcut1() ? ""String_Node_Str"" : GlobalShortcutEntry.getShortcutText(getEntryAt(row).getShortcut());
case 2:
return getEntryAt(row).getEditShortcut2() ? ""String_Node_Str"" : GlobalShortcutEntry.getShortcutText(getEntryAt(row).getShortcut2());
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}",0.7495908346972177
103307,"/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
    connectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(ex);
  }
}","/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    connectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}",0.6752529898804048
103308,"/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
    connectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(ex);
  }
}","/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
synchronized (connectAndLoginLock) {
      inConnectAndLogin=true;
    }
    connectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    eventDuringLogin=null;
    fireRegistrationStateChanged(ex);
  }
 finally {
synchronized (connectAndLoginLock) {
      if (eventDuringLogin != null) {
        if (eventDuringLogin.getNewState().equals(RegistrationState.CONNECTION_FAILED) || eventDuringLogin.getNewState().equals(RegistrationState.UNREGISTERED))         disconnectAndCleanConnection();
        fireRegistrationStateChanged(eventDuringLogin.getOldState(),eventDuringLogin.getNewState(),eventDuringLogin.getReasonCode(),eventDuringLogin.getReason());
        eventDuringLogin=null;
        inConnectAndLogin=false;
        return;
      }
      inConnectAndLogin=false;
    }
  }
}",0.7450244085617724
103309,"/** 
 * Loads the given chat room in the this chat conference panel. Loads all members and adds all corresponding listeners.
 * @param chatRoom the <tt>ChatRoom</tt> to load
 */
public void loadChatRoom(ChatRoom chatRoom){
  for (  ChatRoomMember member : chatRoom.getMembers())   sessionRenderer.addChatContact(new ConferenceChatContact(member));
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addMemberPresenceListener(this);
  sessionRenderer.setChatSubject(chatRoom.getSubject());
}","/** 
 * Loads the given chat room in the this chat conference panel. Loads all members and adds all corresponding listeners.
 * @param chatRoom the <tt>ChatRoom</tt> to load
 */
public void loadChatRoom(ChatRoom chatRoom){
  currentChatTransport=new ConferenceChatTransport(this,chatRoomWrapper.getChatRoom());
  chatTransports.clear();
  chatTransports.add(currentChatTransport);
  sessionRenderer.removeAllChatContacts();
  for (  ChatRoomMember member : chatRoom.getMembers()) {
    sessionRenderer.addChatContact(new ConferenceChatContact(member));
  }
  chatRoom.addPropertyChangeListener(this);
  chatRoom.addMemberPresenceListener(this);
  sessionRenderer.setChatSubject(chatRoom.getSubject());
}",0.8253968253968254
103310,"/** 
 * Returns the <tt>ChatRoomWrapper</tt> that correspond to the given <tt>ChatRoom</tt>. If the list of chat rooms doesn't contain a corresponding wrapper - returns null.
 * @param chatRoom the <tt>ChatRoom</tt> that we're looking for
 * @return the <tt>ChatRoomWrapper</tt> object corresponding to the given<tt>ChatRoom</tt>
 */
public ChatRoomWrapper findChatRoomWrapperFromChatRoom(ChatRoom chatRoom){
  for (  ChatRoomProviderWrapper provider : providersList) {
    if (!chatRoom.getParentProvider().equals(provider.getProtocolProvider()))     continue;
    ChatRoomWrapper systemRoomWrapper=provider.getSystemRoomWrapper();
    ChatRoom systemRoom=systemRoomWrapper.getChatRoom();
    if ((systemRoom != null) && systemRoom.equals(chatRoom)) {
      return systemRoomWrapper;
    }
 else {
      ChatRoomWrapper chatRoomWrapper=provider.findChatRoomWrapperForChatRoom(chatRoom);
      if (chatRoomWrapper != null) {
        if (chatRoomWrapper.getChatRoom() == null) {
          chatRoomWrapper.setChatRoom(chatRoom);
        }
        return chatRoomWrapper;
      }
    }
  }
  return null;
}","/** 
 * Returns the <tt>ChatRoomWrapper</tt> that correspond to the given <tt>ChatRoom</tt>. If the list of chat rooms doesn't contain a corresponding wrapper - returns null.
 * @param chatRoom the <tt>ChatRoom</tt> that we're looking for
 * @return the <tt>ChatRoomWrapper</tt> object corresponding to the given<tt>ChatRoom</tt>
 */
public ChatRoomWrapper findChatRoomWrapperFromChatRoom(ChatRoom chatRoom){
  for (  ChatRoomProviderWrapper provider : providersList) {
    if (!chatRoom.getParentProvider().equals(provider.getProtocolProvider()))     continue;
    ChatRoomWrapper systemRoomWrapper=provider.getSystemRoomWrapper();
    ChatRoom systemRoom=systemRoomWrapper.getChatRoom();
    if ((systemRoom != null) && systemRoom.equals(chatRoom)) {
      return systemRoomWrapper;
    }
 else {
      ChatRoomWrapper chatRoomWrapper=provider.findChatRoomWrapperForChatRoom(chatRoom);
      if (chatRoomWrapper != null) {
        if (chatRoomWrapper.getChatRoom() == null || !chatRoomWrapper.getChatRoom().equals(chatRoom)) {
          chatRoomWrapper.setChatRoom(chatRoom);
        }
        return chatRoomWrapper;
      }
    }
  }
  return null;
}",0.977403633141338
103311,"/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    supportedFeatures.clear();
    this.clearRegistrationStateChangeListener();
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null)     protocolIconPath=""String_Node_Str"";
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(""String_Node_Str"");
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    addSupportedOperationSet(OperationSetPersistentPresence.class,persistentPresence);
    addSupportedOperationSet(OperationSetPresence.class,persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue != null)     basicInstantMessaging.setKeepAliveEnabled(Boolean.parseBoolean(keepAliveStrValue));
    addSupportedOperationSet(OperationSetBasicInstantMessaging.class,basicInstantMessaging);
    addSupportedOperationSet(OperationSetWhiteboarding.class,new OperationSetWhiteboardingJabberImpl(this));
    addSupportedOperationSet(OperationSetTypingNotifications.class,new OperationSetTypingNotificationsJabberImpl(this));
    addSupportedOperationSet(OperationSetMultiUserChat.class,new OperationSetMultiUserChatJabberImpl(this));
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    addSupportedOperationSet(OperationSetServerStoredContactInfo.class,new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver));
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    addSupportedOperationSet(OperationSetServerStoredAccountInfo.class,accountInfo);
    addSupportedOperationSet(OperationSetAvatar.class,new OperationSetAvatarJabberImpl(this,accountInfo));
    addSupportedOperationSet(OperationSetFileTransfer.class,new OperationSetFileTransferJabberImpl(this));
    addSupportedOperationSet(OperationSetInstantMessageTransform.class,new OperationSetInstantMessageTransformImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    addSupportedOperationSet(OperationSetThumbnailedFileFactory.class,new OperationSetThumbnailedFileFactoryImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);
    ProviderManager providerManager=ProviderManager.getInstance();
    providerManager.addIQProvider(JingleIQ.ELEMENT_NAME,JingleIQ.NAMESPACE,new JingleIQProvider());
    providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,InputEvtIQ.NAMESPACE,new InputEvtIQProvider());
    providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,CoinIQ.NAMESPACE,new CoinIQProvider());
    supportedFeatures.add(URN_XMPP_JINGLE_COIN);
    providerManager.addIQProvider(SessionIQ.ELEMENT_NAME,SessionIQ.NAMESPACE,new SessionIQProvider());
    providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,JingleInfoQueryIQ.NAMESPACE,new JingleInfoQueryIQProvider());
    boolean isCallingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED,false);
    boolean isCallingDisabledForAccount=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,false);
    if (!isCallingDisabled && !isCallingDisabledForAccount) {
      OperationSetBasicTelephonyJabberImpl basicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      addSupportedOperationSet(OperationSetAdvancedTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetBasicTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetSecureZrtpTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetVideoTelephony.class,new OperationSetVideoTelephonyJabberImpl(basicTelephony));
      addSupportedOperationSet(OperationSetTelephonyConferencing.class,new OperationSetTelephonyConferencingJabberImpl(this));
      addJingleFeatures();
      boolean isDesktopStreamingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED,false);
      boolean isAccountDesktopStreamingDisabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,false);
      if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {
        addSupportedOperationSet(OperationSetDesktopStreaming.class,new OperationSetDesktopStreamingJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingServer.class,new OperationSetDesktopSharingServerJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingClient.class,new OperationSetDesktopSharingClientJabberImpl(this));
        supportedFeatures.add(InputEvtIQ.NAMESPACE);
      }
    }
    opsetContactCapabilities=new OperationSetContactCapabilitiesJabberImpl(this);
    if (discoveryManager != null)     opsetContactCapabilities.setDiscoveryManager(discoveryManager);
    addSupportedOperationSet(OperationSetContactCapabilities.class,opsetContactCapabilities);
    addSupportedOperationSet(OperationSetGenericNotifications.class,new OperationSetGenericNotificationsJabberImpl(this));
    isInitialized=true;
  }
}","/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    supportedFeatures.clear();
    this.clearRegistrationStateChangeListener();
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null)     protocolIconPath=""String_Node_Str"";
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(""String_Node_Str"");
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    addSupportedOperationSet(OperationSetPersistentPresence.class,persistentPresence);
    addSupportedOperationSet(OperationSetPresence.class,persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue != null)     basicInstantMessaging.setKeepAliveEnabled(Boolean.parseBoolean(keepAliveStrValue));
    addSupportedOperationSet(OperationSetBasicInstantMessaging.class,basicInstantMessaging);
    addSupportedOperationSet(OperationSetWhiteboarding.class,new OperationSetWhiteboardingJabberImpl(this));
    addSupportedOperationSet(OperationSetTypingNotifications.class,new OperationSetTypingNotificationsJabberImpl(this));
    addSupportedOperationSet(OperationSetMultiUserChat.class,new OperationSetMultiUserChatJabberImpl(this));
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    addSupportedOperationSet(OperationSetServerStoredContactInfo.class,new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver));
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    addSupportedOperationSet(OperationSetServerStoredAccountInfo.class,accountInfo);
    addSupportedOperationSet(OperationSetAvatar.class,new OperationSetAvatarJabberImpl(this,accountInfo));
    addSupportedOperationSet(OperationSetFileTransfer.class,new OperationSetFileTransferJabberImpl(this));
    addSupportedOperationSet(OperationSetInstantMessageTransform.class,new OperationSetInstantMessageTransformImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    addSupportedOperationSet(OperationSetThumbnailedFileFactory.class,new OperationSetThumbnailedFileFactoryImpl());
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);
    ProviderManager providerManager=ProviderManager.getInstance();
    providerManager.addIQProvider(JingleIQ.ELEMENT_NAME,JingleIQ.NAMESPACE,new JingleIQProvider());
    providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,InputEvtIQ.NAMESPACE,new InputEvtIQProvider());
    providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,CoinIQ.NAMESPACE,new CoinIQProvider());
    supportedFeatures.add(URN_XMPP_JINGLE_COIN);
    providerManager.addIQProvider(SessionIQ.ELEMENT_NAME,SessionIQ.NAMESPACE,new SessionIQProvider());
    providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,JingleInfoQueryIQ.NAMESPACE,new JingleInfoQueryIQProvider());
    boolean isCallingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED,false);
    boolean isCallingDisabledForAccount=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,false);
    if (!isCallingDisabled && !isCallingDisabledForAccount) {
      OperationSetBasicTelephonyJabberImpl basicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      addSupportedOperationSet(OperationSetAdvancedTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetBasicTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetSecureZrtpTelephony.class,basicTelephony);
      addSupportedOperationSet(OperationSetVideoTelephony.class,new OperationSetVideoTelephonyJabberImpl(basicTelephony));
      addSupportedOperationSet(OperationSetTelephonyConferencing.class,new OperationSetTelephonyConferencingJabberImpl(this));
      addJingleFeatures();
      boolean isDesktopStreamingDisabled=JabberActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED,false);
      boolean isAccountDesktopStreamingDisabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,false);
      if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {
        addSupportedOperationSet(OperationSetDesktopStreaming.class,new OperationSetDesktopStreamingJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingServer.class,new OperationSetDesktopSharingServerJabberImpl(basicTelephony));
        addSupportedOperationSet(OperationSetDesktopSharingClient.class,new OperationSetDesktopSharingClientJabberImpl(this));
        supportedFeatures.add(InputEvtIQ.NAMESPACE);
      }
    }
    opsetContactCapabilities=new OperationSetContactCapabilitiesJabberImpl(this);
    if (discoveryManager != null)     opsetContactCapabilities.setDiscoveryManager(discoveryManager);
    addSupportedOperationSet(OperationSetContactCapabilities.class,opsetContactCapabilities);
    addSupportedOperationSet(OperationSetGenericNotifications.class,new OperationSetGenericNotificationsJabberImpl(this));
    SmackConfiguration.setPacketReplyTimeout(45000);
    isInitialized=true;
  }
}",0.9958421589393582
103312,"/** 
 * Event when an entry is updated. Something for the entry data or have been added to a new group or removed from one
 * @param addresses Collection
 */
public void entriesUpdated(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String contactID : addresses) {
    RosterEntry entry=roster.getEntry(contactID);
    ContactJabberImpl contact=findContactById(contactID);
    if (contact == null && isEntryDisplayable(entry)) {
      contact=addEntryToContactList(contactID);
    }
    for (    RosterGroup gr : entry.getGroups()) {
      if (findContactGroup(gr.getName()) == null) {
        ContactGroupJabberImpl group=findContactGroupByNameCopy(gr.getName());
        if (group != null) {
          group.setSourceGroup(gr);
          fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RENAMED_EVENT);
        }
 else {
        }
      }
 else {
        ContactGroup contactGroup=contact.getParentContactGroup();
        if (!gr.getName().equals(contactGroup.getGroupName())) {
          if (contactGroup instanceof ContactGroupJabberImpl)           ((ContactGroupJabberImpl)contactGroup).removeContact(contact);
 else           if (contactGroup instanceof RootContactGroupJabberImpl)           ((RootContactGroupJabberImpl)contactGroup).removeContact(contact);
          ContactGroupJabberImpl newParentGroup=findContactGroup(gr.getName());
          newParentGroup.addContact(contact);
          fireContactMoved(contactGroup,newParentGroup,contact);
        }
      }
    }
  }
}","/** 
 * Event when an entry is updated. Something for the entry data or have been added to a new group or removed from one
 * @param addresses Collection
 */
public void entriesUpdated(Collection<String> addresses){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + addresses);
  for (  String contactID : addresses) {
    RosterEntry entry=roster.getEntry(contactID);
    ContactJabberImpl contact=findContactById(contactID);
    if (contact != null && (contact instanceof VolatileContactJabberImpl)) {
      contact=null;
    }
    if (contact == null && isEntryDisplayable(entry)) {
      contact=addEntryToContactList(contactID);
    }
    for (    RosterGroup gr : entry.getGroups()) {
      if (findContactGroup(gr.getName()) == null) {
        ContactGroupJabberImpl group=findContactGroupByNameCopy(gr.getName());
        if (group != null) {
          group.setSourceGroup(gr);
          fireGroupEvent(group,ServerStoredGroupEvent.GROUP_RENAMED_EVENT);
        }
 else {
        }
      }
 else {
        ContactGroup contactGroup=contact.getParentContactGroup();
        if (!gr.getName().equals(contactGroup.getGroupName())) {
          if (contactGroup instanceof ContactGroupJabberImpl)           ((ContactGroupJabberImpl)contactGroup).removeContact(contact);
 else           if (contactGroup instanceof RootContactGroupJabberImpl)           ((RootContactGroupJabberImpl)contactGroup).removeContact(contact);
          ContactGroupJabberImpl newParentGroup=findContactGroup(gr.getName());
          newParentGroup.addContact(contact);
          fireContactMoved(contactGroup,newParentGroup,contact);
        }
      }
    }
  }
}",0.9679626749611198
103313,"public int compare(Presence o1,Presence o2){
  int res=o1.getPriority() - o2.getPriority();
  if (res == 0) {
    res=jabberStatusToPresenceStatus(o1,parentProvider).getStatus() - jabberStatusToPresenceStatus(o2,parentProvider).getStatus();
  }
  return res;
}","public int compare(Presence o1,Presence o2){
  int res=o2.getPriority() - o1.getPriority();
  if (res == 0) {
    res=jabberStatusToPresenceStatus(o2,parentProvider).getStatus() - jabberStatusToPresenceStatus(o1,parentProvider).getStatus();
  }
  return res;
}",0.5923076923076923
103314,"/** 
 * Fires the status change, respecting resource priorities.
 * @param presence the presence changed.
 */
void firePresenceStatusChanged(Presence presence){
  try {
    String userID=StringUtils.parseBareAddress(presence.getFrom());
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + userID);
    TreeSet<Presence> userStats=statuses.get(userID);
    if (userStats == null) {
      userStats=new TreeSet<Presence>(new Comparator<Presence>(){
        public int compare(        Presence o1,        Presence o2){
          int res=o1.getPriority() - o2.getPriority();
          if (res == 0) {
            res=jabberStatusToPresenceStatus(o1,parentProvider).getStatus() - jabberStatusToPresenceStatus(o2,parentProvider).getStatus();
          }
          return res;
        }
      }
);
      statuses.put(userID,userStats);
    }
 else {
      String resource=StringUtils.parseResource(presence.getFrom());
      for (Iterator<Presence> iter=userStats.iterator(); iter.hasNext(); ) {
        Presence p=iter.next();
        if (StringUtils.parseResource(p.getFrom()).equals(resource))         iter.remove();
      }
    }
    if (!jabberStatusToPresenceStatus(presence,parentProvider).equals(parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE))) {
      userStats.add(presence);
    }
    Presence currentPresence;
    if (userStats.size() == 0) {
      currentPresence=presence;
      statuses.remove(userID);
    }
 else     currentPresence=userStats.first();
    ContactJabberImpl sourceContact=ssContactList.findContactById(userID);
    if (sourceContact == null) {
      logger.warn(""String_Node_Str"" + userID);
      return;
    }
    sourceContact.setStatusMessage(currentPresence.getStatus());
    PresenceStatus oldStatus=sourceContact.getPresenceStatus();
    PresenceStatus newStatus=jabberStatusToPresenceStatus(currentPresence,parentProvider);
    if (oldStatus.equals(newStatus))     return;
    sourceContact.updatePresenceStatus(newStatus);
    ContactGroup parent=ssContactList.findContactGroup(sourceContact);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    fireContactPresenceStatusChangeEvent(sourceContact,parent,oldStatus,newStatus);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}","/** 
 * Fires the status change, respecting resource priorities.
 * @param presence the presence changed.
 */
void firePresenceStatusChanged(Presence presence){
  try {
    String userID=StringUtils.parseBareAddress(presence.getFrom());
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + userID);
    TreeSet<Presence> userStats=statuses.get(userID);
    if (userStats == null) {
      userStats=new TreeSet<Presence>(new Comparator<Presence>(){
        public int compare(        Presence o1,        Presence o2){
          int res=o2.getPriority() - o1.getPriority();
          if (res == 0) {
            res=jabberStatusToPresenceStatus(o2,parentProvider).getStatus() - jabberStatusToPresenceStatus(o1,parentProvider).getStatus();
          }
          return res;
        }
      }
);
      statuses.put(userID,userStats);
    }
 else {
      String resource=StringUtils.parseResource(presence.getFrom());
      for (Iterator<Presence> iter=userStats.iterator(); iter.hasNext(); ) {
        Presence p=iter.next();
        if (StringUtils.parseResource(p.getFrom()).equals(resource))         iter.remove();
      }
    }
    if (!jabberStatusToPresenceStatus(presence,parentProvider).equals(parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE))) {
      userStats.add(presence);
    }
    Presence currentPresence;
    if (userStats.size() == 0) {
      currentPresence=presence;
      statuses.remove(userID);
    }
 else     currentPresence=userStats.first();
    ContactJabberImpl sourceContact=ssContactList.findContactById(userID);
    if (sourceContact == null) {
      logger.warn(""String_Node_Str"" + userID);
      return;
    }
    sourceContact.setStatusMessage(currentPresence.getStatus());
    PresenceStatus oldStatus=sourceContact.getPresenceStatus();
    PresenceStatus newStatus=jabberStatusToPresenceStatus(currentPresence,parentProvider);
    if (oldStatus.equals(newStatus))     return;
    sourceContact.updatePresenceStatus(newStatus);
    ContactGroup parent=ssContactList.findContactGroup(sourceContact);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    fireContactPresenceStatusChangeEvent(sourceContact,parent,oldStatus,newStatus);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.9912390488110138
103315,"@Override public UIVideoHandler getVideoHandler(){
  return videoHandler;
}","public UIVideoHandler getVideoHandler(){
  return videoHandler;
}",0.9285714285714286
103316,"/** 
 * Ends the call with for this <tt>CallPeer</tt>. Depending on the state of the peer the method would send a CANCEL, BYE, or BUSY_HERE message and set the new state to DISCONNECTED.
 * @param reasonText the text, if any, to be set on the<tt>ReasonPacketExtension</tt> as the value of its
 * @param reasonOtherExtension the <tt>PacketExtension</tt>, if any, to beset on the <tt>ReasonPacketExtension</tt> as the value of its <tt>otherExtension</tt> property
 */
public void hangup(String reasonText,PacketExtension reasonOtherExtension){
  if (CallPeerState.DISCONNECTED.equals(getState()) || CallPeerState.FAILED.equals(getState())) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerState prevPeerState=getState();
  getMediaHandler().getTransportManager().close();
  setState(CallPeerState.DISCONNECTED);
  JingleIQ responseIQ=null;
  if (prevPeerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(prevPeerState)) {
    responseIQ=JinglePacketFactory.createBye(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (CallPeerState.CONNECTING.equals(prevPeerState) || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(prevPeerState) || CallPeerState.ALERTING_REMOTE_SIDE.equals(prevPeerState)) {
    responseIQ=JinglePacketFactory.createCancel(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.INCOMING_CALL)) {
    responseIQ=JinglePacketFactory.createBusy(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.BUSY) || prevPeerState.equals(CallPeerState.FAILED)) {
  }
 else {
    logger.info(""String_Node_Str"");
  }
  if (responseIQ != null) {
    if (reasonOtherExtension != null) {
      ReasonPacketExtension reason=(ReasonPacketExtension)responseIQ.getExtension(ReasonPacketExtension.ELEMENT_NAME,ReasonPacketExtension.NAMESPACE);
      if (reason != null)       reason.setOtherExtension(reasonOtherExtension);
    }
    getProtocolProvider().getConnection().sendPacket(responseIQ);
  }
}","/** 
 * Ends the call with for this <tt>CallPeer</tt>. Depending on the state of the peer the method would send a CANCEL, BYE, or BUSY_HERE message and set the new state to DISCONNECTED.
 * @param reasonText the text, if any, to be set on the<tt>ReasonPacketExtension</tt> as the value of its
 * @param reasonOtherExtension the <tt>PacketExtension</tt>, if any, to beset on the <tt>ReasonPacketExtension</tt> as the value of its <tt>otherExtension</tt> property
 */
public void hangup(String reasonText,PacketExtension reasonOtherExtension){
  if (CallPeerState.DISCONNECTED.equals(getState()) || CallPeerState.FAILED.equals(getState())) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerState prevPeerState=getState();
  getMediaHandler().getTransportManager().close();
  setState(CallPeerState.DISCONNECTED);
  JingleIQ responseIQ=null;
  if (prevPeerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(prevPeerState)) {
    responseIQ=JinglePacketFactory.createBye(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (CallPeerState.CONNECTING.equals(prevPeerState) || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(prevPeerState) || CallPeerState.ALERTING_REMOTE_SIDE.equals(prevPeerState)) {
    String jingleSID=getJingleSID();
    if (jingleSID == null) {
synchronized (sidSyncRoot) {
        cancelled=true;
        return;
      }
    }
    responseIQ=JinglePacketFactory.createCancel(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.INCOMING_CALL)) {
    responseIQ=JinglePacketFactory.createBusy(getProtocolProvider().getOurJID(),peerJID,getJingleSID());
  }
 else   if (prevPeerState.equals(CallPeerState.BUSY) || prevPeerState.equals(CallPeerState.FAILED)) {
  }
 else {
    logger.info(""String_Node_Str"");
  }
  if (responseIQ != null) {
    if (reasonOtherExtension != null) {
      ReasonPacketExtension reason=(ReasonPacketExtension)responseIQ.getExtension(ReasonPacketExtension.ELEMENT_NAME,ReasonPacketExtension.NAMESPACE);
      if (reason != null)       reason.setOtherExtension(reasonOtherExtension);
    }
    getProtocolProvider().getConnection().sendPacket(responseIQ);
  }
}",0.9659739666590546
103317,"/** 
 * Processes the session initiation   {@link JingleIQ} that we were createdwith, passing its content to the media handler and then sends either a ""session-info/ringing"" or a ""session-terminate"" response.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to initiate the session with this<tt>CallPeerJabberImpl</tt>
 * @throws OperationFailedException exception
 */
protected synchronized void initiateSession(Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  isInitiator=false;
  List<ContentPacketExtension> offer=getMediaHandler().createContentList();
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  sessionInitIQ=JinglePacketFactory.createSessionInitiate(protocolProvider.getOurJID(),this.peerJID,JingleIQ.generateSID(),offer);
  if (sessionInitiateExtensions != null) {
    for (    PacketExtension sessionInitiateExtension : sessionInitiateExtensions) {
      sessionInitIQ.addExtension(sessionInitiateExtension);
    }
  }
  protocolProvider.getConnection().sendPacket(sessionInitIQ);
}","/** 
 * Processes the session initiation   {@link JingleIQ} that we were createdwith, passing its content to the media handler and then sends either a ""session-info/ringing"" or a ""session-terminate"" response.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to initiate the session with this<tt>CallPeerJabberImpl</tt>
 * @throws OperationFailedException exception
 */
protected synchronized void initiateSession(Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  isInitiator=false;
  List<ContentPacketExtension> offer=getMediaHandler().createContentList();
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
synchronized (sidSyncRoot) {
    sessionInitIQ=JinglePacketFactory.createSessionInitiate(protocolProvider.getOurJID(),this.peerJID,JingleIQ.generateSID(),offer);
    if (cancelled) {
      getMediaHandler().getTransportManager().close();
      return;
    }
  }
  if (sessionInitiateExtensions != null) {
    for (    PacketExtension sessionInitiateExtension : sessionInitiateExtensions) {
      sessionInitIQ.addExtension(sessionInitiateExtension);
    }
  }
  protocolProvider.getConnection().sendPacket(sessionInitIQ);
}",0.9503599848427434
103318,"/** 
 * Sends local candidate addresses from the local peer to the remote peer using the <tt>transport-info</tt>   {@link JingleIQ}.
 * @param contents the local candidate addresses to be sent from the localpeer to the remote peer using the <tt>transport-info</tt> {@link JingleIQ}
 */
protected void sendTransportInfo(Iterable<ContentPacketExtension> contents){
  JingleIQ transportInfo=new JingleIQ();
  for (  ContentPacketExtension content : contents)   transportInfo.addContent(content);
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  transportInfo.setAction(JingleAction.TRANSPORT_INFO);
  transportInfo.setFrom(protocolProvider.getOurJID());
  transportInfo.setSID(getJingleSID());
  transportInfo.setTo(getAddress());
  transportInfo.setType(IQ.Type.SET);
  protocolProvider.getConnection().sendPacket(transportInfo);
}","/** 
 * Sends local candidate addresses from the local peer to the remote peer using the <tt>transport-info</tt>   {@link JingleIQ}.
 * @param contents the local candidate addresses to be sent from the localpeer to the remote peer using the <tt>transport-info</tt> {@link JingleIQ}
 */
protected void sendTransportInfo(Iterable<ContentPacketExtension> contents){
  if (cancelled)   return;
  JingleIQ transportInfo=new JingleIQ();
  for (  ContentPacketExtension content : contents)   transportInfo.addContent(content);
  ProtocolProviderServiceJabberImpl protocolProvider=getProtocolProvider();
  transportInfo.setAction(JingleAction.TRANSPORT_INFO);
  transportInfo.setFrom(protocolProvider.getOurJID());
  transportInfo.setSID(getJingleSID());
  transportInfo.setTo(getAddress());
  transportInfo.setType(IQ.Type.SET);
  protocolProvider.getConnection().sendPacket(transportInfo);
}",0.9845094664371772
103319,"/** 
 * Indicates if the form is an advanced form.
 * @return <tt>true</tt> to indicate that this is an advanced form,otherwise returns <tt>false</tt>
 */
public boolean isAdvanced(){
  return true;
}","/** 
 * Indicates if the form is an advanced form.
 * @return <tt>true</tt> to indicate that this is an advanced form,otherwise returns <tt>false</tt>
 */
public boolean isAdvanced(){
  return false;
}",0.9825436408977556
103320,"/** 
 * Sets the default font color.
 * @param fontFamily the default font color
 */
public static void setChatDefaultFontColor(Color fontColor){
  defaultFontColor=fontColor.getRGB();
  configService.setProperty(""String_Node_Str"",defaultFontColor);
}","/** 
 * Sets the default font color.
 * @param fontColor the default font color
 */
public static void setChatDefaultFontColor(Color fontColor){
  defaultFontColor=fontColor.getRGB();
  configService.setProperty(""String_Node_Str"",defaultFontColor);
}",0.9780439121756488
103321,"/** 
 * Loads all user interface configurations.
 */
public static void loadGuiConfigurations(){
  configService.addPropertyChangeListener(new ConfigurationChangeListener());
  String autoPopupProperty=""String_Node_Str"";
  String autoPopup=configService.getString(autoPopupProperty);
  if (autoPopup == null)   autoPopup=GuiActivator.getResources().getSettingsString(autoPopupProperty);
  if (autoPopup != null && autoPopup.equalsIgnoreCase(""String_Node_Str""))   autoPopupNewMessage=true;
  String messageCommandProperty=""String_Node_Str"";
  String messageCommand=configService.getString(messageCommandProperty);
  if (messageCommand == null)   messageCommand=GuiActivator.getResources().getSettingsString(messageCommandProperty);
  if (messageCommand == null || messageCommand.length() == 0)   sendMessageCommand=messageCommand;
  String callPanelShown=configService.getString(""String_Node_Str"");
  if (callPanelShown != null && callPanelShown.length() > 0) {
    isCallPanelShown=Boolean.parseBoolean(callPanelShown);
  }
  String showOffline=configService.getString(""String_Node_Str"");
  if (showOffline != null && showOffline.length() > 0) {
    isShowOffline=Boolean.parseBoolean(showOffline);
  }
  String isVisible=configService.getString(""String_Node_Str"");
  if (isVisible != null && isVisible.length() > 0) {
    isApplicationVisible=new Boolean(isVisible).booleanValue();
  }
  String quitWarningShown=configService.getString(""String_Node_Str"");
  if (quitWarningShown != null && quitWarningShown.length() > 0) {
    isQuitWarningShown=Boolean.parseBoolean(quitWarningShown);
  }
  String isSendTypingNotifProperty=""String_Node_Str"";
  String isSendTypingNotif=configService.getString(isSendTypingNotifProperty);
  if (isSendTypingNotif == null)   isSendTypingNotif=GuiActivator.getResources().getSettingsString(isSendTypingNotifProperty);
  if (isSendTypingNotif != null && isSendTypingNotif.length() > 0) {
    isSendTypingNotifications=Boolean.parseBoolean(isSendTypingNotif);
  }
  String isMoveContactConfirmationRequestedString=configService.getString(""String_Node_Str"");
  if (isMoveContactConfirmationRequestedString != null && isMoveContactConfirmationRequestedString.length() > 0) {
    isMoveContactConfirmationRequested=Boolean.parseBoolean(isMoveContactConfirmationRequestedString);
  }
  String isMultiChatWindowEnabledStringProperty=""String_Node_Str"";
  String isMultiChatWindowEnabledString=configService.getString(isMultiChatWindowEnabledStringProperty);
  if (isMultiChatWindowEnabledString == null)   isMultiChatWindowEnabledString=GuiActivator.getResources().getSettingsString(isMultiChatWindowEnabledStringProperty);
  if (isMultiChatWindowEnabledString != null && isMultiChatWindowEnabledString.length() > 0) {
    isMultiChatWindowEnabled=Boolean.parseBoolean(isMultiChatWindowEnabledString);
  }
  String isLeaveChatRoomOnWindowCloseEnabledStringProperty=""String_Node_Str"";
  String isLeaveChatRoomOnWindowCloseEnabledString=configService.getString(isLeaveChatRoomOnWindowCloseEnabledStringProperty);
  if (isLeaveChatRoomOnWindowCloseEnabledString == null)   isLeaveChatRoomOnWindowCloseEnabledString=GuiActivator.getResources().getSettingsString(isLeaveChatRoomOnWindowCloseEnabledStringProperty);
  if (isLeaveChatRoomOnWindowCloseEnabledString != null && isLeaveChatRoomOnWindowCloseEnabledString.length() > 0) {
    isLeaveChatRoomOnWindowCloseEnabled=new Boolean(isLeaveChatRoomOnWindowCloseEnabledString).booleanValue();
  }
  String isHistoryLoggingEnabledString=configService.getString(""String_Node_Str"");
  if (isHistoryLoggingEnabledString != null && isHistoryLoggingEnabledString.length() > 0) {
    isHistoryLoggingEnabled=Boolean.parseBoolean(isHistoryLoggingEnabledString);
  }
  String isHistoryShownStringProperty=""String_Node_Str"";
  String isHistoryShownString=configService.getString(isHistoryShownStringProperty);
  if (isHistoryShownString == null)   isHistoryShownString=GuiActivator.getResources().getSettingsString(isHistoryShownStringProperty);
  if (isHistoryShownString != null && isHistoryShownString.length() > 0) {
    isHistoryShown=Boolean.parseBoolean(isHistoryShownString);
  }
  String chatHistorySizeStringProperty=""String_Node_Str"";
  String chatHistorySizeString=configService.getString(chatHistorySizeStringProperty);
  if (chatHistorySizeString == null)   chatHistorySizeString=GuiActivator.getResources().getSettingsString(chatHistorySizeStringProperty);
  if (chatHistorySizeString != null && chatHistorySizeString.length() > 0) {
    chatHistorySize=Integer.parseInt(chatHistorySizeString);
  }
  String chatWriteAreaSizeStringProperty=""String_Node_Str"";
  String chatWriteAreaSizeString=configService.getString(chatWriteAreaSizeStringProperty);
  if (chatWriteAreaSizeString == null)   chatWriteAreaSizeString=GuiActivator.getResources().getSettingsString(chatWriteAreaSizeStringProperty);
  if (chatWriteAreaSizeString != null && chatWriteAreaSizeString.length() > 0) {
    chatWriteAreaSize=Integer.parseInt(chatWriteAreaSizeString);
  }
  String isTransparentWindowEnabledProperty=""String_Node_Str"";
  String isTransparentWindowEnabledString=configService.getString(isTransparentWindowEnabledProperty);
  if (isTransparentWindowEnabledString == null)   isTransparentWindowEnabledString=GuiActivator.getResources().getSettingsString(isTransparentWindowEnabledProperty);
  if (isTransparentWindowEnabledString != null && isTransparentWindowEnabledString.length() > 0) {
    isTransparentWindowEnabled=Boolean.parseBoolean(isTransparentWindowEnabledString);
  }
  String windowTransparencyProperty=""String_Node_Str"";
  String windowTransparencyString=configService.getString(windowTransparencyProperty);
  if (windowTransparencyString == null)   windowTransparencyString=GuiActivator.getResources().getSettingsString(windowTransparencyProperty);
  if (windowTransparencyString != null && windowTransparencyString.length() > 0) {
    windowTransparency=Integer.parseInt(windowTransparencyString);
  }
  String isWindowDecoratedProperty=""String_Node_Str"";
  String isWindowDecoratedString=configService.getString(isWindowDecoratedProperty);
  if (isWindowDecoratedString == null)   isWindowDecoratedString=GuiActivator.getResources().getSettingsString(isWindowDecoratedProperty);
  if (isWindowDecoratedString != null && isWindowDecoratedString.length() > 0) {
    isWindowDecorated=Boolean.parseBoolean(isWindowDecoratedString);
  }
  isChatToolbarVisible=configService.getBoolean(""String_Node_Str"",true);
  isChatStylebarVisible=configService.getBoolean(""String_Node_Str"",true);
  isShowSmileys=configService.getBoolean(""String_Node_Str"",true);
  lastContactParent=configService.getString(""String_Node_Str"");
  sendFileLastDir=configService.getString(""String_Node_Str"" + ""String_Node_Str"");
  isAddContactDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",false);
  isRemoveContactDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",false);
  String advancedConfigDisabledDefaultProp=GuiActivator.getResources().getSettingsString(""String_Node_Str"");
  boolean isAdvancedConfigDisabled=false;
  if (advancedConfigDisabledDefaultProp != null)   isAdvancedConfigDisabled=Boolean.parseBoolean(advancedConfigDisabledDefaultProp);
  isAdvancedAccountConfigDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",isAdvancedConfigDisabled);
  defaultFontFamily=configService.getString(""String_Node_Str"");
  defaultFontSize=configService.getString(""String_Node_Str"");
  isDefaultFontBold=configService.getBoolean(""String_Node_Str"",isDefaultFontBold);
  isDefaultFontItalic=configService.getBoolean(""String_Node_Str"",isDefaultFontItalic);
  isDefaultFontUnderline=configService.getBoolean(""String_Node_Str"",isDefaultFontUnderline);
  defaultFontColor=configService.getInt(""String_Node_Str"",0);
}","/** 
 * Loads all user interface configurations.
 */
public static void loadGuiConfigurations(){
  configService.addPropertyChangeListener(new ConfigurationChangeListener());
  String autoPopupProperty=""String_Node_Str"";
  String autoPopup=configService.getString(autoPopupProperty);
  if (autoPopup == null)   autoPopup=GuiActivator.getResources().getSettingsString(autoPopupProperty);
  if (autoPopup != null && autoPopup.equalsIgnoreCase(""String_Node_Str""))   autoPopupNewMessage=true;
  String messageCommandProperty=""String_Node_Str"";
  String messageCommand=configService.getString(messageCommandProperty);
  if (messageCommand == null)   messageCommand=GuiActivator.getResources().getSettingsString(messageCommandProperty);
  if (messageCommand == null || messageCommand.length() == 0)   sendMessageCommand=messageCommand;
  String callPanelShown=configService.getString(""String_Node_Str"");
  if (callPanelShown != null && callPanelShown.length() > 0) {
    isCallPanelShown=Boolean.parseBoolean(callPanelShown);
  }
  String showOffline=configService.getString(""String_Node_Str"");
  if (showOffline != null && showOffline.length() > 0) {
    isShowOffline=Boolean.parseBoolean(showOffline);
  }
  String isVisible=configService.getString(""String_Node_Str"");
  if (isVisible != null && isVisible.length() > 0) {
    isApplicationVisible=new Boolean(isVisible).booleanValue();
  }
  String quitWarningShown=configService.getString(""String_Node_Str"");
  if (quitWarningShown != null && quitWarningShown.length() > 0) {
    isQuitWarningShown=Boolean.parseBoolean(quitWarningShown);
  }
  String isSendTypingNotifProperty=""String_Node_Str"";
  String isSendTypingNotif=configService.getString(isSendTypingNotifProperty);
  if (isSendTypingNotif == null)   isSendTypingNotif=GuiActivator.getResources().getSettingsString(isSendTypingNotifProperty);
  if (isSendTypingNotif != null && isSendTypingNotif.length() > 0) {
    isSendTypingNotifications=Boolean.parseBoolean(isSendTypingNotif);
  }
  String isMoveContactConfirmationRequestedString=configService.getString(""String_Node_Str"");
  if (isMoveContactConfirmationRequestedString != null && isMoveContactConfirmationRequestedString.length() > 0) {
    isMoveContactConfirmationRequested=Boolean.parseBoolean(isMoveContactConfirmationRequestedString);
  }
  String isMultiChatWindowEnabledStringProperty=""String_Node_Str"";
  String isMultiChatWindowEnabledString=configService.getString(isMultiChatWindowEnabledStringProperty);
  if (isMultiChatWindowEnabledString == null)   isMultiChatWindowEnabledString=GuiActivator.getResources().getSettingsString(isMultiChatWindowEnabledStringProperty);
  if (isMultiChatWindowEnabledString != null && isMultiChatWindowEnabledString.length() > 0) {
    isMultiChatWindowEnabled=Boolean.parseBoolean(isMultiChatWindowEnabledString);
  }
  String isLeaveChatRoomOnWindowCloseEnabledStringProperty=""String_Node_Str"";
  String isLeaveChatRoomOnWindowCloseEnabledString=configService.getString(isLeaveChatRoomOnWindowCloseEnabledStringProperty);
  if (isLeaveChatRoomOnWindowCloseEnabledString == null)   isLeaveChatRoomOnWindowCloseEnabledString=GuiActivator.getResources().getSettingsString(isLeaveChatRoomOnWindowCloseEnabledStringProperty);
  if (isLeaveChatRoomOnWindowCloseEnabledString != null && isLeaveChatRoomOnWindowCloseEnabledString.length() > 0) {
    isLeaveChatRoomOnWindowCloseEnabled=new Boolean(isLeaveChatRoomOnWindowCloseEnabledString).booleanValue();
  }
  String isHistoryLoggingEnabledString=configService.getString(""String_Node_Str"");
  if (isHistoryLoggingEnabledString != null && isHistoryLoggingEnabledString.length() > 0) {
    isHistoryLoggingEnabled=Boolean.parseBoolean(isHistoryLoggingEnabledString);
  }
  String isHistoryShownStringProperty=""String_Node_Str"";
  String isHistoryShownString=configService.getString(isHistoryShownStringProperty);
  if (isHistoryShownString == null)   isHistoryShownString=GuiActivator.getResources().getSettingsString(isHistoryShownStringProperty);
  if (isHistoryShownString != null && isHistoryShownString.length() > 0) {
    isHistoryShown=Boolean.parseBoolean(isHistoryShownString);
  }
  String chatHistorySizeStringProperty=""String_Node_Str"";
  String chatHistorySizeString=configService.getString(chatHistorySizeStringProperty);
  if (chatHistorySizeString == null)   chatHistorySizeString=GuiActivator.getResources().getSettingsString(chatHistorySizeStringProperty);
  if (chatHistorySizeString != null && chatHistorySizeString.length() > 0) {
    chatHistorySize=Integer.parseInt(chatHistorySizeString);
  }
  String chatWriteAreaSizeStringProperty=""String_Node_Str"";
  String chatWriteAreaSizeString=configService.getString(chatWriteAreaSizeStringProperty);
  if (chatWriteAreaSizeString == null)   chatWriteAreaSizeString=GuiActivator.getResources().getSettingsString(chatWriteAreaSizeStringProperty);
  if (chatWriteAreaSizeString != null && chatWriteAreaSizeString.length() > 0) {
    chatWriteAreaSize=Integer.parseInt(chatWriteAreaSizeString);
  }
  String isTransparentWindowEnabledProperty=""String_Node_Str"";
  String isTransparentWindowEnabledString=configService.getString(isTransparentWindowEnabledProperty);
  if (isTransparentWindowEnabledString == null)   isTransparentWindowEnabledString=GuiActivator.getResources().getSettingsString(isTransparentWindowEnabledProperty);
  if (isTransparentWindowEnabledString != null && isTransparentWindowEnabledString.length() > 0) {
    isTransparentWindowEnabled=Boolean.parseBoolean(isTransparentWindowEnabledString);
  }
  String windowTransparencyProperty=""String_Node_Str"";
  String windowTransparencyString=configService.getString(windowTransparencyProperty);
  if (windowTransparencyString == null)   windowTransparencyString=GuiActivator.getResources().getSettingsString(windowTransparencyProperty);
  if (windowTransparencyString != null && windowTransparencyString.length() > 0) {
    windowTransparency=Integer.parseInt(windowTransparencyString);
  }
  String isWindowDecoratedProperty=""String_Node_Str"";
  String isWindowDecoratedString=configService.getString(isWindowDecoratedProperty);
  if (isWindowDecoratedString == null)   isWindowDecoratedString=GuiActivator.getResources().getSettingsString(isWindowDecoratedProperty);
  if (isWindowDecoratedString != null && isWindowDecoratedString.length() > 0) {
    isWindowDecorated=Boolean.parseBoolean(isWindowDecoratedString);
  }
  isChatToolbarVisible=configService.getBoolean(""String_Node_Str"",true);
  isChatStylebarVisible=configService.getBoolean(""String_Node_Str"",true);
  isShowSmileys=configService.getBoolean(""String_Node_Str"",true);
  lastContactParent=configService.getString(""String_Node_Str"");
  sendFileLastDir=configService.getString(""String_Node_Str"" + ""String_Node_Str"");
  isAddContactDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",false);
  isRemoveContactDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",false);
  String advancedConfigDisabledDefaultProp=GuiActivator.getResources().getSettingsString(""String_Node_Str"");
  boolean isAdvancedConfigDisabled=false;
  if (advancedConfigDisabledDefaultProp != null)   isAdvancedConfigDisabled=Boolean.parseBoolean(advancedConfigDisabledDefaultProp);
  isAdvancedAccountConfigDisabled=configService.getBoolean(""String_Node_Str"" + ""String_Node_Str"",isAdvancedConfigDisabled);
  defaultFontFamily=configService.getString(""String_Node_Str"");
  defaultFontSize=configService.getString(""String_Node_Str"");
  isDefaultFontBold=configService.getBoolean(""String_Node_Str"",isDefaultFontBold);
  isDefaultFontItalic=configService.getBoolean(""String_Node_Str"",isDefaultFontItalic);
  isDefaultFontUnderline=configService.getBoolean(""String_Node_Str"",isDefaultFontUnderline);
  int colorSetting=configService.getInt(""String_Node_Str"",-1);
  if (colorSetting != -1)   defaultFontColor=colorSetting;
}",0.9940142638818136
103322,"/** 
 * Sets the default isItalic property.
 * @param isBold indicates if the default chat font is italic
 */
public static void setChatFontIsItalic(boolean isItalic){
  isDefaultFontItalic=isItalic;
  configService.setProperty(""String_Node_Str"",isItalic);
}","/** 
 * Sets the default isItalic property.
 * @param isItalic indicates if the default chat font is italic
 */
public static void setChatFontIsItalic(boolean isItalic){
  isDefaultFontItalic=isItalic;
  configService.setProperty(""String_Node_Str"",isItalic);
}",0.9806949806949808
103323,"/** 
 * Returns the default chat font color.
 * @return the default chat font color
 */
public static Color getChatDefaultFontColor(){
  return new Color(defaultFontColor);
}","/** 
 * Returns the default chat font color.
 * @return the default chat font color
 */
public static Color getChatDefaultFontColor(){
  return defaultFontColor == -1 ? null : new Color(defaultFontColor);
}",0.9157894736842104
103324,"/** 
 * Sets the default isUnderline property.
 * @param isBold indicates if the default chat font is underline
 */
public static void setChatFontIsUnderline(boolean isUnderline){
  isDefaultFontUnderline=isUnderline;
  configService.setProperty(""String_Node_Str"",isUnderline);
}","/** 
 * Sets the default isUnderline property.
 * @param isUnderline indicates if the default chat font is underline
 */
public static void setChatFontIsUnderline(boolean isUnderline){
  isDefaultFontUnderline=isUnderline;
  configService.setProperty(""String_Node_Str"",isUnderline);
}",0.9769094138543516
103325,"/** 
 * Creates a <tt>UIContact</tt> for the given <tt>metaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> for which we would like tocreate an <tt>UIContact</tt>
 * @return an <tt>UIContact</tt> for the given <tt>metaContact</tt>
 */
public static UIContact createUIContact(MetaContact metaContact){
  MetaUIContact descriptor=new MetaUIContact(metaContact);
  metaContact.setData(UI_CONTACT_DATA_KEY,descriptor);
  return descriptor;
}","/** 
 * Creates a <tt>UIContact</tt> for the given <tt>metaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> for which we would like tocreate an <tt>UIContact</tt>
 * @return an <tt>UIContact</tt> for the given <tt>metaContact</tt>
 */
public static UIContact createUIContact(final MetaContact metaContact){
  final MetaUIContact descriptor=new MetaUIContact(metaContact);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      metaContact.setData(UI_CONTACT_DATA_KEY,descriptor);
    }
  }
);
  return descriptor;
}",0.9025125628140704
103326,"/** 
 * Starts the SIP Communicator.
 * @param args command line args if any
 * @throws Exception whenever it makes sense.
 */
public static void main(String[] args) throws Exception {
  String version=System.getProperty(""String_Node_Str"");
  String vmVendor=System.getProperty(""String_Node_Str"");
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.startsWith(""String_Node_Str""))   System.setProperty(""String_Node_Str"",""String_Node_Str"");
  setScHomeDir(osName);
  if (version.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"")) {
    String os=""String_Node_Str"";
    if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.MAC_OSX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.LINUX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.WINDOWS;
    ChangeJVMFrame changeJVMFrame=new ChangeJVMFrame(os);
    Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
    changeJVMFrame.setLocation(screenSize.width / 2 - changeJVMFrame.getWidth() / 2,screenSize.height / 2 - changeJVMFrame.getHeight() / 2);
    changeJVMFrame.setVisible(true);
    return;
  }
  LaunchArgHandler argHandler=LaunchArgHandler.getInstance();
  int argHandlerRes=argHandler.handleArgs(args);
  if (argHandlerRes == LaunchArgHandler.ACTION_EXIT || argHandlerRes == LaunchArgHandler.ACTION_ERROR) {
    System.exit(argHandler.getErrorCode());
  }
  if (argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED) {
switch (new SipCommunicatorLock().tryLock(args)) {
case SipCommunicatorLock.LOCK_ERROR:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    System.exit(SipCommunicatorLock.LOCK_ERROR);
  break;
case SipCommunicatorLock.ALREADY_STARTED:
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
System.exit(SipCommunicatorLock.SUCCESS);
break;
case SipCommunicatorLock.SUCCESS:
break;
}
}
System.setOut(new ScStdOut(System.out));
Main.main(new String[0]);
}","/** 
 * Starts the SIP Communicator.
 * @param args command line args if any
 * @throws Exception whenever it makes sense.
 */
public static void main(String[] args) throws Exception {
  String version=System.getProperty(""String_Node_Str"");
  String vmVendor=System.getProperty(""String_Node_Str"");
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.startsWith(""String_Node_Str"")) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (osName.startsWith(""String_Node_Str"")) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  setScHomeDir(osName);
  if (version.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"")) {
    String os=""String_Node_Str"";
    if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.MAC_OSX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.LINUX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.WINDOWS;
    ChangeJVMFrame changeJVMFrame=new ChangeJVMFrame(os);
    Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
    changeJVMFrame.setLocation(screenSize.width / 2 - changeJVMFrame.getWidth() / 2,screenSize.height / 2 - changeJVMFrame.getHeight() / 2);
    changeJVMFrame.setVisible(true);
    return;
  }
  LaunchArgHandler argHandler=LaunchArgHandler.getInstance();
  int argHandlerRes=argHandler.handleArgs(args);
  if (argHandlerRes == LaunchArgHandler.ACTION_EXIT || argHandlerRes == LaunchArgHandler.ACTION_ERROR) {
    System.exit(argHandler.getErrorCode());
  }
  if (argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED) {
switch (new SipCommunicatorLock().tryLock(args)) {
case SipCommunicatorLock.LOCK_ERROR:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    System.exit(SipCommunicatorLock.LOCK_ERROR);
  break;
case SipCommunicatorLock.ALREADY_STARTED:
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
System.exit(SipCommunicatorLock.SUCCESS);
break;
case SipCommunicatorLock.SUCCESS:
break;
}
}
System.setOut(new ScStdOut(System.out));
Main.main(new String[0]);
}",0.9707875671885956
103327,"protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int inputLength=inputBuffer.getLength();
  int inputOffset=inputBuffer.getOffset();
  if ((prevInputLength + inputLength) < INPUT_FRAME_SIZE_IN_BYTES) {
    System.arraycopy(input,inputOffset,prevInput,prevInputLength,inputLength);
    prevInputLength+=inputLength;
    return BUFFER_PROCESSED_OK | OUTPUT_BUFFER_NOT_FILLED;
  }
  int readShorts=0;
  if (prevInputLength > 0) {
    readShorts+=readShorts(prevInput,0,sp16,0,prevInputLength / 2);
    prevInputLength=0;
  }
  readShorts=readShorts(input,inputOffset,sp16,readShorts,sp16.length - readShorts);
  int readBytes=2 * readShorts;
  inputLength-=readBytes;
  inputBuffer.setLength(inputLength);
  inputOffset+=readBytes;
  inputBuffer.setOffset(inputOffset);
  coder.process(sp16,serial);
  byte[] output=validateByteArraySize(outputBuffer,outputBuffer.getOffset() + 2 * OUTPUT_FRAME_SIZE_IN_BYTES);
  packetize(serial,output,outputBuffer.getOffset() + OUTPUT_FRAME_SIZE_IN_BYTES * outputFrameCount);
  outputBuffer.setLength(outputBuffer.getLength() + OUTPUT_FRAME_SIZE_IN_BYTES);
  outputBuffer.setFormat(outputFormat);
  int processResult=BUFFER_PROCESSED_OK;
  if (outputFrameCount == 1)   outputFrameCount=0;
 else {
    outputFrameCount=1;
    processResult|=OUTPUT_BUFFER_NOT_FILLED;
  }
  if (inputLength > 0)   processResult|=INPUT_BUFFER_NOT_CONSUMED;
  return processResult;
}","protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int inputLength=inputBuffer.getLength();
  int inputOffset=inputBuffer.getOffset();
  if ((prevInputLength + inputLength) < INPUT_FRAME_SIZE_IN_BYTES) {
    System.arraycopy(input,inputOffset,prevInput,prevInputLength,inputLength);
    prevInputLength+=inputLength;
    return BUFFER_PROCESSED_OK | OUTPUT_BUFFER_NOT_FILLED;
  }
  int readShorts=0;
  if (prevInputLength > 0) {
    readShorts+=readShorts(prevInput,0,sp16,0,prevInputLength / 2);
    prevInputLength=0;
  }
  readShorts=readShorts(input,inputOffset,sp16,readShorts,sp16.length - readShorts);
  int readBytes=2 * readShorts;
  inputLength-=readBytes;
  inputBuffer.setLength(inputLength);
  inputOffset+=readBytes;
  inputBuffer.setOffset(inputOffset);
  coder.process(sp16,serial);
  byte[] output=validateByteArraySize(outputBuffer,outputBuffer.getOffset() + 2 * OUTPUT_FRAME_SIZE_IN_BYTES);
  packetize(serial,output,outputBuffer.getOffset() + OUTPUT_FRAME_SIZE_IN_BYTES * outputFrameCount);
  outputBuffer.setLength(outputBuffer.getLength() + OUTPUT_FRAME_SIZE_IN_BYTES);
  outputBuffer.setFormat(outputFormat);
  int processResult=BUFFER_PROCESSED_OK;
  if (outputFrameCount == 1)   outputFrameCount=0;
 else {
    outputFrameCount=1;
    processResult|=OUTPUT_BUFFER_NOT_FILLED;
  }
  if (inputLength > 0)   processResult|=INPUT_BUFFER_NOT_CONSUMED;
  if (processResult == BUFFER_PROCESSED_OK) {
    updateOutput(outputBuffer,getOutputFormat(),outputBuffer.getLength(),outputBuffer.getOffset());
    outputBuffer.setDuration(duration);
  }
  return processResult;
}",0.9330759330759332
103328,"/** 
 * Method called back in the RemoteListener to notify listener of all RTP Remote Events.RemoteEvents are one of ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent
 * @param remoteEvent the event
 */
public void update(RemoteEvent remoteEvent){
  if (!logger.isInfoEnabled())   return;
  if (remoteEvent instanceof SenderReportEvent) {
    numberOfReceivedSenderReports++;
    SenderReport report=((SenderReportEvent)remoteEvent).getReport();
    if (report.getFeedbackReports().size() > 0) {
      Feedback feedback=(Feedback)report.getFeedbackReports().get(0);
      long remoteJitter=feedback.getJitter();
      if (remoteJitter < minRemoteInterArrivalJitter || minRemoteInterArrivalJitter == -1)       minRemoteInterArrivalJitter=remoteJitter;
      if (maxRemoteInterArrivalJitter < remoteJitter)       maxRemoteInterArrivalJitter=remoteJitter;
      if (numberOfReceivedSenderReports % 4 != 1)       return;
      StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
      MediaFormat format=getFormat();
      buff.append(""String_Node_Str"").append((format == null) ? ""String_Node_Str"" : format.getMediaType().toString()).append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(report.getSenderPacketCount()).append(""String_Node_Str"").append(report.getSenderByteCount()).append(""String_Node_Str"").append(remoteJitter).append(""String_Node_Str"").append(feedback.getNumLost()).append(""String_Node_Str"").append((int)(feedback.getDLSR() / 65.536)).append(""String_Node_Str"");
      logger.info(buff);
    }
  }
}","/** 
 * Method called back in the RemoteListener to notify listener of all RTP Remote Events.RemoteEvents are one of ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent
 * @param remoteEvent the event
 */
public void update(RemoteEvent remoteEvent){
  if (!logger.isInfoEnabled())   return;
  if (remoteEvent instanceof SenderReportEvent) {
    numberOfReceivedSenderReports++;
    SenderReport report=((SenderReportEvent)remoteEvent).getReport();
    Feedback feedback=null;
    long remoteJitter=-1;
    if (report.getFeedbackReports().size() > 0) {
      feedback=(Feedback)report.getFeedbackReports().get(0);
      remoteJitter=feedback.getJitter();
      if (remoteJitter < minRemoteInterArrivalJitter || minRemoteInterArrivalJitter == -1)       minRemoteInterArrivalJitter=remoteJitter;
      if (maxRemoteInterArrivalJitter < remoteJitter)       maxRemoteInterArrivalJitter=remoteJitter;
    }
    if (numberOfReceivedSenderReports % 4 != 1)     return;
    StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
    MediaFormat format=getFormat();
    buff.append(""String_Node_Str"").append((format == null) ? ""String_Node_Str"" : format.getMediaType().toString()).append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(report.getSenderPacketCount()).append(""String_Node_Str"").append(report.getSenderByteCount());
    if (feedback != null) {
      buff.append(""String_Node_Str"").append(remoteJitter).append(""String_Node_Str"").append(feedback.getNumLost()).append(""String_Node_Str"").append((int)(feedback.getDLSR() / 65.536)).append(""String_Node_Str"");
    }
    buff.append(""String_Node_Str"");
    logger.info(buff);
  }
}",0.9056372549019608
103329,"/** 
 * Sets the preset.
 * @param preset the desired video settings
 * @throws OperationFailedException
 */
private void setRemoteReceivePreset(QualityPreset preset) throws OperationFailedException {
  if (preset.compareTo(getPreferredSendPreset()) > 0)   this.preset=getPreferredSendPreset();
 else   this.preset=preset;
}","/** 
 * Sets the preset.
 * @param preset the desired video settings
 * @throws OperationFailedException
 */
private void setRemoteReceivePreset(QualityPreset preset) throws OperationFailedException {
  if (preset.compareTo(getPreferredSendPreset()) > 0)   this.preset=getPreferredSendPreset();
 else {
    this.preset=preset;
    if (logger.isInfoEnabled() && preset != null && preset.getResolution() != null) {
      logger.info(""String_Node_Str"" + preset.getResolution().width + ""String_Node_Str""+ preset.getResolution().height);
    }
  }
}",0.7465437788018433
103330,"/** 
 * Creates the <tt>DataSource</tt> that this instance is to read captured media from.
 * @return the <tt>DataSource</tt> that this instance is to read capturedmedia from
 */
@Override protected DataSource createCaptureDevice(){
  DataSource captureDevice=super.createCaptureDevice();
  if (captureDevice != null) {
    MediaLocator locator=captureDevice.getLocator();
    String protocol=(locator == null) ? null : locator.getProtocol();
    float frameRate;
    DeviceConfiguration deviceConfig=NeomediaActivator.getMediaServiceImpl().getDeviceConfiguration();
    if (ImageStreamingAuto.LOCATOR_PROTOCOL.equals(protocol)) {
      frameRate=10;
    }
 else {
      Dimension videoSize=deviceConfig.getVideoSize();
      if (outputSize != null && videoSize.height > outputSize.height && videoSize.width > outputSize.width)       videoSize=outputSize;
      VideoMediaStreamImpl.selectVideoSize(captureDevice,videoSize.width,videoSize.height);
      frameRate=deviceConfig.getFrameRate();
    }
    FrameRateControl frameRateControl=(FrameRateControl)captureDevice.getControl(FrameRateControl.class.getName());
    if (frameRateControl != null) {
      float maxSupportedFrameRate=frameRateControl.getMaxSupportedFrameRate();
      if ((maxSupportedFrameRate > 0) && (frameRate > maxSupportedFrameRate))       frameRate=maxSupportedFrameRate;
      if (frameRate > 0)       frameRateControl.setFrameRate(frameRate);
    }
    if (!(captureDevice instanceof PullBufferDataSource)) {
      DataSource cloneableDataSource=Manager.createCloneableDataSource(captureDevice);
      if (cloneableDataSource != null)       captureDevice=cloneableDataSource;
    }
  }
  return captureDevice;
}","/** 
 * Creates the <tt>DataSource</tt> that this instance is to read captured media from.
 * @return the <tt>DataSource</tt> that this instance is to read capturedmedia from
 */
@Override protected DataSource createCaptureDevice(){
  DataSource captureDevice=super.createCaptureDevice();
  if (captureDevice != null) {
    MediaLocator locator=captureDevice.getLocator();
    String protocol=(locator == null) ? null : locator.getProtocol();
    float frameRate;
    DeviceConfiguration deviceConfig=NeomediaActivator.getMediaServiceImpl().getDeviceConfiguration();
    if (ImageStreamingAuto.LOCATOR_PROTOCOL.equals(protocol)) {
      frameRate=10;
    }
 else {
      Dimension videoSize=deviceConfig.getVideoSize();
      if (outputSize != null && videoSize.height > outputSize.height && videoSize.width > outputSize.width)       videoSize=outputSize;
      Dimension dim=VideoMediaStreamImpl.selectVideoSize(captureDevice,videoSize.width,videoSize.height);
      frameRate=deviceConfig.getFrameRate();
      if (logger.isInfoEnabled() && dim != null)       logger.info(""String_Node_Str"" + dim.width + ""String_Node_Str""+ dim.height);
    }
    FrameRateControl frameRateControl=(FrameRateControl)captureDevice.getControl(FrameRateControl.class.getName());
    if (frameRateControl != null) {
      float maxSupportedFrameRate=frameRateControl.getMaxSupportedFrameRate();
      if ((maxSupportedFrameRate > 0) && (frameRate > maxSupportedFrameRate))       frameRate=maxSupportedFrameRate;
      if (frameRate > 0)       frameRateControl.setFrameRate(frameRate);
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"" + (frameRate == -1 ? ""String_Node_Str"" : frameRate));
      }
    }
    if (!(captureDevice instanceof PullBufferDataSource)) {
      DataSource cloneableDataSource=Manager.createCloneableDataSource(captureDevice);
      if (cloneableDataSource != null)       captureDevice=cloneableDataSource;
    }
  }
  return captureDevice;
}",0.9231610609789443
103331,"/** 
 * Sets the <tt>MediaFormat</tt> in which this <tt>MediaDeviceSession</tt> outputs the media captured by its <tt>MediaDevice</tt>.
 * @param format the <tt>MediaFormat</tt> in which this<tt>MediaDeviceSession</tt> is to output the media captured by its <tt>MediaDevice</tt>
 */
public void setFormat(MediaFormat format){
  if (format instanceof VideoMediaFormat && ((VideoMediaFormat)format).getFrameRate() != -1) {
    FrameRateControl frameRateControl=(FrameRateControl)getCaptureDevice().getControl(FrameRateControl.class.getName());
    if (frameRateControl != null) {
      float frameRate=((VideoMediaFormat)format).getFrameRate();
      float maxSupportedFrameRate=frameRateControl.getMaxSupportedFrameRate();
      if ((maxSupportedFrameRate > 0) && (frameRate > maxSupportedFrameRate))       frameRate=maxSupportedFrameRate;
      if (frameRate > 0) {
        frameRateControl.setFrameRate(frameRate);
      }
    }
  }
  super.setFormat(format);
}","/** 
 * Sets the <tt>MediaFormat</tt> in which this <tt>MediaDeviceSession</tt> outputs the media captured by its <tt>MediaDevice</tt>.
 * @param format the <tt>MediaFormat</tt> in which this<tt>MediaDeviceSession</tt> is to output the media captured by its <tt>MediaDevice</tt>
 */
public void setFormat(MediaFormat format){
  if (format instanceof VideoMediaFormat && ((VideoMediaFormat)format).getFrameRate() != -1) {
    FrameRateControl frameRateControl=(FrameRateControl)getCaptureDevice().getControl(FrameRateControl.class.getName());
    if (frameRateControl != null) {
      float frameRate=((VideoMediaFormat)format).getFrameRate();
      float maxSupportedFrameRate=frameRateControl.getMaxSupportedFrameRate();
      if ((maxSupportedFrameRate > 0) && (frameRate > maxSupportedFrameRate))       frameRate=maxSupportedFrameRate;
      if (frameRate > 0) {
        frameRateControl.setFrameRate(frameRate);
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"" + frameRate);
        }
      }
    }
  }
  super.setFormat(format);
}",0.949654491609082
103332,"/** 
 * Modifies the account corresponding to the specified accountID. This method is meant to be used to change properties of already existing accounts. Note that if the given accountID doesn't correspond to any registered account this method would do nothing.
 * @param protocolProvider the protocol provider service corresponding tothe modified account.
 * @param accountProperties a set of protocol (or implementation) specificproperties defining the new account.
 * @throws java.lang.NullPointerException if any of the arguments is null.
 */
public void modifyAccount(ProtocolProviderService protocolProvider,Map<String,String> accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  SipAccountID accountID=(SipAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=registeredAccounts.get(accountID);
  if (registration != null) {
    try {
      if (protocolProvider.isRegistered()) {
        protocolProvider.shutdown();
      }
    }
 catch (    Throwable e) {
    }
    registration.unregister();
  }
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  Map<String,String> oldAcccountProps=accountID.getAccountProperties();
  accountID.setAccountProperties(accountProperties);
  this.storeAccount(accountID);
  String userIDStr=accountProperties.get(USER_ID);
  Hashtable<String,String> properties=new Hashtable<String,String>();
  properties.put(PROTOCOL,ProtocolNames.SIP);
  properties.put(USER_ID,userIDStr);
  try {
    Exception initializationException=null;
    try {
      ((ProtocolProviderServiceSipImpl)protocolProvider).initialize(userIDStr,accountID);
    }
 catch (    Exception ex) {
      initializationException=ex;
      accountID.setAccountProperties(oldAcccountProps);
    }
    this.storeAccount(accountID);
    registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
    registeredAccounts.put(accountID,registration);
    if (initializationException != null)     throw initializationException;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Modifies the account corresponding to the specified accountID. This method is meant to be used to change properties of already existing accounts. Note that if the given accountID doesn't correspond to any registered account this method would do nothing.
 * @param protocolProvider the protocol provider service corresponding tothe modified account.
 * @param accountProperties a set of protocol (or implementation) specificproperties defining the new account.
 * @throws java.lang.NullPointerException if any of the arguments is null.
 */
public void modifyAccount(ProtocolProviderService protocolProvider,Map<String,String> accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  SipAccountID accountID=(SipAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=registeredAccounts.get(accountID);
  if (registration != null) {
    try {
{
        protocolProvider.shutdown();
      }
    }
 catch (    Throwable e) {
    }
    registration.unregister();
  }
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  Map<String,String> oldAcccountProps=accountID.getAccountProperties();
  accountID.setAccountProperties(accountProperties);
  this.storeAccount(accountID);
  String userIDStr=accountProperties.get(USER_ID);
  Hashtable<String,String> properties=new Hashtable<String,String>();
  properties.put(PROTOCOL,ProtocolNames.SIP);
  properties.put(USER_ID,userIDStr);
  try {
    Exception initializationException=null;
    try {
      ((ProtocolProviderServiceSipImpl)protocolProvider).initialize(userIDStr,accountID);
    }
 catch (    Exception ex) {
      initializationException=ex;
      accountID.setAccountProperties(oldAcccountProps);
    }
    this.storeAccount(accountID);
    registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
    registeredAccounts.put(accountID,registration);
    if (initializationException != null)     throw initializationException;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
  }
}",0.991435968930492
103333,"/** 
 * Removes the protocol specific group from the specified meta contact group and removes from meta contacts all proto contacts that belong to the same provider as the group which is being removed.
 * @param metaContainer the MetaContactGroup that we'd like to remove acontact group from.
 * @param groupToRemove the ContactGroup that we'd like removed.
 * @param sourceProvider the ProtocolProvider that the contact group belongsto.
 */
public void removeContactGroupFromMetaContactGroup(MetaContactGroupImpl metaContainer,ContactGroup groupToRemove,ProtocolProviderService sourceProvider){
  locallyRemoveAllContactsForProvider(metaContainer,groupToRemove);
  fireMetaContactGroupEvent(metaContainer,sourceProvider,groupToRemove,MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP);
}","/** 
 * Removes the protocol specific group from the specified meta contact group and removes from meta contacts all proto contacts that belong to the same provider as the group which is being removed.
 * @param metaContainer the MetaContactGroup that we'd like to remove acontact group from.
 * @param groupToRemove the ContactGroup that we'd like removed.
 * @param sourceProvider the ProtocolProvider that the contact group belongsto.
 */
public void removeContactGroupFromMetaContactGroup(MetaContactGroupImpl metaContainer,ContactGroup groupToRemove,ProtocolProviderService sourceProvider){
  if (metaContainer == null) {
    return;
  }
  locallyRemoveAllContactsForProvider(metaContainer,groupToRemove);
  fireMetaContactGroupEvent(metaContainer,sourceProvider,groupToRemove,MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP);
}",0.9713937918441876
103334,"/** 
 * Goes through the specified group and removes from all meta contacts, protocol specific contacts belonging to the specified <tt>groupToRemove</tt>. Note that this method won't undertake any calls to the protocol itself as it is used only to update the local contact list as a result of a server generated event.
 * @param parentMetaGroup  the MetaContactGroup whose children we should gothrough
 * @param groupToRemove the proto group that we want removed together withits children.
 */
private void locallyRemoveAllContactsForProvider(MetaContactGroupImpl parentMetaGroup,ContactGroup groupToRemove){
  Iterator<MetaContact> childrenContactsIter=parentMetaGroup.getChildContacts();
  while (childrenContactsIter.hasNext()) {
    MetaContactImpl child=(MetaContactImpl)childrenContactsIter.next();
    Iterator<Contact> contactsToRemove=child.getContactsForContactGroup(groupToRemove);
    child.removeContactsForGroup(groupToRemove);
    if (child.getContactCount() == 0) {
      parentMetaGroup.removeMetaContact(child);
      fireMetaContactEvent(child,parentMetaGroup,MetaContactEvent.META_CONTACT_REMOVED);
    }
 else {
      while (contactsToRemove.hasNext()) {
        fireProtoContactEvent(contactsToRemove.next(),ProtoContactEvent.PROTO_CONTACT_REMOVED,child,null);
      }
    }
  }
  Iterator<MetaContactGroup> subgroupsIter=parentMetaGroup.getSubgroups();
  while (subgroupsIter.hasNext()) {
    MetaContactGroupImpl subMetaGroup=(MetaContactGroupImpl)subgroupsIter.next();
    Iterator<ContactGroup> contactGroups=subMetaGroup.getContactGroups();
    ContactGroup protoGroup=null;
    while (contactGroups.hasNext()) {
      protoGroup=contactGroups.next();
      if (groupToRemove == protoGroup.getParentContactGroup())       this.locallyRemoveAllContactsForProvider(subMetaGroup,protoGroup);
    }
    if (subMetaGroup.countSubgroups() == 0 && subMetaGroup.countChildContacts() == 0) {
      parentMetaGroup.removeSubgroup(subMetaGroup);
      fireMetaContactGroupEvent(subMetaGroup,groupToRemove.getProtocolProvider(),protoGroup,MetaContactGroupEvent.META_CONTACT_GROUP_REMOVED);
    }
  }
  parentMetaGroup.removeProtoGroup(groupToRemove);
}","/** 
 * Goes through the specified group and removes from all meta contacts, protocol specific contacts belonging to the specified <tt>groupToRemove</tt>. Note that this method won't undertake any calls to the protocol itself as it is used only to update the local contact list as a result of a server generated event.
 * @param parentMetaGroup  the MetaContactGroup whose children we should gothrough
 * @param groupToRemove the proto group that we want removed together withits children.
 */
private void locallyRemoveAllContactsForProvider(MetaContactGroupImpl parentMetaGroup,ContactGroup groupToRemove){
  Iterator<MetaContact> childrenContactsIter=parentMetaGroup.getChildContacts();
  while (childrenContactsIter.hasNext()) {
    MetaContactImpl child=(MetaContactImpl)childrenContactsIter.next();
    Iterator<Contact> contactsToRemove=child.getContactsForContactGroup(groupToRemove);
    child.removeContactsForGroup(groupToRemove);
    if (child.getContactCount() == 0) {
      parentMetaGroup.removeMetaContact(child);
      fireMetaContactEvent(child,parentMetaGroup,MetaContactEvent.META_CONTACT_REMOVED);
    }
 else {
      while (contactsToRemove.hasNext()) {
        fireProtoContactEvent(contactsToRemove.next(),ProtoContactEvent.PROTO_CONTACT_REMOVED,child,null);
      }
    }
  }
  Iterator<MetaContactGroup> subgroupsIter=parentMetaGroup.getSubgroups();
  while (subgroupsIter.hasNext()) {
    MetaContactGroupImpl subMetaGroup=(MetaContactGroupImpl)subgroupsIter.next();
    Iterator<ContactGroup> contactGroups=subMetaGroup.getContactGroups();
    ContactGroup protoGroup=null;
    while (contactGroups.hasNext()) {
      protoGroup=contactGroups.next();
      if (groupToRemove == protoGroup.getParentContactGroup())       this.locallyRemoveAllContactsForProvider(subMetaGroup,protoGroup);
    }
    if (subMetaGroup.countSubgroups() == 0 && subMetaGroup.countChildContacts() == 0 && subMetaGroup.countContactGroups() == 0) {
      parentMetaGroup.removeSubgroup(subMetaGroup);
      fireMetaContactGroupEvent(subMetaGroup,groupToRemove.getProtocolProvider(),protoGroup,MetaContactGroupEvent.META_CONTACT_GROUP_REMOVED);
    }
  }
  parentMetaGroup.removeProtoGroup(groupToRemove);
}",0.99039780521262
103335,"/** 
 * Publishes the given <tt>status</tt> through the given <tt>presence</tt> operation set.
 * @param presence the operation set through which we publish the status
 * @param status the status to publish
 */
public PublishPresenceStatusThread(OperationSetPresence presence,PresenceStatus status){
  this.presence=presence;
  this.status=status;
}","/** 
 * Publishes the given <tt>status</tt> through the given <tt>presence</tt> operation set.
 * @param presence the operation set through which we publish the status
 * @param status the status to publish
 */
public PublishPresenceStatusThread(ProtocolProviderService protocolProvider,OperationSetPresence presence,PresenceStatus status){
  this.protocolProvider=protocolProvider;
  this.presence=presence;
  this.status=status;
}",0.8322663252240717
103336,"@Override public void run(){
  try {
    presence.publishPresenceStatus(status,""String_Node_Str"");
  }
 catch (  IllegalArgumentException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  IllegalStateException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  OperationFailedException e1) {
    if (e1.getErrorCode() == OperationFailedException.GENERAL_ERROR) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.NETWORK_FAILURE) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,msgText,GuiActivator.getResources().getI18NString(""String_Node_Str""),e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
    logger.error(""String_Node_Str"",e1);
  }
}","@Override public void run(){
  try {
    presence.publishPresenceStatus(status,""String_Node_Str"");
  }
 catch (  IllegalArgumentException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  IllegalStateException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  OperationFailedException e1) {
    if (e1.getErrorCode() == OperationFailedException.GENERAL_ERROR) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.NETWORK_FAILURE) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,msgText,GuiActivator.getResources().getI18NString(""String_Node_Str""),e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
    logger.error(""String_Node_Str"",e1);
  }
}",0.8859357696566998
103337,"/** 
 * Handles the <tt>ActionEvent</tt> triggered when one of the items in the list is selected.
 * @param e the <tt>ActionEvent</tt> that notified us
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  Iterator<ProtocolProviderService> pProviders=mainFrame.getProtocolProviders();
  while (pProviders.hasNext()) {
    ProtocolProviderService protocolProvider=pProviders.next();
    if (itemName.equals(Constants.ONLINE_STATUS)) {
      if (!protocolProvider.isRegistered()) {
        saveStatusInformation(protocolProvider,onlineItem.getName());
        GuiActivator.getUIService().getLoginManager().login(protocolProvider);
      }
 else {
        OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
        if (presence == null) {
          saveStatusInformation(protocolProvider,onlineItem.getName());
          continue;
        }
        Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
        while (statusSet.hasNext()) {
          PresenceStatus status=statusSet.next();
          if (status.getStatus() < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD && status.getStatus() >= PresenceStatus.AVAILABLE_THRESHOLD) {
            new PublishPresenceStatusThread(presence,status).start();
            this.saveStatusInformation(protocolProvider,status.getStatusName());
            break;
          }
        }
      }
    }
 else     if (itemName.equals(Constants.OFFLINE_STATUS)) {
      if (!protocolProvider.getRegistrationState().equals(RegistrationState.UNREGISTERED) && !protocolProvider.getRegistrationState().equals(RegistrationState.UNREGISTERING)) {
        OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
        if (presence == null) {
          saveStatusInformation(protocolProvider,offlineItem.getName());
          GuiActivator.getUIService().getLoginManager().logoff(protocolProvider);
          continue;
        }
        Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
        while (statusSet.hasNext()) {
          PresenceStatus status=statusSet.next();
          if (status.getStatus() < PresenceStatus.ONLINE_THRESHOLD) {
            this.saveStatusInformation(protocolProvider,status.getStatusName());
            break;
          }
        }
        try {
          GuiActivator.getUIService().getLoginManager().setManuallyDisconnected(true);
          protocolProvider.unregister();
        }
 catch (        OperationFailedException e1) {
          logger.error(""String_Node_Str"" + protocolProvider + ""String_Node_Str""+ e1);
        }
      }
    }
 else     if (itemName.equals(Constants.FREE_FOR_CHAT_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.AVAILABLE_THRESHOLD,PresenceStatus.MAX_STATUS_VALUE);
    }
 else     if (itemName.equals(Constants.DO_NOT_DISTURB_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.ONLINE_THRESHOLD,PresenceStatus.AWAY_THRESHOLD);
    }
 else     if (itemName.equals(Constants.AWAY_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.AWAY_THRESHOLD,PresenceStatus.AVAILABLE_THRESHOLD);
    }
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> triggered when one of the items in the list is selected.
 * @param e the <tt>ActionEvent</tt> that notified us
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  Iterator<ProtocolProviderService> pProviders=mainFrame.getProtocolProviders();
  while (pProviders.hasNext()) {
    ProtocolProviderService protocolProvider=pProviders.next();
    if (itemName.equals(Constants.ONLINE_STATUS)) {
      if (!protocolProvider.isRegistered()) {
        saveStatusInformation(protocolProvider,onlineItem.getName());
        GuiActivator.getUIService().getLoginManager().login(protocolProvider);
      }
 else {
        OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
        if (presence == null) {
          saveStatusInformation(protocolProvider,onlineItem.getName());
          continue;
        }
        Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
        while (statusSet.hasNext()) {
          PresenceStatus status=statusSet.next();
          if (status.getStatus() < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD && status.getStatus() >= PresenceStatus.AVAILABLE_THRESHOLD) {
            new PublishPresenceStatusThread(protocolProvider,presence,status).start();
            this.saveStatusInformation(protocolProvider,status.getStatusName());
            break;
          }
        }
      }
    }
 else     if (itemName.equals(Constants.OFFLINE_STATUS)) {
      if (!protocolProvider.getRegistrationState().equals(RegistrationState.UNREGISTERED) && !protocolProvider.getRegistrationState().equals(RegistrationState.UNREGISTERING)) {
        OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
        if (presence == null) {
          saveStatusInformation(protocolProvider,offlineItem.getName());
          GuiActivator.getUIService().getLoginManager().logoff(protocolProvider);
          continue;
        }
        Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
        while (statusSet.hasNext()) {
          PresenceStatus status=statusSet.next();
          if (status.getStatus() < PresenceStatus.ONLINE_THRESHOLD) {
            this.saveStatusInformation(protocolProvider,status.getStatusName());
            break;
          }
        }
        try {
          GuiActivator.getUIService().getLoginManager().setManuallyDisconnected(true);
          protocolProvider.unregister();
        }
 catch (        OperationFailedException e1) {
          logger.error(""String_Node_Str"" + protocolProvider + ""String_Node_Str""+ e1);
        }
      }
    }
 else     if (itemName.equals(Constants.FREE_FOR_CHAT_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.AVAILABLE_THRESHOLD,PresenceStatus.MAX_STATUS_VALUE);
    }
 else     if (itemName.equals(Constants.DO_NOT_DISTURB_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.ONLINE_THRESHOLD,PresenceStatus.AWAY_THRESHOLD);
    }
 else     if (itemName.equals(Constants.AWAY_STATUS)) {
      publishStatus(protocolProvider,PresenceStatus.AWAY_THRESHOLD,PresenceStatus.AVAILABLE_THRESHOLD);
    }
  }
}",0.9973631146269584
103338,"/** 
 * Publish present status. We search for the highest value in the given interval.
 * @param protocolProvider the protocol provider to which wechange the status.
 * @param floorStatusValue the min status value.
 * @param ceilStatusValue the max status value.
 */
private void publishStatus(ProtocolProviderService protocolProvider,int floorStatusValue,int ceilStatusValue){
  if (!protocolProvider.isRegistered())   return;
  OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
  if (presence == null)   return;
  Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
  PresenceStatus status=null;
  while (statusSet.hasNext()) {
    PresenceStatus currentStatus=statusSet.next();
    if (status == null && currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue) {
      status=currentStatus;
    }
    if (status != null) {
      if (currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue && currentStatus.getStatus() > status.getStatus()) {
        status=currentStatus;
      }
    }
  }
  if (status != null) {
    new PublishPresenceStatusThread(presence,status).start();
    this.saveStatusInformation(protocolProvider,status.getStatusName());
  }
}","/** 
 * Publish present status. We search for the highest value in the given interval.
 * @param protocolProvider the protocol provider to which wechange the status.
 * @param floorStatusValue the min status value.
 * @param ceilStatusValue the max status value.
 */
private void publishStatus(ProtocolProviderService protocolProvider,int floorStatusValue,int ceilStatusValue){
  if (!protocolProvider.isRegistered())   return;
  OperationSetPresence presence=protocolProvider.getOperationSet(OperationSetPresence.class);
  if (presence == null)   return;
  Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
  PresenceStatus status=null;
  while (statusSet.hasNext()) {
    PresenceStatus currentStatus=statusSet.next();
    if (status == null && currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue) {
      status=currentStatus;
    }
    if (status != null) {
      if (currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue && currentStatus.getStatus() > status.getStatus()) {
        status=currentStatus;
      }
    }
  }
  if (status != null) {
    new PublishPresenceStatusThread(protocolProvider,presence,status).start();
    this.saveStatusInformation(protocolProvider,status.getStatusName());
  }
}",0.9888332691567192
103339,"/** 
 * Handles the <tt>ActionEvent</tt> triggered when one of the items in the list is selected.
 * @param e an <tt>ActionEvent</tt> which carries the data associated withthe performed action
 */
public void actionPerformed(ActionEvent e){
  if (e.getSource() instanceof JMenuItem) {
    String menuItemText=((JMenuItem)e.getSource()).getText();
    LoginManager loginManager=GuiActivator.getUIService().getLoginManager();
    Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
    while (statusSet.hasNext()) {
      PresenceStatus status=statusSet.next();
      if (status.getStatusName().equals(menuItemText)) {
        RegistrationState registrationState=protocolProvider.getRegistrationState();
        if (registrationState == RegistrationState.REGISTERED && !presence.getPresenceStatus().equals(status)) {
          if (status.isOnline()) {
            new PublishPresenceStatusThread(status).start();
          }
 else {
            loginManager.setManuallyDisconnected(true);
            loginManager.logoff(protocolProvider);
          }
          setSelectedStatus(status);
        }
 else         if (registrationState != RegistrationState.REGISTERED && registrationState != RegistrationState.REGISTERING && registrationState != RegistrationState.AUTHENTICATING && status.isOnline()) {
          lastSelectedStatus=status;
          loginManager.login(protocolProvider);
        }
 else         if (!status.isOnline() && !(registrationState == RegistrationState.UNREGISTERING)) {
          loginManager.setManuallyDisconnected(true);
          loginManager.logoff(protocolProvider);
          setSelectedStatus(status);
        }
        saveStatusInformation(protocolProvider,status.getStatusName());
        break;
      }
    }
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> triggered when one of the items in the list is selected.
 * @param e an <tt>ActionEvent</tt> which carries the data associated withthe performed action
 */
public void actionPerformed(ActionEvent e){
  if (e.getSource() instanceof JMenuItem) {
    String menuItemText=((JMenuItem)e.getSource()).getText();
    LoginManager loginManager=GuiActivator.getUIService().getLoginManager();
    Iterator<PresenceStatus> statusSet=presence.getSupportedStatusSet();
    while (statusSet.hasNext()) {
      PresenceStatus status=statusSet.next();
      if (status.getStatusName().equals(menuItemText)) {
        RegistrationState registrationState=protocolProvider.getRegistrationState();
        if (registrationState == RegistrationState.REGISTERED && !presence.getPresenceStatus().equals(status)) {
          if (status.isOnline()) {
            new PublishPresenceStatusThread(protocolProvider,status).start();
          }
 else {
            loginManager.setManuallyDisconnected(true);
            loginManager.logoff(protocolProvider);
          }
          setSelectedStatus(status);
        }
 else         if (registrationState != RegistrationState.REGISTERED && registrationState != RegistrationState.REGISTERING && registrationState != RegistrationState.AUTHENTICATING && status.isOnline()) {
          lastSelectedStatus=status;
          loginManager.login(protocolProvider);
        }
 else         if (!status.isOnline() && !(registrationState == RegistrationState.UNREGISTERING)) {
          loginManager.setManuallyDisconnected(true);
          loginManager.logoff(protocolProvider);
          setSelectedStatus(status);
        }
        saveStatusInformation(protocolProvider,status.getStatusName());
        break;
      }
    }
  }
}",0.9952126161644608
103340,"public PublishPresenceStatusThread(PresenceStatus status){
  this.status=status;
}","public PublishPresenceStatusThread(ProtocolProviderService protocolProvider,PresenceStatus status){
  this.protocolProvider=protocolProvider;
  this.status=status;
}",0.6639676113360324
103341,"/** 
 * Selects a specific <tt>PresenceStatus</tt> in this instance and the <tt>ProtocolProviderService</tt> it depicts.
 * @param presenceStatus the <tt>PresenceStatus</tt> to be selected in thisinstance and the <tt>ProtocolProviderService</tt> it depicts
 */
public void updateStatus(PresenceStatus presenceStatus){
  OperationSetPresence presence=MainFrame.getProtocolPresenceOpSet(protocolProvider);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + protocolProvider.getAccountID().getAccountAddress() + ""String_Node_Str""+ presenceStatus.getStatusName());
  this.setSelectedStatus(presenceStatus);
  if (protocolProvider.isRegistered() && !presence.getPresenceStatus().equals(presenceStatus))   new PublishPresenceStatusThread(presenceStatus).start();
}","/** 
 * Selects a specific <tt>PresenceStatus</tt> in this instance and the <tt>ProtocolProviderService</tt> it depicts.
 * @param presenceStatus the <tt>PresenceStatus</tt> to be selected in thisinstance and the <tt>ProtocolProviderService</tt> it depicts
 */
public void updateStatus(PresenceStatus presenceStatus){
  OperationSetPresence presence=MainFrame.getProtocolPresenceOpSet(protocolProvider);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + protocolProvider.getAccountID().getAccountAddress() + ""String_Node_Str""+ presenceStatus.getStatusName());
  this.setSelectedStatus(presenceStatus);
  if (protocolProvider.isRegistered() && !presence.getPresenceStatus().equals(presenceStatus))   new PublishPresenceStatusThread(protocolProvider,presenceStatus).start();
}",0.9891234804862444
103342,"public void run(){
  try {
    presence.publishPresenceStatus(status,""String_Node_Str"");
  }
 catch (  IllegalArgumentException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  IllegalStateException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  OperationFailedException e1) {
    if (e1.getErrorCode() == OperationFailedException.GENERAL_ERROR) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.NETWORK_FAILURE) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"");
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
    logger.error(""String_Node_Str"",e1);
  }
}","public void run(){
  try {
    presence.publishPresenceStatus(status,""String_Node_Str"");
  }
 catch (  IllegalArgumentException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  IllegalStateException e1) {
    logger.error(""String_Node_Str"",e1);
  }
catch (  OperationFailedException e1) {
    if (e1.getErrorCode() == OperationFailedException.GENERAL_ERROR) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.NETWORK_FAILURE) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
 else     if (e1.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      String msgText=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()});
      new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),msgText,e1).showDialog();
    }
    logger.error(""String_Node_Str"",e1);
  }
}",0.8850873930829305
103343,"/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serverPort the port to use
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(String address,int serverPort,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address,serverPort,serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    startJingleNodesDiscovery();
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}","/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serverPort the port to use
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(String address,int serverPort,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address,serverPort,serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    startJingleNodesDiscovery();
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}",0.9951961569255404
103344,"/** 
 * Process the packet that is about to be sent to the server. The intercepted packet can be modified by the interceptor.<p> <p/> Interceptors are invoked using the same thread that requested the packet to be sent, so it's very important that implementations of this method not block for any extended period of time.
 * @param packet the packet to is going to be sent to the server.
 */
public void interceptPacket(Packet packet){
  try {
    if (packetLogging.isLoggingEnabled(PacketLoggingService.ProtocolName.JABBER)) {
      packetLogging.logPacket(PacketLoggingService.ProtocolName.JABBER,localAddress,connection.getSocket().getLocalPort(),remoteAddress,connection.getPort(),PacketLoggingService.TransportName.TCP,true,packet.toXML().getBytes(""String_Node_Str""));
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","/** 
 * Process the packet that is about to be sent to the server. The intercepted packet can be modified by the interceptor.<p> <p/> Interceptors are invoked using the same thread that requested the packet to be sent, so it's very important that implementations of this method not block for any extended period of time.
 * @param packet the packet to is going to be sent to the server.
 */
public void interceptPacket(Packet packet){
  try {
    if (packetLogging.isLoggingEnabled(PacketLoggingService.ProtocolName.JABBER) && packet != null && connection.getSocket() != null) {
      packetLogging.logPacket(PacketLoggingService.ProtocolName.JABBER,localAddress,connection.getSocket().getLocalPort(),remoteAddress,connection.getPort(),PacketLoggingService.TransportName.TCP,true,packet.toXML().getBytes(""String_Node_Str""));
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.9699074074074074
103345,"/** 
 * The thread run method that handles idle notifies.
 * @see Thread#run()
 */
public void run(){
  while (running) {
    try {
      long idleTime=0;
      if (idleChangeListeners.size() > 0) {
        idleTime=SystemActivityNotifications.getLastInput();
        if (idleTime < idleStateCheckDelay && listenersInIdleState.size() > 0) {
          for (          SystemActivityChangeListener l : listenersInIdleState) {
            fireSystemIdleEndEvent(l);
          }
          listenersInIdleState.clear();
        }
        for (        Map.Entry<SystemActivityChangeListener,Long> entry : idleChangeListeners.entrySet()) {
          if (entry.getValue() <= idleTime) {
            fireSystemIdleEvent(entry.getKey());
            listenersInIdleState.add(entry.getKey());
          }
        }
      }
      if (listenersInIdleState.size() > 0) {
        idleStateCheckDelay=CHECK_FOR_IDLE_WHEN_IDLE;
      }
 else       if (idleTime != 0) {
        long minIdleSetting=Collections.min(idleChangeListeners.values());
        int newSetting=(int)(minIdleSetting - idleTime) + 1000;
        if (newSetting > 0)         idleStateCheckDelay=newSetting;
 else         idleStateCheckDelay=CHECK_FOR_IDLE_DEFAULT;
      }
 else {
        idleStateCheckDelay=CHECK_FOR_IDLE_DEFAULT;
      }
synchronized (this) {
        this.wait(idleStateCheckDelay);
      }
    }
 catch (    UnsatisfiedLinkError t) {
      logger.error(""String_Node_Str"",t);
      return;
    }
catch (    Throwable t) {
      logger.error(""String_Node_Str"",t);
    }
  }
}","/** 
 * The thread run method that handles idle notifies.
 * @see Thread#run()
 */
public void run(){
  while (running) {
    try {
      long idleTime=0;
      if (idleChangeListeners.size() > 0) {
        idleTime=SystemActivityNotifications.getLastInput();
        if (idleTime < idleStateCheckDelay && listenersInIdleState.size() > 0) {
          for (          SystemActivityChangeListener l : listenersInIdleState) {
            fireSystemIdleEndEvent(l);
          }
          listenersInIdleState.clear();
        }
        for (        Map.Entry<SystemActivityChangeListener,Long> entry : idleChangeListeners.entrySet()) {
          SystemActivityChangeListener listener=entry.getKey();
          if (listenersInIdleState.contains(listener))           continue;
          if (entry.getValue() <= idleTime) {
            fireSystemIdleEvent(listener);
            listenersInIdleState.add(listener);
          }
        }
      }
      if (listenersInIdleState.size() > 0) {
        idleStateCheckDelay=CHECK_FOR_IDLE_WHEN_IDLE;
      }
 else       if (idleTime != 0) {
        long minIdleSetting=Collections.min(idleChangeListeners.values());
        int newSetting=(int)(minIdleSetting - idleTime) + 1000;
        if (newSetting > 0)         idleStateCheckDelay=newSetting;
 else         idleStateCheckDelay=CHECK_FOR_IDLE_DEFAULT;
      }
 else {
        idleStateCheckDelay=CHECK_FOR_IDLE_DEFAULT;
      }
synchronized (this) {
        this.wait(idleStateCheckDelay);
      }
    }
 catch (    UnsatisfiedLinkError t) {
      logger.error(""String_Node_Str"",t);
      return;
    }
catch (    Throwable t) {
      logger.error(""String_Node_Str"",t);
    }
  }
}",0.918868511035126
103346,"/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serverPort the port to use
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(String address,int serverPort,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address,serverPort,serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    startJingleNodesDiscovery();
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}","/** 
 * Connects xmpp connection and login. Returning the state whether is it final - Abort due to certificate cancel or keep trying cause only current address has failed or stop trying cause we succeeded.
 * @param address the address to connect to
 * @param serverPort the port to use
 * @param serviceName the service name to use
 * @param userName the username to use
 * @param password the password to use
 * @param resource and the resource.
 * @return return the state how to continue the connect process.
 * @throws XMPPException if we cannot connect for some reason
 */
private ConnectState connectAndLogin(String address,int serverPort,String serviceName,String userName,String password,String resource) throws XMPPException {
  ConnectionConfiguration confConn=new ConnectionConfiguration(address,serverPort,serviceName,proxy);
  confConn.setReconnectionAllowed(false);
  boolean tlsRequired=!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_ALLOW_NON_SECURE,false);
  confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);
  if (connection != null) {
    logger.error(""String_Node_Str"" + connection.isConnected(),new Exception(""String_Node_Str"" + getAccountID().getAccountAddress()));
    disconnectAndCleanConnection();
  }
  connection=new XMPPConnection(confConn);
  try {
    CertificateService cvs=getCertificateVerificationService();
    if (cvs != null) {
      connection.setCustomTrustManager(new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[]{serviceName,""String_Node_Str"" + serviceName}))));
    }
  }
 catch (  GeneralSecurityException e) {
    logger.error(""String_Node_Str"",e);
    throw new XMPPException(""String_Node_Str"",e);
  }
  if (debugger == null)   debugger=new SmackPacketDebugger();
  debugger.setConnection(connection);
  connection.addPacketListener(debugger,null);
  connection.addPacketInterceptor(debugger,null);
  connection.connect();
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  registerServiceDiscoveryManager();
  if (connectionListener == null) {
    connectionListener=new JabberConnectionListener();
  }
  if (!connection.isSecureConnection() && tlsRequired) {
    throw new XMPPException(""String_Node_Str"");
  }
  connection.addConnectionListener(connectionListener);
  if (abortConnecting) {
    abortConnecting=false;
    disconnectAndCleanConnection();
    return ConnectState.ABORT_CONNECTING;
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
  SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
  SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
  SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
  connection.login(userName,password,resource);
  if (connection.isAuthenticated()) {
    connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    OperationSetPersistentPresenceJabberImpl opSet=(OperationSetPersistentPresenceJabberImpl)this.getOperationSet(OperationSetPersistentPresence.class);
    try {
      opSet.publishPresenceStatus(getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE),""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"");
    }
    startJingleNodesDiscovery();
    return ConnectState.STOP_TRYING;
  }
 else {
    disconnectAndCleanConnection();
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
    return ConnectState.CONTINUE_TRYING;
  }
}",0.9827408552292632
103347,"/** 
 * Adds new <tt>NetworkConfigurationChangeListener</tt> which will be informed for network configuration changes.
 * @param listener the listener.
 */
void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
synchronized (listeners) {
    if (!listeners.contains(listener)) {
      listeners.add(listener);
      initialFireEvents(listener);
    }
  }
  NetaddrActivator.getBundleContext().addServiceListener(this);
  if (this.systemActivityNotificationsService == null) {
    SystemActivityNotificationsService systActService=ServiceUtils.getService(NetaddrActivator.getBundleContext(),SystemActivityNotificationsService.class);
    handleNewSystemActivityNotificationsService(systActService);
  }
}","/** 
 * Adds new <tt>NetworkConfigurationChangeListener</tt> which will be informed for network configuration changes.
 * @param listener the listener.
 */
void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  eventDispatcher.addNetworkConfigurationChangeListener(listener);
  initialFireEvents(listener);
  NetaddrActivator.getBundleContext().addServiceListener(this);
  if (this.systemActivityNotificationsService == null) {
    SystemActivityNotificationsService systActService=ServiceUtils.getService(NetaddrActivator.getBundleContext(),SystemActivityNotificationsService.class);
    handleNewSystemActivityNotificationsService(systActService);
  }
}",0.8907563025210085
103348,"/** 
 * Checks current interfaces configuration against the last saved active interfaces.
 * @param fireEvents whether we will fire events when we detectthat interface is changed. When we start we query the interfaces just to check which are online, without firing events.
 * @param waitBeforeFiringUpEvents milliseconds to wait beforefiring events for interfaces up, sometimes we must wait a little bit and give time for interfaces to configure fully (dns on linux).
 */
private void checkNetworkInterfaces(boolean fireEvents,int waitBeforeFiringUpEvents) throws SocketException {
  Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
  Map<String,List<InetAddress>> currentActiveInterfaces=new HashMap<String,List<InetAddress>>();
  while (e.hasMoreElements()) {
    NetworkInterface networkInterface=e.nextElement();
    if (isInterfaceLoopback(networkInterface))     continue;
    if (isInterfaceUp(networkInterface)) {
      List<InetAddress> addresses=new ArrayList<InetAddress>();
      Enumeration<InetAddress> as=networkInterface.getInetAddresses();
      while (as.hasMoreElements()) {
        InetAddress inetAddress=as.nextElement();
        if (inetAddress.isLinkLocalAddress())         continue;
        addresses.add(inetAddress);
      }
      if (addresses.size() > 0)       currentActiveInterfaces.put(networkInterface.getName(),addresses);
    }
  }
  List<String> inactiveActiveInterfaces=new ArrayList<String>(activeInterfaces.keySet());
  List<String> currentActiveInterfacesSet=new ArrayList<String>(currentActiveInterfaces.keySet());
  inactiveActiveInterfaces.removeAll(currentActiveInterfacesSet);
  for (int i=0; i < inactiveActiveInterfaces.size(); i++) {
    String iface=inactiveActiveInterfaces.get(i);
    if (!currentActiveInterfacesSet.contains(iface)) {
      if (fireEvents)       fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_DOWN));
      activeInterfaces.remove(iface);
    }
  }
  Iterator<Map.Entry<String,List<InetAddress>>> activeEntriesIter=activeInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    Iterator<InetAddress> addrIter=entry.getValue().iterator();
    while (addrIter.hasNext()) {
      InetAddress addr=addrIter.next();
      List<InetAddress> addresses=currentActiveInterfaces.get(entry.getKey());
      if (addresses != null && !addresses.contains(addr)) {
        if (fireEvents)         fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_DOWN,addr));
        addrIter.remove();
      }
    }
  }
  if (waitBeforeFiringUpEvents > 0 && currentActiveInterfaces.size() != 0) {
synchronized (this) {
      try {
        wait(1000);
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  activeEntriesIter=currentActiveInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    for (    InetAddress addr : entry.getValue()) {
      List<InetAddress> addresses=activeInterfaces.get(entry.getKey());
      if (addresses != null && !addresses.contains(addr)) {
        if (fireEvents)         fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_UP,addr));
        addresses.add(addr);
      }
    }
  }
  Iterator<String> ifaceIter=activeInterfaces.keySet().iterator();
  while (ifaceIter.hasNext()) {
    currentActiveInterfaces.remove(ifaceIter.next());
  }
  activeEntriesIter=currentActiveInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    for (    InetAddress addr : entry.getValue()) {
      if (fireEvents)       fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_UP,addr));
    }
    if (fireEvents)     fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.IFACE_UP));
    activeInterfaces.put(entry.getKey(),entry.getValue());
  }
}","/** 
 * Checks current interfaces configuration against the last saved active interfaces.
 * @param fireEvents whether we will fire events when we detectthat interface is changed. When we start we query the interfaces just to check which are online, without firing events.
 * @param waitBeforeFiringUpEvents milliseconds to wait beforefiring events for interfaces up, sometimes we must wait a little bit and give time for interfaces to configure fully (dns on linux).
 */
private void checkNetworkInterfaces(boolean fireEvents,int waitBeforeFiringUpEvents) throws SocketException {
  Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
  Map<String,List<InetAddress>> currentActiveInterfaces=new HashMap<String,List<InetAddress>>();
  while (e.hasMoreElements()) {
    NetworkInterface networkInterface=e.nextElement();
    if (isInterfaceLoopback(networkInterface))     continue;
    if (isInterfaceUp(networkInterface)) {
      List<InetAddress> addresses=new ArrayList<InetAddress>();
      Enumeration<InetAddress> as=networkInterface.getInetAddresses();
      while (as.hasMoreElements()) {
        InetAddress inetAddress=as.nextElement();
        if (inetAddress.isLinkLocalAddress())         continue;
        addresses.add(inetAddress);
      }
      if (addresses.size() > 0)       currentActiveInterfaces.put(networkInterface.getName(),addresses);
    }
  }
  List<String> inactiveActiveInterfaces=new ArrayList<String>(activeInterfaces.keySet());
  List<String> currentActiveInterfacesSet=new ArrayList<String>(currentActiveInterfaces.keySet());
  inactiveActiveInterfaces.removeAll(currentActiveInterfacesSet);
  for (int i=0; i < inactiveActiveInterfaces.size(); i++) {
    String iface=inactiveActiveInterfaces.get(i);
    if (!currentActiveInterfacesSet.contains(iface)) {
      if (fireEvents)       eventDispatcher.fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_DOWN));
      activeInterfaces.remove(iface);
    }
  }
  Iterator<Map.Entry<String,List<InetAddress>>> activeEntriesIter=activeInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    Iterator<InetAddress> addrIter=entry.getValue().iterator();
    while (addrIter.hasNext()) {
      InetAddress addr=addrIter.next();
      List<InetAddress> addresses=currentActiveInterfaces.get(entry.getKey());
      if (addresses != null && !addresses.contains(addr)) {
        if (fireEvents)         eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_DOWN,addr));
        addrIter.remove();
      }
    }
  }
  if (waitBeforeFiringUpEvents > 0 && currentActiveInterfaces.size() != 0) {
synchronized (this) {
      try {
        wait(waitBeforeFiringUpEvents);
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  activeEntriesIter=currentActiveInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    for (    InetAddress addr : entry.getValue()) {
      List<InetAddress> addresses=activeInterfaces.get(entry.getKey());
      if (addresses != null && !addresses.contains(addr)) {
        if (fireEvents)         eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_UP,addr));
        addresses.add(addr);
      }
    }
  }
  Iterator<String> ifaceIter=activeInterfaces.keySet().iterator();
  while (ifaceIter.hasNext()) {
    currentActiveInterfaces.remove(ifaceIter.next());
  }
  activeEntriesIter=currentActiveInterfaces.entrySet().iterator();
  while (activeEntriesIter.hasNext()) {
    final Map.Entry<String,List<InetAddress>> entry=activeEntriesIter.next();
    for (    InetAddress addr : entry.getValue()) {
      if (fireEvents)       eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.ADDRESS_UP,addr));
    }
    if (fireEvents) {
      int wait=waitBeforeFiringUpEvents;
      if (wait == 0) {
        wait=500;
      }
      eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(),ChangeEvent.IFACE_UP),wait);
    }
    activeInterfaces.put(entry.getKey(),entry.getValue());
  }
}",0.972205216113628
103349,"/** 
 * Stop.
 */
void stop(){
  if (isRunning) {
synchronized (this) {
      isRunning=false;
      notifyAll();
    }
  }
}","/** 
 * Stop.
 */
void stop(){
  if (isRunning) {
synchronized (this) {
      isRunning=false;
      notifyAll();
    }
  }
  if (eventDispatcher != null)   eventDispatcher.stop();
}",0.8143322475570033
103350,"/** 
 * Remove <tt>NetworkConfigurationChangeListener</tt>.
 * @param listener the listener.
 */
void removeNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
synchronized (listeners) {
    listeners.remove(listener);
  }
}","/** 
 * Remove <tt>NetworkConfigurationChangeListener</tt>.
 * @param listener the listener.
 */
void removeNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){
  eventDispatcher.removeNetworkConfigurationChangeListener(listener);
}",0.8226120857699805
103351,"/** 
 * Down all interfaces and fire events for it.
 */
private void downAllInterfaces(){
  Iterator<String> iter=activeInterfaces.keySet().iterator();
  while (iter.hasNext()) {
    String niface=iter.next();
    fireChangeEvent(new ChangeEvent(niface,ChangeEvent.IFACE_DOWN,true));
  }
  activeInterfaces.clear();
}","/** 
 * Down all interfaces and fire events for it.
 */
private void downAllInterfaces(){
  Iterator<String> iter=activeInterfaces.keySet().iterator();
  while (iter.hasNext()) {
    String niface=iter.next();
    eventDispatcher.fireChangeEvent(new ChangeEvent(niface,ChangeEvent.IFACE_DOWN,true));
  }
  activeInterfaces.clear();
}",0.9753846153846154
103352,"/** 
 * Used to fire initial events to newly added listers.
 * @param listener the listener to fire.
 */
private void initialFireEvents(NetworkConfigurationChangeListener listener){
  try {
    Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
    while (e.hasMoreElements()) {
      NetworkInterface networkInterface=e.nextElement();
      if (isInterfaceLoopback(networkInterface))       continue;
      if (isInterfaceUp(networkInterface)) {
        Enumeration<InetAddress> as=networkInterface.getInetAddresses();
        boolean hasAddress=false;
        while (as.hasMoreElements()) {
          InetAddress inetAddress=as.nextElement();
          if (inetAddress.isLinkLocalAddress())           continue;
          hasAddress=true;
          fireChangeEvent(new ChangeEvent(networkInterface.getName(),ChangeEvent.ADDRESS_UP,inetAddress,false,true),listener);
        }
        if (hasAddress)         fireChangeEvent(new ChangeEvent(networkInterface.getName(),ChangeEvent.IFACE_UP,null,false,true),listener);
      }
    }
  }
 catch (  SocketException e) {
    logger.error(""String_Node_Str"",e);
  }
}","/** 
 * Used to fire initial events to newly added listers.
 * @param listener the listener to fire.
 */
private void initialFireEvents(NetworkConfigurationChangeListener listener){
  try {
    Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
    while (e.hasMoreElements()) {
      NetworkInterface networkInterface=e.nextElement();
      if (isInterfaceLoopback(networkInterface))       continue;
      if (isInterfaceUp(networkInterface)) {
        Enumeration<InetAddress> as=networkInterface.getInetAddresses();
        boolean hasAddress=false;
        while (as.hasMoreElements()) {
          InetAddress inetAddress=as.nextElement();
          if (inetAddress.isLinkLocalAddress())           continue;
          hasAddress=true;
          NetworkEventDispatcher.fireChangeEvent(new ChangeEvent(networkInterface.getName(),ChangeEvent.ADDRESS_UP,inetAddress,false,true),listener);
        }
        if (hasAddress)         NetworkEventDispatcher.fireChangeEvent(new ChangeEvent(networkInterface.getName(),ChangeEvent.IFACE_UP,null,false,true),listener);
      }
    }
  }
 catch (  SocketException e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.9800693240901212
103353,"/** 
 * Extracts all properties concerning the usage of an outbound proxy for this account.
 * @param accountID the account whose outbound proxy we are currentlyinitializing.
 * @param ix index of the address to use.
 */
void initOutboundProxy(SipAccountID accountID,int ix){
  String proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  boolean proxyAddressAndPortEntered=false;
  if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0 || accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false)) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int domainIx=userID.indexOf(""String_Node_Str"");
    if (domainIx > 0) {
      proxyAddressStr=userID.substring(domainIx + 1);
    }
 else {
      proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
        return;
      }
    }
  }
 else {
    if (accountID.getAccountProperty(ProtocolProviderFactory.PROXY_PORT) != null) {
      proxyAddressAndPortEntered=true;
    }
  }
  InetAddress proxyAddress=null;
  int proxyPort=ListeningPoint.PORT_5060;
  String proxyTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (proxyTransport != null && proxyTransport.length() > 0) {
    if (!proxyTransport.equals(ListeningPoint.UDP) && !proxyTransport.equals(ListeningPoint.TCP) && !proxyTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(proxyTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    proxyTransport=getDefaultTransport();
  }
  try {
    proxyPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.PROXY_PORT,proxyPort);
    if (proxyPort > NetworkUtils.MAX_PORT_NUMBER) {
      throw new IllegalArgumentException(proxyPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
    }
    InetSocketAddress proxySocketAddress=null;
    if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false)) {
      if (connectionAddresses == null) {
        ArrayList<InetSocketAddress> proxySocketAddressesList=new ArrayList<InetSocketAddress>();
        ArrayList<String> proxyTransportsList=new ArrayList<String>();
        resolveSipAddress(proxyAddressStr,proxyTransport,proxySocketAddressesList,proxyTransportsList,true);
        connectionTransports=proxyTransportsList.toArray(new String[proxyTransportsList.size()]);
        connectionAddresses=proxySocketAddressesList.toArray(new InetSocketAddress[proxySocketAddressesList.size()]);
      }
      proxyTransport=connectionTransports[ix];
      proxySocketAddress=connectionAddresses[ix];
    }
 else {
      if (proxyAddressAndPortEntered) {
        if (connectionAddresses == null) {
          ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
          resolveAddresses(proxyAddressStr,addresses,checkPreferIPv6Addresses(),proxyPort);
          connectionAddresses=addresses.toArray(new InetSocketAddress[addresses.size()]);
          connectionTransports=new String[addresses.size()];
          Arrays.fill(connectionTransports,proxyTransport);
        }
        if (connectionAddresses.length > ix)         proxySocketAddress=connectionAddresses[ix];
      }
 else {
        if (connectionAddresses == null) {
          ArrayList<InetSocketAddress> proxySocketAddressesList=new ArrayList<InetSocketAddress>();
          ArrayList<String> proxyTransportsList=new ArrayList<String>();
          resolveSipAddress(proxyAddressStr,proxyTransport,proxySocketAddressesList,proxyTransportsList,false);
          connectionTransports=proxyTransportsList.toArray(new String[proxyTransportsList.size()]);
          connectionAddresses=proxySocketAddressesList.toArray(new InetSocketAddress[proxySocketAddressesList.size()]);
        }
        proxyTransport=connectionTransports[ix];
        proxySocketAddress=connectionAddresses[ix];
      }
    }
    if (proxySocketAddress == null)     throw new UnknownHostException();
    proxyAddress=proxySocketAddress.getAddress();
    proxyPort=proxySocketAddress.getPort();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + proxyAddressStr);
    accountID.putAccountProperty(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.error(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isProxyValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,false);
    if (!isProxyValidated) {
      throw new IllegalArgumentException(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (connectionAddresses == null || connectionAddresses.length == 0) {
    sipRegistrarConnection=null;
    connectionAddresses=null;
    connectionTransports=null;
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  if (proxyAddress == null) {
    return;
  }
  try {
    if (this.getRegistrarConnection() != null)     this.getRegistrarConnection().setTransport(proxyTransport);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + currentConnectionAddress,ex);
    throw new IllegalArgumentException(""String_Node_Str"" + currentConnectionAddress + ""String_Node_Str""+ ex.getMessage());
  }
  StringBuilder proxyStringBuffer=new StringBuilder(proxyAddress.getHostAddress());
  if (proxyAddress instanceof Inet6Address) {
    proxyStringBuffer.insert(0,'[');
    proxyStringBuffer.append(']');
  }
  proxyStringBuffer.append(':');
  proxyStringBuffer.append(Integer.toString(proxyPort));
  proxyStringBuffer.append('/');
  proxyStringBuffer.append(proxyTransport);
  this.outboundProxyString=proxyStringBuffer.toString();
  this.outboundProxySocketAddress=new InetSocketAddress(proxyAddress,proxyPort);
  this.outboundProxyTransport=proxyTransport;
}","/** 
 * Extracts all properties concerning the usage of an outbound proxy for this account.
 * @param accountID the account whose outbound proxy we are currentlyinitializing.
 * @param ix index of the address to use.
 */
void initOutboundProxy(SipAccountID accountID,int ix){
  String proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  boolean proxyAddressAndPortEntered=false;
  if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0 || accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false)) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int domainIx=userID.indexOf(""String_Node_Str"");
    if (domainIx > 0) {
      proxyAddressStr=userID.substring(domainIx + 1);
    }
 else {
      proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
        return;
      }
    }
  }
 else {
    if (accountID.getAccountProperty(ProtocolProviderFactory.PROXY_PORT) != null) {
      proxyAddressAndPortEntered=true;
    }
  }
  InetAddress proxyAddress=null;
  int proxyPort=ListeningPoint.PORT_5060;
  String proxyTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (proxyTransport != null && proxyTransport.length() > 0) {
    if (!proxyTransport.equals(ListeningPoint.UDP) && !proxyTransport.equals(ListeningPoint.TCP) && !proxyTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(proxyTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    proxyTransport=getDefaultTransport();
  }
  try {
    proxyPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.PROXY_PORT,proxyPort);
    if (proxyPort > NetworkUtils.MAX_PORT_NUMBER) {
      throw new IllegalArgumentException(proxyPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
    }
    InetSocketAddress proxySocketAddress=null;
    if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false)) {
      if (connectionAddresses == null) {
        ArrayList<InetSocketAddress> proxySocketAddressesList=new ArrayList<InetSocketAddress>();
        ArrayList<String> proxyTransportsList=new ArrayList<String>();
        resolveSipAddress(proxyAddressStr,proxyTransport,proxySocketAddressesList,proxyTransportsList,true);
        connectionTransports=proxyTransportsList.toArray(new String[proxyTransportsList.size()]);
        connectionAddresses=proxySocketAddressesList.toArray(new InetSocketAddress[proxySocketAddressesList.size()]);
      }
      proxyTransport=connectionTransports[ix];
      proxySocketAddress=connectionAddresses[ix];
    }
 else {
      if (proxyAddressAndPortEntered) {
        if (connectionAddresses == null) {
          ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
          resolveAddresses(proxyAddressStr,addresses,checkPreferIPv6Addresses(),proxyPort);
          connectionAddresses=addresses.toArray(new InetSocketAddress[addresses.size()]);
          connectionTransports=new String[addresses.size()];
          Arrays.fill(connectionTransports,proxyTransport);
        }
        if (connectionAddresses.length > ix)         proxySocketAddress=connectionAddresses[ix];
      }
 else {
        if (connectionAddresses == null) {
          ArrayList<InetSocketAddress> proxySocketAddressesList=new ArrayList<InetSocketAddress>();
          ArrayList<String> proxyTransportsList=new ArrayList<String>();
          resolveSipAddress(proxyAddressStr,proxyTransport,proxySocketAddressesList,proxyTransportsList,false);
          connectionTransports=proxyTransportsList.toArray(new String[proxyTransportsList.size()]);
          connectionAddresses=proxySocketAddressesList.toArray(new InetSocketAddress[proxySocketAddressesList.size()]);
        }
        proxyTransport=connectionTransports[ix];
        proxySocketAddress=connectionAddresses[ix];
      }
    }
    if (proxySocketAddress == null)     throw new UnknownHostException();
    proxyAddress=proxySocketAddress.getAddress();
    if (this.currentConnectionAddress == null)     this.currentConnectionAddress=proxySocketAddress;
    proxyPort=proxySocketAddress.getPort();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + proxyAddressStr);
    accountID.putAccountProperty(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.error(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isProxyValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,false);
    if (!isProxyValidated) {
      throw new IllegalArgumentException(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (connectionAddresses == null || connectionAddresses.length == 0) {
    sipRegistrarConnection=null;
    connectionAddresses=null;
    connectionTransports=null;
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  if (proxyAddress == null) {
    return;
  }
  try {
    if (this.getRegistrarConnection() != null)     this.getRegistrarConnection().setTransport(proxyTransport);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + currentConnectionAddress,ex);
    throw new IllegalArgumentException(""String_Node_Str"" + currentConnectionAddress + ""String_Node_Str""+ ex.getMessage());
  }
  StringBuilder proxyStringBuffer=new StringBuilder(proxyAddress.getHostAddress());
  if (proxyAddress instanceof Inet6Address) {
    proxyStringBuffer.insert(0,'[');
    proxyStringBuffer.append(']');
  }
  proxyStringBuffer.append(':');
  proxyStringBuffer.append(Integer.toString(proxyPort));
  proxyStringBuffer.append('/');
  proxyStringBuffer.append(proxyTransport);
  this.outboundProxyString=proxyStringBuffer.toString();
  this.outboundProxySocketAddress=new InetSocketAddress(proxyAddress,proxyPort);
  this.outboundProxyTransport=proxyTransport;
}",0.9918012825716374
103354,"/** 
 * Implements   {@link AbstractCodecExt#doProcess(Buffer,Buffer)}.
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int inputLength=inputBuffer.getLength();
  if (this.inputLength != inputLength)   initDec(inputLength);
  int outputLength=dec.ULP_inst.blockl * 2;
  byte[] output=validateByteArraySize(outputBuffer,outputLength);
  int outputOffset=0;
  dec.decode(output,outputOffset,input,inputBuffer.getOffset(),(short)1);
  updateOutput(outputBuffer,getOutputFormat(),outputLength,outputOffset);
  return BUFFER_PROCESSED_OK;
}","/** 
 * Implements   {@link AbstractCodecExt#doProcess(Buffer,Buffer)}.
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int inputLength=inputBuffer.getLength();
  if (offsets.size() == 0 && ((inputLength > ilbc_constants.NO_OF_BYTES_20MS && inputLength != ilbc_constants.NO_OF_BYTES_30MS) || inputLength > ilbc_constants.NO_OF_BYTES_30MS)) {
    int nb=0;
    int len=0;
    if ((inputLength % ilbc_constants.NO_OF_BYTES_20MS) == 0) {
      nb=(inputLength % ilbc_constants.NO_OF_BYTES_20MS);
      len=ilbc_constants.NO_OF_BYTES_20MS;
    }
 else     if ((inputLength % ilbc_constants.NO_OF_BYTES_30MS) == 0) {
      nb=(inputLength % ilbc_constants.NO_OF_BYTES_30MS);
      len=ilbc_constants.NO_OF_BYTES_30MS;
    }
    if (this.inputLength != len)     initDec(len);
    for (int i=0; i < nb; i++) {
      offsets.add(new Integer(inputLength + (i * len)));
    }
  }
 else   if (this.inputLength != inputLength)   initDec(inputLength);
  int outputLength=dec.ULP_inst.blockl * 2;
  byte[] output=validateByteArraySize(outputBuffer,outputLength);
  int outputOffset=0;
  int offsetToAdd=0;
  if (offsets.size() > 0)   offsetToAdd=offsets.remove(0).intValue();
  dec.decode(output,outputOffset,input,inputBuffer.getOffset() + offsetToAdd,(short)1);
  updateOutput(outputBuffer,getOutputFormat(),outputLength,outputOffset);
  int flags=BUFFER_PROCESSED_OK;
  if (offsets.size() > 0) {
    flags|=INPUT_BUFFER_NOT_CONSUMED;
  }
  return flags;
}",0.6036925719192786
103355,"/** 
 * Implements   {@link AbstractCodecExt#doClose()}.
 * @see AbstractCodecExt#doClose()
 */
protected void doClose(){
  enc=null;
  outputLength=0;
  inputLength=0;
  prevInput=null;
  prevInputLength=0;
}","/** 
 * Implements   {@link AbstractCodecExt#doClose()}.
 * @see AbstractCodecExt#doClose()
 */
protected void doClose(){
  enc=null;
  outputLength=0;
  inputLength=0;
  prevInput=null;
  prevInputLength=0;
  duration=0;
}",0.9675925925925926
103356,"/** 
 * Implements   {@link AbstractCodecExt#doOpen()}.
 * @see AbstractCodecExt#doOpen()
 */
protected void doOpen(){
  int mode=Constants.ILBC_MODE;
  enc=new ilbc_encoder(mode);
switch (mode) {
case 20:
    outputLength=ilbc_constants.NO_OF_BYTES_20MS;
  break;
case 30:
outputLength=ilbc_constants.NO_OF_BYTES_30MS;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
inputLength=enc.ULP_inst.blockl * 2;
prevInput=new byte[inputLength];
prevInputLength=0;
}","/** 
 * Implements   {@link AbstractCodecExt#doOpen()}.
 * @see AbstractCodecExt#doOpen()
 */
protected void doOpen(){
  int mode=Constants.ILBC_MODE;
  enc=new ilbc_encoder(mode);
switch (mode) {
case 20:
    outputLength=ilbc_constants.NO_OF_BYTES_20MS;
  break;
case 30:
outputLength=ilbc_constants.NO_OF_BYTES_30MS;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
duration=mode * 1000000;
inputLength=enc.ULP_inst.blockl * 2;
prevInput=new byte[inputLength];
prevInputLength=0;
}",0.9746707193515703
103357,"/** 
 * Implements   {@link AbstractCodecExt#doProcess(Buffer,Buffer)}.
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  int inputLength=inputBuffer.getLength();
  byte[] input=(byte[])inputBuffer.getData();
  int inputOffset=inputBuffer.getOffset();
  if ((prevInputLength != 0) || (inputLength < this.inputLength)) {
    int bytesToCopy=this.inputLength - prevInputLength;
    if (bytesToCopy > inputLength)     bytesToCopy=inputLength;
    System.arraycopy(input,inputOffset,prevInput,prevInputLength,bytesToCopy);
    prevInputLength+=bytesToCopy;
    inputBuffer.setLength(inputLength - bytesToCopy);
    inputBuffer.setOffset(inputOffset + bytesToCopy);
    inputLength=prevInputLength;
    input=prevInput;
    inputOffset=0;
  }
 else {
    inputBuffer.setLength(inputLength - this.inputLength);
    inputBuffer.setOffset(inputOffset + this.inputLength);
  }
  int ret;
  if (inputLength >= this.inputLength) {
    prevInputLength=0;
    int outputOffset=0;
    byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
    enc.encode(output,outputOffset,input,inputOffset);
    updateOutput(outputBuffer,outputFormat,outputLength,outputOffset);
    ret=BUFFER_PROCESSED_OK;
  }
 else   ret=OUTPUT_BUFFER_NOT_FILLED;
  if (inputBuffer.getLength() > 0)   ret|=INPUT_BUFFER_NOT_CONSUMED;
  return ret;
}","/** 
 * Implements   {@link AbstractCodecExt#doProcess(Buffer,Buffer)}.
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  int inputLength=inputBuffer.getLength();
  byte[] input=(byte[])inputBuffer.getData();
  int inputOffset=inputBuffer.getOffset();
  if ((prevInputLength != 0) || (inputLength < this.inputLength)) {
    int bytesToCopy=this.inputLength - prevInputLength;
    if (bytesToCopy > inputLength)     bytesToCopy=inputLength;
    System.arraycopy(input,inputOffset,prevInput,prevInputLength,bytesToCopy);
    prevInputLength+=bytesToCopy;
    inputBuffer.setLength(inputLength - bytesToCopy);
    inputBuffer.setOffset(inputOffset + bytesToCopy);
    inputLength=prevInputLength;
    input=prevInput;
    inputOffset=0;
  }
 else {
    inputBuffer.setLength(inputLength - this.inputLength);
    inputBuffer.setOffset(inputOffset + this.inputLength);
  }
  int ret;
  if (inputLength >= this.inputLength) {
    prevInputLength=0;
    int outputOffset=0;
    byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
    enc.encode(output,outputOffset,input,inputOffset);
    updateOutput(outputBuffer,getOutputFormat(),outputLength,outputOffset);
    outputBuffer.setDuration(duration);
    ret=BUFFER_PROCESSED_OK;
  }
 else   ret=OUTPUT_BUFFER_NOT_FILLED;
  if (inputBuffer.getLength() > 0)   ret|=INPUT_BUFFER_NOT_CONSUMED;
  return ret;
}",0.984126984126984
103358,"/** 
 * Notifies this manager that a specific <tt>ProtocolProviderService</tt> has been registered as a service.
 * @param provider the <tt>ProtocolProviderService</tt> which has beenregistered as a service.
 */
private void handleProviderAdded(final ProtocolProviderService provider){
  new Thread(new Runnable(){
    public void run(){
      String className=provider.getClass().getName();
      className=className.substring(0,className.lastIndexOf('.'));
      String acc=ProtocolProviderFactory.findAccountPrefix(bundleContext,provider.getAccountID(),className);
      String password=getCredentialsService().loadPassword(acc);
      enableContactSource(provider.getAccountID().getAccountAddress(),password);
    }
  }
).start();
}","/** 
 * Notifies this manager that a specific <tt>ProtocolProviderService</tt> has been registered as a service.
 * @param provider the <tt>ProtocolProviderService</tt> which has beenregistered as a service.
 */
private void handleProviderAdded(final ProtocolProviderService provider){
  new Thread(new Runnable(){
    public void run(){
      String className=provider.getClass().getName();
      className=className.substring(0,className.lastIndexOf('.'));
      String acc=ProtocolProviderFactory.findAccountPrefix(bundleContext,provider.getAccountID(),className);
      String password=getCredentialsService().loadPassword(acc);
      if (configService.getBoolean(acc + ""String_Node_Str"",true)) {
        enableContactSource(provider.getAccountID().getAccountAddress(),password);
      }
    }
  }
).start();
}",0.9496774193548388
103359,"public void run(){
  String className=provider.getClass().getName();
  className=className.substring(0,className.lastIndexOf('.'));
  String acc=ProtocolProviderFactory.findAccountPrefix(bundleContext,provider.getAccountID(),className);
  String password=getCredentialsService().loadPassword(acc);
  enableContactSource(provider.getAccountID().getAccountAddress(),password);
}","public void run(){
  String className=provider.getClass().getName();
  className=className.substring(0,className.lastIndexOf('.'));
  String acc=ProtocolProviderFactory.findAccountPrefix(bundleContext,provider.getAccountID(),className);
  String password=getCredentialsService().loadPassword(acc);
  if (configService.getBoolean(acc + ""String_Node_Str"",true)) {
    enableContactSource(provider.getAccountID().getAccountAddress(),password);
  }
}",0.9148418491484184
103360,"private void checkNetworkInterfaces(boolean fireEvents){
  try {
    if (activeInterfaces.size() == 0) {
synchronized (this) {
        try {
          wait(1000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
    Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
    List<NetworkInterface> currentActiveInterfaces=new ArrayList<NetworkInterface>();
    while (e.hasMoreElements()) {
      NetworkInterface networkInterface=e.nextElement();
      if (isInterfaceLoopback(networkInterface))       continue;
      if (isInterfaceUp(networkInterface) && hasValidAddress(networkInterface)) {
        currentActiveInterfaces.add(networkInterface);
      }
    }
    List<NetworkInterface> inactiveActiveInterfaces=new ArrayList<NetworkInterface>(activeInterfaces);
    inactiveActiveInterfaces.removeAll(currentActiveInterfaces);
    for (int i=0; i < inactiveActiveInterfaces.size(); i++) {
      NetworkInterface iface=inactiveActiveInterfaces.get(i);
      if (!containsInterfaceWithName(currentActiveInterfaces,iface.getName())) {
        if (fireEvents)         fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_DOWN,false));
        activeInterfaces.remove(iface);
      }
    }
    currentActiveInterfaces.removeAll(activeInterfaces);
    for (int i=0; i < currentActiveInterfaces.size(); i++) {
      NetworkInterface iface=currentActiveInterfaces.get(i);
      if (fireEvents)       fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_UP,false));
      activeInterfaces.add(iface);
    }
  }
 catch (  SocketException e) {
    logger.error(""String_Node_Str"",e);
  }
}","private void checkNetworkInterfaces(boolean fireEvents){
  try {
synchronized (this) {
      try {
        wait(1000);
      }
 catch (      InterruptedException ex) {
      }
    }
    Enumeration<NetworkInterface> e=NetworkInterface.getNetworkInterfaces();
    List<NetworkInterface> currentActiveInterfaces=new ArrayList<NetworkInterface>();
    while (e.hasMoreElements()) {
      NetworkInterface networkInterface=e.nextElement();
      if (isInterfaceLoopback(networkInterface))       continue;
      if (isInterfaceUp(networkInterface) && hasValidAddress(networkInterface)) {
        currentActiveInterfaces.add(networkInterface);
      }
    }
    List<NetworkInterface> inactiveActiveInterfaces=new ArrayList<NetworkInterface>(activeInterfaces);
    inactiveActiveInterfaces.removeAll(currentActiveInterfaces);
    for (int i=0; i < inactiveActiveInterfaces.size(); i++) {
      NetworkInterface iface=inactiveActiveInterfaces.get(i);
      if (!containsInterfaceWithName(currentActiveInterfaces,iface.getName())) {
        if (fireEvents)         fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_DOWN,false));
        activeInterfaces.remove(iface);
      }
    }
    currentActiveInterfaces.removeAll(activeInterfaces);
    for (int i=0; i < currentActiveInterfaces.size(); i++) {
      NetworkInterface iface=currentActiveInterfaces.get(i);
      if (fireEvents)       fireChangeEvent(new ChangeEvent(iface,ChangeEvent.IFACE_UP,false));
      activeInterfaces.add(iface);
    }
  }
 catch (  SocketException e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.967601246105919
103361,"/** 
 * Process candidates received.
 * @param sessionInitIQ The {@link SessionIQ} that created the session weare handling here
 * @throws OperationFailedException if something goes wrong
 */
public void processCandidates(SessionIQ sessionInitIQ) throws OperationFailedException {
  Collection<PacketExtension> extensions=sessionInitIQ.getExtensions();
  List<GTalkCandidatePacketExtension> candidates=new ArrayList<GTalkCandidatePacketExtension>();
  for (  PacketExtension ext : extensions) {
    if (ext.getElementName().equalsIgnoreCase(GTalkCandidatePacketExtension.ELEMENT_NAME)) {
      GTalkCandidatePacketExtension cand=(GTalkCandidatePacketExtension)ext;
      candidates.add(cand);
    }
  }
  try {
    getMediaHandler().processCandidates(candidates);
  }
 catch (  OperationFailedException ofe) {
    logger.warn(""String_Node_Str"",ofe);
    String reasonText=""String_Node_Str"" + ofe.getMessage();
    SessionIQ errResp=GTalkPacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getID(),Reason.GENERAL_ERROR,reasonText);
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  if (freeswitchSession != null) {
    if (!isInitiator)     processSessionAccept(freeswitchSession);
 else     answer();
    freeswitchSession=null;
  }
}","/** 
 * Process candidates received.
 * @param sessionInitIQ The {@link SessionIQ} that created the session weare handling here
 */
public void processCandidates(SessionIQ sessionInitIQ){
  Collection<PacketExtension> extensions=sessionInitIQ.getExtensions();
  List<GTalkCandidatePacketExtension> candidates=new ArrayList<GTalkCandidatePacketExtension>();
  for (  PacketExtension ext : extensions) {
    if (ext.getElementName().equalsIgnoreCase(GTalkCandidatePacketExtension.ELEMENT_NAME)) {
      GTalkCandidatePacketExtension cand=(GTalkCandidatePacketExtension)ext;
      candidates.add(cand);
    }
  }
  try {
    getMediaHandler().processCandidates(candidates);
  }
 catch (  OperationFailedException ofe) {
    logger.warn(""String_Node_Str"",ofe);
    String reasonText=""String_Node_Str"" + ofe.getMessage();
    SessionIQ errResp=GTalkPacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getID(),Reason.GENERAL_ERROR,reasonText);
    getMediaHandler().getTransportManager().close();
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  if (freeswitchSession != null) {
    if (!isInitiator)     processSessionAccept(freeswitchSession);
 else {
      try {
        answer();
      }
 catch (      OperationFailedException e) {
        logger.info(""String_Node_Str"");
      }
    }
    freeswitchSession=null;
  }
}",0.923886355664679
103362,"/** 
 * Removes the room that is currently selected.
 */
void removeSelectedRoom(){
  ChatRoomWrapper chatRoomWrapper=chatRoomsTableModel.getValueAt(chatRoomList.getSelectedRow());
  ConferenceChatManager conferenceManager=GuiActivator.getUIService().getConferenceChatManager();
  conferenceManager.removeChatRoom(chatRoomWrapper);
}","/** 
 * Removes the room that is currently selected.
 */
void removeSelectedRoom(){
  if (chatRoomList.getSelectedRow() == -1)   return;
  ChatRoomWrapper chatRoomWrapper=chatRoomsTableModel.getValueAt(chatRoomList.getSelectedRow());
  ConferenceChatManager conferenceManager=GuiActivator.getUIService().getConferenceChatManager();
  conferenceManager.removeChatRoom(chatRoomWrapper);
}",0.9262865090403338
103363,"/** 
 * Initializes the chat rooms list interface.
 */
private void initChatRoomList(){
  this.chatRoomsTableModel=new ChatRoomTableModel(chatRoomList);
  this.chatRoomList.addMouseListener(this);
  this.chatRoomList.setDefaultRenderer(ProtocolProviderService.class,new ProtocolProviderTableCellRenderer());
  this.chatRoomList.setDefaultRenderer(ChatRoomWrapper.class,new ChatRoomTableCellRenderer());
  this.chatRoomList.setOpaque(false);
  this.chatRoomList.setModel(chatRoomsTableModel);
  ConferenceChatManager confChatManager=GuiActivator.getUIService().getConferenceChatManager();
  confChatManager.addChatRoomListChangeListener(chatRoomsTableModel);
}","/** 
 * Initializes the chat rooms list interface.
 */
private void initChatRoomList(){
  this.chatRoomsTableModel=new ChatRoomTableModel(chatRoomList);
  this.chatRoomList.addMouseListener(this);
  this.chatRoomList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.chatRoomList.setDefaultRenderer(ProtocolProviderService.class,new ProtocolProviderTableCellRenderer());
  this.chatRoomList.setDefaultRenderer(ChatRoomWrapper.class,new ChatRoomTableCellRenderer());
  this.chatRoomList.setOpaque(false);
  this.chatRoomList.setModel(chatRoomsTableModel);
  ConferenceChatManager confChatManager=GuiActivator.getUIService().getConferenceChatManager();
  confChatManager.addChatRoomListChangeListener(chatRoomsTableModel);
}",0.9461593682699212
103364,"/** 
 * Process a packet.
 * @param packet to process.
 */
public void processPacket(Packet packet){
  if (!(packet instanceof org.jivesoftware.smack.packet.Message))   return;
  org.jivesoftware.smack.packet.Message msg=(org.jivesoftware.smack.packet.Message)packet;
  long timeStamp;
  DelayInformation delay=(DelayInformation)msg.getExtension(""String_Node_Str"",""String_Node_Str"");
  if (delay != null) {
    timeStamp=delay.getStamp().getTime();
  }
 else {
    timeStamp=System.currentTimeMillis();
  }
  String msgBody=msg.getBody();
  if (msgBody == null)   return;
  int messageReceivedEventType=ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED;
  String msgFrom=msg.getFrom();
  ChatRoomMember member=null;
  String fromUserName=StringUtils.parseResource(msgFrom);
  if (nickname.equals(getNickName(fromUserName)))   return;
  if (msgFrom.equals(getName())) {
    messageReceivedEventType=ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED;
    member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,getName(),getName());
  }
 else {
    member=smackParticipantToScMember(msgFrom);
  }
  if (member == null) {
    member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,fromUserName,msgFrom);
  }
  if (logger.isDebugEnabled()) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + fromUserName + ""String_Node_Str""+ msg.toXML());
  }
  Message newMessage=createMessage(msgBody);
  if (msg.getType() == org.jivesoftware.smack.packet.Message.Type.error) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + fromUserName);
    XMPPError error=packet.getError();
    int errorCode=error.getCode();
    int errorResultCode=ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;
    String errorReason=error.getMessage();
    if (errorCode == 503) {
      org.jivesoftware.smackx.packet.MessageEvent msgEvent=(org.jivesoftware.smackx.packet.MessageEvent)packet.getExtension(""String_Node_Str"",""String_Node_Str"");
      if (msgEvent != null && msgEvent.isOffline()) {
        errorResultCode=ChatRoomMessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED;
      }
    }
    ChatRoomMessageDeliveryFailedEvent evt=new ChatRoomMessageDeliveryFailedEvent(ChatRoomJabberImpl.this,member,errorResultCode,errorReason,new Date(),newMessage);
    fireMessageEvent(evt);
    return;
  }
  ChatRoomMessageReceivedEvent msgReceivedEvt=new ChatRoomMessageReceivedEvent(ChatRoomJabberImpl.this,member,timeStamp,newMessage,messageReceivedEventType);
  if (delay != null)   msgReceivedEvt.setHistoryMessage(true);
  fireMessageEvent(msgReceivedEvt);
}","/** 
 * Process a packet.
 * @param packet to process.
 */
public void processPacket(Packet packet){
  if (!(packet instanceof org.jivesoftware.smack.packet.Message))   return;
  org.jivesoftware.smack.packet.Message msg=(org.jivesoftware.smack.packet.Message)packet;
  long timeStamp;
  DelayInformation delay=(DelayInformation)msg.getExtension(""String_Node_Str"",""String_Node_Str"");
  if (delay != null) {
    timeStamp=delay.getStamp().getTime();
  }
 else {
    timeStamp=System.currentTimeMillis();
  }
  String msgBody=msg.getBody();
  if (msgBody == null)   return;
  int messageReceivedEventType=ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED;
  String msgFrom=msg.getFrom();
  ChatRoomMember member=null;
  String fromUserName=StringUtils.parseResource(msgFrom);
  if (getUserNickname().equals(fromUserName))   return;
  if (msgFrom.equals(getName())) {
    messageReceivedEventType=ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED;
    member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,getName(),getName());
  }
 else {
    member=smackParticipantToScMember(msgFrom);
  }
  if (member == null) {
    member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,fromUserName,msgFrom);
  }
  if (logger.isDebugEnabled()) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + fromUserName + ""String_Node_Str""+ msg.toXML());
  }
  Message newMessage=createMessage(msgBody);
  if (msg.getType() == org.jivesoftware.smack.packet.Message.Type.error) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + fromUserName);
    XMPPError error=packet.getError();
    int errorCode=error.getCode();
    int errorResultCode=ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;
    String errorReason=error.getMessage();
    if (errorCode == 503) {
      org.jivesoftware.smackx.packet.MessageEvent msgEvent=(org.jivesoftware.smackx.packet.MessageEvent)packet.getExtension(""String_Node_Str"",""String_Node_Str"");
      if (msgEvent != null && msgEvent.isOffline()) {
        errorResultCode=ChatRoomMessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED;
      }
    }
    ChatRoomMessageDeliveryFailedEvent evt=new ChatRoomMessageDeliveryFailedEvent(ChatRoomJabberImpl.this,member,errorResultCode,errorReason,new Date(),newMessage);
    fireMessageEvent(evt);
    return;
  }
  ChatRoomMessageReceivedEvent msgReceivedEvt=new ChatRoomMessageReceivedEvent(ChatRoomJabberImpl.this,member,timeStamp,newMessage,messageReceivedEventType);
  if (delay != null)   msgReceivedEvt.setHistoryMessage(true);
  fireMessageEvent(msgReceivedEvt);
}",0.991112828438949
103365,"/** 
 * Called when a new room occupant has joined the room. Note: Take in consideration that when you join a room you will receive the list of current occupants in the room. This message will be sent for each occupant.
 * @param participant the participant that has just joined the room(e.g. room@conference.jabber.org/nick).
 */
public void joined(String participant){
  if (logger.isInfoEnabled())   logger.info(participant + ""String_Node_Str"" + getName()+ ""String_Node_Str"");
  String participantName=StringUtils.parseResource(participant);
  if (nickname.equals(getNickName(participantName)) || members.containsKey(participantName))   return;
  if (members.contains(participantName))   return;
  Occupant occupant=multiUserChat.getOccupant(participant);
  ChatRoomMemberJabberImpl member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,occupant.getNick(),occupant.getJid());
  members.put(participantName,member);
  fireMemberPresenceEvent(member,ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,null);
}","/** 
 * Called when a new room occupant has joined the room. Note: Take in consideration that when you join a room you will receive the list of current occupants in the room. This message will be sent for each occupant.
 * @param participant the participant that has just joined the room(e.g. room@conference.jabber.org/nick).
 */
public void joined(String participant){
  if (logger.isInfoEnabled())   logger.info(participant + ""String_Node_Str"" + getName()+ ""String_Node_Str"");
  String participantName=StringUtils.parseResource(participant);
  if (nickname.equals(participantName) || members.containsKey(participantName))   return;
  if (members.contains(participantName))   return;
  Occupant occupant=multiUserChat.getOccupant(participant);
  ChatRoomMemberJabberImpl member=new ChatRoomMemberJabberImpl(ChatRoomJabberImpl.this,occupant.getNick(),occupant.getJid());
  members.put(participantName,member);
  fireMemberPresenceEvent(member,ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,null);
}",0.9806259314456036
103366,"/** 
 * Compares to presets and its dimensions.
 * @param o object to compare to.
 * @return a negative integer, zero, or a positive integer as this object isless than, equal to, or greater than the specified object.
 */
public int compareTo(QualityPreset o){
  if (resolution.equals(o.resolution))   return 0;
 else   if ((resolution.height < o.resolution.height) && (resolution.width < o.resolution.width))   return -1;
 else   return 1;
}","/** 
 * Compares to presets and its dimensions.
 * @param o object to compare to.
 * @return a negative integer, zero, or a positive integer as this object isless than, equal to, or greater than the specified object.
 */
public int compareTo(QualityPreset o){
  if (resolution == null)   return -1;
 else   if (o == null)   return 1;
 else   if (resolution.equals(o.resolution))   return 0;
 else   if ((resolution.height < o.resolution.height) && (resolution.width < o.resolution.width))   return -1;
 else   return 1;
}",0.6444906444906445
103367,"/** 
 * Puts all <tt>MediaStream</tt>s in this handler locally on or off hold (according to the value of <tt>locallyOnHold</tt>). This would also be taken into account when the next update offer is generated.
 * @param locallyOnHold <tt>true</tt> if we are to make our audio streamstop transmitting and <tt>false</tt> if we are to start transmitting again.
 */
public void setLocallyOnHold(boolean locallyOnHold){
  this.locallyOnHold=locallyOnHold;
  if (locallyOnHold) {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().and(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().and(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
 else {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().or(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null && videoStream.getDirection() != MediaDirection.INACTIVE) {
      videoStream.setDirection(videoStream.getDirection().or(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
}","/** 
 * Puts all <tt>MediaStream</tt>s in this handler locally on or off hold (according to the value of <tt>locallyOnHold</tt>). This would also be taken into account when the next update offer is generated.
 * @param locallyOnHold <tt>true</tt> if we are to make our audio streamstop transmitting and <tt>false</tt> if we are to start transmitting again.
 */
public void setLocallyOnHold(boolean locallyOnHold){
  this.locallyOnHold=locallyOnHold;
  if (locallyOnHold) {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().and(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().and(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
 else {
    if (CallPeerState.ON_HOLD_MUTUALLY.equals(getPeer().getState())) {
      return;
    }
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().or(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null && videoStream.getDirection() != MediaDirection.INACTIVE) {
      videoStream.setDirection(videoStream.getDirection().or(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
}",0.963960396039604
103368,"/** 
 * Implements   {@link CsrcAudioLevelListener#audioLevelsReceived(long[][])}so that we could deliver to   {@link ConferenceMembersSoundLevelListener}s the events corresponding to the audio level changes that are being reported here.
 * @param audioLevels the levels that we need to dispatch to all registered<tt>ConferenceMemberSoundLevelListeners</tt>.
 */
public void audioLevelsReceived(long[] audioLevels){
  if (getConferenceMemberCount() == 0)   return;
  Map<ConferenceMember,Integer> levelsMap=new HashMap<ConferenceMember,Integer>();
  for (int i=0; i < audioLevels.length; i+=2) {
    ConferenceMember mmbr=findConferenceMember(audioLevels[i]);
    if (mmbr == null)     continue;
 else     levelsMap.put(mmbr,(int)audioLevels[i + 1]);
  }
  ConferenceMembersSoundLevelEvent evt=new ConferenceMembersSoundLevelEvent(this,levelsMap);
synchronized (conferenceMemberAudioLevelListeners) {
    int conferenceMemberAudioLevelListenerCount=conferenceMemberAudioLevelListeners.size();
    for (int i=0; i < conferenceMemberAudioLevelListenerCount; i++)     conferenceMemberAudioLevelListeners.get(i).soundLevelChanged(evt);
  }
}","/** 
 * Implements   {@link CsrcAudioLevelListener#audioLevelsReceived(long[])}so that we could deliver to   {@link ConferenceMembersSoundLevelListener}s the events corresponding to the audio level changes that are being reported here.
 * @param audioLevels the levels that we need to dispatch to all registered<tt>ConferenceMemberSoundLevelListeners</tt>.
 */
public void audioLevelsReceived(long[] audioLevels){
  if (getConferenceMemberCount() == 0)   return;
  Map<ConferenceMember,Integer> levelsMap=new HashMap<ConferenceMember,Integer>();
  for (int i=0; i < audioLevels.length; i+=2) {
    ConferenceMember mmbr=findConferenceMember(audioLevels[i]);
    if (mmbr == null)     continue;
 else     levelsMap.put(mmbr,(int)audioLevels[i + 1]);
  }
  ConferenceMembersSoundLevelEvent evt=new ConferenceMembersSoundLevelEvent(this,levelsMap);
synchronized (conferenceMemberAudioLevelListeners) {
    int conferenceMemberAudioLevelListenerCount=conferenceMemberAudioLevelListeners.size();
    for (int i=0; i < conferenceMemberAudioLevelListenerCount; i++)     conferenceMemberAudioLevelListeners.get(i).soundLevelChanged(evt);
  }
}",0.9991197183098592
103369,"public void handleQuit(ApplicationEvent event){
  ((FileMenu)userData).closeActionPerformed();
  event.setHandled(true);
}","public void handleQuit(ApplicationEvent event){
  ((FileMenu)userData).closeActionPerformed();
synchronized (this) {
    try {
      wait(15000);
    }
 catch (    InterruptedException ex) {
    }
  }
  event.setHandled(true);
}",0.6971428571428572
103370,"public static boolean run(final Object userData){
  Application application=Application.getApplication();
  if (application != null) {
    application.addApplicationListener(new ApplicationAdapter(){
      public void handleQuit(      ApplicationEvent event){
        ((FileMenu)userData).closeActionPerformed();
        event.setHandled(true);
      }
    }
);
    return true;
  }
  return false;
}","public static boolean run(final Object userData){
  Application application=Application.getApplication();
  if (application != null) {
    application.addApplicationListener(new ApplicationAdapter(){
      public void handleQuit(      ApplicationEvent event){
        ((FileMenu)userData).closeActionPerformed();
synchronized (this) {
          try {
            wait(15000);
          }
 catch (          InterruptedException ex) {
          }
        }
        event.setHandled(true);
      }
    }
);
    return true;
  }
  return false;
}",0.8492569002123143
103371,"/** 
 * Creates the ICE agent that we would be using in this transport manager for all negotiation.
 * @return the ICE agent to use for all the ICE negotiation that thistransport manager would be going through
 */
private Agent createIceAgent(){
  CallPeerJabberImpl peer=getCallPeer();
  ProtocolProviderServiceJabberImpl provider=peer.getProtocolProvider();
  NetworkAddressManagerService namSer=getNetAddrMgr();
  boolean atLeastOneStunServer=false;
  Agent agent=namSer.createIceAgent();
  agent.setControlling(!peer.isInitiator());
  JabberAccountID accID=(JabberAccountID)provider.getAccountID();
  if (accID.isStunServerDiscoveryEnabled()) {
    String username=org.jivesoftware.smack.util.StringUtils.parseName(provider.getOurJID());
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(accID);
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(accID.getUserID());
      credentials=provider.getAuthority().obtainCredentials(ProtocolNames.JABBER,credentials,SecurityAuthority.AUTHENTICATION_REQUIRED);
      if (credentials == null) {
        return null;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        return null;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(accID,password);
      }
    }
    StunCandidateHarvester autoHarvester=namSer.discoverStunServer(accID.getService(),StringUtils.getUTF8Bytes(username),StringUtils.getUTF8Bytes(password));
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + autoHarvester);
    if (autoHarvester != null) {
      atLeastOneStunServer=true;
      agent.addCandidateHarvester(autoHarvester);
    }
  }
  for (  StunServerDescriptor desc : accID.getStunServers()) {
    TransportAddress addr=new TransportAddress(desc.getAddress(),desc.getPort(),Transport.UDP);
    StunCandidateHarvester harvester;
    if (desc.isTurnSupported()) {
      harvester=new TurnCandidateHarvester(addr,new LongTermCredential(desc.getUsername(),desc.getPassword()));
    }
 else {
      harvester=new StunCandidateHarvester(addr);
    }
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + harvester);
    atLeastOneStunServer=true;
    agent.addCandidateHarvester(harvester);
  }
  if (!atLeastOneStunServer) {
    if (accID.isUseDefaultStunServer()) {
      TransportAddress addr=new TransportAddress(DEFAULT_STUN_SERVER_ADDRESS,DEFAULT_STUN_SERVER_PORT,Transport.UDP);
      StunCandidateHarvester harvester=new StunCandidateHarvester(addr);
      if (harvester != null) {
        agent.addCandidateHarvester(harvester);
      }
    }
  }
  if (accID.isJingleNodesRelayEnabled()) {
    SmackServiceNode serviceNode=peer.getProtocolProvider().getJingleNodesServiceNode();
    if (serviceNode != null) {
      JingleNodesHarvester harvester=new JingleNodesHarvester(serviceNode);
      if (harvester != null) {
        agent.addCandidateHarvester(harvester);
      }
    }
  }
  if (accID.isUPNPEnabled()) {
    UPNPHarvester harvester=new UPNPHarvester();
    if (harvester != null) {
      agent.addCandidateHarvester(harvester);
    }
  }
  return agent;
}","/** 
 * Creates the ICE agent that we would be using in this transport manager for all negotiation.
 * @return the ICE agent to use for all the ICE negotiation that thistransport manager would be going through
 */
private Agent createIceAgent(){
  CallPeerJabberImpl peer=getCallPeer();
  ProtocolProviderServiceJabberImpl provider=peer.getProtocolProvider();
  NetworkAddressManagerService namSer=getNetAddrMgr();
  boolean atLeastOneStunServer=false;
  Agent agent=namSer.createIceAgent();
  agent.setControlling(!peer.isInitiator());
  JabberAccountID accID=(JabberAccountID)provider.getAccountID();
  if (accID.isStunServerDiscoveryEnabled()) {
    String username=org.jivesoftware.smack.util.StringUtils.parseName(provider.getOurJID());
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(accID);
    if (provider.getUserCredentials() != null)     password=provider.getUserCredentials().getPasswordAsString();
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(accID.getUserID());
      credentials=provider.getAuthority().obtainCredentials(ProtocolNames.JABBER,credentials,SecurityAuthority.AUTHENTICATION_REQUIRED);
      if (credentials == null) {
        return null;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        return null;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(accID,password);
      }
    }
    StunCandidateHarvester autoHarvester=namSer.discoverStunServer(accID.getService(),StringUtils.getUTF8Bytes(username),StringUtils.getUTF8Bytes(password));
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + autoHarvester);
    if (autoHarvester != null) {
      atLeastOneStunServer=true;
      agent.addCandidateHarvester(autoHarvester);
    }
  }
  for (  StunServerDescriptor desc : accID.getStunServers()) {
    TransportAddress addr=new TransportAddress(desc.getAddress(),desc.getPort(),Transport.UDP);
    StunCandidateHarvester harvester;
    if (desc.isTurnSupported()) {
      harvester=new TurnCandidateHarvester(addr,new LongTermCredential(desc.getUsername(),desc.getPassword()));
    }
 else {
      harvester=new StunCandidateHarvester(addr);
    }
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + harvester);
    atLeastOneStunServer=true;
    agent.addCandidateHarvester(harvester);
  }
  if (!atLeastOneStunServer) {
    if (accID.isUseDefaultStunServer()) {
      TransportAddress addr=new TransportAddress(DEFAULT_STUN_SERVER_ADDRESS,DEFAULT_STUN_SERVER_PORT,Transport.UDP);
      StunCandidateHarvester harvester=new StunCandidateHarvester(addr);
      if (harvester != null) {
        agent.addCandidateHarvester(harvester);
      }
    }
  }
  if (accID.isJingleNodesRelayEnabled()) {
    SmackServiceNode serviceNode=peer.getProtocolProvider().getJingleNodesServiceNode();
    if (serviceNode != null) {
      JingleNodesHarvester harvester=new JingleNodesHarvester(serviceNode);
      if (harvester != null) {
        agent.addCandidateHarvester(harvester);
      }
    }
  }
  if (accID.isUPNPEnabled()) {
    UPNPHarvester harvester=new UPNPHarvester();
    if (harvester != null) {
      agent.addCandidateHarvester(harvester);
    }
  }
  return agent;
}",0.9829639680385948
103372,"/** 
 * Gets the matching output formats for a specific format.
 * @param in input format
 * @return array for formats matching input format
 */
private Format[] getMatchingOutputFormats(Format in){
  VideoFormat videoIn=(VideoFormat)in;
  return new Format[]{new ParameterizedVideoFormat(Constants.H264,videoIn.getSize(),Format.NOT_SPECIFIED,Format.byteArray,videoIn.getFrameRate(),ParameterizedVideoFormat.toMap(PACKETIZATION_MODE_FMTP,Integer.toString(packetizationMode)))};
}","/** 
 * Gets the matching output formats for a specific format.
 * @param in input format
 * @return array for formats matching input format
 */
private Format[] getMatchingOutputFormats(Format in){
  VideoFormat videoIn=(VideoFormat)in;
  String[] packetizationModes=(this.packetizationMode == null) ? new String[]{""String_Node_Str"",""String_Node_Str""} : new String[]{this.packetizationMode};
  Format[] matchingOutputFormats=new Format[packetizationModes.length];
  Dimension size=videoIn.getSize();
  float frameRate=videoIn.getFrameRate();
  for (int index=packetizationModes.length - 1; index >= 0; index--) {
    matchingOutputFormats[index]=new ParameterizedVideoFormat(Constants.H264,size,Format.NOT_SPECIFIED,Format.byteArray,frameRate,ParameterizedVideoFormat.toMap(PACKETIZATION_MODE_FMTP,packetizationModes[index]));
  }
  return matchingOutputFormats;
}",0.6220238095238095
103373,"/** 
 * Sets the packetization mode to be used for the H.264 RTP payload output by this <tt>JNIEncoder</tt> and the associated packetizer.
 * @param packetizationMode the packetization mode to be used for the H.264RTP payload output by this <tt>JNIEncoder</tt> and the associated packetizer
 */
public void setPacketizationMode(String packetizationMode){
  if ((packetizationMode == null) || ""String_Node_Str"".equals(packetizationMode))   this.packetizationMode=0;
 else   if (""String_Node_Str"".equals(packetizationMode))   this.packetizationMode=1;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Sets the packetization mode to be used for the H.264 RTP payload output by this <tt>JNIEncoder</tt> and the associated packetizer.
 * @param packetizationMode the packetization mode to be used for the H.264RTP payload output by this <tt>JNIEncoder</tt> and the associated packetizer
 */
public void setPacketizationMode(String packetizationMode){
  if ((packetizationMode == null) || ""String_Node_Str"".equals(packetizationMode))   this.packetizationMode=""String_Node_Str"";
 else   if (""String_Node_Str"".equals(packetizationMode))   this.packetizationMode=""String_Node_Str"";
 else   throw new IllegalArgumentException(""String_Node_Str"");
}",0.9714285714285714
103374,"/** 
 * Sets the <tt>Format</tt> in which this <tt>Codec</tt> is to output media data.
 * @param out the <tt>Format</tt> in which this <tt>Codec</tt> is tooutput media data
 * @return the <tt>Format</tt> in which this <tt>Codec</tt> is currentlyconfigured to output media data or <tt>null</tt> if <tt>format</tt> was found to be incompatible with this <tt>Codec</tt>
 */
@Override public Format setOutputFormat(Format out){
  if (!(out instanceof VideoFormat) || (null == AbstractCodecExt.matches(out,getMatchingOutputFormats(inputFormat))))   return null;
  VideoFormat videoOut=(VideoFormat)out;
  Dimension outSize=videoOut.getSize();
  if (outSize == null) {
    Dimension inSize=((VideoFormat)inputFormat).getSize();
    outSize=(inSize == null) ? new Dimension(Constants.VIDEO_WIDTH,Constants.VIDEO_HEIGHT) : inSize;
  }
  Map<String,String> fmtps=null;
  if (out instanceof ParameterizedVideoFormat)   fmtps=((ParameterizedVideoFormat)out).getFormatParameters();
  if (fmtps == null)   fmtps=new HashMap<String,String>();
  fmtps.put(PACKETIZATION_MODE_FMTP,Integer.toString(packetizationMode));
  outputFormat=new ParameterizedVideoFormat(videoOut.getEncoding(),outSize,Format.NOT_SPECIFIED,Format.byteArray,videoOut.getFrameRate(),fmtps);
  return outputFormat;
}","/** 
 * Sets the <tt>Format</tt> in which this <tt>Codec</tt> is to output media data.
 * @param out the <tt>Format</tt> in which this <tt>Codec</tt> is tooutput media data
 * @return the <tt>Format</tt> in which this <tt>Codec</tt> is currentlyconfigured to output media data or <tt>null</tt> if <tt>format</tt> was found to be incompatible with this <tt>Codec</tt>
 */
@Override public Format setOutputFormat(Format out){
  if (!(out instanceof VideoFormat) || (null == AbstractCodecExt.matches(out,getMatchingOutputFormats(inputFormat))))   return null;
  VideoFormat videoOut=(VideoFormat)out;
  Dimension outSize=videoOut.getSize();
  if (outSize == null) {
    Dimension inSize=((VideoFormat)inputFormat).getSize();
    outSize=(inSize == null) ? new Dimension(Constants.VIDEO_WIDTH,Constants.VIDEO_HEIGHT) : inSize;
  }
  Map<String,String> fmtps=null;
  if (out instanceof ParameterizedVideoFormat)   fmtps=((ParameterizedVideoFormat)out).getFormatParameters();
  if (fmtps == null)   fmtps=new HashMap<String,String>();
  if (packetizationMode != null)   fmtps.put(PACKETIZATION_MODE_FMTP,packetizationMode);
  outputFormat=new ParameterizedVideoFormat(videoOut.getEncoding(),outSize,Format.NOT_SPECIFIED,Format.byteArray,videoOut.getFrameRate(),fmtps);
  return outputFormat;
}",0.9800703399765534
103375,"/** 
 * Opens this <tt>Codec</tt>.
 */
@Override public synchronized void open() throws ResourceUnavailableException {
  if (opened)   return;
  if (inputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  if (outputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  VideoFormat outputVideoFormat=(VideoFormat)outputFormat;
  Dimension size=outputVideoFormat.getSize();
  int width=size.width;
  int height=size.height;
  long avcodec=FFmpeg.avcodec_find_encoder(FFmpeg.CODEC_ID_H264);
  avctx=FFmpeg.avcodec_alloc_context();
  FFmpeg.avcodeccontext_set_pix_fmt(avctx,FFmpeg.PIX_FMT_YUV420P);
  FFmpeg.avcodeccontext_set_size(avctx,width,height);
  FFmpeg.avcodeccontext_set_qcompress(avctx,0.6f);
  int bitRate=128000;
  int frameRate=(int)outputVideoFormat.getFrameRate();
  if (frameRate == Format.NOT_SPECIFIED)   frameRate=DEFAULT_FRAME_RATE;
  FFmpeg.avcodeccontext_set_bit_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_bit_rate_tolerance(avctx,(bitRate / frameRate));
  FFmpeg.avcodeccontext_set_rc_max_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_sample_aspect_ratio(avctx,0,0);
  FFmpeg.avcodeccontext_set_thread_count(avctx,1);
  FFmpeg.avcodeccontext_set_time_base(avctx,1,frameRate);
  FFmpeg.avcodeccontext_set_ticks_per_frame(avctx,2);
  FFmpeg.avcodeccontext_set_quantizer(avctx,30,31,4);
  FFmpeg.avcodeccontext_add_partitions(avctx,0x111);
  FFmpeg.avcodeccontext_set_mb_decision(avctx,FFmpeg.FF_MB_DECISION_SIMPLE);
  FFmpeg.avcodeccontext_set_rc_eq(avctx,""String_Node_Str"");
  FFmpeg.avcodeccontext_add_flags(avctx,FFmpeg.CODEC_FLAG_LOOP_FILTER);
  FFmpeg.avcodeccontext_add_flags2(avctx,FFmpeg.CODEC_FLAG2_INTRA_REFRESH);
  FFmpeg.avcodeccontext_set_me_method(avctx,7);
  FFmpeg.avcodeccontext_set_me_subpel_quality(avctx,2);
  FFmpeg.avcodeccontext_set_me_range(avctx,16);
  FFmpeg.avcodeccontext_set_me_cmp(avctx,FFmpeg.FF_CMP_CHROMA);
  FFmpeg.avcodeccontext_set_scenechange_threshold(avctx,40);
  FFmpeg.avcodeccontext_set_crf(avctx,0);
  FFmpeg.avcodeccontext_set_rc_buffer_size(avctx,10);
  FFmpeg.avcodeccontext_set_gop_size(avctx,IFRAME_INTERVAL);
  FFmpeg.avcodeccontext_set_i_quant_factor(avctx,1f / 1.4f);
  FFmpeg.avcodeccontext_set_refs(avctx,1);
  FFmpeg.avcodeccontext_set_keyint_min(avctx,0);
  if (packetizationMode == 0) {
    FFmpeg.avcodeccontext_set_rtp_payload_size(avctx,Packetizer.MAX_PAYLOAD_SIZE);
  }
  ConfigurationService configuration=NeomediaActivator.getConfigurationService();
  String profile=(configuration == null) ? null : configuration.getString(DEFAULT_PROFILE_PNAME,DEFAULT_DEFAULT_PROFILE);
  try {
    FFmpeg.avcodeccontext_set_profile(avctx,BASELINE_PROFILE.equalsIgnoreCase(profile) ? FFmpeg.FF_PROFILE_H264_BASELINE : FFmpeg.FF_PROFILE_H264_MAIN);
  }
 catch (  UnsatisfiedLinkError ule) {
    logger.warn(""String_Node_Str"");
  }
  if (FFmpeg.avcodec_open(avctx,avcodec) < 0) {
    throw new ResourceUnavailableException(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
  }
  encFrameLen=(width * height * 3) / 2;
  rawFrameBuffer=FFmpeg.av_malloc(encFrameLen);
  avframe=FFmpeg.avcodec_alloc_frame();
  int sizeInBytes=width * height;
  FFmpeg.avframe_set_data(avframe,rawFrameBuffer,sizeInBytes,sizeInBytes / 4);
  FFmpeg.avframe_set_linesize(avframe,width,width / 2,width / 2);
  encFrameBuffer=new byte[encFrameLen];
  if (keyFrameRequestee == null) {
    keyFrameRequestee=new KeyFrameControl.KeyFrameRequestee(){
      public boolean keyFrameRequest(){
        return JNIEncoder.this.keyFrameRequest();
      }
    }
;
  }
  if (keyFrameControl != null)   keyFrameControl.addKeyFrameRequestee(-1,keyFrameRequestee);
  opened=true;
  super.open();
}","/** 
 * Opens this <tt>Codec</tt>.
 */
@Override public synchronized void open() throws ResourceUnavailableException {
  if (opened)   return;
  if (inputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  if (outputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  VideoFormat outputVideoFormat=(VideoFormat)outputFormat;
  Dimension size=outputVideoFormat.getSize();
  int width=size.width;
  int height=size.height;
  long avcodec=FFmpeg.avcodec_find_encoder(FFmpeg.CODEC_ID_H264);
  avctx=FFmpeg.avcodec_alloc_context();
  FFmpeg.avcodeccontext_set_pix_fmt(avctx,FFmpeg.PIX_FMT_YUV420P);
  FFmpeg.avcodeccontext_set_size(avctx,width,height);
  FFmpeg.avcodeccontext_set_qcompress(avctx,0.6f);
  int bitRate=128000;
  int frameRate=(int)outputVideoFormat.getFrameRate();
  if (frameRate == Format.NOT_SPECIFIED)   frameRate=DEFAULT_FRAME_RATE;
  FFmpeg.avcodeccontext_set_bit_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_bit_rate_tolerance(avctx,(bitRate / frameRate));
  FFmpeg.avcodeccontext_set_rc_max_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_sample_aspect_ratio(avctx,0,0);
  FFmpeg.avcodeccontext_set_thread_count(avctx,1);
  FFmpeg.avcodeccontext_set_time_base(avctx,1,frameRate);
  FFmpeg.avcodeccontext_set_ticks_per_frame(avctx,2);
  FFmpeg.avcodeccontext_set_quantizer(avctx,30,31,4);
  FFmpeg.avcodeccontext_add_partitions(avctx,0x111);
  FFmpeg.avcodeccontext_set_mb_decision(avctx,FFmpeg.FF_MB_DECISION_SIMPLE);
  FFmpeg.avcodeccontext_set_rc_eq(avctx,""String_Node_Str"");
  FFmpeg.avcodeccontext_add_flags(avctx,FFmpeg.CODEC_FLAG_LOOP_FILTER);
  FFmpeg.avcodeccontext_add_flags2(avctx,FFmpeg.CODEC_FLAG2_INTRA_REFRESH);
  FFmpeg.avcodeccontext_set_me_method(avctx,7);
  FFmpeg.avcodeccontext_set_me_subpel_quality(avctx,2);
  FFmpeg.avcodeccontext_set_me_range(avctx,16);
  FFmpeg.avcodeccontext_set_me_cmp(avctx,FFmpeg.FF_CMP_CHROMA);
  FFmpeg.avcodeccontext_set_scenechange_threshold(avctx,40);
  FFmpeg.avcodeccontext_set_crf(avctx,0);
  FFmpeg.avcodeccontext_set_rc_buffer_size(avctx,10);
  FFmpeg.avcodeccontext_set_gop_size(avctx,IFRAME_INTERVAL);
  FFmpeg.avcodeccontext_set_i_quant_factor(avctx,1f / 1.4f);
  FFmpeg.avcodeccontext_set_refs(avctx,1);
  FFmpeg.avcodeccontext_set_keyint_min(avctx,0);
  if ((null == packetizationMode) || ""String_Node_Str"".equals(packetizationMode)) {
    FFmpeg.avcodeccontext_set_rtp_payload_size(avctx,Packetizer.MAX_PAYLOAD_SIZE);
  }
  ConfigurationService configuration=NeomediaActivator.getConfigurationService();
  String profile=(configuration == null) ? null : configuration.getString(DEFAULT_PROFILE_PNAME,DEFAULT_DEFAULT_PROFILE);
  try {
    FFmpeg.avcodeccontext_set_profile(avctx,BASELINE_PROFILE.equalsIgnoreCase(profile) ? FFmpeg.FF_PROFILE_H264_BASELINE : FFmpeg.FF_PROFILE_H264_MAIN);
  }
 catch (  UnsatisfiedLinkError ule) {
    logger.warn(""String_Node_Str"");
  }
  if (FFmpeg.avcodec_open(avctx,avcodec) < 0) {
    throw new ResourceUnavailableException(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
  }
  encFrameLen=(width * height * 3) / 2;
  rawFrameBuffer=FFmpeg.av_malloc(encFrameLen);
  avframe=FFmpeg.avcodec_alloc_frame();
  int sizeInBytes=width * height;
  FFmpeg.avframe_set_data(avframe,rawFrameBuffer,sizeInBytes,sizeInBytes / 4);
  FFmpeg.avframe_set_linesize(avframe,width,width / 2,width / 2);
  encFrameBuffer=new byte[encFrameLen];
  if (keyFrameRequestee == null) {
    keyFrameRequestee=new KeyFrameControl.KeyFrameRequestee(){
      public boolean keyFrameRequest(){
        return JNIEncoder.this.keyFrameRequest();
      }
    }
;
  }
  if (keyFrameControl != null)   keyFrameControl.addKeyFrameRequestee(-1,keyFrameRequestee);
  opened=true;
  super.open();
}",0.988213233324404
103376,"/** 
 * Returns the list of formats supported at the output.
 * @param in input <tt>Format</tt> to determine corresponding output<tt>Format/tt>s
 * @return array of formats supported at output
 */
public Format[] getSupportedOutputFormats(Format in){
  if (in == null)   return SUPPORTED_OUTPUT_FORMATS;
  if (!(in instanceof VideoFormat) || (null == AbstractCodecExt.matches(in,inputFormats)))   return new Format[0];
  return getMatchingOutputFormats(in);
}","/** 
 * Returns the list of formats supported at the output.
 * @param in input <tt>Format</tt> to determine corresponding output<tt>Format</tt>s
 * @return array of formats supported at output
 */
public Format[] getSupportedOutputFormats(Format in){
  Format[] supportedOutputFormats;
  if (in == null)   supportedOutputFormats=SUPPORTED_OUTPUT_FORMATS;
 else   if (!(in instanceof VideoFormat) || (null == AbstractCodecExt.matches(in,inputFormats)))   supportedOutputFormats=new Format[0];
 else   supportedOutputFormats=getMatchingOutputFormats(in);
  return supportedOutputFormats;
}",0.8003820439350525
103377,"/** 
 * Finds the first <tt>Format</tt> instance in a specific list of <tt>Format</tt>s which matches a specific <tt>Format</tt>. The implementation considers a pair of <tt>Format</tt>s matching if they have the same encoding.
 * @param formats the array of <tt>Format</tt>s to be searched for a matchto the specified <tt>format</tt>
 * @param format the <tt>Format</tt> to search for a match in the specified<tt>formats</tt>
 * @return the first element of <tt>formats</tt> which matches<tt>format</tt> i.e. is of the same encoding
 */
private static Format findFirstMatchingFormat(Format[] formats,Format format){
  double formatSampleRate=(format instanceof AudioFormat) ? ((AudioFormat)format).getSampleRate() : Format.NOT_SPECIFIED;
  for (  Format match : formats) {
    if (match.isSameEncoding(format)) {
      if ((formatSampleRate != Format.NOT_SPECIFIED) && (match instanceof AudioFormat)) {
        double matchSampleRate=((AudioFormat)match).getSampleRate();
        if ((matchSampleRate != Format.NOT_SPECIFIED) && (matchSampleRate != formatSampleRate))         continue;
      }
      return match;
    }
  }
  return null;
}","/** 
 * Finds the first <tt>Format</tt> instance in a specific list of <tt>Format</tt>s which matches a specific <tt>Format</tt>. The implementation considers a pair of <tt>Format</tt>s matching if they have the same encoding.
 * @param formats the array of <tt>Format</tt>s to be searched for a matchto the specified <tt>format</tt>
 * @param format the <tt>Format</tt> to search for a match in the specified<tt>formats</tt>
 * @return the first element of <tt>formats</tt> which matches<tt>format</tt> i.e. is of the same encoding
 */
private static Format findFirstMatchingFormat(Format[] formats,Format format){
  double formatSampleRate=(format instanceof AudioFormat) ? ((AudioFormat)format).getSampleRate() : Format.NOT_SPECIFIED;
  ParameterizedVideoFormat parameterizedVideoFormat=(format instanceof ParameterizedVideoFormat) ? (ParameterizedVideoFormat)format : null;
  for (  Format match : formats) {
    if (match.isSameEncoding(format)) {
      if (match instanceof AudioFormat) {
        if (formatSampleRate != Format.NOT_SPECIFIED) {
          double matchSampleRate=((AudioFormat)match).getSampleRate();
          if ((matchSampleRate != Format.NOT_SPECIFIED) && (matchSampleRate != formatSampleRate))           continue;
        }
      }
 else       if (match instanceof ParameterizedVideoFormat) {
        if (!((ParameterizedVideoFormat)match).formatParametersMatch(format))         continue;
      }
 else       if (parameterizedVideoFormat != null) {
        if (!parameterizedVideoFormat.formatParametersMatch(match))         continue;
      }
      return match;
    }
  }
  return null;
}",0.7542649727767695
103378,"/** 
 * Creates a new <tt>MediaFormat</tt> instance for a specific JMF <tt>Format</tt> and assigns it specific clock rate and set of format-specific parameters.
 * @param format the JMF <tt>Format</tt> the new instance is to provide animplementation of <tt>MediaFormat</tt> for
 * @param clockRate the clock rate of the new instance
 * @param formatParameters the set of format-specific parameters of the newinstance
 * @param advancedAttrs advanced attributes of the new instance
 * @return a new <tt>MediaFormat</tt> instance for the specified JMF<tt>Format</tt> and with the specified clock rate and set of format-specific parameters
 */
public static MediaFormatImpl<? extends Format> createInstance(Format format,double clockRate,Map<String,String> formatParameters,Map<String,String> advancedAttrs){
  if (format instanceof AudioFormat) {
    AudioFormat audioFormat=(AudioFormat)format;
    AudioFormat clockRateAudioFormat=new AudioFormat(audioFormat.getEncoding(),clockRate,audioFormat.getSampleSizeInBits(),audioFormat.getChannels());
    return new AudioMediaFormatImpl((AudioFormat)clockRateAudioFormat.intersects(audioFormat),formatParameters,advancedAttrs);
  }
  if (format instanceof VideoFormat)   return new VideoMediaFormatImpl((VideoFormat)format,clockRate,-1,formatParameters,advancedAttrs);
  return null;
}","/** 
 * Creates a new <tt>MediaFormat</tt> instance for a specific JMF <tt>Format</tt> and assigns it specific clock rate and set of format-specific parameters.
 * @param format the JMF <tt>Format</tt> the new instance is to provide animplementation of <tt>MediaFormat</tt> for
 * @param clockRate the clock rate of the new instance
 * @param formatParameters the set of format-specific parameters of the newinstance
 * @param advancedAttrs advanced attributes of the new instance
 * @return a new <tt>MediaFormat</tt> instance for the specified JMF<tt>Format</tt> and with the specified clock rate and set of format-specific parameters
 */
public static MediaFormatImpl<? extends Format> createInstance(Format format,double clockRate,Map<String,String> formatParameters,Map<String,String> advancedAttrs){
  if (format instanceof AudioFormat) {
    AudioFormat audioFormat=(AudioFormat)format;
    AudioFormat clockRateAudioFormat=new AudioFormat(audioFormat.getEncoding(),clockRate,audioFormat.getSampleSizeInBits(),audioFormat.getChannels());
    return new AudioMediaFormatImpl((AudioFormat)clockRateAudioFormat.intersects(audioFormat),formatParameters,advancedAttrs);
  }
 else   if (format instanceof VideoFormat)   return new VideoMediaFormatImpl((VideoFormat)format,clockRate,-1,formatParameters,advancedAttrs);
 else   return null;
}",0.995505617977528
103379,"/** 
 * Determines whether a specific format matches this instance i.e. whether their attributes match according to the definition of ""match"" given by  {@link Format#matches(Format)}.
 * @param format the <tt>Format</tt> to compare to this instance
 * @return <tt>true</tt> if the specified <tt>format</tt> matches this one;otherwise, <tt>false</tt>
 */
@Override public boolean matches(Format format){
  if (!super.matches(format))   return false;
  Map<String,String> formatFmtps=null;
  if (format instanceof ParameterizedVideoFormat)   formatFmtps=((ParameterizedVideoFormat)format).getFormatParameters();
  return VideoMediaFormatImpl.formatParametersMatch(getEncoding(),getFormatParameters(),formatFmtps);
}","/** 
 * Determines whether a specific format matches this instance i.e. whether their attributes match according to the definition of ""match"" given by  {@link Format#matches(Format)}.
 * @param format the <tt>Format</tt> to compare to this instance
 * @return <tt>true</tt> if the specified <tt>format</tt> matches this one;otherwise, <tt>false</tt>
 */
@Override public boolean matches(Format format){
  if (!super.matches(format))   return false;
  return formatParametersMatch(format);
}",0.771404821280133
103380,"/** 
 * Initializes a new <tt>VideoMediaFormatImpl</tt> instance which is to provide an implementation of <tt>VideoMediaFormat</tt> for a specific JMF <tt>VideoFormat</tt> and to have specific clock rate and set of format-specific parameters.
 * @param format the JMF <tt>VideoFormat</tt> the new instance is to wrapand provide an implementation of <tt>VideoMediaFormat</tt> for
 * @param clockRate the clock rate of the new <tt>VideoMediaFormatImpl</tt>instance
 * @param frameRate the frame rate of the new <tt>VideoMediaFormatImpl</tt>instance
 * @param formatParameters the set of format-specific parameters of the newinstance
 * @param advancedParameters set of advanced parameters of the new instance
 */
VideoMediaFormatImpl(VideoFormat format,double clockRate,float frameRate,Map<String,String> formatParameters,Map<String,String> advancedParameters){
  super(new VideoFormat(format.getEncoding(),format.getSize(),format.getMaxDataLength(),format.getDataType(),frameRate),formatParameters,advancedParameters);
  this.clockRate=clockRate;
}","/** 
 * Initializes a new <tt>VideoMediaFormatImpl</tt> instance which is to provide an implementation of <tt>VideoMediaFormat</tt> for a specific JMF <tt>VideoFormat</tt> and to have specific clock rate and set of format-specific parameters.
 * @param format the JMF <tt>VideoFormat</tt> the new instance is to wrapand provide an implementation of <tt>VideoMediaFormat</tt> for
 * @param clockRate the clock rate of the new <tt>VideoMediaFormatImpl</tt>instance
 * @param frameRate the frame rate of the new <tt>VideoMediaFormatImpl</tt>instance
 * @param formatParameters the set of format-specific parameters of the newinstance
 * @param advancedParameters set of advanced parameters of the new instance
 */
VideoMediaFormatImpl(VideoFormat format,double clockRate,float frameRate,Map<String,String> formatParameters,Map<String,String> advancedParameters){
  super(new ParameterizedVideoFormat(format.getEncoding(),format.getSize(),format.getMaxDataLength(),format.getDataType(),frameRate,formatParameters),formatParameters,advancedParameters);
  this.clockRate=clockRate;
}",0.9858757062146892
103381,"/** 
 * Clear saved password. Used when we are in situation that saved username and password are no longer valid.
 */
public void clear(){
  if (usedScope != null) {
    if (passwordPropertyName == null)     passwordPropertyName=getCredentialProperty(usedScope);
    if (usernamePropertyName == null)     usernamePropertyName=getCredentialProperty(usedScope);
    HttpUtilActivator.getConfigurationService().removeProperty(usernamePropertyName);
    HttpUtilActivator.getCredentialsService().removePassword(passwordPropertyName);
  }
}","/** 
 * Clear saved password. Used when we are in situation that saved username and password are no longer valid.
 */
public void clear(){
  if (usedScope != null) {
    if (passwordPropertyName == null)     passwordPropertyName=getCredentialProperty(usedScope);
    if (usernamePropertyName == null)     usernamePropertyName=getCredentialProperty(usedScope);
    HttpUtilActivator.getConfigurationService().removeProperty(usernamePropertyName);
    HttpUtilActivator.getCredentialsService().removePassword(passwordPropertyName);
  }
  this.challengedForCredentials=false;
}",0.9648331830477908
103382,"/** 
 * Get the   {@link org.apache.http.auth.Credentials credentials} for thegiven authentication scope.
 * @param authscope the {@link org.apache.http.auth.AuthScope authentication scope}
 * @return the credentials
 * @see #setCredentials(org.apache.http.auth.AuthScope,org.apache.http.auth.Credentials)
 */
public Credentials getCredentials(AuthScope authscope){
  this.usedScope=authscope;
  if (passwordPropertyName == null)   passwordPropertyName=getCredentialProperty(authscope);
  if (usernamePropertyName == null)   usernamePropertyName=getCredentialProperty(authscope);
  String pass=HttpUtilActivator.getCredentialsService().loadPassword(passwordPropertyName);
  if (pass == null) {
    AuthenticationWindow authWindow=new AuthenticationWindow(authscope.getHost(),true,null);
    authWindow.setVisible(true);
    if (!authWindow.isCanceled()) {
      Credentials cred=new UsernamePasswordCredentials(authWindow.getUserName(),new String(authWindow.getPassword()));
      if (authWindow.isRememberPassword()) {
        HttpUtilActivator.getConfigurationService().setProperty(usernamePropertyName,authWindow.getUserName());
        HttpUtilActivator.getCredentialsService().storePassword(passwordPropertyName,new String(authWindow.getPassword()));
      }
      return cred;
    }
    retry=false;
  }
 else {
    return new UsernamePasswordCredentials(HttpUtilActivator.getConfigurationService().getString(usernamePropertyName),pass);
  }
  return null;
}","/** 
 * Get the   {@link org.apache.http.auth.Credentials credentials} for thegiven authentication scope.
 * @param authscope the {@link org.apache.http.auth.AuthScope authentication scope}
 * @return the credentials
 * @see #setCredentials(org.apache.http.auth.AuthScope,org.apache.http.auth.Credentials)
 */
public Credentials getCredentials(AuthScope authscope){
  this.usedScope=authscope;
  this.challengedForCredentials=true;
  if (passwordPropertyName == null)   passwordPropertyName=getCredentialProperty(authscope);
  if (usernamePropertyName == null)   usernamePropertyName=getCredentialProperty(authscope);
  String pass=HttpUtilActivator.getCredentialsService().loadPassword(passwordPropertyName);
  if (pass == null) {
    AuthenticationWindow authWindow=new AuthenticationWindow(authscope.getHost(),true,null);
    authWindow.setVisible(true);
    if (!authWindow.isCanceled()) {
      Credentials cred=new UsernamePasswordCredentials(authWindow.getUserName(),new String(authWindow.getPassword()));
      if (authWindow.isRememberPassword()) {
        HttpUtilActivator.getConfigurationService().setProperty(usernamePropertyName,authWindow.getUserName());
        HttpUtilActivator.getCredentialsService().storePassword(passwordPropertyName,new String(authWindow.getPassword()));
      }
      return cred;
    }
    retry=false;
  }
 else {
    return new UsernamePasswordCredentials(HttpUtilActivator.getConfigurationService().getString(usernamePropertyName),pass);
  }
  return null;
}",0.9871881321645314
103383,"/** 
 * Executes the metod and return the result. Handle ask for password when hitting password protected site. Keep asking for password till user clicks cancel or enters correct password. When 'remember password' is checked password is saved, if this password and username are not correct clear them, if there are correct they stay saved.
 * @param httpClient the configured http client to use.
 * @param req the request for now it is get or post.
 * @return the result http entity.
 */
private static HttpEntity executeMethod(DefaultHttpClient httpClient,HttpRequestBase req) throws Throwable {
  HttpResponse response=null;
  int redirects=0;
  while (response == null || response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
    if (response != null) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      URI uri=req.getURI();
      req.abort();
      req=req.getClass().newInstance();
      req.setURI(uri);
      httpClient.getCredentialsProvider().clear();
      response=httpClient.execute(req);
    }
 else     response=httpClient.execute(req);
    if (!((HTTPCredentialsProvider)httpClient.getCredentialsProvider()).retry()) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      break;
    }
    Header locationHeader=response.getFirstHeader(""String_Node_Str"");
    if (locationHeader != null && req instanceof HttpPost && (response.getStatusLine().getStatusCode() == HttpStatus.SC_MOVED_PERMANENTLY || response.getStatusLine().getStatusCode() == HttpStatus.SC_MOVED_TEMPORARILY || response.getStatusLine().getStatusCode() == HttpStatus.SC_SEE_OTHER) && redirects < MAX_REDIRECTS) {
      HttpRequestBase oldreq=req;
      oldreq.abort();
      String newLocation=locationHeader.getValue();
      HttpEntity en=((HttpPost)oldreq).getEntity();
      if (en != null && en instanceof StringEntity) {
        ByteArrayOutputStream out=new ByteArrayOutputStream();
        en.writeTo(out);
        newLocation+=""String_Node_Str"" + out.toString(""String_Node_Str"");
      }
      req=new HttpGet(newLocation);
      req.setParams(oldreq.getParams());
      req.setHeaders(oldreq.getAllHeaders());
      redirects++;
      response=httpClient.execute(req);
    }
  }
  if (response != null && response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
    return response.getEntity();
  }
  return null;
}","/** 
 * Executes the method and return the result. Handle ask for password when hitting password protected site. Keep asking for password till user clicks cancel or enters correct password. When 'remember password' is checked password is saved, if this password and username are not correct clear them, if there are correct they stay saved.
 * @param httpClient the configured http client to use.
 * @param req the request for now it is get or post.
 * @return the result http entity.
 */
private static HttpEntity executeMethod(DefaultHttpClient httpClient,HttpRequestBase req) throws Throwable {
  HttpResponse response=null;
  int redirects=0;
  while (response == null || response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
    if (response != null && response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      URI uri=req.getURI();
      req.abort();
      req=req.getClass().newInstance();
      req.setURI(uri);
      httpClient.getCredentialsProvider().clear();
      if (!((HTTPCredentialsProvider)httpClient.getCredentialsProvider()).isChallengedForCredentials()) {
        throw new AuthenticationException(""String_Node_Str"");
      }
 else {
        response=httpClient.execute(req);
      }
    }
 else     response=httpClient.execute(req);
    if (!((HTTPCredentialsProvider)httpClient.getCredentialsProvider()).retry()) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      break;
    }
    Header locationHeader=response.getFirstHeader(""String_Node_Str"");
    if (locationHeader != null && req instanceof HttpPost && (response.getStatusLine().getStatusCode() == HttpStatus.SC_MOVED_PERMANENTLY || response.getStatusLine().getStatusCode() == HttpStatus.SC_MOVED_TEMPORARILY || response.getStatusLine().getStatusCode() == HttpStatus.SC_SEE_OTHER) && redirects < MAX_REDIRECTS) {
      HttpRequestBase oldreq=req;
      oldreq.abort();
      String newLocation=locationHeader.getValue();
      HttpEntity en=((HttpPost)oldreq).getEntity();
      if (en != null && en instanceof StringEntity) {
        ByteArrayOutputStream out=new ByteArrayOutputStream();
        en.writeTo(out);
        newLocation+=""String_Node_Str"" + out.toString(""String_Node_Str"");
      }
      req=new HttpGet(newLocation);
      req.setParams(oldreq.getParams());
      req.setHeaders(oldreq.getAllHeaders());
      redirects++;
      response=httpClient.execute(req);
    }
  }
  if (response != null && response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
    return response.getEntity();
  }
  return null;
}",0.9388397246804326
103384,"/** 
 * Posting form to <tt>address</tt>. For submission we use POST method which is ""application/x-www-form-urlencoded"" encoded.
 * @param address HTTP address.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @param formParamNames the parameter names to include in post.
 * @param formParamValues the corresponding parameter values to use.
 * @param usernameParamIx the index of the username parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @param passwordParamIx the index of the password parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
public static HTTPResponseResult postForm(String address,String usernamePropertyName,String passwordPropertyName,String[] formParamNames,String[] formParamValues,int usernameParamIx,int passwordParamIx){
  DefaultHttpClient httpClient=null;
  try {
    HttpPost postMethod=new HttpPost(address);
    httpClient=getHttpClient(usernamePropertyName,passwordPropertyName,postMethod.getURI().getHost());
    Credentials creds=null;
    if (usernameParamIx != -1 && usernameParamIx < formParamNames.length && passwordParamIx != -1 && passwordParamIx < formParamNames.length) {
      URL url=new URL(address);
      creds=new HTTPCredentialsProvider(usernamePropertyName,passwordPropertyName).getCredentials(new AuthScope(url.getHost(),url.getPort()));
    }
    List<NameValuePair> parameters=new ArrayList<NameValuePair>();
    if (formParamNames != null) {
      for (int i=0; i < formParamNames.length; i++) {
        if (i == usernameParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getUserPrincipal().getName()));
        }
 else         if (i == passwordParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getPassword()));
        }
 else {
          parameters.add(new BasicNameValuePair(formParamNames[i],formParamValues[i]));
        }
      }
    }
    String s=URLEncodedUtils.format(parameters,HTTP.UTF_8);
    StringEntity entity=new StringEntity(s,HTTP.UTF_8);
    entity.setContentType(URLEncodedUtils.CONTENT_TYPE);
    postMethod.setEntity(entity);
    HttpEntity resEntity=executeMethod(httpClient,postMethod);
    if (resEntity == null)     return null;
    return new HTTPResponseResult(resEntity,httpClient);
  }
 catch (  Throwable e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Posting form to <tt>address</tt>. For submission we use POST method which is ""application/x-www-form-urlencoded"" encoded.
 * @param httpClient the http client
 * @param postMethod the post method
 * @param address HTTP address.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @param formParamNames the parameter names to include in post.
 * @param formParamValues the corresponding parameter values to use.
 * @param usernameParamIx the index of the username parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @param passwordParamIx the index of the password parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
private static HttpEntity postForm(DefaultHttpClient httpClient,HttpPost postMethod,String address,String usernamePropertyName,String passwordPropertyName,String[] formParamNames,String[] formParamValues,int usernameParamIx,int passwordParamIx) throws Throwable {
  Credentials creds=null;
  if (usernameParamIx != -1 && usernameParamIx < formParamNames.length && passwordParamIx != -1 && passwordParamIx < formParamNames.length) {
    URL url=new URL(address);
    HTTPCredentialsProvider prov=(HTTPCredentialsProvider)httpClient.getCredentialsProvider();
    creds=prov.getCredentials(new AuthScope(url.getHost(),url.getPort()));
    if (creds == null && !prov.retry()) {
      return null;
    }
  }
  List<NameValuePair> parameters=new ArrayList<NameValuePair>();
  if (formParamNames != null) {
    for (int i=0; i < formParamNames.length; i++) {
      if (i == usernameParamIx && creds != null) {
        parameters.add(new BasicNameValuePair(formParamNames[i],creds.getUserPrincipal().getName()));
      }
 else       if (i == passwordParamIx && creds != null) {
        parameters.add(new BasicNameValuePair(formParamNames[i],creds.getPassword()));
      }
 else {
        parameters.add(new BasicNameValuePair(formParamNames[i],formParamValues[i]));
      }
    }
  }
  String s=URLEncodedUtils.format(parameters,HTTP.UTF_8);
  StringEntity entity=new StringEntity(s,HTTP.UTF_8);
  entity.setContentType(URLEncodedUtils.CONTENT_TYPE);
  postMethod.setEntity(entity);
  return executeMethod(httpClient,postMethod);
}",0.6875807344528511
103385,"/** 
 * Overrides Object#hashCode() because Object#equals(Object) is overridden.
 * @return a hash code value for this <tt>MediaFormat</tt>.
 */
@Override public int hashCode(){
  return (getFormat().hashCode() | getFormatParameters().hashCode());
}","/** 
 * Overrides Object#hashCode() because Object#equals(Object) is overridden.
 * @return a hash code value for this <tt>MediaFormat</tt>.
 */
@Override public int hashCode(){
  return getJMFEncoding().hashCode() | getFormatParameters().hashCode();
}",0.8023952095808383
103386,"/** 
 * Indicates whether some other object is ""equal to"" this one. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
@Override public boolean equals(Object obj){
  if (obj == null || !(obj instanceof String || (obj instanceof ContactJabberImpl)))   return false;
  if (obj != null && obj instanceof ContactJabberImpl && !(((ContactJabberImpl)obj).getAddress().equalsIgnoreCase(getAddress()) && ((ContactJabberImpl)obj).getProtocolProvider() == getProtocolProvider()))   return false;
  if (obj != null && obj instanceof String && !(getAddress().substring(0,getAddress().indexOf(""String_Node_Str"")).equals(obj)))   return false;
  return true;
}","/** 
 * Indicates whether some other object is ""equal to"" this one. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
@Override public boolean equals(Object obj){
  if (obj == null || !(obj instanceof String || (obj instanceof ContactJabberImpl)))   return false;
  if (obj instanceof ContactJabberImpl && ((ContactJabberImpl)obj).getAddress().equalsIgnoreCase(getAddress()) && ((ContactJabberImpl)obj).getProtocolProvider() == getProtocolProvider()) {
    return true;
  }
  if (obj instanceof String) {
    int atIndex=getAddress().indexOf(""String_Node_Str"");
    if (atIndex > 0) {
      if (getAddress().equalsIgnoreCase((String)obj) || getAddress().substring(0,atIndex).equalsIgnoreCase((String)obj)) {
        return true;
      }
    }
 else     if (getAddress().equalsIgnoreCase((String)obj))     return true;
  }
  return false;
}",0.6449359720605355
103387,"/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.searchField=new SearchField(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    /** 
 * Invoked when a window has been closed.
 */
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
    /** 
 * Invoked when a window has been opened.
 */
    public void windowOpened(    WindowEvent e){
      GuiActivator.getContactList().requestFocusInWindow();
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  KeyboardFocusManager keyManager=KeyboardFocusManager.getCurrentKeyboardFocusManager();
  keyManager.addKeyEventDispatcher(new MainKeyDispatcher(keyManager));
  this.init();
  this.initPluginComponents();
}","/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.searchField=new SearchField(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    /** 
 * Invoked when a window has been closed.
 */
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
    /** 
 * Invoked when a window has been opened.
 */
    public void windowOpened(    WindowEvent e){
      GuiActivator.getContactList().requestFocusInWindow();
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  try {
    Toolkit xToolkit=Toolkit.getDefaultToolkit();
    java.lang.reflect.Field awtAppClassNameField=xToolkit.getClass().getDeclaredField(""String_Node_Str"");
    awtAppClassNameField.setAccessible(true);
    awtAppClassNameField.set(xToolkit,applicationName);
  }
 catch (  Throwable t) {
  }
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  KeyboardFocusManager keyManager=KeyboardFocusManager.getCurrentKeyboardFocusManager();
  keyManager.addKeyEventDispatcher(new MainKeyDispatcher(keyManager));
  this.init();
  this.initPluginComponents();
}",0.8909157241882525
103388,"/** 
 * Initializes the dialog.
 */
private void init(){
  TransparentPanel labelsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  TransparentPanel fieldsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  labelsPanel.add(accountLabel);
  fieldsPanel.add(accountCombo);
  initAccountCombo();
  accountCombo.setRenderer(new AccountComboRenderer());
  labelsPanel.add(groupLabel);
  fieldsPanel.add(groupCombo);
  initGroupCombo();
  groupCombo.setRenderer(new GroupComboRenderer());
  labelsPanel.add(contactAddressLabel);
  fieldsPanel.add(contactAddressField);
  labelsPanel.add(displayNameLabel);
  fieldsPanel.add(displayNameField);
  contactAddressField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent e){
    }
    public void insertUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
    public void removeUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
  }
);
  TransparentPanel dataPanel=new TransparentPanel(new BorderLayout());
  dataPanel.add(labelsPanel,BorderLayout.WEST);
  dataPanel.add(fieldsPanel);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,20));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  mainPanel.add(imageLabel,BorderLayout.WEST);
  mainPanel.add(dataPanel,BorderLayout.CENTER);
  this.getContentPane().add(mainPanel,BorderLayout.NORTH);
  this.getContentPane().add(createButtonsPanel(),BorderLayout.SOUTH);
  this.setPreferredSize(new Dimension(450,200));
  this.addWindowFocusListener(this);
  loadSkin();
}","/** 
 * Initializes the dialog.
 */
private void init(){
  TransparentPanel labelsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  TransparentPanel fieldsPanel=new TransparentPanel(new GridLayout(0,1,5,5));
  labelsPanel.add(accountLabel);
  fieldsPanel.add(accountCombo);
  initAccountCombo();
  accountCombo.setRenderer(new AccountComboRenderer());
  labelsPanel.add(groupLabel);
  fieldsPanel.add(groupCombo);
  initGroupCombo();
  groupCombo.setRenderer(new GroupComboRenderer());
  labelsPanel.add(contactAddressLabel);
  fieldsPanel.add(contactAddressField);
  labelsPanel.add(displayNameLabel);
  fieldsPanel.add(displayNameField);
  contactAddressField.getDocument().addDocumentListener(new DocumentListener(){
    public void changedUpdate(    DocumentEvent e){
    }
    public void insertUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
    public void removeUpdate(    DocumentEvent e){
      updateAddButtonState();
    }
  }
);
  TransparentPanel dataPanel=new TransparentPanel(new BorderLayout());
  dataPanel.add(labelsPanel,BorderLayout.WEST);
  dataPanel.add(fieldsPanel);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(20,10));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  mainPanel.add(imageLabel,BorderLayout.WEST);
  mainPanel.add(dataPanel,BorderLayout.CENTER);
  mainPanel.add(createButtonsPanel(),BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel,BorderLayout.CENTER);
  this.setPreferredSize(new Dimension(450,250));
  this.setResizable(false);
  this.addWindowFocusListener(this);
  loadSkin();
}",0.942507068803016
103389,"/** 
 * Initializes buttons panel.
 * @param uiContact the <tt>UIContact</tt> for which we initialize thebutton panel
 */
private void initButtonsPanel(UIContact uiContact){
  this.remove(callButton);
  this.remove(callVideoButton);
  this.remove(desktopSharingButton);
  this.remove(chatButton);
  this.remove(addContactButton);
  if (!isSelected)   return;
  int statusMessageLabelHeight=0;
  if (displayDetailsLabel.getText().length() > 0)   statusMessageLabelHeight=20;
 else   statusMessageLabelHeight=15;
  UIContactDetail imContact=null;
  if (uiContact.getDescriptor() instanceof MetaContact)   imContact=uiContact.getDefaultContactDetail(OperationSetBasicInstantMessaging.class);
  int x=statusLabel.getWidth() + LEFT_BORDER + STATUS_RIGHT_BORDER;
  if (imContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=1;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.chatButton.setBorder(null);
    this.add(chatButton,constraints);
    chatButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + chatButton.getBounds());
    x+=chatButton.getWidth();
  }
  UIContactDetail telephonyContact=uiContact.getDefaultContactDetail(OperationSetBasicTelephony.class);
  if (telephonyContact != null || uiContact.getDescriptor() instanceof SourceContact) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=2;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.callButton.setBorder(null);
    this.add(callButton,constraints);
    callButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    callButton.setEnabled(telephonyContact != null);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + callButton.getBounds());
    x+=callButton.getWidth();
  }
  UIContactDetail videoContact=uiContact.getDefaultContactDetail(OperationSetVideoTelephony.class);
  if (videoContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=3;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.callVideoButton.setBorder(null);
    this.add(callVideoButton,constraints);
    callVideoButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + callVideoButton.getBounds());
    x+=callVideoButton.getWidth();
  }
  UIContactDetail desktopContact=uiContact.getDefaultContactDetail(OperationSetDesktopSharingServer.class);
  if (desktopContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=4;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.desktopSharingButton.setBorder(null);
    this.add(desktopSharingButton,constraints);
    desktopSharingButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + desktopSharingButton.getBounds());
    x+=desktopSharingButton.getWidth();
  }
  if (uiContact.getDescriptor() instanceof SourceContact) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=5;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.addContactButton.setBorder(null);
    this.add(addContactButton,constraints);
    addContactButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + addContactButton.getBounds());
    x+=addContactButton.getWidth();
  }
  this.setBounds(0,0,tree.getWidth(),getPreferredSize().height);
}","/** 
 * Initializes buttons panel.
 * @param uiContact the <tt>UIContact</tt> for which we initialize thebutton panel
 */
private void initButtonsPanel(UIContact uiContact){
  this.remove(chatButton);
  this.remove(callButton);
  this.remove(callVideoButton);
  this.remove(desktopSharingButton);
  this.remove(addContactButton);
  if (!isSelected)   return;
  int statusMessageLabelHeight=0;
  if (displayDetailsLabel.getText().length() > 0)   statusMessageLabelHeight=20;
 else   statusMessageLabelHeight=15;
  UIContactDetail imContact=null;
  if (uiContact.getDescriptor() instanceof MetaContact)   imContact=uiContact.getDefaultContactDetail(OperationSetBasicInstantMessaging.class);
  int x=statusIcon.getIconWidth() + statusLabel.getIconTextGap() + LEFT_BORDER+ STATUS_RIGHT_BORDER;
  if (imContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=1;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.chatButton.setBorder(null);
    this.add(chatButton,constraints);
    chatButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    x+=chatButton.getWidth();
  }
  UIContactDetail telephonyContact=uiContact.getDefaultContactDetail(OperationSetBasicTelephony.class);
  if (telephonyContact != null || uiContact.getDescriptor() instanceof SourceContact) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=2;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.callButton.setBorder(null);
    this.add(callButton,constraints);
    callButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    callButton.setEnabled(telephonyContact != null);
    x+=callButton.getWidth();
  }
  UIContactDetail videoContact=uiContact.getDefaultContactDetail(OperationSetVideoTelephony.class);
  if (videoContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=3;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.callVideoButton.setBorder(null);
    this.add(callVideoButton,constraints);
    callVideoButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    x+=callVideoButton.getWidth();
  }
  UIContactDetail desktopContact=uiContact.getDefaultContactDetail(OperationSetDesktopSharingServer.class);
  if (desktopContact != null) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=4;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.desktopSharingButton.setBorder(null);
    this.add(desktopSharingButton,constraints);
    desktopSharingButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    x+=desktopSharingButton.getWidth();
  }
  if (uiContact.getDescriptor() instanceof SourceContact) {
    constraints.anchor=GridBagConstraints.WEST;
    constraints.fill=GridBagConstraints.NONE;
    constraints.gridx=5;
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.gridheight=1;
    constraints.weightx=0f;
    constraints.weighty=0f;
    this.addContactButton.setBorder(null);
    this.add(addContactButton,constraints);
    addContactButton.setBounds(x,nameLabel.getHeight() + statusMessageLabelHeight,28,28);
    x+=addContactButton.getWidth();
  }
  this.setBounds(0,0,tree.getWidth(),getPreferredSize().height);
}",0.927392329651235
103390,"/** 
 * Dispatches the given mouse <tt>event</tt> to the underlying buttons.
 * @param event the <tt>MouseEvent</tt> to dispatch
 */
private void dispatchEventToButtons(MouseEvent event){
  TreePath mousePath=this.getPathForLocation(event.getX(),event.getY());
  if (mousePath == null || !mousePath.equals(this.getSelectionPath()))   return;
  JPanel renderer=(JPanel)getCellRenderer().getTreeCellRendererComponent(this,mousePath.getLastPathComponent(),true,true,true,this.getRowForPath(mousePath),true);
  Rectangle r=this.getPathBounds(mousePath);
  int translatedX=event.getX() - r.x;
  int translatedY=event.getY() - r.y;
  Component mouseComponent=renderer.findComponentAt(translatedX,translatedY);
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"" + mouseComponent + ""String_Node_Str""+ translatedX+ ""String_Node_Str""+ translatedY);
  if (mouseComponent instanceof SIPCommButton) {
    MouseEvent evt=new MouseEvent(mouseComponent,event.getID(),event.getWhen(),event.getModifiers(),5,5,event.getClickCount(),event.isPopupTrigger());
    mouseComponent.dispatchEvent(evt);
    this.repaint();
  }
}","/** 
 * Dispatches the given mouse <tt>event</tt> to the underlying buttons.
 * @param event the <tt>MouseEvent</tt> to dispatch
 */
private void dispatchEventToButtons(MouseEvent event){
  TreePath mousePath=this.getPathForLocation(event.getX(),event.getY());
  if (mousePath == null || !mousePath.equals(this.getSelectionPath()))   return;
  JPanel renderer=(JPanel)getCellRenderer().getTreeCellRendererComponent(this,mousePath.getLastPathComponent(),true,true,true,this.getRowForPath(mousePath),true);
  Rectangle r=this.getPathBounds(mousePath);
  int translatedX=event.getX() - r.x;
  int translatedY=event.getY() - r.y;
  Component mouseComponent=renderer.findComponentAt(translatedX,translatedY);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + mouseComponent.getClass().getName() + ""String_Node_Str""+ mouseComponent.getBounds()+ ""String_Node_Str""+ translatedX+ ""String_Node_Str""+ translatedY);
  if (mouseComponent instanceof SIPCommButton) {
    MouseEvent evt=new MouseEvent(mouseComponent,event.getID(),event.getWhen(),event.getModifiers(),5,5,event.getClickCount(),event.isPopupTrigger());
    mouseComponent.dispatchEvent(evt);
    this.repaint();
  }
}",0.9625761531766752
103391,"/** 
 * Implements the very update procedure on Windows which includes without being limited to: <ol> <li>Downloads the setup in a temporary directory.</li> <li>Warns that the update procedure will shut down the application.</li> <li>Executes the setup in a separate process and shuts down the application.</li> </ol>
 */
private static void windowsUpdate(){
  File delta=null;
  boolean deleteDelta=true;
  File msi=null;
  try {
    String deltaLink=downloadLink.replace(latestVersion,latestVersion + ""String_Node_Str"" + getCurrentVersion().getNightlyBuildID());
    if (!deltaLink.equalsIgnoreCase(downloadLink) && logger.isDebugEnabled())     delta=download(deltaLink);
    if (delta != null) {
      File[] deltaMsi=new File[1];
      createTempFileOutputStream(delta.toURI().toURL(),""String_Node_Str"",true,deltaMsi);
      Process process=new ProcessBuilder(delta.getCanonicalPath(),""String_Node_Str"",deltaMsi[0].getCanonicalPath()).start();
      int exitCode=1;
      while (true) {
        try {
          exitCode=process.waitFor();
          break;
        }
 catch (        InterruptedException ie) {
        }
      }
      if (0 == exitCode) {
        deleteDelta=false;
        msi=deltaMsi[0];
      }
    }
  }
 catch (  Exception e) {
  }
 finally {
    if (deleteDelta && (delta != null)) {
      delta.delete();
      delta=null;
    }
  }
  boolean deleteMsi=true;
  deleteDelta=true;
  try {
    if (msi == null)     msi=download(downloadLink);
    if (msi != null) {
      ResourceManagementService resources=Resources.getResources();
      if (UpdateActivator.getUIService().getPopupDialog().showConfirmPopupDialog(resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str""),PopupDialog.YES_NO_OPTION,PopupDialog.QUESTION_MESSAGE) == PopupDialog.YES_OPTION) {
        List<String> command=new ArrayList<String>();
        command.add(((delta == null) ? msi : delta).getCanonicalPath());
        command.add(""String_Node_Str"");
        if (delta != null) {
          command.add(""String_Node_Str"");
          command.add(msi.getCanonicalPath());
        }
        command.add(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
        deleteMsi=false;
        deleteDelta=false;
        new ProcessBuilder(command).start();
        UpdateActivator.getShutdownService().beginShutdown();
      }
    }
  }
 catch (  FileNotFoundException fnfe) {
    ResourceManagementService resources=Resources.getResources();
    UpdateActivator.getUIService().getPopupDialog().showMessagePopupDialog(resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str""),PopupDialog.INFORMATION_MESSAGE);
  }
catch (  Exception e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
 finally {
    if (deleteMsi && (msi != null)) {
      msi.delete();
      msi=null;
    }
    if (deleteDelta && (delta != null)) {
      delta.delete();
      delta=null;
    }
  }
}","/** 
 * Implements the very update procedure on Windows which includes without being limited to: <ol> <li>Downloads the setup in a temporary directory.</li> <li>Warns that the update procedure will shut down the application.</li> <li>Executes the setup in a separate process and shuts down the application.</li> </ol>
 */
private static void windowsUpdate(){
  File delta=null;
  boolean deleteDelta=true;
  File msi=null;
  try {
    String deltaTarget=null;
    Version ver=getCurrentVersion();
    if (ver.isPreRelease())     deltaTarget=ver.getNightlyBuildID();
 else     deltaTarget=String.valueOf(ver.getVersionRevision());
    String deltaLink=downloadLink.replace(latestVersion,latestVersion + ""String_Node_Str"" + deltaTarget);
    if (!deltaLink.equalsIgnoreCase(downloadLink) && logger.isDebugEnabled())     delta=download(deltaLink);
    if (delta != null) {
      File[] deltaMsi=new File[1];
      createTempFileOutputStream(delta.toURI().toURL(),""String_Node_Str"",true,deltaMsi);
      Process process=new ProcessBuilder(delta.getCanonicalPath(),""String_Node_Str"",deltaMsi[0].getCanonicalPath()).start();
      int exitCode=1;
      while (true) {
        try {
          exitCode=process.waitFor();
          break;
        }
 catch (        InterruptedException ie) {
        }
      }
      if (0 == exitCode) {
        deleteDelta=false;
        msi=deltaMsi[0];
      }
    }
  }
 catch (  Exception e) {
  }
 finally {
    if (deleteDelta && (delta != null)) {
      delta.delete();
      delta=null;
    }
  }
  boolean deleteMsi=true;
  deleteDelta=true;
  try {
    if (msi == null)     msi=download(downloadLink);
    if (msi != null) {
      ResourceManagementService resources=Resources.getResources();
      if (UpdateActivator.getUIService().getPopupDialog().showConfirmPopupDialog(resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str""),PopupDialog.YES_NO_OPTION,PopupDialog.QUESTION_MESSAGE) == PopupDialog.YES_OPTION) {
        List<String> command=new ArrayList<String>();
        command.add(((delta == null) ? msi : delta).getCanonicalPath());
        command.add(""String_Node_Str"");
        if (delta != null) {
          command.add(""String_Node_Str"");
          command.add(msi.getCanonicalPath());
        }
        command.add(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
        deleteMsi=false;
        deleteDelta=false;
        new ProcessBuilder(command).start();
        UpdateActivator.getShutdownService().beginShutdown();
      }
    }
  }
 catch (  FileNotFoundException fnfe) {
    ResourceManagementService resources=Resources.getResources();
    UpdateActivator.getUIService().getPopupDialog().showMessagePopupDialog(resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str""),PopupDialog.INFORMATION_MESSAGE);
  }
catch (  Exception e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
 finally {
    if (deleteMsi && (msi != null)) {
      msi.delete();
      msi=null;
    }
    if (deleteDelta && (delta != null)) {
      delta.delete();
      delta=null;
    }
  }
}",0.9592404648878704
103392,"/** 
 * Posts a <tt>file</tt> to the <tt>address</tt>.
 * @param address the address to post the form to.
 * @param fileParamName the name of the param for the file.
 * @param file the file we will send.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
public static HTTPResponseResult postFile(String address,String fileParamName,File file,String usernamePropertyName,String passwordPropertyName){
  DefaultHttpClient httpClient=null;
  try {
    HttpPost postMethod=new HttpPost(address);
    httpClient=getHttpClient(usernamePropertyName,passwordPropertyName,postMethod.getURI().getHost());
    String mimeType=URLConnection.guessContentTypeFromName(file.getPath());
    if (mimeType == null)     mimeType=""String_Node_Str"";
    FileBody bin=new FileBody(file,mimeType);
    MultipartEntity reqEntity=new MultipartEntity();
    reqEntity.addPart(fileParamName,bin);
    postMethod.setEntity(reqEntity);
    HttpEntity resEntity=executeMethod(httpClient,postMethod);
    if (resEntity == null)     return null;
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + EntityUtils.toString(resEntity));
    return new HTTPResponseResult(reqEntity,httpClient);
  }
 catch (  Throwable e) {
    logger.error(""String_Node_Str"" + address,e);
  }
  return null;
}","/** 
 * Posts a <tt>file</tt> to the <tt>address</tt>.
 * @param address the address to post the form to.
 * @param fileParamName the name of the param for the file.
 * @param file the file we will send.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
public static HTTPResponseResult postFile(String address,String fileParamName,File file,String usernamePropertyName,String passwordPropertyName){
  DefaultHttpClient httpClient=null;
  try {
    HttpPost postMethod=new HttpPost(address);
    httpClient=getHttpClient(usernamePropertyName,passwordPropertyName,postMethod.getURI().getHost());
    String mimeType=URLConnection.guessContentTypeFromName(file.getPath());
    if (mimeType == null)     mimeType=""String_Node_Str"";
    FileBody bin=new FileBody(file,mimeType);
    MultipartEntity reqEntity=new MultipartEntity();
    reqEntity.addPart(fileParamName,bin);
    postMethod.setEntity(reqEntity);
    HttpEntity resEntity=executeMethod(httpClient,postMethod);
    if (resEntity == null)     return null;
    return new HTTPResponseResult(reqEntity,httpClient);
  }
 catch (  Throwable e) {
    logger.error(""String_Node_Str"" + address,e);
  }
  return null;
}",0.9673776662484316
103393,"/** 
 * Posting form to <tt>address</tt>. For submission we use POST method which is ""application/x-www-form-urlencoded"" encoded.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @param formParamNames the parameter names to include in post.
 * @param formParamValues the corresponding parameter values to use.
 * @param usernameParamIx the index of the username parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @param passwordParamIx the index of the password parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
public static HTTPResponseResult postForm(String address,String usernamePropertyName,String passwordPropertyName,String[] formParamNames,String[] formParamValues,int usernameParamIx,int passwordParamIx){
  DefaultHttpClient httpClient=null;
  try {
    HttpPost postMethod=new HttpPost(address);
    httpClient=getHttpClient(usernamePropertyName,passwordPropertyName,postMethod.getURI().getHost());
    Credentials creds=null;
    if (usernameParamIx != -1 && usernameParamIx < formParamNames.length && passwordParamIx != -1 && passwordParamIx < formParamNames.length) {
      URL url=new URL(address);
      creds=new HTTPCredentialsProvider(usernamePropertyName,passwordPropertyName).getCredentials(new AuthScope(url.getHost(),url.getPort()));
    }
    List<NameValuePair> parameters=new ArrayList<NameValuePair>();
    if (formParamNames != null) {
      for (int i=0; i < formParamNames.length; i++) {
        if (i == usernameParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getUserPrincipal().getName()));
        }
 else         if (i == passwordParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getPassword()));
        }
 else {
          parameters.add(new BasicNameValuePair(formParamNames[i],formParamValues[i]));
        }
      }
    }
    String s=URLEncodedUtils.format(parameters,HTTP.UTF_8);
    StringEntity entity=new StringEntity(s,HTTP.UTF_8);
    entity.setContentType(URLEncodedUtils.CONTENT_TYPE);
    postMethod.setEntity(entity);
    HttpEntity resEntity=executeMethod(httpClient,postMethod);
    if (resEntity == null)     return null;
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + EntityUtils.toString(resEntity));
    return new HTTPResponseResult(resEntity,httpClient);
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Posting form to <tt>address</tt>. For submission we use POST method which is ""application/x-www-form-urlencoded"" encoded.
 * @param usernamePropertyName the property to use to retrieve/storeusername value if protected site is hit, for username ConfigurationService service is used.
 * @param passwordPropertyName the property to use to retrieve/storepassword value if protected site is hit, for password CredentialsStorageService service is used.
 * @param formParamNames the parameter names to include in post.
 * @param formParamValues the corresponding parameter values to use.
 * @param usernameParamIx the index of the username parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @param passwordParamIx the index of the password parameter in the<tt>formParamNames</tt> and <tt>formParamValues</tt> if any, otherwise -1.
 * @return the result or null if send was not possible orcredentials ask if any was canceled.
 */
public static HTTPResponseResult postForm(String address,String usernamePropertyName,String passwordPropertyName,String[] formParamNames,String[] formParamValues,int usernameParamIx,int passwordParamIx){
  DefaultHttpClient httpClient=null;
  try {
    HttpPost postMethod=new HttpPost(address);
    httpClient=getHttpClient(usernamePropertyName,passwordPropertyName,postMethod.getURI().getHost());
    Credentials creds=null;
    if (usernameParamIx != -1 && usernameParamIx < formParamNames.length && passwordParamIx != -1 && passwordParamIx < formParamNames.length) {
      URL url=new URL(address);
      creds=new HTTPCredentialsProvider(usernamePropertyName,passwordPropertyName).getCredentials(new AuthScope(url.getHost(),url.getPort()));
    }
    List<NameValuePair> parameters=new ArrayList<NameValuePair>();
    if (formParamNames != null) {
      for (int i=0; i < formParamNames.length; i++) {
        if (i == usernameParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getUserPrincipal().getName()));
        }
 else         if (i == passwordParamIx && creds != null) {
          parameters.add(new BasicNameValuePair(formParamNames[i],creds.getPassword()));
        }
 else {
          parameters.add(new BasicNameValuePair(formParamNames[i],formParamValues[i]));
        }
      }
    }
    String s=URLEncodedUtils.format(parameters,HTTP.UTF_8);
    StringEntity entity=new StringEntity(s,HTTP.UTF_8);
    entity.setContentType(URLEncodedUtils.CONTENT_TYPE);
    postMethod.setEntity(entity);
    HttpEntity resEntity=executeMethod(httpClient,postMethod);
    if (resEntity == null)     return null;
    return new HTTPResponseResult(resEntity,httpClient);
  }
 catch (  Throwable e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}",0.9459172852598092
103394,"/** 
 * Finds the attributes shared by two matching <tt>Format</tt>s. If the specified <tt>Format</tt> does not match this one, the result is undefined.
 * @param format the matching <tt>Format</tt> to intersect with this one
 * @return a <tt>Format</tt> with its attributes set to the attributescommon to this instance and the specified <tt>format</tt>
 */
@Override public Format intersects(Format format){
  Format intersection=super.intersects(format);
  if (intersection == null)   return null;
  if (!(format instanceof AVFrameFormat))   return intersection;
  ((AVFrameFormat)intersection).pixFmt=(pixFmt == NOT_SPECIFIED) ? ((AVFrameFormat)format).pixFmt : pixFmt;
  return intersection;
}","/** 
 * Finds the attributes shared by two matching <tt>Format</tt>s. If the specified <tt>Format</tt> does not match this one, the result is undefined.
 * @param format the matching <tt>Format</tt> to intersect with this one
 * @return a <tt>Format</tt> with its attributes set to the attributescommon to this instance and the specified <tt>format</tt>
 */
@Override public Format intersects(Format format){
  Format intersection=super.intersects(format);
  if (intersection == null)   return null;
  AVFrameFormat avFrameFormatIntersection=(AVFrameFormat)intersection;
  avFrameFormatIntersection.pixFmt=((pixFmt == NOT_SPECIFIED) && (format instanceof AVFrameFormat)) ? ((AVFrameFormat)format).pixFmt : pixFmt;
  return intersection;
}",0.8905923344947735
103395,"/** 
 * Method called back in the RemoteListener to notify listener of all RTP Remote Events.RemoteEvents are one of ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent
 * @param remoteEvent the event
 */
public void update(RemoteEvent remoteEvent){
  if (!logger.isInfoEnabled())   return;
  if (remoteEvent instanceof SenderReportEvent) {
    numberOfReceivedSenderReports++;
    SenderReport report=((SenderReportEvent)remoteEvent).getReport();
    if (report.getFeedbackReports().size() > 0) {
      Feedback feedback=(Feedback)report.getFeedbackReports().get(0);
      long remoteJitter=feedback.getJitter();
      if (remoteJitter < minRemoteInterArrivalJitter || minRemoteInterArrivalJitter == -1)       minRemoteInterArrivalJitter=remoteJitter;
      if (maxRemoteInterArrivalJitter < remoteJitter)       maxRemoteInterArrivalJitter=remoteJitter;
      if (numberOfReceivedSenderReports % 4 != 1)       return;
      StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
      buff.append(""String_Node_Str"").append(getFormat().getMediaType().toString()).append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(report.getSenderPacketCount()).append(""String_Node_Str"").append(report.getSenderByteCount()).append(""String_Node_Str"").append(remoteJitter).append(""String_Node_Str"").append(feedback.getNumLost()).append(""String_Node_Str"").append((int)(feedback.getDLSR() / 65.536)).append(""String_Node_Str"");
      logger.info(buff);
    }
  }
}","/** 
 * Method called back in the RemoteListener to notify listener of all RTP Remote Events.RemoteEvents are one of ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent
 * @param remoteEvent the event
 */
public void update(RemoteEvent remoteEvent){
  if (!logger.isInfoEnabled())   return;
  if (remoteEvent instanceof SenderReportEvent) {
    numberOfReceivedSenderReports++;
    SenderReport report=((SenderReportEvent)remoteEvent).getReport();
    if (report.getFeedbackReports().size() > 0) {
      Feedback feedback=(Feedback)report.getFeedbackReports().get(0);
      long remoteJitter=feedback.getJitter();
      if (remoteJitter < minRemoteInterArrivalJitter || minRemoteInterArrivalJitter == -1)       minRemoteInterArrivalJitter=remoteJitter;
      if (maxRemoteInterArrivalJitter < remoteJitter)       maxRemoteInterArrivalJitter=remoteJitter;
      if (numberOfReceivedSenderReports % 4 != 1)       return;
      StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
      buff.append(""String_Node_Str"").append(getFormat() != null ? getFormat().getMediaType().toString() : ""String_Node_Str"").append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(report.getSenderPacketCount()).append(""String_Node_Str"").append(report.getSenderByteCount()).append(""String_Node_Str"").append(remoteJitter).append(""String_Node_Str"").append(feedback.getNumLost()).append(""String_Node_Str"").append((int)(feedback.getDLSR() / 65.536)).append(""String_Node_Str"");
      logger.info(buff);
    }
  }
}",0.9862385321100916
103396,"/** 
 * Prints all statistics available for rtpManager.
 * @param rtpManager the RTP manager that we'd like to print statistics for.
 */
private void printFlowStatistics(RTPManager rtpManager){
  try {
    GlobalTransmissionStats s=rtpManager.getGlobalTransmissionStats();
    StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
    buff.append(""String_Node_Str"").append(getFormat().getMediaType()).append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getBytesSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRTPSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(minRemoteInterArrivalJitter).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(maxRemoteInterArrivalJitter).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getLocalColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRemoteColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRTCPSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getTransmitFailed());
    logger.info(buff);
    GlobalReceptionStats rs=rtpManager.getGlobalReceptionStats();
    buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
    buff.append(""String_Node_Str"").append(getFormat().getMediaType()).append(""String_Node_Str"").append(getRemoteSourceID()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getPacketsRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBytesRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getLost()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getMinInterArrivalJitter()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getMaxInterArrivalJitter()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getRTCPRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBadRTCPPkts()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBadRTPkts()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getLocalColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedBye()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedRR()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedSDES()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedSR()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getPacketsLooped()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getRemoteColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getSRRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getTransmitFailed()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getUnknownTypes());
    logger.info(buff);
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
  }
}","/** 
 * Prints all statistics available for rtpManager.
 * @param rtpManager the RTP manager that we'd like to print statistics for.
 */
private void printFlowStatistics(RTPManager rtpManager){
  try {
    GlobalTransmissionStats s=rtpManager.getGlobalTransmissionStats();
    StringBuilder buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
    buff.append(""String_Node_Str"").append(getFormat() != null ? getFormat().getMediaType() : ""String_Node_Str"").append(""String_Node_Str"").append(getLocalSourceID()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getBytesSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRTPSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(minRemoteInterArrivalJitter).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(maxRemoteInterArrivalJitter).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getLocalColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRemoteColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getRTCPSent()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(s.getTransmitFailed());
    logger.info(buff);
    GlobalReceptionStats rs=rtpManager.getGlobalReceptionStats();
    buff=new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);
    buff.append(""String_Node_Str"").append(getFormat().getMediaType()).append(""String_Node_Str"").append(getRemoteSourceID()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getPacketsRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBytesRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getLost()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getMinInterArrivalJitter()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(statisticsEngine.getMaxInterArrivalJitter()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getRTCPRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBadRTCPPkts()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getBadRTPkts()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getLocalColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedBye()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedRR()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedSDES()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getMalformedSR()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getPacketsLooped()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getRemoteColls()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getSRRecd()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getTransmitFailed()).append(""String_Node_Str"").append(StatisticsEngine.RTP_STAT_PREFIX).append(""String_Node_Str"").append(rs.getUnknownTypes());
    logger.info(buff);
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
  }
}",0.9948352188883424
103397,"/** 
 * Retrieve photo of a contact. Adapted from Google sample.
 * @param photoLink photo link
 * @param service
 * @return byte array containing image photo or null if problem happened
 */
public static byte[] downloadPhoto(ILink photoLink,ContactsService service){
  try {
    if (photoLink != null) {
      GDataRequest request=service.createLinkQueryRequest(photoLink);
      request.execute();
      InputStream in=request.getResponseStream();
      ByteArrayOutputStream out=new ByteArrayOutputStream();
      byte[] buffer=new byte[4096];
      for (int read=0; (read=in.read(buffer)) != -1; out.write(buffer,0,read))       ;
      return out.toByteArray();
    }
  }
 catch (  Exception e) {
    logger.info(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Retrieve photo of a contact. Adapted from Google sample.
 * @param photoLink photo link
 * @param service
 * @return byte array containing image photo or null if problem happened
 */
public static byte[] downloadPhoto(ILink photoLink,ContactsService service){
  try {
    if (photoLink != null) {
      GDataRequest request=service.createLinkQueryRequest(photoLink);
      request.execute();
      InputStream in=request.getResponseStream();
      ByteArrayOutputStream out=new ByteArrayOutputStream();
      byte[] buffer=new byte[4096];
      for (int read=0; (read=in.read(buffer)) != -1; out.write(buffer,0,read))       ;
      return out.toByteArray();
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return null;
}",0.9940750493745886
103398,"/** 
 * Removes the <tt>ConferenceMemberPanel</tt> corresponding to the given <tt>member</tt>.
 * @param member the <tt>ConferenceMember</tt>, which panel to remove
 */
private void removeConferenceMemberPanel(ConferenceMember member){
  ConferenceMemberPanel memberPanel=conferenceMembersPanels.get(member);
  if (memberPanel != null) {
    this.remove(memberPanel);
    conferenceMembersPanels.remove(member);
    member.removePropertyChangeListener(memberPanel);
  }
}","/** 
 * Removes the <tt>ConferenceMemberPanel</tt> corresponding to the given <tt>member</tt>.
 * @param member the <tt>ConferenceMember</tt>, which panel to remove
 */
private void removeConferenceMemberPanel(ConferenceMember member){
  ConferenceMemberPanel memberPanel=conferenceMembersPanels.get(member);
  if (memberPanel != null) {
    int i=0;
    this.remove(memberPanel);
    conferenceMembersPanels.remove(member);
    member.removePropertyChangeListener(memberPanel);
    for (    Map.Entry<ConferenceMember,ConferenceMemberPanel> m : conferenceMembersPanels.entrySet()) {
      GridBagConstraints constraints=new GridBagConstraints();
      ConferenceMemberPanel mV=m.getValue();
      this.remove(mV);
      constraints.fill=GridBagConstraints.BOTH;
      constraints.gridx=0;
      constraints.gridy=i;
      constraints.weightx=1;
      constraints.weighty=0;
      constraints.insets=new Insets(10,0,0,0);
      this.add(mV,constraints);
      i++;
    }
  }
}",0.6510020732550104
103399,"/** 
 * Removes listeners registered for audio level changes with the specified receive  <tt>stream</tt>.
 * @param stream the stream whose listeners we'd like to get rid of.
 */
public void removeStreamAudioLevelListener(ReceiveStream stream){
synchronized (streamAudioLevelListeners) {
    AudioLevelEventDispatcher dispatcher=streamAudioLevelListeners.remove(stream);
    dispatcher.setAudioLevelListener(null);
  }
}","/** 
 * Removes listeners registered for audio level changes with the specified receive  <tt>stream</tt>.
 * @param stream the stream whose listeners we'd like to get rid of.
 */
public void removeStreamAudioLevelListener(ReceiveStream stream){
synchronized (streamAudioLevelListeners) {
    AudioLevelEventDispatcher dispatcher=streamAudioLevelListeners.remove(stream);
    if (dispatcher != null) {
      dispatcher.setAudioLevelListener(null);
    }
  }
}",0.9567198177676538
103400,"/** 
 * Notifies all CallPeer associated with and established in a specific call for conference information.
 * @param call the <tt>Call</tt>
 */
protected void notifyAll(Call call){
  if (!call.isConferenceFocus()) {
    return;
  }
synchronized (objSync) {
    Iterator<? extends CallPeer> it=call.getCallPeers();
    while (it.hasNext()) {
      CallPeer callPeer=it.next();
      System.out.print(callPeer.getAddress());
      notify(callPeer);
    }
    version++;
  }
}","/** 
 * Notifies all CallPeer associated with and established in a specific call for conference information.
 * @param call the <tt>Call</tt>
 */
protected void notifyAll(Call call){
  if (!call.isConferenceFocus()) {
    return;
  }
synchronized (objSync) {
    Iterator<? extends CallPeer> it=call.getCallPeers();
    while (it.hasNext()) {
      CallPeer callPeer=it.next();
      notify(callPeer);
    }
    version++;
  }
}",0.9479512735326688
103401,"/** 
 * Handle Coin IQ.
 * @param coinIQ Coin IQ
 * @param callPeer a <tt>CallPeer</tt>
 */
private void handleCoin(CoinIQ coinIQ,CallPeerJabberImpl callPeer){
  ConferenceMember[] conferenceMembersToRemove=callPeer.getConferenceMembers();
  int conferenceMembersToRemoveCount=conferenceMembersToRemove.length;
  UsersPacketExtension users=null;
  Collection<PacketExtension> usersList=coinIQ.getExtensions();
  for (  PacketExtension ext : usersList) {
    if (ext.getElementName().equals(UsersPacketExtension.ELEMENT_NAME)) {
      users=(UsersPacketExtension)ext;
      break;
    }
  }
  if (users == null) {
    return;
  }
  Collection<UserPacketExtension> userList=users.getChildExtensionsOfType(UserPacketExtension.class);
  if (userList.size() == 0) {
    return;
  }
  for (  UserPacketExtension u : userList) {
    String address=null;
    if (u.getAttribute(""String_Node_Str"") != null) {
      address=stripParametersFromAddress((String)u.getAttribute(""String_Node_Str""));
    }
    if ((address == null) || (address.length() < 1))     continue;
    ConferenceMemberJabberImpl existingConferenceMember=null;
    for (int conferenceMemberIndex=0; conferenceMemberIndex < conferenceMembersToRemoveCount; conferenceMemberIndex++) {
      ConferenceMemberJabberImpl conferenceMember=(ConferenceMemberJabberImpl)conferenceMembersToRemove[conferenceMemberIndex];
      if ((conferenceMember != null) && address.equalsIgnoreCase(conferenceMember.getAddress())) {
        conferenceMembersToRemove[conferenceMemberIndex]=null;
        existingConferenceMember=conferenceMember;
        break;
      }
    }
    boolean addConferenceMember=false;
    if (existingConferenceMember == null) {
      existingConferenceMember=new ConferenceMemberJabberImpl(callPeer,address);
      addConferenceMember=true;
    }
 else {
      addConferenceMember=false;
    }
    if (existingConferenceMember != null) {
      String displayName=u.getDisplayText();
      List<EndpointPacketExtension> endpoints=u.getChildExtensionsOfType(EndpointPacketExtension.class);
      String endpointStatus=null;
      String ssrc=null;
      if (endpoints.size() > 0) {
        EndpointPacketExtension endpoint=endpoints.get(0);
        endpointStatus=endpoint.getStatus().toString();
        List<MediaPacketExtension> medias=endpoint.getChildExtensionsOfType(MediaPacketExtension.class);
        for (        MediaPacketExtension media : medias) {
          if (media.getType().equalsIgnoreCase(MediaType.AUDIO.toString())) {
            ssrc=media.getSrcID();
          }
        }
      }
      existingConferenceMember.setDisplayName(displayName);
      existingConferenceMember.setEndpointStatus(endpointStatus);
      if (ssrc != null) {
        existingConferenceMember.setSSRC(Long.parseLong(ssrc));
      }
      if (addConferenceMember) {
        callPeer.addConferenceMember(existingConferenceMember);
      }
    }
  }
  for (int conferenceMemberIndex=0; conferenceMemberIndex < conferenceMembersToRemoveCount; conferenceMemberIndex++) {
    ConferenceMember conferenceMemberToRemove=conferenceMembersToRemove[conferenceMemberIndex];
    if (conferenceMemberToRemove != null)     callPeer.removeConferenceMember(conferenceMemberToRemove);
  }
}","/** 
 * Handle Coin IQ.
 * @param coinIQ Coin IQ
 * @param callPeer a <tt>CallPeer</tt>
 */
private void handleCoin(CoinIQ coinIQ,CallPeerJabberImpl callPeer){
  ConferenceMember[] conferenceMembersToRemove=callPeer.getConferenceMembers();
  int conferenceMembersToRemoveCount=conferenceMembersToRemove.length;
  UsersPacketExtension users=null;
  Collection<PacketExtension> usersList=coinIQ.getExtensions();
  for (  PacketExtension ext : usersList) {
    if (ext.getElementName().equals(UsersPacketExtension.ELEMENT_NAME)) {
      users=(UsersPacketExtension)ext;
      break;
    }
  }
  if (users == null) {
    return;
  }
  Collection<UserPacketExtension> userList=users.getChildExtensionsOfType(UserPacketExtension.class);
  if (userList.size() == 0) {
    return;
  }
  for (  UserPacketExtension u : userList) {
    String address=null;
    if (u.getAttribute(""String_Node_Str"") != null) {
      address=stripParametersFromAddress((String)u.getAttribute(""String_Node_Str""));
    }
    if ((address == null) || (address.length() < 1))     continue;
    ConferenceMemberJabberImpl existingConferenceMember=null;
    for (int conferenceMemberIndex=0; conferenceMemberIndex < conferenceMembersToRemoveCount; conferenceMemberIndex++) {
      ConferenceMemberJabberImpl conferenceMember=(ConferenceMemberJabberImpl)conferenceMembersToRemove[conferenceMemberIndex];
      if ((conferenceMember != null) && address.equalsIgnoreCase(conferenceMember.getAddress())) {
        conferenceMembersToRemove[conferenceMemberIndex]=null;
        existingConferenceMember=conferenceMember;
        break;
      }
    }
    boolean addConferenceMember=false;
    if (existingConferenceMember == null) {
      existingConferenceMember=new ConferenceMemberJabberImpl(callPeer,address);
      addConferenceMember=true;
    }
 else {
      addConferenceMember=false;
    }
    if (existingConferenceMember != null) {
      String displayName=u.getDisplayText();
      List<EndpointPacketExtension> endpoints=u.getChildExtensionsOfType(EndpointPacketExtension.class);
      String endpointStatus=null;
      String ssrc=null;
      if (endpoints.size() > 0) {
        EndpointPacketExtension endpoint=endpoints.get(0);
        if (endpoint.getStatus() == null) {
          break;
        }
        endpointStatus=endpoint.getStatus().toString();
        List<MediaPacketExtension> medias=endpoint.getChildExtensionsOfType(MediaPacketExtension.class);
        for (        MediaPacketExtension media : medias) {
          if (media.getType().equalsIgnoreCase(MediaType.AUDIO.toString())) {
            ssrc=media.getSrcID();
          }
        }
      }
      existingConferenceMember.setDisplayName(displayName);
      existingConferenceMember.setEndpointStatus(endpointStatus);
      if (ssrc != null) {
        existingConferenceMember.setSSRC(Long.parseLong(ssrc));
      }
      if (addConferenceMember) {
        callPeer.addConferenceMember(existingConferenceMember);
      }
    }
  }
  for (int conferenceMemberIndex=0; conferenceMemberIndex < conferenceMembersToRemoveCount; conferenceMemberIndex++) {
    ConferenceMember conferenceMemberToRemove=conferenceMembersToRemove[conferenceMemberIndex];
    if (conferenceMemberToRemove != null)     callPeer.removeConferenceMember(conferenceMemberToRemove);
  }
}",0.9891387486614656
103402,"/** 
 * Remove capabilities for the given contacts.
 * @param contact the <tt>Contact</tt>, which capabilities we remove
 * @param opSets the new updated set of operation sets
 */
private void removeCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<String> caps=this.capabilities.keySet().iterator();
  Set<String> contactNewCaps=opSets.keySet();
  while (caps.hasNext()) {
    String opSetName=caps.next();
    List<Contact> contactsForCap=capabilities.get(opSetName);
    if (contactsForCap.contains(contact) && !contactNewCaps.contains(opSetName)) {
      contactsForCap.remove(contact);
      if (contactsForCap.size() == 0)       capabilities.remove(opSetName);
    }
  }
}","/** 
 * Remove capabilities for the given contacts.
 * @param contact the <tt>Contact</tt>, which capabilities we remove
 * @param opSets the new updated set of operation sets
 */
private void removeCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<Map.Entry<String,List<Contact>>> caps=this.capabilities.entrySet().iterator();
  Set<String> contactNewCaps=opSets.keySet();
  while (caps.hasNext()) {
    Map.Entry<String,List<Contact>> entry=caps.next();
    String opSetName=entry.getKey();
    List<Contact> contactsForCap=entry.getValue();
    if (contactsForCap.contains(contact) && !contactNewCaps.contains(opSetName)) {
      contactsForCap.remove(contact);
      if (contactsForCap.size() == 0)       caps.remove();
    }
  }
}",0.8899392302498312
103403,"/** 
 * Handles the change when we turn on/off local video streaming such as creating/releasing visual component.
 * @param listener Listener that will be callbacked
 */
private void handleLocalVideoStreamingChange(VideoTelephonyListener listener){
synchronized (videoContainers) {
    if (videoTelephony == null)     return;
    if (videoTelephony.isLocalVideoStreaming(callPeer.getCall())) {
      try {
        videoTelephony.createLocalVisualComponent(callPeer,listener);
      }
 catch (      OperationFailedException ex) {
        logger.error(""String_Node_Str"",ex);
      }
    }
 else     if (localVideo != null) {
      videoTelephony.disposeLocalVisualComponent(callPeer,localVideo);
      localVideo=null;
    }
  }
}","/** 
 * Handles the change when we turn on/off local video streaming such as creating/releasing visual component.
 * @param listener Listener that will be called back
 */
private void handleLocalVideoStreamingChange(VideoTelephonyListener listener){
synchronized (videoContainers) {
    if (videoTelephony == null)     return;
    if (videoTelephony.isLocalVideoStreaming(callPeer.getCall())) {
      try {
        videoTelephony.createLocalVisualComponent(callPeer,listener);
      }
 catch (      OperationFailedException ex) {
        logger.error(""String_Node_Str"",ex);
      }
    }
 else     if (localVideo != null) {
      videoTelephony.disposeLocalVisualComponent(callPeer,localVideo);
      localVideo=null;
    }
  }
}",0.9965682910089224
103404,"/** 
 * Shows/hides the local video component.
 * @param isVisible <tt>true</tt> to show the local video, <tt>false</tt> -otherwise
 */
public void setLocalVideoVisible(boolean isVisible){
synchronized (videoContainers) {
    this.localVideoVisible=isVisible;
    if (isVisible != callRenderer.getCallContainer().isShowHideVideoButtonSelected()) {
      callRenderer.getCallContainer().setShowHideVideoButtonSelected(isVisible);
    }
    int videoContainerCount;
    if ((videoTelephony != null) && ((videoContainerCount=videoContainers.size()) > 0)) {
      Container videoContainer=videoContainers.get(videoContainerCount - 1);
      if (localVideo != null) {
        if (isVisible) {
          Container localVideoParent=localVideo.getParent();
          if (localVideoParent != null)           localVideoParent.remove(localVideo);
          Container closeButtonParent=closeButton.getParent();
          if (closeButtonParent != null)           closeButtonParent.remove(closeButton);
          videoContainer.add(localVideo,VideoLayout.LOCAL);
          videoContainer.add(closeButton,VideoLayout.CLOSE_LOCAL_BUTTON);
        }
 else {
          videoContainer.remove(localVideo);
          videoContainer.remove(closeButton);
        }
      }
    }
  }
}","/** 
 * Shows/hides the local video component.
 * @param isVisible <tt>true</tt> to show the local video, <tt>false</tt> -otherwise
 */
public void setLocalVideoVisible(boolean isVisible){
synchronized (videoContainers) {
    this.localVideoVisible=isVisible;
    if (isVisible != callRenderer.getCallContainer().isShowHideVideoButtonSelected()) {
      callRenderer.getCallContainer().setShowHideVideoButtonSelected(isVisible);
    }
    int videoContainerCount;
    if ((videoTelephony != null) && ((videoContainerCount=videoContainers.size()) > 0)) {
      Container videoContainer=videoContainers.get(videoContainerCount - 1);
      if (localVideo != null) {
        if (isVisible) {
          Container localVideoParent=localVideo.getParent();
          if (localVideoParent != null)           localVideoParent.remove(localVideo);
          Container closeButtonParent=closeButton.getParent();
          if (closeButtonParent != null)           closeButtonParent.remove(closeButton);
          videoContainer.add(localVideo,VideoLayout.LOCAL);
          videoContainer.add(closeButton,VideoLayout.CLOSE_LOCAL_BUTTON);
        }
 else {
          videoContainer.remove(localVideo);
          videoContainer.remove(closeButton);
        }
        videoContainer.validate();
        videoContainer.repaint();
      }
    }
  }
}",0.9733693554612118
103405,"/** 
 * Creates all the controls for a type(AUDIO or VIDEO)
 * @param type the type.
 * @return the build Component.
 */
private static Component createControls(int type){
  final JComboBox comboBox=new JComboBox();
  comboBox.setEditable(false);
  comboBox.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),type));
  final JPanel portAudioPanel;
  if (type == DeviceConfigurationComboBoxModel.AUDIO) {
    portAudioPanel=new TransparentPanel(new GridBagLayout());
    portAudioPanel.setPreferredSize(new Dimension(WIDTH,200));
    portAudioPanel.setMaximumSize(new Dimension(WIDTH,200));
    comboBox.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        if (e.getStateChange() == ItemEvent.SELECTED) {
          if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
            createPortAudioControls(portAudioPanel);
          }
 else {
            portAudioPanel.removeAll();
          }
          portAudioPanel.revalidate();
          portAudioPanel.repaint();
        }
      }
    }
);
    if (comboBox.getSelectedItem().equals(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO))     createPortAudioControls(portAudioPanel);
  }
 else {
    portAudioPanel=null;
  }
  JLabel label=new JLabel(getLabelText(type));
  label.setDisplayedMnemonic(getDisplayedMnemonic(type));
  label.setLabelFor(comboBox);
  Container firstContainer=new TransparentPanel(new FlowLayout(FlowLayout.CENTER));
  firstContainer.setMaximumSize(new Dimension(WIDTH,25));
  firstContainer.add(label);
  firstContainer.add(comboBox);
  JPanel secondContainer=new TransparentPanel();
  secondContainer.setLayout(new BoxLayout(secondContainer,BoxLayout.Y_AXIS));
  if (portAudioPanel != null) {
    secondContainer.add(portAudioPanel);
  }
 else {
    comboBox.setLightWeightPopupEnabled(false);
    secondContainer.add(createPreview(type,comboBox));
  }
  secondContainer.add(createEncodingControls(type));
  JPanel container=new TransparentPanel(new BorderLayout());
  container.add(firstContainer,BorderLayout.NORTH);
  container.add(secondContainer,BorderLayout.CENTER);
  return container;
}","/** 
 * Creates all the controls for a type(AUDIO or VIDEO)
 * @param type the type.
 * @return the build Component.
 */
private static Component createControls(int type){
  final JComboBox comboBox=new JComboBox();
  comboBox.setEditable(false);
  comboBox.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),type));
  final JPanel portAudioPanel;
  if (type == DeviceConfigurationComboBoxModel.AUDIO) {
    portAudioPanel=new TransparentPanel(new GridBagLayout());
    portAudioPanel.setPreferredSize(new Dimension(WIDTH,200));
    portAudioPanel.setMaximumSize(new Dimension(WIDTH,200));
    comboBox.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        if (ItemEvent.SELECTED == e.getStateChange()) {
          if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
            createPortAudioControls(portAudioPanel);
          }
 else {
            portAudioPanel.removeAll();
          }
          portAudioPanel.revalidate();
          portAudioPanel.repaint();
        }
      }
    }
);
    if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(comboBox.getSelectedItem()))     createPortAudioControls(portAudioPanel);
  }
 else {
    portAudioPanel=null;
  }
  JLabel label=new JLabel(getLabelText(type));
  label.setDisplayedMnemonic(getDisplayedMnemonic(type));
  label.setLabelFor(comboBox);
  Container firstContainer=new TransparentPanel(new FlowLayout(FlowLayout.CENTER));
  firstContainer.setMaximumSize(new Dimension(WIDTH,25));
  firstContainer.add(label);
  firstContainer.add(comboBox);
  JPanel secondContainer=new TransparentPanel();
  secondContainer.setLayout(new BoxLayout(secondContainer,BoxLayout.Y_AXIS));
  if (portAudioPanel != null) {
    secondContainer.add(portAudioPanel);
  }
 else {
    comboBox.setLightWeightPopupEnabled(false);
    secondContainer.add(createPreview(type,comboBox));
  }
  secondContainer.add(createEncodingControls(type));
  JPanel container=new TransparentPanel(new BorderLayout());
  container.add(firstContainer,BorderLayout.NORTH);
  container.add(secondContainer,BorderLayout.CENTER);
  return container;
}",0.9740980573543015
103406,"public void itemStateChanged(ItemEvent e){
  if (e.getStateChange() == ItemEvent.SELECTED) {
    if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
      createPortAudioControls(portAudioPanel);
    }
 else {
      portAudioPanel.removeAll();
    }
    portAudioPanel.revalidate();
    portAudioPanel.repaint();
  }
}","public void itemStateChanged(ItemEvent e){
  if (ItemEvent.SELECTED == e.getStateChange()) {
    if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
      createPortAudioControls(portAudioPanel);
    }
 else {
      portAudioPanel.removeAll();
    }
    portAudioPanel.revalidate();
    portAudioPanel.repaint();
  }
}",0.8928571428571429
103407,"public void hierarchyChanged(HierarchyEvent event){
  if (((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) && comboBox.isDisplayable()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        comboBoxListener.actionPerformed(null);
      }
    }
);
  }
 else {
    if (!comboBox.isDisplayable())     videoDeviceInPreview=null;
  }
}","public void hierarchyChanged(HierarchyEvent event){
  if ((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) == 0)   return;
  if (comboBox.isDisplayable()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        comboBoxListener.actionPerformed(null);
      }
    }
);
    if (windowListener == null) {
      window=SwingUtilities.windowForComponent(comboBox);
      if (window != null) {
        windowListener=new WindowAdapter(){
          @Override public void windowClosing(          WindowEvent event){
            dispose();
          }
        }
;
        window.addWindowListener(windowListener);
      }
    }
  }
 else {
    dispose();
  }
}",0.2364990689013035
103408,"/** 
 * Create preview component.
 * @param type type
 * @param comboBox the options.
 * @return the component.
 */
private static Component createPreview(int type,final JComboBox comboBox){
  final JComponent preview;
  if (type == DeviceConfigurationComboBoxModel.VIDEO) {
    JLabel noPreview=new JLabel(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
    noPreview.setHorizontalAlignment(SwingConstants.CENTER);
    noPreview.setVerticalAlignment(SwingConstants.CENTER);
    preview=createVideoContainer(noPreview);
    preview.setPreferredSize(new Dimension(WIDTH,280));
    preview.setMaximumSize(new Dimension(WIDTH,280));
    final ActionListener comboBoxListener=new ActionListener(){
      public void actionPerformed(      ActionEvent event){
        Object selection=comboBox.getSelectedItem();
        CaptureDeviceInfo device=null;
        if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice)         device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
        ((DeviceConfigurationComboBoxModel)comboBox.getModel()).reinitVideo();
        if ((device != null) && device.equals(videoDeviceInPreview))         return;
        Exception exception;
        try {
          createPreview(device,preview);
          exception=null;
        }
 catch (        IOException ex) {
          exception=ex;
        }
catch (        MediaException ex) {
          exception=ex;
        }
        if (exception != null) {
          logger.error(""String_Node_Str"" + device,exception);
          device=null;
        }
        videoDeviceInPreview=device;
      }
    }
;
    comboBox.addActionListener(comboBoxListener);
    comboBox.addHierarchyListener(new HierarchyListener(){
      public void hierarchyChanged(      HierarchyEvent event){
        if (((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) && comboBox.isDisplayable()) {
          SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              comboBoxListener.actionPerformed(null);
            }
          }
);
        }
 else {
          if (!comboBox.isDisplayable())           videoDeviceInPreview=null;
        }
      }
    }
);
  }
 else   preview=new TransparentPanel();
  return preview;
}","/** 
 * Create preview component.
 * @param type type
 * @param comboBox the options.
 * @return the component.
 */
private static Component createPreview(int type,final JComboBox comboBox){
  final JComponent preview;
  if (type == DeviceConfigurationComboBoxModel.VIDEO) {
    JLabel noPreview=new JLabel(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
    noPreview.setHorizontalAlignment(SwingConstants.CENTER);
    noPreview.setVerticalAlignment(SwingConstants.CENTER);
    preview=createVideoContainer(noPreview);
    preview.setPreferredSize(new Dimension(WIDTH,280));
    preview.setMaximumSize(new Dimension(WIDTH,280));
    final ActionListener comboBoxListener=new ActionListener(){
      public void actionPerformed(      ActionEvent event){
        Object selection=comboBox.getSelectedItem();
        CaptureDeviceInfo device=null;
        if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice)         device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
        ((DeviceConfigurationComboBoxModel)comboBox.getModel()).reinitVideo();
        if ((device != null) && device.equals(videoDeviceInPreview))         return;
        Exception exception;
        try {
          createPreview(device,preview);
          exception=null;
        }
 catch (        IOException ex) {
          exception=ex;
        }
catch (        MediaException ex) {
          exception=ex;
        }
        if (exception != null) {
          logger.error(""String_Node_Str"" + device,exception);
          device=null;
        }
        videoDeviceInPreview=device;
      }
    }
;
    comboBox.addActionListener(comboBoxListener);
    HierarchyListener hierarchyListener=new HierarchyListener(){
      private Window window;
      private WindowListener windowListener;
      public void dispose(){
        if (windowListener != null) {
          if (window != null) {
            window.removeWindowListener(windowListener);
            window=null;
          }
          windowListener=null;
        }
        videoDeviceInPreview=null;
      }
      public void hierarchyChanged(      HierarchyEvent event){
        if ((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) == 0)         return;
        if (comboBox.isDisplayable()) {
          SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              comboBoxListener.actionPerformed(null);
            }
          }
);
          if (windowListener == null) {
            window=SwingUtilities.windowForComponent(comboBox);
            if (window != null) {
              windowListener=new WindowAdapter(){
                @Override public void windowClosing(                WindowEvent event){
                  dispose();
                }
              }
;
              window.addWindowListener(windowListener);
            }
          }
        }
 else {
          dispose();
        }
      }
    }
;
    comboBox.addHierarchyListener(hierarchyListener);
  }
 else   preview=new TransparentPanel();
  return preview;
}",0.7065868263473054
103409,"@Override public void componentResized(ComponentEvent e){
  processLightweightComponentEvent();
}","@Override public void componentResized(ComponentEvent e){
}",0.7564102564102564
103410,"/** 
 * Dispatches <tt>MouseEvent</tt>s to whatever is underneath this <tt>SwingVideoComponentCanvas</tt> because it only renders <tt>Component</tt>s i.e. it is like a ""glass pane"".
 */
private boolean dispatchMouseEvent(MouseEvent e){
  Component srcc=e.getComponent();
  if (srcc != null) {
    Container parent=getParent();
    if (parent != null) {
      Point parentPoint=SwingUtilities.convertPoint(srcc,e.getPoint(),parent);
      Component dstc=getComponentAt(parent,parentPoint);
      if (dstc != null) {
        dstc.dispatchEvent(SwingUtilities.convertMouseEvent(srcc,e,dstc));
        return true;
      }
    }
  }
  return false;
}","/** 
 * Dispatches <tt>MouseEvent</tt>s to whatever is underneath this <tt>SwingVideoComponentCanvas</tt> because it only renders <tt>Component</tt>s i.e. it is like a ""glass pane"".
 */
private boolean dispatchMouseEvent(MouseEvent e){
  Component srcc=e.getComponent();
  if (srcc != null) {
    int id=e.getID();
    Component dstc=null;
    if (MouseEvent.MOUSE_PRESSED == id)     mousePressedComponent=null;
 else     if (mousePressedComponent != null) {
      dstc=mousePressedComponent;
      if ((MouseEvent.MOUSE_CLICKED == id) || (MouseEvent.MOUSE_RELEASED == id))       mousePressedComponent=null;
    }
    if (dstc == null) {
      Container parent=getParent();
      if (parent != null) {
        Point parentPoint=SwingUtilities.convertPoint(srcc,e.getPoint(),parent);
        dstc=getComponentAt(parent,parentPoint);
      }
    }
    if (dstc != null) {
      if (MouseEvent.MOUSE_PRESSED == id)       mousePressedComponent=dstc;
      dstc.dispatchEvent(SwingUtilities.convertMouseEvent(srcc,e,dstc));
      return true;
    }
  }
  return false;
}",0.668614845119813
103411,"public void componentRemoved(ContainerEvent e){
  Component c=e.getChild();
  if (!(c instanceof AWTVideoComponent) && !(c instanceof SwingVideoComponent)) {
    nonVideoComponentRemoved(c);
  }
 else   if (SwingVideoComponentCanvas.this.equals(c))   removeAllNonVideoComponents();
}","public void componentRemoved(ContainerEvent e){
  Component c=e.getChild();
  if (mousePressedComponent == c)   mousePressedComponent=null;
  if (!(c instanceof AWTVideoComponent) && !(c instanceof SwingVideoComponent)) {
    nonVideoComponentRemoved(c);
  }
 else   if (SwingVideoComponentCanvas.this.equals(c))   removeAllNonVideoComponents();
}",0.8984126984126984
103412,"@Override public void removeNotify(){
  if (parent != null) {
    parent.removeContainerListener(parentContainerListener);
    removeAllNonVideoComponents();
    parent=null;
  }
synchronized (getHandleLock()) {
    long handle=getHandle();
    if (handle != 0) {
      try {
        close(handle,this);
      }
  finally {
        this.handle=0;
      }
    }
  }
  super.removeNotify();
}","@Override public void removeNotify(){
  mousePressedComponent=null;
  if (parent != null) {
    parent.removeContainerListener(parentContainerListener);
    removeAllNonVideoComponents();
    parent=null;
  }
synchronized (getHandleLock()) {
    long handle=getHandle();
    if (handle != 0) {
      try {
        close(handle,this);
      }
  finally {
        this.handle=0;
      }
    }
  }
  super.removeNotify();
}",0.9629629629629628
103413,"/** 
 * Returns the media type (e.g. audio or video) for the specified media <tt>description</tt>.
 * @param description the <tt>MediaDescription</tt> whose media type we'dlike to extract.
 * @return the media type (e.g. audio or video) for the specified media<tt>description</tt>.
 */
public static MediaType getMediaType(MediaDescription description){
  try {
    return MediaType.parseString(description.getMedia().getMediaType());
  }
 catch (  SdpException exc) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + description,exc);
    throw new IllegalArgumentException(""String_Node_Str"" + description,exc);
  }
}","/** 
 * Returns the media type (e.g. audio or video) for the specified media <tt>description</tt>.
 * @param description the <tt>MediaDescription</tt> whose media type we'dlike to extract.
 * @return the media type (e.g. audio or video) for the specified media<tt>description</tt>.
 * @throws IllegalArgumentException if <tt>description</tt> does notcontain a known media type.
 */
public static MediaType getMediaType(MediaDescription description) throws IllegalArgumentException {
  try {
    return MediaType.parseString(description.getMedia().getMediaType());
  }
 catch (  SdpException exc) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + description,exc);
    throw new IllegalArgumentException(""String_Node_Str"" + description,exc);
  }
}",0.6695095948827292
103414,"/** 
 * Creates and returns a new <tt>SessionDescription</tt> that is supposed to update our previous <tt>descToUpdate</tt> and advertise the brand new <tt>newMediaDescriptions</tt>. The method also respects other 3264 policies like reusing the origin field and augmenting its version number for example.
 * @param descToUpdate the <tt>SessionDescription</tt> that we'd like toupdate.
 * @param newConnectionAddress the <tt>InetAddress</tt> that we'd like touse in the new <tt>c=</tt> field.
 * @param newMediaDescriptions the descriptions of the new streams that we'dlike to have in the updated session.
 * @return a new <tt>SessionDescription</tt> that updates<tt>descToUpdate</tt>;
 */
public static SessionDescription createSessionUpdateDescription(SessionDescription descToUpdate,InetAddress newConnectionAddress,Vector<MediaDescription> newMediaDescriptions) throws OperationFailedException {
  SessionDescription update=createSessionDescription(newConnectionAddress,null,newMediaDescriptions);
  try {
    Origin o=(Origin)descToUpdate.getOrigin().clone();
    long version=o.getSessionVersion();
    o.setSessionVersion(version + 1);
    update.setOrigin(o);
  }
 catch (  Exception e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
  Vector<MediaDescription> prevMedias=extractMediaDescriptions(descToUpdate);
  Vector<MediaDescription> completeMediaDescList=new Vector<MediaDescription>();
  newMediaDescriptions=new Vector<MediaDescription>(newMediaDescriptions);
  for (  MediaDescription medToUpdate : prevMedias) {
    MediaType type=getMediaType(medToUpdate);
    MediaDescription desc=removeMediaDesc(newMediaDescriptions,type);
    if (desc == null) {
      desc=createDisablingAnswer(medToUpdate);
    }
    completeMediaDescList.add(desc);
  }
  for (  MediaDescription medToAdd : newMediaDescriptions) {
    completeMediaDescList.add(medToAdd);
  }
  try {
    update.setMediaDescriptions(completeMediaDescList);
  }
 catch (  SdpException e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
  return update;
}","/** 
 * Creates and returns a new <tt>SessionDescription</tt> that is supposed to update our previous <tt>descToUpdate</tt> and advertise the brand new <tt>newMediaDescriptions</tt>. The method also respects other 3264 policies like reusing the origin field and augmenting its version number for example.
 * @param descToUpdate the <tt>SessionDescription</tt> that we'd like toupdate.
 * @param newConnectionAddress the <tt>InetAddress</tt> that we'd like touse in the new <tt>c=</tt> field.
 * @param newMediaDescriptions the descriptions of the new streams that we'dlike to have in the updated session.
 * @return a new <tt>SessionDescription</tt> that updates<tt>descToUpdate</tt>;
 */
public static SessionDescription createSessionUpdateDescription(SessionDescription descToUpdate,InetAddress newConnectionAddress,Vector<MediaDescription> newMediaDescriptions) throws OperationFailedException {
  SessionDescription update=createSessionDescription(newConnectionAddress,null,newMediaDescriptions);
  try {
    Origin o=(Origin)descToUpdate.getOrigin().clone();
    long version=o.getSessionVersion();
    o.setSessionVersion(version + 1);
    update.setOrigin(o);
  }
 catch (  Exception e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
  Vector<MediaDescription> prevMedias=extractMediaDescriptions(descToUpdate);
  Vector<MediaDescription> completeMediaDescList=new Vector<MediaDescription>();
  newMediaDescriptions=new Vector<MediaDescription>(newMediaDescriptions);
  for (  MediaDescription medToUpdate : prevMedias) {
    MediaDescription desc=null;
    try {
      MediaType type=getMediaType(medToUpdate);
      desc=removeMediaDesc(newMediaDescriptions,type);
    }
 catch (    IllegalArgumentException e) {
    }
    if (desc == null) {
      desc=createDisablingAnswer(medToUpdate);
    }
    completeMediaDescList.add(desc);
  }
  for (  MediaDescription medToAdd : newMediaDescriptions) {
    completeMediaDescList.add(medToAdd);
  }
  try {
    update.setMediaDescriptions(completeMediaDescList);
  }
 catch (  SdpException e) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e);
  }
  return update;
}",0.972972972972973
103415,"/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @param device video device that will be used to stream desktop.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee,MediaDevice device) throws OperationFailedException {
  CallJabberImpl call=(CallJabberImpl)super.createVideoCall(callee,device);
  CallPeerJabberImpl callPeer=call.getCallPeers().next();
  callPeer.addCallPeerListener(callPeerListener);
  size=(((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=null;
  return call;
}","/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @param device video device that will be used to stream desktop.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee,MediaDevice device) throws OperationFailedException {
  CallJabberImpl call=(CallJabberImpl)super.createVideoCall(callee,device);
  CallPeerJabberImpl callPeer=call.getCallPeers().next();
  callPeer.addCallPeerListener(callPeerListener);
  size=(((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=getOriginForMediaDevice(device);
  return call;
}",0.9715113471752777
103416,"/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice <tt>MediaDevice</tt> used
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  call.setVideoDevice(videoDevice);
  call.setLocalVideoAllowed(true,getMediaUseCase());
  basicTelephony.createOutgoingCall(call,calleeAddress);
  origin=null;
  return call;
}","/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice <tt>MediaDevice</tt> used
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  call.setVideoDevice(videoDevice);
  call.setLocalVideoAllowed(true,getMediaUseCase());
  basicTelephony.createOutgoingCall(call,calleeAddress);
  origin=getOriginForMediaDevice(videoDevice);
  return call;
}",0.9765807962529274
103417,"/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  ((CallJabberImpl)call).setLocalVideoAllowed(allowed,MediaUseCase.DESKTOP);
  ((CallJabberImpl)call).setVideoDevice(mediaDevice);
  size=((VideoMediaFormat)mediaDevice.getFormat()).getSize();
  ((CallJabberImpl)call).modifyVideoContent(allowed);
  origin=null;
}","/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  ((CallJabberImpl)call).setLocalVideoAllowed(allowed,MediaUseCase.DESKTOP);
  ((CallJabberImpl)call).setVideoDevice(mediaDevice);
  size=((VideoMediaFormat)mediaDevice.getFormat()).getSize();
  ((CallJabberImpl)call).modifyVideoContent(allowed);
  origin=getOriginForMediaDevice(mediaDevice);
}",0.9815327793167128
103418,"/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee) throws OperationFailedException {
  Call call=createOutgoingVideoCall(callee.getAddress());
  size=(((VideoMediaFormat)((CallJabberImpl)call).getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=null;
  return call;
}","/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee) throws OperationFailedException {
  Call call=createOutgoingVideoCall(callee.getAddress());
  MediaDevice device=((CallJabberImpl)call).getDefaultDevice(MediaType.VIDEO);
  size=(((VideoMediaFormat)device.getFormat()).getSize());
  origin=getOriginForMediaDevice(device);
  return call;
}",0.9310747663551402
103419,"/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @param device <tt>MediaDevice</tt> to use for this call
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee,MediaDevice device) throws OperationFailedException {
  CallSipImpl call=(CallSipImpl)super.createVideoCall(callee,device);
  CallPeerSipImpl callPeer=call.getCallPeers().next();
  callPeer.addMethodProcessorListener(this);
  callPeer.addCallPeerListener(callPeerListener);
  size=(((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=null;
  return call;
}","/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @param device <tt>MediaDevice</tt> to use for this call
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee,MediaDevice device) throws OperationFailedException {
  CallSipImpl call=(CallSipImpl)super.createVideoCall(callee,device);
  CallPeerSipImpl callPeer=call.getCallPeers().next();
  callPeer.addMethodProcessorListener(this);
  callPeer.addCallPeerListener(callPeerListener);
  size=(((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=getOriginForMediaDevice(device);
  return call;
}",0.9722614010343208
103420,"/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  ((CallSipImpl)call).setVideoDevice(mediaDevice);
  ((CallSipImpl)call).setLocalVideoAllowed(allowed,MediaUseCase.DESKTOP);
  size=(((VideoMediaFormat)((CallSipImpl)call).getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=null;
  ((CallSipImpl)call).reInvite();
}","/** 
 * Sets the indicator which determines whether the streaming of local video in a specific <tt>Call</tt> is allowed. The setting does not reflect the availability of actual video capture devices, it just expresses the desire of the user to have the local video streamed in the case the system is actually able to do so.
 * @param call the <tt>Call</tt> to allow/disallow the streaming of localvideo for
 * @param mediaDevice the media device to use for the desktop streaming
 * @param allowed <tt>true</tt> to allow the streaming of local video forthe specified <tt>Call</tt>; <tt>false</tt> to disallow it
 * @throws OperationFailedException if initializing local video fails.
 */
public void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed) throws OperationFailedException {
  ((CallSipImpl)call).setVideoDevice(mediaDevice);
  ((CallSipImpl)call).setLocalVideoAllowed(allowed,MediaUseCase.DESKTOP);
  size=(((VideoMediaFormat)((CallSipImpl)call).getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=getOriginForMediaDevice(mediaDevice);
  ((CallSipImpl)call).reInvite();
}",0.9818346957311536
103421,"/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee) throws OperationFailedException {
  Call call=super.createVideoCall(callee);
  size=(((VideoMediaFormat)((CallSipImpl)call).getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());
  origin=null;
  return call;
}","/** 
 * Create a new video call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override public Call createVideoCall(Contact callee) throws OperationFailedException {
  Call call=super.createVideoCall(callee);
  MediaDevice device=((CallSipImpl)call).getDefaultDevice(MediaType.VIDEO);
  size=(((VideoMediaFormat)device.getFormat()).getSize());
  origin=getOriginForMediaDevice(device);
  return call;
}",0.9295942720763724
103422,"/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (contactList instanceof TreeContactList) {
    ContactListFilter filter=((TreeContactList)contactList).getCurrentFilter();
    if (filter != null && filter.equals(TreeContactList.historyFilter) && value instanceof ContactNode && row % 2 == 0) {
      setBackground(Constants.CALL_HISTORY_EVEN_ROW_COLOR);
    }
 else {
      setBackground(Color.WHITE);
    }
  }
  if (value instanceof ContactNode) {
    UIContact contact=((ContactNode)value).getContactDescriptor();
    String displayName=contact.getDisplayName();
    if ((displayName == null || displayName.trim().length() < 1) && !(contact instanceof ShowMoreContact)) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isContactActive(contact))     statusIcon.setImage(msgReceivedImage);
 else     statusIcon=contact.getStatusIcon();
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     nameLabel.setForeground(contactForegroundColor);
    if (contact instanceof ShowMoreContact) {
      rightLabel.setFont(rightLabel.getFont().deriveFont(12f));
      rightLabel.setForeground(Color.GRAY);
      rightLabel.setText((String)contact.getDescriptor());
    }
 else     rightLabel.setText(""String_Node_Str"");
    this.initDisplayDetails(contact);
    this.initButtonsPanel(contact);
    int avatarWidth, avatarHeight;
    if (isSelected) {
      avatarWidth=EXTENDED_AVATAR_WIDTH;
      avatarHeight=EXTENDED_AVATAR_HEIGHT;
    }
 else {
      avatarWidth=AVATAR_WIDTH;
      avatarHeight=AVATAR_HEIGHT;
    }
    ImageIcon avatar=contact.getAvatar(isSelected,avatarWidth,avatarHeight);
    if (avatar != null) {
      this.rightLabel.setIcon(avatar);
    }
    this.setToolTipText(contact.getDescriptor().toString());
  }
 else   if (value instanceof GroupNode) {
    UIGroup groupItem=((GroupNode)value).getGroupDescriptor();
    this.nameLabel.setText(groupItem.getDisplayName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(displayDetailsLabel);
    this.remove(callButton);
    this.remove(callVideoButton);
    this.remove(desktopSharingButton);
    this.remove(chatButton);
    this.remove(addContactButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    this.rightLabel.setText(""String_Node_Str"");
    if (groupItem.countChildContacts() >= 0) {
      rightLabel.setFont(rightLabel.getFont().deriveFont(9f));
      this.rightLabel.setForeground(Color.BLACK);
      this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    }
    this.setToolTipText(groupItem.getDescriptor().toString());
  }
  return this;
}","/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (contactList instanceof TreeContactList) {
    ContactListFilter filter=((TreeContactList)contactList).getCurrentFilter();
    if (filter != null && filter.equals(TreeContactList.historyFilter) && value instanceof ContactNode && row % 2 == 0) {
      setBackground(Constants.CALL_HISTORY_EVEN_ROW_COLOR);
    }
 else {
      setBackground(Color.WHITE);
    }
  }
  if (value instanceof ContactNode) {
    UIContact contact=((ContactNode)value).getContactDescriptor();
    String displayName=contact.getDisplayName();
    if ((displayName == null || displayName.trim().length() < 1) && !(contact instanceof ShowMoreContact)) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isContactActive(contact))     statusIcon.setImage(msgReceivedImage);
 else     statusIcon=contact.getStatusIcon();
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     nameLabel.setForeground(contactForegroundColor);
    this.initDisplayDetails(contact);
    this.initButtonsPanel(contact);
    int avatarWidth, avatarHeight;
    if (isSelected) {
      avatarWidth=EXTENDED_AVATAR_WIDTH;
      avatarHeight=EXTENDED_AVATAR_HEIGHT;
    }
 else {
      avatarWidth=AVATAR_WIDTH;
      avatarHeight=AVATAR_HEIGHT;
    }
    ImageIcon avatar=contact.getAvatar(isSelected,avatarWidth,avatarHeight);
    if (avatar != null) {
      this.rightLabel.setIcon(avatar);
    }
    if (contact instanceof ShowMoreContact) {
      rightLabel.setFont(rightLabel.getFont().deriveFont(12f));
      rightLabel.setForeground(Color.GRAY);
      rightLabel.setText((String)contact.getDescriptor());
    }
 else {
      rightLabel.setFont(rightLabel.getFont().deriveFont(9f));
      rightLabel.setText(""String_Node_Str"");
    }
    this.setToolTipText(contact.getDescriptor().toString());
  }
 else   if (value instanceof GroupNode) {
    UIGroup groupItem=((GroupNode)value).getGroupDescriptor();
    this.nameLabel.setText(groupItem.getDisplayName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(displayDetailsLabel);
    this.remove(callButton);
    this.remove(callVideoButton);
    this.remove(desktopSharingButton);
    this.remove(chatButton);
    this.remove(addContactButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    this.rightLabel.setText(""String_Node_Str"");
    if (groupItem.countChildContacts() >= 0) {
      rightLabel.setFont(rightLabel.getFont().deriveFont(9f));
      this.rightLabel.setForeground(Color.BLACK);
      this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    }
    this.setToolTipText(groupItem.getDescriptor().toString());
  }
  return this;
}",0.9190912714228776
103423,"/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if (!path.equals(getSelectionPath()) && (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  if (lastComponent instanceof ContactNode) {
    UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiContact.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiGroup.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
  dispatchEventToButtons(e);
}","/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  boolean isSelected=path.equals(getSelectionPath());
  if (!isSelected && (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  if (lastComponent instanceof ContactNode) {
    UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiContact.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiGroup.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
  if (isSelected && e.getClickCount() < 2)   dispatchEventToButtons(e);
}",0.9633933759442184
103424,"/** 
 * Manages a mouse click over the contact list. When the left mouse button is clicked on a contact cell different things may happen depending on the contained component under the mouse. If the mouse is double clicked on the ""contact name"" the chat window is opened, configured to use the default protocol contact for the selected MetaContact. If the mouse is clicked on one of the protocol icons, the chat window is opened, configured to use the protocol contact corresponding to the given icon. When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the click
 */
public void mouseClicked(MouseEvent e){
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) == 0)   return;
  if (lastComponent instanceof ContactNode) {
    fireContactListEvent(((ContactNode)lastComponent).getContactDescriptor(),ContactListEvent.CONTACT_CLICKED,e.getClickCount());
  }
 else   if (lastComponent instanceof GroupNode) {
    fireContactListEvent(((GroupNode)lastComponent).getGroupDescriptor(),ContactListEvent.GROUP_CLICKED,e.getClickCount());
  }
  if (e.getClickCount() < 2)   dispatchEventToButtons(e);
}","/** 
 * Manages a mouse click over the contact list. When the left mouse button is clicked on a contact cell different things may happen depending on the contained component under the mouse. If the mouse is double clicked on the ""contact name"" the chat window is opened, configured to use the default protocol contact for the selected MetaContact. If the mouse is clicked on one of the protocol icons, the chat window is opened, configured to use the protocol contact corresponding to the given icon. When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the click
 */
public void mouseClicked(MouseEvent e){
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) == 0)   return;
  if (lastComponent instanceof ContactNode) {
    fireContactListEvent(((ContactNode)lastComponent).getContactDescriptor(),ContactListEvent.CONTACT_CLICKED,e.getClickCount());
  }
 else   if (lastComponent instanceof GroupNode) {
    fireContactListEvent(((GroupNode)lastComponent).getGroupDescriptor(),ContactListEvent.GROUP_CLICKED,e.getClickCount());
  }
}",0.9817724701445631
103425,"/** 
 * Move origin of a partial desktop streaming <tt>MediaDevice</tt>.
 * @param mediaDevice desktop streaming <tt>MediaDevice</tt> obtained bygetMediaDeviceForPartialDesktopStreaming() method.
 * @param x new x coordinate origin
 * @param y new y coordinate origin
 */
public void movePartialDesktopStreaming(MediaDevice mediaDevice,int x,int y){
  MediaDeviceImpl dev=(MediaDeviceImpl)mediaDevice;
  if (!dev.getCaptureDeviceInfo().getLocator().getProtocol().equals(ImageStreamingAuto.LOCATOR_PROTOCOL)) {
    return;
  }
  VideoMediaDeviceSession session=(VideoMediaDeviceSession)dev.getSession();
  DataSource ds=session.getCaptureDevice();
  if (ds instanceof MutePullBufferDataSource) {
    MutePullBufferDataSource ds2=(MutePullBufferDataSource)ds;
    ds=ds2.getWrappedDataSource();
  }
  ScreenDevice screen=getScreenForPoint(new Point(x,y));
  ScreenDevice currentScreen=screen;
  if (x < 0) {
    x+=screen.getSize().width;
  }
 else   if (x > screen.getSize().width) {
    List<ScreenDevice> devs=getAvailableScreenDevices();
    if (screen.getIndex() > 0) {
      screen=devs.get(screen.getIndex() - 1);
    }
    x-=screen.getSize().width;
  }
  if (y < 0) {
    y+=screen.getSize().height;
  }
 else   if (y > screen.getSize().height) {
    List<ScreenDevice> devs=getAvailableScreenDevices();
    if (screen.getIndex() > 0) {
      screen=devs.get(screen.getIndex() - 1);
    }
    y-=screen.getSize().height;
  }
  ((net.java.sip.communicator.impl.neomedia.jmfext.media.protocol.imgstreaming.DataSource)ds).setOrigin(0,currentScreen.getIndex(),x,y);
}","/** 
 * Move origin of a partial desktop streaming <tt>MediaDevice</tt>.
 * @param mediaDevice desktop streaming <tt>MediaDevice</tt> obtained bygetMediaDeviceForPartialDesktopStreaming() method.
 * @param x new x coordinate origin
 * @param y new y coordinate origin
 */
public void movePartialDesktopStreaming(MediaDevice mediaDevice,int x,int y){
  MediaDeviceImpl dev=(MediaDeviceImpl)mediaDevice;
  if (!dev.getCaptureDeviceInfo().getLocator().getProtocol().equals(ImageStreamingAuto.LOCATOR_PROTOCOL)) {
    return;
  }
  VideoMediaDeviceSession session=(VideoMediaDeviceSession)dev.getSession();
  DataSource ds=session.getCaptureDevice();
  if (ds instanceof MutePullBufferDataSource) {
    MutePullBufferDataSource ds2=(MutePullBufferDataSource)ds;
    ds=ds2.getWrappedDataSource();
  }
  ScreenDevice screen=getScreenForPoint(new Point(x,y));
  ScreenDevice currentScreen=screen;
  if (screen == null) {
    return;
  }
  Rectangle bounds=((ScreenDeviceImpl)screen).getBounds();
  x-=bounds.x;
  y-=bounds.y;
  ((net.java.sip.communicator.impl.neomedia.jmfext.media.protocol.imgstreaming.DataSource)ds).setOrigin(0,currentScreen.getIndex(),x,y);
}",0.7756598240469208
103426,"/** 
 * Get a <tt>MediaDevice</tt> for a part of desktop streaming/sharing.
 * @param mediaDevice original desktop streaming <tt>MediaDevice</tt>
 * @param width width of the part
 * @param height height of the part
 * @param x origin of the x coordinate (relative to the full desktop)
 * @param y origin of the y coordinate (relative to the full desktop)
 * @return <tt>MediaDevice</tt> representing the part of desktop or nullif problem
 */
public MediaDevice getMediaDeviceForPartialDesktopStreaming(int width,int height,int x,int y){
  MediaDevice device=null;
  String name=""String_Node_Str"";
  Dimension size=null;
  int multiple=0;
  Point p=new Point(x,y);
  ScreenDevice dev=getScreenForPoint(p);
  int display=-1;
  if (dev != null) {
    display=dev.getIndex();
  }
 else {
    return null;
  }
  if (OSUtils.IS_MAC) {
    multiple=Math.round(width / 16f);
    width=multiple * 16;
  }
 else {
    multiple=Math.round(width / 2f);
    width=multiple * 2;
  }
  multiple=Math.round(height / 2f);
  height=multiple * 2;
  size=new Dimension(width,height);
  Format formats[]=new Format[]{new AVFrameFormat(size,Format.NOT_SPECIFIED,FFmpeg.PIX_FMT_ARGB,Format.NOT_SPECIFIED),new RGBFormat(size,Format.NOT_SPECIFIED,Format.byteArray,Format.NOT_SPECIFIED,32,2,3,4)};
  if (x < 0) {
    x+=dev.getSize().width;
  }
 else   if (x > dev.getSize().width) {
    List<ScreenDevice> devs=getAvailableScreenDevices();
    if (dev.getIndex() > 0) {
      dev=devs.get(dev.getIndex() - 1);
    }
    x-=dev.getSize().width;
  }
  if (y < 0) {
    y+=dev.getSize().height;
  }
 else   if (y > dev.getSize().height) {
    List<ScreenDevice> devs=getAvailableScreenDevices();
    if (dev.getIndex() > 0) {
      dev=devs.get(dev.getIndex() - 1);
    }
    y-=dev.getSize().height;
  }
  CaptureDeviceInfo devInfo=new CaptureDeviceInfo(name + ""String_Node_Str"" + display,new MediaLocator(ImageStreamingAuto.LOCATOR_PROTOCOL + ""String_Node_Str"" + display+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y),formats);
  device=new MediaDeviceImpl(devInfo,MediaType.VIDEO);
  return device;
}","/** 
 * Get a <tt>MediaDevice</tt> for a part of desktop streaming/sharing.
 * @param mediaDevice original desktop streaming <tt>MediaDevice</tt>
 * @param width width of the part
 * @param height height of the part
 * @param x origin of the x coordinate (relative to the full desktop)
 * @param y origin of the y coordinate (relative to the full desktop)
 * @return <tt>MediaDevice</tt> representing the part of desktop or nullif problem
 */
public MediaDevice getMediaDeviceForPartialDesktopStreaming(int width,int height,int x,int y){
  MediaDevice device=null;
  String name=""String_Node_Str"";
  Dimension size=null;
  int multiple=0;
  Point p=new Point(x,y);
  ScreenDevice dev=getScreenForPoint(p);
  int display=-1;
  if (dev != null) {
    display=dev.getIndex();
  }
 else {
    return null;
  }
  if (OSUtils.IS_MAC) {
    multiple=Math.round(width / 16f);
    width=multiple * 16;
  }
 else {
    multiple=Math.round(width / 2f);
    width=multiple * 2;
  }
  multiple=Math.round(height / 2f);
  height=multiple * 2;
  size=new Dimension(width,height);
  Format formats[]=new Format[]{new AVFrameFormat(size,Format.NOT_SPECIFIED,FFmpeg.PIX_FMT_ARGB,Format.NOT_SPECIFIED),new RGBFormat(size,Format.NOT_SPECIFIED,Format.byteArray,Format.NOT_SPECIFIED,32,2,3,4)};
  Rectangle bounds=((ScreenDeviceImpl)dev).getBounds();
  x-=bounds.x;
  y-=bounds.y;
  CaptureDeviceInfo devInfo=new CaptureDeviceInfo(name + ""String_Node_Str"" + display,new MediaLocator(ImageStreamingAuto.LOCATOR_PROTOCOL + ""String_Node_Str"" + display+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y),formats);
  device=new MediaDeviceImpl(devInfo,MediaType.VIDEO);
  return device;
}",0.8522392062215071
103427,"/** 
 * If the screen contains specified point.
 * @param p point coordinate
 * @return true if point belongs to screen, false otherwise
 */
public boolean containsPoint(Point p){
  GraphicsConfiguration configs[]=screen.getConfigurations();
  for (  GraphicsConfiguration config : configs) {
    Rectangle bounds=config.getBounds();
    if (bounds.contains(p)) {
      return true;
    }
  }
  return false;
}","/** 
 * If the screen contains specified point.
 * @param p point coordinate
 * @return true if point belongs to screen, false otherwise
 */
public boolean containsPoint(Point p){
  GraphicsConfiguration config=screen.getDefaultConfiguration();
  Rectangle bounds=config.getBounds();
  if (bounds.contains(p)) {
    return true;
  }
  return false;
}",0.6736842105263158
103428,"/** 
 * Reloads icon.
 */
public void loadSkin(){
  if (type == WARNING) {
    iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.WARNING_ICON)));
  }
 else {
    iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ERROR_ICON)));
  }
}","/** 
 * Reloads icon.
 */
public void loadSkin(){
  ImageID icon=(type == WARNING) ? ImageLoader.WARNING_ICON : ImageLoader.ERROR_ICON;
  iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(icon)));
}",0.5226781857451404
103429,"/** 
 * Creates an instance of <tt>MessageDialog</tt> by specifying the owner window and the message to be displayed.
 * @param owner the dialog owner
 * @param title the title of the error dialog
 * @param message the message to be displayed
 * @param type the dialog type
 */
public ErrorDialog(Frame owner,String title,String message,int type){
  this(owner,title,message);
  if (type == WARNING) {
    iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.WARNING_ICON)));
    this.type=type;
  }
}","/** 
 * Initializes a new <tt>ErrorDialog</tt> with a specific owner <tt>Frame</tt>, title and message to be displayed and of a specific type.
 * @param owner the dialog owner
 * @param title the title of the error dialog
 * @param message the message to be displayed
 * @param type the dialog type
 */
public ErrorDialog(Frame owner,String title,String message,int type){
  this(owner,title,message);
  if (type == WARNING) {
    iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.WARNING_ICON)));
    this.type=type;
  }
}",0.8068506184586108
103430,"/** 
 * Update the ErrorDialog when the user clicks on the hyperlink.
 * @param e The event generated by the click on the hyperlink.
 */
public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    displayOrHideDetails();
  }
}","/** 
 * Update the ErrorDialog when the user clicks on the hyperlink.
 * @param e The event generated by the click on the hyperlink.
 */
public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)   showOrHideDetails();
}",0.9582577132486388
103431,"/** 
 * Implements <code>ApplicationWindow.show</code> method.
 * @param isVisible specifies whether the frame is to be visible or not.
 */
public void setVisible(boolean isVisible){
  if (isVisible && configList.getSelectedIndex() < 0) {
    this.configList.setSelectedIndex(0);
  }
  super.setVisible(isVisible);
}","/** 
 * Implements <code>ApplicationWindow.show</code> method.
 * @param isVisible specifies whether the frame is to be visible or not.
 */
@Override public void setVisible(boolean isVisible){
  if (isVisible && configList.getSelectedIndex() < 0) {
    this.configList.setSelectedIndex(0);
  }
  super.setVisible(isVisible);
}",0.9844236760124612
103432,"/** 
 * Handles registration of a new configuration form.
 * @param event the <tt>ServiceEvent</tt> that notified us
 */
public void serviceChanged(ServiceEvent event){
  Object sService=AdvancedConfigActivator.bundleContext.getService(event.getServiceReference());
  if (!(sService instanceof ConfigurationForm))   return;
  ConfigurationForm configForm=(ConfigurationForm)sService;
  if (!configForm.isAdvanced())   return;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
  this.addConfigForm(configForm);
break;
case ServiceEvent.UNREGISTERING:
this.removeConfigForm(configForm);
break;
}
}","/** 
 * Handles registration of a new configuration form.
 * @param event the <tt>ServiceEvent</tt> that notified us
 */
public void serviceChanged(ServiceEvent event){
  Object sService=AdvancedConfigActivator.bundleContext.getService(event.getServiceReference());
  if (!(sService instanceof ConfigurationForm))   return;
  ConfigurationForm configForm=(ConfigurationForm)sService;
  if ((configForm == this) || !configForm.isAdvanced())   return;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
  this.addConfigForm(configForm);
break;
case ServiceEvent.UNREGISTERING:
this.removeConfigForm(configForm);
break;
}
}",0.9824046920821116
103433,"/** 
 * Installs this UI to the given component.
 * @param c the component to which to install this UI
 */
public void installUI(JComponent c){
  if (c == null)   throw new NullPointerException(""String_Node_Str"");
  tree=(JTree)c;
  tree.addTreeSelectionListener(new TreeSelectionListener(){
    public void valueChanged(    TreeSelectionEvent e){
      layoutCache.invalidatePathBounds(e.getOldLeadSelectionPath());
      layoutCache.invalidatePathBounds(e.getNewLeadSelectionPath());
      updateSize();
      tree.repaint();
    }
  }
);
  tree.addHierarchyListener(new HierarchyListener(){
    public void hierarchyChanged(    HierarchyEvent e){
      if (e.getID() == HierarchyEvent.HIERARCHY_CHANGED && (e.getChangeFlags() & HierarchyEvent.PARENT_CHANGED) != 0 && e.getChangedParent() instanceof JViewport) {
        parentViewport=(JViewport)e.getChangedParent();
      }
    }
  }
);
  super.installUI(c);
}","/** 
 * Installs this UI to the given component.
 * @param c the component to which to install this UI
 */
public void installUI(JComponent c){
  if (c == null)   throw new NullPointerException(""String_Node_Str"");
  tree=(JTree)c;
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    public void valueChanged(    TreeSelectionEvent e){
      selectionChanged(e.getOldLeadSelectionPath(),e.getNewLeadSelectionPath());
    }
  }
);
  tree.addHierarchyListener(new HierarchyListener(){
    public void hierarchyChanged(    HierarchyEvent e){
      if (e.getID() == HierarchyEvent.HIERARCHY_CHANGED && (e.getChangeFlags() & HierarchyEvent.PARENT_CHANGED) != 0 && e.getChangedParent() instanceof JViewport) {
        parentViewport=(JViewport)e.getChangedParent();
      }
    }
  }
);
  super.installUI(c);
}",0.885208452312964
103434,"public void valueChanged(TreeSelectionEvent e){
  layoutCache.invalidatePathBounds(e.getOldLeadSelectionPath());
  layoutCache.invalidatePathBounds(e.getNewLeadSelectionPath());
  updateSize();
  tree.repaint();
}","public void valueChanged(TreeSelectionEvent e){
  selectionChanged(e.getOldLeadSelectionPath(),e.getNewLeadSelectionPath());
}",0.6666666666666666
103435,"/** 
 * Creates an instance of <tt>ContactListTreeModel</tt>.
 */
public ContactListTreeModel(){
  super(null);
  RootUIGroup rootDescriptor=new RootUIGroup();
  rootGroupNode=new GroupNode(this,rootDescriptor);
  rootDescriptor.setGroupNode(rootGroupNode);
  this.setRoot(rootGroupNode);
}","/** 
 * Creates an instance of <tt>ContactListTreeModel</tt>.
 * @param tree the parent tree
 */
public ContactListTreeModel(JTree tree){
  super(null);
  this.parentTree=tree;
  RootUIGroup rootDescriptor=new RootUIGroup();
  rootGroupNode=new GroupNode(this,rootDescriptor);
  rootDescriptor.setGroupNode(rootGroupNode);
  this.setRoot(rootGroupNode);
}",0.8992248062015504
103436,"/** 
 * Removes the node corresponding to the given <tt>uiContact</tt> from this group.
 * @param uiContact the <tt>UIContact</tt> to remove
 */
public void removeContact(UIContact uiContact){
  final ContactNode contactNode=uiContact.getContactNode();
  if (contactNode != null) {
    int index=getIndex(contactNode);
    children.removeElementAt(index);
    contactNode.setParent(null);
    uiContact.setContactNode(null);
    uiContact=null;
    fireNodeRemoved(contactNode,index);
  }
}","/** 
 * Removes the node corresponding to the given <tt>uiContact</tt> from this group.
 * @param uiContact the <tt>UIContact</tt> to remove
 */
public void removeContact(UIContact uiContact){
  final ContactNode contactNode=uiContact.getContactNode();
  if (contactNode != null) {
    int index=getIndex(contactNode);
    int selectedIndex=getLeadSelectionRow();
    children.removeElementAt(index);
    contactNode.setParent(null);
    uiContact.setContactNode(null);
    uiContact=null;
    fireNodeRemoved(contactNode,index);
    refreshSelection(selectedIndex,getLeadSelectionRow());
  }
}",0.904059040590406
103437,"/** 
 * Removes the node corresponding to the given <tt>uiGroup</tt> from this group node.
 * @param uiGroup the <tt>UIGroup</tt> to remove
 */
public void removeContactGroup(UIGroup uiGroup){
  GroupNode groupNode=uiGroup.getGroupNode();
  if (groupNode != null) {
    int index=getIndex(groupNode);
    children.removeElementAt(index);
    groupNode.setParent(null);
    uiGroup.setGroupNode(null);
    fireNodeRemoved(groupNode,index);
  }
}","/** 
 * Removes the node corresponding to the given <tt>uiGroup</tt> from this group node.
 * @param uiGroup the <tt>UIGroup</tt> to remove
 */
public void removeContactGroup(UIGroup uiGroup){
  GroupNode groupNode=uiGroup.getGroupNode();
  if (groupNode != null) {
    int index=getIndex(groupNode);
    int selectedIndex=getLeadSelectionRow();
    children.removeElementAt(index);
    groupNode.setParent(null);
    uiGroup.setGroupNode(null);
    fireNodeRemoved(groupNode,index);
    refreshSelection(selectedIndex,getLeadSelectionRow());
  }
}",0.8951612903225806
103438,"public void run(){
  Collections.sort(children,nodeComparator);
  fireNodesChanged();
}","public void run(){
  TreePath selectionPath=getLeadSelectionPath();
  int oldSelectionIndex=getLeadSelectionRow();
  Collections.sort(children,nodeComparator);
  fireNodesChanged();
  treeModel.getParentTree().setSelectionPath(selectionPath);
  refreshSelection(oldSelectionIndex,getLeadSelectionRow());
}",0.4438775510204081
103439,"/** 
 * Creates a <tt>ContactNode</tt> for the given <tt>uiContact</tt> and adds it to this group.
 * @param uiContact the <tt>UIContact</tt> to add
 * @return the created <tt>ContactNode</tt>
 */
public ContactNode addContact(UIContact uiContact){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
  ContactNode contactNode=new ContactNode(uiContact);
  uiContact.setContactNode(contactNode);
  add(contactNode);
  int contactIndex=getIndex(contactNode);
  if (contactIndex > -1)   fireNodeInserted(contactIndex);
  return contactNode;
}","/** 
 * Creates a <tt>ContactNode</tt> for the given <tt>uiContact</tt> and adds it to this group.
 * @param uiContact the <tt>UIContact</tt> to add
 * @return the created <tt>ContactNode</tt>
 */
public ContactNode addContact(UIContact uiContact){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + uiContact.getDisplayName());
  int selectedIndex=getLeadSelectionRow();
  ContactNode contactNode=new ContactNode(uiContact);
  uiContact.setContactNode(contactNode);
  add(contactNode);
  int contactIndex=getIndex(contactNode);
  if (contactIndex > -1)   fireNodeInserted(contactIndex);
  refreshSelection(selectedIndex,getLeadSelectionRow());
  return contactNode;
}",0.721958925750395
103440,"/** 
 * Sorts the children of this node.
 * @param treeModel the <tt>ContactListTreeModel</tt>, which should berefreshed
 */
@SuppressWarnings(""String_Node_Str"") public void sort(ContactListTreeModel treeModel){
  if (children != null) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        Collections.sort(children,nodeComparator);
        fireNodesChanged();
      }
    }
);
  }
}","/** 
 * Sorts the children of this node.
 * @param treeModel the <tt>ContactListTreeModel</tt>, which should berefreshed
 */
@SuppressWarnings(""String_Node_Str"") public void sort(final ContactListTreeModel treeModel){
  if (children != null) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        TreePath selectionPath=getLeadSelectionPath();
        int oldSelectionIndex=getLeadSelectionRow();
        Collections.sort(children,nodeComparator);
        fireNodesChanged();
        treeModel.getParentTree().setSelectionPath(selectionPath);
        refreshSelection(oldSelectionIndex,getLeadSelectionRow());
      }
    }
);
  }
}",0.7682242990654206
103441,"/** 
 * Creates a <tt>GroupNode</tt> for the given <tt>uiGroup</tt> and adds it to this group.
 * @param uiGroup the <tt>UIGroup</tt> to add
 * @return the created <tt>GroupNode</tt>
 */
public GroupNode addContactGroup(UIGroup uiGroup){
  GroupNode groupNode=new GroupNode(treeModel,uiGroup);
  uiGroup.setGroupNode(groupNode);
  add(groupNode);
  int groupIndex=getIndex(groupNode);
  if (groupIndex > -1)   fireNodeInserted(groupIndex);
  return groupNode;
}","/** 
 * Creates a <tt>GroupNode</tt> for the given <tt>uiGroup</tt> and adds it to this group.
 * @param uiGroup the <tt>UIGroup</tt> to add
 * @return the created <tt>GroupNode</tt>
 */
public GroupNode addContactGroup(UIGroup uiGroup){
  int selectedIndex=getLeadSelectionRow();
  GroupNode groupNode=new GroupNode(treeModel,uiGroup);
  uiGroup.setGroupNode(groupNode);
  add(groupNode);
  int groupIndex=getIndex(groupNode);
  if (groupIndex > -1)   fireNodeInserted(groupIndex);
  refreshSelection(selectedIndex,getLeadSelectionRow());
  return groupNode;
}",0.6712328767123288
103442,"/** 
 * Creates the <tt>TreeContactList</tt>.
 */
public TreeContactList(){
  originalMouseListeners=this.getMouseListeners();
  for (  MouseListener listener : originalMouseListeners)   this.removeMouseListener(listener);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addTreeExpansionListener(this);
  GuiActivator.getContactListService().addMetaContactListListener(this);
  treeModel=new ContactListTreeModel();
  setTreeModel(treeModel);
  if (isRootVisible())   setRootVisible(false);
  this.initKeyActions();
  this.initContactSources();
}","/** 
 * Creates the <tt>TreeContactList</tt>.
 */
public TreeContactList(){
  originalMouseListeners=this.getMouseListeners();
  for (  MouseListener listener : originalMouseListeners)   this.removeMouseListener(listener);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addTreeExpansionListener(this);
  GuiActivator.getContactListService().addMetaContactListListener(this);
  treeModel=new ContactListTreeModel(this);
  setTreeModel(treeModel);
  if (isRootVisible())   setRootVisible(false);
  this.initKeyActions();
  this.initContactSources();
}",0.9965217391304348
103443,"/** 
 * Indicates that a change has occurred in the status of the source <tt>CallPeer</tt>.
 * @param evt the <tt>CallPeerChangeEvent</tt> instance containing thesource event as well as its previous and its new status
 */
@Override public void peerStateChanged(CallPeerChangeEvent evt){
  CallPeer peer=evt.getSourceCallPeer();
  CallPeerState state=peer.getState();
  if (remoteControlEnabled && state != null && (state.equals(CallPeerState.DISCONNECTED) || state.equals(CallPeerState.FAILED))) {
    disableRemoteControl(evt.getSourceCallPeer());
  }
 else   if (state != null && state.equals(CallPeerState.CONNECTED)) {
    enableRemoteControl(evt.getSourceCallPeer());
  }
}","/** 
 * Indicates that a change has occurred in the status of the source <tt>CallPeer</tt>.
 * @param evt the <tt>CallPeerChangeEvent</tt> instance containing thesource event as well as its previous and its new status
 */
@Override public void peerStateChanged(CallPeerChangeEvent evt){
  CallPeer peer=evt.getSourceCallPeer();
  CallPeerState state=peer.getState();
  if (remoteControlEnabled && state != null && (state.equals(CallPeerState.DISCONNECTED) || state.equals(CallPeerState.FAILED))) {
    disableRemoteControl(evt.getSourceCallPeer());
  }
}",0.8993506493506493
103444,"/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
protected Call createOutgoingVideoCall(String calleeAddress) throws OperationFailedException {
  boolean supported=false;
  String fullCalleeURI=null;
  if (calleeAddress.indexOf('/') > 0) {
    fullCalleeURI=calleeAddress;
  }
 else {
    fullCalleeURI=parentProvider.getConnection().getRoster().getPresence(calleeAddress).getFrom();
  }
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  DiscoverInfo di=null;
  try {
    di=parentProvider.getDiscoveryManager().discoverInfo(fullCalleeURI);
    if (di.containsFeature(InputEvtIQ.NAMESPACE)) {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
      supported=true;
    }
 else {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
    }
  }
 catch (  XMPPException ex) {
    logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
  }
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  call.setLocalVideoAllowed(true,getMediaUseCase());
  call.setLocalInputEvtAware(supported);
  basicTelephony.createOutgoingCall(call,calleeAddress);
  return call;
}","/** 
 * Check if the remote part supports Jingle video.
 * @param calleeAddress Contact address
 * @param videoDevice specific video device to use (null to use defaultdevice)
 * @return true if contact support Jingle video, false otherwise
 * @throws OperationFailedException with the corresponding code if we failto create the video call.
 */
@Override protected Call createOutgoingVideoCall(String calleeAddress,MediaDevice videoDevice) throws OperationFailedException {
  boolean supported=false;
  String fullCalleeURI=null;
  if (calleeAddress.indexOf('/') > 0) {
    fullCalleeURI=calleeAddress;
  }
 else {
    fullCalleeURI=parentProvider.getConnection().getRoster().getPresence(calleeAddress).getFrom();
  }
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  DiscoverInfo di=null;
  try {
    di=parentProvider.getDiscoveryManager().discoverInfo(fullCalleeURI);
    if (di.containsFeature(InputEvtIQ.NAMESPACE)) {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
      supported=true;
    }
 else {
      if (logger.isInfoEnabled())       logger.info(fullCalleeURI + ""String_Node_Str"");
    }
  }
 catch (  XMPPException ex) {
    logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
  }
  if (parentProvider.getConnection() == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallJabberImpl call=new CallJabberImpl(basicTelephony);
  if (videoDevice != null) {
    call.setVideoDevice(videoDevice);
  }
  call.setLocalVideoAllowed(true,getMediaUseCase());
  call.setLocalInputEvtAware(supported);
  basicTelephony.createOutgoingCall(call,calleeAddress);
  return call;
}",0.9433497536945812
103445,"/** 
 * Disable desktop remote control. Local desktop stop regenerates keyboard and mouse events received from peer.
 * @param callPeer call peer that will stop controlling on local computer
 */
public void disableRemoteControl(CallPeer callPeer){
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  remoteControlEnabled=false;
  if (callPeers.contains(callPeer.getAddress())) {
    callPeers.remove(callPeer.getAddress());
  }
}","/** 
 * Disable desktop remote control. Local desktop stops regenerate keyboard and mouse events received from peer.
 * @param callPeer call peer that will stop controlling on local computer
 */
public void disableRemoteControl(CallPeer callPeer){
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  remoteControlEnabled=false;
  if (callPeers.contains(callPeer.getAddress())) {
    callPeers.remove(callPeer.getAddress());
  }
}",0.9729119638826184
103446,"/** 
 * Notifies this <tt>MethodProcessorListener</tt> that a specific <tt>CallPeer</tt> has processed a specific SIP <tt>Response</tt> and has replied to it with a specific SIP <tt>Request</tt>.
 * @param sourceCallPeer the <tt>CallPeer</tt> which has processed thespecified SIP <tt>Response</tt>
 * @param response the SIP <tt>Response</tt> which has been processed by<tt>sourceCallPeer</tt>
 * @param request the SIP <tt>Request</tt> sent by <tt>sourceCallPeer</tt>as a reply to the specified SIP <tt>response</tt>
 * @see MethodProcessorListener#responseProcessed(CallPeerSipImpl,Response,Request)
 */
public void responseProcessed(CallPeerSipImpl sourceCallPeer,Response response,Request request){
  if (Response.OK == response.getStatusCode()) {
    CSeqHeader cseqHeader=(CSeqHeader)response.getHeader(CSeqHeader.NAME);
    if ((cseqHeader != null) && Request.INVITE.equalsIgnoreCase(cseqHeader.getMethod())) {
      enableRemoteControl(sourceCallPeer);
    }
  }
}","/** 
 * Notifies this <tt>MethodProcessorListener</tt> that a specific <tt>CallPeer</tt> has processed a specific SIP <tt>Response</tt> and has replied to it with a specific SIP <tt>Request</tt>.
 * @param sourceCallPeer the <tt>CallPeer</tt> which has processed thespecified SIP <tt>Response</tt>
 * @param response the SIP <tt>Response</tt> which has been processed by<tt>sourceCallPeer</tt>
 * @param request the SIP <tt>Request</tt> sent by <tt>sourceCallPeer</tt>as a reply to the specified SIP <tt>response</tt>
 * @see MethodProcessorListener#responseProcessed(CallPeerSipImpl,Response,Request)
 */
public void responseProcessed(CallPeerSipImpl sourceCallPeer,Response response,Request request){
  if (Response.OK == response.getStatusCode()) {
    CSeqHeader cseqHeader=(CSeqHeader)response.getHeader(CSeqHeader.NAME);
    if ((cseqHeader != null) && Request.INVITE.equalsIgnoreCase(cseqHeader.getMethod())) {
    }
  }
}",0.9773803261441346
103447,"/** 
 * Sends this collector's query to the default resolver.
 */
public void run(){
  Message localResponse=null;
  try {
    localResponse=defaultResolver.send(query);
  }
 catch (  Throwable exc) {
    this.exception=exc;
  }
synchronized (this) {
    if (done)     return;
    response=localResponse;
    done=true;
    notify();
  }
}","/** 
 * Sends this collector's query to the default resolver.
 */
public void run(){
  Message localResponse=null;
  try {
    localResponse=defaultResolver.send(query);
  }
 catch (  Throwable exc) {
    logger.info(""String_Node_Str"" + exc);
    this.exception=exc;
  }
synchronized (this) {
    if (done)     return;
    response=localResponse;
    done=true;
    notify();
  }
}",0.9111111111111112
103448,"/** 
 * Asynchronously sends this collector's query to all backup resolvers.
 */
public void sendBackupQueries(){
synchronized (this) {
    for (    Resolver resolver : backupResolvers) {
      if (done)       return;
      resolver.sendAsync(query,this);
    }
  }
}","/** 
 * Asynchronously sends this collector's query to all backup resolvers.
 */
public void sendBackupQueries(){
  logger.info(""String_Node_Str"");
synchronized (this) {
    for (    Resolver resolver : backupResolvers) {
      if (done)       return;
      resolver.sendAsync(query,this);
    }
  }
}",0.9401408450704224
103449,"/** 
 * Waits for resolution to complete (if necessary) and then either returns the response we received or throws whatever exception we saw.
 * @return the response {@link Message} we received from the DNS.
 * @throws IOException if this resolution ended badly because of anetwork IO error
 * @throws RuntimeException if something unexpected happenedduring resolution.
 * @throws IllegalArgumentException if something unexpected happenedduring resolution.
 */
public Message returnResponseOrThrowUp() throws IOException, RuntimeException, IllegalArgumentException {
  if (!done)   waitForResponse(0);
  if (response != null)   return response;
 else   if (exception instanceof IOException)   throw (IOException)exception;
 else   if (exception instanceof RuntimeException)   throw (RuntimeException)exception;
 else   if (exception instanceof Error)   throw (Error)exception;
 else   throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Waits for resolution to complete (if necessary) and then either returns the response we received or throws whatever exception we saw.
 * @return the response {@link Message} we received from the DNS.
 * @throws IOException if this resolution ended badly because of anetwork IO error
 * @throws RuntimeException if something unexpected happenedduring resolution.
 * @throws IllegalArgumentException if something unexpected happenedduring resolution.
 */
public Message returnResponseOrThrowUp() throws IOException, RuntimeException, IllegalArgumentException {
  if (!done)   waitForResponse(0);
  if (response != null)   return response;
 else   if (exception instanceof IOException) {
    logger.warn(""String_Node_Str"",exception);
    throw (IOException)exception;
  }
 else   if (exception instanceof RuntimeException) {
    logger.warn(""String_Node_Str"",exception);
    throw (RuntimeException)exception;
  }
 else   if (exception instanceof Error) {
    logger.warn(""String_Node_Str"",exception);
    throw (Error)exception;
  }
 else {
    logger.warn(""String_Node_Str"",exception);
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.7619502868068834
103450,"/** 
 * Create a new call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to anew call.
 * @return CallPeer the CallPeer that will represented bythe specified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if wefail to create the call.
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createCall(callee.getAddress());
}","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>Contact</tt>.
 * @param callee the address of the callee who we should invite to a newcall
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 * @see OperationSetBasicTelephony#createCall(Contact)
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createCall(callee.getAddress());
}",0.4087591240875912
103451,"/** 
 * Create a new call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to anew call.
 * @return CallPeer the CallPeer that will represented bythe specified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createCall(callee.getAddress());
}","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>Contact</tt>.
 * @param callee the address of the callee who we should invite to a newcall
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 * @see OperationSetBasicTelephony#createCall(Contact)
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createCall(callee.getAddress());
}",0.4395782643957826
103452,"/** 
 * Create a new call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to anew call.
 * @return CallPeer the CallPeer that will represented bythe specified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if wefail to create the call.
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createNewCall(callee.getAddress());
}","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>Contact</tt>.
 * @param callee the address of the callee who we should invite to a newcall
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 * @see OperationSetBasicTelephony#createCall(Contact)
 */
public Call createCall(Contact callee) throws OperationFailedException {
  return createNewCall(callee.getAddress());
}",0.4116222760290557
103453,"/** 
 * Create a new call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by the specified URI.All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
public Call createCall(Contact callee) throws OperationFailedException {
  Address toAddress;
  try {
    toAddress=protocolProvider.parseAddressString(callee.getAddress());
  }
 catch (  ParseException ex) {
    logger.error(ex.getMessage(),ex);
    throw new IllegalArgumentException(ex.getMessage());
  }
  return createOutgoingCall(toAddress,null);
}","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>Contact</tt>.
 * @param callee the address of the callee who we should invite to a newcall
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 * @see OperationSetBasicTelephony#createCall(Contact)
 */
public Call createCall(Contact callee) throws OperationFailedException {
  Address toAddress;
  try {
    toAddress=protocolProvider.parseAddressString(callee.getAddress());
  }
 catch (  ParseException ex) {
    logger.error(ex.getMessage(),ex);
    throw new IllegalArgumentException(ex.getMessage());
  }
  return createOutgoingCall(toAddress,null);
}",0.5944997074312464
103454,"/** 
 * Create a new call and invite the specified CallPeer to it.
 * @param callee the address of the callee that we should invite to a newcall.
 * @return CallPeer the CallPeer that will represented by thespecified uri. All following state change events will be delivered through that call peer. The Call that this peer is a member of could be retrieved from the CallParticipatn instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
public Call createCall(Contact callee) throws OperationFailedException ;","/** 
 * Creates a new <tt>Call</tt> and invites a specific <tt>CallPeer</tt> to it given by her <tt>Contact</tt>.
 * @param callee the address of the callee who we should invite to a newcall
 * @return a newly created <tt>Call</tt>. The specified <tt>callee</tt> isavailable in the <tt>Call</tt> as a <tt>CallPeer</tt>
 * @throws OperationFailedException with the corresponding code if we failto create the call
 */
public Call createCall(Contact callee) throws OperationFailedException ;",0.418348623853211
103455,"/** 
 * Creates an instance of <tt>ChatConversationPanel</tt>.
 * @param chatContainer The parent <tt>ChatConversationContainer</tt>.
 */
public ChatConversationPanel(ChatConversationContainer chatContainer){
  editorKit=new SIPCommHTMLEditorKit(this);
  this.chatContainer=chatContainer;
  isHistory=(chatContainer instanceof HistoryWindow);
  this.rightButtonMenu=new ChatRightButtonMenu(this);
  this.document=(HTMLDocument)editorKit.createDefaultDocument();
  this.chatTextPane.setEditorKitForContentType(""String_Node_Str"",editorKit);
  this.chatTextPane.setEditorKit(editorKit);
  this.chatTextPane.setEditable(false);
  this.chatTextPane.setDocument(document);
  this.chatTextPane.setDragEnabled(true);
  chatTextPane.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,Boolean.TRUE);
  Constants.loadSimpleStyle(document.getStyleSheet(),chatTextPane.getFont());
  this.chatTextPane.addHyperlinkListener(this);
  this.chatTextPane.addMouseListener(this);
  this.chatTextPane.setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
  this.setWheelScrollingEnabled(true);
  JPanel viewportView=new TransparentPanel(new BorderLayout());
  viewportView.add(chatTextPane);
  this.setViewportView(viewportView);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  ToolTipManager.sharedInstance().registerComponent(chatTextPane);
  String copyLinkString=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  copyLinkItem=new JMenuItem(copyLinkString,new ImageIcon(ImageLoader.getImage(ImageLoader.COPY_ICON)));
  copyLinkItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StringSelection stringSelection=new StringSelection(currentHref);
      Clipboard clipboard=Toolkit.getDefaultToolkit().getSystemClipboard();
      clipboard.setContents(stringSelection,ChatConversationPanel.this);
    }
  }
);
  String openLinkString=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  openLinkItem=new JMenuItem(openLinkString,new ImageIcon(ImageLoader.getImage(ImageLoader.BROWSER_ICON)));
  openLinkItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      GuiActivator.getBrowserLauncher().openURL(currentHref);
    }
  }
);
  openLinkItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  copyLinkItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  ComponentListener componentListener=new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
synchronized (scrollToBottomRunnable) {
        if (!scrollToBottomIsPending)         return;
        scrollToBottomIsPending=false;
        SwingUtilities.invokeLater(scrollToBottomRunnable);
      }
    }
  }
;
  viewportView.addComponentListener(componentListener);
  getViewport().addComponentListener(componentListener);
}","/** 
 * Creates an instance of <tt>ChatConversationPanel</tt>.
 * @param chatContainer The parent <tt>ChatConversationContainer</tt>.
 */
public ChatConversationPanel(ChatConversationContainer chatContainer){
  editorKit=new SIPCommHTMLEditorKit(this);
  this.chatContainer=chatContainer;
  isHistory=(chatContainer instanceof HistoryWindow);
  this.rightButtonMenu=new ChatRightButtonMenu(this);
  this.document=(HTMLDocument)editorKit.createDefaultDocument();
  this.chatTextPane.setEditorKitForContentType(""String_Node_Str"",editorKit);
  this.chatTextPane.setEditorKit(editorKit);
  this.chatTextPane.setEditable(false);
  this.chatTextPane.setDocument(document);
  this.chatTextPane.setDragEnabled(true);
  chatTextPane.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,Boolean.TRUE);
  Constants.loadSimpleStyle(document.getStyleSheet(),chatTextPane.getFont());
  this.chatTextPane.addHyperlinkListener(this);
  this.chatTextPane.addMouseListener(this);
  this.chatTextPane.setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
  this.setWheelScrollingEnabled(true);
  this.setViewportView(chatTextPane);
  this.setBorder(null);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  ToolTipManager.sharedInstance().registerComponent(chatTextPane);
  String copyLinkString=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  copyLinkItem=new JMenuItem(copyLinkString,new ImageIcon(ImageLoader.getImage(ImageLoader.COPY_ICON)));
  copyLinkItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StringSelection stringSelection=new StringSelection(currentHref);
      Clipboard clipboard=Toolkit.getDefaultToolkit().getSystemClipboard();
      clipboard.setContents(stringSelection,ChatConversationPanel.this);
    }
  }
);
  String openLinkString=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  openLinkItem=new JMenuItem(openLinkString,new ImageIcon(ImageLoader.getImage(ImageLoader.BROWSER_ICON)));
  openLinkItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      GuiActivator.getBrowserLauncher().openURL(currentHref);
    }
  }
);
  openLinkItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  copyLinkItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  ComponentListener componentListener=new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
synchronized (scrollToBottomRunnable) {
        if (!scrollToBottomIsPending)         return;
        scrollToBottomIsPending=false;
        SwingUtilities.invokeLater(scrollToBottomRunnable);
      }
    }
  }
;
  chatTextPane.addComponentListener(componentListener);
  getViewport().addComponentListener(componentListener);
}",0.9522980501392758
103456,"public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(JSplitPane.DIVIDER_LOCATION_PROPERTY)) {
    int dividerLocation=(Integer)evt.getNewValue();
    if (dividerLocation != autoDividerLocation) {
      int writeAreaSize=messagePane.getHeight() - dividerLocation - messagePane.getDividerSize();
      ConfigurationManager.setChatWriteAreaSize(writeAreaSize);
      writeMessagePanel.setPreferredSize(new Dimension((int)writeMessagePanel.getPreferredSize().getWidth(),writeAreaSize));
    }
  }
}","public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(JSplitPane.DIVIDER_LOCATION_PROPERTY)) {
    int dividerLocation=(Integer)evt.getNewValue();
    int writeAreaSize=messagePane.getHeight() - dividerLocation - messagePane.getDividerSize();
    ConfigurationManager.setChatWriteAreaSize(writeAreaSize);
  }
}",0.7880870561282932
103457,"/** 
 * Removes the typing notification message from the conversation panel.
 */
public void removeTypingNotification(){
  conversationPanel.removeTypingNotification();
}","/** 
 * Removes the typing notification message from the conversation panel.
 */
public void removeTypingNotification(){
  addTypingNotification(""String_Node_Str"");
}",0.875
103458,"/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatContainer The parent window of this chat panel.
 */
public ChatPanel(ChatContainer chatContainer){
  super(new BorderLayout());
  this.chatContainer=chatContainer;
  this.conversationPanel=new ChatConversationPanel(this);
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.conversationPanel.getChatTextPane().setTransferHandler(new ChatTransferHandler(this));
  this.writeMessagePanel=new ChatWritePanel(this);
  this.messagePane.setBorder(null);
  this.messagePane.setOpaque(false);
  this.messagePane.addPropertyChangeListener(new DividerLocationListener());
  this.messagePane.setDividerSize(3);
  this.messagePane.setResizeWeight(1.0D);
  this.messagePane.setBottomComponent(writeMessagePanel);
  this.add(messagePane,BorderLayout.CENTER);
  if (OSUtils.IS_MAC) {
    setOpaque(true);
    setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  }
  this.addComponentListener(new TabSelectionComponentListener());
}","/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatContainer The parent window of this chat panel.
 */
public ChatPanel(ChatContainer chatContainer){
  super(new BorderLayout());
  this.chatContainer=chatContainer;
  this.conversationPanel=new ChatConversationPanel(this);
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.conversationPanel.getChatTextPane().setTransferHandler(new ChatTransferHandler(this));
  topPanel.setBackground(Color.WHITE);
  topPanel.setBorder(BorderFactory.createMatteBorder(1,0,1,0,Color.GRAY));
  this.writeMessagePanel=new ChatWritePanel(this);
  this.messagePane.setBorder(null);
  this.messagePane.setOpaque(false);
  this.messagePane.addPropertyChangeListener(new DividerLocationListener());
  this.messagePane.setDividerSize(3);
  this.messagePane.setResizeWeight(1.0D);
  this.messagePane.setBottomComponent(writeMessagePanel);
  this.messagePane.setTopComponent(topPanel);
  this.add(messagePane,BorderLayout.CENTER);
  if (OSUtils.IS_MAC) {
    setOpaque(true);
    setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  }
  this.addComponentListener(new TabSelectionComponentListener());
}",0.9299474605954466
103459,"/** 
 * Sets the chat session to associate to this chat panel.
 * @param chatSession the chat session to associate to this chat panel
 */
public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if ((this.chatSession != null) && this.chatSession.isContactListSupported()) {
    messagePane.remove(conversationPanel);
    TransparentPanel rightPanel=new TransparentPanel(new BorderLayout(5,5));
    Dimension chatContactPanelSize=new Dimension(150,100);
    rightPanel.setMinimumSize(chatContactPanelSize);
    rightPanel.setPreferredSize(chatContactPanelSize);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    this.chatContactListPanel.setOpaque(false);
    topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    topSplitPane.setBorder(null);
    topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setOpaque(false);
    topSplitPane.setResizeWeight(1.0D);
    ChatTransport chatTransport=chatSession.getCurrentChatTransport();
    JLabel localUserLabel=new JLabel(chatTransport.getProtocolProvider().getAccountID().getDisplayName());
    localUserLabel.setFont(localUserLabel.getFont().deriveFont(Font.BOLD));
    rightPanel.add(localUserLabel,BorderLayout.NORTH);
    rightPanel.add(chatContactListPanel,BorderLayout.CENTER);
    topSplitPane.setLeftComponent(conversationPanel);
    topSplitPane.setRightComponent(rightPanel);
    messagePane.setTopComponent(topSplitPane);
  }
 else {
    if (topSplitPane != null) {
      if (chatContactListPanel != null) {
        topSplitPane.remove(chatContactListPanel);
        chatContactListPanel=null;
      }
      this.messagePane.remove(topSplitPane);
      topSplitPane=null;
    }
    this.messagePane.setTopComponent(conversationPanel);
  }
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      subjectPanel=null;
      this.revalidate();
      this.repaint();
    }
    writeMessagePanel.setTransportSelectorBoxVisible(true);
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    ConferenceChatSession confSession=(ConferenceChatSession)chatSession;
    writeMessagePanel.setTransportSelectorBoxVisible(false);
    confSession.addLocalUserRoleListener(this);
    confSession.addMemberRoleListener(this);
    subjectPanel=new ChatRoomSubjectPanel((ConferenceChatSession)chatSession);
    this.add(subjectPanel,BorderLayout.NORTH);
  }
  if (chatContactListPanel != null) {
    Iterator<ChatContact<?>> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext())     chatContactListPanel.addContact(chatParticipants.next());
  }
}","/** 
 * Sets the chat session to associate to this chat panel.
 * @param chatSession the chat session to associate to this chat panel
 */
public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if ((this.chatSession != null) && this.chatSession.isContactListSupported()) {
    topPanel.remove(conversationPanel);
    TransparentPanel rightPanel=new TransparentPanel(new BorderLayout(5,5));
    Dimension chatContactPanelSize=new Dimension(150,100);
    rightPanel.setMinimumSize(chatContactPanelSize);
    rightPanel.setPreferredSize(chatContactPanelSize);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    this.chatContactListPanel.setOpaque(false);
    topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    topSplitPane.setBorder(null);
    topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setOpaque(false);
    topSplitPane.setResizeWeight(1.0D);
    ChatTransport chatTransport=chatSession.getCurrentChatTransport();
    JLabel localUserLabel=new JLabel(chatTransport.getProtocolProvider().getAccountID().getDisplayName());
    localUserLabel.setFont(localUserLabel.getFont().deriveFont(Font.BOLD));
    rightPanel.add(localUserLabel,BorderLayout.NORTH);
    rightPanel.add(chatContactListPanel,BorderLayout.CENTER);
    topSplitPane.setLeftComponent(conversationPanel);
    topSplitPane.setRightComponent(rightPanel);
    topPanel.add(topSplitPane);
  }
 else {
    if (topSplitPane != null) {
      if (chatContactListPanel != null) {
        topSplitPane.remove(chatContactListPanel);
        chatContactListPanel=null;
      }
      this.messagePane.remove(topSplitPane);
      topSplitPane=null;
    }
    topPanel.add(conversationPanel);
  }
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      subjectPanel=null;
      this.revalidate();
      this.repaint();
    }
    writeMessagePanel.setTransportSelectorBoxVisible(true);
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    ConferenceChatSession confSession=(ConferenceChatSession)chatSession;
    writeMessagePanel.setTransportSelectorBoxVisible(false);
    confSession.addLocalUserRoleListener(this);
    confSession.addMemberRoleListener(this);
    subjectPanel=new ChatRoomSubjectPanel((ConferenceChatSession)chatSession);
    this.add(subjectPanel,BorderLayout.NORTH);
  }
  if (chatContactListPanel != null) {
    Iterator<ChatContact<?>> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext())     chatContactListPanel.addContact(chatParticipants.next());
  }
}",0.9828001375988992
103460,"/** 
 * Adds a typing notification message to the conversation panel.
 * @param typingNotification the typing notification string
 */
public void addTypingNotification(String typingNotification){
  conversationPanel.addTypingNotification(typingNotification);
}","/** 
 * Adds a typing notification message to the conversation panel.
 * @param typingNotification the typing notification to show
 */
public void addTypingNotification(String typingNotification){
  if (typingNotificationLabel == null) {
    typingNotificationLabel=new JLabel(typingNotification,typingIcon,SwingConstants.CENTER);
    typingNotificationLabel.setPreferredSize(new Dimension(500,20));
    typingNotificationLabel.setForeground(Color.GRAY);
    typingNotificationLabel.setFont(typingNotificationLabel.getFont().deriveFont(11f));
    typingNotificationLabel.setVerticalTextPosition(JLabel.BOTTOM);
    typingNotificationLabel.setHorizontalTextPosition(JLabel.LEFT);
    typingNotificationLabel.setIconTextGap(0);
    topPanel.add(typingNotificationLabel,BorderLayout.SOUTH);
  }
 else {
    typingNotificationLabel.setText(typingNotification);
    if (typingNotification != null && !typingNotification.equals(""String_Node_Str""))     typingNotificationLabel.setIcon(typingIcon);
 else     typingNotificationLabel.setIcon(null);
  }
  revalidate();
  repaint();
}",0.2953523238380809
103461,"public void setToolbarVisible(boolean isVisible){
  mainToolBar.setVisible(isVisible);
  contactPhotoPanel.setVisible(isVisible);
  revalidate();
  repaint();
}","/** 
 * Shows/hides the toolbar.
 * @param isVisible 
 */
public void setToolbarVisible(boolean isVisible){
  mainToolBar.setVisible(isVisible);
  contactPhotoPanel.setVisible(isVisible);
  revalidate();
  repaint();
}",0.8465608465608465
103462,"/** 
 * Packs the content of this call window.
 */
public void pack(){
  pack();
}","/** 
 * Packs the content of this call window.
 */
public void pack(){
  revalidate();
  repaint();
}",0.8743169398907104
103463,"/** 
 * Closes the given call panel.
 * @param callPanel the <tt>CallPanel</tt> to close
 */
public void close(CallPanel callPanel){
  if (this.callPanel.equals(callPanel))   dispose();
}","/** 
 * Hang ups the current call on close.
 * @param isEscaped indicates if the window was close by pressing the escapebutton
 */
protected void close(boolean isEscaped){
  if (!isEscaped) {
    callPanel.actionPerformedOnHangupButton();
  }
}",0.1531322505800464
103464,"/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hang up button.
 * @param event the <tt>CallEvent</tt>
 */
public void callEnded(CallEvent event){
  Call sourceCall=event.getSourceCall();
  stopAllSounds();
  NotificationManager.fireNotification(NotificationManager.HANG_UP);
  if (activeCalls.get(sourceCall) != null) {
    CallPanel callContainer=activeCalls.get(sourceCall);
    callContainer.getCallWindow().close(callContainer);
  }
}","/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hang up button.
 * @param event the <tt>CallEvent</tt>
 */
public void callEnded(CallEvent event){
  Call sourceCall=event.getSourceCall();
  stopAllSounds();
  NotificationManager.fireNotification(NotificationManager.HANG_UP);
  if (activeCalls.get(sourceCall) != null) {
    CallPanel callContainer=activeCalls.get(sourceCall);
    activeCalls.remove(sourceCall);
    callContainer.getCallWindow().closeWait(callContainer);
  }
}",0.963963963963964
103465,"/** 
 * Executes the action associated with the ""Hang up"" button which may be invoked by clicking the button in question or closing this dialog.
 */
private void actionPerformedOnHangupButton(){
  Call call=getCall();
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  if (call != null)   CallManager.hangupCall(call);
  callWindow.close(this);
}","/** 
 * Executes the action associated with the ""Hang up"" button which may be invoked by clicking the button in question or closing this dialog.
 */
public void actionPerformedOnHangupButton(){
  Call call=getCall();
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  if (call != null)   CallManager.hangupCall(call);
  callWindow.close(this);
}",0.9871645274212368
103466,"/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  if (!path.equals(getSelectionPath()) && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if (lastComponent instanceof ContactNode) {
    UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
    fireContactListEvent(uiContact,ContactListEvent.CONTACT_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiContact.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
    fireContactListEvent(uiGroup,ContactListEvent.GROUP_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiGroup.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
  dispatchEventToButtons(e);
}","/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  if (!path.equals(getSelectionPath()) && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if (lastComponent instanceof ContactNode) {
    UIContact uiContact=((ContactNode)lastComponent).getContactDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiContact.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    UIGroup uiGroup=((GroupNode)lastComponent).getGroupDescriptor();
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=uiGroup.getRightButtonMenu();
      openRightButtonMenu(e.getPoint());
    }
  }
  dispatchEventToButtons(e);
}",0.9527991218441272
103467,"/** 
 * Adds the given <tt>contact</tt> to this list.
 * @param query the <tt>ContactQuery</tt> that adds the given contact
 * @param contact the <tt>UIContact</tt> to add
 * @param group the <tt>UIGroup</tt> to add to
 * @param isSorted indicates if the contact should be sorted regarding tothe <tt>GroupNode</tt> policy
 */
private void addContact(final ContactQuery query,final UIContact contact,final UIGroup group,final boolean isSorted){
  if (!SwingUtilities.isEventDispatchThread()) {
    LowPriorityEventQueue.invokeLater(new Runnable(){
      public void run(){
        if (query != null && query.getStatus() != ContactQuery.QUERY_CANCELED)         addContact(contact,group,isSorted);
      }
    }
);
    return;
  }
}","/** 
 * Adds the given <tt>contact</tt> to this list.
 * @param query the <tt>ContactQuery</tt> that adds the given contact
 * @param contact the <tt>UIContact</tt> to add
 * @param group the <tt>UIGroup</tt> to add to
 * @param isSorted indicates if the contact should be sorted regarding tothe <tt>GroupNode</tt> policy
 */
private void addContact(final ContactQuery query,final UIContact contact,final UIGroup group,final boolean isSorted){
  if (!SwingUtilities.isEventDispatchThread()) {
    LowPriorityEventQueue.invokeLater(new Runnable(){
      public void run(){
        if (query != null && currentFilterQuery.containsQuery(query)) {
          addContact(contact,group,isSorted);
        }
      }
    }
);
    return;
  }
}",0.936431989063568
103468,"/** 
 * Returns a list of all currently registered telephony providers.
 * @return a list of all currently registered telephony providers
 */
public static List<ProtocolProviderService> getTelephonyProviders(){
  List<ProtocolProviderService> telephonyProviders=new LinkedList<ProtocolProviderService>();
  for (  ProtocolProviderFactory providerFactory : GuiActivator.getProtocolProviderFactories().values()) {
    ServiceReference serRef;
    ProtocolProviderService protocolProvider;
    for (    AccountID accountID : providerFactory.getRegisteredAccounts()) {
      serRef=providerFactory.getProviderForAccount(accountID);
      protocolProvider=(ProtocolProviderService)GuiActivator.bundleContext.getService(serRef);
      if (protocolProvider.getOperationSet(OperationSetBasicTelephony.class) != null && protocolProvider.isRegistered()) {
        telephonyProviders.add(protocolProvider);
      }
    }
  }
  return telephonyProviders;
}","/** 
 * Returns a list of all currently registered telephony providers.
 * @return a list of all currently registered telephony providers
 */
public static List<ProtocolProviderService> getTelephonyProviders(){
  return GuiActivator.getRegisteredProviders(OperationSetBasicTelephony.class);
}",0.3543689320388349
103469,"/** 
 * Calls the given treeNode.
 * @param treeNode the <tt>TreeNode</tt> to call
 */
private void call(TreeNode treeNode){
  List<UIContactDetail> telephonyContacts=((ContactNode)treeNode).getContactDescriptor().getContactDetailsForOperationSet(OperationSetBasicTelephony.class);
  ChooseCallAccountPopupMenu chooseAccountDialog=null;
  if (telephonyContacts.size() == 1) {
    UIContactDetail detail=telephonyContacts.get(0);
    ProtocolProviderService preferredProvider=detail.getPreferredProtocolProvider(OperationSetBasicTelephony.class);
    List<ProtocolProviderService> providers=null;
    String protocolName=null;
    if (preferredProvider != null) {
      if (preferredProvider.isRegistered())       CallManager.createCall(preferredProvider,detail.getAddress());
 else {
        protocolName=preferredProvider.getProtocolName();
        providers=CallManager.getRegisteredProviders(protocolName,OperationSetBasicTelephony.class);
      }
    }
 else {
      protocolName=detail.getPreferredProtocol(OperationSetBasicTelephony.class);
      providers=CallManager.getRegisteredProviders(protocolName,OperationSetBasicTelephony.class);
    }
    if (providers != null) {
      int providersCount=providers.size();
      if (providersCount <= 0) {
        new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolName})).showDialog();
      }
 else       if (providersCount == 1) {
        CallManager.createCall(providers.get(0),detail.getAddress());
      }
 else       if (providersCount > 1)       chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,detail.getAddress(),providers);
    }
  }
 else   if (telephonyContacts.size() > 1) {
    chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,telephonyContacts);
  }
  if (chooseAccountDialog != null) {
    Point location=new Point(callButton.getX(),callButton.getY() + callButton.getHeight());
    SwingUtilities.convertPointToScreen(location,tree);
    location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
    chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
  }
}","/** 
 * Calls the given treeNode.
 * @param treeNode the <tt>TreeNode</tt> to call
 */
private void call(TreeNode treeNode){
  List<UIContactDetail> telephonyContacts=((ContactNode)treeNode).getContactDescriptor().getContactDetailsForOperationSet(OperationSetBasicTelephony.class);
  ChooseCallAccountPopupMenu chooseAccountDialog=null;
  if (telephonyContacts.size() == 1) {
    UIContactDetail detail=telephonyContacts.get(0);
    ProtocolProviderService preferredProvider=detail.getPreferredProtocolProvider(OperationSetBasicTelephony.class);
    List<ProtocolProviderService> providers=null;
    String protocolName=null;
    if (preferredProvider != null) {
      if (preferredProvider.isRegistered())       CallManager.createCall(preferredProvider,detail.getAddress());
 else {
        protocolName=preferredProvider.getProtocolName();
        providers=GuiActivator.getRegisteredProviders(protocolName,OperationSetBasicTelephony.class);
      }
    }
 else {
      protocolName=detail.getPreferredProtocol(OperationSetBasicTelephony.class);
      if (protocolName != null)       providers=GuiActivator.getRegisteredProviders(protocolName,OperationSetBasicTelephony.class);
 else       providers=CallManager.getTelephonyProviders();
    }
    if (providers != null) {
      int providersCount=providers.size();
      if (providersCount <= 0) {
        new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolName})).showDialog();
      }
 else       if (providersCount == 1) {
        CallManager.createCall(providers.get(0),detail.getAddress());
      }
 else       if (providersCount > 1)       chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,detail.getAddress(),providers);
    }
  }
 else   if (telephonyContacts.size() > 1) {
    chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,telephonyContacts);
  }
  if (chooseAccountDialog != null) {
    Point location=new Point(callButton.getX(),callButton.getY() + callButton.getHeight());
    SwingUtilities.convertPointToScreen(location,tree);
    location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
    chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
  }
}",0.9656102494942684
103470,"/** 
 * Calls the given treeNode with video option enabled.
 * @param treeNode the <tt>TreeNode</tt> to call
 */
private void callVideo(TreeNode treeNode){
  List<UIContactDetail> videoContacts=((ContactNode)treeNode).getContactDescriptor().getContactDetailsForOperationSet(OperationSetVideoTelephony.class);
  ChooseCallAccountPopupMenu chooseAccountDialog=null;
  if (videoContacts.size() == 1) {
    UIContactDetail detail=videoContacts.get(0);
    ProtocolProviderService preferredProvider=detail.getPreferredProtocolProvider(OperationSetVideoTelephony.class);
    List<ProtocolProviderService> providers=null;
    String protocolName=null;
    if (preferredProvider != null) {
      if (preferredProvider.isRegistered())       CallManager.createVideoCall(preferredProvider,detail.getAddress());
 else {
        protocolName=preferredProvider.getProtocolName();
        providers=CallManager.getRegisteredProviders(protocolName,OperationSetVideoTelephony.class);
      }
    }
 else {
      protocolName=detail.getPreferredProtocol(OperationSetVideoTelephony.class);
      providers=CallManager.getRegisteredProviders(protocolName,OperationSetVideoTelephony.class);
    }
    if (providers != null) {
      int providersCount=providers.size();
      if (providersCount <= 0) {
        new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolName})).showDialog();
      }
 else       if (providersCount == 1) {
        CallManager.createVideoCall(providers.get(0),detail.getAddress());
      }
 else       if (providersCount > 1)       chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,detail.getAddress(),providers,OperationSetVideoTelephony.class);
    }
  }
 else   if (videoContacts.size() > 1) {
    chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,videoContacts,OperationSetVideoTelephony.class);
  }
  if (chooseAccountDialog != null) {
    Point location=new Point(callVideoButton.getX(),callVideoButton.getY() + callVideoButton.getHeight());
    SwingUtilities.convertPointToScreen(location,tree);
    location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
    chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
  }
}","/** 
 * Calls the given treeNode with video option enabled.
 * @param treeNode the <tt>TreeNode</tt> to call
 */
private void callVideo(TreeNode treeNode){
  List<UIContactDetail> videoContacts=((ContactNode)treeNode).getContactDescriptor().getContactDetailsForOperationSet(OperationSetVideoTelephony.class);
  ChooseCallAccountPopupMenu chooseAccountDialog=null;
  if (videoContacts.size() == 1) {
    UIContactDetail detail=videoContacts.get(0);
    ProtocolProviderService preferredProvider=detail.getPreferredProtocolProvider(OperationSetVideoTelephony.class);
    List<ProtocolProviderService> providers=null;
    String protocolName=null;
    if (preferredProvider != null) {
      if (preferredProvider.isRegistered())       CallManager.createVideoCall(preferredProvider,detail.getAddress());
 else {
        protocolName=preferredProvider.getProtocolName();
        providers=GuiActivator.getRegisteredProviders(protocolName,OperationSetVideoTelephony.class);
      }
    }
 else {
      protocolName=detail.getPreferredProtocol(OperationSetVideoTelephony.class);
      if (protocolName != null)       providers=GuiActivator.getRegisteredProviders(protocolName,OperationSetVideoTelephony.class);
 else       providers=GuiActivator.getRegisteredProviders(OperationSetVideoTelephony.class);
    }
    if (providers != null) {
      int providersCount=providers.size();
      if (providersCount <= 0) {
        new ErrorDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolName})).showDialog();
      }
 else       if (providersCount == 1) {
        CallManager.createVideoCall(providers.get(0),detail.getAddress());
      }
 else       if (providersCount > 1)       chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,detail.getAddress(),providers,OperationSetVideoTelephony.class);
    }
  }
 else   if (videoContacts.size() > 1) {
    chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,videoContacts,OperationSetVideoTelephony.class);
  }
  if (chooseAccountDialog != null) {
    Point location=new Point(callVideoButton.getX(),callVideoButton.getY() + callVideoButton.getHeight());
    SwingUtilities.convertPointToScreen(location,tree);
    location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
    chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
  }
}",0.9605291231064648
103471,"/** 
 * Returns the image corresponding to the underlying <tt>SourceContact</tt>.
 * @param isSelected indicates if the contact is currently selected in thecontact list component
 * @param width the desired image width
 * @param height the desired image height
 * @return the image
 */
public ImageIcon getAvatar(boolean isSelected,int width,int height){
  byte[] image=sourceContact.getImage();
  if (image != null) {
    ImageIcon icon=new ImageIcon();
    if (icon.getIconWidth() > width || icon.getIconHeight() > height) {
      icon=ImageUtils.getScaledRoundedIcon(icon.getImage(),width,height);
    }
    return icon;
  }
 else   return null;
}","/** 
 * Returns the image corresponding to the underlying <tt>SourceContact</tt>.
 * @param isSelected indicates if the contact is currently selected in thecontact list component
 * @param width the desired image width
 * @param height the desired image height
 * @return the image
 */
public ImageIcon getAvatar(boolean isSelected,int width,int height){
  byte[] image=sourceContact.getImage();
  if ((image != null) && (image.length > 0)) {
    ImageIcon icon=new ImageIcon(image);
    if (icon.getIconWidth() > width || icon.getIconHeight() > height) {
      icon=ImageUtils.getScaledRoundedIcon(icon.getImage(),width,height);
    }
    return icon;
  }
 else   return null;
}",0.9781790820165538
103472,"/** 
 * Notifies this <tt>MacOSXAddrBookContactQuery</tt> about a specific <tt>ABPerson</tt>.
 * @param person a pointer to the <tt>ABPerson</tt> instance to notify about
 * @return <tt>true</tt> if this <tt>MacOSXAddrBookContactQuery</tt> is tocontinue being called; otherwise, <tt>false</tt>
 */
private boolean onPerson(long person){
  Object[] values=ABRecord_valuesForProperties(person,ABPERSON_PROPERTIES);
  if (matches(values)) {
    String displayName=getDisplayName(values);
    if (displayName.length() != 0) {
      List<ContactDetail> contactDetails=getContactDetails(values);
      if (!contactDetails.isEmpty()) {
        AddrBookSourceContact sourceContact=new AddrBookSourceContact(getContactSource(),displayName,contactDetails);
        try {
          byte[] image=ABPerson_imageData(person);
          if (image != null)           sourceContact.setImage(image);
        }
 catch (        OutOfMemoryError oome) {
        }
        addQueryResult(sourceContact);
      }
    }
  }
  return (getStatus() == QUERY_IN_PROGRESS);
}","/** 
 * Notifies this <tt>MacOSXAddrBookContactQuery</tt> about a specific <tt>ABPerson</tt>.
 * @param person a pointer to the <tt>ABPerson</tt> instance to notify about
 * @return <tt>true</tt> if this <tt>MacOSXAddrBookContactQuery</tt> is tocontinue being called; otherwise, <tt>false</tt>
 */
private boolean onPerson(long person){
  Object[] values=ABRecord_valuesForProperties(person,ABPERSON_PROPERTIES);
  String displayName=getDisplayName(values);
  if ((displayName.length() != 0) && (query.matcher(displayName).find() || matches(values))) {
    List<ContactDetail> contactDetails=getContactDetails(values);
    if (!contactDetails.isEmpty()) {
      AddrBookSourceContact sourceContact=new AddrBookSourceContact(getContactSource(),displayName,contactDetails);
      try {
        byte[] image=ABPerson_imageData(person);
        if (image != null)         sourceContact.setImage(image);
      }
 catch (      OutOfMemoryError oome) {
      }
      addQueryResult(sourceContact);
    }
  }
  return (getStatus() == QUERY_IN_PROGRESS);
}",0.9010989010989012
103473,"/** 
 * Gets the <tt>contactDetails</tt> to be set on a <tt>SourceContact</tt> which is to represent an <tt>ABPerson</tt> specified by the values of its  {@link #ABPERSON_PROPERTIES}.
 * @param values the values of the <tt>ABPERSON_PROPERTIES</tt> whichrepresent the <tt>ABPerson</tt> to get the <tt>contactDetails</tt> of
 * @return the <tt>contactDetails</tt> to be set on a <tt>SourceContact</tt>which is to represent the <tt>ABPerson</tt> specified by <tt>values</tt>
 */
private List<ContactDetail> getContactDetails(Object[] values){
  List<ContactDetail> contactDetails=new LinkedList<ContactDetail>();
  for (int i=0; i < CONTACT_DETAIL_PROPERTY_INDEXES.length; i++) {
    Object value=values[CONTACT_DETAIL_PROPERTY_INDEXES[i]];
    if (value instanceof String) {
      String stringValue=(String)value;
      if (stringValue.length() != 0)       contactDetails.add(new ContactDetail(stringValue));
    }
 else     if (value instanceof Object[]) {
      for (      Object subValue : (Object[])value) {
        if (subValue instanceof String) {
          String stringSubValue=(String)subValue;
          if (stringSubValue.length() != 0) {
            contactDetails.add(new ContactDetail(stringSubValue));
          }
        }
      }
    }
  }
  return contactDetails;
}","/** 
 * Gets the <tt>contactDetails</tt> to be set on a <tt>SourceContact</tt> which is to represent an <tt>ABPerson</tt> specified by the values of its  {@link #ABPERSON_PROPERTIES}.
 * @param values the values of the <tt>ABPERSON_PROPERTIES</tt> whichrepresent the <tt>ABPerson</tt> to get the <tt>contactDetails</tt> of
 * @return the <tt>contactDetails</tt> to be set on a <tt>SourceContact</tt>which is to represent the <tt>ABPerson</tt> specified by <tt>values</tt>
 */
private List<ContactDetail> getContactDetails(Object[] values){
  List<ContactDetail> contactDetails=new LinkedList<ContactDetail>();
  for (int i=0; i < CONTACT_DETAIL_PROPERTY_INDEXES.length; i++) {
    int property=CONTACT_DETAIL_PROPERTY_INDEXES[i];
    Object value=values[property];
    if (value instanceof String) {
      String stringValue=(String)value;
      if (stringValue.length() != 0) {
        contactDetails.add(setCapabilities(new ContactDetail(stringValue),property));
      }
    }
 else     if (value instanceof Object[]) {
      for (      Object subValue : (Object[])value) {
        if (subValue instanceof String) {
          String stringSubValue=(String)subValue;
          if (stringSubValue.length() != 0) {
            contactDetails.add(setCapabilities(new ContactDetail(stringSubValue),property));
          }
        }
      }
    }
  }
  return contactDetails;
}",0.9514124293785312
103474,"/** 
 * Creates a REGISTER <tt>Request</tt> as per the specified parameters.
 * @param addressOfRecord the address that we shall be registering
 * @param registrationsExpiration the expiration interval for the AOR
 * @param callIdHeader the Call-ID header for our new <tt>Request</tt>.
 * @param cSeqValue the sequence number of the new request.
 * @return the newly created REGISTER <tt>Request</tt>
 * @throws InvalidArgumentException in case there's a problem with any ofthe arguments that we received for this request.
 * @throws ParseException in case there's a problem with any ofthe arguments that we received for this request.
 * @throws OperationFailedException if we have a problem with the<tt>MaxForwardsHeader</tt>.
 */
public Request createRegisterRequest(Address addressOfRecord,int registrationsExpiration,CallIdHeader callIdHeader,long cSeqValue) throws InvalidArgumentException, ParseException, OperationFailedException {
  FromHeader fromHeader=protocolProvider.getHeaderFactory().createFromHeader(addressOfRecord,SipMessageFactory.generateLocalTag());
  CSeqHeader cSeqHeader=protocolProvider.getHeaderFactory().createCSeqHeader(cSeqValue,Request.REGISTER);
  ToHeader toHeader=protocolProvider.getHeaderFactory().createToHeader(addressOfRecord,null);
  MaxForwardsHeader maxForwardsHeader=protocolProvider.getMaxForwardsHeader();
  String domain=((SipURI)toHeader.getAddress().getURI()).getHost();
  SipURI requestURI=protocolProvider.getAddressFactory().createSipURI(null,domain);
  ArrayList<ViaHeader> viaHeaders=protocolProvider.getLocalViaHeaders(requestURI);
  Request request=createRequest(requestURI,Request.REGISTER,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwardsHeader);
  ExpiresHeader expHeader=null;
  for (int retry=0; retry < 2; retry++) {
    try {
      expHeader=protocolProvider.getHeaderFactory().createExpiresHeader(registrationsExpiration);
    }
 catch (    InvalidArgumentException ex) {
      if (retry == 0) {
        registrationsExpiration=3600;
        continue;
      }
      throw new IllegalArgumentException(""String_Node_Str"" + registrationsExpiration,ex);
    }
  }
  request.addHeader(expHeader);
  ContactHeader contactHeader=(ContactHeader)request.getHeader(ContactHeader.NAME);
  contactHeader.setExpires(registrationsExpiration);
  request.setHeader(contactHeader);
  return request;
}","/** 
 * Creates a REGISTER <tt>Request</tt> as per the specified parameters.
 * @param addressOfRecord the address that we shall be registering
 * @param registrationsExpiration the expiration interval for the AOR
 * @param callIdHeader the Call-ID header for our new <tt>Request</tt>.
 * @param cSeqValue the sequence number of the new request.
 * @return the newly created REGISTER <tt>Request</tt>
 * @throws InvalidArgumentException in case there's a problem with any ofthe arguments that we received for this request.
 * @throws ParseException in case there's a problem with any ofthe arguments that we received for this request.
 * @throws OperationFailedException if we have a problem with the<tt>MaxForwardsHeader</tt>.
 */
public Request createRegisterRequest(Address addressOfRecord,int registrationsExpiration,CallIdHeader callIdHeader,long cSeqValue) throws InvalidArgumentException, ParseException, OperationFailedException {
  FromHeader fromHeader=protocolProvider.getHeaderFactory().createFromHeader(addressOfRecord,SipMessageFactory.generateLocalTag());
  CSeqHeader cSeqHeader=protocolProvider.getHeaderFactory().createCSeqHeader(cSeqValue,Request.REGISTER);
  ToHeader toHeader=protocolProvider.getHeaderFactory().createToHeader(addressOfRecord,null);
  MaxForwardsHeader maxForwardsHeader=protocolProvider.getMaxForwardsHeader();
  String domain=protocolProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  SipURI requestURI=protocolProvider.getAddressFactory().createSipURI(null,domain);
  ArrayList<ViaHeader> viaHeaders=protocolProvider.getLocalViaHeaders(requestURI);
  Request request=createRequest(requestURI,Request.REGISTER,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwardsHeader);
  ExpiresHeader expHeader=null;
  for (int retry=0; retry < 2; retry++) {
    try {
      expHeader=protocolProvider.getHeaderFactory().createExpiresHeader(registrationsExpiration);
    }
 catch (    InvalidArgumentException ex) {
      if (retry == 0) {
        registrationsExpiration=3600;
        continue;
      }
      throw new IllegalArgumentException(""String_Node_Str"" + registrationsExpiration,ex);
    }
  }
  request.addHeader(expHeader);
  ContactHeader contactHeader=(ContactHeader)request.getHeader(ContactHeader.NAME);
  contactHeader.setExpires(registrationsExpiration);
  request.setHeader(contactHeader);
  return request;
}",0.9706621961441744
103475,"/** 
 * Loads the account with the given identifier.
 * @param accountID the account identifier
 */
public void loadAccount(AccountID accountID){
  String password=SIPAccRegWizzActivator.getSIPProtocolProviderFactory().loadPassword(accountID);
  String serverAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  String displayName=accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);
  String authName=accountID.getAccountPropertyString(ProtocolProviderFactory.AUTHORIZATION_NAME);
  String serverPort=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED,false);
  boolean forceP2P=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE,false);
  boolean enabledDefaultEncryption=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true);
  boolean enabledSipZrtpAttribute=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,true);
  boolean proxyAutoConfigureEnabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false);
  String pollingPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=accountID.getAccountPropertyString(""String_Node_Str"");
  String keepAliveInterval=accountID.getAccountPropertyString(""String_Node_Str"");
  boolean xCapEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean xCapUseSipCredetials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
  String xCapServerUri=accountID.getAccountPropertyString(""String_Node_Str"");
  String xCapUser=accountID.getAccountPropertyString(""String_Node_Str"");
  String xCapPassword=accountID.getAccountPropertyString(""String_Node_Str"");
  connectionPanel.setServerOverridden(accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,false));
  accountPanel.setUserIDEnabled(false);
  accountPanel.setUserID((serverAddress == null) ? accountID.getUserID() : (accountID.getUserID() + ""String_Node_Str"" + serverAddress));
  if (password != null) {
    accountPanel.setPassword(password);
    accountPanel.setRememberPassword(true);
  }
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setServerEnabled(false);
  if (displayName != null && displayName.length() > 0)   accountPanel.setDisplayName(displayName);
  if (authName != null && authName.length() > 0)   connectionPanel.setAuthenticationName(authName);
  connectionPanel.enablesProxyAutoConfigure(proxyAutoConfigureEnabled);
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setProxy(proxyAddress);
  connectionPanel.setSelectedTransport(preferredTransport);
  connectionPanel.setProxyPort(proxyPort);
  presencePanel.setPresenceEnabled(enablePresence);
  presencePanel.setForcePeerToPeerMode(forceP2P);
  connectionPanel.enablesDefaultEncryption(enabledDefaultEncryption);
  connectionPanel.setSipZrtpEnabled(enabledSipZrtpAttribute,enabledDefaultEncryption);
  presencePanel.setPollPeriod(pollingPeriod);
  presencePanel.setSubscriptionExpiration(subscriptionPeriod);
  if (!enablePresence) {
    presencePanel.setPresenceOptionsEnabled(enablePresence);
  }
  connectionPanel.setKeepAliveMethod(keepAliveMethod);
  connectionPanel.setKeepAliveInterval(keepAliveInterval);
  presencePanel.setXCapEnable(xCapEnable);
  presencePanel.setXCapEnableEnabled(xCapEnable);
  presencePanel.setXCapUseSipCredetials(xCapUseSipCredetials);
  presencePanel.setXCapUseSipCredetialsEnabled(xCapUseSipCredetials);
  presencePanel.setXCapServerUri(xCapServerUri);
  presencePanel.setXCapUser(xCapUser);
  presencePanel.setXCapPassword(xCapPassword);
}","/** 
 * Loads the account with the given identifier.
 * @param accountID the account identifier
 */
public void loadAccount(AccountID accountID){
  String password=SIPAccRegWizzActivator.getSIPProtocolProviderFactory().loadPassword(accountID);
  String serverAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  String displayName=accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);
  String authName=accountID.getAccountPropertyString(ProtocolProviderFactory.AUTHORIZATION_NAME);
  String serverPort=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED,false);
  boolean forceP2P=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE,false);
  boolean enabledDefaultEncryption=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION,true);
  boolean enabledSipZrtpAttribute=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,true);
  boolean proxyAutoConfigureEnabled=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_AUTO_CONFIG,false);
  String pollingPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=accountID.getAccountPropertyString(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=accountID.getAccountPropertyString(""String_Node_Str"");
  String keepAliveInterval=accountID.getAccountPropertyString(""String_Node_Str"");
  boolean xCapEnable=accountID.getAccountPropertyBoolean(""String_Node_Str"",false);
  boolean xCapUseSipCredetials=accountID.getAccountPropertyBoolean(""String_Node_Str"",true);
  String xCapServerUri=accountID.getAccountPropertyString(""String_Node_Str"");
  String xCapUser=accountID.getAccountPropertyString(""String_Node_Str"");
  String xCapPassword=accountID.getAccountPropertyString(""String_Node_Str"");
  boolean isServerOverridden=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,false);
  connectionPanel.setServerOverridden(isServerOverridden);
  accountPanel.setUserIDEnabled(false);
  accountPanel.setUserID((serverAddress == null) ? accountID.getUserID() : accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID));
  if (password != null) {
    accountPanel.setPassword(password);
    accountPanel.setRememberPassword(true);
  }
  connectionPanel.setServerAddress(serverAddress);
  connectionPanel.setServerEnabled(isServerOverridden);
  if (displayName != null && displayName.length() > 0)   accountPanel.setDisplayName(displayName);
  if (authName != null && authName.length() > 0)   connectionPanel.setAuthenticationName(authName);
  connectionPanel.enablesProxyAutoConfigure(proxyAutoConfigureEnabled);
  connectionPanel.setServerPort(serverPort);
  connectionPanel.setProxy(proxyAddress);
  connectionPanel.setSelectedTransport(preferredTransport);
  connectionPanel.setProxyPort(proxyPort);
  presencePanel.setPresenceEnabled(enablePresence);
  presencePanel.setForcePeerToPeerMode(forceP2P);
  connectionPanel.enablesDefaultEncryption(enabledDefaultEncryption);
  connectionPanel.setSipZrtpEnabled(enabledSipZrtpAttribute,enabledDefaultEncryption);
  presencePanel.setPollPeriod(pollingPeriod);
  presencePanel.setSubscriptionExpiration(subscriptionPeriod);
  if (!enablePresence) {
    presencePanel.setPresenceOptionsEnabled(enablePresence);
  }
  connectionPanel.setKeepAliveMethod(keepAliveMethod);
  connectionPanel.setKeepAliveInterval(keepAliveInterval);
  presencePanel.setXCapEnable(xCapEnable);
  presencePanel.setXCapEnableEnabled(xCapEnable);
  presencePanel.setXCapUseSipCredetials(xCapUseSipCredetials);
  presencePanel.setXCapUseSipCredetialsEnabled(xCapUseSipCredetials);
  presencePanel.setXCapServerUri(xCapServerUri);
  presencePanel.setXCapUser(xCapUser);
  presencePanel.setXCapPassword(xCapPassword);
}",0.972583313637438
103476,"/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException problem installing account
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  HashMap<String,String> accountProperties=new HashMap<String,String>();
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  String serverAddress=null;
  String serverFromUsername=SIPAccountRegistrationForm.getServerFromUserName(userName);
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
  if (serverFromUsername == null && registration.getDefaultDomain() != null) {
    userName=userName + ""String_Node_Str"" + registration.getDefaultDomain();
    if (serverAddress == null)     serverAddress=registration.getDefaultDomain();
  }
 else   if (serverAddress == null && serverFromUsername != null) {
    serverAddress=serverFromUsername;
  }
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
    if (userName.indexOf(serverAddress) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
  accountProperties.put(ProtocolProviderFactory.DISPLAY_NAME,registration.getDisplayName());
  accountProperties.put(ProtocolProviderFactory.AUTHORIZATION_NAME,registration.getAuthorizationName());
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  if (registration.isProxyAutoConfigure()) {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.TRUE.toString());
  }
 else {
    accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,registration.getProxy());
    accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
    accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  }
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  }
 else {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.TRUE.toString());
  }
  accountProperties.put(ProtocolProviderFactory.DEFAULT_ENCRYPTION,Boolean.toString(registration.isDefaultEncryption()));
  accountProperties.put(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,Boolean.toString(registration.isSipZrtpAttribute()));
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  if (registration.getKeepAliveMethod() != null)   accountProperties.put(""String_Node_Str"",registration.getKeepAliveMethod());
 else   accountProperties.put(""String_Node_Str"",registration.getDefaultKeepAliveMethod());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveInterval());
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapEnable()));
  if (registration.isXCapEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapUseSipCredetials()));
    if (registration.getXCapServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapServerUri());
    }
    if (registration.getXCapUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapUser());
    }
    if (registration.getXCapPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapPassword());
    }
  }
  if (!StringUtils.isNullOrEmpty(registration.getVoicemailURI(),true))   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,registration.getVoicemailURI());
  if (isModification) {
    accountProperties.put(ProtocolProviderFactory.USER_ID,userName);
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    this.isModification=false;
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Exception exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(exc.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}","/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 * @throws OperationFailedException problem installing account
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd) throws OperationFailedException {
  HashMap<String,String> accountProperties=new HashMap<String,String>();
  accountProperties.put(ProtocolProviderFactory.PROTOCOL,getProtocol());
  String protocolIconPath=getProtocolIconPath();
  if (protocolIconPath != null)   accountProperties.put(ProtocolProviderFactory.PROTOCOL_ICON_PATH,protocolIconPath);
  String accountIconPath=getAccountIconPath();
  if (accountIconPath != null)   accountProperties.put(ProtocolProviderFactory.ACCOUNT_ICON_PATH,accountIconPath);
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  String serverAddress=null;
  String serverFromUsername=SIPAccountRegistrationForm.getServerFromUserName(userName);
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
  if (serverFromUsername == null && registration.getDefaultDomain() != null) {
    userName=userName + ""String_Node_Str"" + registration.getDefaultDomain();
    if (serverAddress == null)     serverAddress=registration.getDefaultDomain();
  }
 else   if (serverAddress == null && serverFromUsername != null) {
    serverAddress=serverFromUsername;
  }
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
    if (userName.indexOf(serverAddress) < 0)     accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,Boolean.toString(true));
  }
  accountProperties.put(ProtocolProviderFactory.DISPLAY_NAME,registration.getDisplayName());
  accountProperties.put(ProtocolProviderFactory.AUTHORIZATION_NAME,registration.getAuthorizationName());
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  if (registration.isProxyAutoConfigure()) {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.TRUE.toString());
  }
 else {
    accountProperties.put(ProtocolProviderFactory.PROXY_AUTO_CONFIG,Boolean.FALSE.toString());
    accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,registration.getProxy());
    accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
    accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  }
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  if (serverAddress != null) {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  }
 else {
    accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.TRUE.toString());
  }
  accountProperties.put(ProtocolProviderFactory.DEFAULT_ENCRYPTION,Boolean.toString(registration.isDefaultEncryption()));
  accountProperties.put(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE,Boolean.toString(registration.isSipZrtpAttribute()));
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  if (registration.getKeepAliveMethod() != null)   accountProperties.put(""String_Node_Str"",registration.getKeepAliveMethod());
 else   accountProperties.put(""String_Node_Str"",registration.getDefaultKeepAliveMethod());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveInterval());
  accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapEnable()));
  if (registration.isXCapEnable()) {
    accountProperties.put(""String_Node_Str"",Boolean.toString(registration.isXCapUseSipCredetials()));
    if (registration.getXCapServerUri() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapServerUri());
    }
    if (registration.getXCapUser() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapUser());
    }
    if (registration.getXCapPassword() != null) {
      accountProperties.put(""String_Node_Str"",registration.getXCapPassword());
    }
  }
  if (!StringUtils.isNullOrEmpty(registration.getVoicemailURI(),true))   accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI,registration.getVoicemailURI());
  if (isModification) {
    accountProperties.put(ProtocolProviderFactory.USER_ID,userName);
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    this.isModification=false;
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalStateException exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.IDENTIFICATION_CONFLICT);
  }
catch (  Exception exc) {
    logger.warn(exc.getMessage());
    throw new OperationFailedException(exc.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
  return protocolProvider;
}",0.9913706967026978
103477,"/** 
 * Creates an account id for the specified provider userid and accountProperties.
 * @param userID a String that uniquely identifies the user.
 * @param accountProperties a Map containing any other protocol andimplementation specific account initialization properties
 * @param protocolName the name of the protocol implemented by the providerthat this id is meant for.
 * @param serviceName the name of the service (e.g. iptel.org, jabber.org,icq.com) that this account is registered with.
 */
protected AccountID(String userID,Map<String,String> accountProperties,String protocolName,String serviceName){
  this.protocolDisplayName=getOverriddenProtocolName(accountProperties,protocolName);
  this.protocolName=protocolName;
  this.userID=userID;
  this.accountProperties=new HashMap<String,String>(accountProperties);
  this.serviceName=serviceName;
  this.accountUID=protocolDisplayName + ""String_Node_Str"" + userID+ ""String_Node_Str""+ ((serviceName == null) ? ""String_Node_Str"" : serviceName);
}","/** 
 * Creates an account id for the specified provider userid and accountProperties. If account uid exists in account properties, we are loading the account and so load its value from there, prevent changing account uid when server changed (serviceName has changed).
 * @param userID a String that uniquely identifies the user.
 * @param accountProperties a Map containing any other protocol andimplementation specific account initialization properties
 * @param protocolName the name of the protocol implemented by the providerthat this id is meant for.
 * @param serviceName the name of the service (e.g. iptel.org, jabber.org,icq.com) that this account is registered with.
 */
protected AccountID(String userID,Map<String,String> accountProperties,String protocolName,String serviceName){
  this.protocolDisplayName=getOverriddenProtocolName(accountProperties,protocolName);
  this.protocolName=protocolName;
  this.userID=userID;
  this.accountProperties=new HashMap<String,String>(accountProperties);
  this.serviceName=serviceName;
  String existingAccountUID=accountProperties.get(ProtocolProviderFactory.ACCOUNT_UID);
  if (existingAccountUID == null) {
    this.accountUID=protocolDisplayName + ""String_Node_Str"" + userID+ ""String_Node_Str""+ ((serviceName == null) ? ""String_Node_Str"" : serviceName);
  }
 else {
    this.accountUID=existingAccountUID;
  }
}",0.8416175231676495
103478,"/** 
 * Sets the <tt>MediaFormat</tt> that this <tt>MediaStream</tt> should transmit in.
 * @param format the <tt>MediaFormat</tt> that this <tt>MediaStream</tt>should transmit in
 * @see MediaStream#setFormat(MediaFormat)
 */
public void setFormat(MediaFormat format){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + hashCode() + ""String_Node_Str""+ getDeviceSession().getFormat()+ ""String_Node_Str""+ format);
  setAdvancedAttributes(format.getAdvancedAttributes());
  handleAttributes(format.getAdvancedAttributes());
  handleAttributes(format.getFormatParameters());
  getDeviceSession().setFormat(format);
}","/** 
 * Sets the <tt>MediaFormat</tt> that this <tt>MediaStream</tt> should transmit in.
 * @param format the <tt>MediaFormat</tt> that this <tt>MediaStream</tt>should transmit in
 * @see MediaStream#setFormat(MediaFormat)
 */
public void setFormat(MediaFormat format){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + hashCode() + ""String_Node_Str""+ format);
  setAdvancedAttributes(format.getAdvancedAttributes());
  handleAttributes(format.getAdvancedAttributes());
  handleAttributes(format.getFormatParameters());
  getDeviceSession().setFormat(format);
}",0.6589211618257261
103479,"/** 
 * Init and establish the specified call.
 * @param call the <tt>CallJabberImpl</tt> that will be usedto initiate the call
 * @param calleeAddress the address of the callee that we'd like to connectwith.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to init the specified <tt>call</tt>
 * @return the <tt>CallPeer</tt> that represented by the specified uri. Allfollowing state change events will be delivered through that call peer. The <tt>Call</tt> that this peer is a member of could be retrieved from the <tt>CallPeer</tt> instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
CallPeerJabberImpl createOutgoingCall(CallJabberImpl call,String calleeAddress,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (protocolProvider.getConnection() == null || call == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  String fullCalleeURI=null;
  DiscoverInfo di=null;
  int bestPriority=0;
  Iterator<Presence> it=getProtocolProvider().getConnection().getRoster().getPresences(calleeAddress);
  while (it.hasNext()) {
    Presence presence=it.next();
    String calleeURI=presence.getFrom();
    int priority=(presence.getPriority() == Integer.MIN_VALUE) ? 0 : presence.getPriority();
    try {
      DiscoverInfo discoverInfo=protocolProvider.getDiscoveryManager().discoverInfo(calleeURI);
      if (discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE)) {
        if (priority > bestPriority) {
          bestPriority=priority;
          di=discoverInfo;
          fullCalleeURI=calleeURI;
        }
      }
    }
 catch (    XMPPException ex) {
      logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
    }
  }
  if (di != null) {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
  }
 else {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"" + calleeAddress + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + fullCalleeURI + ""String_Node_Str""+ bestPriority);
  }
  CallPeerJabberImpl peer=null;
  try {
    peer=call.initiateSession(fullCalleeURI,di,sessionInitiateExtensions);
  }
 catch (  Throwable t) {
    if (t instanceof ThreadDeath)     throw (ThreadDeath)t;
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,t);
  }
  return peer;
}","/** 
 * Init and establish the specified call.
 * @param call the <tt>CallJabberImpl</tt> that will be usedto initiate the call
 * @param calleeAddress the address of the callee that we'd like to connectwith.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to init the specified <tt>call</tt>
 * @return the <tt>CallPeer</tt> that represented by the specified uri. Allfollowing state change events will be delivered through that call peer. The <tt>Call</tt> that this peer is a member of could be retrieved from the <tt>CallPeer</tt> instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
CallPeerJabberImpl createOutgoingCall(CallJabberImpl call,String calleeAddress,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (protocolProvider.getConnection() == null || call == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  String fullCalleeURI=null;
  DiscoverInfo di=null;
  int bestPriority=-1;
  Iterator<Presence> it=getProtocolProvider().getConnection().getRoster().getPresences(calleeAddress);
  while (it.hasNext()) {
    Presence presence=it.next();
    String calleeURI=presence.getFrom();
    int priority=(presence.getPriority() == Integer.MIN_VALUE) ? 0 : presence.getPriority();
    try {
      DiscoverInfo discoverInfo=protocolProvider.getDiscoveryManager().discoverInfo(calleeURI);
      if (discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE)) {
        if (priority > bestPriority) {
          bestPriority=priority;
          di=discoverInfo;
          fullCalleeURI=calleeURI;
        }
      }
    }
 catch (    XMPPException ex) {
      logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
    }
  }
  if (di != null) {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
  }
 else {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"" + calleeAddress + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + fullCalleeURI + ""String_Node_Str""+ bestPriority);
  }
  CallPeerJabberImpl peer=null;
  try {
    peer=call.initiateSession(fullCalleeURI,di,sessionInitiateExtensions);
  }
 catch (  Throwable t) {
    if (t instanceof ThreadDeath)     throw (ThreadDeath)t;
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,t);
  }
  return peer;
}",0.9994715518759908
103480,"private void removeCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<String> caps=this.capabilities.keySet().iterator();
  Set<String> contactNewCaps=opSets.keySet();
  while (caps.hasNext()) {
    String opSetName=caps.next();
    List<Contact> contactsForCap=capabilities.get(opSetName);
    if (contactsForCap.contains(contact) && !contactNewCaps.contains(opSetName)) {
      contactsForCap.remove(contact);
      if (contactsForCap.size() == 0)       capabilities.remove(opSetName);
    }
  }
}","/** 
 * Remove capabilities for the given contacts.
 * @param contact the <tt>Contact</tt>, which capabilities we remove
 * @param opSets the new updated set of operation sets
 */
private void removeCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<String> caps=this.capabilities.keySet().iterator();
  Set<String> contactNewCaps=opSets.keySet();
  while (caps.hasNext()) {
    String opSetName=caps.next();
    List<Contact> contactsForCap=capabilities.get(opSetName);
    if (contactsForCap.contains(contact) && !contactNewCaps.contains(opSetName)) {
      contactsForCap.remove(contact);
      if (contactsForCap.size() == 0)       capabilities.remove(opSetName);
    }
  }
}",0.8553054662379421
103481,"/** 
 * Adds the capabilities of the given contact. 
 * @param contact the <tt>Contact</tt>, which capabilities we add
 * @param opSets the map of operation sets supported by the contact
 */
private void addCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<String> contactNewCaps=opSets.keySet().iterator();
  while (contactNewCaps.hasNext()) {
    String newCap=contactNewCaps.next();
    List<Contact> capContacts=null;
    if (!capabilities.containsKey(newCap)) {
      capContacts=new LinkedList<Contact>();
      capContacts.add(contact);
      capabilities.put(newCap,capContacts);
    }
 else {
      capContacts=capabilities.get(newCap);
      if (!capContacts.contains(contact)) {
        capContacts.add(contact);
      }
    }
  }
}","/** 
 * Adds the capabilities of the given contact.
 * @param contact the <tt>Contact</tt>, which capabilities we add
 * @param opSets the map of operation sets supported by the contact
 */
private void addCapabilities(Contact contact,Map<String,? extends OperationSet> opSets){
  Iterator<String> contactNewCaps=opSets.keySet().iterator();
  while (contactNewCaps.hasNext()) {
    String newCap=contactNewCaps.next();
    List<Contact> capContacts=null;
    if (!capabilities.containsKey(newCap)) {
      capContacts=new LinkedList<Contact>();
      capContacts.add(contact);
      capabilities.put(newCap,capContacts);
    }
 else {
      capContacts=capabilities.get(newCap);
      if (!capContacts.contains(contact)) {
        capContacts.add(contact);
      }
    }
  }
}",0.9993560849967804
103482,"/** 
 * Init and establish the specified call.
 * @param call the <tt>CallJabberImpl</tt> that will be usedto initiate the call
 * @param calleeAddress the address of the callee that we'd like to connectwith.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to init the specified <tt>call</tt>
 * @return the <tt>CallPeer</tt> that represented by the specified uri. Allfollowing state change events will be delivered through that call peer. The <tt>Call</tt> that this peer is a member of could be retrieved from the <tt>CallPeer</tt> instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
CallPeerJabberImpl createOutgoingCall(CallJabberImpl call,String calleeAddress,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (protocolProvider.getConnection() == null || call == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  String fullCalleeURI=null;
  DiscoverInfo di=null;
  int bestPriority=0;
  Iterator<Presence> it=getProtocolProvider().getConnection().getRoster().getPresences(calleeAddress);
  while (it.hasNext()) {
    Presence presence=it.next();
    String calleeURI=presence.getFrom();
    int priority=(presence.getPriority() == Integer.MIN_VALUE) ? 0 : presence.getPriority();
    try {
      DiscoverInfo discoverInfo=protocolProvider.getDiscoveryManager().discoverInfo(calleeURI);
      if (discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE)) {
        if (priority > bestPriority) {
          bestPriority=priority;
          di=discoverInfo;
          fullCalleeURI=calleeURI;
        }
      }
    }
 catch (    XMPPException ex) {
      logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
    }
  }
  if (di != null) {
    if (logger.isInfoEnabled())     logger.info(fullCalleeURI + ""String_Node_Str"");
  }
 else {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"" + fullCalleeURI + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + fullCalleeURI + ""String_Node_Str""+ bestPriority);
  }
  CallPeerJabberImpl peer=null;
  try {
    peer=call.initiateSession(fullCalleeURI,di,sessionInitiateExtensions);
  }
 catch (  Throwable t) {
    if (t instanceof ThreadDeath)     throw (ThreadDeath)t;
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,t);
  }
  return peer;
}","/** 
 * Init and establish the specified call.
 * @param call the <tt>CallJabberImpl</tt> that will be usedto initiate the call
 * @param calleeAddress the address of the callee that we'd like to connectwith.
 * @param sessionInitiateExtensions a collection of additional and optional<tt>PacketExtension</tt>s to be added to the <tt>session-initiate</tt> {@link JingleIQ} which is to init the specified <tt>call</tt>
 * @return the <tt>CallPeer</tt> that represented by the specified uri. Allfollowing state change events will be delivered through that call peer. The <tt>Call</tt> that this peer is a member of could be retrieved from the <tt>CallPeer</tt> instance with the use of the corresponding method.
 * @throws OperationFailedException with the corresponding code if we failto create the call.
 */
CallPeerJabberImpl createOutgoingCall(CallJabberImpl call,String calleeAddress,Iterable<PacketExtension> sessionInitiateExtensions) throws OperationFailedException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (protocolProvider.getConnection() == null || call == null) {
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  String fullCalleeURI=null;
  DiscoverInfo di=null;
  int bestPriority=0;
  Iterator<Presence> it=getProtocolProvider().getConnection().getRoster().getPresences(calleeAddress);
  while (it.hasNext()) {
    Presence presence=it.next();
    String calleeURI=presence.getFrom();
    int priority=(presence.getPriority() == Integer.MIN_VALUE) ? 0 : presence.getPriority();
    try {
      DiscoverInfo discoverInfo=protocolProvider.getDiscoveryManager().discoverInfo(calleeURI);
      if (discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE)) {
        if (priority > bestPriority) {
          bestPriority=priority;
          di=discoverInfo;
          fullCalleeURI=calleeURI;
        }
      }
    }
 catch (    XMPPException ex) {
      logger.warn(""String_Node_Str"" + fullCalleeURI,ex);
    }
  }
  if (di != null) {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
  }
 else {
    if (logger.isInfoEnabled())     logger.info(calleeAddress + ""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"" + calleeAddress + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + fullCalleeURI + ""String_Node_Str""+ bestPriority);
  }
  CallPeerJabberImpl peer=null;
  try {
    peer=call.initiateSession(fullCalleeURI,di,sessionInitiateExtensions);
  }
 catch (  Throwable t) {
    if (t instanceof ThreadDeath)     throw (ThreadDeath)t;
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,t);
  }
  return peer;
}",0.9908386187455956
103483,"/** 
 * Changes the current audio system. When javasound is selected we also change the capture device.
 * @param name the name of the audio system.
 * @param captureDevice the selected capture device, if is null we willchoose a default one. Param used when first time initing and extracting config.
 * @param save whether we will save this new option or not.
 */
public void setAudioSystem(String name,CaptureDeviceInfo captureDevice,boolean save){
  ConfigurationService config=NeomediaActivator.getConfigurationService();
  audioSystem=name;
  if (name.equals(AUDIO_SYSTEM_NONE)) {
    setAudioCaptureDevice(null,save);
    setAudioNotifyDevice(null,save);
    setAudioPlaybackDevice(null,save);
  }
 else   if (name.equals(AUDIO_SYSTEM_JAVASOUND)) {
    setAudioNotifyDevice(null,save);
    setAudioPlaybackDevice(null,save);
    if (captureDevice != null)     setAudioCaptureDevice(captureDevice,save);
 else {
      CaptureDeviceInfo[] audioCaptureDevices=getAvailableAudioCaptureDevices();
      for (      CaptureDeviceInfo captureDeviceInfo : audioCaptureDevices) {
        if (captureDeviceInfo.getLocator().getProtocol().equals(""String_Node_Str"")) {
          setAudioCaptureDevice(captureDeviceInfo,save);
          break;
        }
      }
    }
    if (audioCaptureDevice != null) {
      removePortAudioRenderer();
      initJavaSoundRenderer();
    }
  }
 else   if (name.equals(AUDIO_SYSTEM_PORTAUDIO)) {
    String audioNotifyDevName=config.getString(PROP_AUDIO_NOTIFY_DEVICE);
    String audioPlaybackDevName=config.getString(PROP_AUDIO_PLAYBACK_DEVICE);
    setAudioPlaybackDevice(PortAudioAuto.defaultPlaybackDevice,save);
    setAudioNotifyDevice(PortAudioAuto.defaultPlaybackDevice,save);
    if (captureDevice != null) {
      this.audioCaptureDevice=captureDevice;
      if (audioNotifyDevName != null) {
        for (        CaptureDeviceInfo captureDeviceInfo : PortAudioAuto.playbackDevices) {
          if (audioNotifyDevName.equals(captureDeviceInfo.getName())) {
            setAudioNotifyDevice(captureDeviceInfo,save);
            break;
          }
        }
      }
      if (audioPlaybackDevName != null) {
        for (        CaptureDeviceInfo captureDeviceInfo : PortAudioAuto.playbackDevices) {
          if (audioPlaybackDevName.equals(captureDeviceInfo.getName())) {
            setAudioPlaybackDevice(captureDeviceInfo,save);
            break;
          }
        }
      }
    }
 else     setAudioCaptureDevice(PortAudioAuto.defaultCaptureDevice,save);
    return;
  }
 else {
    logger.error(""String_Node_Str"" + name);
    audioSystem=null;
  }
  if (save) {
    config.setProperty(PROP_AUDIO_DEVICE_IS_DISABLED,audioCaptureDevice == null);
  }
}","/** 
 * Changes the current audio system. When javasound is selected we also change the capture device.
 * @param name the name of the audio system.
 * @param captureDevice the selected capture device, if is null we willchoose a default one. Param used when first time initing and extracting config.
 * @param save whether we will save this new option or not.
 */
public void setAudioSystem(String name,CaptureDeviceInfo captureDevice,boolean save){
  ConfigurationService config=NeomediaActivator.getConfigurationService();
  audioSystem=name;
  if (name.equals(AUDIO_SYSTEM_NONE)) {
    setAudioCaptureDevice(null,save);
    setAudioNotifyDevice(null,save);
    setAudioPlaybackDevice(null,save);
  }
 else   if (name.equals(AUDIO_SYSTEM_JAVASOUND)) {
    setAudioNotifyDevice(null,save);
    setAudioPlaybackDevice(null,save);
    if (captureDevice != null)     setAudioCaptureDevice(captureDevice,save);
 else {
      CaptureDeviceInfo[] audioCaptureDevices=getAvailableAudioCaptureDevices();
      for (      CaptureDeviceInfo captureDeviceInfo : audioCaptureDevices) {
        if (captureDeviceInfo.getLocator().getProtocol().equals(""String_Node_Str"")) {
          setAudioCaptureDevice(captureDeviceInfo,save);
          break;
        }
      }
    }
    if (audioCaptureDevice != null) {
      removePortAudioRenderer();
      initJavaSoundRenderer();
    }
  }
 else   if (name.equals(AUDIO_SYSTEM_PORTAUDIO)) {
    String audioNotifyDevName=config.getString(PROP_AUDIO_NOTIFY_DEVICE);
    String audioPlaybackDevName=config.getString(PROP_AUDIO_PLAYBACK_DEVICE);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + audioNotifyDevName + ""String_Node_Str"");
      logger.debug(""String_Node_Str"" + audioPlaybackDevName + ""String_Node_Str"");
    }
    setAudioPlaybackDevice(PortAudioAuto.defaultPlaybackDevice,save);
    setAudioNotifyDevice(PortAudioAuto.defaultPlaybackDevice,save);
    if (captureDevice != null) {
      this.audioCaptureDevice=captureDevice;
    }
 else     setAudioCaptureDevice(PortAudioAuto.defaultCaptureDevice,save);
    if (audioNotifyDevName != null) {
      for (      CaptureDeviceInfo captureDeviceInfo : PortAudioAuto.playbackDevices) {
        if (audioNotifyDevName.equals(captureDeviceInfo.getName())) {
          setAudioNotifyDevice(captureDeviceInfo,save);
          break;
        }
      }
    }
    if (audioPlaybackDevName != null) {
      for (      CaptureDeviceInfo captureDeviceInfo : PortAudioAuto.playbackDevices) {
        if (audioPlaybackDevName.equals(captureDeviceInfo.getName())) {
          setAudioPlaybackDevice(captureDeviceInfo,save);
          break;
        }
      }
    }
    return;
  }
 else {
    logger.error(""String_Node_Str"" + name);
    audioSystem=null;
  }
  if (save) {
    config.setProperty(PROP_AUDIO_DEVICE_IS_DISABLED,audioCaptureDevice == null);
  }
}",0.9032955159373312
103484,"/** 
 * Initializes a new <tt>PortAudioAuto</tt> instance which creates PortAudio capture devices by enumerating all host devices with input channels.
 * @throws Exception if anything wrong happens while creating the PortAudiocapture devices
 */
PortAudioAuto() throws Exception {
  if (logger.isDebugEnabled())   Registry.set(""String_Node_Str"",true);
  int deviceCount=PortAudio.Pa_GetDeviceCount();
  int defaultInputDeviceIx=PortAudio.Pa_GetDefaultInputDevice();
  int defaultOutputDeviceIx=PortAudio.Pa_GetDefaultOutputDevice();
  Vector<CaptureDeviceInfo> playbackDevVector=new Vector<CaptureDeviceInfo>();
  int channels=1;
  int sampleSizeInBits=16;
  long sampleFormat=PortAudio.getPaSampleFormat(sampleSizeInBits);
  for (int deviceIndex=0; deviceIndex < deviceCount; deviceIndex++) {
    long deviceInfo=PortAudio.Pa_GetDeviceInfo(deviceIndex);
    int maxInputChannels=PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);
    int maxOutputChannels=PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);
    String devName=PortAudio.PaDeviceInfo_getName(deviceInfo);
    if (devName != null)     devName=devName.trim();
    CaptureDeviceInfo jmfInfo=new CaptureDeviceInfo(devName,new MediaLocator(LOCATOR_PROTOCOL + ""String_Node_Str"" + deviceIndex),new Format[]{new AudioFormat(AudioFormat.LINEAR,(maxInputChannels > 0) ? getSupportedSampleRate(true,deviceIndex,channels,sampleFormat) : PortAudio.DEFAULT_SAMPLE_RATE,sampleSizeInBits,channels,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,Format.byteArray)});
    if (maxInputChannels > 0)     CaptureDeviceManager.addDevice(jmfInfo);
    if (maxOutputChannels > 0)     playbackDevVector.add(jmfInfo);
    if (deviceIndex == defaultInputDeviceIx)     defaultCaptureDevice=jmfInfo;
    if (deviceIndex == defaultOutputDeviceIx)     defaultPlaybackDevice=jmfInfo;
  }
  playbackDevices=playbackDevVector.toArray(new CaptureDeviceInfo[0]);
  CaptureDeviceManager.commit();
  DeviceConfiguration.addAudioSystem(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);
  supported=true;
}","/** 
 * Initializes a new <tt>PortAudioAuto</tt> instance which creates PortAudio capture devices by enumerating all host devices with input channels.
 * @throws Exception if anything wrong happens while creating the PortAudiocapture devices
 */
PortAudioAuto() throws Exception {
  if (logger.isDebugEnabled())   Registry.set(""String_Node_Str"",true);
  int deviceCount=PortAudio.Pa_GetDeviceCount();
  int defaultInputDeviceIx=PortAudio.Pa_GetDefaultInputDevice();
  int defaultOutputDeviceIx=PortAudio.Pa_GetDefaultOutputDevice();
  Vector<CaptureDeviceInfo> playbackDevVector=new Vector<CaptureDeviceInfo>();
  int channels=1;
  int sampleSizeInBits=16;
  long sampleFormat=PortAudio.getPaSampleFormat(sampleSizeInBits);
  for (int deviceIndex=0; deviceIndex < deviceCount; deviceIndex++) {
    long deviceInfo=PortAudio.Pa_GetDeviceInfo(deviceIndex);
    int maxInputChannels=PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);
    int maxOutputChannels=PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);
    String devName=PortAudio.PaDeviceInfo_getName(deviceInfo);
    if (devName != null)     devName=devName.trim();
    CaptureDeviceInfo jmfInfo=new CaptureDeviceInfo(devName,new MediaLocator(LOCATOR_PROTOCOL + ""String_Node_Str"" + deviceIndex),new Format[]{new AudioFormat(AudioFormat.LINEAR,(maxInputChannels > 0) ? getSupportedSampleRate(true,deviceIndex,channels,sampleFormat) : PortAudio.DEFAULT_SAMPLE_RATE,sampleSizeInBits,channels,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,Format.byteArray)});
    if (maxInputChannels > 0) {
      CaptureDeviceManager.addDevice(jmfInfo);
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + devName + ""String_Node_Str"");
    }
    if (maxOutputChannels > 0) {
      playbackDevVector.add(jmfInfo);
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + devName + ""String_Node_Str"");
    }
    if (deviceIndex == defaultInputDeviceIx) {
      defaultCaptureDevice=jmfInfo;
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + devName + ""String_Node_Str"");
    }
    if (deviceIndex == defaultOutputDeviceIx) {
      defaultPlaybackDevice=jmfInfo;
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + devName + ""String_Node_Str"");
    }
  }
  playbackDevices=playbackDevVector.toArray(new CaptureDeviceInfo[0]);
  CaptureDeviceManager.commit();
  DeviceConfiguration.addAudioSystem(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);
  supported=true;
}",0.9010845986984816
103485,"/** 
 * Loads the given error message in the current dialog, by re-validating the content.
 * @param errorMessage The error message to load.
 */
private void loadErrorMessage(String errorMessage){
  JEditorPane errorMessagePane=new JEditorPane();
  errorMessagePane.setOpaque(false);
  errorMessagePane.setText(errorMessage);
  errorMessagePane.setForeground(Color.RED);
  accountPanel.add(errorMessagePane,BorderLayout.NORTH);
  accountPanel.revalidate();
  accountPanel.repaint();
  this.pack();
  this.setSize(getWidth(),getHeight() + errorMessagePane.getHeight());
}","/** 
 * Loads the given error message in the current dialog, by re-validating the content.
 * @param errorMessage The error message to load.
 */
private void loadErrorMessage(String errorMessage){
  if (errorMessagePane == null) {
    errorMessagePane=new JEditorPane();
    errorMessagePane.setOpaque(false);
    errorMessagePane.setForeground(Color.RED);
    accountPanel.add(errorMessagePane,BorderLayout.NORTH);
    if (isVisible())     pack();
    this.setSize(getWidth(),getHeight() + errorMessagePane.getHeight());
  }
  errorMessagePane.setText(errorMessage);
  accountPanel.revalidate();
  accountPanel.repaint();
}",0.6817420435510888
103486,"/** 
 * Get the output format.
 * @return output format
 * @see net.sf.fmj.media.AbstractCodec#getOutputFormat()
 */
@Override public Format getOutputFormat(){
  Format outputFormat=super.getOutputFormat();
  if ((outputFormat != null) && (outputFormat.getClass() == AudioFormat.class)) {
    AudioFormat outputAudioFormat=(AudioFormat)outputFormat;
    setOutputFormat(new AudioFormat(outputAudioFormat.getEncoding(),outputAudioFormat.getSampleRate(),outputAudioFormat.getSampleSizeInBits(),outputAudioFormat.getChannels(),outputAudioFormat.getEndian(),outputAudioFormat.getSigned(),outputAudioFormat.getFrameSizeInBits(),outputAudioFormat.getFrameRate(),outputAudioFormat.getDataType()){
      @Override public long computeDuration(      long length){
        return JNIEncoder.this.duration;
      }
    }
);
  }
  return outputFormat;
}","/** 
 * Get the output format.
 * @return output format
 * @see net.sf.fmj.media.AbstractCodec#getOutputFormat()
 */
@Override public Format getOutputFormat(){
  Format outputFormat=super.getOutputFormat();
  if ((outputFormat != null) && (outputFormat.getClass() == AudioFormat.class)) {
    AudioFormat outputAudioFormat=(AudioFormat)outputFormat;
    outputFormat=setOutputFormat(new AudioFormat(outputAudioFormat.getEncoding(),outputAudioFormat.getSampleRate(),outputAudioFormat.getSampleSizeInBits(),outputAudioFormat.getChannels(),outputAudioFormat.getEndian(),outputAudioFormat.getSigned(),outputAudioFormat.getFrameSizeInBits(),outputAudioFormat.getFrameRate(),outputAudioFormat.getDataType()){
      private static final long serialVersionUID=0L;
      @Override public long computeDuration(      long length){
        return JNIEncoder.this.duration;
      }
    }
);
  }
  return outputFormat;
}",0.9621993127147768
103487,"/** 
 * Called when this bundle is started.
 * @param bc The execution context of the bundle being started.
 * @throws Exception If
 */
public void start(BundleContext bc) throws Exception {
  bundleContext=bc;
  try {
    SystrayService systrayService=new SystrayServiceJdicImpl();
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    bundleContext.registerService(SystrayService.class.getName(),systrayService,null);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    DesktopService desktopService=new DesktopServiceImpl();
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    bundleContext.registerService(DesktopService.class.getName(),desktopService,null);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    logger.logEntry();
  }
  finally {
    logger.logExit();
  }
}","/** 
 * Called when this bundle is started.
 * @param bc The execution context of the bundle being started.
 * @throws Exception If
 */
public void start(BundleContext bc) throws Exception {
  bundleContext=bc;
  try {
    MacOSXDockIcon.addDockIconListener();
    SystrayService systrayService=new SystrayServiceJdicImpl();
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    bundleContext.registerService(SystrayService.class.getName(),systrayService,null);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    DesktopService desktopService=new DesktopServiceImpl();
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    bundleContext.registerService(DesktopService.class.getName(),desktopService,null);
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"");
    logger.logEntry();
  }
  finally {
    logger.logExit();
  }
}",0.976027397260274
103488,"/** 
 * Handles early media in 183 Session Progress responses. Retrieves the SDP and makes sure that we start transmitting and playing early media that we receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
 * @param tran the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param response the 183 <tt>Response</tt> to process
 */
public void processSessionProgress(ClientTransaction tran,Response response){
  if (response.getContentLength().getContentLength() == 0) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    return;
  }
  ContentTypeHeader contentTypeHeader=(ContentTypeHeader)response.getHeader(ContentTypeHeader.NAME);
  if (!contentTypeHeader.getContentType().equalsIgnoreCase(""String_Node_Str"") || !contentTypeHeader.getContentSubType().equalsIgnoreCase(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  try {
    getMediaHandler().processAnswer(SdpUtils.getContentAsString(response));
  }
 catch (  Exception exc) {
    logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    return;
  }
  setState(CallPeerState.CONNECTING_WITH_EARLY_MEDIA);
}","/** 
 * Handles early media in 183 Session Progress responses. Retrieves the SDP and makes sure that we start transmitting and playing early media that we receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
 * @param tran the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param response the 183 <tt>Response</tt> to process
 */
public void processSessionProgress(ClientTransaction tran,Response response){
  if (response.getContentLength().getContentLength() == 0) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    return;
  }
  ContentTypeHeader contentTypeHeader=(ContentTypeHeader)response.getHeader(ContentTypeHeader.NAME);
  if (!contentTypeHeader.getContentType().equalsIgnoreCase(""String_Node_Str"") || !contentTypeHeader.getContentSubType().equalsIgnoreCase(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  try {
    getMediaHandler().processAnswer(SdpUtils.getContentAsString(response));
  }
 catch (  Exception exc) {
    logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    return;
  }
  setState(CallPeerState.CONNECTING_WITH_EARLY_MEDIA);
  getMediaHandler().start();
  setMute(true);
}",0.981346309813463
103489,"/** 
 * Registers   {@link #CUSTOM_CODEC_FORMATS} with a specific<tt>RTPManager</tt>.
 * @param rtpManager the <tt>RTPManager</tt> to register{@link #CUSTOM_CODEC_FORMATS} with
 * @see MediaStreamImpl#registerCustomCodecFormats(RTPManager)
 */
@Override protected void registerCustomCodecFormats(RTPManager rtpManager){
  super.registerCustomCodecFormats(rtpManager);
  if (!FMJConditionals.REGISTER_FORMATS_WITH_EVERY_RTP_MANAGER && formatsRegisteredOnce)   return;
  for (  AudioFormat format : CUSTOM_CODEC_FORMATS) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + format + ""String_Node_Str"");
    rtpManager.addFormat(format,MediaUtils.getRTPPayloadType(format.getEncoding(),format.getSampleRate()));
  }
  formatsRegisteredOnce=true;
}","/** 
 * Registers   {@link #CUSTOM_CODEC_FORMATS} with a specific<tt>RTPManager</tt>.
 * @param rtpManager the <tt>RTPManager</tt> to register{@link #CUSTOM_CODEC_FORMATS} with
 * @see MediaStreamImpl#registerCustomCodecFormats(RTPManager)
 */
@Override protected void registerCustomCodecFormats(RTPManager rtpManager){
  super.registerCustomCodecFormats(rtpManager);
  for (  AudioFormat format : CUSTOM_CODEC_FORMATS) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + format + ""String_Node_Str"");
    rtpManager.addFormat(format,MediaUtils.getRTPPayloadType(format.getEncoding(),format.getSampleRate()));
  }
}",0.9076592698639944
103490,"/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null)       engine.setOwnSSRC(sendStream.getSSRC());
    }
 catch (    IOException ioe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,ioe);
    }
catch (    UnsupportedFormatException ufe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ ufe.getFailedFormat(),ufe);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}","/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  registerCustomCodecFormats(rtpManager);
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null)       engine.setOwnSSRC(sendStream.getSSRC());
    }
 catch (    IOException ioe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,ioe);
    }
catch (    UnsupportedFormatException ufe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ ufe.getFailedFormat(),ufe);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}",0.9910865874363328
103491,"/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",32000,701);
  setEncodingPreference(""String_Node_Str"",16000,700);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,0);
  setEncodingPreference(""String_Node_Str"",8000,0);
  setEncodingPreference(Constants.TELEPHONE_EVENT,8000,1);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  for (  String pName : confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false)) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1);
    if (fmtName.contains(""String_Node_Str"")) {
      fmtName=fmtName.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (confService.getString(PROP_SDP_PREFERENCE + ""String_Node_Str"" + fmtName) != null)       continue;
    }
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}","/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",32000,701);
  setEncodingPreference(""String_Node_Str"",16000,700);
  setEncodingPreference(""String_Node_Str"",8000,675);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,0);
  setEncodingPreference(Constants.TELEPHONE_EVENT,8000,1);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  for (  String pName : confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false)) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1);
    if (fmtName.contains(""String_Node_Str"")) {
      fmtName=fmtName.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (confService.getString(PROP_SDP_PREFERENCE + ""String_Node_Str"" + fmtName) != null)       continue;
    }
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}",0.9798371461806902
103492,"/** 
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int outputOffset=outputBuffer.getOffset();
  int outputLength=inputBuffer.getLength() * 4;
  byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
  g722_decoder_process(decoder,input,inputBuffer.getOffset(),output,outputOffset,outputLength);
  outputBuffer.setDuration((outputLength * 1000000L) / (16L * 2L));
  outputBuffer.setFormat(getOutputFormat());
  outputBuffer.setLength(outputLength);
  return BUFFER_PROCESSED_OK;
}","/** 
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int outputOffset=outputBuffer.getOffset();
  int outputLength=inputBuffer.getLength() * 4;
  byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
  g722_decoder_process(decoder,input,inputBuffer.getOffset(),output,outputOffset,outputLength);
  for (int i=outputOffset; i < outputLength; i+=2) {
    short sample=ArrayIOUtils.readShort(output,i);
    sample<<=2;
    ArrayIOUtils.writeShort(sample,output,i);
  }
  outputBuffer.setDuration((outputLength * 1000000L) / (16L * 2L));
  outputBuffer.setFormat(getOutputFormat());
  outputBuffer.setLength(outputLength);
  return BUFFER_PROCESSED_OK;
}",0.8888888888888888
103493,"/** 
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  byte[] input=(byte[])inputBuffer.getData();
  int outputOffset=outputBuffer.getOffset();
  int outputLength=inputBuffer.getLength() / 4;
  byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
  g722_encoder_process(encoder,input,inputBuffer.getOffset(),output,outputOffset,outputLength);
  outputBuffer.setDuration(computeDuration(outputLength));
  outputBuffer.setFormat(getOutputFormat());
  outputBuffer.setLength(outputLength);
  return BUFFER_PROCESSED_OK;
}","/** 
 * @param inputBuffer
 * @param outputBuffer
 * @return
 * @see AbstractCodecExt#doProcess(Buffer,Buffer)
 */
protected int doProcess(Buffer inputBuffer,Buffer outputBuffer){
  int inputOffset=inputBuffer.getOffset();
  int inputLength=inputBuffer.getLength();
  byte[] input=(byte[])inputBuffer.getData();
  int outputOffset=outputBuffer.getOffset();
  int outputLength=inputLength / 4;
  byte[] output=validateByteArraySize(outputBuffer,outputOffset + outputLength);
  for (int i=inputOffset; i < inputLength; i+=2) {
    short sample=ArrayIOUtils.readShort(input,i);
    sample>>>=2;
    ArrayIOUtils.writeShort(sample,input,i);
  }
  g722_encoder_process(encoder,input,inputOffset,output,outputOffset,outputLength);
  outputBuffer.setDuration(computeDuration(outputLength));
  outputBuffer.setFormat(getOutputFormat());
  outputBuffer.setLength(outputLength);
  return BUFFER_PROCESSED_OK;
}",0.8160407383831955
103494,"/** 
 * Shows this modal dialog.
 * @param isVisible specifies whether we should be showing or hiding thewindow.
 */
@Override public void setVisible(boolean isVisible){
  this.setName(""String_Node_Str"");
  pack();
  super.setVisible(isVisible);
  if (isVisible) {
    this.passwdField.requestFocus();
synchronized (lock) {
      try {
        lock.wait();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","/** 
 * Shows this modal dialog.
 * @param isVisible specifies whether we should be showing or hiding thewindow.
 */
@Override public void setVisible(boolean isVisible){
  this.setName(""String_Node_Str"");
  super.setVisible(isVisible);
  if (isVisible) {
    this.passwdField.requestFocus();
synchronized (lock) {
      try {
        lock.wait();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}",0.9888392857142856
103495,"/** 
 * Constructs the <tt>LoginWindow</tt>.
 */
private void init(){
  setTitle(UtilActivator.getResources().getI18NString(""String_Node_Str"",new String[]{server}));
  this.infoTextArea.setEditable(false);
  this.infoTextArea.setOpaque(false);
  this.infoTextArea.setLineWrap(true);
  this.infoTextArea.setWrapStyleWord(true);
  this.infoTextArea.setFont(infoTextArea.getFont().deriveFont(Font.BOLD));
  this.infoTextArea.setText(UtilActivator.getResources().getI18NString(""String_Node_Str"",new String[]{server}));
  JLabel uinLabel=new JLabel(UtilActivator.getResources().getI18NString(""String_Node_Str""));
  uinLabel.setFont(uinLabel.getFont().deriveFont(Font.BOLD));
  JLabel passwdLabel=new JLabel(UtilActivator.getResources().getI18NString(""String_Node_Str""));
  passwdLabel.setFont(passwdLabel.getFont().deriveFont(Font.BOLD));
  this.labelsPanel.add(uinLabel);
  this.labelsPanel.add(passwdLabel);
  this.labelsPanel.add(new JLabel());
  this.rememberPassCheckBox.setOpaque(false);
  this.textFieldsPanel.add(uinValue);
  this.textFieldsPanel.add(passwdField);
  this.textFieldsPanel.add(rememberPassCheckBox);
  this.buttonsPanel.add(loginButton);
  this.buttonsPanel.add(cancelButton);
  this.mainPanel.add(infoTextArea,BorderLayout.NORTH);
  this.mainPanel.add(labelsPanel,BorderLayout.WEST);
  this.mainPanel.add(textFieldsPanel,BorderLayout.CENTER);
  this.mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  this.backgroundPanel.add(mainPanel,BorderLayout.CENTER);
  this.loginButton.setName(""String_Node_Str"");
  this.cancelButton.setName(""String_Node_Str"");
  this.loginButton.setMnemonic(UtilActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.cancelButton.setMnemonic(UtilActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.loginButton.addActionListener(this);
  this.cancelButton.addActionListener(this);
  this.getRootPane().setDefaultButton(loginButton);
  this.setTransparent(true);
}","/** 
 * Constructs the <tt>LoginWindow</tt>.
 */
private void init(){
  setTitle(UtilActivator.getResources().getI18NString(""String_Node_Str"",new String[]{server}));
  infoTextArea.setEditable(false);
  infoTextArea.setOpaque(false);
  infoTextArea.setLineWrap(true);
  infoTextArea.setWrapStyleWord(true);
  infoTextArea.setFont(infoTextArea.getFont().deriveFont(Font.BOLD));
  infoTextArea.setText(UtilActivator.getResources().getI18NString(""String_Node_Str"",new String[]{server}));
  infoTextArea.setAlignmentX(0.5f);
  JLabel uinLabel=new JLabel(UtilActivator.getResources().getI18NString(""String_Node_Str""));
  uinLabel.setFont(uinLabel.getFont().deriveFont(Font.BOLD));
  JLabel passwdLabel=new JLabel(UtilActivator.getResources().getI18NString(""String_Node_Str""));
  passwdLabel.setFont(passwdLabel.getFont().deriveFont(Font.BOLD));
  TransparentPanel labelsPanel=new TransparentPanel(new GridLayout(0,1,8,8));
  labelsPanel.add(uinLabel);
  labelsPanel.add(passwdLabel);
  labelsPanel.add(new JLabel());
  this.rememberPassCheckBox.setOpaque(false);
  this.rememberPassCheckBox.setBorder(null);
  TransparentPanel textFieldsPanel=new TransparentPanel(new GridLayout(0,1,8,8));
  textFieldsPanel.add(uinValue);
  textFieldsPanel.add(passwdField);
  textFieldsPanel.add(rememberPassCheckBox);
  JPanel buttonPanel=new TransparentPanel(new FlowLayout(FlowLayout.CENTER));
  buttonPanel.add(loginButton);
  buttonPanel.add(cancelButton);
  JPanel southEastPanel=new TransparentPanel(new BorderLayout());
  southEastPanel.add(buttonPanel,BorderLayout.EAST);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(10,10));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,0,20,20));
  mainPanel.add(infoTextArea,BorderLayout.NORTH);
  mainPanel.add(labelsPanel,BorderLayout.WEST);
  mainPanel.add(textFieldsPanel,BorderLayout.CENTER);
  mainPanel.add(southEastPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel,BorderLayout.EAST);
  this.loginButton.setName(""String_Node_Str"");
  this.cancelButton.setName(""String_Node_Str"");
  this.loginButton.setMnemonic(UtilActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.cancelButton.setMnemonic(UtilActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.loginButton.addActionListener(this);
  this.cancelButton.addActionListener(this);
  this.getRootPane().setDefaultButton(loginButton);
}",0.724169741697417
103496,"/** 
 * Saves the last status for all accounts. This information is used on loging. Each time user logs in he's logged with the same status as he was the last time before closing the application.
 * @param protocolProvider the protocol provider to save status informationfor
 * @param statusName the name of the status to save
 */
protected void saveStatusInformation(ProtocolProviderService protocolProvider,String statusName){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  boolean savedAccount=false;
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
      configService.setProperty(accountRootPropName + ""String_Node_Str"",statusName);
      savedAccount=true;
    }
  }
  if (!savedAccount) {
    String accNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    String accountPackage=""String_Node_Str"" + accNodeName;
    configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
    configService.setProperty(accountPackage + ""String_Node_Str"",statusName);
  }
  this.setPreferredSize(new Dimension(28,24));
}","/** 
 * Saves the last status for all accounts. This information is used on loging. Each time user logs in he's logged with the same status as he was the last time before closing the application.
 * @param protocolProvider the protocol provider to save status informationfor
 * @param statusName the name of the status to save
 */
protected void saveStatusInformation(ProtocolProviderService protocolProvider,String statusName){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  boolean savedAccount=false;
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
      configService.setProperty(accountRootPropName + ""String_Node_Str"",statusName);
      savedAccount=true;
    }
  }
  if (!savedAccount) {
    String accNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    String accountPackage=""String_Node_Str"" + accNodeName;
    configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
    configService.setProperty(accountPackage + ""String_Node_Str"",statusName);
  }
}",0.9825083736509118
103497,"/** 
 * Paints this component. If the state of this menu is connecting, paints the connecting icon.
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  super.paintComponent(g);
  if (isConnecting)   g.drawImage(connectingIcon,0,3,this);
}","/** 
 * Paints this component. If the state of this menu is connecting, paints the connecting icon.
 * @param g the <tt>Graphics</tt> object used for painting
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  super.paintComponent(g);
  if (isConnecting)   g.drawImage(connectingIcon,0,3,this);
}",0.9043760129659644
103498,"/** 
 * Creates the ICE agent that we would be using in this transport manager for all negotiation.
 * @return the ICE agent to use for all the ICE negotiation that thistransport manager would be going through
 */
private Agent createIceAgent(){
  ProtocolProviderServiceJabberImpl provider=getCallPeer().getProtocolProvider();
  NetworkAddressManagerService namSer=getNetAddrMgr();
  Agent agent=namSer.createIceAgent();
  JabberAccountID accID=(JabberAccountID)provider.getAccountID();
  if (accID.isStunServerDiscoveryEnabled()) {
    String username=provider.getOurJID();
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(accID);
    StunCandidateHarvester autoHarvester=null;
    try {
      autoHarvester=namSer.discoverStunServer(accID.getService(),username.getBytes(""String_Node_Str""),password.getBytes(""String_Node_Str""));
      logger.info(""String_Node_Str"" + autoHarvester);
    }
 catch (    UnsupportedEncodingException exc) {
    }
    if (autoHarvester != null)     agent.addCandidateHarvester(autoHarvester);
  }
  for (  StunServerDescriptor desc : accID.getStunServers()) {
    TransportAddress addr=new TransportAddress(desc.getAddress(),desc.getPort(),Transport.UDP);
    StunCandidateHarvester harvester;
    if (desc.isTurnSupported()) {
      harvester=new TurnCandidateHarvester(addr,new LongTermCredential(desc.getUsername(),desc.getPassword()));
    }
 else {
      harvester=new StunCandidateHarvester(addr);
    }
    logger.info(""String_Node_Str"" + harvester);
    agent.addCandidateHarvester(harvester);
  }
  return agent;
}","/** 
 * Creates the ICE agent that we would be using in this transport manager for all negotiation.
 * @return the ICE agent to use for all the ICE negotiation that thistransport manager would be going through
 */
private Agent createIceAgent(){
  ProtocolProviderServiceJabberImpl provider=getCallPeer().getProtocolProvider();
  NetworkAddressManagerService namSer=getNetAddrMgr();
  Agent agent=namSer.createIceAgent();
  JabberAccountID accID=(JabberAccountID)provider.getAccountID();
  if (accID.isStunServerDiscoveryEnabled()) {
    String username=provider.getOurJID();
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(accID);
    StunCandidateHarvester autoHarvester=namSer.discoverStunServer(accID.getService(),StringUtils.getUTF8Bytes(username),StringUtils.getUTF8Bytes(password));
    logger.info(""String_Node_Str"" + autoHarvester);
    if (autoHarvester != null)     agent.addCandidateHarvester(autoHarvester);
  }
  for (  StunServerDescriptor desc : accID.getStunServers()) {
    TransportAddress addr=new TransportAddress(desc.getAddress(),desc.getPort(),Transport.UDP);
    StunCandidateHarvester harvester;
    if (desc.isTurnSupported()) {
      harvester=new TurnCandidateHarvester(addr,new LongTermCredential(desc.getUsername(),desc.getPassword()));
    }
 else {
      harvester=new StunCandidateHarvester(addr);
    }
    logger.info(""String_Node_Str"" + harvester);
    agent.addCandidateHarvester(harvester);
  }
  return agent;
}",0.9131853785900784
103499,"public Hop resolveAddress(Hop inputAddress){
  try {
    String transport=inputAddress.getTransport();
    String hostAddress=inputAddress.getHost();
    if (transport == null)     transport=ListeningPoint.UDP;
    InetSocketAddress host;
    if (NetworkUtils.isValidIPAddress(hostAddress)) {
      byte[] addr=null;
      addr=IPAddressUtil.textToNumericFormatV4(hostAddress);
      if (addr == null) {
        addr=IPAddressUtil.textToNumericFormatV6(hostAddress);
      }
      host=new InetSocketAddress(InetAddress.getByAddress(hostAddress,addr),inputAddress.getPort());
    }
 else     if (transport.equalsIgnoreCase(ListeningPoint.TLS)) {
      host=NetworkUtils.getSRVRecord(""String_Node_Str"",ListeningPoint.TCP,hostAddress);
    }
 else {
      host=NetworkUtils.getSRVRecord(""String_Node_Str"",transport,hostAddress);
    }
    if (host != null) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + host.getHostName() + ""String_Node_Str""+ host.getPort()+ ""String_Node_Str""+ transport);
      return new HopImpl(host.getHostName(),host.getPort(),transport);
    }
  }
 catch (  Exception ex) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + inputAddress + ""String_Node_Str""+ ex.getMessage());
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",ex);
  }
  Hop returnHop;
  if (inputAddress.getPort() != -1) {
    returnHop=inputAddress;
  }
 else {
    String transport=inputAddress.getTransport();
    returnHop=new HopImpl(inputAddress.getHost(),MessageProcessor.getDefaultPort(transport),transport);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + returnHop);
  return returnHop;
}","/** 
 * Implements the actual resolving. This is where we do the DNS queries.
 * @param inputAddress the unresolved <tt>Hop</tt> that we'd need to findan address for.
 * @return the newly created <tt>Hop</tt> containing the resolveddestination.
 */
public Hop resolveAddress(Hop inputAddress){
  try {
    String transport=inputAddress.getTransport();
    String hostAddress=inputAddress.getHost();
    if (transport == null)     transport=ListeningPoint.UDP;
    InetSocketAddress host;
    if (NetworkUtils.isValidIPAddress(hostAddress)) {
      byte[] addr=null;
      addr=NetworkUtils.strToIPv4(hostAddress);
      if (addr == null) {
        addr=NetworkUtils.strToIPv6(hostAddress);
      }
      host=new InetSocketAddress(InetAddress.getByAddress(hostAddress,addr),inputAddress.getPort());
    }
 else     if (transport.equalsIgnoreCase(ListeningPoint.TLS)) {
      host=NetworkUtils.getSRVRecord(""String_Node_Str"",ListeningPoint.TCP,hostAddress);
    }
 else {
      host=NetworkUtils.getSRVRecord(""String_Node_Str"",transport,hostAddress);
    }
    if (host != null) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + host.getHostName() + ""String_Node_Str""+ host.getPort()+ ""String_Node_Str""+ transport);
      return new HopImpl(host.getHostName(),host.getPort(),transport);
    }
  }
 catch (  Exception ex) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + inputAddress + ""String_Node_Str""+ ex.getMessage());
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",ex);
  }
  Hop returnHop;
  if (inputAddress.getPort() != -1) {
    returnHop=inputAddress;
  }
 else {
    String transport=inputAddress.getTransport();
    returnHop=new HopImpl(inputAddress.getHost(),MessageProcessor.getDefaultPort(transport),transport);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + returnHop);
  return returnHop;
}",0.9029045643153528
103500,"public void openURL(String url){
  new LaunchBrowser(url).start();
}","/** 
 * Creates a <tt>LaunchBrowser</tt> thread for the specified <tt>url</tt>.
 * @param url the url we'd like to launch a browser for.
 */
public void openURL(String url){
  new LaunchBrowser(url).start();
}",0.4909747292418772
103501,"public LaunchBrowser(String url){
  this.url=url;
}","/** 
 * Creates a new instance.
 * @param url the url we'd like to launch a browser for.
 */
public LaunchBrowser(String url){
  this.url=url;
}",0.5230769230769231
103502,"public void run(){
  try {
    if (OSUtils.IS_MAC) {
      FileManager.openURL(url);
    }
 else     if (OSUtils.IS_WINDOWS) {
      Runtime.getRuntime().exec(""String_Node_Str"" + url);
    }
 else {
      String[] browsers={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      String browser=null;
      for (int i=0; i < browsers.length && browser == null; i++) {
        if (Runtime.getRuntime().exec(new String[]{""String_Node_Str"",browsers[i]}).waitFor() == 0)         browser=browsers[i];
      }
      if (browser == null)       throw new Exception(""String_Node_Str"");
 else       Runtime.getRuntime().exec(new String[]{browser,url});
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * On mac, asks FileManager to open the the url, on Windows uses FileProtocolHandler to do so, on Linux, loops through a list of known browsers until we find one that seems to work.
 */
public void run(){
  try {
    if (OSUtils.IS_MAC) {
      FileManager.openURL(url);
    }
 else     if (OSUtils.IS_WINDOWS) {
      Runtime.getRuntime().exec(""String_Node_Str"" + url);
    }
 else {
      String[] browsers={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      String browser=null;
      for (int i=0; i < browsers.length && browser == null; i++) {
        if (Runtime.getRuntime().exec(new String[]{""String_Node_Str"",browsers[i]}).waitFor() == 0)         browser=browsers[i];
      }
      if (browser == null)       throw new Exception(""String_Node_Str"");
 else       Runtime.getRuntime().exec(new String[]{browser,url});
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8916619398752127
103503,"/** 
 * Starts the SIP Communicator.
 * @param args
 */
public static void main(String[] args) throws Exception {
  String version=System.getProperty(""String_Node_Str"");
  String vmVendor=System.getProperty(""String_Node_Str"");
  String osName=System.getProperty(""String_Node_Str"");
  setScHomeDir(osName);
  if (version.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"")) {
    String os=""String_Node_Str"";
    if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.MAC_OSX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.LINUX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.WINDOWS;
    ChangeJVMFrame changeJVMFrame=new ChangeJVMFrame(os);
    changeJVMFrame.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - changeJVMFrame.getWidth() / 2,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - changeJVMFrame.getHeight() / 2);
    changeJVMFrame.setVisible(true);
    return;
  }
  LaunchArgHandler argHandler=LaunchArgHandler.getInstance();
  int argHandlerRes=argHandler.handleArgs(args);
  if (argHandlerRes == LaunchArgHandler.ACTION_EXIT || argHandlerRes == LaunchArgHandler.ACTION_ERROR) {
    System.exit(argHandler.getErrorCode());
  }
  if (argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED) {
    SipCommunicatorLock lock=new SipCommunicatorLock();
    int lockResult=lock.tryLock(args);
    if (lockResult == SipCommunicatorLock.LOCK_ERROR) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      System.exit(SipCommunicatorLock.LOCK_ERROR);
    }
 else     if (lockResult == SipCommunicatorLock.ALREADY_STARTED) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      System.exit(SipCommunicatorLock.SUCCESS);
    }
 else     if (lockResult == SipCommunicatorLock.SUCCESS) {
    }
  }
  System.setOut(new ScStdOut(System.out));
  Main.main(new String[0]);
}","/** 
 * Starts the SIP Communicator.
 * @param args command line args if any
 * @throws Exception whenever it makes sense.
 */
public static void main(String[] args) throws Exception {
  String version=System.getProperty(""String_Node_Str"");
  String vmVendor=System.getProperty(""String_Node_Str"");
  String osName=System.getProperty(""String_Node_Str"");
  setScHomeDir(osName);
  if (version.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"") || vmVendor.startsWith(""String_Node_Str"")) {
    String os=""String_Node_Str"";
    if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.MAC_OSX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.LINUX;
 else     if (osName.startsWith(""String_Node_Str""))     os=ChangeJVMFrame.WINDOWS;
    ChangeJVMFrame changeJVMFrame=new ChangeJVMFrame(os);
    changeJVMFrame.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - changeJVMFrame.getWidth() / 2,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - changeJVMFrame.getHeight() / 2);
    changeJVMFrame.setVisible(true);
    return;
  }
  LaunchArgHandler argHandler=LaunchArgHandler.getInstance();
  int argHandlerRes=argHandler.handleArgs(args);
  if (argHandlerRes == LaunchArgHandler.ACTION_EXIT || argHandlerRes == LaunchArgHandler.ACTION_ERROR) {
    System.exit(argHandler.getErrorCode());
  }
  if (argHandlerRes != LaunchArgHandler.ACTION_CONTINUE_LOCK_DISABLED) {
    SipCommunicatorLock lock=new SipCommunicatorLock();
    int lockResult=lock.tryLock(args);
    if (lockResult == SipCommunicatorLock.LOCK_ERROR) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      System.exit(SipCommunicatorLock.LOCK_ERROR);
    }
 else     if (lockResult == SipCommunicatorLock.ALREADY_STARTED) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      System.exit(SipCommunicatorLock.SUCCESS);
    }
 else     if (lockResult == SipCommunicatorLock.SUCCESS) {
    }
  }
  System.setOut(new ScStdOut(System.out));
  Main.main(new String[0]);
}",0.98277117204562
103504,"/** 
 * Creates the list of additional STUN/TURN servers that are added by the user.
 * @return the created component
 */
private Component createAdditionalServersComponent(){
  table.setPreferredScrollableViewportSize(new Dimension(450,60));
  tableModel.addColumn(Resources.getString(""String_Node_Str"") + ""String_Node_Str"" + Resources.getString(""String_Node_Str""));
  tableModel.addColumn(Resources.getString(""String_Node_Str""));
  table.setDefaultRenderer(StunServerDescriptor.class,new StunServerCellRenderer());
  JScrollPane scrollPane=new JScrollPane(table);
  JButton addButton=new JButton(Resources.getString(""String_Node_Str""));
  addButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StunConfigDialog stunDialog=new StunConfigDialog();
      stunDialog.setVisible(true);
    }
  }
);
  JButton editButton=new JButton(Resources.getString(""String_Node_Str""));
  editButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StunServerDescriptor stunServer=(StunServerDescriptor)tableModel.getValueAt(table.getSelectedRow(),0);
      if (stunServer != null) {
        StunConfigDialog dialog=new StunConfigDialog(stunServer.getAddress(),stunServer.getPort(),stunServer.isTurnSupported(),StunServerDescriptor.getUTF8String(stunServer.getUsername()),StunServerDescriptor.getUTF8String(stunServer.getPassword()));
        dialog.setVisible(true);
      }
    }
  }
);
  JButton deleteButton=new JButton(Resources.getString(""String_Node_Str""));
  deleteButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tableModel.removeRow(table.getSelectedRow());
    }
  }
);
  TransparentPanel buttonsPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  buttonsPanel.add(addButton);
  buttonsPanel.add(editButton);
  buttonsPanel.add(deleteButton);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createTitledBorder(Resources.getString(""String_Node_Str"")));
  mainPanel.add(scrollPane);
  mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  return mainPanel;
}","/** 
 * Creates the list of additional STUN/TURN servers that are added by the user.
 * @return the created component
 */
private Component createAdditionalServersComponent(){
  table.setPreferredScrollableViewportSize(new Dimension(450,60));
  tableModel.addColumn(Resources.getString(""String_Node_Str"") + ""String_Node_Str"" + Resources.getString(""String_Node_Str""));
  tableModel.addColumn(Resources.getString(""String_Node_Str""));
  table.setDefaultRenderer(StunServerDescriptor.class,new StunServerCellRenderer());
  JScrollPane scrollPane=new JScrollPane(table);
  JButton addButton=new JButton(Resources.getString(""String_Node_Str""));
  addButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StunConfigDialog stunDialog=new StunConfigDialog();
      stunDialog.setVisible(true);
    }
  }
);
  JButton editButton=new JButton(Resources.getString(""String_Node_Str""));
  editButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      StunServerDescriptor stunServer=(StunServerDescriptor)tableModel.getValueAt(table.getSelectedRow(),0);
      if (stunServer != null) {
        StunConfigDialog dialog=new StunConfigDialog(stunServer.getAddress(),stunServer.getPort(),stunServer.isTurnSupported(),StringUtils.getUTF8String(stunServer.getUsername()),StringUtils.getUTF8String(stunServer.getPassword()));
        dialog.setVisible(true);
      }
    }
  }
);
  JButton deleteButton=new JButton(Resources.getString(""String_Node_Str""));
  deleteButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tableModel.removeRow(table.getSelectedRow());
    }
  }
);
  TransparentPanel buttonsPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  buttonsPanel.add(addButton);
  buttonsPanel.add(editButton);
  buttonsPanel.add(deleteButton);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createTitledBorder(Resources.getString(""String_Node_Str"")));
  mainPanel.add(scrollPane);
  mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  return mainPanel;
}",0.9875346260387812
103505,"/** 
 * Sets the password associated to this server username.
 * @param password the password to set
 */
public void setPassword(String password){
  this.password=getUTF8Bytes(password);
}","/** 
 * Sets the password associated to this server username.
 * @param password the password to set
 */
public void setPassword(String password){
  this.password=StringUtils.getUTF8Bytes(password);
}",0.9690721649484536
103506,"/** 
 * Sets the username associated to this server.
 * @param username the username to set
 */
public void setUsername(String username){
  this.username=getUTF8Bytes(username);
}","/** 
 * Sets the username associated to this server.
 * @param username the username to set
 */
public void setUsername(String username){
  this.username=StringUtils.getUTF8Bytes(username);
}",0.9675675675675676
103507,"/** 
 * Creates an instance of <tt>StunServer</tt> by specifying all parameters.
 * @param address the IP address or FQDN of the STUN server
 * @param port the port of the server
 * @param supportTurn indicates if this STUN server supports TURN
 * @param username the user name for authenticating
 * @param password the password
 */
public StunServerDescriptor(String address,int port,boolean supportTurn,String username,String password){
  this.address=address;
  this.port=port;
  this.isTurnSupported=supportTurn;
  this.username=getUTF8Bytes(username);
  this.password=getUTF8Bytes(password);
}","/** 
 * Creates an instance of <tt>StunServer</tt> by specifying all parameters.
 * @param address the IP address or FQDN of the STUN server
 * @param port the port of the server
 * @param supportTurn indicates if this STUN server supports TURN
 * @param username the user name for authenticating
 * @param password the password
 */
public StunServerDescriptor(String address,int port,boolean supportTurn,String username,String password){
  this.address=address;
  this.port=port;
  this.isTurnSupported=supportTurn;
  this.username=StringUtils.getUTF8Bytes(username);
  this.password=StringUtils.getUTF8Bytes(password);
}",0.980327868852459
103508,"/** 
 * Stores this descriptor into the specified   {@link Map}.The method is meant for use with account property maps. It also allows prepending an account prefix to all property names so that multiple descriptors can be stored in a single   {@link Map}.
 * @param props the account properties {@link Map} that we'd like to storethis descriptor in.
 * @param namePrefix the prefix that we should prepend to every propertyname.
 */
public void storeDescriptor(Map<String,String> props,String namePrefix){
  if (namePrefix == null)   namePrefix=""String_Node_Str"";
  props.put(namePrefix + STUN_ADDRESS,getAddress());
  if (getPort() != -1)   props.put(namePrefix + STUN_PORT,Integer.toString(getPort()));
  if (getUsername() != null && getUsername().length > 0)   props.put(namePrefix + STUN_USERNAME,getUTF8String(getUsername()));
  if (getPassword() != null && getPassword().length > 0)   props.put(namePrefix + STUN_PASSWORD,new String(getPassword()));
  props.put(namePrefix + STUN_IS_TURN_SUPPORTED,Boolean.toString(isTurnSupported()));
}","/** 
 * Stores this descriptor into the specified   {@link Map}.The method is meant for use with account property maps. It also allows prepending an account prefix to all property names so that multiple descriptors can be stored in a single   {@link Map}.
 * @param props the account properties {@link Map} that we'd like to storethis descriptor in.
 * @param namePrefix the prefix that we should prepend to every propertyname.
 */
public void storeDescriptor(Map<String,String> props,String namePrefix){
  if (namePrefix == null)   namePrefix=""String_Node_Str"";
  props.put(namePrefix + STUN_ADDRESS,getAddress());
  if (getPort() != -1)   props.put(namePrefix + STUN_PORT,Integer.toString(getPort()));
  if (getUsername() != null && getUsername().length > 0)   props.put(namePrefix + STUN_USERNAME,StringUtils.getUTF8String(getUsername()));
  if (getPassword() != null && getPassword().length > 0)   props.put(namePrefix + STUN_PASSWORD,new String(getPassword()));
  props.put(namePrefix + STUN_IS_TURN_SUPPORTED,Boolean.toString(isTurnSupported()));
}",0.9942748091603052
103509,"/** 
 * Creates the directory in the pattern.
 * @param pattern
 */
private static void checkDestinationDirectory(String pattern){
  try {
    int ix=pattern.lastIndexOf('/');
    if (ix != -1) {
      String dirName=pattern.substring(0,ix);
      dirName=dirName.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
      dirName=dirName.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
      new File(dirName).mkdirs();
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Creates the directory in the pattern.
 * @param pattern the directory we'd like to check.
 */
private static void checkDestinationDirectory(String pattern){
  try {
    int ix=pattern.lastIndexOf('/');
    if (ix != -1) {
      String dirName=pattern.substring(0,ix);
      dirName=dirName.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
      dirName=dirName.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
      new File(dirName).mkdirs();
    }
  }
 catch (  Exception e) {
  }
}",0.966990291262136
103510,"/** 
 * Stores XCAP_PASSWORD property.
 * @param accountID the account identifier.
 */
private void storeXCapPassword(AccountID accountID){
  CredentialsStorageService credentialsStorage=ServiceUtils.getService(getBundleContext(),CredentialsStorageService.class);
  String accountPrefix=accountID.getAccountUniqueID() + ""String_Node_Str"";
  String password=accountID.getAccountPropertyString(ProtocolProviderServiceSipImpl.XCAP_PASSWORD);
  if (password != null) {
    credentialsStorage.storePassword(accountPrefix,password);
    accountID.removeAccountProperty(ProtocolProviderServiceSipImpl.XCAP_PASSWORD);
  }
}","/** 
 * Stores XCAP_PASSWORD property.
 * @param accountID the account identifier.
 */
private void storeXCapPassword(AccountID accountID){
  Object password=accountID.getAccountProperty(ProtocolProviderServiceSipImpl.XCAP_PASSWORD);
  if (password != null) {
    CredentialsStorageService credentialsStorage=ServiceUtils.getService(getBundleContext(),CredentialsStorageService.class);
    String accountPrefix=accountID.getAccountUniqueID() + ""String_Node_Str"";
    credentialsStorage.storePassword(accountPrefix,(String)password);
    accountID.removeAccountProperty(ProtocolProviderServiceSipImpl.XCAP_PASSWORD);
  }
}",0.63915857605178
103511,"/** 
 * Ovverides the original in order not to save the XCAP_PASSWORD field.
 * @param accountID the account identifier.
 */
protected void storeAccount(AccountID accountID){
  storeXCapPassword(accountID);
  super.storeAccount(accountID);
  loadXCapPassword(accountID);
}","/** 
 * Ovverides the original in order not to save the XCAP_PASSWORD field.
 * @param accountID the account identifier.
 */
protected void storeAccount(AccountID accountID){
  storeXCapPassword(accountID);
  super.storeAccount(accountID);
}",0.9395711500974658
103512,"/** 
 * Shutdowns operation sets that need it then calls the <tt>SipRegistrarConnection.unregister()</tt> method.
 */
public void run(){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  OperationSetBasicTelephonySipImpl telephony=(OperationSetBasicTelephonySipImpl)getOperationSet(OperationSetBasicTelephony.class);
  telephony.shutdown();
  if (isRegistered()) {
    try {
      ShutdownUnregistrationBlockListener listener=new ShutdownUnregistrationBlockListener();
      addRegistrationStateChangeListener(listener);
      unregister();
      listener.waitForEvent(5000L);
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  headerFactory=null;
  messageFactory=null;
  addressFactory=null;
  sipSecurityManager=null;
  methodProcessors.clear();
  isInitialized=false;
}","/** 
 * Shutdowns operation sets that need it then calls the <tt>SipRegistrarConnection.unregister()</tt> method.
 */
public void run(){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  OperationSetBasicTelephonySipImpl telephony=(OperationSetBasicTelephonySipImpl)getOperationSet(OperationSetBasicTelephony.class);
  telephony.shutdown();
  if (isRegistered()) {
    try {
      ShutdownUnregistrationBlockListener listener=new ShutdownUnregistrationBlockListener();
      addRegistrationStateChangeListener(listener);
      unregister();
      listener.waitForEvent(3000L);
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  headerFactory=null;
  messageFactory=null;
  addressFactory=null;
  sipSecurityManager=null;
  methodProcessors.clear();
  isInitialized=false;
}",0.9988372093023256
103513,"/** 
 * Initializes the SipRegistrarConnection that this class will be using.
 * @param accountID the ID of the account that this registrar is associatedwith.
 * @throws java.lang.IllegalArgumentException if one or more accountproperties have invalid values.
 */
private void initRegistrarConnection(SipAccountID accountID) throws IllegalArgumentException {
  String registrarAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int index=userID.indexOf('@');
    if (index > -1)     registrarAddressStr=userID.substring(index + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetSocketAddress[] registrarSocketAddresses=null;
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
    if (registrarTransport == null)     registrarTransport=getDefaultTransport();
    registrarSocketAddresses=resolveSipAddress(registrarAddressStr,registrarTransport);
    accountID.putAccountProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    if (logger.isDebugEnabled())     logger.debug(registrarAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isServerValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,false);
    if (!isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (registrarSocketAddresses == null || registrarSocketAddresses.length == 0) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  registrarPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.SERVER_PORT,registrarPort);
  if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
    throw new IllegalArgumentException(registrarPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
  }
  String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    registrarTransport=ListeningPoint.UDP;
  }
  int expires=SipActivator.getConfigurationService().getInt(REGISTRATION_EXPIRATION,SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION);
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarSocketAddresses,registrarTransport,expires,this);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + registrarSocketAddresses[0].getAddress().getHostAddress(),ex);
    throw new IllegalArgumentException(""String_Node_Str"" + registrarSocketAddresses[0].getAddress().getHostAddress() + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * Initializes the SipRegistrarConnection that this class will be using.
 * @param accountID the ID of the account that this registrar is associatedwith.
 * @throws java.lang.IllegalArgumentException if one or more accountproperties have invalid values.
 */
private void initRegistrarConnection(SipAccountID accountID) throws IllegalArgumentException {
  String registrarAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int index=userID.indexOf('@');
    if (index > -1)     registrarAddressStr=userID.substring(index + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetSocketAddress[] registrarSocketAddresses=null;
  String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    registrarTransport=getDefaultTransport();
  }
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    if (accountID.getAccountProperty(ProtocolProviderFactory.SERVER_PORT) != null) {
      ArrayList<InetSocketAddress> registrarSocketAddressesList=new ArrayList<InetSocketAddress>();
      resolveAddresses(registrarAddressStr,registrarSocketAddressesList,Boolean.getBoolean(""String_Node_Str""),registrarPort);
      registrarSocketAddresses=registrarSocketAddressesList.toArray(new InetSocketAddress[0]);
    }
 else {
      registrarSocketAddresses=resolveSipAddress(registrarAddressStr,registrarTransport);
    }
    if (registrarSocketAddresses != null && registrarSocketAddresses.length > 0)     accountID.putAccountProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    if (logger.isDebugEnabled())     logger.debug(registrarAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isServerValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,false);
    if (!isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (registrarSocketAddresses == null || registrarSocketAddresses.length == 0) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  registrarPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.SERVER_PORT,registrarPort);
  if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
    throw new IllegalArgumentException(registrarPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
  }
  int expires=SipActivator.getConfigurationService().getInt(REGISTRATION_EXPIRATION,SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION);
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarSocketAddresses,registrarTransport,expires,this);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + registrarSocketAddresses[0].getAddress().getHostAddress(),ex);
    throw new IllegalArgumentException(""String_Node_Str"" + registrarSocketAddresses[0].getAddress().getHostAddress() + ""String_Node_Str""+ ex.getMessage());
  }
}",0.7488352393053791
103514,"/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  Thread t=new Thread(new ShutdownThread());
  t.setDaemon(false);
  t.start();
}","/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  new ShutdownThread().run();
}",0.8450704225352113
103515,"/** 
 * Extracts all properties concerning the usage of an outbound proxy for this account.
 * @param accountID the account whose outbound proxy we are currentlyinitializing.
 * @param ix index of the address to use.
 */
void initOutboundProxy(SipAccountID accountID,int ix){
  String proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
    proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
    if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
      return;
    }
  }
  InetAddress proxyAddress=null;
  int proxyPort=ListeningPoint.PORT_5060;
  try {
    String proxyTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
    if (proxyTransport == null)     proxyTransport=getDefaultTransport();
    InetSocketAddress proxySocketAddress=resolveSipAddress(proxyAddressStr,proxyTransport)[ix];
    proxyAddress=proxySocketAddress.getAddress();
    proxyPort=proxySocketAddress.getPort();
    proxyAddressStr=proxyAddress.getHostName();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + proxyAddressStr);
    accountID.putAccountProperty(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.error(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isProxyValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,false);
    if (!isProxyValidated) {
      throw new IllegalArgumentException(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (proxyAddressStr == null || proxyAddressStr.length() == 0 || proxyAddress == null) {
    return;
  }
  proxyPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.PROXY_PORT,proxyPort);
  if (proxyPort > NetworkUtils.MAX_PORT_NUMBER) {
    throw new IllegalArgumentException(proxyPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
  }
  String proxyTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (proxyTransport != null && proxyTransport.length() > 0) {
    if (!proxyTransport.equals(ListeningPoint.UDP) && !proxyTransport.equals(ListeningPoint.TCP) && !proxyTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(proxyTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    proxyTransport=ListeningPoint.UDP;
  }
  StringBuilder proxyStringBuffer=new StringBuilder(proxyAddress.getHostAddress());
  if (proxyAddress instanceof Inet6Address) {
    proxyStringBuffer.insert(0,'[');
    proxyStringBuffer.append(']');
  }
  proxyStringBuffer.append(':');
  proxyStringBuffer.append(Integer.toString(proxyPort));
  proxyStringBuffer.append('/');
  proxyStringBuffer.append(proxyTransport);
  this.outboundProxyString=proxyStringBuffer.toString();
  this.outboundProxySocketAddress=new InetSocketAddress(proxyAddress,proxyPort);
  this.outboundProxyTransport=proxyTransport;
}","/** 
 * Extracts all properties concerning the usage of an outbound proxy for this account.
 * @param accountID the account whose outbound proxy we are currentlyinitializing.
 * @param ix index of the address to use.
 */
void initOutboundProxy(SipAccountID accountID,int ix){
  String proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.PROXY_ADDRESS);
  boolean proxyAddressAndPortEntered=false;
  if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
    proxyAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
    if (proxyAddressStr == null || proxyAddressStr.trim().length() == 0) {
      return;
    }
  }
 else {
    if (accountID.getAccountProperty(ProtocolProviderFactory.PROXY_PORT) != null) {
      proxyAddressAndPortEntered=true;
    }
  }
  InetAddress proxyAddress=null;
  int proxyPort=ListeningPoint.PORT_5060;
  String proxyTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (proxyTransport != null && proxyTransport.length() > 0) {
    if (!proxyTransport.equals(ListeningPoint.UDP) && !proxyTransport.equals(ListeningPoint.TCP) && !proxyTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(proxyTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    proxyTransport=getDefaultTransport();
  }
  try {
    proxyPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.PROXY_PORT,proxyPort);
    if (proxyPort > NetworkUtils.MAX_PORT_NUMBER) {
      throw new IllegalArgumentException(proxyPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
    }
    InetSocketAddress proxySocketAddress=null;
    if (proxyAddressAndPortEntered) {
      ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
      resolveAddresses(proxyAddressStr,addresses,Boolean.getBoolean(""String_Node_Str""),proxyPort);
      if (addresses.size() > ix)       proxySocketAddress=addresses.get(ix);
    }
 else {
      proxySocketAddress=resolveSipAddress(proxyAddressStr,proxyTransport)[ix];
    }
    proxyAddress=proxySocketAddress.getAddress();
    proxyPort=proxySocketAddress.getPort();
    proxyAddressStr=proxyAddress.getHostName();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + proxyAddressStr);
    accountID.putAccountProperty(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.error(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    boolean isProxyValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,false);
    if (!isProxyValidated) {
      throw new IllegalArgumentException(proxyAddressStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
  if (proxyAddressStr == null || proxyAddressStr.length() == 0 || proxyAddress == null) {
    return;
  }
  StringBuilder proxyStringBuffer=new StringBuilder(proxyAddress.getHostAddress());
  if (proxyAddress instanceof Inet6Address) {
    proxyStringBuffer.insert(0,'[');
    proxyStringBuffer.append(']');
  }
  proxyStringBuffer.append(':');
  proxyStringBuffer.append(Integer.toString(proxyPort));
  proxyStringBuffer.append('/');
  proxyStringBuffer.append(proxyTransport);
  this.outboundProxyString=proxyStringBuffer.toString();
  this.outboundProxySocketAddress=new InetSocketAddress(proxyAddress,proxyPort);
  this.outboundProxyTransport=proxyTransport;
}",0.5646845211075806
103516,"/** 
 * Creates a full filename for the call by combining the directory, file prefix and extension. If the directory is <tt>null</tt> user's home directory is used.
 * @param savedCallsPath the path to the directory in which the generatedfile name is to be placed
 * @return a full filename for the call
 */
private String createDefaultFilename(String savedCallsPath){
  if (savedCallsPath == null) {
    try {
      savedCallsPath=GuiActivator.getFileAccessService().getDefaultDownloadDirectory().getAbsolutePath();
    }
 catch (    IOException ioex) {
    }
  }
  String ext=configuration.getString(Recorder.CALL_FORMAT);
  if ((ext == null) || (ext.length() == 0) || !isSupportedFormat(ext))   ext=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
  return ((savedCallsPath == null) ? ""String_Node_Str"" : (savedCallsPath + File.separator)) + generateCallFilename(ext);
}","/** 
 * Creates a full filename for the call by combining the directory, file prefix and extension. If the directory is <tt>null</tt> user's home directory is used.
 * @param savedCallsPath the path to the directory in which the generatedfile name is to be placed
 * @return a full filename for the call
 */
private String createDefaultFilename(String savedCallsPath){
  if (savedCallsPath == null) {
    try {
      savedCallsPath=GuiActivator.getFileAccessService().getDefaultDownloadDirectory().getAbsolutePath();
    }
 catch (    IOException ioex) {
    }
  }
  String ext=configuration.getString(Recorder.FORMAT);
  if ((ext == null) || (ext.length() == 0) || !isSupportedFormat(ext))   ext=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
  return ((savedCallsPath == null) ? ""String_Node_Str"" : (savedCallsPath + File.separator)) + generateCallFilename(ext);
}",0.9971181556195964
103517,"/** 
 * Starts/stops the recording of the call when this button is pressed.
 * @param evt the <tt>ActionEvent</tt> that notified us of the action
 */
public void actionPerformed(ActionEvent evt){
  if (call != null) {
    if (isSelected()) {
      boolean startedRecording=false;
      try {
        startedRecording=startRecording();
      }
  finally {
        if (!startedRecording && (recorder != null)) {
          try {
            recorder.stop();
          }
  finally {
            recorder=null;
          }
        }
        setSelected(startedRecording);
      }
    }
 else     if (recorder != null) {
      try {
        recorder.stop();
        NotificationManager.fireNotification(NotificationManager.CALL_SAVED,resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str"",new String[]{callFilename}));
      }
  finally {
        recorder=null;
        setSelected(false);
      }
    }
  }
}","/** 
 * Starts/stops the recording of the call when this button is pressed.
 * @param evt the <tt>ActionEvent</tt> that notified us of the action
 */
public void actionPerformed(ActionEvent evt){
  if (call != null) {
    if (isSelected()) {
      boolean startedRecording=false;
      try {
        startedRecording=startRecording();
      }
  finally {
        if (!startedRecording && (recorder != null)) {
          try {
            recorder.stop();
          }
  finally {
            recorder=null;
          }
        }
        setSelected(startedRecording);
      }
      if (startedRecording && (recorder != null)) {
        recorder.addListener(new Recorder.Listener(){
          public void recorderStopped(          Recorder recorder){
            NotificationManager.fireNotification(NotificationManager.CALL_SAVED,resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str"",new String[]{callFilename}));
          }
        }
);
      }
    }
 else     if (recorder != null) {
      try {
        recorder.stop();
      }
  finally {
        recorder=null;
        setSelected(false);
      }
    }
  }
}",0.8570052961001444
103518,"/** 
 * Starts recording   {@link #call} creating {@link #recorder} first andasking the user for the recording format and file if they are not configured in the ""Call Recording"" configuration form.
 * @return <tt>true</tt> if the recording has been started successfully;otherwise, <tt>false</tt>
 */
private boolean startRecording(){
  String savedCallsPath=configuration.getString(Recorder.SAVED_CALLS_PATH);
  if ((savedCallsPath == null) || (savedCallsPath.length() == 0)) {
    if (callFileChooser == null) {
      callFileChooser=GenericFileDialog.create(null,resources.getI18NString(""String_Node_Str""),SipCommFileChooser.SAVE_FILE_OPERATION);
      callFileChooser.addFilter(new SipCommFileFilter(){
        public boolean accept(        File f){
          return f.isDirectory() || isSupportedFormat(f);
        }
        public String getDescription(){
          StringBuilder description=new StringBuilder();
          description.append(""String_Node_Str"");
          Recorder recorder;
          try {
            recorder=getRecorder();
          }
 catch (          OperationFailedException ofex) {
            logger.error(""String_Node_Str"",ofex);
            recorder=null;
          }
          if (recorder != null) {
            List<String> supportedFormats=recorder.getSupportedFormats();
            if (supportedFormats != null) {
              description.append(""String_Node_Str"");
              boolean firstSupportedFormat=true;
              for (              String supportedFormat : supportedFormats) {
                if (firstSupportedFormat)                 firstSupportedFormat=false;
 else                 description.append(""String_Node_Str"");
                description.append(""String_Node_Str"");
                description.append(supportedFormat);
              }
              description.append(')');
            }
          }
          return description.toString();
        }
      }
);
    }
    callFileChooser.setStartPath(createDefaultFilename(null));
    File selectedFile=callFileChooser.getFileFromDialog();
    if (selectedFile != null) {
      callFilename=selectedFile.getAbsolutePath();
      String callFormat=SoundFileUtils.getExtension(selectedFile);
      if ((callFormat != null) && (callFormat.length() != 0)) {
        if (!isSupportedFormat(selectedFile)) {
          if (SoundFileUtils.isSoundFile(selectedFile)) {
            callFilename=callFilename.substring(0,callFilename.lastIndexOf('.'));
          }
          callFormat=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
          callFilename+='.' + callFormat;
        }
        configuration.setProperty(Recorder.CALL_FORMAT,callFormat);
      }
    }
 else {
      return false;
    }
  }
 else   callFilename=createDefaultFilename(savedCallsPath);
  Throwable exception=null;
  try {
    Recorder recorder=getRecorder();
    if (recorder != null)     recorder.start(callFilename);
    this.recorder=recorder;
  }
 catch (  IOException ioex) {
    exception=ioex;
  }
catch (  MediaException mex) {
    exception=mex;
  }
catch (  OperationFailedException ofex) {
    exception=ofex;
  }
  if ((recorder == null) || (exception != null)) {
    logger.error(""String_Node_Str"" + call + ""String_Node_Str""+ callFilename,exception);
    return false;
  }
 else   return true;
}","/** 
 * Starts recording   {@link #call} creating {@link #recorder} first andasking the user for the recording format and file if they are not configured in the ""Call Recording"" configuration form.
 * @return <tt>true</tt> if the recording has been started successfully;otherwise, <tt>false</tt>
 */
private boolean startRecording(){
  String savedCallsPath=configuration.getString(Recorder.SAVED_CALLS_PATH);
  String callFormat;
  if ((savedCallsPath == null) || (savedCallsPath.length() == 0)) {
    if (callFileChooser == null) {
      callFileChooser=GenericFileDialog.create(null,resources.getI18NString(""String_Node_Str""),SipCommFileChooser.SAVE_FILE_OPERATION);
      callFileChooser.addFilter(new SipCommFileFilter(){
        public boolean accept(        File f){
          return f.isDirectory() || isSupportedFormat(f);
        }
        public String getDescription(){
          StringBuilder description=new StringBuilder();
          description.append(""String_Node_Str"");
          Recorder recorder;
          try {
            recorder=getRecorder();
          }
 catch (          OperationFailedException ofex) {
            logger.error(""String_Node_Str"",ofex);
            recorder=null;
          }
          if (recorder != null) {
            List<String> supportedFormats=recorder.getSupportedFormats();
            if (supportedFormats != null) {
              description.append(""String_Node_Str"");
              boolean firstSupportedFormat=true;
              for (              String supportedFormat : supportedFormats) {
                if (firstSupportedFormat)                 firstSupportedFormat=false;
 else                 description.append(""String_Node_Str"");
                description.append(""String_Node_Str"");
                description.append(supportedFormat);
              }
              description.append(')');
            }
          }
          return description.toString();
        }
      }
);
    }
    callFileChooser.setStartPath(createDefaultFilename(null));
    File selectedFile=callFileChooser.getFileFromDialog();
    if (selectedFile != null) {
      callFilename=selectedFile.getAbsolutePath();
      callFormat=SoundFileUtils.getExtension(selectedFile);
      if ((callFormat != null) && (callFormat.length() != 0)) {
        if (!isSupportedFormat(selectedFile)) {
          if (SoundFileUtils.isSoundFile(selectedFile)) {
            callFilename=callFilename.substring(0,callFilename.lastIndexOf('.'));
          }
          callFormat=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
          callFilename+='.' + callFormat;
        }
        configuration.setProperty(Recorder.FORMAT,callFormat);
      }
    }
 else {
      return false;
    }
  }
 else {
    callFilename=createDefaultFilename(savedCallsPath);
    callFormat=SoundFileUtils.getExtension(new File(callFilename));
  }
  Throwable exception=null;
  try {
    Recorder recorder=getRecorder();
    if (recorder != null) {
      if ((callFormat == null) || (callFormat.length() <= 0))       callFormat=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
      recorder.start(callFormat,callFilename);
    }
    this.recorder=recorder;
  }
 catch (  IOException ioex) {
    exception=ioex;
  }
catch (  MediaException mex) {
    exception=mex;
  }
catch (  OperationFailedException ofex) {
    exception=ofex;
  }
  if ((recorder == null) || (exception != null)) {
    logger.error(""String_Node_Str"" + call + ""String_Node_Str""+ callFilename,exception);
    return false;
  }
 else   return true;
}",0.952911838051929
103519,"/** 
 * Returns the string to be used as the tooltip for <i>event</i>. 
 * @param event the <tt>MouseEvent</tt> 
 * @return the string to be used as the tooltip for <i>event</i>.
 */
public String getToolTipText(MouseEvent event){
  if (currentHref != null && currentHref.length() != 0)   return currentHref;
 else   return null;
}","/** 
 * Returns the string to be used as the tooltip for <i>event</i>. 
 * @param event the <tt>MouseEvent</tt> 
 * @return the string to be used as the tooltip for <i>event</i>.
 */
@Override public String getToolTipText(MouseEvent event){
  return ((currentHref != null) && (currentHref.length() != 0)) ? currentHref : null;
}",0.9044006069802732
103520,"public void itemStateChanged(ItemEvent event){
  if (event.getStateChange() == ItemEvent.SELECTED) {
    NeomediaActivator.getConfigurationService().setProperty(Recorder.CALL_FORMAT,event.getItem());
  }
}","public void itemStateChanged(ItemEvent event){
  if (event.getStateChange() == ItemEvent.SELECTED) {
    NeomediaActivator.getConfigurationService().setProperty(Recorder.FORMAT,event.getItem());
  }
}",0.9876543209876544
103521,"/** 
 * Creates a combo box with supported audio formats.
 * @return a combo box with supported audio formats
 */
private Component createFormatsComboBox(){
  ComboBoxModel formatsComboBoxModel=new DefaultComboBoxModel(RecorderImpl.SUPPORTED_FORMATS);
  formatsComboBox=new JComboBox();
  formatsComboBox.setPreferredSize(new Dimension(200,30));
  formatsComboBox.setModel(formatsComboBoxModel);
  formatsComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      if (event.getStateChange() == ItemEvent.SELECTED) {
        NeomediaActivator.getConfigurationService().setProperty(Recorder.CALL_FORMAT,event.getItem());
      }
    }
  }
);
  return formatsComboBox;
}","/** 
 * Creates a combo box with supported audio formats.
 * @return a combo box with supported audio formats
 */
private Component createFormatsComboBox(){
  ComboBoxModel formatsComboBoxModel=new DefaultComboBoxModel(RecorderImpl.SUPPORTED_FORMATS);
  formatsComboBox=new JComboBox();
  formatsComboBox.setPreferredSize(new Dimension(200,30));
  formatsComboBox.setModel(formatsComboBoxModel);
  formatsComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      if (event.getStateChange() == ItemEvent.SELECTED) {
        NeomediaActivator.getConfigurationService().setProperty(Recorder.FORMAT,event.getItem());
      }
    }
  }
);
  return formatsComboBox;
}",0.9964862965565706
103522,"/** 
 * Loads values from the configuration and sets the UI components to these values.
 */
private void loadValues(){
  ConfigurationService configurationService=NeomediaActivator.getConfigurationService();
  String callFormat=configurationService.getString(Recorder.CALL_FORMAT);
  formatsComboBox.setSelectedItem((callFormat == null) ? SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT : callFormat);
  savedCallsDir=configurationService.getString(Recorder.SAVED_CALLS_PATH);
  saveCallsToCheckBox.setSelected(savedCallsDir != null);
  callDirTextField.setText(savedCallsDir);
  callDirTextField.setEnabled(saveCallsToCheckBox.isSelected());
  callDirChooseButton.setEnabled(saveCallsToCheckBox.isSelected());
}","/** 
 * Loads values from the configuration and sets the UI components to these values.
 */
private void loadValues(){
  ConfigurationService configuration=NeomediaActivator.getConfigurationService();
  String format=configuration.getString(Recorder.FORMAT);
  formatsComboBox.setSelectedItem((format == null) ? SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT : format);
  savedCallsDir=configuration.getString(Recorder.SAVED_CALLS_PATH);
  saveCallsToCheckBox.setSelected(savedCallsDir != null);
  callDirTextField.setText(savedCallsDir);
  callDirTextField.setEnabled(saveCallsToCheckBox.isSelected());
  callDirChooseButton.setEnabled(saveCallsToCheckBox.isSelected());
}",0.9681159420289857
103523,"public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  ProtocolProviderService pps=(ProtocolProviderService)value;
  OperationSetPresence presence=pps.getOperationSet(OperationSetPresence.class);
  this.setText(pps.getAccountID().getDisplayName());
  if (presence.getPresenceStatus() != null) {
    byte[] protocolStatusImage=presence.getPresenceStatus().getStatusIcon();
    if (protocolStatusImage != null) {
      this.setIcon(new ImageIcon(protocolStatusImage));
    }
 else {
      this.setIcon(null);
    }
  }
  if (isSelected)   this.setBackground(table.getSelectionBackground());
 else   this.setBackground(UIManager.getColor(""String_Node_Str""));
  return this;
}","public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  ProtocolProviderService pps=(ProtocolProviderService)value;
  OperationSetPresence presence=pps.getOperationSet(OperationSetPresence.class);
  if (presence != null) {
    byte[] protocolStatusImage=presence.getPresenceStatus().getStatusIcon();
    if (protocolStatusImage != null) {
      this.setIcon(new ImageIcon(protocolStatusImage));
    }
 else {
      this.setIcon(null);
    }
  }
  this.setText(pps.getAccountID().getDisplayName());
  if (isSelected)   this.setBackground(table.getSelectionBackground());
 else   this.setBackground(UIManager.getColor(""String_Node_Str""));
  return this;
}",0.6508795669824087
103524,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState().equals(RegistrationState.UNREGISTERING)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    cancelTimer();
    ssContactList.destroy();
    try {
      publishPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE),""String_Node_Str"");
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
    }
    stopEvents();
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    ssContactList.init();
    if ((!presenceEnabled) || (pollingTask != null)) {
      return;
    }
    for (    ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {
      forcePollContact(contact);
    }
    pollingTask=new PollOfflineContactsTask();
    timer.schedule(pollingTask,pollingTaskPeriod,pollingTaskPeriod);
  }
 else   if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    ssContactList.destroy();
    for (    ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {
      PresenceStatus oldContactStatus=contact.getPresenceStatus();
      if (subscriber != null) {
        try {
          subscriber.removeSubscription(getAddress(contact));
        }
 catch (        OperationFailedException ex) {
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"" + contact);
          }
        }
      }
      if (!oldContactStatus.isOnline()) {
        continue;
      }
      contact.setPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE));
      fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus);
    }
    cancelTimer();
    waitedCallIds.clear();
    fireProviderStatusChangeEvent(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE));
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState().equals(RegistrationState.UNREGISTERING)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    cancelTimer();
    ssContactList.destroy();
    try {
      publishPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE),""String_Node_Str"");
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
    }
    stopEvents();
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    ssContactList.init();
    if ((!presenceEnabled) || (pollingTask != null)) {
      return;
    }
    for (    ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {
      forcePollContact(contact);
    }
    pollingTask=new PollOfflineContactsTask();
    timer.schedule(pollingTask,pollingTaskPeriod,pollingTaskPeriod);
  }
 else   if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    ssContactList.destroy();
    for (    ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {
      PresenceStatus oldContactStatus=contact.getPresenceStatus();
      if (subscriber != null) {
        try {
          subscriber.removeSubscription(getAddress(contact));
        }
 catch (        OperationFailedException ex) {
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"" + contact);
          }
        }
      }
      if (!oldContactStatus.isOnline()) {
        continue;
      }
      contact.setPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE));
      fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus);
    }
    cancelTimer();
    waitedCallIds.clear();
    try {
      publishPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE),""String_Node_Str"");
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}",0.9658478130617136
103525,"/** 
 * Whether portaudio is supported.
 * @return the supported
 */
public static boolean isSupported(){
  return supported;
}","/** 
 * Determines whether PortAudio is supported.
 * @return <tt>true</tt> if PortAudio is supported; otherwise,<tt>false</tt>
 */
public static boolean isSupported(){
  return supported;
}",0.7760252365930599
103526,"/** 
 * Initializes a new <tt>PortAudioAuto</tt> instance which creates PortAudio capture devices by enumerating all host devices with input channels.
 * @throws Exception if anything wrong happens while creating the PortAudiocapture devices
 */
PortAudioAuto() throws Exception {
  if (logger.isDebugEnabled())   Registry.set(""String_Node_Str"",true);
  int deviceCount=PortAudio.Pa_GetDeviceCount();
  int defaultInputDeviceIx=PortAudio.Pa_GetDefaultInputDevice();
  int defaultOutputDeviceIx=PortAudio.Pa_GetDefaultOutputDevice();
  Vector<CaptureDeviceInfo> playbackDevVector=new Vector<CaptureDeviceInfo>();
  int channels=1;
  int sampleSizeInBits=16;
  long sampleFormat=PortAudio.getPaSampleFormat(sampleSizeInBits);
  for (int deviceIndex=0; deviceIndex < deviceCount; deviceIndex++) {
    long deviceInfo=PortAudio.Pa_GetDeviceInfo(deviceIndex);
    int maxInputChannels=PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);
    int maxOutputChannels=PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);
    String devName=PortAudio.PaDeviceInfo_getCharsetAwareName(deviceInfo);
    if (devName != null)     devName=devName.trim();
    CaptureDeviceInfo jmfInfo=new CaptureDeviceInfo(devName,new MediaLocator(LOCATOR_PROTOCOL + ""String_Node_Str"" + deviceIndex),new Format[]{new AudioFormat(AudioFormat.LINEAR,(maxInputChannels > 0) ? getSupportedSampleRate(true,deviceIndex,channels,sampleFormat) : PortAudio.DEFAULT_SAMPLE_RATE,sampleSizeInBits,channels,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,Format.byteArray)});
    if (maxInputChannels > 0)     CaptureDeviceManager.addDevice(jmfInfo);
    if (maxOutputChannels > 0)     playbackDevVector.add(jmfInfo);
    if (deviceIndex == defaultInputDeviceIx)     defaultCaptureDevice=jmfInfo;
    if (deviceIndex == defaultOutputDeviceIx)     defaultPlaybackDevice=jmfInfo;
  }
  playbackDevices=playbackDevVector.toArray(new CaptureDeviceInfo[0]);
  CaptureDeviceManager.commit();
  DeviceConfiguration.addAudioSystem(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);
  try {
    ConfigurationService config=NeomediaActivator.getConfigurationService();
    boolean echoCancelEnabled=config.getBoolean(DeviceConfiguration.PROP_AUDIO_ECHOCANCEL_ENABLED,PortAudioManager.isEnabledEchoCancel());
    if (echoCancelEnabled) {
      long echoCancelFilterLengthInMillis=config.getLong(DeviceConfiguration.PROP_AUDIO_ECHOCANCEL_FILTER_LENGTH_IN_MILLIS,PortAudioManager.getFilterLengthInMillis());
      PortAudioManager.setEchoCancel(echoCancelEnabled,echoCancelFilterLengthInMillis);
    }
    boolean denoiseEnabled=config.getBoolean(DeviceConfiguration.PROP_AUDIO_DENOISE_ENABLED,PortAudioManager.isEnabledDeNoise());
    PortAudioManager.setDeNoise(denoiseEnabled);
    int defaultAudioLatency=(int)(PortAudioManager.getSuggestedLatency() * 1000);
    int audioLatency=config.getInt(DeviceConfiguration.PROP_AUDIO_LATENCY,defaultAudioLatency);
    if (audioLatency != defaultAudioLatency)     PortAudioManager.setSuggestedLatency((double)audioLatency / 1000d);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  supported=true;
}","/** 
 * Initializes a new <tt>PortAudioAuto</tt> instance which creates PortAudio capture devices by enumerating all host devices with input channels.
 * @throws Exception if anything wrong happens while creating the PortAudiocapture devices
 */
PortAudioAuto() throws Exception {
  if (logger.isDebugEnabled())   Registry.set(""String_Node_Str"",true);
  int deviceCount=PortAudio.Pa_GetDeviceCount();
  int defaultInputDeviceIx=PortAudio.Pa_GetDefaultInputDevice();
  int defaultOutputDeviceIx=PortAudio.Pa_GetDefaultOutputDevice();
  Vector<CaptureDeviceInfo> playbackDevVector=new Vector<CaptureDeviceInfo>();
  int channels=1;
  int sampleSizeInBits=16;
  long sampleFormat=PortAudio.getPaSampleFormat(sampleSizeInBits);
  for (int deviceIndex=0; deviceIndex < deviceCount; deviceIndex++) {
    long deviceInfo=PortAudio.Pa_GetDeviceInfo(deviceIndex);
    int maxInputChannels=PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);
    int maxOutputChannels=PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);
    String devName=PortAudio.PaDeviceInfo_getCharsetAwareName(deviceInfo);
    if (devName != null)     devName=devName.trim();
    CaptureDeviceInfo jmfInfo=new CaptureDeviceInfo(devName,new MediaLocator(LOCATOR_PROTOCOL + ""String_Node_Str"" + deviceIndex),new Format[]{new AudioFormat(AudioFormat.LINEAR,(maxInputChannels > 0) ? getSupportedSampleRate(true,deviceIndex,channels,sampleFormat) : PortAudio.DEFAULT_SAMPLE_RATE,sampleSizeInBits,channels,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,Format.byteArray)});
    if (maxInputChannels > 0)     CaptureDeviceManager.addDevice(jmfInfo);
    if (maxOutputChannels > 0)     playbackDevVector.add(jmfInfo);
    if (deviceIndex == defaultInputDeviceIx)     defaultCaptureDevice=jmfInfo;
    if (deviceIndex == defaultOutputDeviceIx)     defaultPlaybackDevice=jmfInfo;
  }
  playbackDevices=playbackDevVector.toArray(new CaptureDeviceInfo[0]);
  CaptureDeviceManager.commit();
  DeviceConfiguration.addAudioSystem(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);
  try {
    ConfigurationService config=NeomediaActivator.getConfigurationService();
    boolean echoCancelEnabled=config.getBoolean(DeviceConfiguration.PROP_AUDIO_ECHOCANCEL_ENABLED,PortAudioManager.isEnabledEchoCancel());
    long echoCancelFilterLengthInMillis=PortAudioManager.getFilterLengthInMillis();
    if (echoCancelEnabled) {
      echoCancelFilterLengthInMillis=config.getLong(DeviceConfiguration.PROP_AUDIO_ECHOCANCEL_FILTER_LENGTH_IN_MILLIS,echoCancelFilterLengthInMillis);
    }
    PortAudioManager.setEchoCancel(echoCancelEnabled,echoCancelFilterLengthInMillis);
    boolean denoiseEnabled=config.getBoolean(DeviceConfiguration.PROP_AUDIO_DENOISE_ENABLED,PortAudioManager.isEnabledDeNoise());
    PortAudioManager.setDeNoise(denoiseEnabled);
    int defaultAudioLatency=(int)(PortAudioManager.getSuggestedLatency() * 1000);
    int audioLatency=config.getInt(DeviceConfiguration.PROP_AUDIO_LATENCY,defaultAudioLatency);
    if (audioLatency != defaultAudioLatency)     PortAudioManager.setSuggestedLatency((double)audioLatency / 1000d);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
  supported=true;
}",0.9511543898225224
103527,"/** 
 * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
 * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;<tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to construct or send theINVITE request putting the remote side on/off hold.
 */
public void putOnHold(boolean onHold) throws OperationFailedException {
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  mediaHandler.setLocallyOnHold(onHold);
  SessionInfoType type;
  if (onHold)   type=SessionInfoType.hold;
 else   type=SessionInfoType.unhold;
  reevalLocalHoldStatus();
  JingleIQ onHoldIQ=JinglePacketFactory.createSessionInfo(getProtocolProvider().getOurJID(),peerJID,getJingleSID(),type);
  getProtocolProvider().getConnection().sendPacket(onHoldIQ);
}","/** 
 * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
 * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;<tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to construct or send theINVITE request putting the remote side on/off hold.
 */
public void putOnHold(boolean onHold) throws OperationFailedException {
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  mediaHandler.setLocallyOnHold(onHold);
  SessionInfoType type;
  if (onHold)   type=SessionInfoType.hold;
 else {
    type=SessionInfoType.unhold;
    getMediaHandler().reinitAllContents();
  }
  reevalLocalHoldStatus();
  JingleIQ onHoldIQ=JinglePacketFactory.createSessionInfo(getProtocolProvider().getOurJID(),peerJID,getJingleSID(),type);
  getProtocolProvider().getConnection().sendPacket(onHoldIQ);
}",0.9691096305269532
103528,"/** 
 * Sets our state to CONNECTED, sends an ACK and processes the SDP description in the <tt>ok</tt> <tt>Response</tt>.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
public void processInviteOK(ClientTransaction clientTransaction,Response ok){
  try {
    getProtocolProvider().sendAck(clientTransaction);
  }
 catch (  InvalidArgumentException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
catch (  SipException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
  try {
    if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {
      getMediaHandler().processAnswer(SdpUtils.getContentAsString(ok));
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    try {
      setState(CallPeerState.CONNECTED);
      hangup();
    }
 catch (    Exception e) {
    }
 finally {
      logAndFail(""String_Node_Str"",exc);
    }
    return;
  }
  if (!CallPeerState.isOnHold(getState())) {
    setState(CallPeerState.CONNECTED);
    if (isMute() != this.getCall().isMute())     setMute(this.getCall().isMute());
  }
  fireResponseProcessed(ok,null);
}","/** 
 * Sets our state to CONNECTED, sends an ACK and processes the SDP description in the <tt>ok</tt> <tt>Response</tt>.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
public void processInviteOK(ClientTransaction clientTransaction,Response ok){
  try {
    getProtocolProvider().sendAck(clientTransaction);
  }
 catch (  InvalidArgumentException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
catch (  SipException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
  try {
    if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {
      getMediaHandler().processAnswer(SdpUtils.getContentAsString(ok));
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    try {
      setState(CallPeerState.CONNECTED);
      hangup();
    }
 catch (    Exception e) {
    }
 finally {
      logAndFail(""String_Node_Str"",exc);
    }
    return;
  }
  if (!CallPeerState.isOnHold(getState())) {
    setState(CallPeerState.CONNECTED);
    getMediaHandler().start();
    if (isMute() != this.getCall().isMute())     setMute(this.getCall().isMute());
  }
  fireResponseProcessed(ok,null);
}",0.9879705083430346
103529,"/** 
 * Updates the session description and sends the state of the corresponding call peer to CONNECTED.
 * @param serverTransaction the transaction that the ACK was received in.
 * @param ack the ACK <tt>Request</tt> we need to process
 */
public void processAck(ServerTransaction serverTransaction,Request ack){
  ContentLengthHeader contentLength=ack.getContentLength();
  if ((contentLength != null) && (contentLength.getContentLength() > 0)) {
    try {
      getMediaHandler().processAnswer(SdpUtils.getContentAsString(ack));
    }
 catch (    Exception exc) {
      logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
      return;
    }
  }
  CallPeerState peerState=getState();
  if (!CallPeerState.isOnHold(peerState)) {
    setState(CallPeerState.CONNECTED);
    if (isMute() != this.getCall().isMute())     setMute(this.getCall().isMute());
  }
}","/** 
 * Updates the session description and sends the state of the corresponding call peer to CONNECTED.
 * @param serverTransaction the transaction that the ACK was received in.
 * @param ack the ACK <tt>Request</tt> we need to process
 */
public void processAck(ServerTransaction serverTransaction,Request ack){
  ContentLengthHeader contentLength=ack.getContentLength();
  if ((contentLength != null) && (contentLength.getContentLength() > 0)) {
    try {
      getMediaHandler().processAnswer(SdpUtils.getContentAsString(ack));
    }
 catch (    Exception exc) {
      logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
      return;
    }
  }
  CallPeerState peerState=getState();
  if (!CallPeerState.isOnHold(peerState)) {
    setState(CallPeerState.CONNECTED);
    getMediaHandler().start();
    if (isMute() != this.getCall().isMute())     setMute(this.getCall().isMute());
  }
}",0.9833064081852452
103530,"/** 
 * Starts/stops the recording of the call when this button is pressed.
 * @param evt the <tt>ActionEvent</tt> that notified us of the action
 */
public void actionPerformed(ActionEvent evt){
  if (call != null) {
    if (isSelected()) {
      startRecording();
    }
 else     if (recorder != null) {
      try {
        recorder.stop();
        NotificationManager.fireNotification(NotificationManager.CALL_SAVED,resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str"",new String[]{callFilename}));
      }
  finally {
        recorder=null;
      }
    }
  }
}","/** 
 * Starts/stops the recording of the call when this button is pressed.
 * @param evt the <tt>ActionEvent</tt> that notified us of the action
 */
public void actionPerformed(ActionEvent evt){
  if (call != null) {
    if (isSelected()) {
      boolean startedRecording=false;
      try {
        startedRecording=startRecording();
      }
  finally {
        if (!startedRecording && (recorder != null)) {
          try {
            recorder.stop();
          }
  finally {
            recorder=null;
          }
        }
        setSelected(startedRecording);
      }
    }
 else     if (recorder != null) {
      try {
        recorder.stop();
        NotificationManager.fireNotification(NotificationManager.CALL_SAVED,resources.getI18NString(""String_Node_Str""),resources.getI18NString(""String_Node_Str"",new String[]{callFilename}));
      }
  finally {
        recorder=null;
        setSelected(false);
      }
    }
  }
}",0.7534336167429693
103531,"/** 
 * Initializes a new <tt>RecordButton</tt> instance which is to record the audio stream.
 * @param call the <tt>Call</tt> to be associated with the new instance andto have its audio stream recorded
 * @param fullScreen <tt>true</tt> if the new instance is to be used infull-screen UI; otherwise, <tt>false</tt>
 * @param selected <tt>true</tt> if the new toggle button is to be initiallyselected; otherwise, <tt>false</tt>
 */
public RecordButton(Call call,boolean fullScreen,boolean selected){
  super(call,fullScreen,selected,ImageLoader.RECORD_BUTTON,null);
  callFileChooser=GenericFileDialog.create(null,resources.getI18NString(""String_Node_Str""),SipCommFileChooser.SAVE_FILE_OPERATION);
  callFileChooser.addFilter(new SipCommFileFilter(){
    public boolean accept(    File f){
      return f.isDirectory() || isSupportedFormat(f);
    }
    public String getDescription(){
      StringBuilder description=new StringBuilder();
      description.append(""String_Node_Str"");
      Recorder recorder;
      try {
        recorder=getRecorder();
      }
 catch (      OperationFailedException ofex) {
        logger.error(""String_Node_Str"",ofex);
        recorder=null;
      }
      if (recorder != null) {
        List<String> supportedFormats=recorder.getSupportedFormats();
        if (supportedFormats != null) {
          description.append(""String_Node_Str"");
          boolean firstSupportedFormat=true;
          for (          String supportedFormat : supportedFormats) {
            if (firstSupportedFormat)             firstSupportedFormat=false;
 else             description.append(""String_Node_Str"");
            description.append(""String_Node_Str"");
            description.append(supportedFormat);
          }
          description.append(')');
        }
      }
      return description.toString();
    }
  }
);
  String toolTip=resources.getI18NString(""String_Node_Str"");
  String saveDir=configuration.getString(Recorder.SAVED_CALLS_PATH);
  if ((saveDir != null) && (saveDir.length() != 0))   toolTip+=""String_Node_Str"" + saveDir + ""String_Node_Str"";
  setToolTipText(toolTip);
}","/** 
 * Initializes a new <tt>RecordButton</tt> instance which is to record the audio stream.
 * @param call the <tt>Call</tt> to be associated with the new instance andto have its audio stream recorded
 * @param fullScreen <tt>true</tt> if the new instance is to be used infull-screen UI; otherwise, <tt>false</tt>
 * @param selected <tt>true</tt> if the new toggle button is to be initiallyselected; otherwise, <tt>false</tt>
 */
public RecordButton(Call call,boolean fullScreen,boolean selected){
  super(call,fullScreen,selected,ImageLoader.RECORD_BUTTON,null);
  String toolTip=resources.getI18NString(""String_Node_Str"");
  String saveDir=configuration.getString(Recorder.SAVED_CALLS_PATH);
  if ((saveDir != null) && (saveDir.length() != 0))   toolTip+=""String_Node_Str"" + saveDir + ""String_Node_Str"";
  setToolTipText(toolTip);
}",0.567741935483871
103532,"/** 
 * Starts recording   {@link #call} creating {@link #recorder} first andasking the user for the recording format and file if they are not configured in the ""Call Recording"" configuration form.
 */
private void startRecording(){
  String savedCallsPath=configuration.getString(Recorder.SAVED_CALLS_PATH);
  if ((savedCallsPath == null) || (savedCallsPath.length() == 0)) {
    callFileChooser.setStartPath(createDefaultFilename(null));
    File selectedFile=callFileChooser.getFileFromDialog();
    if (selectedFile != null) {
      callFilename=selectedFile.getAbsolutePath();
      String callFormat=SoundFileUtils.getExtension(selectedFile);
      if ((callFormat != null) && (callFormat.length() != 0)) {
        if (!isSupportedFormat(selectedFile)) {
          if (SoundFileUtils.isSoundFile(selectedFile)) {
            callFilename=callFilename.substring(0,callFilename.lastIndexOf('.'));
          }
          callFormat=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
          callFilename+='.' + callFormat;
        }
        configuration.setProperty(Recorder.CALL_FORMAT,callFormat);
      }
    }
 else {
      setSelected(false);
      if (recorder != null) {
        try {
          recorder.stop();
        }
  finally {
          recorder=null;
        }
      }
      return;
    }
  }
 else   callFilename=createDefaultFilename(savedCallsPath);
  Throwable exception=null;
  try {
    Recorder recorder=getRecorder();
    if (recorder != null)     recorder.start(callFilename);
    this.recorder=recorder;
  }
 catch (  IOException ioex) {
    exception=ioex;
  }
catch (  MediaException mex) {
    exception=mex;
  }
catch (  OperationFailedException ofex) {
    exception=ofex;
  }
  if ((recorder == null) || (exception != null)) {
    logger.error(""String_Node_Str"" + call + ""String_Node_Str""+ callFilename,exception);
    if (recorder != null) {
      try {
        recorder.stop();
      }
  finally {
        recorder=null;
      }
    }
  }
  setSelected(recorder != null);
}","/** 
 * Starts recording   {@link #call} creating {@link #recorder} first andasking the user for the recording format and file if they are not configured in the ""Call Recording"" configuration form.
 * @return <tt>true</tt> if the recording has been started successfully;otherwise, <tt>false</tt>
 */
private boolean startRecording(){
  String savedCallsPath=configuration.getString(Recorder.SAVED_CALLS_PATH);
  if ((savedCallsPath == null) || (savedCallsPath.length() == 0)) {
    if (callFileChooser == null) {
      callFileChooser=GenericFileDialog.create(null,resources.getI18NString(""String_Node_Str""),SipCommFileChooser.SAVE_FILE_OPERATION);
      callFileChooser.addFilter(new SipCommFileFilter(){
        public boolean accept(        File f){
          return f.isDirectory() || isSupportedFormat(f);
        }
        public String getDescription(){
          StringBuilder description=new StringBuilder();
          description.append(""String_Node_Str"");
          Recorder recorder;
          try {
            recorder=getRecorder();
          }
 catch (          OperationFailedException ofex) {
            logger.error(""String_Node_Str"",ofex);
            recorder=null;
          }
          if (recorder != null) {
            List<String> supportedFormats=recorder.getSupportedFormats();
            if (supportedFormats != null) {
              description.append(""String_Node_Str"");
              boolean firstSupportedFormat=true;
              for (              String supportedFormat : supportedFormats) {
                if (firstSupportedFormat)                 firstSupportedFormat=false;
 else                 description.append(""String_Node_Str"");
                description.append(""String_Node_Str"");
                description.append(supportedFormat);
              }
              description.append(')');
            }
          }
          return description.toString();
        }
      }
);
    }
    callFileChooser.setStartPath(createDefaultFilename(null));
    File selectedFile=callFileChooser.getFileFromDialog();
    if (selectedFile != null) {
      callFilename=selectedFile.getAbsolutePath();
      String callFormat=SoundFileUtils.getExtension(selectedFile);
      if ((callFormat != null) && (callFormat.length() != 0)) {
        if (!isSupportedFormat(selectedFile)) {
          if (SoundFileUtils.isSoundFile(selectedFile)) {
            callFilename=callFilename.substring(0,callFilename.lastIndexOf('.'));
          }
          callFormat=SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT;
          callFilename+='.' + callFormat;
        }
        configuration.setProperty(Recorder.CALL_FORMAT,callFormat);
      }
    }
 else {
      return false;
    }
  }
 else   callFilename=createDefaultFilename(savedCallsPath);
  Throwable exception=null;
  try {
    Recorder recorder=getRecorder();
    if (recorder != null)     recorder.start(callFilename);
    this.recorder=recorder;
  }
 catch (  IOException ioex) {
    exception=ioex;
  }
catch (  MediaException mex) {
    exception=mex;
  }
catch (  OperationFailedException ofex) {
    exception=ofex;
  }
  if ((recorder == null) || (exception != null)) {
    logger.error(""String_Node_Str"" + call + ""String_Node_Str""+ callFilename,exception);
    return false;
  }
 else   return true;
}",0.6355916210605774
103533,"/** 
 * @return
 * @see AbstractCodec#getOutputFormat()
 */
@Override public Format getOutputFormat(){
  Format outputFormat=super.getOutputFormat();
  if ((outputFormat != null) && (outputFormat.getClass() == AudioFormat.class)) {
    AudioFormat outputAudioFormat=(AudioFormat)outputFormat;
    setOutputFormat(new AudioFormat(outputAudioFormat.getEncoding(),outputAudioFormat.getSampleRate(),outputAudioFormat.getSampleSizeInBits(),outputAudioFormat.getChannels(),outputAudioFormat.getEndian(),outputAudioFormat.getSigned(),outputAudioFormat.getFrameSizeInBits(),outputAudioFormat.getFrameRate(),outputAudioFormat.getDataType()){
      @Override public long computeDuration(      long length){
        return JNIEncoder.this.duration;
      }
    }
);
  }
  return outputFormat;
}","/** 
 * @return
 * @see net.sf.fmj.media.AbstractCodec#getOutputFormat()
 */
@Override public Format getOutputFormat(){
  Format outputFormat=super.getOutputFormat();
  if ((outputFormat != null) && (outputFormat.getClass() == AudioFormat.class)) {
    AudioFormat outputAudioFormat=(AudioFormat)outputFormat;
    setOutputFormat(new AudioFormat(outputAudioFormat.getEncoding(),outputAudioFormat.getSampleRate(),outputAudioFormat.getSampleSizeInBits(),outputAudioFormat.getChannels(),outputAudioFormat.getEndian(),outputAudioFormat.getSigned(),outputAudioFormat.getFrameSizeInBits(),outputAudioFormat.getFrameRate(),outputAudioFormat.getDataType()){
      @Override public long computeDuration(      long length){
        return JNIEncoder.this.duration;
      }
    }
);
  }
  return outputFormat;
}",0.989260897030954
103534,"/** 
 * Initializes a new <tt>AudioMixer</tt> instance. Because JMF's <tt>Manager.createMergingDataSource(DataSource[])</tt> requires the implementation of <tt>CaptureDevice</tt> for audio if it is implemented for video and it is indeed the cause for our use case of <tt>AudioMixingPushBufferDataSource</tt>, the new <tt>AudioMixer</tt> instance provides specified <tt>CaptureDevice</tt> capabilities to the <tt>AudioMixingPushBufferDataSource</tt>s it creates. The specified <tt>CaptureDevice</tt> is also added as the first input <tt>DataSource</tt> of the new instance.
 * @param captureDevice the <tt>CaptureDevice</tt> capabilities to beprovided to the <tt>AudioMixingPushBufferDataSource</tt>s created by the new instance and its first input <tt>DataSource</tt>
 */
public AudioMixer(CaptureDevice captureDevice){
  if (captureDevice instanceof PullBufferDataSource)   captureDevice=new PushBufferDataSourceAdapter((PullBufferDataSource)captureDevice);
  if (logger.isTraceEnabled())   captureDevice=MediaDeviceImpl.createTracingCaptureDevice(captureDevice,logger);
  this.captureDevice=captureDevice;
  this.localOutputDataSource=createOutputDataSource();
  addInputDataSource((DataSource)this.captureDevice,this.localOutputDataSource);
}","/** 
 * Initializes a new <tt>AudioMixer</tt> instance. Because JMF's <tt>Manager.createMergingDataSource(DataSource[])</tt> requires the implementation of <tt>CaptureDevice</tt> for audio if it is implemented for video and it is indeed the cause for our use case of <tt>AudioMixingPushBufferDataSource</tt>, the new <tt>AudioMixer</tt> instance provides specified <tt>CaptureDevice</tt> capabilities to the <tt>AudioMixingPushBufferDataSource</tt>s it creates. The specified <tt>CaptureDevice</tt> is also added as the first input <tt>DataSource</tt> of the new instance.
 * @param captureDevice the <tt>CaptureDevice</tt> capabilities to beprovided to the <tt>AudioMixingPushBufferDataSource</tt>s created by the new instance and its first input <tt>DataSource</tt>
 */
public AudioMixer(CaptureDevice captureDevice){
  if (captureDevice instanceof PullBufferDataSource) {
    captureDevice=new PushBufferDataSourceAdapter((PullBufferDataSource)captureDevice);
  }
  if (logger.isTraceEnabled()) {
    captureDevice=MediaDeviceImpl.createTracingCaptureDevice(captureDevice,logger);
  }
  this.captureDevice=captureDevice;
  this.localOutputDataSource=createOutputDataSource();
  addInputDataSource((DataSource)this.captureDevice,this.localOutputDataSource);
}",0.9936153232242618
103535,"/** 
 * Gets the <tt>SourceStream</tt>s (in the form of <tt>InputStreamDesc</tt>) of a specific <tt>DataSource</tt> (provided in the form of <tt>InputDataSourceDesc</tt>) which produce data in a specific <tt>AudioFormat</tt> (or a matching one).
 * @param inputDataSourceDesc the <tt>DataSource</tt> (in the form of <tt>InputDataSourceDesc</tt>) which is to be examined for <tt>SourceStreams</tt> producing data in the specified <tt>AudioFormat</tt>
 * @param outputFormat the <tt>AudioFormat</tt> in which the collected <tt>SourceStream</tt>s are to produce data
 * @param existingInputStreams
 * @param inputStreams the <tt>List</tt> of <tt>InputStreamDesc</tt> in which the discovered <tt>SourceStream</tt>s are to be returned
 * @return <tt>true</tt> if <tt>SourceStream</tt>s produced by thespecified input <tt>DataSource</tt> and outputting data in the specified <tt>AudioFormat</tt> were discovered and reported in <tt>inputStreams</tt>; otherwise, <tt>false</tt>
 */
private boolean getInputStreamsFromInputDataSource(InputDataSourceDesc inputDataSourceDesc,AudioFormat outputFormat,InputStreamDesc[] existingInputStreams,List<InputStreamDesc> inputStreams){
  SourceStream[] inputDataSourceStreams=inputDataSourceDesc.getStreams();
  if (inputDataSourceStreams != null) {
    boolean added=false;
    for (    SourceStream inputStream : inputDataSourceStreams) {
      Format inputFormat=getFormat(inputStream);
      if ((inputFormat != null) && matches(inputFormat,outputFormat)) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(inputStream,inputDataSourceDesc);
        if (inputStreams.add(inputStreamDesc))         added=true;
      }
    }
    return added;
  }
  DataSource inputDataSource=inputDataSourceDesc.getEffectiveInputDataSource();
  if (inputDataSource == null)   return false;
  Format inputFormat=getFormat(inputDataSource);
  if ((inputFormat != null) && !matches(inputFormat,outputFormat)) {
    if (inputDataSource instanceof PushDataSource) {
      for (      PushSourceStream inputStream : ((PushDataSource)inputDataSource).getStreams()) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(new PushBufferStreamAdapter(inputStream,inputFormat),inputDataSourceDesc);
        inputStreams.add(inputStreamDesc);
      }
      return true;
    }
    if (inputDataSource instanceof PullDataSource) {
      for (      PullSourceStream inputStream : ((PullDataSource)inputDataSource).getStreams()) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(new PullBufferStreamAdapter(inputStream,inputFormat),inputDataSourceDesc);
        inputStreams.add(inputStreamDesc);
      }
      return true;
    }
  }
  return false;
}","/** 
 * Gets the <tt>SourceStream</tt>s (in the form of <tt>InputStreamDesc</tt>) of a specific <tt>DataSource</tt> (provided in the form of <tt>InputDataSourceDesc</tt>) which produce data in a specific <tt>AudioFormat</tt> (or a matching one).
 * @param inputDataSourceDesc the <tt>DataSource</tt> (in the form of<tt>InputDataSourceDesc</tt>) which is to be examined for <tt>SourceStreams</tt> producing data in the specified <tt>AudioFormat</tt>
 * @param outputFormat the <tt>AudioFormat</tt> in which the collected<tt>SourceStream</tt>s are to produce data
 * @param existingInputStreams the <tt>InputStreamDesc</tt> instances whichalready exist and which are used to avoid creating multiple <tt>InputStreamDesc</tt>s for input <tt>SourceStream</tt>s which already have ones
 * @param inputStreams the <tt>List</tt> of <tt>InputStreamDesc</tt> inwhich the discovered <tt>SourceStream</tt>s are to be returned
 * @return <tt>true</tt> if <tt>SourceStream</tt>s produced by the specifiedinput <tt>DataSource</tt> and outputting data in the specified <tt>AudioFormat</tt> were discovered and reported in <tt>inputStreams</tt>; otherwise, <tt>false</tt>
 */
private boolean getInputStreamsFromInputDataSource(InputDataSourceDesc inputDataSourceDesc,AudioFormat outputFormat,InputStreamDesc[] existingInputStreams,List<InputStreamDesc> inputStreams){
  SourceStream[] inputDataSourceStreams=inputDataSourceDesc.getStreams();
  if (inputDataSourceStreams != null) {
    boolean added=false;
    for (    SourceStream inputStream : inputDataSourceStreams) {
      Format inputFormat=getFormat(inputStream);
      if ((inputFormat != null) && matches(inputFormat,outputFormat)) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(inputStream,inputDataSourceDesc);
        if (inputStreams.add(inputStreamDesc))         added=true;
      }
    }
    return added;
  }
  DataSource inputDataSource=inputDataSourceDesc.getEffectiveInputDataSource();
  if (inputDataSource == null)   return false;
  Format inputFormat=getFormat(inputDataSource);
  if ((inputFormat != null) && !matches(inputFormat,outputFormat)) {
    if (inputDataSource instanceof PushDataSource) {
      for (      PushSourceStream inputStream : ((PushDataSource)inputDataSource).getStreams()) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(new PushBufferStreamAdapter(inputStream,inputFormat),inputDataSourceDesc);
        inputStreams.add(inputStreamDesc);
      }
      return true;
    }
    if (inputDataSource instanceof PullDataSource) {
      for (      PullSourceStream inputStream : ((PullDataSource)inputDataSource).getStreams()) {
        InputStreamDesc inputStreamDesc=getExistingInputStreamDesc(inputStream,existingInputStreams);
        if (inputStreamDesc == null)         inputStreamDesc=createInputStreamDesc(new PullBufferStreamAdapter(inputStream,inputFormat),inputDataSourceDesc);
        inputStreams.add(inputStreamDesc);
      }
      return true;
    }
  }
  return false;
}",0.9666348903717826
103536,"/** 
 * Adds a new input <tt>DataSource</tt> to the collection of input <tt>DataSource</tt>s from which this instance reads audio. If the specified <tt>DataSource</tt> indeed provides audio, the respective contributions to the mix will be excluded from the mix output provided through a specific <tt>AudioMixingPushBufferDataSource</tt>.
 * @param inputDataSource a new <tt>DataSource</tt> to input audio to thisinstance
 * @param outputDataSource the <tt>AudioMixingPushBufferDataSource</tt> tonot include the audio contributions of <tt>inputDataSource</tt> in the mix it outputs
 */
void addInputDataSource(DataSource inputDataSource,AudioMixingPushBufferDataSource outputDataSource){
  if (inputDataSource == null)   throw new IllegalArgumentException(""String_Node_Str"");
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     if (inputDataSource.equals(inputDataSourceDesc.inputDataSource))     throw new IllegalArgumentException(""String_Node_Str"");
    InputDataSourceDesc inputDataSourceDesc=new InputDataSourceDesc(inputDataSource,outputDataSource);
    boolean added=inputDataSources.add(inputDataSourceDesc);
    if (added) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + inputDataSource.hashCode());
      if (connected > 0)       try {
        inputDataSourceDesc.connect(this);
      }
 catch (      IOException ioex) {
        throw new UndeclaredThrowableException(ioex);
      }
      if (outputStream != null)       getOutputStream();
      if (started > 0)       try {
        inputDataSourceDesc.start();
      }
 catch (      IOException ioe) {
        throw new UndeclaredThrowableException(ioe);
      }
    }
  }
}","/** 
 * Adds a new input <tt>DataSource</tt> to the collection of input <tt>DataSource</tt>s from which this instance reads audio. If the specified <tt>DataSource</tt> indeed provides audio, the respective contributions to the mix will be excluded from the mix output provided through a specific <tt>AudioMixingPushBufferDataSource</tt>.
 * @param inputDataSource a new <tt>DataSource</tt> to input audio to thisinstance
 * @param outputDataSource the <tt>AudioMixingPushBufferDataSource</tt> tonot include the audio contributions of <tt>inputDataSource</tt> in the mix it outputs
 */
void addInputDataSource(DataSource inputDataSource,AudioMixingPushBufferDataSource outputDataSource){
  if (inputDataSource == null)   throw new IllegalArgumentException(""String_Node_Str"");
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     if (inputDataSource.equals(inputDataSourceDesc.inputDataSource))     throw new IllegalArgumentException(""String_Node_Str"");
    InputDataSourceDesc inputDataSourceDesc=new InputDataSourceDesc(inputDataSource,outputDataSource);
    boolean added=inputDataSources.add(inputDataSourceDesc);
    if (added) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + inputDataSource.hashCode());
      if (connected > 0) {
        try {
          inputDataSourceDesc.connect(this);
        }
 catch (        IOException ioex) {
          throw new UndeclaredThrowableException(ioex);
        }
      }
      if (outputStream != null)       getOutputStream();
      if (started > 0) {
        try {
          inputDataSourceDesc.start();
        }
 catch (        IOException ioe) {
          throw new UndeclaredThrowableException(ioe);
        }
      }
    }
  }
}",0.9873708381171068
103537,"/** 
 * Starts the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to start. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> starts if it hasn't started yet. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to start it
 */
void start(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.start();
    started++;
  }
}","/** 
 * Starts the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to start. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> starts if it hasn't started yet. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to start it
 */
void start(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started == 0) {
      for (      InputDataSourceDesc inputDataSourceDesc : inputDataSources)       inputDataSourceDesc.start();
    }
    started++;
  }
}",0.991898148148148
103538,"/** 
 * Stops the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to stop. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> stops. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to stop it
 */
void stop(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started <= 0)     return;
    started--;
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.stop();
  }
}","/** 
 * Stops the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to stop. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> stops. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to stop it
 */
void stop(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started <= 0)     return;
    started--;
    if (started == 0) {
      for (      InputDataSourceDesc inputDataSourceDesc : inputDataSources)       inputDataSourceDesc.stop();
    }
  }
}",0.9919261822376008
103539,"/** 
 * Removes <tt>DataSource</tt>s accepted by a specific <tt>DataSourceFilter</tt> from the list of input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> from which it reads audio to be mixed.
 * @param dataSourceFilter the <tt>DataSourceFilter</tt> which selects the<tt>DataSource</tt>s to be removed from the list of input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> from which it reads audio to be mixed
 */
public void removeInputDataSources(DataSourceFilter dataSourceFilter){
synchronized (inputDataSources) {
    Iterator<InputDataSourceDesc> inputDataSourceIter=inputDataSources.iterator();
    boolean removed=false;
    while (inputDataSourceIter.hasNext())     if (dataSourceFilter.accept(inputDataSourceIter.next().inputDataSource)) {
      inputDataSourceIter.remove();
      removed=true;
    }
    if (removed && (outputStream != null))     getOutputStream();
  }
}","/** 
 * Removes <tt>DataSource</tt>s accepted by a specific <tt>DataSourceFilter</tt> from the list of input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> from which it reads audio to be mixed.
 * @param dataSourceFilter the <tt>DataSourceFilter</tt> which selects the<tt>DataSource</tt>s to be removed from the list of input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> from which it reads audio to be mixed
 */
public void removeInputDataSources(DataSourceFilter dataSourceFilter){
synchronized (inputDataSources) {
    Iterator<InputDataSourceDesc> inputDataSourceIter=inputDataSources.iterator();
    boolean removed=false;
    while (inputDataSourceIter.hasNext()) {
      if (dataSourceFilter.accept(inputDataSourceIter.next().inputDataSource)) {
        inputDataSourceIter.remove();
        removed=true;
      }
    }
    if (removed && (outputStream != null))     getOutputStream();
  }
}",0.9910813823857302
103540,"/** 
 * Returns a Contact header containing a sip URI based on a localhost address and therefore usable in REGISTER requests only.
 * @param intendedDestination the destination that we plan to be sendingthis contact header to.
 * @return a Contact header based upon a local inet address.
 */
public ContactHeader getContactHeader(SipURI intendedDestination){
  ContactHeader registrationContactHeader=null;
  ListeningPoint srcListeningPoint=getListeningPoint(intendedDestination);
  InetAddress targetAddress=getIntendedDestination(intendedDestination);
  try {
    InetAddress localAddress=SipActivator.getNetworkAddressManagerService().getLocalHost(targetAddress);
    SipURI contactURI=addressFactory.createSipURI(getAccountID().getUserID(),localAddress.getHostAddress());
    String transport=srcListeningPoint.getTransport();
    contactURI.setTransportParam(transport);
    int localPort=srcListeningPoint.getPort();
    if (ListeningPoint.TCP.equalsIgnoreCase(transport)) {
      InetAddress intendedDestinationAddress=NetworkUtils.getInetAddress(intendedDestination.getHost());
      int dstPort=intendedDestination.getPort();
      if (!targetAddress.equals(intendedDestinationAddress) && getOutboundProxy() != null)       dstPort=getOutboundProxy().getPort();
      if (dstPort == -1)       dstPort=5060;
      InetSocketAddress localSockAddr=sipStackSharing.obtainLocalAddress(targetAddress,dstPort,localAddress);
      localPort=localSockAddr.getPort();
    }
    contactURI.setPort(localPort);
    String paramValue=getContactAddressCustomParamValue();
    if (paramValue != null) {
      contactURI.setParameter(SipStackSharing.CONTACT_ADDRESS_CUSTOM_PARAM_NAME,paramValue);
    }
    Address contactAddress=addressFactory.createAddress(contactURI);
    String ourDisplayName=getOurDisplayName();
    if (ourDisplayName != null) {
      contactAddress.setDisplayName(ourDisplayName);
    }
    registrationContactHeader=headerFactory.createContactHeader(contactAddress);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + registrationContactHeader);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
catch (  java.io.IOException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  return registrationContactHeader;
}","/** 
 * Returns a Contact header containing a sip URI based on a localhost address and therefore usable in REGISTER requests only.
 * @param intendedDestination the destination that we plan to be sendingthis contact header to.
 * @return a Contact header based upon a local inet address.
 */
public ContactHeader getContactHeader(SipURI intendedDestination){
  ContactHeader registrationContactHeader=null;
  ListeningPoint srcListeningPoint=getListeningPoint(intendedDestination);
  InetSocketAddress targetAddress=getIntendedDestination(intendedDestination);
  try {
    InetAddress localAddress=SipActivator.getNetworkAddressManagerService().getLocalHost(targetAddress.getAddress());
    SipURI contactURI=addressFactory.createSipURI(getAccountID().getUserID(),localAddress.getHostAddress());
    String transport=srcListeningPoint.getTransport();
    contactURI.setTransportParam(transport);
    int localPort=srcListeningPoint.getPort();
    if (ListeningPoint.TCP.equalsIgnoreCase(transport)) {
      InetSocketAddress localSockAddr=sipStackSharing.obtainLocalAddress(targetAddress.getAddress(),targetAddress.getPort(),localAddress);
      localPort=localSockAddr.getPort();
    }
    contactURI.setPort(localPort);
    String paramValue=getContactAddressCustomParamValue();
    if (paramValue != null) {
      contactURI.setParameter(SipStackSharing.CONTACT_ADDRESS_CUSTOM_PARAM_NAME,paramValue);
    }
    Address contactAddress=addressFactory.createAddress(contactURI);
    String ourDisplayName=getOurDisplayName();
    if (ourDisplayName != null) {
      contactAddress.setDisplayName(ourDisplayName);
    }
    registrationContactHeader=headerFactory.createContactHeader(contactAddress);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + registrationContactHeader);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
catch (  java.io.IOException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  return registrationContactHeader;
}",0.8814159292035398
103541,"/** 
 * Returns the SIP address of record (Display Name <user@server.net>) that this account is created for. The method takes into account whether or not we are running in Registar or ""No Registar"" mode and either returns the AOR we are using to register or an address constructed using the local address
 * @param intendedDestination the destination that we would be using thelocal address to communicate with. .
 * @return our Address Of Record that we should use in From headers.
 */
public Address getOurSipAddress(SipURI intendedDestination){
  SipRegistrarConnection src=getRegistrarConnection();
  if (src != null && !src.isRegistrarless())   return src.getAddressOfRecord();
  InetAddress destinationAddr=getIntendedDestination(intendedDestination);
  InetAddress localHost=SipActivator.getNetworkAddressManagerService().getLocalHost(destinationAddr);
  String userID=getAccountID().getUserID();
  try {
    SipURI ourSipURI=getAddressFactory().createSipURI(userID,localHost.getHostAddress());
    ListeningPoint lp=getListeningPoint(intendedDestination);
    ourSipURI.setTransportParam(lp.getTransport());
    ourSipURI.setPort(lp.getPort());
    Address ourSipAddress=getAddressFactory().createAddress(getOurDisplayName(),ourSipURI);
    ourSipAddress.setDisplayName(getOurDisplayName());
    return ourSipAddress;
  }
 catch (  ParseException exc) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",exc);
    throw new IllegalArgumentException(""String_Node_Str"",exc);
  }
}","/** 
 * Returns the SIP address of record (Display Name <user@server.net>) that this account is created for. The method takes into account whether or not we are running in Registar or ""No Registar"" mode and either returns the AOR we are using to register or an address constructed using the local address
 * @param intendedDestination the destination that we would be using thelocal address to communicate with. .
 * @return our Address Of Record that we should use in From headers.
 */
public Address getOurSipAddress(SipURI intendedDestination){
  SipRegistrarConnection src=getRegistrarConnection();
  if (src != null && !src.isRegistrarless())   return src.getAddressOfRecord();
  InetSocketAddress destinationAddr=getIntendedDestination(intendedDestination);
  InetAddress localHost=SipActivator.getNetworkAddressManagerService().getLocalHost(destinationAddr.getAddress());
  String userID=getAccountID().getUserID();
  try {
    SipURI ourSipURI=getAddressFactory().createSipURI(userID,localHost.getHostAddress());
    ListeningPoint lp=getListeningPoint(intendedDestination);
    ourSipURI.setTransportParam(lp.getTransport());
    ourSipURI.setPort(lp.getPort());
    Address ourSipAddress=getAddressFactory().createAddress(getOurDisplayName(),ourSipURI);
    ourSipAddress.setDisplayName(getOurDisplayName());
    return ourSipAddress;
  }
 catch (  ParseException exc) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"",exc);
    throw new IllegalArgumentException(""String_Node_Str"",exc);
  }
}",0.9937231582424844
103542,"/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting the specified <tt>destination</tt>. This is an utility method that is used whenever we have to choose one of our local addresses to put in the Via, Contact or (in the case of no registrar accounts) From headers. The method also takes into account the existence of an outbound proxy and in that case returns its address as the next hop.
 * @param host the destination that we would contact.
 * @return the <tt>InetAddress</tt> that is most likely to be to be usedas a next hop when contacting the specified <tt>destination</tt>.
 * @throws IllegalArgumentException if <tt>destination</tt> is not a validhost/ip/fqdn.
 */
public InetAddress getIntendedDestination(String host) throws IllegalArgumentException {
  InetAddress destinationInetAddress=null;
  InetSocketAddress outboundProxy=getOutboundProxy();
  if (outboundProxy != null) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    destinationInetAddress=outboundProxy.getAddress();
  }
 else {
    try {
      destinationInetAddress=resolveSipAddress(host).getAddress();
    }
 catch (    UnknownHostException ex) {
      throw new IllegalArgumentException(host + ""String_Node_Str"",ex);
    }
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + destinationInetAddress + ""String_Node_Str""+ host);
  return destinationInetAddress;
}","/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting the specified <tt>destination</tt>. This is an utility method that is used whenever we have to choose one of our local addresses to put in the Via, Contact or (in the case of no registrar accounts) From headers. The method also takes into account the existence of an outbound proxy and in that case returns its address as the next hop.
 * @param host the destination that we would contact.
 * @return the <tt>InetSocketAddress</tt> that is most likely to be to beused as a next hop when contacting the specified <tt>destination</tt>.
 * @throws IllegalArgumentException if <tt>destination</tt> is not a validhost/ip/fqdn.
 */
public InetSocketAddress getIntendedDestination(String host) throws IllegalArgumentException {
  InetSocketAddress destinationInetAddress=null;
  InetSocketAddress outboundProxy=getOutboundProxy();
  if (outboundProxy != null) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"");
    destinationInetAddress=outboundProxy;
  }
 else {
    try {
      destinationInetAddress=resolveSipAddress(host);
    }
 catch (    UnknownHostException ex) {
      throw new IllegalArgumentException(host + ""String_Node_Str"",ex);
    }
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + destinationInetAddress + ""String_Node_Str""+ host);
  return destinationInetAddress;
}",0.981145251396648
103543,"/** 
 * Initializes and returns an ArrayList with a single ViaHeader containing a localhost address usable with the specified s<tt>destination</tt>. This ArrayList may be used when sending requests to that destination. <p>
 * @param intendedDestination The address of the destination that therequest using the via headers will be sent to.
 * @return ViaHeader-s list to be used when sending requests.
 * @throws OperationFailedException code INTERNAL_ERROR if a ParseExceptionoccurs while initializing the array list.
 */
public ArrayList<ViaHeader> getLocalViaHeaders(SipURI intendedDestination) throws OperationFailedException {
  ArrayList<ViaHeader> viaHeaders=new ArrayList<ViaHeader>();
  ListeningPoint srcListeningPoint=getListeningPoint(intendedDestination.getTransportParam());
  try {
    InetAddress localAddress=SipActivator.getNetworkAddressManagerService().getLocalHost(getIntendedDestination(intendedDestination));
    int localPort=srcListeningPoint.getPort();
    String transport=srcListeningPoint.getTransport();
    if (ListeningPoint.TCP.equalsIgnoreCase(transport)) {
      int dstPort=intendedDestination.getPort();
      if (dstPort == -1)       dstPort=5060;
      InetSocketAddress localSockAddr=sipStackSharing.obtainLocalAddress(NetworkUtils.getInetAddress(intendedDestination.getHost()),dstPort,localAddress);
      localPort=localSockAddr.getPort();
    }
    ViaHeader viaHeader=headerFactory.createViaHeader(localAddress.getHostAddress(),localPort,transport,null);
    viaHeaders.add(viaHeader);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + viaHeader);
    return viaHeaders;
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),ex);
    throw new OperationFailedException(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  java.io.IOException ex) {
    logger.error(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),ex);
    throw new OperationFailedException(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),OperationFailedException.INTERNAL_ERROR,ex);
  }
}","/** 
 * Initializes and returns an ArrayList with a single ViaHeader containing a localhost address usable with the specified s<tt>destination</tt>. This ArrayList may be used when sending requests to that destination. <p>
 * @param intendedDestination The address of the destination that therequest using the via headers will be sent to.
 * @return ViaHeader-s list to be used when sending requests.
 * @throws OperationFailedException code INTERNAL_ERROR if a ParseExceptionoccurs while initializing the array list.
 */
public ArrayList<ViaHeader> getLocalViaHeaders(SipURI intendedDestination) throws OperationFailedException {
  ArrayList<ViaHeader> viaHeaders=new ArrayList<ViaHeader>();
  ListeningPoint srcListeningPoint=getListeningPoint(intendedDestination.getTransportParam());
  try {
    InetSocketAddress targetAddress=getIntendedDestination(intendedDestination);
    InetAddress localAddress=SipActivator.getNetworkAddressManagerService().getLocalHost(targetAddress.getAddress());
    int localPort=srcListeningPoint.getPort();
    String transport=srcListeningPoint.getTransport();
    if (ListeningPoint.TCP.equalsIgnoreCase(transport)) {
      InetSocketAddress localSockAddr=sipStackSharing.obtainLocalAddress(targetAddress.getAddress(),targetAddress.getPort(),localAddress);
      localPort=localSockAddr.getPort();
    }
    ViaHeader viaHeader=headerFactory.createViaHeader(localAddress.getHostAddress(),localPort,transport,null);
    viaHeaders.add(viaHeader);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + viaHeader);
    return viaHeaders;
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),ex);
    throw new OperationFailedException(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  java.io.IOException ex) {
    logger.error(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),ex);
    throw new OperationFailedException(""String_Node_Str"" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(),OperationFailedException.NETWORK_FAILURE,ex);
  }
}",0.9000631180307175
103544,"/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting the specified <tt>destination</tt>. This is an utility method that is used whenever we have to choose one of our local addresses to put in the Via, Contact or (in the case of no registrar accounts) From headers. The method also takes into account the existence of an outbound proxy and in that case returns its address as the next hop.
 * @param peer the CallPeer that we would contact.
 * @return the <tt>InetAddress</tt> that is most likely to be to be usedas a next hop when contacting the specified <tt>destination</tt>.
 * @throws IllegalArgumentException if <tt>destination</tt> is not a validhost/ip/fqdn
 */
protected InetAddress getIntendedDestination(CallPeerSipImpl peer){
  return peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress());
}","/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting the specified <tt>destination</tt>. This is an utility method that is used whenever we have to choose one of our local addresses to put in the Via, Contact or (in the case of no registrar accounts) From headers. The method also takes into account the existence of an outbound proxy and in that case returns its address as the next hop.
 * @param peer the CallPeer that we would contact.
 * @return the <tt>InetAddress</tt> that is most likely to be to be usedas a next hop when contacting the specified <tt>destination</tt>.
 * @throws IllegalArgumentException if <tt>destination</tt> is not a validhost/ip/fqdn
 */
protected InetAddress getIntendedDestination(CallPeerSipImpl peer){
  return peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress()).getAddress();
}",0.9926345609065156
103545,"/** 
 * Loads the xcap-caps from the server.
 * @return the xcap-caps.
 * @throws IllegalStateException if the user has not been connected.
 * @throws XCapException         if there is some error during operation.
 */
private XCapCapsType loadXCapCaps() throws XCapException {
  String xCapCapsDocument=getXCapCapsDocument();
  XCapResourceId resourceId=new XCapResourceId(xCapCapsDocument);
  try {
    String xml=getResource(resourceId,XCapCapsClient.CONTENT_TYPE);
    if (xml == null) {
      return new XCapCapsType();
    }
    return XCapCapsParser.fromXml(xml);
  }
 catch (  ParsingException e) {
    throw new XCapException(""String_Node_Str"",e);
  }
}","/** 
 * Loads the xcap-caps from the server.
 * @return the xcap-caps.
 * @throws IllegalStateException if the user has not been connected.
 * @throws XCapException         if there is some error during operation.
 */
private XCapCapsType loadXCapCaps() throws XCapException {
  String xCapCapsDocument=getXCapCapsDocument();
  XCapResourceId resourceId=new XCapResourceId(xCapCapsDocument);
  try {
    String xml=getResource(resourceId,XCapCapsClient.CONTENT_TYPE);
    if (xml == null) {
      throw new XCapException(""String_Node_Str"");
    }
    return XCapCapsParser.fromXml(xml);
  }
 catch (  ParsingException e) {
    throw new XCapException(""String_Node_Str"",e);
  }
}",0.9514563106796116
103546,"/** 
 * Sets the reason of a call failure if one occurs. The renderer should display this reason to the user.
 * @param reason the reason to display
 */
public void setErrorReason(String reason){
  if (errorMessageComponent == null) {
    errorMessageComponent=new JTextPane();
    JTextPane textPane=(JTextPane)errorMessageComponent;
    textPane.setOpaque(false);
    StyledDocument doc=textPane.getStyledDocument();
    MutableAttributeSet standard=new SimpleAttributeSet();
    StyleConstants.setAlignment(standard,StyleConstants.ALIGN_CENTER);
    StyleConstants.setFontFamily(standard,textPane.getFont().getFamily());
    StyleConstants.setFontSize(standard,12);
    doc.setParagraphAttributes(0,0,standard,true);
    GridBagConstraints constraints=new GridBagConstraints();
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridx=0;
    constraints.gridy=4;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(5,0,0,0);
    add(errorMessageComponent,constraints);
    this.revalidate();
  }
  errorMessageComponent.setText(reason);
  if (isVisible())   errorMessageComponent.repaint();
}","/** 
 * Sets the reason of a call failure if one occurs. The renderer should display this reason to the user.
 * @param reason the reason to display
 */
public void setErrorReason(String reason){
  if (errorMessageComponent == null) {
    errorMessageComponent=new JTextPane();
    JTextPane textPane=(JTextPane)errorMessageComponent;
    textPane.setEditable(false);
    textPane.setOpaque(false);
    StyledDocument doc=textPane.getStyledDocument();
    MutableAttributeSet standard=new SimpleAttributeSet();
    StyleConstants.setAlignment(standard,StyleConstants.ALIGN_CENTER);
    StyleConstants.setFontFamily(standard,textPane.getFont().getFamily());
    StyleConstants.setFontSize(standard,12);
    doc.setParagraphAttributes(0,0,standard,true);
    GridBagConstraints constraints=new GridBagConstraints();
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridx=0;
    constraints.gridy=4;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(5,0,0,0);
    add(errorMessageComponent,constraints);
    this.revalidate();
  }
  errorMessageComponent.setText(reason);
  if (isVisible())   errorMessageComponent.repaint();
}",0.9858308286818376
103547,"/** 
 * Sets the reason of a call failure if one occurs. The renderer should display this reason to the user.
 * @param reason the reason to display
 */
protected void setErrorReason(String reason){
  if (errorMessageComponent == null) {
    errorMessageComponent=new JTextPane();
    JTextPane textPane=(JTextPane)errorMessageComponent;
    textPane.setOpaque(false);
    StyledDocument doc=textPane.getStyledDocument();
    MutableAttributeSet standard=new SimpleAttributeSet();
    StyleConstants.setFontFamily(standard,textPane.getFont().getFamily());
    StyleConstants.setFontSize(standard,12);
    doc.setParagraphAttributes(0,0,standard,true);
    addToCenter(errorMessageComponent);
    this.revalidate();
  }
  errorMessageComponent.setText(reason);
  if (isVisible())   errorMessageComponent.repaint();
}","/** 
 * Sets the reason of a call failure if one occurs. The renderer should display this reason to the user.
 * @param reason the reason to display
 */
protected void setErrorReason(String reason){
  if (errorMessageComponent == null) {
    errorMessageComponent=new JTextPane();
    JTextPane textPane=(JTextPane)errorMessageComponent;
    textPane.setEditable(false);
    textPane.setOpaque(false);
    StyledDocument doc=textPane.getStyledDocument();
    MutableAttributeSet standard=new SimpleAttributeSet();
    StyleConstants.setFontFamily(standard,textPane.getFont().getFamily());
    StyleConstants.setFontSize(standard,12);
    doc.setParagraphAttributes(0,0,standard,true);
    addToCenter(errorMessageComponent);
    this.revalidate();
  }
  errorMessageComponent.setText(reason);
  if (isVisible())   errorMessageComponent.repaint();
}",0.9801563439567048
103548,"/** 
 * Removes the corresponding server and all related chat rooms from this list.
 * @param chatRoomProvider the <tt>ChatRoomProviderWrapper</tt>corresponding to the server to remove
 */
private void removeChatProvider(ChatRoomProviderWrapper chatRoomProvider){
  providersList.remove(chatRoomProvider);
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  String providerAccountUID=chatRoomProvider.getProtocolProvider().getAccountID().getAccountUniqueID();
  for (  String accountRootPropName : configService.getPropertyNamesByPrefix(prefix,true)) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(providerAccountUID)) {
      List<String> chatRooms=configService.getPropertyNamesByPrefix(accountRootPropName + ""String_Node_Str"",true);
      for (      String chatRoomPropName : chatRooms) {
        configService.setProperty(chatRoomPropName + ""String_Node_Str"",null);
      }
      configService.setProperty(accountRootPropName,null);
    }
  }
  fireProviderWrapperRemoved(chatRoomProvider);
}","/** 
 * Removes the corresponding server and all related chat rooms from this list.
 * @param chatRoomProvider the <tt>ChatRoomProviderWrapper</tt>corresponding to the server to remove
 */
private void removeChatProvider(ChatRoomProviderWrapper chatRoomProvider){
  providersList.remove(chatRoomProvider);
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  AccountID accountID=chatRoomProvider.getProtocolProvider().getAccountID();
  if (!GuiActivator.getAccountManager().getStoredAccounts().contains(accountID)) {
    String providerAccountUID=accountID.getAccountUniqueID();
    for (    String accountRootPropName : configService.getPropertyNamesByPrefix(prefix,true)) {
      String accountUID=configService.getString(accountRootPropName);
      if (accountUID.equals(providerAccountUID)) {
        List<String> chatRooms=configService.getPropertyNamesByPrefix(accountRootPropName + ""String_Node_Str"",true);
        for (        String chatRoomPropName : chatRooms) {
          configService.setProperty(chatRoomPropName + ""String_Node_Str"",null);
        }
        configService.setProperty(accountRootPropName,null);
      }
    }
  }
  fireProviderWrapperRemoved(chatRoomProvider);
}",0.8915254237288136
103549,"/** 
 * Returns the <tt>ChatRoomWrapper</tt> that correspond to the given <tt>ChatRoom</tt>. If the list of chat rooms doesn't contain a corresponding wrapper - returns null.
 * @param chatRoom the <tt>ChatRoom</tt> that we're looking for
 * @return the <tt>ChatRoomWrapper</tt> object corresponding to the given<tt>ChatRoom</tt>
 */
public ChatRoomWrapper findChatRoomWrapperFromChatRoom(ChatRoom chatRoom){
  for (  ChatRoomProviderWrapper provider : providersList) {
    ChatRoomWrapper systemRoomWrapper=provider.getSystemRoomWrapper();
    ChatRoom systemRoom=systemRoomWrapper.getChatRoom();
    if ((systemRoom != null) && systemRoom.equals(chatRoom)) {
      return systemRoomWrapper;
    }
 else {
      ChatRoomWrapper chatRoomWrapper=provider.findChatRoomWrapperForChatRoom(chatRoom);
      if (chatRoomWrapper != null) {
        if (chatRoomWrapper.getChatRoom() == null) {
          chatRoomWrapper.setChatRoom(chatRoom);
        }
        return chatRoomWrapper;
      }
    }
  }
  return null;
}","/** 
 * Returns the <tt>ChatRoomWrapper</tt> that correspond to the given <tt>ChatRoom</tt>. If the list of chat rooms doesn't contain a corresponding wrapper - returns null.
 * @param chatRoom the <tt>ChatRoom</tt> that we're looking for
 * @return the <tt>ChatRoomWrapper</tt> object corresponding to the given<tt>ChatRoom</tt>
 */
public ChatRoomWrapper findChatRoomWrapperFromChatRoom(ChatRoom chatRoom){
  for (  ChatRoomProviderWrapper provider : providersList) {
    if (!chatRoom.getParentProvider().equals(provider.getProtocolProvider()))     continue;
    ChatRoomWrapper systemRoomWrapper=provider.getSystemRoomWrapper();
    ChatRoom systemRoom=systemRoomWrapper.getChatRoom();
    if ((systemRoom != null) && systemRoom.equals(chatRoom)) {
      return systemRoomWrapper;
    }
 else {
      ChatRoomWrapper chatRoomWrapper=provider.findChatRoomWrapperForChatRoom(chatRoom);
      if (chatRoomWrapper != null) {
        if (chatRoomWrapper.getChatRoom() == null) {
          chatRoomWrapper.setChatRoom(chatRoom);
        }
        return chatRoomWrapper;
      }
    }
  }
  return null;
}",0.9167455061494796
103550,"/** 
 * Initializes this chat room dialog.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout(5,5));
  JPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(15,15,5,15));
  JPanel labels=new TransparentPanel(new GridLayout(2,2,5,5));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(2,2,5,5));
  providersCombo=createProvidersCombobox();
  roomsCombo=new JComboBox();
  roomsCombo.setEditable(true);
  roomsCombo.setPreferredSize(providersCombo.getPreferredSize());
  editor=((JTextField)roomsCombo.getEditor().getEditorComponent());
  providersCombo.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED)       loadProviderRooms();
    }
  }
);
  valuesPanel.add(providersCombo);
  valuesPanel.add(roomsCombo);
  northPanel.add(labels,BorderLayout.WEST);
  northPanel.add(valuesPanel,BorderLayout.CENTER);
  JPanel buttonPanel=new TransparentPanel(new BorderLayout(5,5));
  buttonPanel.setBorder(BorderFactory.createEmptyBorder(0,15,10,15));
  JPanel westButtonPanel=new TransparentPanel();
  JPanel eastButtonPanel=new TransparentPanel();
  addButton.addActionListener(this);
  removeButton.addActionListener(this);
  okButton.addActionListener(this);
  cancelButton.addActionListener(this);
  westButtonPanel.add(addButton);
  westButtonPanel.add(removeButton);
  eastButtonPanel.add(cancelButton);
  eastButtonPanel.add(okButton);
  buttonPanel.add(westButtonPanel,BorderLayout.WEST);
  buttonPanel.add(eastButtonPanel,BorderLayout.EAST);
  chatRoomsTableUI=new ChatRoomTableUI(this);
  chatRoomsTableUI.setOpaque(false);
  chatRoomsTableUI.setBorder(BorderFactory.createEmptyBorder(5,15,5,15));
  northPanel.setPreferredSize(new Dimension(600,80));
  this.getContentPane().add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsTableUI,BorderLayout.CENTER);
  loadProviderRooms();
  editor.addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
      chatRoomsTableUI.clearSelection();
    }
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
    }
  }
);
  chatRoomsTableUI.addSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
        if (room != null) {
          editor.setText(room.getChatRoomName());
          providersCombo.setSelectedItem(room.getParentProvider());
        }
      }
    }
  }
);
  GuiActivator.getUIService().getConferenceChatManager().getChatRoomList().addChatRoomProviderWrapperListener(new ChatRoomList.ChatRoomProviderWrapperListener(){
    public void chatRoomProviderWrapperAdded(    ChatRoomProviderWrapper provider){
      providersCombo.addItem(provider);
    }
    public void chatRoomProviderWrapperRemoved(    ChatRoomProviderWrapper provider){
      providersCombo.removeItem(provider);
    }
  }
);
}","/** 
 * Initializes this chat room dialog.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout(5,5));
  JPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(15,15,5,15));
  JPanel labels=new TransparentPanel(new GridLayout(2,2,5,5));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  labels.add(new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(2,2,5,5));
  providersCombo=createProvidersCombobox();
  roomsCombo=new JComboBox();
  roomsCombo.setEditable(true);
  roomsCombo.setPreferredSize(providersCombo.getPreferredSize());
  editor=((JTextField)roomsCombo.getEditor().getEditorComponent());
  providersCombo.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED)       loadProviderRooms();
    }
  }
);
  valuesPanel.add(providersCombo);
  valuesPanel.add(roomsCombo);
  northPanel.add(labels,BorderLayout.WEST);
  northPanel.add(valuesPanel,BorderLayout.CENTER);
  JPanel buttonPanel=new TransparentPanel(new BorderLayout(5,5));
  buttonPanel.setBorder(BorderFactory.createEmptyBorder(0,15,10,15));
  JPanel westButtonPanel=new TransparentPanel();
  JPanel eastButtonPanel=new TransparentPanel();
  addButton.addActionListener(this);
  removeButton.addActionListener(this);
  okButton.addActionListener(this);
  cancelButton.addActionListener(this);
  westButtonPanel.add(addButton);
  westButtonPanel.add(removeButton);
  eastButtonPanel.add(cancelButton);
  eastButtonPanel.add(okButton);
  buttonPanel.add(westButtonPanel,BorderLayout.WEST);
  buttonPanel.add(eastButtonPanel,BorderLayout.EAST);
  chatRoomsTableUI=new ChatRoomTableUI(this);
  chatRoomsTableUI.setOpaque(false);
  chatRoomsTableUI.setBorder(BorderFactory.createEmptyBorder(5,15,5,15));
  northPanel.setPreferredSize(new Dimension(600,80));
  this.getContentPane().add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsTableUI,BorderLayout.CENTER);
  loadProviderRooms();
  editor.addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
      chatRoomsTableUI.clearSelection();
      if (editor.getText().trim().length() > 0)       okButton.setEnabled(true);
 else       okButton.setEnabled(false);
    }
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
    }
  }
);
  chatRoomsTableUI.addSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
        if (room != null) {
          editor.setText(room.getChatRoomName());
          providersCombo.setSelectedItem(room.getParentProvider());
          okButton.setEnabled(true);
        }
      }
    }
  }
);
  GuiActivator.getUIService().getConferenceChatManager().getChatRoomList().addChatRoomProviderWrapperListener(new ChatRoomList.ChatRoomProviderWrapperListener(){
    public void chatRoomProviderWrapperAdded(    ChatRoomProviderWrapper provider){
      providersCombo.addItem(provider);
    }
    public void chatRoomProviderWrapperRemoved(    ChatRoomProviderWrapper provider){
      providersCombo.removeItem(provider);
    }
  }
);
}",0.976634131913635
103551,"public void valueChanged(ListSelectionEvent e){
  if (!e.getValueIsAdjusting()) {
    ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
    if (room != null) {
      editor.setText(room.getChatRoomName());
      providersCombo.setSelectedItem(room.getParentProvider());
    }
  }
}","public void valueChanged(ListSelectionEvent e){
  if (!e.getValueIsAdjusting()) {
    ChatRoomWrapper room=chatRoomsTableUI.getSelectedRoom();
    if (room != null) {
      editor.setText(room.getChatRoomName());
      providersCombo.setSelectedItem(room.getParentProvider());
      okButton.setEnabled(true);
    }
  }
}",0.9458128078817734
103552,"@Override public void run(){
  okButton.setEnabled(false);
  roomsCombo.setEnabled(false);
  List<String> rooms=GuiActivator.getUIService().getConferenceChatManager().getExistingChatRooms(getSelectedProvider());
  roomsCombo.removeAllItems();
  if (rooms == null) {
    roomsCombo.setEnabled(true);
    okButton.setEnabled(true);
    return;
  }
  Collections.sort(rooms);
  for (  String room : rooms)   roomsCombo.addItem(room);
  roomsCombo.setSelectedIndex(-1);
  roomsCombo.setEnabled(true);
  okButton.setEnabled(true);
}","@Override public void run(){
  okButton.setEnabled(false);
  roomsCombo.setEnabled(false);
  List<String> rooms=GuiActivator.getUIService().getConferenceChatManager().getExistingChatRooms(getSelectedProvider());
  roomsCombo.removeAllItems();
  if (rooms == null) {
    roomsCombo.setEnabled(true);
    return;
  }
  Collections.sort(rooms);
  for (  String room : rooms)   roomsCombo.addItem(room);
  roomsCombo.setSelectedIndex(-1);
  roomsCombo.setEnabled(true);
}",0.9396378269617708
103553,"public void keyTyped(KeyEvent e){
  chatRoomsTableUI.clearSelection();
}","public void keyTyped(KeyEvent e){
  chatRoomsTableUI.clearSelection();
  if (editor.getText().trim().length() > 0)   okButton.setEnabled(true);
 else   okButton.setEnabled(false);
}",0.5691699604743083
103554,"/** 
 * Loads the rooms hosted on the selected provider. Loads it in different thread so it won't block the caller.
 */
public void loadProviderRooms(){
  new Thread(){
    @Override public void run(){
      okButton.setEnabled(false);
      roomsCombo.setEnabled(false);
      List<String> rooms=GuiActivator.getUIService().getConferenceChatManager().getExistingChatRooms(getSelectedProvider());
      roomsCombo.removeAllItems();
      if (rooms == null) {
        roomsCombo.setEnabled(true);
        okButton.setEnabled(true);
        return;
      }
      Collections.sort(rooms);
      for (      String room : rooms)       roomsCombo.addItem(room);
      roomsCombo.setSelectedIndex(-1);
      roomsCombo.setEnabled(true);
      okButton.setEnabled(true);
    }
  }
.start();
}","/** 
 * Loads the rooms hosted on the selected provider. Loads it in different thread so it won't block the caller.
 */
public void loadProviderRooms(){
  new Thread(){
    @Override public void run(){
      okButton.setEnabled(false);
      roomsCombo.setEnabled(false);
      List<String> rooms=GuiActivator.getUIService().getConferenceChatManager().getExistingChatRooms(getSelectedProvider());
      roomsCombo.removeAllItems();
      if (rooms == null) {
        roomsCombo.setEnabled(true);
        return;
      }
      Collections.sort(rooms);
      for (      String room : rooms)       roomsCombo.addItem(room);
      roomsCombo.setSelectedIndex(-1);
      roomsCombo.setEnabled(true);
    }
  }
.start();
}",0.9546666666666668
103555,"/** 
 * Refreshes the chat room's list when a modification in the model has occurred.
 * @param evt
 */
public void contentChanged(ChatRoomListChangeEvent evt){
  ChatRoomWrapper chatRoomWrapper=evt.getSourceChatRoom();
  if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_ADDED) {
    rooms.add(chatRoomWrapper);
    int index=rooms.indexOf(chatRoomWrapper);
    if (index != -1) {
      fireTableRowsInserted(index,index);
      parentTable.setRowSelectionInterval(index,index);
    }
  }
 else   if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_REMOVED) {
    int ix=rooms.indexOf(chatRoomWrapper);
    rooms.remove(chatRoomWrapper);
    OperationSetPresence presence=chatRoomWrapper.getParentProvider().getProtocolProvider().getOperationSet(OperationSetPresence.class);
    if (presence != null)     presence.removeProviderPresenceStatusListener(this);
    if (ix != -1) {
      fireTableRowsDeleted(ix,ix);
    }
  }
 else   if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_CHANGED) {
    int index=rooms.indexOf(chatRoomWrapper);
    if (index != -1) {
      fireTableRowsUpdated(index,index);
    }
  }
}","/** 
 * Refreshes the chat room's list when a modification in the model has occurred.
 * @param evt
 */
public void contentChanged(ChatRoomListChangeEvent evt){
  ChatRoomWrapper chatRoomWrapper=evt.getSourceChatRoom();
  if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_ADDED) {
    addChatRoom(chatRoomWrapper,true);
  }
 else   if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_REMOVED) {
    removeChatRoom(chatRoomWrapper);
  }
 else   if (evt.getEventID() == ChatRoomListChangeEvent.CHAT_ROOM_CHANGED) {
    int index=rooms.indexOf(chatRoomWrapper);
    if (index != -1) {
      fireTableRowsUpdated(index,index);
    }
  }
}",0.6928251121076233
103556,"/** 
 * Creates new model for the supplied table.
 * @param parentTable the parent table.
 */
public ChatRoomTableModel(JTable parentTable){
  this.parentTable=parentTable;
  chatRoomList=GuiActivator.getUIService().getConferenceChatManager().getChatRoomList();
  Iterator<ChatRoomProviderWrapper> iter=chatRoomList.getChatRoomProviders();
  while (iter.hasNext()) {
    ChatRoomProviderWrapper provider=iter.next();
    for (int i=0; i < provider.countChatRooms(); i++) {
      ChatRoomWrapper room=provider.getChatRoom(i);
      rooms.add(room);
    }
    OperationSetPresence presence=provider.getProtocolProvider().getOperationSet(OperationSetPresence.class);
    if (presence != null)     presence.addProviderPresenceStatusListener(this);
  }
}","/** 
 * Creates new model for the supplied table.
 * @param parentTable the parent table.
 */
public ChatRoomTableModel(JTable parentTable){
  this.parentTable=parentTable;
  chatRoomList=GuiActivator.getUIService().getConferenceChatManager().getChatRoomList();
  chatRoomList.addChatRoomProviderWrapperListener(this);
  Iterator<ChatRoomProviderWrapper> iter=chatRoomList.getChatRoomProviders();
  while (iter.hasNext()) {
    ChatRoomProviderWrapper provider=iter.next();
    if (!provider.getProtocolProvider().getAccountID().isEnabled()) {
      continue;
    }
    handleProviderAdded(provider);
  }
}",0.6346863468634686
103557,"/** 
 * Implements the <tt>ServiceListener</tt> method. Verifies whether the passed event concerns a <tt>ProtocolProviderService</tt> and modifies the list of registered protocol providers accordingly.
 * @param event The <tt>ServiceEvent</tt> object.
 */
public void serviceChanged(ServiceEvent event){
  Object sService=bundleContext.getService(event.getServiceReference());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + sService.getClass().getName());
  if (!(sService instanceof ProtocolProviderService)) {
    return;
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"");
  ProtocolProviderService provider=(ProtocolProviderService)sService;
  ProtocolProviderFactory sourceFactory=null;
  ServiceReference[] allBundleServices=event.getServiceReference().getBundle().getRegisteredServices();
  for (  ServiceReference bundleServiceRef : allBundleServices) {
    Object service=bundleContext.getService(bundleServiceRef);
    if (service instanceof ProtocolProviderFactory) {
      sourceFactory=(ProtocolProviderFactory)service;
      break;
    }
  }
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    String providerMask=System.getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
    if (providerMask != null && providerMask.trim().length() > 0) {
      String servRefMask=(String)event.getServiceReference().getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
      if (servRefMask == null || !servRefMask.equals(providerMask)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + provider.getAccountID());
        return;
      }
    }
    if (sourceFactory != null && currentlyInstalledProviders.containsKey(provider.getAccountID().getAccountUniqueID())) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str"");
    }
    this.handleProviderAdded((ProtocolProviderService)sService);
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    if (sourceFactory == null) {
      return;
    }
    AccountID accountID=provider.getAccountID();
    if (sourceFactory.getRegisteredAccounts().contains(accountID)) {
synchronized (this) {
        this.removeMetaContactListListener(storageManager);
        this.handleProviderRemoved((ProtocolProviderService)sService);
        this.addMetaContactListListener(storageManager);
      }
      return;
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str""+ ""String_Node_Str"");
    this.handleProviderRemoved((ProtocolProviderService)sService);
  }
}","/** 
 * Implements the <tt>ServiceListener</tt> method. Verifies whether the passed event concerns a <tt>ProtocolProviderService</tt> and modifies the list of registered protocol providers accordingly.
 * @param event The <tt>ServiceEvent</tt> object.
 */
public void serviceChanged(ServiceEvent event){
  Object sService=bundleContext.getService(event.getServiceReference());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + sService.getClass().getName());
  if (!(sService instanceof ProtocolProviderService)) {
    return;
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"");
  ProtocolProviderService provider=(ProtocolProviderService)sService;
  ProtocolProviderFactory sourceFactory=null;
  ServiceReference[] allBundleServices=event.getServiceReference().getBundle().getRegisteredServices();
  for (  ServiceReference bundleServiceRef : allBundleServices) {
    Object service=bundleContext.getService(bundleServiceRef);
    if (service instanceof ProtocolProviderFactory) {
      sourceFactory=(ProtocolProviderFactory)service;
      break;
    }
  }
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    String providerMask=System.getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
    if (providerMask != null && providerMask.trim().length() > 0) {
      String servRefMask=(String)event.getServiceReference().getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
      if (servRefMask == null || !servRefMask.equals(providerMask)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + provider.getAccountID());
        return;
      }
    }
    if (sourceFactory != null && currentlyInstalledProviders.containsKey(provider.getAccountID().getAccountUniqueID())) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str"");
    }
    this.handleProviderAdded((ProtocolProviderService)sService);
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    if (sourceFactory == null) {
      return;
    }
    AccountID accountID=provider.getAccountID();
    if (ContactlistActivator.getAccountManager().getStoredAccounts().contains(accountID)) {
synchronized (this) {
        this.removeMetaContactListListener(storageManager);
        this.handleProviderRemoved((ProtocolProviderService)sService);
        this.addMetaContactListListener(storageManager);
      }
      return;
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str""+ ""String_Node_Str"");
    this.handleProviderRemoved((ProtocolProviderService)sService);
  }
}",0.9868737289702348
103558,"/** 
 * Removes the specified account from the list of accounts that this provider factory is handling. If the specified accountID is unknown to the ProtocolProviderFactory, the call has no effect and false is returned. This method is persistent in nature and once called the account corresponding to the specified ID will not be loaded during future runs of the project.
 * @param accountID the ID of the account to remove.
 * @return true if an account with the specified ID existed and was removedand false otherwise.
 */
public boolean uninstallAccount(AccountID accountID){
  ServiceReference serRef=getProviderForAccount(accountID);
  if (serRef != null) {
    BundleContext bundleContext=getBundleContext();
    ProtocolProviderService protocolProvider=(ProtocolProviderService)bundleContext.getService(serRef);
    try {
      protocolProvider.unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + accountID + ""String_Node_Str""+ ex);
    }
    ServiceRegistration registration;
synchronized (registeredAccounts) {
      registration=registeredAccounts.remove(accountID);
    }
    if (registration != null) {
      registration.unregister();
    }
  }
  return removeStoredAccount(accountID);
}","/** 
 * Removes the specified account from the list of accounts that this provider factory is handling. If the specified accountID is unknown to the ProtocolProviderFactory, the call has no effect and false is returned. This method is persistent in nature and once called the account corresponding to the specified ID will not be loaded during future runs of the project.
 * @param accountID the ID of the account to remove.
 * @return true if an account with the specified ID existed and was removedand false otherwise.
 */
public boolean uninstallAccount(AccountID accountID){
  ServiceReference serRef=getProviderForAccount(accountID);
  boolean wasAccountExisting=false;
  if (serRef != null) {
    BundleContext bundleContext=getBundleContext();
    ProtocolProviderService protocolProvider=(ProtocolProviderService)bundleContext.getService(serRef);
    try {
      protocolProvider.unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + accountID + ""String_Node_Str""+ ex);
    }
    ServiceRegistration registration;
synchronized (registeredAccounts) {
      registration=registeredAccounts.remove(accountID);
    }
    wasAccountExisting=removeStoredAccount(accountID);
    if (registration != null) {
      registration.unregister();
    }
  }
  return wasAccountExisting;
}",0.9081039162466072
103559,"/** 
 * Creates the corresponding <tt>ProtoContactEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a protocol specific <tt>Contact</tt> has been added moved or removed.
 * @param source the contact that has caused the event.
 * @param eventName One of the ProtoContactEvent.PROTO_CONTACT_XXX fieldsindicating the exact type of the event.
 * @param oldParent the <tt>MetaContact</tt> that was wrapping the source<tt>Contact</tt> before the event occurred or <tt>null</tt> if the event is caused by adding a new <tt>Contact</tt>
 * @param newParent the <tt>MetaContact</tt> that is wrapping the source<tt>Contact</tt> after the event occurred or <tt>null</tt> if the event is caused by removing a <tt>Contact</tt>
 */
private void fireProtoContactEvent(Contact source,String eventName,MetaContact oldParent,MetaContact newParent){
  ProtoContactEvent event=new ProtoContactEvent(source,eventName,oldParent,newParent);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_ADDED)) {
      listener.protoContactAdded(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_MOVED)) {
      listener.protoContactMoved(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_REMOVED)) {
      listener.protoContactRemoved(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_MODIFIED)) {
      listener.protoContactModified(event);
    }
  }
}","/** 
 * Creates the corresponding <tt>ProtoContactEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a protocol specific <tt>Contact</tt> has been added moved or removed. Synchronized to avoid firing events when we are editing the account (there we temporally remove and then add again the storage manager and don't want anybody to interrupt us).
 * @param source the contact that has caused the event.
 * @param eventName One of the ProtoContactEvent.PROTO_CONTACT_XXX fieldsindicating the exact type of the event.
 * @param oldParent the <tt>MetaContact</tt> that was wrapping the source<tt>Contact</tt> before the event occurred or <tt>null</tt> if the event is caused by adding a new <tt>Contact</tt>
 * @param newParent the <tt>MetaContact</tt> that is wrapping the source<tt>Contact</tt> after the event occurred or <tt>null</tt> if the event is caused by removing a <tt>Contact</tt>
 */
private synchronized void fireProtoContactEvent(Contact source,String eventName,MetaContact oldParent,MetaContact newParent){
  ProtoContactEvent event=new ProtoContactEvent(source,eventName,oldParent,newParent);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_ADDED)) {
      listener.protoContactAdded(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_MOVED)) {
      listener.protoContactMoved(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_REMOVED)) {
      listener.protoContactRemoved(event);
    }
 else     if (eventName.equals(ProtoContactEvent.PROTO_CONTACT_MODIFIED)) {
      listener.protoContactModified(event);
    }
  }
}",0.943666169895678
103560,"/** 
 * Creates the corresponding <tt>MetaContactPropertyChangeEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a MetaContact has been modified.
 * @param event the event to dispatch.
 */
void fireMetaContactEvent(MetaContactPropertyChangeEvent event){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (event instanceof MetaContactMovedEvent) {
      listener.metaContactMoved((MetaContactMovedEvent)event);
    }
 else     if (event instanceof MetaContactRenamedEvent) {
      listener.metaContactRenamed((MetaContactRenamedEvent)event);
    }
 else     if (event instanceof MetaContactModifiedEvent) {
      listener.metaContactModified((MetaContactModifiedEvent)event);
    }
 else     if (event instanceof MetaContactAvatarUpdateEvent) {
      listener.metaContactAvatarUpdated((MetaContactAvatarUpdateEvent)event);
    }
  }
}","/** 
 * Creates the corresponding <tt>MetaContactPropertyChangeEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a MetaContact has been modified. Synchronized to avoid firing events when we are editing the account (there we temporally remove and then add again the storage manager and don't want anybody to interrupt us).
 * @param event the event to dispatch.
 */
synchronized void fireMetaContactEvent(MetaContactPropertyChangeEvent event){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (event instanceof MetaContactMovedEvent) {
      listener.metaContactMoved((MetaContactMovedEvent)event);
    }
 else     if (event instanceof MetaContactRenamedEvent) {
      listener.metaContactRenamed((MetaContactRenamedEvent)event);
    }
 else     if (event instanceof MetaContactModifiedEvent) {
      listener.metaContactModified((MetaContactModifiedEvent)event);
    }
 else     if (event instanceof MetaContactAvatarUpdateEvent) {
      listener.metaContactAvatarUpdated((MetaContactAvatarUpdateEvent)event);
    }
  }
}",0.9109750353273668
103561,"/** 
 * Implements the <tt>ServiceListener</tt> method. Verifies whether the passed event concerns a <tt>ProtocolProviderService</tt> and modifies the list of registered protocol providers accordingly.
 * @param event The <tt>ServiceEvent</tt> object.
 */
public void serviceChanged(ServiceEvent event){
  Object sService=bundleContext.getService(event.getServiceReference());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + sService.getClass().getName());
  if (!(sService instanceof ProtocolProviderService)) {
    return;
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"");
  ProtocolProviderService provider=(ProtocolProviderService)sService;
  ProtocolProviderFactory sourceFactory=null;
  ServiceReference[] allBundleServices=event.getServiceReference().getBundle().getRegisteredServices();
  for (  ServiceReference bundleServiceRef : allBundleServices) {
    Object service=bundleContext.getService(bundleServiceRef);
    if (service instanceof ProtocolProviderFactory) {
      sourceFactory=(ProtocolProviderFactory)service;
      break;
    }
  }
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    String providerMask=System.getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
    if (providerMask != null && providerMask.trim().length() > 0) {
      String servRefMask=(String)event.getServiceReference().getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
      if (servRefMask == null || !servRefMask.equals(providerMask)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + provider.getAccountID());
        return;
      }
    }
    if (sourceFactory != null && currentlyInstalledProviders.containsKey(provider.getAccountID().getAccountUniqueID())) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + provider.getAccountID());
      return;
    }
    this.handleProviderAdded((ProtocolProviderService)sService);
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    if (sourceFactory == null) {
      return;
    }
    AccountID accountID=provider.getAccountID();
    if (sourceFactory.getRegisteredAccounts().contains(accountID)) {
      return;
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str""+ ""String_Node_Str"");
    this.handleProviderRemoved((ProtocolProviderService)sService);
  }
}","/** 
 * Implements the <tt>ServiceListener</tt> method. Verifies whether the passed event concerns a <tt>ProtocolProviderService</tt> and modifies the list of registered protocol providers accordingly.
 * @param event The <tt>ServiceEvent</tt> object.
 */
public void serviceChanged(ServiceEvent event){
  Object sService=bundleContext.getService(event.getServiceReference());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + sService.getClass().getName());
  if (!(sService instanceof ProtocolProviderService)) {
    return;
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"");
  ProtocolProviderService provider=(ProtocolProviderService)sService;
  ProtocolProviderFactory sourceFactory=null;
  ServiceReference[] allBundleServices=event.getServiceReference().getBundle().getRegisteredServices();
  for (  ServiceReference bundleServiceRef : allBundleServices) {
    Object service=bundleContext.getService(bundleServiceRef);
    if (service instanceof ProtocolProviderFactory) {
      sourceFactory=(ProtocolProviderFactory)service;
      break;
    }
  }
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    String providerMask=System.getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
    if (providerMask != null && providerMask.trim().length() > 0) {
      String servRefMask=(String)event.getServiceReference().getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);
      if (servRefMask == null || !servRefMask.equals(providerMask)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + provider.getAccountID());
        return;
      }
    }
    if (sourceFactory != null && currentlyInstalledProviders.containsKey(provider.getAccountID().getAccountUniqueID())) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str"");
    }
    this.handleProviderAdded((ProtocolProviderService)sService);
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    if (sourceFactory == null) {
      return;
    }
    AccountID accountID=provider.getAccountID();
    if (sourceFactory.getRegisteredAccounts().contains(accountID)) {
synchronized (this) {
        this.removeMetaContactListListener(storageManager);
        this.handleProviderRemoved((ProtocolProviderService)sService);
        this.addMetaContactListListener(storageManager);
      }
      return;
    }
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + provider.getAccountID() + ""String_Node_Str""+ ""String_Node_Str"");
    this.handleProviderRemoved((ProtocolProviderService)sService);
  }
}",0.950794265788454
103562,"/** 
 * Creates the corresponding MetaContactGroup event and notifies all <tt>MetaContactListListener</tt>s that a MetaContactGroup is added or removed from the MetaContactList.
 * @param source the MetaContactGroup instance that is added to the MetaContactList
 * @param provider the ProtocolProviderService instance where this event occurred
 * @param sourceProtoGroup the proto group associated with this event ornull if the event does not concern a particular source group.
 * @param eventID one of the METACONTACT_GROUP_XXX static fields indicating the nature of the event.
 */
private void fireMetaContactGroupEvent(MetaContactGroup source,ProtocolProviderService provider,ContactGroup sourceProtoGroup,int eventID){
  MetaContactGroupEvent evt=new MetaContactGroupEvent(source,provider,sourceProtoGroup,eventID);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + evt);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
switch (eventID) {
case MetaContactGroupEvent.META_CONTACT_GROUP_ADDED:
      listener.metaContactGroupAdded(evt);
    break;
case MetaContactGroupEvent.META_CONTACT_GROUP_REMOVED:
  listener.metaContactGroupRemoved(evt);
break;
case MetaContactGroupEvent.CHILD_CONTACTS_REORDERED:
listener.childContactsReordered(evt);
break;
case MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED:
case MetaContactGroupEvent.CONTACT_GROUP_RENAMED_IN_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP:
listener.metaContactGroupModified(evt);
break;
default :
logger.error(""String_Node_Str"" + eventID + ""String_Node_Str""+ evt);
}
}
}","/** 
 * Creates the corresponding MetaContactGroup event and notifies all <tt>MetaContactListListener</tt>s that a MetaContactGroup is added or removed from the MetaContactList. Synchronized to avoid firing events when we are editing the account (there we temporally remove and then add again the storage manager and don't want anybody to interrupt us).
 * @param source the MetaContactGroup instance that is added to the MetaContactList
 * @param provider the ProtocolProviderService instance where this event occurred
 * @param sourceProtoGroup the proto group associated with this event ornull if the event does not concern a particular source group.
 * @param eventID one of the METACONTACT_GROUP_XXX static fields indicating the nature of the event.
 */
private synchronized void fireMetaContactGroupEvent(MetaContactGroup source,ProtocolProviderService provider,ContactGroup sourceProtoGroup,int eventID){
  MetaContactGroupEvent evt=new MetaContactGroupEvent(source,provider,sourceProtoGroup,eventID);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + evt);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
switch (eventID) {
case MetaContactGroupEvent.META_CONTACT_GROUP_ADDED:
      listener.metaContactGroupAdded(evt);
    break;
case MetaContactGroupEvent.META_CONTACT_GROUP_REMOVED:
  listener.metaContactGroupRemoved(evt);
break;
case MetaContactGroupEvent.CHILD_CONTACTS_REORDERED:
listener.childContactsReordered(evt);
break;
case MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED:
case MetaContactGroupEvent.CONTACT_GROUP_RENAMED_IN_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP:
case MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP:
listener.metaContactGroupModified(evt);
break;
default :
logger.error(""String_Node_Str"" + eventID + ""String_Node_Str""+ evt);
}
}
}",0.9465346534653464
103563,"/** 
 * Initiates the content of this frame.
 */
private void init(){
  if (GuiActivator.getUIService().getExitOnMainWindowClose())   this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
 else   this.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
  this.setKeybindingInput(KeybindingSet.Category.MAIN);
  this.addKeybindingAction(""String_Node_Str"",new RenameAction());
  getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(0,0));
  this.setJMenuBar(menu);
  northPanel.add(accountStatusPanel,BorderLayout.CENTER);
  TransparentPanel searchPanel=new TransparentPanel(new BorderLayout(2,0));
  searchPanel.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
  searchPanel.add(searchField);
  searchPanel.add(new CallHistoryButton(),BorderLayout.EAST);
  centerPanel.add(searchPanel,BorderLayout.NORTH);
  centerPanel.add(contactListPanel,BorderLayout.CENTER);
  this.mainPanel.add(northPanel,BorderLayout.NORTH);
  this.mainPanel.add(centerPanel,BorderLayout.CENTER);
  java.awt.Container contentPane=getContentPane();
  contentPane.add(mainPanel,BorderLayout.CENTER);
  contentPane.add(statusBarPanel,BorderLayout.SOUTH);
}","/** 
 * Initiates the content of this frame.
 */
private void init(){
  setDefaultCloseOperation(GuiActivator.getUIService().getExitOnMainWindowClose() ? JFrame.DISPOSE_ON_CLOSE : JFrame.HIDE_ON_CLOSE);
  this.setKeybindingInput(KeybindingSet.Category.MAIN);
  this.addKeybindingAction(""String_Node_Str"",new RenameAction());
  getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(0,0));
  this.setJMenuBar(menu);
  northPanel.add(accountStatusPanel,BorderLayout.CENTER);
  TransparentPanel searchPanel=new TransparentPanel(new BorderLayout(2,0));
  searchPanel.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
  searchPanel.add(searchField);
  searchPanel.add(new CallHistoryButton(),BorderLayout.EAST);
  centerPanel.add(searchPanel,BorderLayout.NORTH);
  centerPanel.add(contactListPanel,BorderLayout.CENTER);
  this.mainPanel.add(northPanel,BorderLayout.NORTH);
  this.mainPanel.add(centerPanel,BorderLayout.CENTER);
  java.awt.Container contentPane=getContentPane();
  contentPane.add(mainPanel,BorderLayout.CENTER);
  contentPane.add(statusBarPanel,BorderLayout.SOUTH);
}",0.9574638844301766
103564,"/** 
 * Sets a name that can be used when displaying this contact in user interface components.
 * @param displayName a human readable String representing this<tt>MetaContact</tt>
 */
void setDisplayName(String displayName){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    this.displayName=(displayName == null) ? ""String_Node_Str"" : displayName;
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}","/** 
 * Sets a name that can be used when displaying this contact in user interface components.
 * @param displayName a human readable String representing this<tt>MetaContact</tt>
 */
void setDisplayName(String displayName){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null)     parentGroup.lightRemoveMetaContact(this);
    this.displayName=(displayName == null) ? ""String_Node_Str"" : displayName;
    if (parentGroup != null)     parentGroup.lightAddMetaContact(this);
  }
}",0.9802371541501976
103565,"/** 
 * Removes the specified protocol specific contact from the contacts encapsulated in this <code>MetaContact</code>. The method also updates the total status field accordingly. And updates its ordered position in its parent group. If the display name of this <code>MetaContact</code> was the one of the removed contact, we update it.
 * @param contact the contact to remove
 */
void removeProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline-=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.remove(contact);
    if (defaultContact == contact) {
      defaultContact=null;
    }
    if ((protoContacts.size() > 0) && displayName.equals(contact.getDisplayName())) {
      displayName=getDefaultContact().getDisplayName();
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}","/** 
 * Removes the specified protocol specific contact from the contacts encapsulated in this <code>MetaContact</code>. The method also updates the total status field accordingly. And updates its ordered position in its parent group. If the display name of this <code>MetaContact</code> was the one of the removed contact, we update it.
 * @param contact the contact to remove
 */
void removeProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null)     parentGroup.lightRemoveMetaContact(this);
    contactsOnline-=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.remove(contact);
    if (defaultContact == contact)     defaultContact=null;
    if ((protoContacts.size() > 0) && displayName.equals(contact.getDisplayName())) {
      displayName=getDefaultContact().getDisplayName();
    }
    if (parentGroup != null)     parentGroup.lightAddMetaContact(this);
  }
}",0.9841772151898734
103566,"/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    defaultContact=null;
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=contact.getDisplayName();
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}","/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null)     parentGroup.lightRemoveMetaContact(this);
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    defaultContact=null;
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=contact.getDisplayName();
    }
    if (parentGroup != null)     parentGroup.lightAddMetaContact(this);
  }
}",0.9875776397515528
103567,"/** 
 * Queries all protoco contacts in this meta contact for their avatars. Beware that this method could cause multiple network operations. Use with caution.
 * @return a byte array containing the first avatar returned by any ofthis metacontact's child contacts or <tt>null</tt> if none of them returned an avatar.
 */
private byte[] queryProtoContactAvatar(Contact contact){
  try {
    byte[] contactImage=contact.getImage();
    if (contactImage != null && contactImage.length > 0) {
      return contactImage;
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
  return null;
}","/** 
 * Queries all protocol contacts in this meta contact for their avatars. Beware that this method could cause multiple network operations. Use with caution.
 * @return a byte array containing the first avatar returned by any ofthis metacontact's child contacts or <tt>null</tt> if none of them returned an avatar.
 */
private byte[] queryProtoContactAvatar(Contact contact){
  try {
    byte[] contactImage=contact.getImage();
    if (contactImage != null && contactImage.length > 0) {
      return contactImage;
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
  return null;
}",0.9991836734693876
103568,"/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (value instanceof ContactNode) {
    UIContact contact=((ContactNode)value).getContactDescriptor();
    String displayName=contact.getDisplayName();
    if (displayName == null || displayName.length() < 1) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isContactActive(contact)) {
      statusIcon.setImage(msgReceivedImage);
    }
 else {
      statusIcon=contact.getStatusIcon();
    }
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     this.nameLabel.setForeground(contactForegroundColor);
    this.initDisplayDetails(contact);
    this.initButtonsPanel(contact);
    ImageIcon avatar=isSelected ? contact.getAvatar(isSelected,EXTENDED_AVATAR_WIDTH,EXTENDED_AVATAR_HEIGHT) : contact.getAvatar(isSelected,AVATAR_WIDTH,AVATAR_HEIGHT);
    if (avatar != null)     this.rightLabel.setIcon(avatar);
    this.rightLabel.setText(""String_Node_Str"");
    this.setToolTipText(contact.getDescriptor().toString());
  }
 else   if (value instanceof GroupNode) {
    UIGroup groupItem=((GroupNode)value).getGroupDescriptor();
    this.nameLabel.setText(groupItem.getDisplayName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(displayDetailsLabel);
    this.remove(callButton);
    this.remove(chatButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    if (groupItem.countChildContacts() >= 0)     this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    this.setToolTipText(groupItem.getDescriptor().toString());
  }
  return this;
}","/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (value instanceof ContactNode) {
    UIContact contact=((ContactNode)value).getContactDescriptor();
    String displayName=contact.getDisplayName();
    if (displayName == null || displayName.trim().length() < 1) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isContactActive(contact)) {
      statusIcon.setImage(msgReceivedImage);
    }
 else {
      statusIcon=contact.getStatusIcon();
    }
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     this.nameLabel.setForeground(contactForegroundColor);
    this.initDisplayDetails(contact);
    this.initButtonsPanel(contact);
    ImageIcon avatar=isSelected ? contact.getAvatar(isSelected,EXTENDED_AVATAR_WIDTH,EXTENDED_AVATAR_HEIGHT) : contact.getAvatar(isSelected,AVATAR_WIDTH,AVATAR_HEIGHT);
    if (avatar != null)     this.rightLabel.setIcon(avatar);
    this.rightLabel.setText(""String_Node_Str"");
    this.setToolTipText(contact.getDescriptor().toString());
  }
 else   if (value instanceof GroupNode) {
    UIGroup groupItem=((GroupNode)value).getGroupDescriptor();
    this.nameLabel.setText(groupItem.getDisplayName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(displayDetailsLabel);
    this.remove(callButton);
    this.remove(chatButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    if (groupItem.countChildContacts() >= 0)     this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    this.setToolTipText(groupItem.getDescriptor().toString());
  }
  return this;
}",0.9987005754594394
103569,"/** 
 * Returns the default <tt>ContactDetail</tt> to use for any operations depending to the given <tt>OperationSet</tt> class.
 * @param opSetClass the <tt>OperationSet</tt> class we're interested in
 * @return the default <tt>ContactDetail</tt> to use for any operationsdepending to the given <tt>OperationSet</tt> class
 */
public UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){
  List<UIContactDetail> details=getContactDetailsForOperationSet(opSetClass);
  if (details != null && !details.isEmpty())   return details.get(0);
  return null;
}","/** 
 * Returns the default <tt>ContactDetail</tt> to use for any operations depending to the given <tt>OperationSet</tt> class.
 * @param opSetClass the <tt>OperationSet</tt> class we're interested in
 * @return the default <tt>ContactDetail</tt> to use for any operationsdepending to the given <tt>OperationSet</tt> class
 */
public UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){
  List<UIContactDetail> details=getContactDetailsForOperationSet(opSetClass);
  return (details != null && !details.isEmpty()) ? details.get(0) : null;
}",0.9661751951431048
103570,"/** 
 * Returns the display name of this <tt>MetaUIContact</tt>.
 * @return the display name of this <tt>MetaUIContact</tt>
 */
public String getDisplayName(){
  return metaContact.getDisplayName();
}","/** 
 * Returns the display name of this <tt>MetaUIContact</tt>.
 * @return the display name of this <tt>MetaUIContact</tt>
 */
public String getDisplayName(){
  String displayName=metaContact.getDisplayName();
  if ((displayName == null) || (displayName.trim().length() == 0)) {
    Iterator<Contact> contactIter=metaContact.getContacts();
    int contactCount=0;
    String address=null;
    while (contactIter.hasNext()) {
      Contact contact=contactIter.next();
      contactCount++;
      displayName=contact.getDisplayName();
      if ((displayName == null) || (displayName.trim().length() == 0)) {
        address=(contactCount == 1) ? contact.getAddress() : null;
      }
 else       break;
    }
    if ((address != null) && (address.trim().length() != 0) && ((displayName == null) || (displayName.trim().length() == 0)))     displayName=address;
  }
  return displayName;
}",0.3557603686635944
103571,"/** 
 * Returns a String that could be used by any user interacting modules for referring to this contact. An alias is not necessarily unique but is often more human readable than an address (or id).
 * @return a String that can be used for referring to this contact wheninteracting with the user.
 */
public String getDisplayName(){
  if (isResolved) {
    String name=null;
    RosterEntry entry=ssclCallback.getRosterEntry(jid);
    if (entry != null)     name=entry.getName();
    if (name == null)     name=getAddress();
    return name;
  }
 else   return tempId;
}","/** 
 * Returns a String that could be used by any user interacting modules for referring to this contact. An alias is not necessarily unique but is often more human readable than an address (or id).
 * @return a String that can be used for referring to this contact wheninteracting with the user.
 */
public String getDisplayName(){
  if (isResolved) {
    RosterEntry entry=ssclCallback.getRosterEntry(jid);
    String name=null;
    if (entry != null)     name=entry.getName();
    if ((name != null) && (name.trim().length() != 0))     return name;
  }
  return getAddress();
}",0.7829861111111112
103572,"/** 
 * Returns a reference to the contact group that this contact is currently a child of or null if the underlying protocol does not suppord persistent presence.
 * @return a reference to the contact group that this contact is currentlya child of or null if the underlying protocol does not suppord persistent presence.
 */
public ContactGroup getParentContactGroup(){
  return ssclCallback.findContactGroup(this);
}","/** 
 * Returns a reference to the contact group that this contact is currently a child of or null if the underlying protocol does not support persistent presence.
 * @return a reference to the contact group that this contact is currentlya child of or null if the underlying protocol does not support persistent presence.
 */
public ContactGroup getParentContactGroup(){
  return ssclCallback.findContactGroup(this);
}",0.9952153110047848
103573,"/** 
 * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
 * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;<tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to construct or send theINVITE request putting the remote side on/off hold.
 */
public void putOnHold(boolean onHold) throws OperationFailedException {
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  mediaHandler.setLocallyOnHold(onHold);
  try {
    sendReInvite(mediaHandler.createOffer());
  }
 catch (  Exception ex) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex,logger);
  }
  reevalLocalHoldStatus();
}","/** 
 * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
 * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;<tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to construct or send theINVITE request putting the remote side on/off hold.
 */
public void putOnHold(boolean onHold) throws OperationFailedException {
  CallPeerMediaHandlerJabberImpl mediaHandler=getMediaHandler();
  mediaHandler.setLocallyOnHold(onHold);
  reevalLocalHoldStatus();
}",0.8211708099438653
103574,"/** 
 * Wraps up any ongoing candidate harvests and returns our response to the last offer we've received, so that the peer could use it to send a <tt>session-accept</tt>.
 * @return  the last generated list of {@link ContentPacketExtension}s that the call peer could use to send a <tt>session-accept</tt>.
 * @throws OperationFailedException if we fail to configure the media stream
 */
protected List<ContentPacketExtension> generateSessionAccept() throws OperationFailedException {
  List<ContentPacketExtension> sessAccept=getTransportManager().wrapupHarvest();
  for (  ContentPacketExtension content : sessAccept) {
    RtpDescriptionPacketExtension description=JingleUtils.getRtpDescription(content);
    MediaType type=MediaType.parseString(description.getMedia());
    StreamConnector connector=getTransportManager().getStreamConnector(type);
    MediaDevice dev=getDefaultDevice(type);
    MediaStreamTarget target=JingleUtils.extractDefaultTarget(content);
    MediaDirection direction=JingleUtils.getDirection(content,!peer.isInitiator());
    MediaFormat format=JingleUtils.payloadTypeToMediaFormat(description.getPayloadTypes().get(0),getDynamicPayloadTypes());
    List<RTPExtension> rtpExtensions=JingleUtils.extractRTPExtensions(description,this.getRtpExtensionsRegistry());
    initStream(connector,dev,format,target,direction,rtpExtensions);
  }
  return sessAccept;
}","/** 
 * Wraps up any ongoing candidate harvests and returns our response to the last offer we've received, so that the peer could use it to send a <tt>session-accept</tt>.
 * @return  the last generated list of {@link ContentPacketExtension}s that the call peer could use to send a <tt>session-accept</tt>.
 * @throws OperationFailedException if we fail to configure the media stream
 */
protected List<ContentPacketExtension> generateSessionAccept() throws OperationFailedException {
  List<ContentPacketExtension> sessAccept=getTransportManager().wrapupHarvest();
  for (  ContentPacketExtension ourContent : sessAccept) {
    RtpDescriptionPacketExtension description=JingleUtils.getRtpDescription(ourContent);
    MediaType type=MediaType.parseString(description.getMedia());
    StreamConnector connector=getTransportManager().getStreamConnector(type);
    MediaDevice dev=getDefaultDevice(type);
    ContentPacketExtension theirContent=this.remoteContentMap.get(ourContent.getName());
    MediaStreamTarget target=JingleUtils.extractDefaultTarget(theirContent);
    MediaDirection direction=JingleUtils.getDirection(ourContent,!peer.isInitiator());
    MediaFormat format=JingleUtils.payloadTypeToMediaFormat(description.getPayloadTypes().get(0),getDynamicPayloadTypes());
    List<RTPExtension> rtpExtensions=JingleUtils.extractRTPExtensions(description,this.getRtpExtensionsRegistry());
    initStream(connector,dev,format,target,direction,rtpExtensions);
  }
  return sessAccept;
}",0.9614181438998958
103575,"/** 
 * Parses and handles the specified <tt>offer</tt> and returns a content extension representing the current state of this media handler. This method MUST only be called when <tt>offer</tt> is the first session description that this <tt>MediaHandler</tt> is seeing.
 * @param offer the offer that we'd like to parse, handle and get an answerfor.
 * @throws OperationFailedException if we have a problem satisfying thedescription received in <tt>offer</tt> (e.g. failed to open a device or initialize a stream ...).
 * @throws IllegalArgumentException if there's a problem with<tt>offer</tt>'s format or semantics.
 */
public void processOffer(List<ContentPacketExtension> offer) throws OperationFailedException, IllegalArgumentException {
  List<ContentPacketExtension> answerContentList=new ArrayList<ContentPacketExtension>(offer.size());
  boolean atLeastOneValidDescription=false;
  for (  ContentPacketExtension content : offer) {
    RtpDescriptionPacketExtension description=JingleUtils.getRtpDescription(content);
    MediaType mediaType=MediaType.parseString(description.getMedia());
    List<MediaFormat> remoteFormats=JingleUtils.extractFormats(description,getDynamicPayloadTypes());
    MediaDevice dev=getDefaultDevice(mediaType);
    MediaDirection devDirection=(dev == null) ? MediaDirection.INACTIVE : dev.getDirection();
    devDirection=devDirection.and(getDirectionUserPreference(mediaType));
    MediaDirection remoteDirection=JingleUtils.getDirection(content);
    MediaDirection direction=devDirection.getDirectionForAnswer(remoteDirection);
    List<MediaFormat> mutuallySupportedFormats=intersectFormats(remoteFormats,dev.getSupportedFormats());
    List<RTPExtension> offeredRTPExtensions=JingleUtils.extractRTPExtensions(description,this.getRtpExtensionsRegistry());
    List<RTPExtension> supportedExtensions=getExtensionsForType(mediaType);
    List<RTPExtension> rtpExtensions=intersectRTPExtensions(offeredRTPExtensions,supportedExtensions);
    MediaStreamTarget target=JingleUtils.extractDefaultTarget(content);
    int targetDataPort=target.getDataAddress().getPort();
    if (mutuallySupportedFormats.isEmpty() || (devDirection == MediaDirection.INACTIVE) || (targetDataPort == 0)) {
      closeStream(mediaType);
      continue;
    }
    answerContentList.add(JingleUtils.createDescription(content.getCreator(),content.getName(),JingleUtils.getSenders(direction,!peer.isInitiator()),mutuallySupportedFormats,rtpExtensions,getDynamicPayloadTypes(),getRtpExtensionsRegistry()));
    atLeastOneValidDescription=true;
  }
  if (!atLeastOneValidDescription)   ProtocolProviderServiceJabberImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT,null,logger);
  this.localContentList=answerContentList;
  getTransportManager().startCandidateHarvest(offer,answerContentList);
}","/** 
 * Parses and handles the specified <tt>offer</tt> and returns a content extension representing the current state of this media handler. This method MUST only be called when <tt>offer</tt> is the first session description that this <tt>MediaHandler</tt> is seeing.
 * @param offer the offer that we'd like to parse, handle and get an answerfor.
 * @throws OperationFailedException if we have a problem satisfying thedescription received in <tt>offer</tt> (e.g. failed to open a device or initialize a stream ...).
 * @throws IllegalArgumentException if there's a problem with<tt>offer</tt>'s format or semantics.
 */
public void processOffer(List<ContentPacketExtension> offer) throws OperationFailedException, IllegalArgumentException {
  List<ContentPacketExtension> answerContentList=new ArrayList<ContentPacketExtension>(offer.size());
  boolean atLeastOneValidDescription=false;
  for (  ContentPacketExtension content : offer) {
    remoteContentMap.put(content.getName(),content);
    RtpDescriptionPacketExtension description=JingleUtils.getRtpDescription(content);
    MediaType mediaType=MediaType.parseString(description.getMedia());
    List<MediaFormat> remoteFormats=JingleUtils.extractFormats(description,getDynamicPayloadTypes());
    MediaDevice dev=getDefaultDevice(mediaType);
    MediaDirection devDirection=(dev == null) ? MediaDirection.INACTIVE : dev.getDirection();
    devDirection=devDirection.and(getDirectionUserPreference(mediaType));
    MediaDirection remoteDirection=JingleUtils.getDirection(content);
    MediaDirection direction=devDirection.getDirectionForAnswer(remoteDirection);
    List<MediaFormat> mutuallySupportedFormats=intersectFormats(remoteFormats,dev.getSupportedFormats());
    List<RTPExtension> offeredRTPExtensions=JingleUtils.extractRTPExtensions(description,this.getRtpExtensionsRegistry());
    List<RTPExtension> supportedExtensions=getExtensionsForType(mediaType);
    List<RTPExtension> rtpExtensions=intersectRTPExtensions(offeredRTPExtensions,supportedExtensions);
    MediaStreamTarget target=JingleUtils.extractDefaultTarget(content);
    int targetDataPort=target.getDataAddress().getPort();
    if (mutuallySupportedFormats.isEmpty() || (devDirection == MediaDirection.INACTIVE) || (targetDataPort == 0)) {
      closeStream(mediaType);
      continue;
    }
    ContentPacketExtension ourContent=JingleUtils.createDescription(content.getCreator(),content.getName(),JingleUtils.getSenders(direction,!peer.isInitiator()),mutuallySupportedFormats,rtpExtensions,getDynamicPayloadTypes(),getRtpExtensionsRegistry());
    answerContentList.add(ourContent);
    localContentMap.put(content.getName(),ourContent);
    atLeastOneValidDescription=true;
  }
  if (!atLeastOneValidDescription)   ProtocolProviderServiceJabberImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.ILLEGAL_ARGUMENT,null,logger);
  getTransportManager().startCandidateHarvest(offer,answerContentList);
}",0.9410558687852384
103576,"/** 
 * ZRTP computes the SAS string after nearly all the negotiation and computations are done internally.
 * @param sas 	The string containing the SAS.
 * @param isVerified is sas verified.
 */
@Override public void showSAS(String sas,boolean isVerified){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"" + sas);
  this.sas=sas;
  this.isSasVerified=isVerified;
}","/** 
 * ZRTP computes the SAS string after nearly all the negotiation and computations are done internally.
 * @param sas     The string containing the SAS.
 * @param isVerified is sas verified.
 */
@Override public void showSAS(String sas,boolean isVerified){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"" + sas);
  this.sas=sas;
  this.isSasVerified=isVerified;
}",0.9939975990396158
103577,"/** 
 * Inform user interface that security is not active any more. 
 */
@Override public void secureOff(){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"");
  securityListener.securityTurnedOff(sessionType);
}","/** 
 * Inform user interface that security is not active any more.
 */
@Override public void secureOff(){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"");
  securityListener.securityTurnedOff(sessionType);
}",0.9980806142034548
103578,"/** 
 * Inform the user that ZRTP received ""go clear"" message from its peer. 
 */
@Override public void confirmGoClear(){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"");
}","/** 
 * Inform the user that ZRTP received ""go clear"" message from its peer.
 */
@Override public void confirmGoClear(){
  if (logger.isDebugEnabled())   logger.debug(sessionTypeToString(sessionType) + ""String_Node_Str"");
}",0.9977628635346756
103579,"/** 
 * Creates a <tt>List</tt> containing the   {@link ContentPacketExtension}s of the streams that this handler is prepared to initiate depending on available <tt>MediaDevice</tt>s and local on-hold and video transmission preferences.
 * @return a {@link List} containing the {@link ContentPacketExtension}s of streams that this handler is prepared to initiate.
 * @throws OperationFailedException if we fail to create the descriptionsfor reasons like - problems with device interaction, allocating ports, etc.
 */
public List<ContentPacketExtension> createContentList() throws OperationFailedException {
  List<ContentPacketExtension> mediaDescs=new ArrayList<ContentPacketExtension>();
  for (  MediaType mediaType : MediaType.values()) {
    MediaDevice dev=getDefaultDevice(mediaType);
    if (dev != null) {
      MediaDirection direction=dev.getDirection().and(getDirectionUserPreference(mediaType));
      if (isLocallyOnHold())       direction=direction.and(MediaDirection.SENDONLY);
      if (direction != MediaDirection.INACTIVE) {
        ContentPacketExtension content=createContentForOffer(dev.getSupportedFormats(),direction,dev.getSupportedExtensions());
        if (peer.getCall().isSipZrtpAttribute()) {
          ZrtpControl control=getZrtpControls().get(mediaType);
          if (control == null) {
            control=JabberActivator.getMediaService().createZrtpControl();
            getZrtpControls().put(mediaType,control);
          }
          String helloHash=control.getHelloHash();
          if (helloHash != null && helloHash.length() > 0) {
            ZrtpHashPacketExtension hash=new ZrtpHashPacketExtension();
            hash.setValue(helloHash);
          }
        }
        mediaDescs.add(content);
      }
    }
  }
  if (mediaDescs.isEmpty()) {
    ProtocolProviderServiceJabberImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR,null,logger);
  }
  getTransportManager().startCandidateHarvest(mediaDescs);
  return getTransportManager().wrapupHarvest();
}","/** 
 * Creates a <tt>List</tt> containing the   {@link ContentPacketExtension}s of the streams that this handler is prepared to initiate depending on available <tt>MediaDevice</tt>s and local on-hold and video transmission preferences.
 * @return a {@link List} containing the {@link ContentPacketExtension}s of streams that this handler is prepared to initiate.
 * @throws OperationFailedException if we fail to create the descriptionsfor reasons like - problems with device interaction, allocating ports, etc.
 */
public List<ContentPacketExtension> createContentList() throws OperationFailedException {
  List<ContentPacketExtension> mediaDescs=new ArrayList<ContentPacketExtension>();
  for (  MediaType mediaType : MediaType.values()) {
    MediaDevice dev=getDefaultDevice(mediaType);
    if (dev != null) {
      MediaDirection direction=dev.getDirection().and(getDirectionUserPreference(mediaType));
      if (isLocallyOnHold())       direction=direction.and(MediaDirection.SENDONLY);
      if (direction != MediaDirection.INACTIVE) {
        ContentPacketExtension content=createContentForOffer(dev.getSupportedFormats(),direction,dev.getSupportedExtensions());
        if (peer.getCall().isSipZrtpAttribute()) {
          ZrtpControl control=getZrtpControls().get(mediaType);
          if (control == null) {
            control=JabberActivator.getMediaService().createZrtpControl();
            getZrtpControls().put(mediaType,control);
          }
          String helloHash=control.getHelloHash();
          if (helloHash != null && helloHash.length() > 0) {
            ZrtpHashPacketExtension hash=new ZrtpHashPacketExtension();
            hash.setValue(helloHash);
            content.addChildExtension(hash);
          }
        }
        mediaDescs.add(content);
      }
    }
  }
  if (mediaDescs.isEmpty()) {
    ProtocolProviderServiceJabberImpl.throwOperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.GENERAL_ERROR,null,logger);
  }
  getTransportManager().startCandidateHarvest(mediaDescs);
  return getTransportManager().wrapupHarvest();
}",0.9891800913681174
103580,"/** 
 * Puts the specified <tt>CallPeer</tt> on or off hold.
 * @param peer the <tt>CallPeer</tt> to be put on or off hold
 * @param on <tt>true</tt> to have the specified <tt>CallPeer</tt>put on hold; <tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to send the ""hold"" message.
 */
private void putOnHold(CallPeer peer,boolean on) throws OperationFailedException {
  CallPeerJabberImpl jabberPeer=(CallPeerJabberImpl)peer;
}","/** 
 * Puts the specified <tt>CallPeer</tt> on or off hold.
 * @param peer the <tt>CallPeer</tt> to be put on or off hold
 * @param on <tt>true</tt> to have the specified <tt>CallPeer</tt>put on hold; <tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to send the ""hold"" message.
 */
private void putOnHold(CallPeer peer,boolean on) throws OperationFailedException {
  CallPeerJabberImpl jabberPeer=(CallPeerJabberImpl)peer;
  jabberPeer.putOnHold(on);
}",0.9697624190064796
103581,"/** 
 * Creates a   {@link JingleIQ} <tt>session-info</tt> packet carrying a<tt>ringing</tt> payload.
 * @param sessionInitiate the {@link JingleIQ} that established the sessionwhich the response is going to belong to.
 * @return a {@link JingleIQ} <tt>session-info</tt> packet carrying a<tt>ringing</tt> payload.
 */
public static JingleIQ createRinging(JingleIQ sessionInitiate){
  JingleIQ ringing=new JingleIQ();
  ringing.setTo(sessionInitiate.getFrom());
  ringing.setFrom(sessionInitiate.getTo());
  ringing.setType(IQ.Type.SET);
  ringing.setSID(sessionInitiate.getSID());
  ringing.setAction(JingleAction.SESSION_INFO);
  SessionInfoPacketExtension ringingPayload=new SessionInfoPacketExtension(SessionInfoType.ringing);
  ringing.setSessionInfo(ringingPayload);
  return ringing;
}","/** 
 * Creates a   {@link JingleIQ} <tt>session-info</tt> packet carrying a<tt>ringing</tt> payload.
 * @param sessionInitiate the {@link JingleIQ} that established the sessionwhich the response is going to belong to.
 * @return a {@link JingleIQ} <tt>session-info</tt> packet carrying a<tt>ringing</tt> payload.
 */
public static JingleIQ createRinging(JingleIQ sessionInitiate){
  return createSessionInfo(sessionInitiate.getFrom(),sessionInitiate.getTo(),sessionInitiate.getSID(),SessionInfoType.ringing);
}",0.7096774193548387
103582,"public void run(){
  if (currentImage == null) {
    byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
    if ((accountImage != null) && (accountImage.length > 0)) {
      currentImage=accountImage;
      accountImageLabel.setImageIcon(currentImage);
    }
  }
  String accountName=null;
  if (currentFirstName == null) {
    String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
    if (firstName != null && firstName.length() > 0) {
      currentFirstName=firstName;
      accountName=currentFirstName;
    }
  }
  if (currentLastName == null) {
    String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
    if (lastName != null && lastName.length() > 0) {
      currentLastName=lastName;
      if (accountName != null)       accountName+=""String_Node_Str"";
      accountName+=currentLastName;
    }
  }
  if (currentFirstName == null && currentLastName == null) {
    String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
    if (displayName != null)     accountName=displayName;
  }
  if (accountName != null && accountName.length() > 0)   accountNameLabel.setText(accountName);
}","public void run(){
  if (currentImage == null) {
    byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
    if ((accountImage != null) && (accountImage.length > 0)) {
      currentImage=accountImage;
      accountImageLabel.setImageIcon(currentImage);
    }
  }
  String accountName=null;
  if (currentFirstName == null) {
    String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
    if (firstName != null && firstName.length() > 0) {
      currentFirstName=firstName;
      accountName=currentFirstName;
    }
  }
  if (currentLastName == null) {
    String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
    if (lastName != null && lastName.length() > 0) {
      currentLastName=lastName;
      if ((accountName == null) || (accountName.length() == 0))       accountName=currentLastName;
 else       accountName+=""String_Node_Str"" + currentLastName;
    }
  }
  if (currentFirstName == null && currentLastName == null) {
    String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
    if (displayName != null)     accountName=displayName;
  }
  if (accountName != null && accountName.length() > 0)   accountNameLabel.setText(accountName);
}",0.9416309012875536
103583,"/** 
 * Updates account information when a protocol provider is registered.
 * @param evt the <tt>RegistrationStateChangeEvent</tt> that notified usof the change
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    final OperationSetServerStoredAccountInfo accountInfoOpSet=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (accountInfoOpSet != null)     new Thread(){
      public void run(){
        if (currentImage == null) {
          byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
          if ((accountImage != null) && (accountImage.length > 0)) {
            currentImage=accountImage;
            accountImageLabel.setImageIcon(currentImage);
          }
        }
        String accountName=null;
        if (currentFirstName == null) {
          String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
          if (firstName != null && firstName.length() > 0) {
            currentFirstName=firstName;
            accountName=currentFirstName;
          }
        }
        if (currentLastName == null) {
          String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
          if (lastName != null && lastName.length() > 0) {
            currentLastName=lastName;
            if (accountName != null)             accountName+=""String_Node_Str"";
            accountName+=currentLastName;
          }
        }
        if (currentFirstName == null && currentLastName == null) {
          String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
          if (displayName != null)           accountName=displayName;
        }
        if (accountName != null && accountName.length() > 0)         accountNameLabel.setText(accountName);
      }
    }
.start();
  }
}","/** 
 * Updates account information when a protocol provider is registered.
 * @param evt the <tt>RegistrationStateChangeEvent</tt> that notified usof the change
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    final OperationSetServerStoredAccountInfo accountInfoOpSet=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
    if (accountInfoOpSet != null)     new Thread(){
      public void run(){
        if (currentImage == null) {
          byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
          if ((accountImage != null) && (accountImage.length > 0)) {
            currentImage=accountImage;
            accountImageLabel.setImageIcon(currentImage);
          }
        }
        String accountName=null;
        if (currentFirstName == null) {
          String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
          if (firstName != null && firstName.length() > 0) {
            currentFirstName=firstName;
            accountName=currentFirstName;
          }
        }
        if (currentLastName == null) {
          String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
          if (lastName != null && lastName.length() > 0) {
            currentLastName=lastName;
            if ((accountName == null) || (accountName.length() == 0))             accountName=currentLastName;
 else             accountName+=""String_Node_Str"" + currentLastName;
          }
        }
        if (currentFirstName == null && currentLastName == null) {
          String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
          if (displayName != null)           accountName=displayName;
        }
        if (accountName != null && accountName.length() > 0)         accountNameLabel.setText(accountName);
      }
    }
.start();
  }
}",0.9626262626262626
103584,"/** 
 * Returns the first name of the account, to which the given accountInfoOpSet belongs.
 * @param accountInfoOpSet The account info operation set corresponding tothe searched account.
 * @return the first name of the account, to which the givenaccountInfoOpSet belongs.
 */
public static String getFirstName(OperationSetServerStoredAccountInfo accountInfoOpSet){
  FirstNameDetail firstName=null;
  Iterator<GenericDetail> firstNameDetails=accountInfoOpSet.getDetails(FirstNameDetail.class);
  if (firstNameDetails.hasNext())   firstName=(FirstNameDetail)firstNameDetails.next();
  if (firstName == null)   return null;
  return firstName.getString();
}","/** 
 * Returns the first name of the account, to which the given accountInfoOpSet belongs.
 * @param accountInfoOpSet The account info operation set corresponding tothe searched account.
 * @return the first name of the account, to which the givenaccountInfoOpSet belongs.
 */
public static String getFirstName(OperationSetServerStoredAccountInfo accountInfoOpSet){
  Iterator<GenericDetail> firstNameDetails=accountInfoOpSet.getDetails(FirstNameDetail.class);
  if (firstNameDetails.hasNext()) {
    FirstNameDetail firstName=(FirstNameDetail)firstNameDetails.next();
    if (firstName != null)     return firstName.toString();
  }
  return null;
}",0.8553940321346595
103585,"/** 
 * Handles incoming jingle packets and passes them to the corresponding method based on their action.
 * @param packet the packet to process.
 */
public void processPacket(Packet packet){
  if (!(packet instanceof JingleIQ))   return;
  JingleIQ jingleIQ=(JingleIQ)packet;
  if (jingleIQ.getType() == IQ.Type.SET) {
    IQ ack=IQ.createResultIQ(jingleIQ);
    protocolProvider.getConnection().sendPacket(ack);
  }
  processJinglePacket(jingleIQ);
}","/** 
 * Handles incoming jingle packets and passes them to the corresponding method based on their action.
 * @param packet the packet to process.
 */
public void processPacket(Packet packet){
  if (!(packet instanceof JingleIQ))   return;
  JingleIQ jingleIQ=(JingleIQ)packet;
  if (jingleIQ.getType() == IQ.Type.SET) {
    IQ ack=IQ.createResultIQ(jingleIQ);
    protocolProvider.getConnection().sendPacket(ack);
  }
  try {
    processJinglePacket(jingleIQ);
  }
 catch (  Throwable thr) {
    logger.info(""String_Node_Str"",thr);
  }
}",0.9142280524722504
103586,"/** 
 * Returns the value of the senders argument which indicates the parties that will be generating content in this session; the allowable values are defined in the <tt>SendersEnum</tt>.
 * @return a {@link SendersEnum} instance indicating the the parties thatwill be generating content in this session.
 */
public SendersEnum getSenders(){
  return SendersEnum.valueOf(getAttributeAsString(SENDERS_ATTR_NAME));
}","/** 
 * Returns the value of the senders argument which indicates the parties that will be generating content in this session; the allowable values are defined in the <tt>SendersEnum</tt>.
 * @return a {@link SendersEnum} instance indicating the the parties thatwill be generating content in this session.
 */
public SendersEnum getSenders(){
  Object attributeVal=getAttribute(SENDERS_ATTR_NAME);
  return attributeVal == null ? null : SendersEnum.valueOf(attributeVal.toString());
}",0.8476084538375973
103587,"/** 
 * Closes both the control and the data socket of the specified connector and releases its reference (if it wasn't the case already).
 * @param mediaType the type of the connector we'd like to close.
 */
public void closeStreamConnector(MediaType mediaType){
  StreamConnector connector=(mediaType == MediaType.VIDEO) ? videoStreamConnector : audioStreamConnector;
synchronized (connector) {
    if (connector != null) {
      audioStreamConnector.getDataSocket().close();
      audioStreamConnector.getControlSocket().close();
      audioStreamConnector=null;
    }
  }
}","/** 
 * Closes both the control and the data socket of the specified connector and releases its reference (if it wasn't the case already).
 * @param mediaType the type of the connector we'd like to close.
 */
public void closeStreamConnector(MediaType mediaType){
  StreamConnector connector=(mediaType == MediaType.VIDEO) ? videoStreamConnector : audioStreamConnector;
synchronized (connector) {
    if (connector != null) {
      connector.getDataSocket().close();
      connector.getControlSocket().close();
      connector=null;
    }
  }
}",0.7957181088314005
103588,"/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting our XMPP server. This is an utility method that is used whenever we have to choose one of our local addresses (e.g. when trying to pick a best candidate for raw udp). It is based on the assumption that, in absence of any more specific details, chances are that we will be accessing remote destinations via the same interface that we are using to access our jabber server.
 * @return the <tt>InetAddress</tt> that is most likely to be to be usedas a next hop when contacting our server.
 * @throws IllegalArgumentException if we don't have a valid server.
 */
public InetAddress getNextHop() throws IllegalArgumentException {
  InetAddress nextHop=null;
  String nextHopStr=null;
  if (proxy != null)   nextHopStr=proxy.getProxyAddress();
 else   nextHopStr=getConnection().getHost();
  try {
    nextHop=NetworkUtils.getInetAddress(nextHopStr);
  }
 catch (  UnknownHostException ex) {
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + nextHop + ""String_Node_Str"");
  return nextHop;
}","/** 
 * Returns the <tt>InetAddress</tt> that is most likely to be to be used as a next hop when contacting our XMPP server. This is an utility method that is used whenever we have to choose one of our local addresses (e.g. when trying to pick a best candidate for raw udp). It is based on the assumption that, in absence of any more specific details, chances are that we will be accessing remote destinations via the same interface that we are using to access our jabber server.
 * @return the <tt>InetAddress</tt> that is most likely to be to be usedas a next hop when contacting our server.
 * @throws IllegalArgumentException if we don't have a valid server.
 */
public InetAddress getNextHop() throws IllegalArgumentException {
  InetAddress nextHop=null;
  String nextHopStr=null;
  if (proxy != null && proxy.getProxyType() != org.jivesoftware.smack.proxy.ProxyInfo.ProxyType.NONE) {
    nextHopStr=proxy.getProxyAddress();
  }
 else {
    nextHopStr=getConnection().getHost();
  }
  try {
    nextHop=NetworkUtils.getInetAddress(nextHopStr);
  }
 catch (  UnknownHostException ex) {
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + nextHop + ""String_Node_Str"");
  return nextHop;
}",0.9570903146710258
103589,"/** 
 * Changes auto join value in configuration service.
 * @param value change of auto join property.
 */
public void setAutoJoin(boolean value){
  autoJoin=value;
  if (!isPersistent())   return;
  if (value) {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,Boolean.toString(autoJoin));
  }
 else {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,null);
  }
}","/** 
 * Changes auto join value in configuration service.
 * @param value change of auto join property.
 */
public void setAutoJoin(boolean value){
  autoJoin=value;
  if (!isPersistent()) {
    setPersistent(true);
    ConfigurationManager.saveChatRoom(getParentProvider().getProtocolProvider(),getChatRoomID(),getChatRoomID(),getChatRoomName());
  }
  if (value) {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,Boolean.toString(autoJoin));
  }
 else {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,null);
  }
}",0.8571428571428571
103590,"/** 
 * Changes auto join value in configuration service.
 * @param value change of auto join property.
 */
public void setAutoJoin(boolean value){
  autoJoin=value;
  if (!persistent)   return;
  if (value) {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,Boolean.toString(autoJoin));
  }
 else {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,null);
  }
}","/** 
 * Changes auto join value in configuration service.
 * @param value change of auto join property.
 */
public void setAutoJoin(boolean value){
  autoJoin=value;
  if (!isPersistent())   return;
  if (value) {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,Boolean.toString(autoJoin));
  }
 else {
    ConfigurationManager.updateChatRoomProperty(getParentProvider().getProtocolProvider(),chatRoomID,AUTOJOIN_PROPERTY_NAME,null);
  }
}",0.9766081871345028
103591,"/** 
 * Implements <tt>connectionClosedOnError</tt> from <tt>ConnectionListener</tt>.
 * @param exception contains information on the error.
 */
public void connectionClosedOnError(Exception exception){
  logger.error(""String_Node_Str"" + exception.getLocalizedMessage());
  if (exception instanceof XMPPException) {
    StreamError err=((XMPPException)exception).getStreamError();
    if (err != null && err.getCode().equals(XMPPError.Condition.conflict.toString())) {
synchronized (connectAndLoginLock) {
        if (inConnectAndLogin) {
          eventDuringLogin=new RegistrationStateChangeEvent(ProtocolProviderServiceJabberImpl.this,getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS,""String_Node_Str"");
          return;
        }
      }
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS,""String_Node_Str"");
      return;
    }
  }
 else   if (exception instanceof SSLHandshakeException && exception.getCause() instanceof CertificateException) {
    return;
  }
synchronized (connectAndLoginLock) {
    if (inConnectAndLogin) {
      eventDuringLogin=new RegistrationStateChangeEvent(ProtocolProviderServiceJabberImpl.this,getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,exception.getMessage());
      return;
    }
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,exception.getMessage());
}","/** 
 * Implements <tt>connectionClosedOnError</tt> from <tt>ConnectionListener</tt>.
 * @param exception contains information on the error.
 */
public void connectionClosedOnError(Exception exception){
  logger.error(""String_Node_Str"" + exception.getLocalizedMessage());
  if (exception instanceof XMPPException) {
    StreamError err=((XMPPException)exception).getStreamError();
    if (err != null && err.getCode().equals(XMPPError.Condition.conflict.toString())) {
synchronized (connectAndLoginLock) {
        if (inConnectAndLogin) {
          eventDuringLogin=new RegistrationStateChangeEvent(ProtocolProviderServiceJabberImpl.this,getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS,""String_Node_Str"");
          return;
        }
      }
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS,""String_Node_Str"");
      return;
    }
  }
 else   if (exception instanceof SSLHandshakeException && exception.getCause() instanceof CertificateException) {
    return;
  }
synchronized (connectAndLoginLock) {
    if (inConnectAndLogin) {
      eventDuringLogin=new RegistrationStateChangeEvent(ProtocolProviderServiceJabberImpl.this,getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,exception.getMessage());
      return;
    }
  }
  fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,exception.getMessage());
}",0.577570093457944
103592,"/** 
 * Returns the <tt>FileAccessService</tt> obtained from the bundle context.
 * @return the <tt>FileAccessService</tt> obtained from the bundle context
 */
public static FileAccessService getFileAccessService(){
  if (fileAccessService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(FileAccessService.class.getName());
    if (serviceReference != null)     fileAccessService=(FileAccessService)bundleContext.getService(serviceReference);
  }
  return fileAccessService;
}","/** 
 * Returns the <tt>FileAccessService</tt> obtained from the bundle context.
 * @return the <tt>FileAccessService</tt> obtained from the bundle context
 */
public static FileAccessService getFileAccessService(){
  if (fileAccessService == null) {
    fileAccessService=ServiceUtils.getService(bundleContext,FileAccessService.class);
  }
  return fileAccessService;
}",0.6833144154370034
103593,"/** 
 * Returns the <tt>AccountManager</tt> obtained from the bundle context.
 * @return the <tt>AccountManager</tt> obtained from the bundle context
 */
public static AccountManager getAccountManager(){
  if (accountManager == null) {
    ServiceReference accountManagerRef=bundleContext.getServiceReference(AccountManager.class.getName());
    accountManager=(AccountManager)bundleContext.getService(accountManagerRef);
  }
  return accountManager;
}","/** 
 * Returns the <tt>AccountManager</tt> obtained from the bundle context.
 * @return the <tt>AccountManager</tt> obtained from the bundle context
 */
public static AccountManager getAccountManager(){
  if (accountManager == null) {
    accountManager=ServiceUtils.getService(bundleContext,AccountManager.class);
  }
  return accountManager;
}",0.6741854636591479
103594,"/** 
 * Returns the <tt>BrowserLauncherService</tt> obtained from the bundle context.
 * @return the <tt>BrowserLauncherService</tt> obtained from the bundlecontext
 */
public static BrowserLauncherService getBrowserLauncher(){
  if (browserLauncherService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(BrowserLauncherService.class.getName());
    browserLauncherService=(BrowserLauncherService)bundleContext.getService(serviceReference);
  }
  return browserLauncherService;
}","/** 
 * Returns the <tt>BrowserLauncherService</tt> obtained from the bundle context.
 * @return the <tt>BrowserLauncherService</tt> obtained from the bundlecontext
 */
public static BrowserLauncherService getBrowserLauncher(){
  if (browserLauncherService == null) {
    browserLauncherService=ServiceUtils.getService(bundleContext,BrowserLauncherService.class);
  }
  return browserLauncherService;
}",0.7052401746724891
103595,"/** 
 * Returns the <tt>KeybindingsService</tt> obtained from the bundle context.
 * @return the <tt>KeybindingsService</tt> obtained from the bundle context
 */
public static KeybindingsService getKeybindingsService(){
  if (keybindingsService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(KeybindingsService.class.getName());
    keybindingsService=(KeybindingsService)bundleContext.getService(serviceReference);
  }
  return keybindingsService;
}","/** 
 * Returns the <tt>KeybindingsService</tt> obtained from the bundle context.
 * @return the <tt>KeybindingsService</tt> obtained from the bundle context
 */
public static KeybindingsService getKeybindingsService(){
  if (keybindingsService == null) {
    keybindingsService=ServiceUtils.getService(bundleContext,KeybindingsService.class);
  }
  return keybindingsService;
}",0.7152777777777778
103596,"/** 
 * Returns a list of all registered contact sources.
 * @return a list of all registered contact sources
 */
public static List<ContactSourceService> getContactSources(){
  if (contactSources != null)   return contactSources;
  contactSources=new Vector<ContactSourceService>();
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ContactSourceService.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  if (serRefs != null) {
    for (int i=0; i < serRefs.length; i++) {
      ContactSourceService contactSource=(ContactSourceService)bundleContext.getService(serRefs[i]);
      contactSources.add(contactSource);
    }
  }
  return contactSources;
}","/** 
 * Returns a list of all registered contact sources.
 * @return a list of all registered contact sources
 */
public static List<ContactSourceService> getContactSources(){
  if (contactSources != null)   return contactSources;
  contactSources=new Vector<ContactSourceService>();
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ContactSourceService.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  if (serRefs != null) {
    for (    ServiceReference serRef : serRefs) {
      ContactSourceService contactSource=(ContactSourceService)bundleContext.getService(serRef);
      contactSources.add(contactSource);
    }
  }
  return contactSources;
}",0.8241539482415395
103597,"/** 
 * Returns an instance of the <tt>MediaService</tt> obtained from the bundle context.
 * @return an instance of the <tt>MediaService</tt> obtained from thebundle context
 */
public static MediaService getMediaService(){
  if (mediaService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(MediaService.class.getName());
    mediaService=(MediaService)bundleContext.getService(serviceReference);
  }
  return mediaService;
}","/** 
 * Returns an instance of the <tt>MediaService</tt> obtained from the bundle context.
 * @return an instance of the <tt>MediaService</tt> obtained from thebundle context
 */
public static MediaService getMediaService(){
  if (mediaService == null) {
    mediaService=ServiceUtils.getService(bundleContext,MediaService.class);
  }
  return mediaService;
}",0.7317073170731707
103598,"/** 
 * Returns the <tt>ProtocolProviderService</tt> corresponding to the given account identifier that is registered in the given factory
 * @param accountID the identifier of the account
 * @return the <tt>ProtocolProviderService</tt> corresponding to the givenaccount identifier that is registered in the given factory
 */
public static ProtocolProviderService getRegisteredProviderForAccount(AccountID accountID){
  Iterator<ProtocolProviderFactory> factories=getProtocolProviderFactories().values().iterator();
  while (factories.hasNext()) {
    ProtocolProviderFactory factory=factories.next();
    if (factory.getRegisteredAccounts().contains(accountID)) {
      ServiceReference serRef=factory.getProviderForAccount(accountID);
      if (serRef != null)       return (ProtocolProviderService)bundleContext.getService(serRef);
    }
  }
  return null;
}","/** 
 * Returns the <tt>ProtocolProviderService</tt> corresponding to the given account identifier that is registered in the given factory
 * @param accountID the identifier of the account
 * @return the <tt>ProtocolProviderService</tt> corresponding to the givenaccount identifier that is registered in the given factory
 */
public static ProtocolProviderService getRegisteredProviderForAccount(AccountID accountID){
  for (  ProtocolProviderFactory factory : getProtocolProviderFactories().values()) {
    if (factory.getRegisteredAccounts().contains(accountID)) {
      ServiceReference serRef=factory.getProviderForAccount(accountID);
      if (serRef != null) {
        return (ProtocolProviderService)bundleContext.getService(serRef);
      }
    }
  }
  return null;
}",0.910757946210269
103599,"/** 
 * Returns the <tt>NotificationService</tt> obtained from the bundle context.
 * @return the <tt>NotificationService</tt> obtained from the bundle context
 */
public static NotificationService getNotificationService(){
  if (notificationService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(NotificationService.class.getName());
    notificationService=(NotificationService)bundleContext.getService(serviceReference);
  }
  return notificationService;
}","/** 
 * Returns the <tt>NotificationService</tt> obtained from the bundle context.
 * @return the <tt>NotificationService</tt> obtained from the bundle context
 */
public static NotificationService getNotificationService(){
  if (notificationService == null) {
    notificationService=ServiceUtils.getService(bundleContext,NotificationService.class);
  }
  return notificationService;
}",0.7105561861520999
103600,"/** 
 * Returns the <tt>SystrayService</tt> obtained from the bundle context.
 * @return the <tt>SystrayService</tt> obtained from the bundle context
 */
public static SystrayService getSystrayService(){
  if (systrayService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(SystrayService.class.getName());
    if (serviceReference == null)     return null;
    systrayService=(SystrayService)bundleContext.getService(serviceReference);
  }
  return systrayService;
}","/** 
 * Returns the <tt>SystrayService</tt> obtained from the bundle context.
 * @return the <tt>SystrayService</tt> obtained from the bundle context
 */
public static SystrayService getSystrayService(){
  if (systrayService == null) {
    systrayService=ServiceUtils.getService(bundleContext,SystrayService.class);
  }
  return systrayService;
}",0.6682408500590319
103601,"/** 
 * Returns the <tt>DesktopService</tt> obtained from the bundle context.
 * @return the <tt>DesktopService</tt> obtained from the bundle context
 */
public static DesktopService getDesktopService(){
  if (desktopService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(DesktopService.class.getName());
    desktopService=(DesktopService)bundleContext.getService(serviceReference);
  }
  return desktopService;
}","/** 
 * Returns the <tt>DesktopService</tt> obtained from the bundle context.
 * @return the <tt>DesktopService</tt> obtained from the bundle context
 */
public static DesktopService getDesktopService(){
  if (desktopService == null) {
    desktopService=ServiceUtils.getService(bundleContext,DesktopService.class);
  }
  return desktopService;
}",0.7110552763819096
103602,"/** 
 * Returns the <tt>MetaContactListService</tt> obtained from the bundle context.
 * @return the <tt>MetaContactListService</tt> obtained from the bundlecontext
 */
public static MetaContactListService getContactListService(){
  if (metaCListService == null) {
    ServiceReference clistReference=bundleContext.getServiceReference(MetaContactListService.class.getName());
    metaCListService=(MetaContactListService)bundleContext.getService(clistReference);
  }
  return metaCListService;
}","/** 
 * Returns the <tt>MetaContactListService</tt> obtained from the bundle context.
 * @return the <tt>MetaContactListService</tt> obtained from the bundlecontext
 */
public static MetaContactListService getContactListService(){
  if (metaCListService == null) {
    metaCListService=ServiceUtils.getService(bundleContext,MetaContactListService.class);
  }
  return metaCListService;
}",0.7256235827664399
103603,"/** 
 * Returns the <tt>CallHistoryService</tt> obtained from the bundle context.
 * @return the <tt>CallHistoryService</tt> obtained from the bundlecontext
 */
public static CallHistoryService getCallHistoryService(){
  if (callHistoryService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(CallHistoryService.class.getName());
    callHistoryService=(CallHistoryService)bundleContext.getService(serviceReference);
  }
  return callHistoryService;
}","/** 
 * Returns the <tt>CallHistoryService</tt> obtained from the bundle context.
 * @return the <tt>CallHistoryService</tt> obtained from the bundlecontext
 */
public static CallHistoryService getCallHistoryService(){
  if (callHistoryService == null) {
    callHistoryService=ServiceUtils.getService(bundleContext,CallHistoryService.class);
  }
  return callHistoryService;
}",0.7099767981438515
103604,"/** 
 * Returns the <tt>FileAccessService</tt> obtained from the bundle context.
 * @return the <tt>FileAccessService</tt> obtained from the bundle context
 */
public static FileAccessService getFileAccessService(){
  if (fileAccessService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(FileAccessService.class.getName());
    fileAccessService=(FileAccessService)bundleContext.getService(serviceReference);
  }
  return fileAccessService;
}","/** 
 * Returns the <tt>FileAccessService</tt> obtained from the bundle context.
 * @return the <tt>FileAccessService</tt> obtained from the bundle context
 */
public static FileAccessService getFileAccessService(){
  if (fileAccessService == null) {
    fileAccessService=ServiceUtils.getService(bundleContext,FileAccessService.class);
  }
  return fileAccessService;
}",0.7107438016528925
103605,"/** 
 * Returns the <tt>ResourceManagementService</tt>, through which we will access all resources.
 * @return the <tt>ResourceManagementService</tt>, through which we willaccess all resources.
 */
public static ResourceManagementService getResources(){
  if (resourcesService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(ResourceManagementService.class.getName());
    if (serviceReference == null)     return null;
    resourcesService=(ResourceManagementService)bundleContext.getService(serviceReference);
  }
  return resourcesService;
}","/** 
 * Returns the <tt>ResourceManagementService</tt>, through which we will access all resources.
 * @return the <tt>ResourceManagementService</tt>, through which we willaccess all resources.
 */
public static ResourceManagementService getResources(){
  if (resourcesService == null) {
    resourcesService=ServiceUtils.getService(bundleContext,ResourceManagementService.class);
  }
  return resourcesService;
}",0.6391129032258065
103606,"/** 
 * Returns the <tt>AudioNotifierService</tt> obtained from the bundle context.
 * @return the <tt>AudioNotifierService</tt> obtained from the bundlecontext
 */
public static AudioNotifierService getAudioNotifier(){
  if (audioNotifierService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(AudioNotifierService.class.getName());
    if (serviceReference != null)     audioNotifierService=(AudioNotifierService)bundleContext.getService(serviceReference);
  }
  return audioNotifierService;
}","/** 
 * Returns the <tt>AudioNotifierService</tt> obtained from the bundle context.
 * @return the <tt>AudioNotifierService</tt> obtained from the bundlecontext
 */
public static AudioNotifierService getAudioNotifier(){
  if (audioNotifierService == null) {
    audioNotifierService=ServiceUtils.getService(bundleContext,AudioNotifierService.class);
  }
  return audioNotifierService;
}",0.6790393013100436
103607,"/** 
 * Returns all <tt>ProtocolProviderFactory</tt>s obtained from the bundle context.
 * @return all <tt>ProtocolProviderFactory</tt>s obtained from the bundlecontext
 */
public static Map<Object,ProtocolProviderFactory> getProtocolProviderFactories(){
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  if (serRefs != null) {
    for (int i=0; i < serRefs.length; i++) {
      ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)bundleContext.getService(serRefs[i]);
      providerFactoriesMap.put(serRefs[i].getProperty(ProtocolProviderFactory.PROTOCOL),providerFactory);
    }
  }
  return providerFactoriesMap;
}","/** 
 * Returns all <tt>ProtocolProviderFactory</tt>s obtained from the bundle context.
 * @return all <tt>ProtocolProviderFactory</tt>s obtained from the bundlecontext
 */
public static Map<Object,ProtocolProviderFactory> getProtocolProviderFactories(){
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  if (serRefs != null) {
    for (    ServiceReference serRef : serRefs) {
      ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)bundleContext.getService(serRef);
      providerFactoriesMap.put(serRef.getProperty(ProtocolProviderFactory.PROTOCOL),providerFactory);
    }
  }
  return providerFactoriesMap;
}",0.952144188937228
103608,"/** 
 * Returns the <tt>AccountManager</tt> obtained from the bundle context.
 * @return the <tt>AccountManager</tt> obtained from the bundle context
 */
public static AccountManager getAccountManager(){
  if (accountManager == null) {
    ServiceReference accountManagerRef=bundleContext.getServiceReference(AccountManager.class.getName());
    accountManager=(AccountManager)bundleContext.getService(accountManagerRef);
  }
  return accountManager;
}","/** 
 * Returns the <tt>AccountManager</tt> obtained from the bundle context.
 * @return the <tt>AccountManager</tt> obtained from the bundle context
 */
public static AccountManager getAccountManager(){
  if (accountManager == null) {
    accountManager=ServiceUtils.getService(bundleContext,AccountManager.class);
  }
  return accountManager;
}",0.6741854636591479
103609,"/** 
 * Returns the <tt>ConfigurationService</tt> obtained from the bundle context.
 * @return the <tt>ConfigurationService</tt> obtained from the bundlecontext
 */
public static ConfigurationService getConfigurationService(){
  if (configService == null) {
    ServiceReference configReference=bundleContext.getServiceReference(ConfigurationService.class.getName());
    configService=(ConfigurationService)bundleContext.getService(configReference);
  }
  return configService;
}","/** 
 * Returns the <tt>ConfigurationService</tt> obtained from the bundle context.
 * @return the <tt>ConfigurationService</tt> obtained from the bundlecontext
 */
public static ConfigurationService getConfigurationService(){
  if (configService == null) {
    configService=ServiceUtils.getService(bundleContext,ConfigurationService.class);
  }
  return configService;
}",0.6737089201877934
103610,"/** 
 * Returns the <tt>MetaHistoryService</tt> obtained from the bundle context.
 * @return the <tt>MetaHistoryService</tt> obtained from the bundlecontext
 */
public static MetaHistoryService getMetaHistoryService(){
  if (metaHistoryService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(MetaHistoryService.class.getName());
    if (serviceReference != null)     metaHistoryService=(MetaHistoryService)bundleContext.getService(serviceReference);
  }
  return metaHistoryService;
}","/** 
 * Returns the <tt>MetaHistoryService</tt> obtained from the bundle context.
 * @return the <tt>MetaHistoryService</tt> obtained from the bundlecontext
 */
public static MetaHistoryService getMetaHistoryService(){
  if (metaHistoryService == null) {
    metaHistoryService=ServiceUtils.getService(bundleContext,MetaHistoryService.class);
  }
  return metaHistoryService;
}",0.6830357142857143
103611,"/** 
 * Handles button actions.
 * @param event the <tt>ActionEvent</tt> that notified us
 */
public void actionPerformed(ActionEvent event){
  JButton sourceButton=(JButton)event.getSource();
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)networkComboBox.getSelectedItem();
  AccountRegWizardContainerImpl wizardContainer=((AccountRegWizardContainerImpl)GuiActivator.getUIService().getAccountRegWizardContainer());
  if (sourceButton.equals(advancedButton)) {
    wizard.setModification(false);
    wizardContainer.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    wizardContainer.setCurrentWizard(wizard);
    wizardContainer.showDialog(false);
    this.dispose();
  }
 else   if (sourceButton.equals(addAccountButton)) {
    ProtocolProviderService protocolProvider;
    try {
      if (wizard == emptyWizard) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
      protocolProvider=wizard.signin();
      if (protocolProvider != null)       wizardContainer.saveAccountWizard(protocolProvider,wizard);
      this.dispose();
    }
 catch (    OperationFailedException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      if (e.getErrorCode() == OperationFailedException.ILLEGAL_ARGUMENT) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
 else       if (e.getErrorCode() == OperationFailedException.IDENTIFICATION_CONFLICT) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
 else {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{e.getMessage()}));
      }
    }
catch (    Exception e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{e.getMessage()}));
    }
  }
 else   if (sourceButton.equals(cancelButton)) {
    this.dispose();
  }
}","/** 
 * Handles button actions.
 * @param event the <tt>ActionEvent</tt> that notified us
 */
public void actionPerformed(ActionEvent event){
  JButton sourceButton=(JButton)event.getSource();
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)networkComboBox.getSelectedItem();
  AccountRegWizardContainerImpl wizardContainer=((AccountRegWizardContainerImpl)GuiActivator.getUIService().getAccountRegWizardContainer());
  if (sourceButton.equals(advancedButton)) {
    wizard.setModification(false);
    wizardContainer.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    wizardContainer.setCurrentWizard(wizard);
    wizardContainer.showDialog(false);
    this.dispose();
  }
 else   if (sourceButton.equals(addAccountButton)) {
    ProtocolProviderService protocolProvider;
    try {
      if (wizard == emptyWizard) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
      protocolProvider=wizard.signin();
      if (protocolProvider != null) {
        wizardContainer.saveAccountWizard(protocolProvider,wizard);
        this.dispose();
      }
    }
 catch (    OperationFailedException e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      if (e.getErrorCode() == OperationFailedException.ILLEGAL_ARGUMENT) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
 else       if (e.getErrorCode() == OperationFailedException.IDENTIFICATION_CONFLICT) {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str""));
      }
 else {
        loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{e.getMessage()}));
      }
    }
catch (    Exception e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"");
      loadErrorMessage(GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{e.getMessage()}));
    }
  }
 else   if (sourceButton.equals(cancelButton)) {
    this.dispose();
  }
}",0.9965652600588812
103612,"/** 
 * Creates the error area component.
 */
private void initErrorArea(){
  SimpleAttributeSet attribs=new SimpleAttributeSet();
  StyleConstants.setAlignment(attribs,StyleConstants.ALIGN_RIGHT);
  StyleConstants.setFontFamily(attribs,errorPane.getFont().getFamily());
  StyleConstants.setForeground(attribs,Color.RED);
  errorPane.setParagraphAttributes(attribs,true);
  errorPane.setOpaque(false);
}","/** 
 * Creates the error area component.
 */
private void initErrorArea(){
  SimpleAttributeSet attribs=new SimpleAttributeSet();
  StyleConstants.setAlignment(attribs,StyleConstants.ALIGN_RIGHT);
  StyleConstants.setFontFamily(attribs,errorPane.getFont().getFamily());
  StyleConstants.setForeground(attribs,Color.RED);
  errorPane.setParagraphAttributes(attribs,true);
  errorPane.setPreferredSize(new Dimension(100,50));
  errorPane.setMinimumSize(new Dimension(100,50));
  errorPane.setOpaque(false);
}",0.8857142857142857
103613,"/** 
 * Initializes this panel.
 */
private void init(){
  JPanel labelsPanel=new TransparentPanel(new GridLayout(0,1));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(0,1));
  JLabel usernameLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel displayNameLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel passLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel retypePasswordLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel emailLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  labelsPanel.add(usernameLabel);
  labelsPanel.add(displayNameLabel);
  labelsPanel.add(passLabel);
  labelsPanel.add(retypePasswordLabel);
  labelsPanel.add(emailLabel);
  valuesPanel.add(usernameField);
  valuesPanel.add(displayNameField);
  valuesPanel.add(passField);
  valuesPanel.add(retypePassField);
  valuesPanel.add(emailField);
  initErrorArea();
  add(errorPane,BorderLayout.NORTH);
  add(labelsPanel,BorderLayout.WEST);
  add(valuesPanel,BorderLayout.CENTER);
}","/** 
 * Initializes this panel.
 */
private void init(){
  JPanel labelsPanel=new TransparentPanel(new GridLayout(0,1));
  JPanel valuesPanel=new TransparentPanel(new GridLayout(0,1));
  JLabel usernameLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel displayNameLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel passLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel retypePasswordLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  JLabel emailLabel=new JLabel(Sip2SipAccRegWizzActivator.getResources().getI18NString(""String_Node_Str""));
  labelsPanel.add(usernameLabel);
  labelsPanel.add(displayNameLabel);
  labelsPanel.add(passLabel);
  labelsPanel.add(retypePasswordLabel);
  labelsPanel.add(emailLabel);
  valuesPanel.add(usernameField);
  valuesPanel.add(displayNameField);
  valuesPanel.add(passField);
  valuesPanel.add(retypePassField);
  valuesPanel.add(emailField);
  initErrorArea();
  add(labelsPanel,BorderLayout.WEST);
  add(valuesPanel,BorderLayout.CENTER);
}",0.98456403838131
103614,"/** 
 * Parses the given http response.
 * @param response the http response to parse
 * @return the new account
 */
private NewAccount parseHttpResponse(String response){
  NewAccount newAccount=null;
  try {
    JSONObject jsonObject=new JSONObject(response);
    boolean isSuccess=jsonObject.getBoolean(""String_Node_Str"");
    if (isSuccess) {
      newAccount=new NewAccount(jsonObject.getString(""String_Node_Str""),passField.getPassword(),null,jsonObject.getString(""String_Node_Str""));
    }
 else {
      String errorMessage=jsonObject.getString(""String_Node_Str"");
      errorPane.setText(errorMessage);
      SwingUtilities.getWindowAncestor(CreateSip2SipAccountForm.this).pack();
    }
  }
 catch (  JSONException e1) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e1);
  }
  return newAccount;
}","/** 
 * Parses the given http response.
 * @param response the http response to parse
 * @return the new account
 */
private NewAccount parseHttpResponse(String response){
  NewAccount newAccount=null;
  try {
    JSONObject jsonObject=new JSONObject(response);
    boolean isSuccess=jsonObject.getBoolean(""String_Node_Str"");
    if (isSuccess) {
      newAccount=new NewAccount(jsonObject.getString(""String_Node_Str""),passField.getPassword(),null,jsonObject.getString(""String_Node_Str""));
    }
 else {
      String errorMessage=jsonObject.getString(""String_Node_Str"");
      errorPane.setText(errorMessage);
      add(errorPane,BorderLayout.NORTH);
      SwingUtilities.getWindowAncestor(CreateSip2SipAccountForm.this).pack();
    }
  }
 catch (  JSONException e1) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"",e1);
  }
  return newAccount;
}",0.9757539917208752
103615,"/** 
 * Clears all the data previously entered in the form.
 */
public void clear(){
  usernameField.setText(""String_Node_Str"");
  displayNameField.setText(""String_Node_Str"");
  passField.setText(""String_Node_Str"");
  retypePassField.setText(""String_Node_Str"");
  emailField.setText(""String_Node_Str"");
}","/** 
 * Clears all the data previously entered in the form.
 */
public void clear(){
  usernameField.setText(""String_Node_Str"");
  displayNameField.setText(""String_Node_Str"");
  passField.setText(""String_Node_Str"");
  retypePassField.setText(""String_Node_Str"");
  emailField.setText(""String_Node_Str"");
  errorPane.setText(""String_Node_Str"");
  remove(errorPane);
}",0.9088191330343796
103616,"/** 
 * Saves the user input when the ""Next"" wizard buttons is clicked.
 */
public void commitPage(){
  registrationForm.commitPage(wizard.getRegistration());
  nextPageIdentifier=SUMMARY_PAGE_IDENTIFIER;
  this.isCommitted=true;
}","/** 
 * Saves the user input when the ""Next"" wizard buttons is clicked.
 */
public void commitPage(){
  isCommitted=registrationForm.commitPage(wizard.getRegistration());
  nextPageIdentifier=SUMMARY_PAGE_IDENTIFIER;
}",0.9175946547884188
103617,"public Object getSimpleForm(){
  return registrationForm.getSimpleForm();
}","/** 
 * Returns the simple account registration form.
 * @return the simple account registration form
 */
public Object getSimpleForm(){
  return registrationForm.getSimpleForm();
}",0.5859375
103618,"public boolean isCommitted(){
  return isCommitted;
}","/** 
 * Returns <tt>true</tt> if the page is committed, <tt>false</tt> - otherwise.
 * @return <tt>true</tt> if the page is committed, <tt>false</tt> -otherwise
 */
public boolean isCommitted(){
  return isCommitted;
}",0.3911439114391143
103619,"/** 
 * Saves the user input when the ""Next"" wizard buttons is clicked.
 * @param registration the SIPAccountRegistration
 */
public void commitPage(SIPAccountRegistration registration){
  String userID=null;
  char[] password=null;
  String serverAddress=null;
  String proxyAddress=null;
  if (accountPanel.isCreateAccount()) {
    NewAccount newAccount=getCreateAccountService().createAccount();
    if (newAccount != null) {
      userID=newAccount.getUserName();
      password=newAccount.getPassword();
      serverAddress=newAccount.getServerAddress();
      proxyAddress=newAccount.getProxyAddress();
      if (serverAddress == null)       serverAddress=setServerFieldAccordingToUIN(userID);
      if (proxyAddress == null)       proxyAddress=serverAddress;
    }
 else {
      return;
    }
  }
 else {
    userID=accountPanel.getUserID();
    password=accountPanel.getPassword();
    serverAddress=connectionPanel.getServerAddress();
    proxyAddress=connectionPanel.getProxy();
  }
  if (userID == null || userID.trim().length() == 0)   throw new IllegalStateException(""String_Node_Str"");
  registration.setUserID(userID);
  if (password != null)   registration.setPassword(new String(password));
  registration.setRememberPassword(accountPanel.isRememberPassword());
  registration.setServerAddress(serverAddress);
  registration.setProxy(proxyAddress);
  String displayName=accountPanel.getDisplayName();
  registration.setDisplayName(displayName);
  String authName=connectionPanel.getAuthenticationName();
  if (authName != null && authName.length() > 0)   registration.setAuthorizationName(authName);
  registration.setServerPort(connectionPanel.getServerPort());
  registration.setProxyPort(connectionPanel.getProxyPort());
  registration.setPreferredTransport(connectionPanel.getSelectedTransport());
  registration.setEnablePresence(presencePanel.isPresenceEnabled());
  registration.setForceP2PMode(presencePanel.isForcePeerToPeerMode());
  registration.setDefaultEncryption(connectionPanel.isDefaultEncryptionEnabled());
  registration.setSipZrtpAttribute(connectionPanel.isSipZrtpEnabled());
  registration.setPollingPeriod(presencePanel.getPollPeriod());
  registration.setSubscriptionExpiration(presencePanel.getSubscriptionExpiration());
  registration.setKeepAliveMethod(connectionPanel.getKeepAliveMethod());
  registration.setKeepAliveInterval(connectionPanel.getKeepAliveInterval());
  SIPAccRegWizzActivator.getUIService().getAccountRegWizardContainer().setBackButtonEnabled(true);
}","/** 
 * Saves the user input when the ""Next"" wizard buttons is clicked.
 * @param registration the SIPAccountRegistration
 */
public boolean commitPage(SIPAccountRegistration registration){
  String userID=null;
  char[] password=null;
  String serverAddress=null;
  String proxyAddress=null;
  if (accountPanel.isCreateAccount()) {
    NewAccount newAccount=getCreateAccountService().createAccount();
    if (newAccount != null) {
      userID=newAccount.getUserName();
      password=newAccount.getPassword();
      serverAddress=newAccount.getServerAddress();
      proxyAddress=newAccount.getProxyAddress();
      if (serverAddress == null)       serverAddress=setServerFieldAccordingToUIN(userID);
      if (proxyAddress == null)       proxyAddress=serverAddress;
    }
 else {
      return false;
    }
  }
 else {
    userID=accountPanel.getUserID();
    password=accountPanel.getPassword();
    serverAddress=connectionPanel.getServerAddress();
    proxyAddress=connectionPanel.getProxy();
  }
  if (userID == null || userID.trim().length() == 0)   throw new IllegalStateException(""String_Node_Str"");
  registration.setUserID(userID);
  if (password != null)   registration.setPassword(new String(password));
  registration.setRememberPassword(accountPanel.isRememberPassword());
  registration.setServerAddress(serverAddress);
  registration.setProxy(proxyAddress);
  String displayName=accountPanel.getDisplayName();
  registration.setDisplayName(displayName);
  String authName=connectionPanel.getAuthenticationName();
  if (authName != null && authName.length() > 0)   registration.setAuthorizationName(authName);
  registration.setServerPort(connectionPanel.getServerPort());
  registration.setProxyPort(connectionPanel.getProxyPort());
  registration.setPreferredTransport(connectionPanel.getSelectedTransport());
  registration.setEnablePresence(presencePanel.isPresenceEnabled());
  registration.setForceP2PMode(presencePanel.isForcePeerToPeerMode());
  registration.setDefaultEncryption(connectionPanel.isDefaultEncryptionEnabled());
  registration.setSipZrtpAttribute(connectionPanel.isSipZrtpEnabled());
  registration.setPollingPeriod(presencePanel.getPollPeriod());
  registration.setSubscriptionExpiration(presencePanel.getSubscriptionExpiration());
  registration.setKeepAliveMethod(connectionPanel.getKeepAliveMethod());
  registration.setKeepAliveInterval(connectionPanel.getKeepAliveInterval());
  SIPAccRegWizzActivator.getUIService().getAccountRegWizardContainer().setBackButtonEnabled(true);
  return true;
}",0.9936633663366335
103620,"/** 
 * Returns a simple version of this registration form.
 * @return the simple form component
 */
public Component getSimpleForm(){
  return accountPanel;
}","/** 
 * Returns a simple version of this registration form.
 * @return the simple form component
 */
public Component getSimpleForm(){
  CreateAccountService createAccountService=getCreateAccountService();
  if (createAccountService != null)   createAccountService.clear();
  return accountPanel;
}",0.6958424507658644
103621,"/** 
 * Dispatches the given mouse <tt>event</tt> to the underlying buttons.
 * @param event the <tt>MouseEvent</tt> to dispatch
 */
private void dispatchEventToCheckBox(MouseEvent event){
  int mouseIndex=this.locationToIndex(event.getPoint());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + mouseIndex);
  if (mouseIndex < 0)   return;
  Object value=getModel().getElementAt(mouseIndex);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + value);
  AccountListCellRenderer renderer=(AccountListCellRenderer)getCellRenderer().getListCellRendererComponent(this,value,mouseIndex,true,true);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + renderer.getBounds());
  Rectangle r=this.getCellBounds(mouseIndex,mouseIndex);
  int translatedX=event.getX() - r.x;
  int translatedY=event.getY() - r.y;
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + translatedX + ""String_Node_Str""+ translatedY);
  Component mouseComponent=renderer.findComponentAt(translatedX,translatedY);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + mouseComponent);
  if (mouseComponent instanceof JCheckBox) {
    JCheckBox checkBox=((JCheckBox)mouseComponent);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + !checkBox.isSelected());
    checkBox.setSelected(!checkBox.isSelected());
    enableAccount((Account)value,checkBox.isSelected());
    this.repaint();
  }
}","/** 
 * Dispatches the given mouse <tt>event</tt> to the underlying buttons.
 * @param event the <tt>MouseEvent</tt> to dispatch
 */
private void dispatchEventToCheckBox(MouseEvent event){
  int mouseIndex=this.locationToIndex(event.getPoint());
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + mouseIndex);
  if (mouseIndex < 0)   return;
  Account account=(Account)getModel().getElementAt(mouseIndex);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + account);
  AccountListCellRenderer renderer=(AccountListCellRenderer)getCellRenderer().getListCellRendererComponent(this,account,mouseIndex,true,true);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + renderer.getBounds());
  Rectangle r=this.getCellBounds(mouseIndex,mouseIndex);
  int translatedX=event.getX() - r.x;
  int translatedY=event.getY() - r.y;
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + translatedX + ""String_Node_Str""+ translatedY);
  if (renderer.isOverCheckBox(translatedX,translatedY)) {
    JCheckBox checkBox=account.getEnableCheckBox();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + !checkBox.isSelected());
    checkBox.setSelected(!checkBox.isSelected());
    enableAccount(account,checkBox.isSelected());
    this.repaint();
  }
}",0.7813750454710804
103622,"/** 
 * Returns the renderer component for the cell given by all the parameters.
 * @param list the parent list
 * @param value the value of the cell
 * @param index the index of the cell
 * @param isSelected indicates if the cell is selected
 * @param cellHasFocus indicates if the cell has the focus
 * @return the component rendering the cell
 */
public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.account=(Account)value;
  Icon accountIcon=account.getIcon();
  if (accountIcon != null)   accountLabel.setIcon(accountIcon);
  accountLabel.setText(account.getName());
  Icon statusIcon=account.getStatusIcon();
  if (statusIcon != null)   statusLabel.setIcon(statusIcon);
  String statusName=account.getStatusName();
  if (statusName != null)   statusLabel.setText(statusName);
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  if (!account.isEnabled()) {
    accountLabel.setForeground(Color.GRAY);
    statusLabel.setForeground(Color.GRAY);
  }
 else {
    accountLabel.setForeground(Color.BLACK);
    statusLabel.setForeground(Color.BLACK);
  }
  this.index=index;
  this.isSelected=isSelected;
  this.setBounds(0,0,list.getWidth(),getPreferredSize().height);
  this.addCheckBox();
  return this;
}","/** 
 * Returns the renderer component for the cell given by all the parameters.
 * @param list the parent list
 * @param value the value of the cell
 * @param index the index of the cell
 * @param isSelected indicates if the cell is selected
 * @param cellHasFocus indicates if the cell has the focus
 * @return the component rendering the cell
 */
public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.account=(Account)value;
  Icon accountIcon=account.getIcon();
  if (accountIcon != null)   accountLabel.setIcon(accountIcon);
  accountLabel.setText(account.getName());
  Icon statusIcon=account.getStatusIcon();
  if (statusIcon != null)   statusLabel.setIcon(statusIcon);
  String statusName=account.getStatusName();
  if (statusName != null)   statusLabel.setText(statusName);
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  if (!account.isEnabled()) {
    accountLabel.setForeground(Color.GRAY);
    statusLabel.setForeground(Color.GRAY);
  }
 else {
    accountLabel.setForeground(Color.BLACK);
    statusLabel.setForeground(Color.BLACK);
  }
  this.index=index;
  this.isSelected=isSelected;
  this.setBounds(0,0,list.getWidth(),getPreferredSize().height);
  this.addCheckBox(account);
  return this;
}",0.9972983404091084
103623,"/** 
 * Adds a check box component to this renderer.
 */
private void addCheckBox(){
  for (  Component c : getComponents()) {
    if (c instanceof JCheckBox)     remove(c);
  }
  final JCheckBox checkBox=new JCheckBox();
  checkBox.setBounds(5,5,45,45);
  constraints.anchor=GridBagConstraints.WEST;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.weightx=0f;
  add(checkBox,constraints);
  checkBox.setSelected(account.isEnabled());
}","/** 
 * Adds a check box component to this renderer.
 * @param account the account for which we're adding a check box
 */
private void addCheckBox(Account account){
  for (  Component c : getComponents()) {
    if (c instanceof JCheckBox)     remove(c);
  }
  JCheckBox checkBox=account.getEnableCheckBox();
  if (checkBox == null) {
    checkBox=new JCheckBox();
    account.setEnableCheckBox(checkBox);
  }
  constraints.anchor=GridBagConstraints.WEST;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.weightx=0f;
  add(checkBox,constraints);
  checkBox.setSelected(account.isEnabled());
}",0.7352380952380952
103624,"/** 
 * Creates an instance of the <tt>AudioConfigurationPanel</tt>.
 */
public AudioConfigurationPanel(){
  super(new BorderLayout());
  this.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  add(MediaConfiguration.createAudioConfigPanel(),BorderLayout.NORTH);
}","/** 
 * Creates an instance of the <tt>AudioConfigurationPanel</tt>.
 */
public AudioConfigurationPanel(){
  super(new BorderLayout());
  add(MediaConfiguration.createAudioConfigPanel(),BorderLayout.NORTH);
}",0.8666666666666667
103625,"/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 */
private static void createPortAudioControls(JPanel portAudioPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final SIPCommCheckBox echoCancelCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final SIPCommCheckBox denoiseCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  portAudioPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
}","/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 */
private static void createPortAudioControls(JPanel portAudioPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final SIPCommCheckBox echoCancelCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final SIPCommCheckBox denoiseCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  portAudioPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
  if (portAudioPanel.isVisible()) {
    portAudioPanel.validate();
    portAudioPanel.repaint();
  }
}",0.983197471302612
103626,"/** 
 * Creates an instance of the <tt>VideoConfigurationPanel</tt>.
 */
public VideoConfigurationPanel(){
  super(new BorderLayout());
  this.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  add(MediaConfiguration.createVideoConfigPanel(),BorderLayout.NORTH);
}","/** 
 * Creates an instance of the <tt>VideoConfigurationPanel</tt>.
 */
public VideoConfigurationPanel(){
  super(new BorderLayout());
  add(MediaConfiguration.createVideoConfigPanel(),BorderLayout.NORTH);
}",0.8666666666666667
103627,"/** 
 * Disposes the chat window.
 * @param chatWindow the <tt>ChatWindow</tt> to dispose of
 */
private void disposeChatWindow(ChatWindow chatWindow){
  for (  ChatPanel chatPanel : chatPanels)   chatPanel.dispose();
synchronized (chatPanels) {
    chatPanels.clear();
  }
  if (chatWindow.getChatCount() > 0)   chatWindow.removeAllChats();
  GuiActivator.getUIService().unregisterExportedWindow(chatWindow);
  chatWindow.dispose();
  GuiActivator.getContactList().deactivateAll();
}","/** 
 * Disposes the chat window.
 * @param chatWindow the <tt>ChatWindow</tt> to dispose of
 */
private void disposeChatWindow(ChatWindow chatWindow){
  List<ChatPanel> chatPanelsToDispose=chatWindow.getChatPanels();
  for (  ChatPanel chatPanel : chatPanelsToDispose)   chatPanel.dispose();
synchronized (chatPanels) {
    chatPanels.removeAll(chatPanelsToDispose);
  }
  if (chatWindow.getChatCount() > 0)   chatWindow.removeAllChats();
  GuiActivator.getUIService().unregisterExportedWindow(chatWindow);
  chatWindow.dispose();
  GuiActivator.getContactList().deactivateAll();
}",0.8968105065666041
103628,"/** 
 * Creates all the controls for a type(AUDIO or VIDEO)
 * @param type the type.
 * @return the build Component.
 */
private static Component createControls(int type){
  final JComboBox comboBox=new JComboBox();
  comboBox.setEditable(false);
  comboBox.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),type));
  final JPanel portAudioPanel;
  if (type == DeviceConfigurationComboBoxModel.AUDIO) {
    portAudioPanel=new TransparentPanel(new GridBagLayout());
    portAudioPanel.setPreferredSize(new Dimension(WIDTH,200));
    portAudioPanel.setMaximumSize(new Dimension(WIDTH,200));
    comboBox.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        if (e.getStateChange() == ItemEvent.SELECTED) {
          if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
            createPortAudioControls(portAudioPanel);
          }
 else {
            portAudioPanel.removeAll();
            portAudioPanel.revalidate();
            portAudioPanel.repaint();
          }
        }
      }
    }
);
    if (comboBox.getSelectedItem().equals(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO))     createPortAudioControls(portAudioPanel);
  }
 else {
    portAudioPanel=null;
  }
  JLabel label=new JLabel(getLabelText(type));
  label.setDisplayedMnemonic(getDisplayedMnemonic(type));
  label.setLabelFor(comboBox);
  Container firstContainer=new TransparentPanel(new FlowLayout(FlowLayout.CENTER));
  firstContainer.setMaximumSize(new Dimension(WIDTH,25));
  firstContainer.add(label);
  firstContainer.add(comboBox);
  JPanel secondContainer=new TransparentPanel();
  secondContainer.setLayout(new BoxLayout(secondContainer,BoxLayout.Y_AXIS));
  if (portAudioPanel != null) {
    secondContainer.add(portAudioPanel);
  }
 else {
    comboBox.setLightWeightPopupEnabled(false);
    secondContainer.add(createPreview(type,comboBox));
  }
  secondContainer.add(createEncodingControls(type));
  JPanel container=new TransparentPanel(new BorderLayout());
  container.add(firstContainer,BorderLayout.NORTH);
  container.add(secondContainer,BorderLayout.CENTER);
  return container;
}","/** 
 * Creates all the controls for a type(AUDIO or VIDEO)
 * @param type the type.
 * @return the build Component.
 */
private static Component createControls(int type){
  final JComboBox comboBox=new JComboBox();
  comboBox.setEditable(false);
  comboBox.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),type));
  final JPanel portAudioPanel;
  if (type == DeviceConfigurationComboBoxModel.AUDIO) {
    portAudioPanel=new TransparentPanel(new GridBagLayout());
    portAudioPanel.setPreferredSize(new Dimension(WIDTH,200));
    portAudioPanel.setMaximumSize(new Dimension(WIDTH,200));
    comboBox.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        if (e.getStateChange() == ItemEvent.SELECTED) {
          if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
            createPortAudioControls(portAudioPanel);
          }
 else {
            portAudioPanel.removeAll();
          }
          portAudioPanel.revalidate();
          portAudioPanel.repaint();
        }
      }
    }
);
    if (comboBox.getSelectedItem().equals(DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO))     createPortAudioControls(portAudioPanel);
  }
 else {
    portAudioPanel=null;
  }
  JLabel label=new JLabel(getLabelText(type));
  label.setDisplayedMnemonic(getDisplayedMnemonic(type));
  label.setLabelFor(comboBox);
  Container firstContainer=new TransparentPanel(new FlowLayout(FlowLayout.CENTER));
  firstContainer.setMaximumSize(new Dimension(WIDTH,25));
  firstContainer.add(label);
  firstContainer.add(comboBox);
  JPanel secondContainer=new TransparentPanel();
  secondContainer.setLayout(new BoxLayout(secondContainer,BoxLayout.Y_AXIS));
  if (portAudioPanel != null) {
    secondContainer.add(portAudioPanel);
  }
 else {
    comboBox.setLightWeightPopupEnabled(false);
    secondContainer.add(createPreview(type,comboBox));
  }
  secondContainer.add(createEncodingControls(type));
  JPanel container=new TransparentPanel(new BorderLayout());
  container.add(firstContainer,BorderLayout.NORTH);
  container.add(secondContainer,BorderLayout.CENTER);
  return container;
}",0.9944547134935304
103629,"public void itemStateChanged(ItemEvent e){
  if (e.getStateChange() == ItemEvent.SELECTED) {
    if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
      createPortAudioControls(portAudioPanel);
    }
 else {
      portAudioPanel.removeAll();
      portAudioPanel.revalidate();
      portAudioPanel.repaint();
    }
  }
}","public void itemStateChanged(ItemEvent e){
  if (e.getStateChange() == ItemEvent.SELECTED) {
    if (DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO.equals(e.getItem())) {
      createPortAudioControls(portAudioPanel);
    }
 else {
      portAudioPanel.removeAll();
    }
    portAudioPanel.revalidate();
    portAudioPanel.repaint();
  }
}",0.9822485207100592
103630,"/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 */
private static void createPortAudioControls(JPanel portAudioPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final SIPCommCheckBox echoCancelCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final SIPCommCheckBox denoiseCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  portAudioPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
  if (portAudioPanel.isVisible()) {
    portAudioPanel.validate();
    portAudioPanel.repaint();
  }
}","/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 */
private static void createPortAudioControls(JPanel portAudioPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final SIPCommCheckBox echoCancelCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final SIPCommCheckBox denoiseCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  portAudioPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
}",0.983197471302612
103631,"/** 
 * Shows on the right the configuration form given by the given <tt>ConfigFormDescriptor</tt>.
 * @param configFormDescriptor the descriptor of the for we will be showing.
 */
public void showFormContent(ConfigFormDescriptor configFormDescriptor){
  this.centerPanel.removeAll();
  JComponent configFormPanel=(JComponent)configFormDescriptor.getConfigFormPanel();
  configFormPanel.setOpaque(false);
  centerPanel.add(configFormPanel,BorderLayout.CENTER);
  centerPanel.revalidate();
  centerPanel.setPreferredSize(new Dimension(550,configFormPanel.getPreferredSize().height));
  centerPanel.repaint();
  pack();
}","/** 
 * Shows on the right the configuration form given by the given <tt>ConfigFormDescriptor</tt>.
 * @param configFormDescriptor the descriptor of the for we will be showing.
 */
public void showFormContent(ConfigFormDescriptor configFormDescriptor){
  this.centerPanel.removeAll();
  JComponent configFormPanel=(JComponent)configFormDescriptor.getConfigFormPanel();
  configFormPanel.setOpaque(false);
  centerPanel.add(configFormPanel,BorderLayout.CENTER);
  centerPanel.revalidate();
  centerPanel.setPreferredSize(new Dimension(550,configFormPanel.getPreferredSize().height + 2 * BORDER_SIZE));
  pack();
}",0.958570268074736
103632,"/** 
 * Creates an instance of <tt>ConfigurationManagerImpl</tt>.
 * @param mainFrame The main application window.
 */
public ConfigurationFrame(MainFrame mainFrame){
  super(mainFrame,false);
  this.configList=new ConfigFormList(this);
  JScrollPane configScrollList=new JScrollPane();
  configScrollList.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  configScrollList.setBorder(BorderFactory.createEmptyBorder());
  configScrollList.setOpaque(false);
  configScrollList.getViewport().setOpaque(false);
  configScrollList.getViewport().add(configList);
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.getContentPane().setLayout(new BorderLayout());
  this.addDefaultForms();
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(5,5));
  centerPanel.setMinimumSize(new Dimension(600,100));
  centerPanel.setMaximumSize(new Dimension(600,Toolkit.getDefaultToolkit().getScreenSize().height));
  this.setResizable(false);
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  mainPanel.add(centerPanel,BorderLayout.SOUTH);
  mainPanel.add(configScrollList,BorderLayout.NORTH);
  centerPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  this.getContentPane().add(mainPanel);
  GuiActivator.bundleContext.addServiceListener(this);
  String osgiFilter=""String_Node_Str"" + ConfigurationForm.FORM_TYPE + ""String_Node_Str""+ ConfigurationForm.GENERAL_TYPE+ ""String_Node_Str"";
  ServiceReference[] confFormsRefs=null;
  try {
    confFormsRefs=GuiActivator.bundleContext.getServiceReferences(ConfigurationForm.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
  }
  if (confFormsRefs != null) {
    for (int i=0; i < confFormsRefs.length; i++) {
      ConfigurationForm form=(ConfigurationForm)GuiActivator.bundleContext.getService(confFormsRefs[i]);
      this.addConfigurationForm(form);
    }
  }
}","/** 
 * Creates an instance of <tt>ConfigurationManagerImpl</tt>.
 * @param mainFrame The main application window.
 */
public ConfigurationFrame(MainFrame mainFrame){
  super(mainFrame,false);
  this.configList=new ConfigFormList(this);
  JScrollPane configScrollList=new JScrollPane();
  configScrollList.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  configScrollList.setBorder(BorderFactory.createEmptyBorder());
  configScrollList.setOpaque(false);
  configScrollList.getViewport().setOpaque(false);
  configScrollList.getViewport().add(configList);
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.getContentPane().setLayout(new BorderLayout());
  this.addDefaultForms();
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(5,5));
  centerPanel.setMinimumSize(new Dimension(600,100));
  centerPanel.setMaximumSize(new Dimension(600,Integer.MAX_VALUE));
  this.setResizable(false);
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  mainPanel.add(centerPanel,BorderLayout.SOUTH);
  mainPanel.add(configScrollList,BorderLayout.NORTH);
  centerPanel.setBorder(BorderFactory.createEmptyBorder(BORDER_SIZE,BORDER_SIZE,BORDER_SIZE,BORDER_SIZE));
  this.getContentPane().add(mainPanel);
  GuiActivator.bundleContext.addServiceListener(this);
  String osgiFilter=""String_Node_Str"" + ConfigurationForm.FORM_TYPE + ""String_Node_Str""+ ConfigurationForm.GENERAL_TYPE+ ""String_Node_Str"";
  ServiceReference[] confFormsRefs=null;
  try {
    confFormsRefs=GuiActivator.bundleContext.getServiceReferences(ConfigurationForm.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
  }
  if (confFormsRefs != null) {
    for (int i=0; i < confFormsRefs.length; i++) {
      ConfigurationForm form=(ConfigurationForm)GuiActivator.bundleContext.getService(confFormsRefs[i]);
      this.addConfigurationForm(form);
    }
  }
}",0.9689700130378096
103633,"/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null)       engine.setOwnSSRC(sendStream.getSSRC());
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
catch (    UnsupportedFormatException ufe) {
      exception=ufe;
    }
    if (exception != null) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,exception);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}","/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null)       engine.setOwnSSRC(sendStream.getSSRC());
    }
 catch (    IOException ioe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,ioe);
    }
catch (    UnsupportedFormatException ufe) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ ufe.getFailedFormat(),ufe);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}",0.933788979068774
103634,"/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",16000,351);
  setEncodingPreference(""String_Node_Str"",32000,350);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,0);
  setEncodingPreference(Constants.TELEPHONE_EVENT,8000,1);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  for (  String pName : confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false)) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1).replaceAll(""String_Node_Str"",""String_Node_Str"");
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}","/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",16000,351);
  setEncodingPreference(""String_Node_Str"",32000,350);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,0);
  setEncodingPreference(Constants.TELEPHONE_EVENT,8000,1);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  for (  String pName : confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false)) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1);
    if (fmtName.contains(""String_Node_Str"")) {
      fmtName=fmtName.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (confService.getString(PROP_SDP_PREFERENCE + ""String_Node_Str"" + fmtName) != null)       continue;
    }
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}",0.962217659137577
103635,"/** 
 * Compares the two formats for order. Returns a negative integer, zero, or a positive integer as the first format has been assigned a preference higher, equal to, or greater than the one of the second. <p>
 * @param enc1 the first format to compare for preference.
 * @param enc2 the second format to compare for preference.
 * @return a negative integer, zero, or a positive integer as the firstformat has been assigned a preference higher, equal to, or greater than the one of the second.
 */
private int compareEncodingPreferences(MediaFormat enc1,MediaFormat enc2){
  Integer pref1=encodingPreferences.get(enc1);
  int pref1IntValue=(pref1 == null) ? 0 : pref1;
  Integer pref2=encodingPreferences.get(enc2);
  int pref2IntValue=(pref2 == null) ? 0 : pref2;
  int res=pref2IntValue - pref1IntValue;
  if (res == 0)   return enc1.getEncoding().compareTo(enc2.getEncoding());
  return res;
}","/** 
 * Compares the two formats for order. Returns a negative integer, zero, or a positive integer as the first format has been assigned a preference higher, equal to, or greater than the one of the second.
 * @param enc1 the first format to compare for preference.
 * @param enc2 the second format to compare for preference
 * @return a negative integer, zero, or a positive integer as the firstformat has been assigned a preference higher, equal to, or greater than the one of the second
 */
private int compareEncodingPreferences(MediaFormat enc1,MediaFormat enc2){
  Integer pref1=encodingPreferences.get(enc1);
  int pref1IntValue=(pref1 == null) ? 0 : pref1;
  Integer pref2=encodingPreferences.get(enc2);
  int pref2IntValue=(pref2 == null) ? 0 : pref2;
  int res=pref2IntValue - pref1IntValue;
  if (res == 0) {
    res=enc1.getEncoding().compareTo(enc2.getEncoding());
  }
  return res;
}",0.9838619922092376
103636,"/** 
 * Schedules an update if necessary.
 */
private void updateContactListView(){
  String filterString=getText();
  FilterQuery filterQuery=null;
  if (filterString != null && filterString.length() > 0) {
    TreeContactList.searchFilter.setFilterString(filterString);
    filterQuery=GuiActivator.getContactList().applyFilter(TreeContactList.searchFilter);
  }
 else {
    filterQuery=GuiActivator.getContactList().applyDefaultFilter();
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + filterString + ""String_Node_Str""+ filterQuery);
  if (filterQuery != null && !filterQuery.isCanceled()) {
    if (filterQuery.isSucceeded())     enableUnknownContactView(false);
 else     filterQuery.setQueryListener(this);
  }
 else   enableUnknownContactView(GuiActivator.getContactList().isEmpty());
}","/** 
 * Schedules an update if necessary.
 */
private void updateContactListView(){
  String filterString=getText();
  FilterQuery filterQuery=null;
  boolean isDefaultFilter=false;
  if (filterString != null && filterString.length() > 0) {
    TreeContactList.searchFilter.setFilterString(filterString);
    filterQuery=GuiActivator.getContactList().applyFilter(TreeContactList.searchFilter);
  }
 else {
    filterQuery=GuiActivator.getContactList().applyDefaultFilter();
    isDefaultFilter=true;
  }
  if (filterQuery != null && !filterQuery.isCanceled()) {
    if (isDefaultFilter || filterQuery.isSucceeded())     enableUnknownContactView(false);
 else     filterQuery.setQueryListener(this);
  }
 else   enableUnknownContactView(GuiActivator.getContactList().isEmpty());
}",0.8795483061480552
103637,"/** 
 * Attempts to set the <tt>Format</tt> to be reported by the <tt>FormatControl</tt> of a <tt>PushBufferStream</tt> at a specific zero-based index in the list of streams of this <tt>PushBufferDataSource</tt>. The <tt>PushBufferStream</tt> does not exist at the time of the attempt to set its <tt>Format</tt>.
 * @param streamIndex the zero-based index of the <tt>PushBufferStream</tt>the <tt>Format</tt> of which is to be set
 * @param oldValue the last-known <tt>Format</tt> for the<tt>PushBufferStream</tt> at the specified <tt>streamIndex</tt>
 * @param newValue the <tt>Format</tt> which is to be set
 * @return the <tt>Format</tt> to be reported by the <tt>FormatControl</tt>of the <tt>PushBufferStream</tt> at the specified <tt>streamIndex</tt> in the list of streams of this <tt>PushBufferStream</tt> or <tt>null</tt> if the attempt to set the <tt>Format</tt> did not success and any last-known <tt>Format</tt> is to be left in effect
 * @see AbstractPushBufferCaptureDevice#setFormat(int,Format,Format)
 */
@Override protected Format setFormat(int streamIndex,Format oldValue,Format newValue){
  if (newValue instanceof VideoFormat) {
    VideoFormat newVideoFormatValue=(VideoFormat)newValue;
    Dimension newSize=newVideoFormatValue.getSize();
    if ((newSize != null) && (newSize.width < DEFAULT_WIDTH) && (newSize.height < DEFAULT_HEIGHT)) {
      String encoding=newVideoFormatValue.getEncoding();
      Class<?> dataType=newVideoFormatValue.getDataType();
      float frameRate=newVideoFormatValue.getFrameRate();
      newSize=new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
      newValue=((Format)newVideoFormatValue.clone()).relax().intersects(new VideoFormat(encoding,newSize,Format.NOT_SPECIFIED,dataType,frameRate));
    }
    if (newValue instanceof AVFrameFormat) {
      AVFrameFormat f=(AVFrameFormat)newValue;
      long pixelFormat=-1;
      int pixFmt=f.getPixFmt();
      pixelFormat=getDSPixFmt(pixFmt);
      if (pixelFormat != -1) {
        DSFormat fmt=new DSFormat(newSize.width,newSize.height,pixelFormat);
        device.setFormat(fmt);
      }
    }
    return newValue;
  }
 else {
    return super.setFormat(streamIndex,oldValue,newValue);
  }
}","/** 
 * Attempts to set the <tt>Format</tt> to be reported by the <tt>FormatControl</tt> of a <tt>PushBufferStream</tt> at a specific zero-based index in the list of streams of this <tt>PushBufferDataSource</tt>. The <tt>PushBufferStream</tt> does not exist at the time of the attempt to set its <tt>Format</tt>.
 * @param streamIndex the zero-based index of the <tt>PushBufferStream</tt>the <tt>Format</tt> of which is to be set
 * @param oldValue the last-known <tt>Format</tt> for the<tt>PushBufferStream</tt> at the specified <tt>streamIndex</tt>
 * @param newValue the <tt>Format</tt> which is to be set
 * @return the <tt>Format</tt> to be reported by the <tt>FormatControl</tt>of the <tt>PushBufferStream</tt> at the specified <tt>streamIndex</tt> in the list of streams of this <tt>PushBufferStream</tt> or <tt>null</tt> if the attempt to set the <tt>Format</tt> did not success and any last-known <tt>Format</tt> is to be left in effect
 * @see AbstractPushBufferCaptureDevice#setFormat(int,Format,Format)
 */
@Override protected Format setFormat(int streamIndex,Format oldValue,Format newValue){
  if (newValue instanceof VideoFormat) {
    VideoFormat newVideoFormatValue=(VideoFormat)newValue;
    Dimension newSize=newVideoFormatValue.getSize();
    if ((newSize != null) && (newSize.width < DEFAULT_WIDTH) && (newSize.height < DEFAULT_HEIGHT)) {
      String encoding=newVideoFormatValue.getEncoding();
      Class<?> dataType=newVideoFormatValue.getDataType();
      float frameRate=newVideoFormatValue.getFrameRate();
      newSize=new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
      newValue=((Format)newVideoFormatValue.clone()).relax().intersects(new VideoFormat(encoding,newSize,Format.NOT_SPECIFIED,dataType,frameRate));
    }
    if (newValue instanceof AVFrameFormat) {
      AVFrameFormat f=(AVFrameFormat)newValue;
      long pixelFormat=-1;
      int pixFmt=f.getPixFmt();
      pixelFormat=getDSPixFmt(pixFmt);
      if (pixelFormat != -1) {
        DSFormat fmt=new DSFormat(newSize.width,newSize.height,pixelFormat);
        nativeFormat=fmt;
      }
    }
    return newValue;
  }
 else {
    return super.setFormat(streamIndex,oldValue,newValue);
  }
}",0.9919890135042344
103638,"/** 
 * Starts the transfer of media data from this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while starting the transfer ofmedia data from this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doStart()
 */
@Override protected void doStart() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  device.open();
  device.setDelegate(grabber);
  super.doStart();
}","/** 
 * Starts the transfer of media data from this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while starting the transfer ofmedia data from this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doStart()
 */
@Override protected void doStart() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  device.open();
  if (nativeFormat != null) {
    device.setFormat(nativeFormat);
  }
  device.setDelegate(grabber);
  super.doStart();
}",0.925053533190578
103639,"/** 
 * Opens a connection to the media source specified by the <tt>MediaLocator</tt> of this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while opening the connectionto the media source specified by the <tt>MediaLocator</tt> of this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doConnect()
 */
@Override protected void doConnect() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (manager == null) {
    manager=DSManager.getInstance();
  }
  super.doConnect();
}","/** 
 * Opens a connection to the media source specified by the <tt>MediaLocator</tt> of this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while opening the connectionto the media source specified by the <tt>MediaLocator</tt> of this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doConnect()
 */
@Override protected void doConnect() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  if (manager == null) {
    manager=DSManager.getInstance();
    setLocator(getLocator());
  }
  super.doConnect();
}",0.9730700179533214
103640,"/** 
 * Create a new <tt>PushBufferStream</tt> which is to be at a specific zero-based index in the list of streams of this <tt>PushBufferDataSource</tt>. The <tt>Format</tt>-related information of the new instance is to be abstracted by a specific <tt>FormatControl</tt>.
 * @param streamIndex the zero-based index of the <tt>PushBufferStream</tt>in the list of streams of this <tt>PushBufferDataSource</tt>
 * @param formatControl the <tt>FormatControl</tt> which is to abstract the<tt>Format</tt>-related information of the new instance
 * @return a new <tt>PushBufferStream</tt> which is to be at the specified<tt>streamIndex</tt> in the list of streams of this <tt>PushBufferDataSource</tt> and which has its <tt>Format</tt>-related information abstracted by the specified <tt>formatControl</tt>
 * @see AbstractPushBufferCaptureDevice#createStream(int,FormatControl)
 */
protected AbstractPushBufferStream createStream(int streamIndex,FormatControl formatControl){
  DirectShowStream stream=new DirectShowStream(formatControl);
  device.setDelegate(stream.grabber);
  return stream;
}","/** 
 * Create a new <tt>PushBufferStream</tt> which is to be at a specific zero-based index in the list of streams of this <tt>PushBufferDataSource</tt>. The <tt>Format</tt>-related information of the new instance is to be abstracted by a specific <tt>FormatControl</tt>.
 * @param streamIndex the zero-based index of the <tt>PushBufferStream</tt>in the list of streams of this <tt>PushBufferDataSource</tt>
 * @param formatControl the <tt>FormatControl</tt> which is to abstract the<tt>Format</tt>-related information of the new instance
 * @return a new <tt>PushBufferStream</tt> which is to be at the specified<tt>streamIndex</tt> in the list of streams of this <tt>PushBufferDataSource</tt> and which has its <tt>Format</tt>-related information abstracted by the specified <tt>formatControl</tt>
 * @see AbstractPushBufferCaptureDevice#createStream(int,FormatControl)
 */
protected AbstractPushBufferStream createStream(int streamIndex,FormatControl formatControl){
  DirectShowStream stream=new DirectShowStream(formatControl);
  grabber=stream.grabber;
  return stream;
}",0.9880073800738008
103641,"/** 
 * Starts the transfer of media data from this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while starting the transfer ofmedia data from this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doStart()
 */
@Override protected void doStart() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  device.open();
  super.doStart();
}","/** 
 * Starts the transfer of media data from this <tt>DataSource</tt>.
 * @throws IOException if anything goes wrong while starting the transfer ofmedia data from this <tt>DataSource</tt>
 * @see AbstractPushBufferCaptureDevice#doStart()
 */
@Override protected void doStart() throws IOException {
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  device.open();
  device.setDelegate(grabber);
  super.doStart();
}",0.929171668667467
103642,"/** 
 * Sets the <tt>MediaLocator</tt> which specifies the media source of this <tt>DataSource</tt>.
 * @param locator the <tt>MediaLocator</tt> which specifies the media sourceof this <tt>DataSource</tt>
 * @see DataSource#setLocator(MediaLocator)
 */
@Override public void setLocator(MediaLocator locator){
  DSCaptureDevice device=null;
  super.setLocator(locator);
  locator=getLocator();
  if ((locator != null) && DirectShowAuto.LOCATOR_PROTOCOL.equalsIgnoreCase(locator.getProtocol())) {
    DSCaptureDevice[] devices=manager.getCaptureDevices();
    for (int i=0; i < devices.length; i++) {
      if (devices[i].getName().equals(locator.getRemainder())) {
        device=devices[i];
        break;
      }
    }
  }
 else {
    device=null;
  }
  setDevice(device);
}","/** 
 * Sets the <tt>MediaLocator</tt> which specifies the media source of this <tt>DataSource</tt>.
 * @param locator the <tt>MediaLocator</tt> which specifies the media sourceof this <tt>DataSource</tt>
 * @see DataSource#setLocator(MediaLocator)
 */
@Override public void setLocator(MediaLocator locator){
  DSCaptureDevice device=null;
  if (getLocator() == null) {
    super.setLocator(locator);
  }
  locator=getLocator();
  if ((locator != null) && DirectShowAuto.LOCATOR_PROTOCOL.equalsIgnoreCase(locator.getProtocol())) {
    DSCaptureDevice[] devices=manager.getCaptureDevices();
    for (int i=0; i < devices.length; i++) {
      if (devices[i].getName().equals(locator.getRemainder())) {
        device=devices[i];
        break;
      }
    }
  }
 else {
    device=null;
  }
  setDevice(device);
}",0.9773013871374528
103643,"/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
    this.abortConnectingAndReconnect=false;
    connectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    int reason=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
    if (ex.getWrappedThrowable() instanceof UnknownHostException)     reason=RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,reason,null);
  }
}","/** 
 * Connects and logins again to the server.
 * @param authReasonCode indicates the reason of the re-authentication.
 */
void reregister(int authReasonCode){
  try {
    logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.abortConnecting=false;
    connectAndLogin(authority,authReasonCode);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(ex);
  }
}",0.7785234899328859
103644,"/** 
 * Check whether a certificate is trusted, if not as user whether he trust it.
 * @param chain the certificate chain.
 * @param authType authentication type like: RSA.
 * @throws CertificateException not trusted.
 */
public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  if (certChecked)   return;
  abortConnecting=true;
  try {
    certChecked=true;
    tm.checkServerTrusted(chain,authType);
  }
 catch (  CertificateException e) {
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
    throw e;
  }
  if (abortConnecting) {
    abortConnectingAndReconnect=true;
    return;
  }
 else {
    new Thread(new Runnable(){
      public void run(){
        reregister(SecurityAuthority.CONNECTION_FAILED);
      }
    }
).start();
    return;
  }
}","/** 
 * Check whether a certificate is trusted, if not as user whether he trust it.
 * @param chain the certificate chain.
 * @param authType authentication type like: RSA.
 * @throws CertificateException not trusted.
 */
public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  if (certChecked)   return;
  abortConnecting=true;
  try {
    certChecked=true;
    tm.checkServerTrusted(chain,authType);
  }
 catch (  CertificateException e) {
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
    throw e;
  }
  if (abortConnecting) {
    abortConnecting=false;
    return;
  }
 else {
    new Thread(new Runnable(){
      public void run(){
        reregister(SecurityAuthority.CONNECTION_FAILED);
      }
    }
).start();
    return;
  }
}",0.6529933481152993
103645,"/** 
 * Unregister and fire the event if requested
 * @param fireEvent boolean
 */
private void unregister(boolean fireEvent){
synchronized (initializationLock) {
    RegistrationState currRegState=getRegistrationState();
    if (connection != null)     connection.disconnect();
    if (fireEvent) {
      fireRegistrationStateChanged(currRegState,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
    }
  }
}","/** 
 * Unregister and fire the event if requested
 * @param fireEvent boolean
 */
private void unregister(boolean fireEvent){
synchronized (initializationLock) {
    RegistrationState currRegState=getRegistrationState();
    if (connection != null && connection.isConnected())     connection.disconnect();
    if (fireEvent) {
      fireRegistrationStateChanged(currRegState,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
    }
  }
}",0.9695652173913044
103646,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private synchronized void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      org.jivesoftware.smack.proxy.ProxyInfo proxy=null;
      String globalProxyType=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
      if (globalProxyType == null || globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
        proxy=org.jivesoftware.smack.proxy.ProxyInfo.forNoProxy();
      }
 else {
        String globalProxyAddress=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
        String globalProxyPortStr=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
        int globalProxyPort;
        try {
          globalProxyPort=Integer.parseInt(globalProxyPortStr);
        }
 catch (        NumberFormatException ex) {
          throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
        }
        String globalProxyUsername=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
        String globalProxyPassword=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
        if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
          throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
        }
        if (globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forHttpProxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
 else         if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS4.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forSocks4Proxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
 else         if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS5.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forSocks5Proxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
      }
      ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName,proxy);
      confConn.setReconnectionAllowed(false);
      connection=new XMPPConnection(confConn);
      try {
        CertificateVerificationService gvs=getCertificateVerificationService();
        if (gvs != null)         connection.setCustomTrustManager(new HostTrustManager(gvs.getTrustManager(serverAddress,Integer.parseInt(serverPort))));
      }
 catch (      GeneralSecurityException e) {
        logger.error(""String_Node_Str"",e);
      }
      connection.connect();
      connection.addConnectionListener(new JabberConnectionListener());
      if (abortConnecting) {
        if (abortConnectingAndReconnect) {
          reregister(SecurityAuthority.CONNECTION_FAILED);
        }
 else {
          abortConnecting=false;
          connection.disconnect();
        }
        return;
      }
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
      SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.addConnectionListener(new JabberConnectionListener());
          if (abortConnecting) {
            if (abortConnectingAndReconnect) {
              reregister(SecurityAuthority.CONNECTION_FAILED);
            }
 else {
              abortConnecting=false;
              connection.disconnect();
            }
            return;
          }
          fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    discoveryManager.removeFeature(""String_Node_Str"");
    while (it.hasNext()) {
      String feature=it.next();
      if (!discoveryManager.includesFeature(feature))       discoveryManager.addFeature(feature);
    }
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private synchronized void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      org.jivesoftware.smack.proxy.ProxyInfo proxy=null;
      String globalProxyType=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_TYPE_PROPERTY_NAME);
      if (globalProxyType == null || globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {
        proxy=org.jivesoftware.smack.proxy.ProxyInfo.forNoProxy();
      }
 else {
        String globalProxyAddress=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_ADDRESS_PROPERTY_NAME);
        String globalProxyPortStr=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PORT_PROPERTY_NAME);
        int globalProxyPort;
        try {
          globalProxyPort=Integer.parseInt(globalProxyPortStr);
        }
 catch (        NumberFormatException ex) {
          throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
        }
        String globalProxyUsername=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_USERNAME_PROPERTY_NAME);
        String globalProxyPassword=JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTON_PROXY_PASSWORD_PROPERTY_NAME);
        if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {
          throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
        }
        if (globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forHttpProxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
 else         if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS4.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forSocks4Proxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
 else         if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS5.name())) {
          proxy=org.jivesoftware.smack.proxy.ProxyInfo.forSocks5Proxy(globalProxyAddress,globalProxyPort,globalProxyUsername,globalProxyPassword);
        }
      }
      ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName,proxy);
      confConn.setReconnectionAllowed(false);
      connection=new XMPPConnection(confConn);
      try {
        CertificateVerificationService gvs=getCertificateVerificationService();
        if (gvs != null)         connection.setCustomTrustManager(new HostTrustManager(gvs.getTrustManager(serverAddress,Integer.parseInt(serverPort))));
      }
 catch (      GeneralSecurityException e) {
        logger.error(""String_Node_Str"",e);
      }
      connection.connect();
      connection.addConnectionListener(new JabberConnectionListener());
      if (abortConnecting) {
        abortConnecting=false;
        connection.disconnect();
        return;
      }
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
      SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.addConnectionListener(new JabberConnectionListener());
          if (abortConnecting) {
            abortConnecting=false;
            connection.disconnect();
            return;
          }
          fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    discoveryManager.removeFeature(""String_Node_Str"");
    while (it.hasNext()) {
      String feature=it.next();
      if (!discoveryManager.includesFeature(feature))       discoveryManager.addFeature(feature);
    }
  }
}",0.9821271239773444
103647,"/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
    abortConnectingAndReconnect=false;
    connectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    int reason=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
    RegistrationState regState=RegistrationState.UNREGISTERED;
    Throwable wrappedEx=ex.getWrappedThrowable();
    if (wrappedEx instanceof UnknownHostException || wrappedEx instanceof ConnectException) {
      reason=RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND;
      regState=RegistrationState.CONNECTION_FAILED;
    }
 else     if ((connection.getSASLAuthentication() != null && connection.getSASLAuthentication().isAuthenticated()) || !connection.isAuthenticated()) {
      JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),null);
      reason=RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED;
      regState=RegistrationState.AUTHENTICATION_FAILED;
      reregister(SecurityAuthority.WRONG_PASSWORD);
    }
    fireRegistrationStateChanged(getRegistrationState(),regState,reason,null);
  }
}","/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while we're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(final SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.authority=authority;
  try {
    abortConnecting=false;
    connectAndLogin(authority,SecurityAuthority.AUTHENTICATION_REQUIRED);
  }
 catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(ex);
  }
}",0.6826056826056826
103648,"/** 
 * Loads the accounts stored for a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> to load thestored accounts of
 */
private void doLoadStoredAccounts(ProtocolProviderFactory factory){
  ConfigurationService configService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configService.getPropertyNamesByPrefix(factoryPackage,true);
  logger.debug(""String_Node_Str"" + storedAccounts.size() + ""String_Node_Str""+ factoryPackage+ ""String_Node_Str"");
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    logger.debug(""String_Node_Str"" + storedAccount);
    List<String> storedAccountProperties=configService.getPropertyNamesByPrefix(storedAccount,true);
    Map<String,String> accountProperties=new Hashtable<String,String>();
    for (Iterator<String> storedAccountPropertyIter=storedAccountProperties.iterator(); storedAccountPropertyIter.hasNext(); ) {
      String property=storedAccountPropertyIter.next();
      String value=configService.getString(property);
      property=stripPackagePrefix(property);
      if (ProtocolProviderFactory.PASSWORD.equals(property)) {
        if (value == null) {
          value=""String_Node_Str"";
        }
 else         if (value.length() != 0) {
          value=new String(Base64.decode(value));
        }
      }
      if (value != null) {
        accountProperties.put(property,value);
      }
    }
    try {
      factory.loadAccount(accountProperties);
    }
 catch (    Exception ex) {
      logger.error(""String_Node_Str"" + accountProperties,ex);
    }
  }
}","/** 
 * Loads the accounts stored for a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> to load thestored accounts of
 */
private void doLoadStoredAccounts(ProtocolProviderFactory factory){
  ConfigurationService configService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configService.getPropertyNamesByPrefix(factoryPackage,true);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + storedAccounts.size() + ""String_Node_Str""+ factoryPackage+ ""String_Node_Str"");
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + storedAccount);
    List<String> storedAccountProperties=configService.getPropertyNamesByPrefix(storedAccount,true);
    Map<String,String> accountProperties=new Hashtable<String,String>();
    for (Iterator<String> storedAccountPropertyIter=storedAccountProperties.iterator(); storedAccountPropertyIter.hasNext(); ) {
      String property=storedAccountPropertyIter.next();
      String value=configService.getString(property);
      property=stripPackagePrefix(property);
      if (ProtocolProviderFactory.PASSWORD.equals(property)) {
        if (value == null) {
          value=""String_Node_Str"";
        }
 else         if (value.length() != 0) {
          value=new String(Base64.decode(value));
        }
      }
      if (value != null) {
        accountProperties.put(property,value);
      }
    }
    try {
      factory.loadAccount(accountProperties);
    }
 catch (    Exception ex) {
      logger.error(""String_Node_Str"" + accountProperties,ex);
    }
  }
}",0.9821826280623608
103649,"/** 
 * Stores an account represented in the form of an <code>AccountID</code> created by a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> which created theaccount to be stored
 * @param accountID the account in the form of <code>AccountID</code> to bestored
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID){
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configurationService.getPropertyNamesByPrefix(factoryPackage,true);
  String accountUID=accountID.getAccountUniqueID();
  String accountNodeName=null;
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    String storedAccountUID=configurationService.getString(storedAccount + ""String_Node_Str"");
    if (storedAccountUID.equals(accountUID)) {
      accountNodeName=configurationService.getString(storedAccount);
    }
  }
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    if (property.equals(ProtocolProviderFactory.PASSWORD))     value=new String(Base64.encode(value.getBytes()));
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}","/** 
 * Stores an account represented in the form of an <code>AccountID</code> created by a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> which created theaccount to be stored
 * @param accountID the account in the form of <code>AccountID</code> to bestored
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID){
  ConfigurationService configurationService=ProtocolProviderActivator.getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configurationService.getPropertyNamesByPrefix(factoryPackage,true);
  String accountUID=accountID.getAccountUniqueID();
  String accountNodeName=null;
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    String storedAccountUID=configurationService.getString(storedAccount + ""String_Node_Str"");
    if (storedAccountUID.equals(accountUID)) {
      accountNodeName=configurationService.getString(storedAccount);
    }
  }
  Map<String,Object> configurationProperties=new HashMap<String,Object>();
  if (accountNodeName == null) {
    accountNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    if (property.equals(ProtocolProviderFactory.PASSWORD))     value=new String(Base64.encode(value.getBytes()));
    configurationProperties.put(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
  }
  if (configurationProperties.size() > 0)   configurationService.setProperties(configurationProperties);
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}",0.9931672911615606
103650,"/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  dictProviderFactory.stop();
  dictPpFactoryServReg.unregister();
  logger.info(""String_Node_Str"");
}","/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  dictProviderFactory.stop();
  dictPpFactoryServReg.unregister();
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
}",0.9760383386581468
103651,"/** 
 * Called when this bundle is started. In here we'll export the dict ProtocolProviderFactory implementation so that it could be possible to register accounts with it in SIP Communicator.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,ProtocolNames.DICT);
  dictProviderFactory=new ProtocolProviderFactoryDictImpl();
  dictPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),dictProviderFactory,hashtable);
  logger.info(""String_Node_Str"");
}","/** 
 * Called when this bundle is started. In here we'll export the dict ProtocolProviderFactory implementation so that it could be possible to register accounts with it in SIP Communicator.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,ProtocolNames.DICT);
  dictProviderFactory=new ProtocolProviderFactoryDictImpl();
  dictPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),dictProviderFactory,hashtable);
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
}",0.984375
103652,"/** 
 * The default constructor for the Dict protocol provider.
 */
public ProtocolProviderServiceDictImpl(){
  logger.trace(""String_Node_Str"");
}","/** 
 * The default constructor for the Dict protocol provider.
 */
public ProtocolProviderServiceDictImpl(){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
}",0.9040247678018576
103653,"/** 
 * Close the connection to the server 
 */
private void closeConnection(){
  try {
    this.dictConnection.close();
  }
 catch (  DictException dx) {
    logger.info(dx);
  }
}","/** 
 * Close the connection to the server 
 */
private void closeConnection(){
  try {
    this.dictConnection.close();
  }
 catch (  DictException dx) {
    if (logger.isInfoEnabled())     logger.info(dx);
  }
}",0.8730964467005076
103654,"/** 
 * Checks if the connection to the dict server is open
 * @return TRUE if the connection is open - FALSE otherwise
 */
private boolean connect(){
  if (this.dictConnection.isConnected()) {
    return true;
  }
  try {
    return this.dictConnection.isAvailable();
  }
 catch (  DictException dx) {
    logger.info(dx);
  }
  return false;
}","/** 
 * Checks if the connection to the dict server is open
 * @return TRUE if the connection is open - FALSE otherwise
 */
private boolean connect(){
  if (this.dictConnection.isConnected()) {
    return true;
  }
  try {
    return this.dictConnection.isAvailable();
  }
 catch (  DictException dx) {
    if (logger.isInfoEnabled())     logger.info(dx);
  }
  return false;
}",0.9556786703601108
103655,"/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  logger.trace(""String_Node_Str"" + this.accountID.getUserID());
  closeConnection();
  if (isRegistered()) {
    try {
      unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  isInitialized=false;
}","/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + this.accountID.getUserID());
  closeConnection();
  if (isRegistered()) {
    try {
      unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  isInitialized=false;
}",0.9704480457578646
103656,"/** 
 * Adds <tt>callPeer</tt> to the list of peers in this call. If the call peer is already included in the call, the method has no effect.
 * @param callPeer the new <tt>CallPeer</tt>
 */
public void addCallPeer(final CallPeerGibberishImpl callPeer){
  if (callPeers.contains(callPeer))   return;
  callPeer.addCallPeerListener(this);
  this.callPeers.add(callPeer);
  logger.info(""String_Node_Str"");
  fireCallPeerEvent(callPeer,CallPeerEvent.CALL_PEER_ADDED);
  callPeer.setState(CallPeerState.ALERTING_REMOTE_SIDE,""String_Node_Str"");
  Timer timer1=new Timer(false);
  timer1.schedule(new TimerTask(){
    @Override public void run(){
      callPeer.setState(CallPeerState.CONNECTED,""String_Node_Str"");
    }
  }
,1500);
  final Random random=new Random();
  Timer timer=new Timer(false);
  timer.scheduleAtFixedRate(new TimerTask(){
    @Override public void run(){
      callPeer.fireStreamSoundLevelEvent(random.nextInt(255));
    }
  }
,1800,100);
}","/** 
 * Adds <tt>callPeer</tt> to the list of peers in this call. If the call peer is already included in the call, the method has no effect.
 * @param callPeer the new <tt>CallPeer</tt>
 */
public void addCallPeer(final CallPeerGibberishImpl callPeer){
  if (callPeers.contains(callPeer))   return;
  callPeer.addCallPeerListener(this);
  this.callPeers.add(callPeer);
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  fireCallPeerEvent(callPeer,CallPeerEvent.CALL_PEER_ADDED);
  callPeer.setState(CallPeerState.ALERTING_REMOTE_SIDE,""String_Node_Str"");
  Timer timer1=new Timer(false);
  timer1.schedule(new TimerTask(){
    @Override public void run(){
      callPeer.setState(CallPeerState.CONNECTED,""String_Node_Str"");
    }
  }
,1500);
  final Random random=new Random();
  Timer timer=new Timer(false);
  timer.scheduleAtFixedRate(new TimerTask(){
    @Override public void run(){
      callPeer.fireStreamSoundLevelEvent(random.nextInt(255));
    }
  }
,1800,100);
}",0.984599589322382
103657,"/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  gibberishProviderFactory.stop();
  gibberishPpFactoryServReg.unregister();
  logger.info(""String_Node_Str"");
}","/** 
 * Called when this bundle is stopped so the Framework can perform the bundle-specific activities necessary to stop the bundle.
 * @param context The execution context of the bundle being stopped.
 * @throws Exception If this method throws an exception, the bundle isstill marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle.
 */
public void stop(BundleContext context) throws Exception {
  gibberishProviderFactory.stop();
  gibberishPpFactoryServReg.unregister();
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
}",0.9764150943396226
103658,"/** 
 * Called when this bundle is started. In here we'll export the gibberish ProtocolProviderFactory implementation so that it could be possible to register accounts with it in SIP Communicator.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  GibberishActivator.bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,""String_Node_Str"");
  gibberishProviderFactory=new ProtocolProviderFactoryGibberishImpl();
  gibberishPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),gibberishProviderFactory,hashtable);
  logger.info(""String_Node_Str"");
}","/** 
 * Called when this bundle is started. In here we'll export the gibberish ProtocolProviderFactory implementation so that it could be possible to register accounts with it in SIP Communicator.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  GibberishActivator.bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,""String_Node_Str"");
  gibberishProviderFactory=new ProtocolProviderFactoryGibberishImpl();
  gibberishPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),gibberishProviderFactory,hashtable);
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
}",0.9850448654037888
103659,"/** 
 * Indicates a user request to end a call with the specified call particiapnt.
 * @param peer the peer that we'd like to hang up on.
 * @throws OperationFailedException with the corresponding code if weencounter an error while performing this operation.
 */
public void hangupCallPeer(CallPeer peer) throws OperationFailedException {
  if (peer.getState().equals(CallPeerState.DISCONNECTED)) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerGibberishImpl callPeer=(CallPeerGibberishImpl)peer;
  logger.info(""String_Node_Str"");
  callPeer.setState(CallPeerState.DISCONNECTED,null);
  CallGibberishImpl call=(CallGibberishImpl)callPeer.getCall();
  call.removeCallPeer(callPeer);
}","/** 
 * Indicates a user request to end a call with the specified call particiapnt.
 * @param peer the peer that we'd like to hang up on.
 * @throws OperationFailedException with the corresponding code if weencounter an error while performing this operation.
 */
public void hangupCallPeer(CallPeer peer) throws OperationFailedException {
  if (peer.getState().equals(CallPeerState.DISCONNECTED)) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CallPeerGibberishImpl callPeer=(CallPeerGibberishImpl)peer;
  if (logger.isInfoEnabled())   logger.info(""String_Node_Str"");
  callPeer.setState(CallPeerState.DISCONNECTED,null);
  CallGibberishImpl call=(CallGibberishImpl)callPeer.getCall();
  call.removeCallPeer(callPeer);
}",0.9580838323353292
103660,"/** 
 * Indicates a user request to answer an incoming call from the specified CallPeer.
 * @param peer the call peer that we'd like to answer.
 * @throws OperationFailedException with the corresponding code if weencounter an error while performing this operation.
 */
public void answerCallPeer(CallPeer peer) throws OperationFailedException {
  CallPeerGibberishImpl callPeer=(CallPeerGibberishImpl)peer;
  if (peer.getState().equals(CallPeerState.CONNECTED)) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + peer);
    return;
  }
  callPeer.setState(CallPeerState.CONNECTED,null);
}","/** 
 * Indicates a user request to answer an incoming call from the specified CallPeer.
 * @param peer the call peer that we'd like to answer.
 * @throws OperationFailedException with the corresponding code if weencounter an error while performing this operation.
 */
public void answerCallPeer(CallPeer peer) throws OperationFailedException {
  CallPeerGibberishImpl callPeer=(CallPeerGibberishImpl)peer;
  if (peer.getState().equals(CallPeerState.CONNECTED)) {
    if (logger.isInfoEnabled())     logger.info(""String_Node_Str"" + ""String_Node_Str"" + peer);
    return;
  }
  callPeer.setState(CallPeerState.CONNECTED,null);
}",0.9738134206219312
103661,"public void callStateChanged(CallChangeEvent evt){
  if (evt.getEventType().equals(CallChangeEvent.CALL_STATE_CHANGE) && ((CallState)evt.getNewValue()).equals(CallState.CALL_ENDED)) {
    CallGibberishImpl sourceCall=(CallGibberishImpl)this.activeCalls.remove(evt.getSourceCall().getCallID());
    logger.trace(""String_Node_Str"" + sourceCall + ""String_Node_Str""+ ""String_Node_Str"");
    fireCallEvent(CallEvent.CALL_ENDED,sourceCall);
  }
}","public void callStateChanged(CallChangeEvent evt){
  if (evt.getEventType().equals(CallChangeEvent.CALL_STATE_CHANGE) && ((CallState)evt.getNewValue()).equals(CallState.CALL_ENDED)) {
    CallGibberishImpl sourceCall=(CallGibberishImpl)this.activeCalls.remove(evt.getSourceCall().getCallID());
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + sourceCall + ""String_Node_Str""+ ""String_Node_Str"");
    fireCallEvent(CallEvent.CALL_ENDED,sourceCall);
  }
}",0.963855421686747
103662,"public void callStateChanged(CallChangeEvent evt){
  if (evt.getEventType().equals(CallChangeEvent.CALL_STATE_CHANGE) && ((CallState)evt.getNewValue()).equals(CallState.CALL_ENDED)) {
    CallGibberishImpl sourceCall=(CallGibberishImpl)this.activeCalls.remove(evt.getSourceCall().getCallID());
    logger.trace(""String_Node_Str"" + sourceCall + ""String_Node_Str""+ ""String_Node_Str"");
    telephonyOpSet.fireCallEvent(CallEvent.CALL_ENDED,sourceCall);
  }
}","public void callStateChanged(CallChangeEvent evt){
  if (evt.getEventType().equals(CallChangeEvent.CALL_STATE_CHANGE) && ((CallState)evt.getNewValue()).equals(CallState.CALL_ENDED)) {
    CallGibberishImpl sourceCall=(CallGibberishImpl)this.activeCalls.remove(evt.getSourceCall().getCallID());
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + sourceCall + ""String_Node_Str""+ ""String_Node_Str"");
    telephonyOpSet.fireCallEvent(CallEvent.CALL_ENDED,sourceCall);
  }
}",0.9650053022269351
103663,"/** 
 * The default constructor for the Gibberish protocol provider.
 */
public ProtocolProviderServiceGibberishImpl(){
  logger.trace(""String_Node_Str"");
}","/** 
 * The default constructor for the Gibberish protocol provider.
 */
public ProtocolProviderServiceGibberishImpl(){
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
}",0.9096209912536444
103664,"/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  logger.trace(""String_Node_Str"");
  if (isRegistered()) {
    try {
      unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  isInitialized=false;
}","/** 
 * Makes the service implementation close all open sockets and release any resources that it might have taken and prepare for shutdown/garbage collection.
 */
public void shutdown(){
  if (!isInitialized) {
    return;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"");
  if (isRegistered()) {
    try {
      unregister();
    }
 catch (    OperationFailedException ex) {
      logger.error(""String_Node_Str"" + getAccountID(),ex);
    }
  }
  isInitialized=false;
}",0.9673340358271864
103665,"public void handleStateChange(ChatRoomSession chatRoomSession,ChatSessionState oldChatSessionState,ChatSessionState newChatSessionState){
  logger.debug(""String_Node_Str"" + newChatSessionState);
  if (chatInvitation == null && newChatSessionState.equals(ChatSessionState.INROOM)) {
    try {
      chatRoom.join();
    }
 catch (    Exception e) {
      logger.debug(""String_Node_Str"" + e);
    }
  }
  if (inviteUserList != null && newChatSessionState.equals(ChatSessionState.INROOM)) {
    Iterator<Map.Entry<String,String>> invitesIter=inviteUserList.entrySet().iterator();
    while (invitesIter.hasNext()) {
      Map.Entry<String,String> entry=invitesIter.next();
      chatRoom.invite(entry.getKey(),entry.getValue());
    }
  }
  if (newChatSessionState.equals(ChatSessionState.CLOSED) || newChatSessionState.equals(ChatSessionState.FAILED)) {
    updateMemberList(chatRoomSession.getUsers(),true);
  }
}","public void handleStateChange(ChatRoomSession chatRoomSession,ChatSessionState oldChatSessionState,ChatSessionState newChatSessionState){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + newChatSessionState);
  if (chatInvitation == null && newChatSessionState.equals(ChatSessionState.INROOM)) {
    try {
      chatRoom.join();
    }
 catch (    Exception e) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + e);
    }
  }
  if (inviteUserList != null && newChatSessionState.equals(ChatSessionState.INROOM)) {
    Iterator<Map.Entry<String,String>> invitesIter=inviteUserList.entrySet().iterator();
    while (invitesIter.hasNext()) {
      Map.Entry<String,String> entry=invitesIter.next();
      chatRoom.invite(entry.getKey(),entry.getValue());
    }
  }
  if (newChatSessionState.equals(ChatSessionState.CLOSED) || newChatSessionState.equals(ChatSessionState.FAILED)) {
    updateMemberList(chatRoomSession.getUsers(),true);
  }
}",0.9650793650793652
103666,"/** 
 * Creates the corresponding AdHocChatRoomParticipantPresenceChangeEvent and notifies all <tt>AdHocChatRoomParticipantPresenceListener</tt>s that a Contact has joined or left this <tt>AdHocChatRoom</tt>.
 * @param member the <tt>Contact</tt> that this
 * @param eventID the identifier of the event
 * @param eventReason the reason of the event
 */
private void fireParticipantPresenceEvent(Contact member,String eventID,String eventReason){
  AdHocChatRoomParticipantPresenceChangeEvent evt=new AdHocChatRoomParticipantPresenceChangeEvent(this,member,eventID,eventReason);
  logger.trace(""String_Node_Str"" + evt);
  Iterator<AdHocChatRoomParticipantPresenceListener> listeners=null;
synchronized (memberListeners) {
    listeners=new ArrayList<AdHocChatRoomParticipantPresenceListener>(memberListeners).iterator();
  }
  while (listeners.hasNext()) {
    AdHocChatRoomParticipantPresenceListener listener=listeners.next();
    listener.participantPresenceChanged(evt);
  }
}","/** 
 * Creates the corresponding AdHocChatRoomParticipantPresenceChangeEvent and notifies all <tt>AdHocChatRoomParticipantPresenceListener</tt>s that a Contact has joined or left this <tt>AdHocChatRoom</tt>.
 * @param member the <tt>Contact</tt> that this
 * @param eventID the identifier of the event
 * @param eventReason the reason of the event
 */
private void fireParticipantPresenceEvent(Contact member,String eventID,String eventReason){
  AdHocChatRoomParticipantPresenceChangeEvent evt=new AdHocChatRoomParticipantPresenceChangeEvent(this,member,eventID,eventReason);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + evt);
  Iterator<AdHocChatRoomParticipantPresenceListener> listeners=null;
synchronized (memberListeners) {
    listeners=new ArrayList<AdHocChatRoomParticipantPresenceListener>(memberListeners).iterator();
  }
  while (listeners.hasNext()) {
    AdHocChatRoomParticipantPresenceListener listener=listeners.next();
    listener.participantPresenceChanged(evt);
  }
}",0.9844142785319256
103667,"/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param message The <tt>Message</tt> to send.
 * @throws OperationFailedException if the underlying stack is notregistered or initialized or if the chat room is not joined.
 */
public void sendMessage(Message message) throws OperationFailedException {
  assertConnected();
  try {
    chatRoomSession.sendMessage(message.getContent());
    AdHocChatRoomMessageDeliveredEvent msgDeliveredEvt=new AdHocChatRoomMessageDeliveredEvent(this,System.currentTimeMillis(),message,AdHocChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);
    fireMessageEvent(msgDeliveredEvt);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
}","/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param message The <tt>Message</tt> to send.
 * @throws OperationFailedException if the underlying stack is notregistered or initialized or if the chat room is not joined.
 */
public void sendMessage(Message message) throws OperationFailedException {
  assertConnected();
  try {
    chatRoomSession.sendMessage(message.getContent());
    AdHocChatRoomMessageDeliveredEvent msgDeliveredEvt=new AdHocChatRoomMessageDeliveredEvent(this,System.currentTimeMillis(),message,AdHocChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);
    fireMessageEvent(msgDeliveredEvt);
  }
 catch (  Exception e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"");
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
  }
}",0.9807355516637478
103668,"/** 
 * Handles incoming messages for the specified chat room.
 * @param chatRoomSession Specific chat room session
 * @param chatRoomUser The User who sends the message
 * @param chatMessage The message
 */
public void handleIncomingMessage(ChatRoomSession chatRoomSession,ChatRoomUser chatRoomUser,ChatMessage chatMessage){
  logger.debug(""String_Node_Str"" + chatMessage.getMessage());
  String msgBody=chatMessage.getMessage();
  String msgContent;
  if (msgBody.startsWith(defaultHtmlStartTag)) {
    msgContent=msgBody.substring(msgBody.indexOf(defaultHtmlStartTag) + defaultHtmlStartTag.length(),msgBody.indexOf(defaultHtmlEndTag));
  }
 else   msgContent=msgBody;
  Message newMessage=createMessage(msgContent.getBytes(),HTML_MIME_TYPE,OperationSetBasicInstantMessagingIcqImpl.DEFAULT_MIME_ENCODING,null);
  String participantUID=chatRoomUser.getScreenname().getFormatted();
  if (participantUID.equals(nickName))   return;
  AdHocChatRoomMessageReceivedEvent msgReceivedEvent=new AdHocChatRoomMessageReceivedEvent(chatRoom,participants.get(participantUID),System.currentTimeMillis(),newMessage,AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
  fireMessageEvent(msgReceivedEvent);
}","/** 
 * Handles incoming messages for the specified chat room.
 * @param chatRoomSession Specific chat room session
 * @param chatRoomUser The User who sends the message
 * @param chatMessage The message
 */
public void handleIncomingMessage(ChatRoomSession chatRoomSession,ChatRoomUser chatRoomUser,ChatMessage chatMessage){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + chatMessage.getMessage());
  String msgBody=chatMessage.getMessage();
  String msgContent;
  if (msgBody.startsWith(defaultHtmlStartTag)) {
    msgContent=msgBody.substring(msgBody.indexOf(defaultHtmlStartTag) + defaultHtmlStartTag.length(),msgBody.indexOf(defaultHtmlEndTag));
  }
 else   msgContent=msgBody;
  Message newMessage=createMessage(msgContent.getBytes(),HTML_MIME_TYPE,OperationSetBasicInstantMessagingIcqImpl.DEFAULT_MIME_ENCODING,null);
  String participantUID=chatRoomUser.getScreenname().getFormatted();
  if (participantUID.equals(nickName))   return;
  AdHocChatRoomMessageReceivedEvent msgReceivedEvent=new AdHocChatRoomMessageReceivedEvent(chatRoom,participants.get(participantUID),System.currentTimeMillis(),newMessage,AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
  fireMessageEvent(msgReceivedEvent);
}",0.9873210633946832
103669,"/** 
 * Function called to refuse the file.
 */
public void rejectFile(){
  try {
    incomingFileTransfer.close();
    fileTransferOpSet.fireFileTransferRequestRejected(new FileTransferRequestEvent(fileTransferOpSet,this,date));
  }
 catch (  IllegalStateException e) {
    logger.debug(""String_Node_Str"",e);
    return;
  }
}","/** 
 * Function called to refuse the file.
 */
public void rejectFile(){
  try {
    incomingFileTransfer.close();
    fileTransferOpSet.fireFileTransferRequestRejected(new FileTransferRequestEvent(fileTransferOpSet,this,date));
  }
 catch (  IllegalStateException e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
    return;
  }
}",0.9519650655021834
103670,"public void waitForLastInfo(long waitFor){
synchronized (this) {
    try {
      wait(waitFor);
    }
 catch (    InterruptedException ex) {
      logger.debug(""String_Node_Str"",ex);
    }
  }
}","public void waitForLastInfo(long waitFor){
synchronized (this) {
    try {
      wait(waitFor);
    }
 catch (    InterruptedException ex) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"",ex);
    }
  }
}",0.91725768321513
103671,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    String customMessageEncoding=null;
    if ((customMessageEncoding=System.getProperty(""String_Node_Str"")) != null)     OscarTools.setDefaultCharset(customMessageEncoding);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getOperationSet(OperationSetPersistentPresence.class);
    icqProvider.getAimConnection().getChatRoomManager().addListener(new ChatRoomManagerListenerImpl());
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    String customMessageEncoding=null;
    if ((customMessageEncoding=System.getProperty(""String_Node_Str"")) != null)     OscarTools.setDefaultCharset(customMessageEncoding);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getOperationSet(OperationSetPersistentPresence.class);
    icqProvider.getAimConnection().getChatRoomManager().addListener(new ChatRoomManagerListenerImpl());
  }
}",0.9825744800449692
103672,"public void handleInvitation(ChatRoomManager chatRoomManager,ChatInvitation chatInvitation){
  logger.debug(""String_Node_Str"" + chatInvitation.getRoomName());
  AdHocChatRoom chatRoom=createLocalChatRoomInstance(chatInvitation);
  invitations.put(chatRoom,chatInvitation);
  fireInvitationEvent(chatRoom,chatInvitation.getScreenname().toString(),chatInvitation.getMessage(),null);
}","public void handleInvitation(ChatRoomManager chatRoomManager,ChatInvitation chatInvitation){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + chatInvitation.getRoomName());
  AdHocChatRoom chatRoom=createLocalChatRoomInstance(chatInvitation);
  invitations.put(chatRoom,chatInvitation);
  fireInvitationEvent(chatRoom,chatInvitation.getScreenname().toString(),chatInvitation.getMessage(),null);
}",0.961006289308176
103673,"/** 
 * Get the advanced format parameters list of our device that match remote supported ones.
 * @param remoteFormats remote advanced format parameters found in theSDP message
 * @param localFormats local advanced format parameters of our device
 * @return intersection between our local advanced parameters and remoteadvanced parameters
 */
private List<MediaFormat> getAdvancedFormatParameters(List<MediaFormat> remoteFormats,List<MediaFormat> localFormats){
  List<MediaFormat> ret=new ArrayList<MediaFormat>();
  for (  MediaFormat format : remoteFormats) {
    MediaFormat mf=findMediaFormat(localFormats,format.getEncoding());
    if (mf != null) {
      ret.add(mf);
    }
  }
  return ret;
}","/** 
 * Gets the advanced format parameters list of our device that match remote supported ones.
 * @param remoteFormats remote advanced format parameters found in theSDP message
 * @param localFormats local advanced format parameters of our device
 * @return intersection between our local advanced parameters and remoteadvanced parameters
 */
private List<MediaFormat> getAdvancedFormatParameters(List<MediaFormat> remoteFormats,List<MediaFormat> localFormats){
  List<MediaFormat> ret=new ArrayList<MediaFormat>();
  for (  MediaFormat remoteFormat : remoteFormats) {
    MediaFormat localFormat=findMediaFormat(localFormats,remoteFormat);
    if (localFormat != null)     ret.add(localFormat);
  }
  return ret;
}",0.919605077574048
103674,"/** 
 * Find a <tt>MediaFormat</tt> specified by its encoding in the list of <tt>MediaFormat</tt>.
 * @param formats list of <tt>MediaFormat</tt>
 * @param encoding encoding of the <tt>MediaFormat</tt> to find
 * @return <tt>MediaFormat</tt> if found in list of formats, nullotherwise
 */
private MediaFormat findMediaFormat(List<MediaFormat> formats,String encoding){
  for (  MediaFormat f : formats) {
    if (f.getEncoding().equals(encoding)) {
      return f;
    }
  }
  return null;
}","/** 
 * Finds a <tt>MediaFormat</tt> in a specific list of <tt>MediaFormat</tt>s which matches a specific <tt>MediaFormat</tt>.
 * @param formats the list of <tt>MediaFormat</tt>s to find the specifiedmatching <tt>MediaFormat</tt> into
 * @param encoding encoding of the <tt>MediaFormat</tt> to find
 * @return the <tt>MediaFormat</tt> from <tt>formats</tt> which matches<tt>format</tt> if such a match exists in <tt>formats</tt>; otherwise, <tt>null</tt>
 */
private MediaFormat findMediaFormat(List<MediaFormat> formats,MediaFormat format){
  MediaType mediaType=format.getMediaType();
  String encoding=format.getEncoding();
  double clockRate=format.getClockRate();
  int channels=MediaType.AUDIO.equals(mediaType) ? ((AudioMediaFormat)format).getChannels() : MediaFormatFactory.CHANNELS_NOT_SPECIFIED;
  for (  MediaFormat match : formats) {
    if (AbstractMediaStream.matches(match,mediaType,encoding,clockRate,channels))     return match;
  }
  return null;
}",0.0672153635116598
103675,"/** 
 * Returns the dynamic payload type that has been allocated for <tt>format</tt>. A mapping for the specified <tt>format</tt> would be created even if it did not previously exist. The method is meant for use primarily during generation of SDP descriptions.
 * @param format the <tt>MediaFormat</tt> instance that we'd like to obtaina payload type number for..
 * @return the (possibly newly allocated) payload type number correspondingto the specified <tt>format</tt> instance for the lifetime of the media session.
 * @throws IllegalStateException if we have already registered more dynamicformats than allowed for by RTP.
 */
public byte obtainPayloadTypeNumber(MediaFormat format) throws IllegalStateException {
  Byte payloadType=payloadTypeMappings.get(format);
  if (payloadType == null) {
    payloadType=nextPayloadTypeNumber();
    payloadTypeMappings.put(format,payloadType);
  }
  return payloadType;
}","/** 
 * Returns the dynamic payload type that has been allocated for <tt>format</tt>. A mapping for the specified <tt>format</tt> would be created even if it did not previously exist. The method is meant for use primarily during generation of SDP descriptions.
 * @param format the <tt>MediaFormat</tt> instance that we'd like to obtaina payload type number for..
 * @return the (possibly newly allocated) payload type number correspondingto the specified <tt>format</tt> instance for the lifetime of the media session.
 * @throws IllegalStateException if we have already registered more dynamicformats than allowed for by RTP.
 */
public byte obtainPayloadTypeNumber(MediaFormat format) throws IllegalStateException {
  MediaType mediaType=format.getMediaType();
  String encoding=format.getEncoding();
  double clockRate=format.getClockRate();
  int channels=MediaType.AUDIO.equals(mediaType) ? ((AudioMediaFormat)format).getChannels() : MediaFormatFactory.CHANNELS_NOT_SPECIFIED;
  Byte payloadType=null;
  for (  Map.Entry<MediaFormat,Byte> payloadTypeMapping : payloadTypeMappings.entrySet()) {
    if (AbstractMediaStream.matches(payloadTypeMapping.getKey(),mediaType,encoding,clockRate,channels)) {
      payloadType=payloadTypeMapping.getValue();
      break;
    }
  }
  if (payloadType == null) {
    payloadType=nextPayloadTypeNumber();
    payloadTypeMappings.put(format,payloadType);
  }
  return payloadType;
}",0.7603588210166595
103676,"/** 
 * Creates and returns <tt>MediaFormat</tt> instance corresponding to the specified <tt>payloadType</tt> and the parameters in the <tt>rtpmap</tt> and <tt>fmtp</tt> <tt>Attribute</tt>s. The method would only return <tt>MediaFormat</tt> instances for formats known to our media service implementation and returns <tt>null</tt> otherwise.
 * @param payloadType a static or dynamic payload type number thatdetermines the encoding of the format we'd like to create.
 * @param rtpmap an SDP <tt>Attribute</tt> mapping the <tt>payloadType</tt>to an encoding name.
 * @param fmtp a list of format specific parameters
 * @param advp list of advanced parameters
 * @param ptRegistry the {@link DynamicPayloadTypeRegistry} that we are touse in case <tt>payloadType</tt> is dynamic and <tt>rtpmap</tt> is <tt>null</tt> (in which case we can hope its in the registry).
 * @return a <tt>MediaForamt</tt> instance corresponding to the specified<tt>payloadType</tt> and <tt>rtpmap</tt>, and <tt>fmtp</tt> attributes or <tt>null</tt> if such a format is not currently supported by our media service implementation.
 * @throws SdpException never, the exception is only there because thejain-sdp API declares exceptions in case of impls using lazy parsing but the one in the jain-sip-ri isn't doing it.
 */
private static MediaFormat createFormat(byte payloadType,Attribute rtpmap,Attribute fmtp,List<Attribute> advp,DynamicPayloadTypeRegistry ptRegistry) throws SdpException {
  String encoding=null;
  double clockRate=-1;
  int numChannels=1;
  if (rtpmap != null) {
    String rtpmapValue=rtpmap.getValue();
    StringTokenizer tokenizer=new StringTokenizer(rtpmapValue,""String_Node_Str"",false);
    if (tokenizer.hasMoreTokens()) {
      tokenizer.nextToken();
    }
    if (tokenizer.hasMoreTokens()) {
      encoding=tokenizer.nextToken();
    }
    if (tokenizer.hasMoreTokens()) {
      clockRate=Double.parseDouble(tokenizer.nextToken());
    }
    if (tokenizer.hasMoreTokens()) {
      String nChansStr=tokenizer.nextToken();
      try {
        numChannels=Integer.parseInt(nChansStr);
      }
 catch (      NumberFormatException exc) {
        logger.debug(nChansStr + ""String_Node_Str"",exc);
      }
    }
  }
 else {
    MediaFormat fmt=ptRegistry.findFormat(payloadType);
    if (fmt != null)     return fmt;
  }
  Map<String,String> fmtParamsMap=null;
  Map<String,String> advancedAttrMap=null;
  if (fmtp != null)   fmtParamsMap=parseFmtpAttribute(fmtp);
  if (advp != null) {
    advancedAttrMap=parseAdvancedAttributes(advp);
  }
  MediaFormat format=SipActivator.getMediaService().getFormatFactory().createMediaFormat(payloadType,encoding,clockRate,numChannels,fmtParamsMap,advancedAttrMap);
  if ((payloadType >= MediaFormat.MIN_DYNAMIC_PAYLOAD_TYPE) && (payloadType <= MediaFormat.MAX_DYNAMIC_PAYLOAD_TYPE) && (format != null)&& (ptRegistry.findFormat(payloadType) == null))   ptRegistry.addMapping(format,payloadType);
  return format;
}","/** 
 * Creates and returns <tt>MediaFormat</tt> instance corresponding to the specified <tt>payloadType</tt> and the parameters in the <tt>rtpmap</tt> and <tt>fmtp</tt> <tt>Attribute</tt>s. The method would only return <tt>MediaFormat</tt> instances for formats known to our media service implementation and returns <tt>null</tt> otherwise.
 * @param payloadType a static or dynamic payload type number thatdetermines the encoding of the format we'd like to create.
 * @param rtpmap an SDP <tt>Attribute</tt> mapping the <tt>payloadType</tt>to an encoding name.
 * @param fmtp a list of format specific parameters
 * @param advp list of advanced parameters
 * @param ptRegistry the {@link DynamicPayloadTypeRegistry} that we are touse in case <tt>payloadType</tt> is dynamic and <tt>rtpmap</tt> is <tt>null</tt> (in which case we can hope its in the registry).
 * @return a <tt>MediaForamt</tt> instance corresponding to the specified<tt>payloadType</tt> and <tt>rtpmap</tt>, and <tt>fmtp</tt> attributes or <tt>null</tt> if such a format is not currently supported by our media service implementation.
 * @throws SdpException never, the exception is only there because thejain-sdp API declares exceptions in case of impls using lazy parsing but the one in the jain-sip-ri isn't doing it.
 */
private static MediaFormat createFormat(byte payloadType,Attribute rtpmap,Attribute fmtp,List<Attribute> advp,DynamicPayloadTypeRegistry ptRegistry) throws SdpException {
  String encoding=null;
  double clockRate=-1;
  int numChannels=1;
  if (rtpmap != null) {
    String rtpmapValue=rtpmap.getValue();
    StringTokenizer tokenizer=new StringTokenizer(rtpmapValue,""String_Node_Str"",false);
    if (tokenizer.hasMoreTokens()) {
      tokenizer.nextToken();
    }
    if (tokenizer.hasMoreTokens()) {
      encoding=tokenizer.nextToken();
    }
    if (tokenizer.hasMoreTokens()) {
      clockRate=Double.parseDouble(tokenizer.nextToken());
    }
    if (tokenizer.hasMoreTokens()) {
      String nChansStr=tokenizer.nextToken();
      try {
        numChannels=Integer.parseInt(nChansStr);
      }
 catch (      NumberFormatException exc) {
        logger.debug(nChansStr + ""String_Node_Str"",exc);
      }
    }
  }
 else {
    MediaFormat fmt=ptRegistry.findFormat(payloadType);
    if (fmt != null)     return fmt;
  }
  Map<String,String> fmtParamsMap=null;
  Map<String,String> advancedAttrMap=null;
  if (fmtp != null)   fmtParamsMap=parseFmtpAttribute(fmtp);
  if (advp != null)   advancedAttrMap=parseAdvancedAttributes(advp);
  MediaFormat format=SipActivator.getMediaService().getFormatFactory().createMediaFormat(payloadType,encoding,clockRate,numChannels,fmtParamsMap,advancedAttrMap);
  if ((payloadType >= MediaFormat.MIN_DYNAMIC_PAYLOAD_TYPE) && (payloadType <= MediaFormat.MAX_DYNAMIC_PAYLOAD_TYPE) && (format != null)&& (ptRegistry.findFormat(payloadType) == null))   ptRegistry.addMapping(format,payloadType);
  return format;
}",0.998641765704584
103677,"/** 
 * Creates a new <tt>MediaDescription</tt> instance according to the specified <tt>formats</tt>, <tt>connector</tt> and <tt>direction</tt>, and using the <tt>dynamicPayloadTypes</tt> registry to handle dynamic payload type registrations. The type (e.g. audio/video) of the media description is determined via from the type of the first <tt>MediaFormat</tt> in the <tt>formats</tt> list.
 * @param formats the list of formats that should be advertised in the newlycreated <tt>MediaDescription</tt>.
 * @param connector the socket couple that will be used for the media streamwhich we are advertising with the media description created here.
 * @param direction the direction of the media stream that we are describinghere.
 * @param rtpExtensions a list of <tt>RTPExtension</tt>s supported by the<tt>MediaDevice</tt> that we will be advertising.
 * @param dynamicPayloadTypes a reference to the<tt>DynamicPayloadTypeRegistry</tt> that we should be using to lookup and register dynamic RTP mappings.
 * @param rtpExtensionsRegistry a reference to the<tt>DynamicRTPExtensionRegistry</tt> that we should be using to lookup and register URN to ID mappings.
 * @return the newly create SDP <tt>MediaDescription</tt>.
 * @throws OperationFailedException in case we fail to get payload typenumbers for dynamic payload types or in case our SDP generation fails for some other reason.
 */
public static MediaDescription createMediaDescription(List<MediaFormat> formats,StreamConnector connector,MediaDirection direction,List<RTPExtension> rtpExtensions,DynamicPayloadTypeRegistry dynamicPayloadTypes,DynamicRTPExtensionsRegistry rtpExtensionsRegistry) throws OperationFailedException {
  int[] payloadTypesArray=new int[formats.size()];
  Vector<Attribute> mediaAttributes=new Vector<Attribute>(2 * payloadTypesArray.length + 1);
  MediaType mediaType=null;
  if (direction != MediaDirection.SENDRECV)   mediaAttributes.add(createDirectionAttribute(direction));
  for (int i=0; i < payloadTypesArray.length; i++) {
    MediaFormat format=formats.get(i);
    MediaType fmtMediaType=format.getMediaType();
    if (mediaType == null) {
      mediaType=fmtMediaType;
    }
    byte payloadType=format.getRTPPayloadType();
    if (payloadType == MediaFormat.RTP_PAYLOAD_TYPE_UNKNOWN) {
      try {
        payloadType=dynamicPayloadTypes.obtainPayloadTypeNumber(format);
      }
 catch (      IllegalStateException exception) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exception);
      }
    }
    String numChannelsStr=""String_Node_Str"";
    if (format instanceof AudioMediaFormat) {
      int channels=((AudioMediaFormat)format).getChannels();
      if (channels > 1)       numChannelsStr=""String_Node_Str"" + channels;
    }
    Attribute rtpmap=sdpFactory.createAttribute(SdpConstants.RTPMAP,payloadType + ""String_Node_Str"" + format.getEncoding()+ ""String_Node_Str""+ format.getClockRateString()+ numChannelsStr);
    mediaAttributes.add(rtpmap);
    if (format.getFormatParameters().size() > 0) {
      Attribute fmtp=sdpFactory.createAttribute(""String_Node_Str"",payloadType + ""String_Node_Str"" + encodeFmtp(format));
      mediaAttributes.add(fmtp);
    }
    Iterator<Map.Entry<String,String>> iter=format.getAdvancedAttributes().entrySet().iterator();
    while (iter.hasNext()) {
      Map.Entry<String,String> ntry=iter.next();
      Attribute adv=sdpFactory.createAttribute(ntry.getKey(),payloadType + ""String_Node_Str"" + ntry.getValue());
      mediaAttributes.add(adv);
    }
    payloadTypesArray[i]=payloadType;
  }
  int rtpPort=connector.getDataSocket().getLocalPort();
  int rtcpPort=connector.getControlSocket().getLocalPort();
  if ((rtpPort + 1) != rtcpPort) {
    Attribute rtcpAttr=sdpFactory.createAttribute(RTCP_ATTR,Integer.toString(rtcpPort));
    mediaAttributes.add(rtcpAttr);
  }
  if (rtpExtensions != null && rtpExtensions.size() > 0) {
    for (    RTPExtension extension : rtpExtensions) {
      byte extID=rtpExtensionsRegistry.obtainExtensionMapping(extension);
      String uri=extension.getURI().toString();
      MediaDirection extDirection=extension.getDirection();
      String attributes=extension.getExtensionAttributes();
      String attrValue=Byte.toString(extID) + ((extDirection == MediaDirection.SENDRECV) ? ""String_Node_Str"" : (""String_Node_Str"" + extDirection.toString())) + ""String_Node_Str""+ uri+ (attributes == null ? ""String_Node_Str"" : (""String_Node_Str"" + attributes));
      Attribute extMapAttr=sdpFactory.createAttribute(EXTMAP_ATTR,attrValue);
      mediaAttributes.add(extMapAttr);
    }
  }
  MediaDescription mediaDesc=null;
  try {
    mediaDesc=sdpFactory.createMediaDescription(mediaType.toString(),connector.getDataSocket().getLocalPort(),1,SdpConstants.RTP_AVP,payloadTypesArray);
    mediaDesc.setAttributes(mediaAttributes);
  }
 catch (  Exception cause) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,cause,logger);
  }
  return mediaDesc;
}","/** 
 * Creates a new <tt>MediaDescription</tt> instance according to the specified <tt>formats</tt>, <tt>connector</tt> and <tt>direction</tt>, and using the <tt>dynamicPayloadTypes</tt> registry to handle dynamic payload type registrations. The type (e.g. audio/video) of the media description is determined via from the type of the first <tt>MediaFormat</tt> in the <tt>formats</tt> list.
 * @param formats the list of formats that should be advertised in the newlycreated <tt>MediaDescription</tt>.
 * @param connector the socket couple that will be used for the media streamwhich we are advertising with the media description created here.
 * @param direction the direction of the media stream that we are describinghere.
 * @param rtpExtensions a list of <tt>RTPExtension</tt>s supported by the<tt>MediaDevice</tt> that we will be advertising.
 * @param dynamicPayloadTypes a reference to the<tt>DynamicPayloadTypeRegistry</tt> that we should be using to lookup and register dynamic RTP mappings.
 * @param rtpExtensionsRegistry a reference to the<tt>DynamicRTPExtensionRegistry</tt> that we should be using to lookup and register URN to ID mappings.
 * @return the newly create SDP <tt>MediaDescription</tt>.
 * @throws OperationFailedException in case we fail to get payload typenumbers for dynamic payload types or in case our SDP generation fails for some other reason.
 */
public static MediaDescription createMediaDescription(List<MediaFormat> formats,StreamConnector connector,MediaDirection direction,List<RTPExtension> rtpExtensions,DynamicPayloadTypeRegistry dynamicPayloadTypes,DynamicRTPExtensionsRegistry rtpExtensionsRegistry) throws OperationFailedException {
  int[] payloadTypesArray=new int[formats.size()];
  Vector<Attribute> mediaAttributes=new Vector<Attribute>(2 * payloadTypesArray.length + 1);
  MediaType mediaType=null;
  if (direction != MediaDirection.SENDRECV)   mediaAttributes.add(createDirectionAttribute(direction));
  for (int i=0; i < payloadTypesArray.length; i++) {
    MediaFormat format=formats.get(i);
    MediaType fmtMediaType=format.getMediaType();
    if (mediaType == null)     mediaType=fmtMediaType;
    byte payloadType=format.getRTPPayloadType();
    if (payloadType == MediaFormat.RTP_PAYLOAD_TYPE_UNKNOWN) {
      try {
        payloadType=dynamicPayloadTypes.obtainPayloadTypeNumber(format);
      }
 catch (      IllegalStateException exception) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exception);
      }
    }
    String numChannelsStr=""String_Node_Str"";
    if (format instanceof AudioMediaFormat) {
      int channels=((AudioMediaFormat)format).getChannels();
      if (channels > 1)       numChannelsStr=""String_Node_Str"" + channels;
    }
    Attribute rtpmap=sdpFactory.createAttribute(SdpConstants.RTPMAP,payloadType + ""String_Node_Str"" + format.getEncoding()+ ""String_Node_Str""+ format.getClockRateString()+ numChannelsStr);
    mediaAttributes.add(rtpmap);
    if (format.getFormatParameters().size() > 0) {
      Attribute fmtp=sdpFactory.createAttribute(""String_Node_Str"",payloadType + ""String_Node_Str"" + encodeFmtp(format));
      mediaAttributes.add(fmtp);
    }
    Iterator<Map.Entry<String,String>> iter=format.getAdvancedAttributes().entrySet().iterator();
    while (iter.hasNext()) {
      Map.Entry<String,String> ntry=iter.next();
      Attribute adv=sdpFactory.createAttribute(ntry.getKey(),payloadType + ""String_Node_Str"" + ntry.getValue());
      mediaAttributes.add(adv);
    }
    payloadTypesArray[i]=payloadType;
  }
  int rtpPort=connector.getDataSocket().getLocalPort();
  int rtcpPort=connector.getControlSocket().getLocalPort();
  if ((rtpPort + 1) != rtcpPort) {
    Attribute rtcpAttr=sdpFactory.createAttribute(RTCP_ATTR,Integer.toString(rtcpPort));
    mediaAttributes.add(rtcpAttr);
  }
  if (rtpExtensions != null && rtpExtensions.size() > 0) {
    for (    RTPExtension extension : rtpExtensions) {
      byte extID=rtpExtensionsRegistry.obtainExtensionMapping(extension);
      String uri=extension.getURI().toString();
      MediaDirection extDirection=extension.getDirection();
      String attributes=extension.getExtensionAttributes();
      String attrValue=Byte.toString(extID) + ((extDirection == MediaDirection.SENDRECV) ? ""String_Node_Str"" : (""String_Node_Str"" + extDirection.toString())) + ""String_Node_Str""+ uri+ (attributes == null ? ""String_Node_Str"" : (""String_Node_Str"" + attributes));
      Attribute extMapAttr=sdpFactory.createAttribute(EXTMAP_ATTR,attrValue);
      mediaAttributes.add(extMapAttr);
    }
  }
  MediaDescription mediaDesc=null;
  try {
    mediaDesc=sdpFactory.createMediaDescription(mediaType.toString(),connector.getDataSocket().getLocalPort(),1,SdpConstants.RTP_AVP,payloadTypesArray);
    mediaDesc.setAttributes(mediaAttributes);
  }
 catch (  Exception cause) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,cause,logger);
  }
  return mediaDesc;
}",0.9990071485305798
103678,"/** 
 * Returns a <tt>Map</tt> containing advanced parameters specific to this particular <MediaFormat</tt>. The parameters returned here are meant for use in SIP/SDP or XMPP session descriptions.
 * @return a <tt>Map</tt> containing advanced parameters specific to thisparticular <tt>MediaFormat</tt>
 */
public Map<String,String> getAdvancedAttributes();","/** 
 * Returns a <tt>Map</tt> containing advanced parameters specific to this particular <tt>MediaFormat</tt>. The parameters returned here are meant for use in SIP/SDP or XMPP session descriptions.
 * @return a <tt>Map</tt> containing advanced parameters specific to thisparticular <tt>MediaFormat</tt>
 */
public Map<String,String> getAdvancedAttributes();",0.9958041958041958
103679,"/** 
 * Reads audio data from this <tt>InputPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>InputPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public void read(Buffer buffer) throws PortAudioException {
  if (stopping || !started) {
    buffer.setLength(0);
    return;
  }
synchronized (readSync) {
    while (true) {
      if (bufferData == null) {
        if (!parentStream.read(buffer)) {
          try {
            readSync.wait();
          }
 catch (          InterruptedException e) {
            continue;
          }
          continue;
        }
      }
 else {
        Object data=buffer.getData();
        byte[] tmpArray;
        if (data instanceof byte[] && ((byte[])data).length >= bufferLength) {
          tmpArray=(byte[])data;
        }
 else {
          tmpArray=new byte[bufferLength];
          buffer.setData(tmpArray);
        }
        System.arraycopy(bufferData,0,tmpArray,0,bufferLength);
        buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
        buffer.setLength(bufferLength);
        buffer.setOffset(0);
        buffer.setTimeStamp(bufferTimeStamp);
      }
      break;
    }
    bufferData=null;
  }
}","/** 
 * Reads audio data from this <tt>InputPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>InputPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public void read(Buffer buffer) throws PortAudioException {
  if (stopping || !started) {
    buffer.setLength(0);
    return;
  }
synchronized (readSync) {
    while (true) {
      if (bufferData == null) {
        if (!parentStream.read(buffer)) {
          try {
            readSync.wait();
          }
 catch (          InterruptedException e) {
          }
          continue;
        }
      }
 else {
        Object data=buffer.getData();
        byte[] dataArray=null;
        if (data instanceof byte[]) {
          dataArray=(byte[])data;
          if (dataArray.length < bufferLength)           dataArray=null;
        }
        if (dataArray == null) {
          dataArray=new byte[bufferLength];
          buffer.setData(dataArray);
        }
        System.arraycopy(bufferData,0,dataArray,0,bufferLength);
        buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
        buffer.setLength(bufferLength);
        buffer.setOffset(0);
        buffer.setTimeStamp(bufferTimeStamp);
      }
      break;
    }
    bufferData=null;
  }
}",0.884373845585519
103680,"/** 
 * Reads audio data from this <tt>MasterPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>MasterPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public boolean read(Buffer buffer) throws PortAudioException {
synchronized (readSync) {
    if (readActive) {
      return false;
    }
    readActive=true;
    if (!started) {
      buffer.setLength(0);
      return true;
    }
  }
  Object data=buffer.getData();
  byte[] bufferData;
  if (data instanceof byte[] && ((byte[])data).length >= bytesPerBuffer) {
    bufferData=(byte[])data;
  }
 else {
    bufferData=new byte[bytesPerBuffer];
    buffer.setData(bufferData);
  }
synchronized (connectedToStreamSync) {
    PortAudio.Pa_ReadStream(stream,bufferData,framesPerBuffer);
  }
  long bufferTimeStamp=System.nanoTime();
  buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
  buffer.setLength(bytesPerBuffer);
  buffer.setOffset(0);
  buffer.setTimeStamp(bufferTimeStamp);
  int slaveCount=slaves.size();
  for (int slaveIndex=0; slaveIndex < slaveCount; slaveIndex++) {
    slaves.get(slaveIndex).setBuffer(bufferData,bytesPerBuffer,bufferTimeStamp);
  }
synchronized (readSync) {
    readActive=false;
    readSync.notify();
  }
  return true;
}","/** 
 * Reads audio data from this <tt>MasterPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>MasterPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public boolean read(Buffer buffer) throws PortAudioException {
synchronized (readSync) {
    if (!started) {
      buffer.setLength(0);
      return true;
    }
    if (readActive)     return false;
    readActive=true;
  }
  try {
    Object data=buffer.getData();
    byte[] bufferData=null;
    if (data instanceof byte[]) {
      bufferData=(byte[])data;
      if (bufferData.length < bytesPerBuffer)       bufferData=null;
    }
    if (bufferData == null) {
      bufferData=new byte[bytesPerBuffer];
      buffer.setData(bufferData);
    }
synchronized (connectedToStreamSync) {
      PortAudio.Pa_ReadStream(stream,bufferData,framesPerBuffer);
    }
    long bufferTimeStamp=System.nanoTime();
    buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
    buffer.setLength(bytesPerBuffer);
    buffer.setOffset(0);
    buffer.setTimeStamp(bufferTimeStamp);
    int slaveCount=slaves.size();
    for (int slaveIndex=0; slaveIndex < slaveCount; slaveIndex++) {
      slaves.get(slaveIndex).setBuffer(bufferData,bytesPerBuffer,bufferTimeStamp);
    }
  }
  finally {
synchronized (readSync) {
      readActive=false;
      readSync.notify();
    }
  }
  return true;
}",0.7402011793270898
103681,"/** 
 * Stops the reading of a specific <tt>InputPortAudioStream</tt> from this <tt>MasterPortAudioStream</tt>. When the last such <tt>InputPortAudioStream</tt> stops reading from this instance, this instance closes the native PortAudio stream it reads from.
 * @param slave the <tt>InputPortAudioStream</tt> which has been stopped andno longer wants to read audio from this instance
 * @throws PortAudioException if anything wrong happens while stopping thenative PortAudio stream this instance reads from
 */
synchronized void stop(InputPortAudioStream slave) throws PortAudioException {
  if (!started)   return;
  slaves.remove(slave);
  if (slaves.isEmpty()) {
synchronized (readSync) {
      while (readActive) {
        try {
          readSync.wait();
        }
 catch (        InterruptedException e) {
          continue;
        }
      }
      PortAudio.Pa_CloseStream(stream);
      stream=0;
      started=false;
      PortAudioManager.getInstance().stoppedInputPortAudioStream(this);
    }
  }
}","/** 
 * Stops the reading of a specific <tt>InputPortAudioStream</tt> from this <tt>MasterPortAudioStream</tt>. When the last such <tt>InputPortAudioStream</tt> stops reading from this instance, this instance closes the native PortAudio stream it reads from.
 * @param slave the <tt>InputPortAudioStream</tt> which has been stopped andno longer wants to read audio from this instance
 * @throws PortAudioException if anything wrong happens while stopping thenative PortAudio stream this instance reads from
 */
synchronized void stop(InputPortAudioStream slave) throws PortAudioException {
  if (!started)   return;
  slaves.remove(slave);
  if (slaves.isEmpty()) {
synchronized (readSync) {
      while (readActive) {
        try {
          readSync.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      PortAudio.Pa_CloseStream(stream);
      stream=0;
      started=false;
      PortAudioManager.getInstance().stoppedInputPortAudioStream(this);
    }
  }
}",0.99
103682,"/** 
 * Reads audio data from this <tt>MasterPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>MasterPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public boolean read(Buffer buffer) throws PortAudioException {
synchronized (readSync) {
    if (!started) {
      buffer.setLength(0);
      return true;
    }
    if (readActive)     return false;
    readActive=true;
  }
  try {
    Object data=buffer.getData();
    byte[] bufferData=null;
    if (data instanceof byte[]) {
      bufferData=(byte[])data;
      if (bufferData.length < bytesPerBuffer)       bufferData=null;
    }
    if (bufferData == null) {
      bufferData=new byte[bytesPerBuffer];
      buffer.setData(bufferData);
    }
synchronized (connectedToStreamSync) {
      PortAudio.Pa_ReadStream(stream,bufferData,framesPerBuffer);
    }
    long bufferTimeStamp=System.nanoTime();
    buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
    buffer.setLength(bytesPerBuffer);
    buffer.setOffset(0);
    buffer.setTimeStamp(bufferTimeStamp);
    int slaveCount=slaves.size();
    for (int slaveIndex=0; slaveIndex < slaveCount; slaveIndex++) {
      slaves.get(slaveIndex).setBuffer(bufferData,bytesPerBuffer,bufferTimeStamp);
    }
  }
  finally {
synchronized (readSync) {
      readActive=false;
      readSync.notify();
    }
  }
  return true;
}","/** 
 * Reads audio data from this <tt>MasterPortAudioStream</tt> into a specific <tt>Buffer</tt> blocking until audio data is indeed available.
 * @param buffer the <tt>Buffer</tt> into which the audio data read fromthis <tt>MasterPortAudioStream</tt> is to be returned
 * @throws PortAudioException if an error occurs while reading
 */
public boolean read(Buffer buffer) throws PortAudioException {
synchronized (readSync) {
    if (!started) {
      buffer.setLength(0);
      return true;
    }
    if (readActive)     return false;
    readActive=true;
  }
  try {
    Object data=buffer.getData();
    byte[] bufferData=null;
    if (data instanceof byte[]) {
      bufferData=(byte[])data;
      if (bufferData.length < bytesPerBuffer)       bufferData=null;
    }
    if (bufferData == null) {
      bufferData=new byte[bytesPerBuffer];
      buffer.setData(bufferData);
    }
synchronized (connectedToStreamSync) {
      PortAudio.Pa_ReadStream(stream,bufferData,framesPerBuffer);
    }
    long bufferTimeStamp=System.nanoTime();
    buffer.setFlags(Buffer.FLAG_SYSTEM_TIME);
    buffer.setLength(bytesPerBuffer);
    buffer.setOffset(0);
    buffer.setTimeStamp(bufferTimeStamp);
    int slaveCount=slaves.size();
    for (int slaveIndex=0; slaveIndex < slaveCount; slaveIndex++) {
      slaves.get(slaveIndex).setBuffer(bufferData,bytesPerBuffer,bufferTimeStamp);
    }
  }
  finally {
synchronized (readSync) {
      readActive=false;
      readSync.notifyAll();
    }
  }
  return true;
}",0.9990003332222592
103683,"/** 
 * Stops the reading of a specific <tt>InputPortAudioStream</tt> from this <tt>MasterPortAudioStream</tt>. When the last such <tt>InputPortAudioStream</tt> stops reading from this instance, this instance closes the native PortAudio stream it reads from.
 * @param slave the <tt>InputPortAudioStream</tt> which has been stopped andno longer wants to read audio from this instance
 * @throws PortAudioException if anything wrong happens while stopping thenative PortAudio stream this instance reads from
 */
synchronized void stop(InputPortAudioStream slave) throws PortAudioException {
  if (!started)   return;
  slaves.remove(slave);
  if (slaves.isEmpty()) {
synchronized (readSync) {
      while (readActive) {
        try {
          readSync.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      PortAudio.Pa_CloseStream(stream);
      stream=0;
      started=false;
      PortAudioManager.getInstance().stoppedInputPortAudioStream(this);
    }
  }
}","/** 
 * Stops the reading of a specific <tt>InputPortAudioStream</tt> from this <tt>MasterPortAudioStream</tt>. When the last such <tt>InputPortAudioStream</tt> stops reading from this instance, this instance closes the native PortAudio stream it reads from.
 * @param slave the <tt>InputPortAudioStream</tt> which has been stopped andno longer wants to read audio from this instance
 * @throws PortAudioException if anything wrong happens while stopping thenative PortAudio stream this instance reads from
 */
synchronized void stop(InputPortAudioStream slave) throws PortAudioException {
  if (!started)   return;
  slaves.remove(slave);
  if (slaves.isEmpty()) {
synchronized (readSync) {
      while (readActive) {
        try {
          readSync.wait(100);
        }
 catch (        InterruptedException e) {
        }
      }
      PortAudio.Pa_CloseStream(stream);
      stream=0;
      started=false;
      PortAudioManager.getInstance().stoppedInputPortAudioStream(this);
    }
  }
}",0.9984871406959152
103684,"/** 
 * Creates the <tt>SearchField</tt>.
 * @param frame the main application window
 */
public SearchField(MainFrame frame){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=frame;
  SearchFieldUI textFieldUI=new SearchFieldUI();
  textFieldUI.setDeleteButtonEnabled(true);
  this.setUI(textFieldUI);
  this.setBorder(null);
  this.setOpaque(false);
  this.setPreferredSize(new Dimension(100,22));
  this.setDragEnabled(true);
  this.addTextChangeListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_FOCUSED);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      SearchField.this.mainFrame.requestFocusInCenterPanel();
    }
  }
);
}","/** 
 * Creates the <tt>SearchField</tt>.
 * @param frame the main application window
 */
public SearchField(MainFrame frame){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=frame;
  SearchFieldUI textFieldUI=new SearchFieldUI();
  textFieldUI.setDeleteButtonEnabled(true);
  this.setUI(textFieldUI);
  this.setBorder(null);
  this.setOpaque(false);
  this.setPreferredSize(new Dimension(100,22));
  this.setDragEnabled(true);
  this.addTextChangeListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      SearchField.this.mainFrame.requestFocusInCenterPanel();
    }
  }
);
}",0.9876543209876544
103685,"/** 
 * Starts the <tt>SendStream</tt>s of the <tt>RTPManager</tt> of this <tt>MediaStream</tt>.
 */
private void startSendStreams(){
  if (!sendStreamsAreCreated)   createSendStreams();
  RTPManager rtpManager=getRTPManager();
  @SuppressWarnings(""String_Node_Str"") Iterable<SendStream> sendStreams=rtpManager.getSendStreams();
  if (sendStreams != null)   for (  SendStream sendStream : sendStreams)   try {
    sendStream.getDataSource().connect();
    sendStream.start();
    sendStream.getDataSource().start();
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode());
  }
 catch (  IOException ioe) {
    logger.warn(""String_Node_Str"" + sendStream,ioe);
  }
}","/** 
 * Starts the <tt>SendStream</tt>s of the <tt>RTPManager</tt> of this <tt>MediaStreamImpl</tt>.
 */
private void startSendStreams(){
  if (!sendStreamsAreCreated)   createSendStreams();
  RTPManager rtpManager=getRTPManager();
  @SuppressWarnings(""String_Node_Str"") Iterable<SendStream> sendStreams=rtpManager.getSendStreams();
  if (sendStreams != null) {
    for (    SendStream sendStream : sendStreams) {
      try {
        sendStream.getDataSource().connect();
        sendStream.start();
        sendStream.getDataSource().start();
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + sendStream.hashCode());
        }
      }
 catch (      IOException ioe) {
        logger.warn(""String_Node_Str"" + sendStream,ioe);
      }
    }
  }
}",0.9359145527369828
103686,"/** 
 * Starts the processing of media in this instance in a specific direction.
 * @param direction a <tt>MediaDirection</tt> value which represents thedirection of the processing of media to be started. For example, {@link MediaDirection#SENDRECV} to start both capture and playback ofmedia in this instance or  {@link MediaDirection#SENDONLY} to only startthe capture of media in this instance
 */
@SuppressWarnings(""String_Node_Str"") private void start(MediaDirection direction){
  if (direction == null)   throw new NullPointerException(""String_Node_Str"");
  if (direction.allowsSending() && ((startedDirection == null) || !startedDirection.allowsSending())) {
    startSendStreams();
    getDeviceSession().start(MediaDirection.SENDONLY);
    if (MediaDirection.RECVONLY.equals(startedDirection))     startedDirection=MediaDirection.SENDRECV;
 else     if (startedDirection == null)     startedDirection=MediaDirection.SENDONLY;
  }
  if (direction.allowsReceiving() && ((startedDirection == null) || !startedDirection.allowsReceiving())) {
    RTPManager rtpManager=getRTPManager();
    Iterable<ReceiveStream> receiveStreams;
    try {
      receiveStreams=rtpManager.getReceiveStreams();
    }
 catch (    Exception e) {
      logger.trace(""String_Node_Str"",e);
      receiveStreams=null;
    }
    if (receiveStreams != null)     for (    ReceiveStream receiveStream : receiveStreams)     try {
      DataSource receiveStreamDataSource=receiveStream.getDataSource();
      if (receiveStreamDataSource != null)       receiveStreamDataSource.start();
    }
 catch (    IOException ioe) {
      logger.warn(""String_Node_Str"" + receiveStream,ioe);
    }
    getDeviceSession().start(MediaDirection.RECVONLY);
    if (MediaDirection.SENDONLY.equals(startedDirection))     startedDirection=MediaDirection.SENDRECV;
 else     if (startedDirection == null)     startedDirection=MediaDirection.RECVONLY;
  }
}","/** 
 * Starts the processing of media in this instance in a specific direction.
 * @param direction a <tt>MediaDirection</tt> value which represents thedirection of the processing of media to be started. For example, {@link MediaDirection#SENDRECV} to start both capture and playback ofmedia in this instance or  {@link MediaDirection#SENDONLY} to only startthe capture of media in this instance
 */
private void start(MediaDirection direction){
  if (direction == null)   throw new NullPointerException(""String_Node_Str"");
  if (direction.allowsSending() && ((startedDirection == null) || !startedDirection.allowsSending())) {
    startSendStreams();
    getDeviceSession().start(MediaDirection.SENDONLY);
    if (MediaDirection.RECVONLY.equals(startedDirection))     startedDirection=MediaDirection.SENDRECV;
 else     if (startedDirection == null)     startedDirection=MediaDirection.SENDONLY;
  }
  if (direction.allowsReceiving() && ((startedDirection == null) || !startedDirection.allowsReceiving())) {
    startReceiveStreams();
    getDeviceSession().start(MediaDirection.RECVONLY);
    if (MediaDirection.SENDONLY.equals(startedDirection))     startedDirection=MediaDirection.SENDRECV;
 else     if (startedDirection == null)     startedDirection=MediaDirection.RECVONLY;
  }
}",0.7938692524241476
103687,"/** 
 * The <tt>ZrtpControl</tt> which controls the ZRTP for the current stream.
 * @return the <tt>ZrtpControl</tt> for the current stream.
 */
public ZrtpControl getZrtpControl(){
  return zrtpControl;
}","/** 
 * Gets the <tt>ZrtpControl</tt> which controls the ZRTP of this stream.
 * @return the <tt>ZrtpControl</tt> which controls the ZRTP of this stream
 */
public ZrtpControl getZrtpControl(){
  return zrtpControl;
}",0.8293838862559242
103688,"/** 
 * Stops the processing of media in this instance in a specific direction.
 * @param direction a <tt>MediaDirection</tt> value which represents thedirection of the processing of media to be stopped. For example, {@link MediaDirection#SENDRECV} to stop both capture and playback ofmedia in this instance or  {@link MediaDirection#SENDONLY} to only stopthe capture of media in this instance
 */
@SuppressWarnings(""String_Node_Str"") private void stop(MediaDirection direction){
  if (direction == null)   throw new NullPointerException(""String_Node_Str"");
  if (rtpManager == null)   return;
  if ((MediaDirection.SENDRECV.equals(direction) || MediaDirection.SENDONLY.equals(direction)) && (MediaDirection.SENDRECV.equals(startedDirection) || MediaDirection.SENDONLY.equals(startedDirection))) {
    stopSendStreams(false);
    if (deviceSession != null)     deviceSession.stop(MediaDirection.SENDONLY);
    if (MediaDirection.SENDRECV.equals(startedDirection))     startedDirection=MediaDirection.RECVONLY;
 else     if (MediaDirection.SENDONLY.equals(startedDirection))     startedDirection=null;
  }
  if ((MediaDirection.SENDRECV.equals(direction) || MediaDirection.RECVONLY.equals(direction)) && (MediaDirection.SENDRECV.equals(startedDirection) || MediaDirection.RECVONLY.equals(startedDirection))) {
    Iterable<ReceiveStream> receiveStreams;
    try {
      receiveStreams=rtpManager.getReceiveStreams();
    }
 catch (    Exception e) {
      logger.trace(""String_Node_Str"",e);
      receiveStreams=null;
    }
    if (receiveStreams != null)     for (    ReceiveStream receiveStream : receiveStreams)     try {
      DataSource receiveStreamDataSource=receiveStream.getDataSource();
      if (receiveStreamDataSource != null)       receiveStreamDataSource.stop();
    }
 catch (    IOException ioe) {
      logger.warn(""String_Node_Str"" + receiveStream,ioe);
    }
    if (deviceSession != null)     deviceSession.stop(MediaDirection.RECVONLY);
    if (MediaDirection.SENDRECV.equals(startedDirection))     startedDirection=MediaDirection.SENDONLY;
 else     if (MediaDirection.RECVONLY.equals(startedDirection))     startedDirection=null;
  }
}","/** 
 * Stops the processing of media in this instance in a specific direction.
 * @param direction a <tt>MediaDirection</tt> value which represents thedirection of the processing of media to be stopped. For example, {@link MediaDirection#SENDRECV} to stop both capture and playback ofmedia in this instance or  {@link MediaDirection#SENDONLY} to only stopthe capture of media in this instance
 */
private void stop(MediaDirection direction){
  if (direction == null)   throw new NullPointerException(""String_Node_Str"");
  if (rtpManager == null)   return;
  if ((MediaDirection.SENDRECV.equals(direction) || MediaDirection.SENDONLY.equals(direction)) && (MediaDirection.SENDRECV.equals(startedDirection) || MediaDirection.SENDONLY.equals(startedDirection))) {
    stopSendStreams(false);
    if (deviceSession != null)     deviceSession.stop(MediaDirection.SENDONLY);
    if (MediaDirection.SENDRECV.equals(startedDirection))     startedDirection=MediaDirection.RECVONLY;
 else     if (MediaDirection.SENDONLY.equals(startedDirection))     startedDirection=null;
  }
  if ((MediaDirection.SENDRECV.equals(direction) || MediaDirection.RECVONLY.equals(direction)) && (MediaDirection.SENDRECV.equals(startedDirection) || MediaDirection.RECVONLY.equals(startedDirection))) {
    stopReceiveStreams();
    if (deviceSession != null)     deviceSession.stop(MediaDirection.RECVONLY);
    if (MediaDirection.SENDRECV.equals(startedDirection))     startedDirection=MediaDirection.SENDONLY;
 else     if (MediaDirection.RECVONLY.equals(startedDirection))     startedDirection=null;
  }
}",0.8410064239828694
103689,"/** 
 * Inits the dialog initial display.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout());
  contentPane=new TransparentPanel(new BorderLayout(5,5));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(10,5,5,5));
  JLabel imgLabel=new JLabel(GuiActivator.getResources().getImage(""String_Node_Str""));
  imgLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  northPanel.add(imgLabel,BorderLayout.WEST);
  String descriptionTxt=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{GuiActivator.getResources().getSettingsString(""String_Node_Str""),host,String.valueOf(port)});
  JEditorPane descriptionPane=new JEditorPane();
  descriptionPane.setOpaque(false);
  descriptionPane.setEditable(false);
  descriptionPane.setContentType(""String_Node_Str"");
  descriptionPane.setText(descriptionTxt);
  descriptionPane.setSize(new Dimension(MAX_MSG_PANE_WIDTH,MAX_MSG_PANE_HEIGHT));
  int height=descriptionPane.getPreferredSize().height;
  descriptionPane.setPreferredSize(new Dimension(MAX_MSG_PANE_WIDTH,height));
  northPanel.add(descriptionPane,BorderLayout.CENTER);
  contentPane.add(northPanel,BorderLayout.NORTH);
  certPanel=new TransparentPanel();
  contentPane.add(certPanel,BorderLayout.CENTER);
  TransparentPanel southPanel=new TransparentPanel(new BorderLayout());
  contentPane.add(southPanel,BorderLayout.SOUTH);
  certButton=new JButton();
  certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  certButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionShowCertificate();
    }
  }
);
  TransparentPanel firstButonPanel=new TransparentPanel(new FlowLayout(FlowLayout.LEFT));
  firstButonPanel.add(certButton);
  southPanel.add(firstButonPanel,BorderLayout.WEST);
  TransparentPanel secondButonPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  JButton cancelButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionCancel();
    }
  }
);
  JButton continueButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  continueButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionContinue();
    }
  }
);
  secondButonPanel.add(continueButton);
  secondButonPanel.add(cancelButton);
  southPanel.add(secondButonPanel,BorderLayout.EAST);
  this.getContentPane().add(contentPane,BorderLayout.CENTER);
  pack();
}","/** 
 * Inits the dialog initial display.
 */
private void init(){
  this.getContentPane().setLayout(new BorderLayout());
  contentPane=new TransparentPanel(new BorderLayout(5,5));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(5,5));
  northPanel.setBorder(BorderFactory.createEmptyBorder(10,5,5,5));
  JLabel imgLabel=new JLabel(GuiActivator.getResources().getImage(""String_Node_Str""));
  imgLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  northPanel.add(imgLabel,BorderLayout.WEST);
  String descriptionTxt=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{GuiActivator.getResources().getSettingsString(""String_Node_Str""),host,String.valueOf(port)});
  StyledHTMLEditorPane descriptionPane=new StyledHTMLEditorPane();
  descriptionPane.setOpaque(false);
  descriptionPane.setEditable(false);
  descriptionPane.setContentType(""String_Node_Str"");
  descriptionPane.setText(descriptionTxt);
  descriptionPane.setSize(new Dimension(MAX_MSG_PANE_WIDTH,MAX_MSG_PANE_HEIGHT));
  int height=descriptionPane.getPreferredSize().height;
  descriptionPane.setPreferredSize(new Dimension(MAX_MSG_PANE_WIDTH,height));
  northPanel.add(descriptionPane,BorderLayout.CENTER);
  contentPane.add(northPanel,BorderLayout.NORTH);
  certPanel=new TransparentPanel();
  contentPane.add(certPanel,BorderLayout.CENTER);
  TransparentPanel southPanel=new TransparentPanel(new BorderLayout());
  contentPane.add(southPanel,BorderLayout.SOUTH);
  certButton=new JButton();
  certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  certButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionShowCertificate();
    }
  }
);
  TransparentPanel firstButonPanel=new TransparentPanel(new FlowLayout(FlowLayout.LEFT));
  firstButonPanel.add(certButton);
  southPanel.add(firstButonPanel,BorderLayout.WEST);
  TransparentPanel secondButonPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  JButton cancelButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionCancel();
    }
  }
);
  JButton continueButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  continueButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      actionContinue();
    }
  }
);
  secondButonPanel.add(continueButton);
  secondButonPanel.add(cancelButton);
  southPanel.add(secondButonPanel,BorderLayout.EAST);
  this.getContentPane().add(contentPane,BorderLayout.CENTER);
  pack();
}",0.995910780669145
103690,"/** 
 * Action when shoe certificate button is clicked.
 */
private void actionShowCertificate(){
  if (certOpened) {
    certPanel.removeAll();
    certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    certPanel.revalidate();
    certPanel.repaint();
    pack();
    certOpened=false;
    setLocationRelativeTo(getParent());
    return;
  }
  certPanel.setLayout(new BorderLayout());
  certPanel.add(alwaysTrustCheckBox,BorderLayout.NORTH);
  Component certInfoPane=null;
  if (cert instanceof X509Certificate) {
    certInfoPane=getX509DisplayComponent((X509Certificate)cert);
  }
 else {
    JTextArea textArea=new JTextArea();
    textArea.setEditable(false);
    textArea.setText(cert.toString());
    certInfoPane=textArea;
  }
  final JScrollPane certScroll=new JScrollPane(certInfoPane);
  certScroll.setPreferredSize(new Dimension(300,300));
  certPanel.add(certScroll,BorderLayout.CENTER);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      certScroll.getVerticalScrollBar().setValue(0);
    }
  }
);
  certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  certPanel.revalidate();
  certPanel.repaint();
  setPreferredSize(null);
  pack();
  certOpened=true;
  setLocationRelativeTo(getParent());
}","/** 
 * Action when shoe certificate button is clicked.
 */
private void actionShowCertificate(){
  if (certOpened) {
    certPanel.removeAll();
    certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    certPanel.revalidate();
    certPanel.repaint();
    pack();
    certOpened=false;
    setLocationRelativeTo(getParent());
    return;
  }
  certPanel.setLayout(new BorderLayout());
  certPanel.add(alwaysTrustCheckBox,BorderLayout.NORTH);
  Component certInfoPane=null;
  if (cert instanceof X509Certificate) {
    certInfoPane=getX509DisplayComponent((X509Certificate)cert);
  }
 else {
    JTextArea textArea=new JTextArea();
    textArea.setOpaque(false);
    textArea.setEditable(false);
    textArea.setText(cert.toString());
    certInfoPane=textArea;
  }
  final JScrollPane certScroll=new JScrollPane(certInfoPane);
  certScroll.setPreferredSize(new Dimension(300,300));
  certPanel.add(certScroll,BorderLayout.CENTER);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      certScroll.getVerticalScrollBar().setValue(0);
    }
  }
);
  certButton.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  certPanel.revalidate();
  certPanel.repaint();
  setPreferredSize(null);
  pack();
  certOpened=true;
  setLocationRelativeTo(getParent());
}",0.9881543752388232
103691,"/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 * @param parentPanel the parent panel
 */
private void createPortAudioControls(JPanel portAudioPanel,JPanel parentPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final JCheckBox echoCancelCheckBox=new JCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final JCheckBox denoiseCheckBox=new JCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  parentPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
}","/** 
 * Creates the ui controls for portaudio.
 * @param portAudioPanel the panel
 * @param parentPanel the parent panel
 */
private void createPortAudioControls(JPanel portAudioPanel,JPanel parentPanel){
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.NORTHWEST;
  constraints.gridx=0;
  constraints.weightx=0;
  constraints.weighty=0;
  constraints.gridy=0;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)),constraints);
  constraints.gridy=1;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)),constraints);
  constraints.gridy=2;
  portAudioPanel.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)),constraints);
  constraints.weightx=1;
  constraints.gridx=1;
  constraints.gridy=0;
  JComboBox captureCombo=new JComboBox();
  captureCombo.setEditable(false);
  captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));
  portAudioPanel.add(captureCombo,constraints);
  constraints.gridy=1;
  JComboBox playbackCombo=new JComboBox();
  playbackCombo.setEditable(false);
  playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));
  portAudioPanel.add(playbackCombo,constraints);
  constraints.gridy=2;
  JComboBox notifyCombo=new JComboBox();
  notifyCombo.setEditable(false);
  notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(),DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));
  portAudioPanel.add(notifyCombo,constraints);
  constraints.gridy=3;
  constraints.insets=new Insets(10,0,0,0);
  final SIPCommCheckBox echoCancelCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  echoCancelCheckBox.setSelected(mediaService.getDeviceConfiguration().isEchoCancelEnabled());
  echoCancelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setEchoCancel(echoCancelCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(echoCancelCheckBox,constraints);
  constraints.gridy=4;
  constraints.insets=new Insets(0,0,0,0);
  final SIPCommCheckBox denoiseCheckBox=new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(""String_Node_Str""));
  denoiseCheckBox.setSelected(mediaService.getDeviceConfiguration().isDenoiseEnabled());
  denoiseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      mediaService.getDeviceConfiguration().setDenoise(denoiseCheckBox.isSelected(),true);
    }
  }
);
  portAudioPanel.add(denoiseCheckBox,constraints);
  parentPanel.setBorder(BorderFactory.createTitledBorder(NeomediaActivator.getResources().getI18NString(""String_Node_Str"")));
}",0.9946506185222334
103692,"/** 
 * Enters or exits the ""unknown contact"" view. This view will propose to the user some specific operations if the current filter doesn't match any contacts.
 * @param isEnabled <tt>true</tt> to enable the ""unknown contact"" view,<tt>false</tt> - otherwise.
 */
public void enableUnknownContactView(boolean isEnabled){
  if (isEnabled) {
    if (unknownContactPanel == null)     unknownContactPanel=new UnknownContactPanel(this);
    centerPanel.remove(contactListPanel);
    centerPanel.add(unknownContactPanel,BorderLayout.CENTER);
  }
 else   if (unknownContactPanel != null) {
    centerPanel.remove(unknownContactPanel);
    centerPanel.add(contactListPanel,BorderLayout.CENTER);
  }
  centerPanel.revalidate();
  centerPanel.repaint();
}","/** 
 * Enters or exits the ""unknown contact"" view. This view will propose to the user some specific operations if the current filter doesn't match any contacts.
 * @param isEnabled <tt>true</tt> to enable the ""unknown contact"" view,<tt>false</tt> - otherwise.
 */
public void enableUnknownContactView(boolean isEnabled){
  if (isEnabled) {
    if (unknownContactPanel == null)     unknownContactPanel=new UnknownContactPanel(this);
    contactListPanel.setVisible(false);
    unknownContactPanel.setVisible(true);
    centerPanel.remove(contactListPanel);
    centerPanel.add(unknownContactPanel,BorderLayout.CENTER);
  }
 else   if (unknownContactPanel != null) {
    unknownContactPanel.setVisible(false);
    contactListPanel.setVisible(true);
    centerPanel.remove(unknownContactPanel);
    centerPanel.add(contactListPanel,BorderLayout.CENTER);
  }
  centerPanel.revalidate();
  centerPanel.repaint();
}",0.9009661835748792
103693,"/** 
 * Dispatches the given <tt>KeyEvent</tt>.
 * @param e the <tt>KeyEvent</tt> to dispatch
 * @return <tt>true</tt> if the KeyboardFocusManager should take nofurther action with regard to the KeyEvent; <tt>false</tt> otherwise
 */
public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || (e.getID() != KeyEvent.KEY_PRESSED && e.getID() != KeyEvent.KEY_TYPED))   return false;
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner() && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    searchField.requestFocusInWindow();
    keyManager.redispatchEvent(searchField,e);
    return true;
  }
  return false;
}","/** 
 * Dispatches the given <tt>KeyEvent</tt>.
 * @param e the <tt>KeyEvent</tt> to dispatch
 * @return <tt>true</tt> if the KeyboardFocusManager should take nofurther action with regard to the KeyEvent; <tt>false</tt> otherwise
 */
public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || (e.getID() != KeyEvent.KEY_PRESSED && e.getID() != KeyEvent.KEY_TYPED))   return false;
  if (e.getKeyCode() == KeyEvent.VK_ENTER && (e.isControlDown() || e.isMetaDown())) {
    ctrlEnterKeyTyped();
    return false;
  }
 else   if (e.getKeyCode() == KeyEvent.VK_ENTER && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    enterKeyTyped();
    return false;
  }
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner() && keyManager.getFocusOwner().equals(keyManager.getPermanentFocusOwner())) {
    searchField.requestFocusInWindow();
    keyManager.redispatchEvent(searchField,e);
    return true;
  }
  return false;
}",0.9186706295595785
103694,"/** 
 * Initializes and add some common components.
 */
private void init(){
  setInvoker(invoker);
  this.add(createInfoLabel());
  this.addSeparator();
}","/** 
 * Initializes and add some common components.
 */
private void init(){
  setInvoker(invoker);
  this.add(createInfoLabel());
  this.addSeparator();
  this.setFocusable(true);
}",0.9198813056379822
103695,"/** 
 * Initializes the contact list.
 * @param contactListService The MetaContactListService which will be usedfor a contact list data model.
 */
public void initList(MetaContactListService contactListService){
  this.contactList=new TreeContactList();
  GuiActivator.setContactList(contactList);
  TransparentPanel transparentPanel=new TransparentPanel(new BorderLayout());
  transparentPanel.add(contactList,BorderLayout.NORTH);
  this.setViewportView(transparentPanel);
  transparentPanel.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
  this.contactList.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.contactList.addContactListListener(this);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
        commonRightButtonMenu=new CommonRightButtonMenu(mainFrame);
        commonRightButtonMenu.setInvoker(ContactListPane.this);
        commonRightButtonMenu.setLocation(e.getX() + mainFrame.getX() + 5,e.getY() + mainFrame.getY() + 105);
        commonRightButtonMenu.setVisible(true);
      }
    }
  }
);
  this.getActionMap().put(""String_Node_Str"",new ContactListPanelEnterAction());
  InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
}","/** 
 * Initializes the contact list.
 * @param contactListService The MetaContactListService which will be usedfor a contact list data model.
 */
public void initList(MetaContactListService contactListService){
  this.contactList=new TreeContactList();
  GuiActivator.setContactList(contactList);
  TransparentPanel transparentPanel=new TransparentPanel(new BorderLayout());
  transparentPanel.add(contactList,BorderLayout.NORTH);
  this.setViewportView(transparentPanel);
  transparentPanel.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
  this.contactList.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.contactList.addContactListListener(this);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
        commonRightButtonMenu=new CommonRightButtonMenu(mainFrame);
        commonRightButtonMenu.setInvoker(ContactListPane.this);
        commonRightButtonMenu.setLocation(e.getX() + mainFrame.getX() + 5,e.getY() + mainFrame.getY() + 105);
        commonRightButtonMenu.setVisible(true);
      }
    }
  }
);
}",0.9101123595505618
103696,"/** 
 * Initializes the panel containing the node.
 */
public ContactListTreeCellRenderer(){
  super(new GridBagLayout());
  this.setBorder(BorderFactory.createEmptyBorder(2,5,2,2));
  int groupForegroundProperty=GuiActivator.getResources().getColor(""String_Node_Str"");
  if (groupForegroundProperty > -1)   groupForegroundColor=new Color(groupForegroundProperty);
  int contactForegroundProperty=GuiActivator.getResources().getColor(""String_Node_Str"");
  if (contactForegroundProperty > -1)   contactForegroundColor=new Color(contactForegroundProperty);
  this.setOpaque(false);
  this.nameLabel.setOpaque(false);
  this.statusMessageLabel.setFont(getFont().deriveFont(9f));
  this.statusMessageLabel.setForeground(Color.GRAY);
  this.rightLabel.setFont(rightLabel.getFont().deriveFont(9f));
  this.rightLabel.setHorizontalAlignment(JLabel.RIGHT);
  statusLabel.setBorder(BorderFactory.createEmptyBorder(2,0,0,2));
  constraints.anchor=GridBagConstraints.WEST;
  constraints.fill=GridBagConstraints.VERTICAL;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.gridheight=1;
  constraints.weightx=0f;
  constraints.weighty=1f;
  this.add(statusLabel,constraints);
  constraints.anchor=GridBagConstraints.WEST;
  constraints.fill=GridBagConstraints.NONE;
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.weightx=1f;
  constraints.weighty=0f;
  constraints.gridheight=1;
  constraints.gridwidth=2;
  this.add(nameLabel,constraints);
  rightLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,2));
  constraints.anchor=GridBagConstraints.NORTHEAST;
  constraints.fill=GridBagConstraints.VERTICAL;
  constraints.gridx=3;
  constraints.gridy=0;
  constraints.gridheight=3;
  constraints.weightx=0f;
  constraints.weighty=1f;
  this.add(rightLabel,constraints);
  this.callButton.setName(CALL_BUTTON_NAME);
  this.chatButton.setName(CHAT_BUTTON_NAME);
  callButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (treeNode != null && treeNode instanceof ContactNode) {
        List<Contact> telephonyContacts=((ContactNode)treeNode).getMetaContact().getContactsForOperationSet(OperationSetBasicTelephony.class);
        if (telephonyContacts.size() == 1) {
          Contact contact=telephonyContacts.get(0);
          CallManager.createCall(telephonyContacts.get(0).getProtocolProvider(),contact);
        }
 else         if (telephonyContacts.size() > 1) {
          ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(callButton,telephonyContacts);
          Point location=new Point(callButton.getX(),callButton.getY() + callButton.getHeight());
          SwingUtilities.convertPointToScreen(location,tree);
          location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
          chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
        }
      }
    }
  }
);
  chatButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (treeNode != null && treeNode instanceof ContactNode) {
        GuiActivator.getUIService().getChatWindowManager().startChat(((ContactNode)treeNode).getMetaContact());
      }
    }
  }
);
  this.setToolTipText(""String_Node_Str"");
}","/** 
 * Initializes the panel containing the node.
 */
public ContactListTreeCellRenderer(){
  super(new GridBagLayout());
  this.setBorder(BorderFactory.createEmptyBorder(2,5,2,2));
  int groupForegroundProperty=GuiActivator.getResources().getColor(""String_Node_Str"");
  if (groupForegroundProperty > -1)   groupForegroundColor=new Color(groupForegroundProperty);
  int contactForegroundProperty=GuiActivator.getResources().getColor(""String_Node_Str"");
  if (contactForegroundProperty > -1)   contactForegroundColor=new Color(contactForegroundProperty);
  this.setOpaque(false);
  this.nameLabel.setOpaque(false);
  this.statusMessageLabel.setFont(getFont().deriveFont(9f));
  this.statusMessageLabel.setForeground(Color.GRAY);
  this.rightLabel.setFont(rightLabel.getFont().deriveFont(9f));
  this.rightLabel.setHorizontalAlignment(JLabel.RIGHT);
  statusLabel.setBorder(BorderFactory.createEmptyBorder(2,0,0,2));
  constraints.anchor=GridBagConstraints.WEST;
  constraints.fill=GridBagConstraints.VERTICAL;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.gridheight=1;
  constraints.weightx=0f;
  constraints.weighty=1f;
  this.add(statusLabel,constraints);
  constraints.anchor=GridBagConstraints.WEST;
  constraints.fill=GridBagConstraints.NONE;
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.weightx=1f;
  constraints.weighty=0f;
  constraints.gridheight=1;
  constraints.gridwidth=2;
  this.add(nameLabel,constraints);
  rightLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,2));
  constraints.anchor=GridBagConstraints.NORTHEAST;
  constraints.fill=GridBagConstraints.VERTICAL;
  constraints.gridx=3;
  constraints.gridy=0;
  constraints.gridheight=3;
  constraints.weightx=0f;
  constraints.weighty=1f;
  this.add(rightLabel,constraints);
  this.callButton.setName(CALL_BUTTON_NAME);
  this.chatButton.setName(CHAT_BUTTON_NAME);
  callButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (treeNode != null && treeNode instanceof ContactNode) {
        List<Contact> telephonyContacts=((ContactNode)treeNode).getMetaContact().getContactsForOperationSet(OperationSetBasicTelephony.class);
        if (telephonyContacts.size() == 1) {
          Contact contact=telephonyContacts.get(0);
          CallManager.createCall(telephonyContacts.get(0).getProtocolProvider(),contact);
        }
 else         if (telephonyContacts.size() > 1) {
          ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(tree,telephonyContacts);
          Point location=new Point(callButton.getX(),callButton.getY() + callButton.getHeight());
          SwingUtilities.convertPointToScreen(location,tree);
          location.y=location.y + tree.getPathBounds(tree.getSelectionPath()).y;
          chooseAccountDialog.showPopupMenu(location.x + 8,location.y - 8);
        }
      }
    }
  }
);
  chatButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (treeNode != null && treeNode instanceof ContactNode) {
        GuiActivator.getUIService().getChatWindowManager().startChat(((ContactNode)treeNode).getMetaContact());
      }
    }
  }
);
  this.setToolTipText(""String_Node_Str"");
}",0.9978381717109328
103697,"public void actionPerformed(ActionEvent e){
  if (!lastHasMatching)   CallManager.createCall(getText());
 else   GuiActivator.getContactList().startSelectedContactChat();
}","public void actionPerformed(ActionEvent e){
  setText(""String_Node_Str"");
  SearchField.this.mainFrame.requestFocusInCenterPanel();
}",0.4918032786885246
103698,"/** 
 * Creates the <tt>SearchField</tt>.
 * @param mainFrame the main application window
 */
public SearchField(MainFrame mainFrame){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=mainFrame;
  SearchTextFieldUI textFieldUI=new SearchTextFieldUI();
  textFieldUI.setDeleteButtonEnabled(true);
  this.setUI(textFieldUI);
  this.setBorder(null);
  this.setOpaque(false);
  this.setPreferredSize(new Dimension(100,22));
  this.setDragEnabled(true);
  this.getDocument().addDocumentListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_FOCUSED);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      SearchField.this.mainFrame.requestFocusInCenterPanel();
    }
  }
);
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (!lastHasMatching)       CallManager.createCall(getText());
 else       GuiActivator.getContactList().startSelectedContactChat();
    }
  }
);
}","/** 
 * Creates the <tt>SearchField</tt>.
 * @param frame the main application window
 */
public SearchField(MainFrame frame){
  super(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.mainFrame=frame;
  SearchTextFieldUI textFieldUI=new SearchTextFieldUI();
  textFieldUI.setDeleteButtonEnabled(true);
  this.setUI(textFieldUI);
  this.setBorder(null);
  this.setOpaque(false);
  this.setPreferredSize(new Dimension(100,22));
  this.setDragEnabled(true);
  this.getDocument().addDocumentListener(this);
  InputMap imap=getInputMap(JComponent.WHEN_FOCUSED);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  ActionMap amap=getActionMap();
  amap.put(""String_Node_Str"",new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      setText(""String_Node_Str"");
      SearchField.this.mainFrame.requestFocusInCenterPanel();
    }
  }
);
}",0.6573295985060691
103699,"/** 
 * Ends the registration of this protocol provider with the current registration service.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void unregister() throws OperationFailedException {
  if (getRegistrationState().equals(RegistrationState.UNREGISTERED) || getRegistrationState().equals(RegistrationState.UNREGISTERING)) {
    return;
  }
  sipRegistrarConnection.unregister();
  sipSecurityManager.setSecurityAuthority(null);
}","/** 
 * Ends the registration of this protocol provider with the current registration service.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void unregister() throws OperationFailedException {
  if (getRegistrationState().equals(RegistrationState.UNREGISTERED) || getRegistrationState().equals(RegistrationState.UNREGISTERING) || getRegistrationState().equals(RegistrationState.CONNECTION_FAILED)) {
    return;
  }
  sipRegistrarConnection.unregister();
  sipSecurityManager.setSecurityAuthority(null);
}",0.9412751677852348
103700,"/** 
 * Creates a media <tt>StreamConnector</tt>. The method takes into account the minimum and maximum media port boundaries.
 * @return a new <tt>StreamConnector</tt>.
 * @throws OperationFailedException if we fail binding the the sockets.
 */
private StreamConnector createStreamConnector() throws OperationFailedException {
  NetworkAddressManagerService nam=SipActivator.getNetworkAddressManagerService();
  InetAddress intendedDestination=peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress());
  InetAddress localHostForPeer=nam.getLocalHost(intendedDestination);
  initializePortNumbers();
  DatagramSocket rtpSocket=null;
  try {
    rtpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtpSocket.getLocalPort() + 1;
  DatagramSocket rtcpSocket=null;
  try {
    rtcpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtcpSocket.getLocalPort() + 1;
  DefaultStreamConnector connector=new DefaultStreamConnector(rtpSocket,rtcpSocket);
  return connector;
}","/** 
 * Creates a media <tt>StreamConnector</tt>. The method takes into account the minimum and maximum media port boundaries.
 * @return a new <tt>StreamConnector</tt>.
 * @throws OperationFailedException if we fail binding the the sockets.
 */
private StreamConnector createStreamConnector() throws OperationFailedException {
  NetworkAddressManagerService nam=SipActivator.getNetworkAddressManagerService();
  InetAddress intendedDestination=peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress());
  InetAddress localHostForPeer=nam.getLocalHost(intendedDestination);
  initializePortNumbers();
  DatagramSocket rtpSocket=null;
  try {
    rtpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtpSocket.getLocalPort() + 1;
  DatagramSocket rtcpSocket=null;
  try {
    rtcpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtcpSocket.getLocalPort() + 1;
  if (nextMediaPortToTry > maxMediaPort)   nextMediaPortToTry=minMediaPort;
  DefaultStreamConnector connector=new DefaultStreamConnector(rtpSocket,rtcpSocket);
  return connector;
}",0.974581939799331
103701,"/** 
 * Creates a media <tt>StreamConnector</tt>. The method takes into account the minimum and maximum media port boundaries.
 * @return a new <tt>StreamConnector</tt>.
 * @throws OperationFailedException if we fail binding the the sockets.
 */
private StreamConnector createStreamConnector() throws OperationFailedException {
  NetworkAddressManagerService nam=SipActivator.getNetworkAddressManagerService();
  InetAddress intendedDestination=peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress());
  InetAddress localHostForPeer=nam.getLocalHost(intendedDestination);
  initializePortNumbers();
  DatagramSocket rtpSocket=null;
  try {
    rtpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtpSocket.getLocalPort() + 1;
  DatagramSocket rtcpSocket=null;
  try {
    rtcpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtcpSocket.getLocalPort() + 1;
  if (nextMediaPortToTry > maxMediaPort)   nextMediaPortToTry=minMediaPort;
  DefaultStreamConnector connector=new DefaultStreamConnector(rtpSocket,rtcpSocket);
  return connector;
}","/** 
 * Creates a media <tt>StreamConnector</tt>. The method takes into account the minimum and maximum media port boundaries.
 * @return a new <tt>StreamConnector</tt>.
 * @throws OperationFailedException if we fail binding the the sockets.
 */
private StreamConnector createStreamConnector() throws OperationFailedException {
  NetworkAddressManagerService nam=SipActivator.getNetworkAddressManagerService();
  InetAddress intendedDestination=peer.getProtocolProvider().getIntendedDestination(peer.getPeerAddress());
  InetAddress localHostForPeer=nam.getLocalHost(intendedDestination);
  initializePortNumbers();
  DatagramSocket rtpSocket=null;
  try {
    rtpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtpSocket.getLocalPort() + 1;
  DatagramSocket rtcpSocket=null;
  try {
    rtcpSocket=nam.createDatagramSocket(localHostForPeer,nextMediaPortToTry,minMediaPort,maxMediaPort);
  }
 catch (  Exception exc) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc,logger);
  }
  nextMediaPortToTry=rtcpSocket.getLocalPort() + 1;
  if (nextMediaPortToTry > maxMediaPort - 1)   nextMediaPortToTry=minMediaPort;
  DefaultStreamConnector connector=new DefaultStreamConnector(rtpSocket,rtcpSocket);
  return connector;
}",0.9986970684039088
103702,"/** 
 * Initializes a new <tt>QuickTimeStream</tt> instance which is to have its <tt>Format</tt>-related information abstracted by a specific <tt>FormatControl</tt>.
 * @param formatControl the <tt>FormatControl</tt> which is to abstract the<tt>Format</tt>-related information of the new instance
 */
QuickTimeStream(FormatControl formatControl){
  super(formatControl);
  if (formatControl != null) {
    Format format=formatControl.getFormat();
    if (format != null)     setCaptureOutputFormat(format);
  }
  captureOutput.setAutomaticallyDropsLateVideoFrames(true);
  captureOutput.setDelegate(new QTCaptureDecompressedVideoOutput.Delegate(){
    /** 
 * Notifies this <tt>Delegate</tt> that the <tt>QTCaptureOutput</tt> to which it is set has output a specific <tt>CVImageBuffer</tt> representing a video frame with a specific <tt>QTSampleBuffer</tt>.
 * @param videoFrame the <tt>CVImageBuffer</tt> whichrepresents the output video frame
 * @param sampleBuffer the <tt>QTSampleBuffer</tt> whichrepresents additional details about the output video samples
 */
    public void outputVideoFrameWithSampleBuffer(    CVImageBuffer videoFrame,    QTSampleBuffer sampleBuffer){
      captureOutputDidOutputVideoFrameWithSampleBuffer(captureOutput,videoFrame,sampleBuffer);
    }
  }
);
}","/** 
 * Initializes a new <tt>QuickTimeStream</tt> instance which is to have its <tt>Format</tt>-related information abstracted by a specific <tt>FormatControl</tt>.
 * @param formatControl the <tt>FormatControl</tt> which is to abstract the<tt>Format</tt>-related information of the new instance
 */
QuickTimeStream(FormatControl formatControl){
  super(formatControl);
  if (formatControl != null) {
    Format format=formatControl.getFormat();
    if (format != null)     setCaptureOutputFormat(format);
  }
  automaticallyDropsLateVideoFrames=false;
  captureOutput.setDelegate(new QTCaptureDecompressedVideoOutput.Delegate(){
    /** 
 * Notifies this <tt>Delegate</tt> that the <tt>QTCaptureOutput</tt> to which it is set has output a specific <tt>CVImageBuffer</tt> representing a video frame with a specific <tt>QTSampleBuffer</tt>.
 * @param videoFrame the <tt>CVImageBuffer</tt> whichrepresents the output video frame
 * @param sampleBuffer the <tt>QTSampleBuffer</tt> whichrepresents additional details about the output video samples
 */
    public void outputVideoFrameWithSampleBuffer(    CVImageBuffer videoFrame,    QTSampleBuffer sampleBuffer){
      captureOutputDidOutputVideoFrameWithSampleBuffer(captureOutput,videoFrame,sampleBuffer);
    }
  }
);
}",0.9878764176769652
103703,"/** 
 * Reads media data from this <tt>PushBufferStream</tt> into a specific <tt>Buffer</tt> without blocking.
 * @param buffer the <tt>Buffer</tt> in which media data is to be read fromthis <tt>PushBufferStream</tt>
 * @throws IOException if anything goes wrong while reading media data fromthis <tt>PushBufferStream</tt> into the specified <tt>buffer</tt>
 */
public void read(Buffer buffer) throws IOException {
synchronized (dataSyncRoot) {
    if (data == null)     buffer.setLength(0);
 else {
      buffer.setData(data);
      buffer.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);
      if (dataFormat != null)       buffer.setFormat(dataFormat);
      buffer.setLength(data.length);
      buffer.setOffset(0);
      buffer.setTimeStamp(dataTimeStamp);
      data=null;
    }
  }
}","/** 
 * Reads media data from this <tt>PushBufferStream</tt> into a specific <tt>Buffer</tt> without blocking.
 * @param buffer the <tt>Buffer</tt> in which media data is to be read fromthis <tt>PushBufferStream</tt>
 * @throws IOException if anything goes wrong while reading media data fromthis <tt>PushBufferStream</tt> into the specified <tt>buffer</tt>
 */
public void read(Buffer buffer) throws IOException {
synchronized (dataSyncRoot) {
    if (data == null)     buffer.setLength(0);
 else {
      buffer.setData(data);
      buffer.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);
      if (dataFormat != null)       buffer.setFormat(dataFormat);
      buffer.setLength(data.length);
      buffer.setOffset(0);
      buffer.setTimeStamp(dataTimeStamp);
      data=null;
      if (!automaticallyDropsLateVideoFrames)       dataSyncRoot.notifyAll();
    }
  }
}",0.9535160905840286
103704,"/** 
 * Stops the transfer of media data from this <tt>PushBufferStream</tt>.
 * @throws IOException if anything goes wrong while stopping the transfer ofmedia data from this <tt>PushBufferStream</tt>
 */
@Override public void stop() throws IOException {
synchronized (dataSyncRoot) {
    data=null;
    dataFormat=null;
  }
}","/** 
 * Stops the transfer of media data from this <tt>PushBufferStream</tt>.
 * @throws IOException if anything goes wrong while stopping the transfer ofmedia data from this <tt>PushBufferStream</tt>
 */
@Override public void stop() throws IOException {
  transferDataThread=null;
synchronized (dataSyncRoot) {
    data=null;
    dataFormat=null;
    nextData=null;
    nextDataFormat=null;
    if (!automaticallyDropsLateVideoFrames)     dataSyncRoot.notifyAll();
  }
}",0.8180677540777918
103705,"/** 
 * Set the <tt>Format</tt> of the media data made available by this <tt>PushBufferStream</tt> to   {@link #captureOutput}.
 * @param format the <tt>Format</tt> of the media data made available bythis <tt>PushBufferStream</tt> to be set to  {@link #captureOutput}
 */
private void setCaptureOutputFormat(Format format){
  VideoFormat videoFormat=(VideoFormat)format;
  Dimension size=videoFormat.getSize();
  if (size == null)   size=new Dimension(DataSource.DEFAULT_WIDTH,DataSource.DEFAULT_HEIGHT);
  NSMutableDictionary pixelBufferAttributes=null;
  if (size != null) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(size.width,CVPixelBufferAttributeKey.kCVPixelBufferWidthKey);
    pixelBufferAttributes.setIntForKey(size.height,CVPixelBufferAttributeKey.kCVPixelBufferHeightKey);
  }
  if (format.isSameEncoding(VideoFormat.RGB)) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(CVPixelFormatType.kCVPixelFormatType_32ARGB,CVPixelBufferAttributeKey.kCVPixelBufferPixelFormatTypeKey);
  }
 else   if (format.isSameEncoding(VideoFormat.YUV)) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(CVPixelFormatType.kCVPixelFormatType_420YpCbCr8Planar,CVPixelBufferAttributeKey.kCVPixelBufferPixelFormatTypeKey);
  }
 else   throw new IllegalArgumentException(""String_Node_Str"");
  if (pixelBufferAttributes != null)   captureOutput.setPixelBufferAttributes(pixelBufferAttributes);
}","/** 
 * Set the <tt>Format</tt> of the media data made available by this <tt>PushBufferStream</tt> to   {@link #captureOutput}.
 * @param format the <tt>Format</tt> of the media data made available bythis <tt>PushBufferStream</tt> to be set to  {@link #captureOutput}
 */
private void setCaptureOutputFormat(Format format){
  VideoFormat videoFormat=(VideoFormat)format;
  Dimension size=videoFormat.getSize();
  int width;
  int height;
  if (size == null) {
    width=DataSource.DEFAULT_WIDTH;
    height=DataSource.DEFAULT_HEIGHT;
  }
 else {
    width=size.width;
    height=size.height;
  }
  NSMutableDictionary pixelBufferAttributes=null;
  if ((width > 0) && (height > 0)) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(width,CVPixelBufferAttributeKey.kCVPixelBufferWidthKey);
    pixelBufferAttributes.setIntForKey(height,CVPixelBufferAttributeKey.kCVPixelBufferHeightKey);
  }
  if (format.isSameEncoding(VideoFormat.RGB)) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(CVPixelFormatType.kCVPixelFormatType_32ARGB,CVPixelBufferAttributeKey.kCVPixelBufferPixelFormatTypeKey);
  }
 else   if (format.isSameEncoding(VideoFormat.YUV)) {
    if (pixelBufferAttributes == null)     pixelBufferAttributes=new NSMutableDictionary();
    pixelBufferAttributes.setIntForKey(CVPixelFormatType.kCVPixelFormatType_420YpCbCr8Planar,CVPixelBufferAttributeKey.kCVPixelBufferPixelFormatTypeKey);
  }
 else   throw new IllegalArgumentException(""String_Node_Str"");
  if (pixelBufferAttributes != null)   captureOutput.setPixelBufferAttributes(pixelBufferAttributes);
}",0.9453357100415924
103706,"/** 
 * Notifies this instance that its <tt>QTCaptureOutput</tt> has output a specific <tt>CVImageBuffer</tt> representing a video frame with a specific <tt>QTSampleBuffer</tt>.
 * @param captureOutput the <tt>QTCaptureOutput</tt> which has output avideo frame
 * @param videoFrame the <tt>CVImageBuffer</tt> which represents the outputvideo frame
 * @param sampleBuffer the <tt>QTSampleBuffer</tt> which representsadditional details about the output video samples
 */
private void captureOutputDidOutputVideoFrameWithSampleBuffer(QTCaptureOutput captureOutput,CVImageBuffer videoFrame,QTSampleBuffer sampleBuffer){
  CVPixelBuffer pixelBuffer=(CVPixelBuffer)videoFrame;
  boolean transferData;
synchronized (dataSyncRoot) {
    data=pixelBuffer.getBytes();
    dataTimeStamp=System.nanoTime();
    transferData=(data != null);
    if (dataFormat == null)     dataFormat=getVideoFrameFormat(pixelBuffer);
  }
  if (transferData) {
    BufferTransferHandler transferHandler=this.transferHandler;
    if (transferHandler != null)     transferHandler.transferData(this);
  }
}","/** 
 * Notifies this instance that its <tt>QTCaptureOutput</tt> has output a specific <tt>CVImageBuffer</tt> representing a video frame with a specific <tt>QTSampleBuffer</tt>.
 * @param captureOutput the <tt>QTCaptureOutput</tt> which has output avideo frame
 * @param videoFrame the <tt>CVImageBuffer</tt> which represents the outputvideo frame
 * @param sampleBuffer the <tt>QTSampleBuffer</tt> which representsadditional details about the output video samples
 */
private void captureOutputDidOutputVideoFrameWithSampleBuffer(QTCaptureOutput captureOutput,CVImageBuffer videoFrame,QTSampleBuffer sampleBuffer){
  CVPixelBuffer pixelBuffer=(CVPixelBuffer)videoFrame;
  boolean transferData;
synchronized (dataSyncRoot) {
    if (!automaticallyDropsLateVideoFrames && (data != null)) {
      nextData=pixelBuffer.getBytes();
      nextDataTimeStamp=System.nanoTime();
      if (nextDataFormat == null)       nextDataFormat=getVideoFrameFormat(pixelBuffer);
      return;
    }
    data=pixelBuffer.getBytes();
    dataTimeStamp=System.nanoTime();
    if (dataFormat == null)     dataFormat=getVideoFrameFormat(pixelBuffer);
    nextData=null;
    if (automaticallyDropsLateVideoFrames)     transferData=(data != null);
 else {
      transferData=false;
      dataSyncRoot.notifyAll();
    }
  }
  if (transferData) {
    BufferTransferHandler transferHandler=this.transferHandler;
    if (transferHandler != null)     transferHandler.transferData(this);
  }
}",0.780276134122288
103707,"/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.searchField=new SearchField(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new MainKeyDispatcher());
  this.init();
  this.initPluginComponents();
}","/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.searchField=new SearchField(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
    public void windowActivated(    WindowEvent event){
      ConfigurationManager.setApplicationVisible(true);
    }
    public void windowOpened(    WindowEvent event){
      ConfigurationManager.setApplicationVisible(true);
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new MainKeyDispatcher());
  this.init();
  this.initPluginComponents();
}",0.8897302413629911
103708,"public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || e.getID() != KeyEvent.KEY_PRESSED)   return false;
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner()) {
    String searchText=""String_Node_Str"";
    if (searchField.getText() != null)     searchText+=searchField.getText() + e.getKeyChar();
 else     searchText+=e.getKeyChar();
    searchField.setText(searchText);
    searchField.requestFocus();
    return true;
  }
  return false;
}","public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || e.getID() != KeyEvent.KEY_PRESSED)   return false;
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner()) {
    String searchText=""String_Node_Str"";
    if (searchField.getText() != null)     searchText+=searchField.getText() + e.getKeyChar();
 else     searchText+=e.getKeyChar();
    searchField.setText(searchText);
    searchField.requestFocus();
    return true;
  }
  return false;
}",0.9865861837692824
103709,"/** 
 * Creates an instance of <tt>NoAccountFoundPage</tt>.
 */
public InitialAccountRegistrationFrame(){
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout());
  JPanel messageAreaPanel=new JPanel(new FlowLayout(FlowLayout.CENTER));
  JTextArea messageArea=new JTextArea(Resources.getString(""String_Node_Str""));
  JPanel buttonPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
  JButton cancelButton=new JButton(Resources.getString(""String_Node_Str""));
  this.setTitle(Resources.getString(""String_Node_Str""));
  this.setIconImage(Resources.getImage(""String_Node_Str"").getImage());
  JOptionPane.getRootFrame().setIconImage(Resources.getImage(""String_Node_Str"").getImage());
  mainAccountsPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  this.getContentPane().add(mainPanel);
  mainPanel.add(messageAreaPanel,BorderLayout.NORTH);
  mainPanel.add(mainAccountsPanel,BorderLayout.CENTER);
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  messageAreaPanel.add(messageArea);
  messageArea.setPreferredSize(new Dimension(350,20));
  messageArea.setFont(messageArea.getFont().deriveFont(Font.BOLD));
  mainAccountsPanel.add(accountsPanel,BorderLayout.CENTER);
  mainAccountsPanel.setOpaque(false);
  accountsPanel.setOpaque(false);
  buttonPanel.setOpaque(false);
  messageAreaPanel.setOpaque(false);
  SigninActionListener actionListener=new SigninActionListener();
  signinButton.addActionListener(actionListener);
  cancelButton.addActionListener(actionListener);
  buttonPanel.add(signinButton);
  buttonPanel.add(cancelButton);
  messageArea.setLineWrap(true);
  messageArea.setWrapStyleWord(true);
  messageArea.setEditable(false);
  messageArea.setOpaque(false);
  this.getRootPane().setDefaultButton(signinButton);
  this.initAccountWizards();
  String groupName=Resources.getApplicationProperty(""String_Node_Str"");
  if (groupName != null && groupName.length() > 0) {
    MetaContactListService contactList=SimpleAccountRegistrationActivator.getContactList();
    Iterator<MetaContactGroup> iter=contactList.getRoot().getSubgroups();
    while (iter.hasNext()) {
      MetaContactGroup gr=iter.next();
      if (groupName.equals(gr.getGroupName()))       return;
    }
    contactList.createMetaContactGroup(contactList.getRoot(),groupName);
    getConfigurationService().setProperty(""String_Node_Str"",groupName);
  }
}","/** 
 * Creates an instance of <tt>NoAccountFoundPage</tt>.
 */
public InitialAccountRegistrationFrame(){
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JPanel buttonPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
  JButton cancelButton=new JButton(Resources.getString(""String_Node_Str""));
  this.setTitle(Resources.getString(""String_Node_Str""));
  this.setIconImage(Resources.getImage(""String_Node_Str"").getImage());
  JOptionPane.getRootFrame().setIconImage(Resources.getImage(""String_Node_Str"").getImage());
  mainAccountsPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  this.getContentPane().add(mainPanel);
  mainPanel.add(createTitleComponent(),BorderLayout.NORTH);
  mainPanel.add(mainAccountsPanel,BorderLayout.CENTER);
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  mainAccountsPanel.add(accountsPanel,BorderLayout.CENTER);
  mainAccountsPanel.setOpaque(false);
  accountsPanel.setOpaque(false);
  buttonPanel.setOpaque(false);
  SigninActionListener actionListener=new SigninActionListener();
  signinButton.addActionListener(actionListener);
  cancelButton.addActionListener(actionListener);
  buttonPanel.add(signinButton);
  buttonPanel.add(cancelButton);
  this.getRootPane().setDefaultButton(signinButton);
  this.initAccountWizards();
  String groupName=Resources.getApplicationProperty(""String_Node_Str"");
  if (groupName != null && groupName.length() > 0) {
    MetaContactListService contactList=SimpleAccountRegistrationActivator.getContactList();
    Iterator<MetaContactGroup> iter=contactList.getRoot().getSubgroups();
    while (iter.hasNext()) {
      MetaContactGroup gr=iter.next();
      if (groupName.equals(gr.getGroupName()))       return;
    }
    contactList.createMetaContactGroup(contactList.getRoot(),groupName);
    getConfigurationService().setProperty(""String_Node_Str"",groupName);
  }
}",0.8184923707583694
103710,"/** 
 * Handles a specific <tt>VideoEvent</tt> related to a specific visual <tt>Component</tt> depicting video knowing that it is to be displayed or is already displayed in a specific <tt>Container</tt>.
 * @param videoEvent the <tt>VideoEvent</tt> describing the visual<tt>Component</tt> which was added, removed or updated
 * @param videoContainer the <tt>Container</tt> which is to contain oralready contains the visual <tt>Component</tt> described by <tt>videoEvent</tt>
 */
private void handleVideoEvent(VideoEvent videoEvent,Container videoContainer){
  if (videoEvent != null) {
    if ((videoEvent.getOrigin() == VideoEvent.REMOTE) && (videoEvent instanceof SizeChangeVideoEvent)) {
      SizeChangeVideoEvent sizeChangeVideoEvent=(SizeChangeVideoEvent)videoEvent;
      Component visualComponent=sizeChangeVideoEvent.getVisualComponent();
      int width=sizeChangeVideoEvent.getWidth();
      int height=sizeChangeVideoEvent.getHeight();
      if (visualComponent.getParent() == null)       visualComponent.setPreferredSize(new Dimension(width,height));
 else       if (isAncestor(videoContainer,visualComponent))       ensureSize(visualComponent,width,height);
      return;
    }
switch (videoEvent.getType()) {
case VideoEvent.VIDEO_ADDED:
case VideoEvent.VIDEO_REMOVED:
      break;
default :
    return;
}
}
int zOrder=0;
videoContainer.removeAll();
if (localVideo != null) {
videoContainer.add(localVideo,VideoLayout.LOCAL,zOrder++);
if (!callDialog.isVideoButtonSelected()) callDialog.setVideoButtonSelected(true);
}
Component video=videoTelephony.getVisualComponent(callPeer);
if (video != null) videoContainer.add(video,VideoLayout.CENTER_REMOTE,zOrder++);
videoContainer.validate();
videoContainer.repaint();
}","/** 
 * Handles a specific <tt>VideoEvent</tt> related to a specific visual <tt>Component</tt> depicting video knowing that it is to be displayed or is already displayed in a specific <tt>Container</tt>.
 * @param videoEvent the <tt>VideoEvent</tt> describing the visual<tt>Component</tt> which was added, removed or updated
 * @param videoContainer the <tt>Container</tt> which is to contain oralready contains the visual <tt>Component</tt> described by <tt>videoEvent</tt>
 */
private void handleVideoEvent(VideoEvent videoEvent,Container videoContainer){
  if (videoEvent != null) {
    if ((videoEvent.getOrigin() == VideoEvent.REMOTE) && (videoEvent instanceof SizeChangeVideoEvent)) {
      SizeChangeVideoEvent sizeChangeVideoEvent=(SizeChangeVideoEvent)videoEvent;
      Component visualComponent=sizeChangeVideoEvent.getVisualComponent();
      int width=sizeChangeVideoEvent.getWidth();
      int height=sizeChangeVideoEvent.getHeight();
      if (visualComponent.getParent() == null)       visualComponent.setPreferredSize(new Dimension(width,height));
 else       if (isAncestor(videoContainer,visualComponent)) {
        ensureSize(visualComponent,width,height);
        videoContainer.doLayout();
      }
      return;
    }
switch (videoEvent.getType()) {
case VideoEvent.VIDEO_ADDED:
case VideoEvent.VIDEO_REMOVED:
      break;
default :
    return;
}
}
int zOrder=0;
videoContainer.removeAll();
if (localVideo != null) {
videoContainer.add(localVideo,VideoLayout.LOCAL,zOrder++);
if (!callDialog.isVideoButtonSelected()) callDialog.setVideoButtonSelected(true);
}
Component video=videoTelephony.getVisualComponent(callPeer);
if (video != null) videoContainer.add(video,VideoLayout.CENTER_REMOTE,zOrder++);
videoContainer.validate();
videoContainer.repaint();
}",0.986598232107214
103711,"/** 
 * Paints the MENU_BACKGROUND image on the background of this container.
 * @param g the Graphics object that does the painting
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  Image backgroundImage=ImageLoader.getImage(ImageLoader.MENU_BACKGROUND);
  g.drawImage(backgroundImage,0,0,getWidth(),getHeight(),null);
}","/** 
 * Paints the MENU_BACKGROUND image on the background of this container.
 * @param g the <tt>Graphics</tt> object that does the painting
 */
@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Image backgroundImage=ImageLoader.getImage(ImageLoader.MENU_BACKGROUND);
  g.drawImage(backgroundImage,0,0,getWidth(),getHeight(),this);
}",0.9618104667609618
103712,"/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null) {
        engine.setOwnSSRC(sendStream.getSSRC());
      }
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
catch (    UnsupportedFormatException ufe) {
      exception=ufe;
    }
    if (exception != null) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,exception);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}","/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
      ZRTPTransformEngine engine=zrtpControl.getZrtpEngine();
      if (engine != null)       engine.setOwnSSRC(sendStream.getSSRC());
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
catch (    UnsupportedFormatException ufe) {
      exception=ufe;
    }
    if (exception != null) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,exception);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
}",0.9974171330176496
103713,"/** 
 * Convert image bytes (scale/format).
 * @param dst destination image. Its type must be an array (int[], byte[] or short[])
 * @param dst_pix_fmt destination format
 * @param src source image. Its type must be an array (int[], byte[] or short[])
 * @param width original width
 * @param height original height
 * @param newWidth new width
 * @param newHeight new height
 */
public static native int img_convert(Object dst,int dst_pix_fmt,Object src,int pix_fmt,int width,int height,int newWidth,int newHeight);","/** 
 * Convert image bytes (scale/format).
 * @param dst destination image. Its type must be an array (int[], byte[] or short[])
 * @param dst_pix_fmt destination format
 * @param src source image. Its type must be an array (int[], byte[] or short[])
 * @param pix_fmt the format of <tt>src</tt>
 * @param width original width
 * @param height original height
 * @param newWidth new width
 * @param newHeight new height
 */
public static native int img_convert(Object dst,int dst_pix_fmt,Object src,int pix_fmt,int width,int height,int newWidth,int newHeight);",0.958217270194986
103714,"/** 
 * Sets output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null)   size=new Dimension(640,480);
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
  VideoFormat outputFormat=(VideoFormat)this.outputFormat;
  if (outputFormat != null)   setOutputFormat(new VideoFormat(outputFormat.getEncoding(),size,outputFormat.getMaxDataLength(),outputFormat.getDataType(),outputFormat.getFrameRate()).intersects(outputFormat));
}","/** 
 * Sets output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null)   size=new Dimension(640,480);
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
  VideoFormat outputFormat=(VideoFormat)getOutputFormat();
  if (outputFormat instanceof RGBFormat) {
    RGBFormat rgbOutputFormat=(RGBFormat)outputFormat;
    setOutputFormat(new RGBFormat(size,Format.NOT_SPECIFIED,outputFormat.getDataType(),outputFormat.getFrameRate(),rgbOutputFormat.getBitsPerPixel(),rgbOutputFormat.getRedMask(),rgbOutputFormat.getGreenMask(),rgbOutputFormat.getBlueMask(),rgbOutputFormat.getPixelStride(),size.width,rgbOutputFormat.getFlipped(),rgbOutputFormat.getEndian()));
  }
 else   if (outputFormat instanceof YUVFormat) {
    YUVFormat yuvOutputFormat=(YUVFormat)outputFormat;
    setOutputFormat(new YUVFormat(size,Format.NOT_SPECIFIED,outputFormat.getDataType(),outputFormat.getFrameRate(),yuvOutputFormat.getYuvType(),Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,0,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED));
  }
 else   if (outputFormat != null)   logger.warn(""String_Node_Str"" + outputFormat.getClass().getSimpleName() + ""String_Node_Str"");
}",0.6662542530157748
103715,"/** 
 * Sets the input format.
 * @param format format to set
 * @return format
 */
@Override public Format setInputFormat(Format format){
  VideoFormat videoFormat=(VideoFormat)format;
  if (videoFormat.getSize() == null)   return null;
  return super.setInputFormat(format);
}","/** 
 * Sets the input format.
 * @param format format to set
 * @return format
 */
@Override public Format setInputFormat(Format format){
  Format inputFormat=((format instanceof VideoFormat) && (((VideoFormat)format).getSize() == null)) ? null : super.setInputFormat(format);
  if (logger.isDebugEnabled() && (inputFormat != null))   logger.debug(""String_Node_Str"" + inputFormat);
  return inputFormat;
}",0.6023391812865497
103716,"/** 
 * Sets the <tt>Format</tt> in which this <tt>Codec</tt> is to output media data.
 * @param format the <tt>Format</tt> in which this <tt>Codec</tt> is tooutput media data
 * @return the <tt>Format</tt> in which this <tt>Codec</tt> is currentlyconfigured to output media data or <tt>null</tt> if <tt>format</tt> was found to be incompatible with this <tt>Codec</tt>
 */
@Override public Format setOutputFormat(Format format){
  Format outputFormat=super.setOutputFormat(format);
  if (logger.isDebugEnabled() && (outputFormat != null))   logger.debug(""String_Node_Str"" + ((VideoFormat)outputFormat).getSize());
  return outputFormat;
}","/** 
 * Sets the <tt>Format</tt> in which this <tt>Codec</tt> is to output media data.
 * @param format the <tt>Format</tt> in which this <tt>Codec</tt> is tooutput media data
 * @return the <tt>Format</tt> in which this <tt>Codec</tt> is currentlyconfigured to output media data or <tt>null</tt> if <tt>format</tt> was found to be incompatible with this <tt>Codec</tt>
 */
@Override public Format setOutputFormat(Format format){
  Format outputFormat=super.setOutputFormat(format);
  if (logger.isDebugEnabled() && (outputFormat != null))   logger.debug(""String_Node_Str"" + outputFormat);
  return outputFormat;
}",0.9608938547486032
103717,"/** 
 * Sets output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null)   size=new Dimension(640,480);
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
  VideoFormat outputFormat=(VideoFormat)getOutputFormat();
  if (outputFormat instanceof RGBFormat) {
    RGBFormat rgbOutputFormat=(RGBFormat)outputFormat;
    setOutputFormat(new RGBFormat(size,Format.NOT_SPECIFIED,outputFormat.getDataType(),outputFormat.getFrameRate(),rgbOutputFormat.getBitsPerPixel(),rgbOutputFormat.getRedMask(),rgbOutputFormat.getGreenMask(),rgbOutputFormat.getBlueMask(),rgbOutputFormat.getPixelStride(),size.width,rgbOutputFormat.getFlipped(),rgbOutputFormat.getEndian()));
  }
 else   if (outputFormat instanceof YUVFormat) {
    YUVFormat yuvOutputFormat=(YUVFormat)outputFormat;
    setOutputFormat(new YUVFormat(size,Format.NOT_SPECIFIED,outputFormat.getDataType(),outputFormat.getFrameRate(),yuvOutputFormat.getYuvType(),Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,0,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED));
  }
 else   if (outputFormat != null)   logger.warn(""String_Node_Str"" + outputFormat.getClass().getSimpleName() + ""String_Node_Str"");
}","/** 
 * Sets output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null)   size=new Dimension(640,480);
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
  VideoFormat outputFormat=(VideoFormat)getOutputFormat();
  if (outputFormat instanceof RGBFormat) {
    RGBFormat rgbOutputFormat=(RGBFormat)outputFormat;
    Class<?> dataType=outputFormat.getDataType();
    int bitsPerPixel=rgbOutputFormat.getBitsPerPixel();
    int pixelStride=rgbOutputFormat.getPixelStride();
    if ((pixelStride == Format.NOT_SPECIFIED) && (dataType != null) && (bitsPerPixel != Format.NOT_SPECIFIED))     pixelStride=dataType.equals(Format.byteArray) ? (bitsPerPixel / 8) : 1;
    setOutputFormat(new RGBFormat(size,Format.NOT_SPECIFIED,dataType,outputFormat.getFrameRate(),bitsPerPixel,rgbOutputFormat.getRedMask(),rgbOutputFormat.getGreenMask(),rgbOutputFormat.getBlueMask(),pixelStride,(pixelStride == Format.NOT_SPECIFIED) ? Format.NOT_SPECIFIED : (pixelStride * size.width),rgbOutputFormat.getFlipped(),rgbOutputFormat.getEndian()));
  }
 else   if (outputFormat instanceof YUVFormat) {
    YUVFormat yuvOutputFormat=(YUVFormat)outputFormat;
    setOutputFormat(new YUVFormat(size,Format.NOT_SPECIFIED,outputFormat.getDataType(),outputFormat.getFrameRate(),yuvOutputFormat.getYuvType(),Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,0,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED));
  }
 else   if (outputFormat != null)   logger.warn(""String_Node_Str"" + outputFormat.getClass().getSimpleName() + ""String_Node_Str"");
}",0.6711565257779842
103718,"/** 
 * Process (format conversion, rescale) a buffer.
 * @param input input buffer
 * @param output output buffer
 * @return BUFFER_PROCESSED_OK if buffer successfully processed
 */
@Override public int process(Buffer input,Buffer output){
  VideoFormat vinput=(VideoFormat)input.getFormat();
  VideoFormat voutput=(VideoFormat)output.getFormat();
  int inputWidth=(int)vinput.getSize().getWidth();
  int inputHeight=(int)vinput.getSize().getHeight();
  Object src=input.getData();
  Object dst=output.getData();
  int outputSize=0;
  int outputWidth=0;
  int outputHeight=0;
  int infmt=0;
  int outfmt=0;
  if (voutput == null) {
    voutput=(VideoFormat)outputFormat;
    return BUFFER_PROCESSED_FAILED;
  }
  outputWidth=(int)voutput.getSize().getWidth();
  outputHeight=(int)voutput.getSize().getHeight();
  if (!checkInputBuffer(input)) {
    return BUFFER_PROCESSED_FAILED;
  }
  if (isEOM(input)) {
    propagateEOM(output);
    return BUFFER_PROCESSED_OK;
  }
  if (voutput instanceof YUVFormat) {
    outputSize=(int)(outputWidth * outputHeight * 1.5);
    outfmt=FFMPEG.PIX_FMT_YUV420P;
  }
 else {
    RGBFormat rgb=(RGBFormat)voutput;
    outfmt=FFMPEG.PIX_FMT_RGB32;
    outputSize=(outputWidth * outputHeight * 4);
  }
  if (vinput instanceof YUVFormat) {
    infmt=FFMPEG.PIX_FMT_YUV420P;
  }
 else {
    RGBFormat rgb=(RGBFormat)vinput;
    infmt=getNativeRGBFormat(rgb);
  }
  if (voutput.getDataType() == Format.byteArray) {
    if (dst == null || ((byte[])dst).length < outputSize) {
      dst=new byte[outputSize];
    }
  }
 else   if (voutput.getDataType() == Format.intArray) {
    outputSize=(outputSize % 4) + outputSize / 4;
    if (dst == null || ((int[])dst).length < outputSize) {
      dst=new int[outputSize];
    }
  }
 else   if (voutput.getDataType() == Format.shortArray) {
    outputSize=(outputSize % 2) + outputSize / 2;
    if (dst == null || ((short[])dst).length < outputSize) {
      dst=new short[outputSize];
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    return BUFFER_PROCESSED_FAILED;
  }
synchronized (src) {
    FFMPEG.img_convert(dst,outfmt,src,infmt,inputWidth,inputHeight,outputWidth,outputHeight);
  }
  output.setData(dst);
  output.setLength(outputSize);
  output.setOffset(0);
  return BUFFER_PROCESSED_OK;
}","/** 
 * Processes (converts color space and/or scales) a buffer.
 * @param input input buffer
 * @param output output buffer
 * @return <tt>BUFFER_PROCESSED_OK</tt> if buffer has been successfullyprocessed
 */
@Override public int process(Buffer input,Buffer output){
  if (!checkInputBuffer(input))   return BUFFER_PROCESSED_FAILED;
  if (isEOM(input)) {
    propagateEOM(output);
    return BUFFER_PROCESSED_OK;
  }
  VideoFormat outputFormat=(VideoFormat)output.getFormat();
  if (outputFormat == null) {
    outputFormat=(VideoFormat)this.outputFormat;
    if (outputFormat == null)     return BUFFER_PROCESSED_FAILED;
  }
  int dstFmt;
  int dstLength;
  Dimension outputSize=outputFormat.getSize();
  int outputWidth=outputSize.width;
  int outputHeight=outputSize.height;
  if (outputFormat instanceof YUVFormat) {
    dstFmt=FFMPEG.PIX_FMT_YUV420P;
    dstLength=(int)(outputWidth * outputHeight * 1.5);
  }
 else {
    dstFmt=FFMPEG.PIX_FMT_RGB32;
    dstLength=(outputWidth * outputHeight * 4);
  }
  VideoFormat inputFormat=(VideoFormat)input.getFormat();
  int srcFmt;
  if (inputFormat instanceof YUVFormat)   srcFmt=FFMPEG.PIX_FMT_YUV420P;
 else   srcFmt=getNativeRGBFormat((RGBFormat)inputFormat);
  Class<?> outputDataType=outputFormat.getDataType();
  Object dst=output.getData();
  if (Format.byteArray.equals(outputDataType)) {
    if (dst == null || ((byte[])dst).length < dstLength)     dst=new byte[dstLength];
  }
 else   if (Format.intArray.equals(outputDataType)) {
    dstLength=(dstLength % 4) + dstLength / 4;
    if (dst == null || ((int[])dst).length < dstLength)     dst=new int[dstLength];
  }
 else   if (Format.shortArray.equals(outputDataType)) {
    dstLength=(dstLength % 2) + dstLength / 2;
    if (dst == null || ((short[])dst).length < dstLength)     dst=new short[dstLength];
  }
 else {
    logger.error(""String_Node_Str"" + outputDataType);
    return BUFFER_PROCESSED_FAILED;
  }
  Object src=input.getData();
synchronized (src) {
    Dimension inputSize=inputFormat.getSize();
    FFMPEG.img_convert(dst,dstFmt,src,srcFmt,inputSize.width,inputSize.height,outputWidth,outputHeight);
  }
  output.setData(dst);
  output.setLength(dstLength);
  output.setOffset(0);
  return BUFFER_PROCESSED_OK;
}",0.4847412649270234
103719,"/** 
 * Set output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null) {
    size=new Dimension(640,480);
  }
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
}","/** 
 * Sets output size.
 * @param size size to set
 */
public void setOutputSize(Dimension size){
  if (size == null)   size=new Dimension(640,480);
  supportedOutputFormats[0]=new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[1]=new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[2]=new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1);
  supportedOutputFormats[3]=new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[4]=new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[5]=new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1);
  supportedOutputFormats[6]=new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[7]=new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1);
  supportedOutputFormats[8]=new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1);
}",0.9954932398597895
103720,"/** 
 * Set the input format.
 * @param format format to set
 * @return format
 */
@Override public Format setInputFormat(Format format){
  final VideoFormat videoFormat=(VideoFormat)format;
  if (videoFormat.getSize() == null)   return null;
  format=super.setInputFormat(format);
  return format;
}","/** 
 * Sets the input format.
 * @param format format to set
 * @return format
 */
@Override public Format setInputFormat(Format format){
  VideoFormat videoFormat=(VideoFormat)format;
  if (videoFormat.getSize() == null)   return null;
  return super.setInputFormat(format);
}",0.9342560553633218
103721,"/** 
 * Get native (FFMPEG) RGB format.
 * @param rgb JMF <tt>RGBFormat</tt>
 * @return native RGB format
 */
public static int getNativeRGBFormat(RGBFormat rgb){
  int fmt=0;
  if (rgb.getBitsPerPixel() == 32) {
switch (rgb.getRedMask()) {
case 1:
case 0xff:
      fmt=FFMPEG.PIX_FMT_BGR32;
    break;
case 2:
case (0xff << 8):
  fmt=FFMPEG.PIX_FMT_BGR32_1;
break;
case 3:
case (0xff << 16):
fmt=FFMPEG.PIX_FMT_RGB32;
break;
case 4:
case (0xff << 24):
fmt=FFMPEG.PIX_FMT_RGB32_1;
break;
default :
fmt=FFMPEG.PIX_FMT_RGB32;
break;
}
}
 else {
fmt=FFMPEG.PIX_FMT_RGB24;
}
return fmt;
}","/** 
 * Gets native (FFMPEG) RGB format.
 * @param rgb JMF <tt>RGBFormat</tt>
 * @return native RGB format
 */
public static int getNativeRGBFormat(RGBFormat rgb){
  int fmt;
  if (rgb.getBitsPerPixel() == 32) switch (rgb.getRedMask()) {
case 1:
case 0xff:
    fmt=FFMPEG.PIX_FMT_BGR32;
  break;
case 2:
case (0xff << 8):
fmt=FFMPEG.PIX_FMT_BGR32_1;
break;
case 3:
case (0xff << 16):
fmt=FFMPEG.PIX_FMT_RGB32;
break;
case 4:
case (0xff << 24):
fmt=FFMPEG.PIX_FMT_RGB32_1;
break;
default :
fmt=FFMPEG.PIX_FMT_RGB32;
break;
}
 else fmt=FFMPEG.PIX_FMT_RGB24;
return fmt;
}",0.9644405897658282
103722,"/** 
 * Get the supported input formats.
 * @return array of supported input format
 */
@Override public Format[] getSupportedInputFormats(){
  return supportedInputFormats;
}","/** 
 * Gets the supported input formats.
 * @return array of supported input format
 */
@Override public Format[] getSupportedInputFormats(){
  return supportedInputFormats;
}",0.9971509971509972
103723,"/** 
 * Get the supported output formats for an input ones.
 * @param input input format to convert
 * @return array of supported output format
 */
@Override public Format[] getSupportedOutputFormats(Format input){
  Dimension size=null;
  if (input == null) {
    return supportedOutputFormats;
  }
  size=((VideoFormat)supportedOutputFormats[0]).getSize();
  if (size != null) {
    return supportedOutputFormats;
  }
  size=((VideoFormat)input).getSize();
  return new Format[]{new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1),new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1),new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1)};
}","/** 
 * Gets the supported output formats for an input one.
 * @param input input format to get supported output ones for
 * @return array of supported output formats
 */
@Override public Format[] getSupportedOutputFormats(Format input){
  if (input == null)   return supportedOutputFormats;
  Dimension size=((VideoFormat)supportedOutputFormats[0]).getSize();
  if (size != null)   return supportedOutputFormats;
  size=((VideoFormat)input).getSize();
  return new Format[]{new YUVFormat(size,-1,Format.byteArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new YUVFormat(size,-1,Format.intArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new YUVFormat(size,-1,Format.shortArray,-1.0f,YUVFormat.YUV_420,-1,-1,0,-1,-1),new RGBFormat(size,-1,Format.byteArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.intArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.shortArray,-1.0f,32,-1,-1,-1),new RGBFormat(size,-1,Format.byteArray,-1.0f,24,-1,-1,-1),new RGBFormat(size,-1,Format.intArray,-1.0f,24,-1,-1,-1),new RGBFormat(size,-1,Format.shortArray,-1.0f,24,-1,-1,-1)};
}",0.852304797742239
103724,"/** 
 * Creates an Msn group using the specified <tt>RosterGroup</tt> as a source. The newly created group will always return the name of the underlying RosterGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl update will only be done if source group is changed.
 * @param msnGroup the Msn Group correspoinding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupMsnImpl(MsnGroup msnGroup,MsnContact[] groupMembers,ServerStoredContactListMsnImpl ssclCallback,boolean isResolved){
  this.msnGroup=msnGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  for (int i=0; i < groupMembers.length; i++) {
    if (ssclCallback.findContactById(groupMembers[i].getEmail().getEmailAddress()) != null) {
      continue;
    }
    addContact(new ContactMsnImpl(groupMembers[i],ssclCallback,true,true));
  }
}","/** 
 * Creates an Msn group using the specified <tt>RosterGroup</tt> as a source. The newly created group will always return the name of the underlying RosterGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl update will only be done if source group is changed.
 * @param msnGroup the Msn Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupMsnImpl(MsnGroup msnGroup,MsnContact[] groupMembers,ServerStoredContactListMsnImpl ssclCallback,boolean isResolved){
  this.msnGroup=msnGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  for (  MsnContact groupMember : groupMembers) {
    if (ssclCallback.findContactById(groupMember.getEmail().getEmailAddress()) == null)     addContact(new ContactMsnImpl(groupMember,ssclCallback,true,true));
  }
}",0.9541132699462588
103725,"/** 
 * Returns the <tt>Contact</tt> with the specified address or identifier.
 * @param id the addres or identifier of the <tt>Contact</tt> we arelooking for.
 * @return the <tt>Contact</tt> with the specified id or address.
 */
public Contact getContact(String id){
  return this.findContact(id);
}","/** 
 * Returns the <tt>Contact</tt> with the specified address or identifier.
 * @param id the address or identifier of the <tt>Contact</tt> we arelooking for.
 * @return the <tt>Contact</tt> with the specified id or address.
 */
public Contact getContact(String id){
  return this.findContact(id);
}",0.9983361064891848
103726,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any members it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}",0.9984825493171472
103727,"public void newEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailNotifyMessage message,MsnContact contact){
  String messageFromAddr=message.getFromAddr();
  if ((messageFromAddr == null) || (messageFromAddr.indexOf('@') < 0)) {
    return;
  }
  String subject=message.getSubject();
  try {
    subject=MimeUtility.decodeText(subject);
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
  Message newMailMessage=new MessageMsnImpl(MessageFormat.format(MsnActivator.getResources().getI18NString(""String_Node_Str""),new Object[]{message.getFrom(),messageFromAddr,subject}),DEFAULT_MIME_TYPE,DEFAULT_MIME_ENCODING,subject);
  Contact sourceContact=opSetPersPresence.findContactByID(message.getFromAddr());
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + message.getFrom() + ""String_Node_Str""+ messageFromAddr+ ""String_Node_Str"");
    sourceContact=opSetPersPresence.createVolatileContact(contact);
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMailMessage,sourceContact,System.currentTimeMillis(),MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);
  fireMessageEvent(msgReceivedEvt);
}","public void newEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailNotifyMessage message,MsnContact contact){
  String messageFromAddr=message.getFromAddr();
  if ((messageFromAddr == null) || (messageFromAddr.indexOf('@') < 0))   return;
  String subject=message.getSubject();
  try {
    subject=MimeUtility.decodeText(subject);
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
  String messageFrom=message.getFrom();
  Message newMailMessage=new MessageMsnImpl(MessageFormat.format(MsnActivator.getResources().getI18NString(""String_Node_Str""),messageFrom,messageFromAddr,subject,""String_Node_Str""),HTML_MIME_TYPE,DEFAULT_MIME_ENCODING,subject);
  Contact sourceContact=opSetPersPresence.findContactByID(messageFromAddr);
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + messageFrom + ""String_Node_Str""+ messageFromAddr+ ""String_Node_Str"");
    String id=contact.getId();
    Email email=contact.getEmail();
    String displayName=contact.getDisplayName();
    if (id == null)     id=messageFromAddr;
    if (email == null)     email=Email.parseStr(messageFromAddr);
    if (displayName == null)     displayName=messageFrom;
    sourceContact=opSetPersPresence.createVolatileContact(id,email,displayName);
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMailMessage,sourceContact,System.currentTimeMillis(),MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);
  fireMessageEvent(msgReceivedEvt);
}",0.7762104460541365
103728,"/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. The volatile contact would remain in the list until it is really added to the contact list or until the application is terminated.
 * @param contact the msn contact.
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
public ContactMsnImpl createVolatileContact(MsnContact contact){
  return ssContactList.createVolatileContact(contact);
}","/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. The volatile contact would remain in the list until it is really added to the contact list or until the application is terminated.
 * @param id the id of the MSN contact
 * @param email the e-mail address of the MSN contact
 * @param displayName the display name of the MSN contact
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
public ContactMsnImpl createVolatileContact(String id,Email email,String displayName){
  return ssContactList.createVolatileContact(id,email,displayName);
}",0.7993553585817889
103729,"/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param contact the address of the contact to create.
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
ContactMsnImpl createVolatileContact(MsnContact contact){
  VolatileContact volatileBuddy=new VolatileContact(contact.getId(),contact.getEmail(),contact.getDisplayName());
  ContactMsnImpl newVolatileContact=new ContactMsnImpl(volatileBuddy,this,false,false);
  ContactGroupMsnImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    MsnContact[] emptyBuddies=new MsnContact[]{};
    theVolatileGroup=new ContactGroupMsnImpl(new VolatileGroup(),emptyBuddies,this,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}","/** 
 * Creates a non persistent contact for the specified address. This would also create (if necessary) a group for volatile contacts that would not be added to the server stored contact list. This method would have no effect on the server stored contact list.
 * @param id the id of the contact to create
 * @param email the e-mail address of the contact to create
 * @param displayName the display name of the contact to create
 * @return the newly created volatile <tt>ContactImpl</tt>
 */
ContactMsnImpl createVolatileContact(String id,Email email,String displayName){
  VolatileContact volatileBuddy=new VolatileContact(id,email,displayName);
  ContactMsnImpl newVolatileContact=new ContactMsnImpl(volatileBuddy,this,false,false);
  ContactGroupMsnImpl theVolatileGroup=getNonPersistentGroup();
  if (theVolatileGroup == null) {
    MsnContact[] emptyBuddies=new MsnContact[]{};
    theVolatileGroup=new ContactGroupMsnImpl(new VolatileGroup(),emptyBuddies,this,false);
    theVolatileGroup.addContact(newVolatileContact);
    this.rootGroup.addSubGroup(theVolatileGroup);
    fireGroupEvent(theVolatileGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    theVolatileGroup.addContact(newVolatileContact);
    fireContactAdded(theVolatileGroup,newVolatileContact);
  }
  return newVolatileContact;
}",0.8756884343036979
103730,"/** 
 * Installs Dummy TrustManager will not try to validate self-signed certs. Fix some problems with not proper use of certs.
 */
private static void removeDownloadRestrictions(){
  try {
    SSLContext sc=SSLContext.getInstance(""String_Node_Str"");
    TrustManager[] tma={new DummyTrustManager()};
    sc.init(null,tma,null);
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
  HostnameVerifier hv=new HostnameVerifier(){
    public boolean verify(    String urlHostName,    SSLSession session){
      logger.warn(""String_Node_Str"" + urlHostName + ""String_Node_Str""+ session.getPeerHost());
      return true;
    }
  }
;
  HttpsURLConnection.setDefaultHostnameVerifier(hv);
  Authenticator.setDefault(new Authenticator(){
    protected PasswordAuthentication getPasswordAuthentication(){
      String uName=(String)getConfigurationService().getProperty(UPDATE_USERNAME_CONFIG);
      if (uName != null) {
        String pass=(String)getConfigurationService().getProperty(UPDATE_PASSWORD_CONFIG);
        if (pass != null)         return new PasswordAuthentication(uName,new String(Base64.decode(pass)).toCharArray());
      }
      if (userCredentials != null) {
        return new PasswordAuthentication(userCredentials.getUserName(),userCredentials.getPassword());
      }
 else {
        return null;
      }
    }
  }
);
}","/** 
 * Installs Dummy TrustManager will not try to validate self-signed certs. Fix some problems with not proper use of certs.
 */
private static void removeDownloadRestrictions(){
  try {
    SSLContext sc=SSLContext.getInstance(""String_Node_Str"");
    TrustManager[] tma={new DummyTrustManager()};
    sc.init(null,tma,null);
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
  HostnameVerifier hv=new HostnameVerifier(){
    public boolean verify(    String urlHostName,    SSLSession session){
      logger.warn(""String_Node_Str"" + urlHostName + ""String_Node_Str""+ session.getPeerHost());
      return true;
    }
  }
;
  HttpsURLConnection.setDefaultHostnameVerifier(hv);
  Authenticator.setDefault(new Authenticator(){
    protected PasswordAuthentication getPasswordAuthentication(){
      ConfigurationService config=getConfigurationService();
      String uName=(String)config.getProperty(UPDATE_USERNAME_CONFIG);
      if (uName != null) {
        String pass=(String)config.getProperty(UPDATE_PASSWORD_CONFIG);
        if (pass != null)         return new PasswordAuthentication(uName,new String(Base64.decode(pass)).toCharArray());
      }
      if (userCredentials != null) {
        return new PasswordAuthentication(userCredentials.getUserName(),userCredentials.getPassword());
      }
 else {
        return null;
      }
    }
  }
);
}",0.9571876087713193
103731,"protected PasswordAuthentication getPasswordAuthentication(){
  String uName=(String)getConfigurationService().getProperty(UPDATE_USERNAME_CONFIG);
  if (uName != null) {
    String pass=(String)getConfigurationService().getProperty(UPDATE_PASSWORD_CONFIG);
    if (pass != null)     return new PasswordAuthentication(uName,new String(Base64.decode(pass)).toCharArray());
  }
  if (userCredentials != null) {
    return new PasswordAuthentication(userCredentials.getUserName(),userCredentials.getPassword());
  }
 else {
    return null;
  }
}","protected PasswordAuthentication getPasswordAuthentication(){
  ConfigurationService config=getConfigurationService();
  String uName=(String)config.getProperty(UPDATE_USERNAME_CONFIG);
  if (uName != null) {
    String pass=(String)config.getProperty(UPDATE_PASSWORD_CONFIG);
    if (pass != null)     return new PasswordAuthentication(uName,new String(Base64.decode(pass)).toCharArray());
  }
  if (userCredentials != null) {
    return new PasswordAuthentication(userCredentials.getUserName(),userCredentials.getPassword());
  }
 else {
    return null;
  }
}",0.8923076923076924
103732,"/** 
 * Creates a <tt>MessageReceivedEvent</tt> representing reception of the <tt>source</tt> message received from the specified <tt>from</tt> contact.
 * @param source the <tt>Message</tt> whose reception this event represents.
 * @param from the <tt>Contact</tt> that has sent this message.
 * @param timestamp the exact date when the event ocurred.
 * @param eventType the type of message event that this instance represents(one of the XXX_MESSAGE_RECEIVED static fields). 
 */
public MessageReceivedEvent(Message source,Contact from,long timestamp,int eventType){
  super(source);
  this.from=from;
  this.timestamp=timestamp;
  this.eventType=eventType;
}","/** 
 * Creates a <tt>MessageReceivedEvent</tt> representing reception of the <tt>source</tt> message received from the specified <tt>from</tt> contact.
 * @param source the <tt>Message</tt> whose reception this event represents.
 * @param from the <tt>Contact</tt> that has sent this message.
 * @param timestamp the exact date when the event occurred.
 * @param eventType the type of message event that this instance represents(one of the XXX_MESSAGE_RECEIVED static fields). 
 */
public MessageReceivedEvent(Message source,Contact from,long timestamp,int eventType){
  super(source);
  this.from=from;
  this.timestamp=timestamp;
  this.eventType=eventType;
}",0.999244142101285
103733,"public void actionPerformed(ActionEvent e){
  String searchText=parentWindow.getCurrentSearchText();
  if (searchText == null)   return;
  Vector<ProtocolProviderService> telephonyProviders=CallManager.getTelephonyProviders();
  ProtocolProviderService callProvider=null;
  if (telephonyProviders.size() == 1) {
    CallManager.createCall(callProvider,searchText);
  }
 else   if (telephonyProviders.size() > 1) {
    ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(callContact,searchText,telephonyProviders);
    chooseAccountDialog.showPopupMenu();
  }
}","public void actionPerformed(ActionEvent e){
  String searchText=parentWindow.getCurrentSearchText();
  if (searchText == null)   return;
  Vector<ProtocolProviderService> telephonyProviders=CallManager.getTelephonyProviders();
  if (telephonyProviders.size() == 1) {
    CallManager.createCall(telephonyProviders.get(0),searchText);
  }
 else   if (telephonyProviders.size() > 1) {
    ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(callContact,searchText,telephonyProviders);
    chooseAccountDialog.showPopupMenu();
  }
}",0.5157894736842106
103734,"/** 
 * Creates the <tt>UnknownContactPanel</tt> by specifying the parent window.
 * @param window the parent window
 */
public UnknownContactPanel(MainFrame window){
  this.parentWindow=window;
  this.setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  addContact.setAlignmentX(JButton.CENTER_ALIGNMENT);
  callContact.setAlignmentX(JButton.CENTER_ALIGNMENT);
  addContact.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  callContact.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.add(addContact);
  this.add(callContact);
  addContact.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      AddContactWizard wizard=new AddContactWizard(parentWindow,parentWindow.getCurrentSearchText());
      wizard.showDialog(false);
    }
  }
);
  callContact.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String searchText=parentWindow.getCurrentSearchText();
      if (searchText == null)       return;
      Vector<ProtocolProviderService> telephonyProviders=CallManager.getTelephonyProviders();
      ProtocolProviderService callProvider=null;
      if (telephonyProviders.size() == 1) {
        CallManager.createCall(callProvider,searchText);
      }
 else       if (telephonyProviders.size() > 1) {
        ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(callContact,searchText,telephonyProviders);
        chooseAccountDialog.showPopupMenu();
      }
    }
  }
);
}","/** 
 * Creates the <tt>UnknownContactPanel</tt> by specifying the parent window.
 * @param window the parent window
 */
public UnknownContactPanel(MainFrame window){
  this.parentWindow=window;
  this.setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  addContact.setAlignmentX(JButton.CENTER_ALIGNMENT);
  callContact.setAlignmentX(JButton.CENTER_ALIGNMENT);
  addContact.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  callContact.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.add(addContact);
  this.add(callContact);
  addContact.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      AddContactWizard wizard=new AddContactWizard(parentWindow,parentWindow.getCurrentSearchText());
      wizard.showDialog(false);
    }
  }
);
  callContact.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String searchText=parentWindow.getCurrentSearchText();
      if (searchText == null)       return;
      Vector<ProtocolProviderService> telephonyProviders=CallManager.getTelephonyProviders();
      if (telephonyProviders.size() == 1) {
        CallManager.createCall(telephonyProviders.get(0),searchText);
      }
 else       if (telephonyProviders.size() > 1) {
        ChooseCallAccountPopupMenu chooseAccountDialog=new ChooseCallAccountPopupMenu(callContact,searchText,telephonyProviders);
        chooseAccountDialog.showPopupMenu();
      }
    }
  }
);
}",0.8643183300717547
103735,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return Returns the identifier of the previous page of the wizard.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous page of the wizard
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7646017699115044
103736,"public Object getIdentifier(){
  return IDENTIFIER;
}","/** 
 * Returns the identifier of this wizard page.
 * @return the identifier of this wizard page
 */
public Object getIdentifier(){
  return IDENTIFIER;
}",0.5096153846153846
103737,"public Object getBackPageIdentifier(){
  return IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page.
 */
public Object getBackPageIdentifier(){
  return null;
}",0.3026706231454006
103738,"public Object getWizardForm(){
  return selectAccountPanel;
}","/** 
 * Returns the graphical component corresponding to this wizard page.
 * @return the graphical component corresponding to this wizard page
 */
public Object getWizardForm(){
  return selectAccountPanel;
}",0.4518518518518518
103739,"public void commitPage(){
  selectAccountPanel.initSelectedAccount();
}","/** 
 * Commits all data from the form before going to the next page.
 */
public void commitPage(){
  selectAccountPanel.initSelectedAccount();
}",0.6574074074074074
103740,"/** 
 * Creates an instance of <tt>AddContactWizardPage1</tt>.
 * @param newContact An object that collects all user choices through thewizard.
 * @param providerList The list of available<tt>ProtocolProviderServices</tt>, from which the user could select.
 */
public AddContactWizardPage1(WizardContainer wizard,NewContact newContact,Iterator<ProtocolProviderService> providerList){
  this.wizard=wizard;
  selectAccountPanel=new SelectAccountPanel(newContact,providerList);
  selectAccountPanel.addListSelectionListener(this);
}","/** 
 * Creates an instance of <tt>AddContactWizardPage1</tt>.
 * @param wizard the parent wizard
 * @param newContact An object that collects all user choices through thewizard.
 * @param providerList The list of available<tt>ProtocolProviderServices</tt>, from which the user could select.
 */
public AddContactWizardPage1(WizardContainer wizard,NewContact newContact,Iterator<ProtocolProviderService> providerList){
  this.wizard=wizard;
  selectAccountPanel=new SelectAccountPanel(newContact,providerList);
  selectAccountPanel.addListSelectionListener(this);
}",0.9680365296803652
103741,"public Object getNextPageIdentifier(){
  return AddContactWizardPage2.IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getNextPageIdentifier</code> to return the next identifier.
 * @return the identifier of the next wizard page.
 */
public Object getNextPageIdentifier(){
  return AddContactWizardPage2.IDENTIFIER;
}",0.5171339563862928
103742,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier, which is null as this is the first wizard page.
 * @return the identifier of the previous page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6852248394004282
103743,"/** 
 * Implements the <code>WizardPage.getNextPageIdentifier</code> to return the next page identifier - the summary page.
 */
public Object getNextPageIdentifier(){
  return nextPageIdentifier;
}","/** 
 * Implements the <code>WizardPage.getNextPageIdentifier</code> to return the next identifier - the summary page.
 */
public Object getNextPageIdentifier(){
  return nextPageIdentifier;
}",0.987146529562982
103744,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return Returns the identifier of the previous page of the wizard.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier, which is null as this is the first wizard page.
 * @return the identifier of the previous page of the wizard.
 */
public Object getBackPageIdentifier(){
  return null;
}",0.8043478260869565
103745,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page.
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7624309392265194
103746,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page.
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7624309392265194
103747,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the id of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the id of the previous wizard page.
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7552182163187856
103748,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6352459016393442
103749,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the back page identifier
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6526717557251909
103750,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7416974169741697
103751,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the id of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6928838951310862
103752,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6352459016393442
103753,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7416974169741697
103754,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6352459016393442
103755,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7416974169741697
103756,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.6352459016393442
103757,"/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the next back identifier - the default page.
 * @return the identifier of the default wizard page.
 */
public Object getBackPageIdentifier(){
  return WizardPage.DEFAULT_PAGE_IDENTIFIER;
}","/** 
 * Implements the <code>WizardPage.getBackPageIdentifier</code> to return the back identifier. In this case it's null because this is the first wizard page.
 * @return the identifier of the previous wizard page
 */
public Object getBackPageIdentifier(){
  return null;
}",0.7416974169741697
103758,"/** 
 * Requests the focus in the write message area.
 */
public void requestFocusInWriteArea(){
  getChatWritePanel().getEditorPane().requestFocusInWindow();
}","/** 
 * Requests the focus in the write message area.
 */
public void requestFocusInWriteArea(){
  getChatWritePanel().getEditorPane().requestFocus();
}",0.9743589743589745
103759,"/** 
 * Implements the <tt>ListCellRenderer</tt> method. Returns this panel that has been configured to display a chat contact.
 * @param list the source list
 * @param value the value of the current cell
 * @param index the index of the current cell in the source list
 * @param isSelected indicates if this cell is selected
 * @param cellHasFocus indicates if this cell is focused
 * @return this panel
 */
@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.index=index;
  this.rightLabel.setIcon(null);
  final ChatContact chatContact=(ChatContact)value;
  ChatRoomMember member=null;
  if (chatContact.getDescriptor() instanceof ChatRoomMember)   member=(ChatRoomMember)chatContact.getDescriptor();
  this.setPreferredSize(new Dimension(20,30));
  String displayName=chatContact.getName();
  if (displayName == null || displayName.length() < 1) {
    displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  }
  this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
  this.nameLabel.setText(displayName);
  if (member != null)   if (member.getRole() != null)   this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(member.getRole()));
  if (contactForegroundColor != null)   this.nameLabel.setForeground(contactForegroundColor);
  this.setBorder(BorderFactory.createEmptyBorder(1,5,1,1));
  ImageIcon avatar=chatContact.getAvatar();
  if (avatar != null)   this.rightLabel.setIcon(avatar);
 else   if (member != null) {
    if (chatContact.getName().equals(member.getChatRoom().getUserNickname())) {
      OperationSetServerStoredAccountInfo opSet=member.getChatRoom().getParentProvider().getOperationSet(OperationSetServerStoredAccountInfo.class);
      Iterator<GenericDetail> itr=opSet.getAllAvailableDetails();
      while (itr.hasNext()) {
        GenericDetail detail=itr.next();
        if (detail instanceof BinaryDetail) {
          BinaryDetail bin=(BinaryDetail)detail;
          if (bin.getBytes() != null)           this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(bin.getBytes(),25,25));
          break;
        }
      }
      ChatRoomMemberRole role=member.getChatRoom().getUserRole();
      if (role != null)       this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(role));
    }
 else {
      OperationSetPersistentPresence opSet=member.getChatRoom().getParentProvider().getOperationSet(OperationSetPersistentPresence.class);
      Contact c=opSet.findContactByID(member.getContactAddress());
      if (opSet != null && c != null && c.getImage() != null)       this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(c.getImage(),25,25));
    }
  }
  this.setBounds(0,0,list.getWidth() - 2,30);
  this.nameLabel.setBounds(0,0,list.getWidth() - 28,17);
  this.rightLabel.setBounds(list.getWidth() - 28,0,25,30);
  this.isLeaf=true;
  this.isSelected=isSelected;
  return this;
}","/** 
 * Implements the <tt>ListCellRenderer</tt> method. Returns this panel that has been configured to display a chat contact.
 * @param list the source list
 * @param value the value of the current cell
 * @param index the index of the current cell in the source list
 * @param isSelected indicates if this cell is selected
 * @param cellHasFocus indicates if this cell is focused
 * @return this panel
 */
@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.index=index;
  this.rightLabel.setIcon(null);
  final ChatContact chatContact=(ChatContact)value;
  ChatRoomMember member=null;
  if (chatContact.getDescriptor() instanceof ChatRoomMember)   member=(ChatRoomMember)chatContact.getDescriptor();
  this.setPreferredSize(new Dimension(20,30));
  String displayName=chatContact.getName();
  if (displayName == null || displayName.length() < 1) {
    displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  }
  this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
  this.nameLabel.setText(displayName);
  if (member != null) {
    ChatRoomMemberRole memberRole=member.getRole();
    if (memberRole != null)     this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(memberRole));
  }
  if (contactForegroundColor != null)   this.nameLabel.setForeground(contactForegroundColor);
  this.setBorder(BorderFactory.createEmptyBorder(1,5,1,1));
  ImageIcon avatar=chatContact.getAvatar();
  if (avatar != null)   this.rightLabel.setIcon(avatar);
 else   if (member != null) {
    ChatRoom memberChatRoom=member.getChatRoom();
    ProtocolProviderService protocolProvider=memberChatRoom.getParentProvider();
    if (chatContact.getName().equals(memberChatRoom.getUserNickname())) {
      OperationSetServerStoredAccountInfo opSet=protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
      if (opSet != null) {
        Iterator<GenericDetail> itr=opSet.getAllAvailableDetails();
        while (itr.hasNext()) {
          GenericDetail detail=itr.next();
          if (detail instanceof BinaryDetail) {
            BinaryDetail bin=(BinaryDetail)detail;
            byte[] binBytes=bin.getBytes();
            if (binBytes != null)             this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(binBytes,25,25));
            break;
          }
        }
      }
      ChatRoomMemberRole role;
      try {
        role=memberChatRoom.getUserRole();
      }
 catch (      UnsupportedOperationException uoex) {
        role=member.getRole();
      }
      if (role != null)       this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(role));
    }
 else {
      OperationSetPersistentPresence opSet=protocolProvider.getOperationSet(OperationSetPersistentPresence.class);
      if (opSet != null) {
        Contact c=opSet.findContactByID(member.getContactAddress());
        if (c != null) {
          byte[] cImage=c.getImage();
          if (cImage != null)           this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(cImage,25,25));
        }
      }
    }
  }
  this.setBounds(0,0,list.getWidth() - 2,30);
  this.nameLabel.setBounds(0,0,list.getWidth() - 28,17);
  this.rightLabel.setBounds(list.getWidth() - 28,0,25,30);
  this.isLeaf=true;
  this.isSelected=isSelected;
  return this;
}",0.8172386272944933
103760,"/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=contact.getDisplayName();
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}","/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (getParentGroupModLock()) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    defaultContact=null;
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=contact.getDisplayName();
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}",0.9844236760124612
103761,"/** 
 * Creates the corresponding <tt>MetaContactPropertyChangeEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a MetaContact has been modified.
 * @param event the event to dispatch.
 */
void fireMetaContactEvent(MetaContactPropertyChangeEvent event){
  logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (event instanceof MetaContactMovedEvent) {
      listener.metaContactMoved((MetaContactMovedEvent)event);
    }
 else     if (event instanceof MetaContactRenamedEvent) {
      listener.metaContactRenamed((MetaContactRenamedEvent)event);
    }
 else     if (event instanceof MetaContactModifiedEvent) {
      listener.metaContactModified((MetaContactModifiedEvent)event);
    }
  }
}","/** 
 * Creates the corresponding <tt>MetaContactPropertyChangeEvent</tt> instance and notifies all <tt>MetaContactListListener</tt>s that a MetaContact has been modified.
 * @param event the event to dispatch.
 */
void fireMetaContactEvent(MetaContactPropertyChangeEvent event){
  logger.trace(""String_Node_Str"" + event);
  for (  MetaContactListListener listener : getMetaContactListListeners()) {
    if (event instanceof MetaContactMovedEvent) {
      listener.metaContactMoved((MetaContactMovedEvent)event);
    }
 else     if (event instanceof MetaContactRenamedEvent) {
      listener.metaContactRenamed((MetaContactRenamedEvent)event);
    }
 else     if (event instanceof MetaContactModifiedEvent) {
      listener.metaContactModified((MetaContactModifiedEvent)event);
    }
 else     if (event instanceof MetaContactAvatarUpdateEvent) {
      listener.metaContactAvatarUpdated((MetaContactAvatarUpdateEvent)event);
    }
  }
}",0.9147826086956522
103762,"/** 
 * Sets the avatar for <tt>metaContact</tt> to be <tt>newAvatar</tt>. <p>
 * @param metaContact the <tt>MetaContact</tt> that change avatar 
 * @param protoContact the <tt>Contact> that change avatar
 * @param newAvatar avatar image bytes
 * @throws IllegalArgumentException if <tt>metaContact</tt> is not aninstance that belongs to the underlying implementation.
 */
public void changeMetaContactAvatar(MetaContact metaContact,Contact protoContact,byte[] newAvatar) throws IllegalArgumentException {
  if (!(metaContact instanceof MetaContactImpl)) {
    throw new IllegalArgumentException(metaContact + ""String_Node_Str"");
  }
  byte[] oldAvatar=metaContact.getAvatar(true);
  ((MetaContactImpl)metaContact).cacheAvatar(protoContact,newAvatar);
  fireMetaContactEvent(new MetaContactAvatarUpdate(metaContact,oldAvatar,newAvatar));
}","/** 
 * Sets the avatar for <tt>metaContact</tt> to be <tt>newAvatar</tt>. <p>
 * @param metaContact the <tt>MetaContact</tt> that change avatar 
 * @param protoContact the <tt>Contact> that change avatar
 * @param newAvatar avatar image bytes
 * @throws IllegalArgumentException if <tt>metaContact</tt> is not aninstance that belongs to the underlying implementation.
 */
public void changeMetaContactAvatar(MetaContact metaContact,Contact protoContact,byte[] newAvatar) throws IllegalArgumentException {
  if (!(metaContact instanceof MetaContactImpl)) {
    throw new IllegalArgumentException(metaContact + ""String_Node_Str"");
  }
  byte[] oldAvatar=metaContact.getAvatar(true);
  ((MetaContactImpl)metaContact).cacheAvatar(protoContact,newAvatar);
  fireMetaContactEvent(new MetaContactAvatarUpdateEvent(metaContact,oldAvatar,newAvatar));
}",0.9970291146761736
103763,"/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (value instanceof ContactNode) {
    MetaContact metaContact=((ContactNode)value).getMetaContact();
    String displayName=metaContact.getDisplayName();
    if (displayName == null || displayName.length() < 1) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isMetaContactActive(metaContact)) {
      statusIcon.setImage(msgReceivedImage);
    }
 else {
      statusIcon.setImage(Constants.getStatusIcon(contactList.getMetaContactStatus(metaContact)));
    }
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     this.nameLabel.setForeground(contactForegroundColor);
    this.initStatusMessage(metaContact);
    this.initButtonsPanel(metaContact);
    ImageIcon avatar=getAvatar(metaContact);
    if (avatar != null)     this.rightLabel.setIcon(avatar);
    this.rightLabel.setText(""String_Node_Str"");
    this.setToolTipText(metaContact.getMetaUID());
  }
 else   if (value instanceof GroupNode) {
    MetaContactGroup groupItem=((GroupNode)value).getMetaContactGroup();
    this.nameLabel.setText(groupItem.getGroupName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(statusMessageLabel);
    this.remove(callButton);
    this.remove(chatButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    this.setToolTipText(groupItem.getMetaUID());
  }
  return this;
}","/** 
 * Returns this panel that has been configured to display the meta contact and meta contact group cells.
 * @param tree the source tree
 * @param value the tree node
 * @param selected indicates if the node is selected
 * @param expanded indicates if the node is expanded
 * @param leaf indicates if the node is a leaf
 * @param row indicates the row number of the node
 * @param hasFocus indicates if the node has the focus
 * @return this panel
 */
public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  this.tree=tree;
  this.row=row;
  this.isSelected=selected;
  this.treeNode=(TreeNode)value;
  this.rightLabel.setIcon(null);
  DefaultTreeContactList contactList=(DefaultTreeContactList)tree;
  if (value instanceof ContactNode) {
    MetaContact metaContact=((ContactNode)value).getMetaContact();
    String displayName=metaContact.getDisplayName();
    if (displayName == null || displayName.length() < 1) {
      displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    }
    this.nameLabel.setText(displayName);
    if (contactList.isContactActive(metaContact)) {
      statusIcon.setImage(msgReceivedImage);
    }
 else {
      statusIcon.setImage(Constants.getStatusIcon(contactList.getMetaContactStatus(metaContact)));
    }
    this.statusLabel.setIcon(statusIcon);
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    if (contactForegroundColor != null)     this.nameLabel.setForeground(contactForegroundColor);
    this.initStatusMessage(metaContact);
    this.initButtonsPanel(metaContact);
    ImageIcon avatar=getAvatar(metaContact);
    if (avatar != null)     this.rightLabel.setIcon(avatar);
    this.rightLabel.setText(""String_Node_Str"");
    this.setToolTipText(metaContact.getMetaUID());
  }
 else   if (value instanceof GroupNode) {
    MetaContactGroup groupItem=((GroupNode)value).getMetaContactGroup();
    this.nameLabel.setText(groupItem.getGroupName());
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    if (groupForegroundColor != null)     this.nameLabel.setForeground(groupForegroundColor);
    this.remove(statusMessageLabel);
    this.remove(callButton);
    this.remove(chatButton);
    this.statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);
    this.rightLabel.setIcon(null);
    this.rightLabel.setText(groupItem.countOnlineChildContacts() + ""String_Node_Str"" + groupItem.countChildContacts());
    this.setToolTipText(groupItem.getMetaUID());
  }
  return this;
}",0.99922420480993
103764,"/** 
 * Updates the active state of the contact node corresponding to the given <tt>MetaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> to update
 * @param isActive indicates if the node should be set to active
 */
public void setActiveContact(MetaContact metaContact,boolean isActive){
  ContactNode contactNode=treeModel.findContactNodeByMetaContact(metaContact);
  if (contactNode != null)   contactNode.setActive(isActive);
  if (isActive) {
    activeContacts.add(contactNode);
  }
 else   activeContacts.remove(contactNode);
}","/** 
 * Updates the active state of the contact node corresponding to the given <tt>MetaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> to update
 * @param isActive indicates if the node should be set to active
 */
public void setActiveContact(MetaContact metaContact,boolean isActive){
  ContactNode contactNode=treeModel.findContactNodeByMetaContact(metaContact);
  if (contactNode != null) {
    contactNode.setActive(isActive);
    if (isActive) {
      activeContacts.add(contactNode);
    }
 else     activeContacts.remove(contactNode);
    treeModel.nodeChanged(contactNode);
  }
}",0.9511343804537522
103765,"/** 
 * Deactivates all active contacts.
 */
public void deactivateAll(){
  for (  ContactNode contactNode : activeContacts) {
    contactNode.setActive(false);
  }
  activeContacts.clear();
}","/** 
 * Deactivates all active contacts.
 */
public void deactivateAll(){
  for (  ContactNode contactNode : activeContacts) {
    if (contactNode != null)     contactNode.setActive(false);
  }
  activeContacts.clear();
}",0.9297820823244553
103766,"/** 
 * Creates the <tt>SearchFilter</tt> by specifying the string used for filtering.
 * @param filterString the String used for filtering
 */
public void setFilterString(String filterString){
  filterString=Pattern.quote(filterString);
  this.filterPattern=Pattern.compile(filterString,Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
}","/** 
 * Creates the <tt>SearchFilter</tt> by specifying the string used for filtering.
 * @param filterString the String used for filtering
 */
public void setFilterString(String filterString){
  filterString=Pattern.quote(filterString);
  this.filterPattern=Pattern.compile(filterString,Pattern.MULTILINE | Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
}",0.966906474820144
103767,"/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (jabberProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  if (!jabberProvider.isRegistered())   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
}","/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (jabberProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  if (!jabberProvider.isRegistered()) {
    if (opSetPersPresence.getPresenceStatus().isOnline()) {
      opSetPersPresence.fireProviderStatusChangeEvent(opSetPersPresence.getPresenceStatus(),jabberProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));
    }
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.7962806424344886
103768,"/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (jabberProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
 else   if (!jabberProvider.isRegistered())   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
}","/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (jabberProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
 else   if (!jabberProvider.isRegistered()) {
    if (opSetPersPresence.getPresenceStatus().isOnline()) {
      opSetPersPresence.fireProviderStatusChangeEvent(opSetPersPresence.getPresenceStatus(),jabberProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));
    }
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.798326359832636
103769,"public void processPacket(Packet packet){
  if (!(packet instanceof StreamInitiation))   return;
  logger.debug(""String_Node_Str"");
  StreamInitiation streamInitiation=(StreamInitiation)packet;
  FileTransferRequest jabberRequest=new FileTransferRequest(manager,streamInitiation);
  IncomingFileTransferRequestJabberImpl incomingFileTransferRequest=new IncomingFileTransferRequestJabberImpl(jabberProvider,OperationSetFileTransferJabberImpl.this,jabberRequest);
  org.jivesoftware.smackx.packet.StreamInitiation.File file=streamInitiation.getFile();
  boolean isThumbnailedFile=false;
  if (file instanceof FileElement) {
    ThumbnailElement thumbnailElement=((FileElement)file).getThumbnailElement();
    if (thumbnailElement != null) {
      isThumbnailedFile=true;
      incomingFileTransferRequest.createThumbnailListeners(thumbnailElement.getCid());
      ThumbnailIQ thumbnailRequest=new ThumbnailIQ(streamInitiation.getTo(),streamInitiation.getFrom(),thumbnailElement.getCid(),IQ.Type.GET);
      logger.debug(""String_Node_Str"" + thumbnailRequest.toXML());
      jabberProvider.getConnection().sendPacket(thumbnailRequest);
    }
  }
  if (!isThumbnailedFile) {
    FileTransferRequestEvent fileTransferRequestEvent=new FileTransferRequestEvent(OperationSetFileTransferJabberImpl.this,incomingFileTransferRequest,new Date());
    fireFileTransferRequest(fileTransferRequestEvent);
  }
}","/** 
 * Listens for file transfer packets.
 * @param packet
 */
public void processPacket(Packet packet){
  if (!(packet instanceof StreamInitiation))   return;
  logger.debug(""String_Node_Str"");
  StreamInitiation streamInitiation=(StreamInitiation)packet;
  FileTransferRequest jabberRequest=new FileTransferRequest(manager,streamInitiation);
  IncomingFileTransferRequestJabberImpl incomingFileTransferRequest=new IncomingFileTransferRequestJabberImpl(jabberProvider,OperationSetFileTransferJabberImpl.this,jabberRequest);
  org.jivesoftware.smackx.packet.StreamInitiation.File file=streamInitiation.getFile();
  boolean isThumbnailedFile=false;
  if (file instanceof FileElement) {
    ThumbnailElement thumbnailElement=((FileElement)file).getThumbnailElement();
    if (thumbnailElement != null) {
      isThumbnailedFile=true;
      incomingFileTransferRequest.createThumbnailListeners(thumbnailElement.getCid());
      ThumbnailIQ thumbnailRequest=new ThumbnailIQ(streamInitiation.getTo(),streamInitiation.getFrom(),thumbnailElement.getCid(),IQ.Type.GET);
      logger.debug(""String_Node_Str"" + thumbnailRequest.toXML());
      jabberProvider.getConnection().sendPacket(thumbnailRequest);
    }
  }
  if (!isThumbnailedFile) {
    FileTransferRequestEvent fileTransferRequestEvent=new FileTransferRequestEvent(OperationSetFileTransferJabberImpl.this,incomingFileTransferRequest,new Date());
    fireFileTransferRequest(fileTransferRequestEvent);
  }
}",0.9775596072931276
103770,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    manager=new FileTransferManager(jabberProvider.getConnection());
    fileTransferRequestListener=new FileTransferRequestListener();
    ProviderManager.getInstance().addIQProvider(FileElement.ELEMENT_NAME,FileElement.NAMESPACE,new FileElement());
    ProviderManager.getInstance().addIQProvider(ThumbnailIQ.ELEMENT_NAME,ThumbnailIQ.NAMESPACE,new ThumbnailIQ());
    jabberProvider.getConnection().addPacketListener(fileTransferRequestListener,new AndFilter(new PacketTypeFilter(StreamInitiation.class),new IQTypeFilter(IQ.Type.SET)));
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED) {
    if (fileTransferRequestListener != null && jabberProvider.getConnection() != null) {
      jabberProvider.getConnection().removePacketListener(fileTransferRequestListener);
    }
    ProviderManager providerManager=ProviderManager.getInstance();
    if (providerManager != null) {
      ProviderManager.getInstance().removeIQProvider(FileElement.ELEMENT_NAME,FileElement.NAMESPACE);
      ProviderManager.getInstance().removeIQProvider(ThumbnailIQ.ELEMENT_NAME,ThumbnailIQ.NAMESPACE);
    }
    fileTransferRequestListener=null;
    manager=null;
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    opSetPersPresence=(OperationSetPersistentPresenceJabberImpl)jabberProvider.getOperationSet(OperationSetPersistentPresence.class);
    manager=new FileTransferManager(jabberProvider.getConnection());
    fileTransferRequestListener=new FileTransferRequestListener();
    ProviderManager.getInstance().addIQProvider(FileElement.ELEMENT_NAME,FileElement.NAMESPACE,new FileElement());
    ProviderManager.getInstance().addIQProvider(ThumbnailIQ.ELEMENT_NAME,ThumbnailIQ.NAMESPACE,new ThumbnailIQ());
    jabberProvider.getConnection().addPacketListener(fileTransferRequestListener,new AndFilter(new PacketTypeFilter(StreamInitiation.class),new IQTypeFilter(IQ.Type.SET)));
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED) {
    if (fileTransferRequestListener != null && jabberProvider.getConnection() != null) {
      jabberProvider.getConnection().removePacketListener(fileTransferRequestListener);
    }
    ProviderManager providerManager=ProviderManager.getInstance();
    if (providerManager != null) {
      ProviderManager.getInstance().removeIQProvider(FileElement.ELEMENT_NAME,FileElement.NAMESPACE);
      ProviderManager.getInstance().removeIQProvider(ThumbnailIQ.ELEMENT_NAME,ThumbnailIQ.NAMESPACE);
    }
    fileTransferRequestListener=null;
    manager=null;
  }
}",0.96047197640118
103771,"/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (parentProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  if (!parentProvider.isRegistered())   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
}","/** 
 * Utility method throwing an exception if the stack is not properly initialized.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 */
private void assertConnected() throws IllegalStateException {
  if (parentProvider == null)   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  if (!parentProvider.isRegistered()) {
    if (currentStatus.isOnline()) {
      fireProviderStatusChangeEvent(currentStatus,parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));
    }
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.8433303491495077
103772,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private synchronized void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        confConn.setReconnectionAllowed(false);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        }
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
      SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    discoveryManager.removeFeature(""String_Node_Str"");
    while (it.hasNext()) {
      String feature=it.next();
      if (!discoveryManager.includesFeature(feature))       discoveryManager.addFeature(feature);
    }
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private synchronized void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        confConn.setReconnectionAllowed(false);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        }
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      SASLAuthentication.unregisterSASLMechanism(""String_Node_Str"");
      SASLAuthentication.registerSASLMechanism(""String_Node_Str"",SASLDigestMD5Mechanism.class);
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"");
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.addConnectionListener(new JabberConnectionListener());
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    discoveryManager.removeFeature(""String_Node_Str"");
    while (it.hasNext()) {
      String feature=it.next();
      if (!discoveryManager.includesFeature(feature))       discoveryManager.addFeature(feature);
    }
  }
}",0.9928003031451308
103773,"public void logException(Exception ex){
  logger.warn(""String_Node_Str"" + ex,ex);
}","/** 
 * Prints the specified <tt>exception</tt> as a warning.
 * @param exception the <tt>Exception</tt> we are passed from jain-sip.
 */
public void logException(Exception exception){
  logger.warn(""String_Node_Str"" + exception,exception);
}",0.5107692307692308
103774,"public void closeLogFile(){
}","/** 
 * Dummy implementation for   {@link ServerLogger#closeLogFile()}
 */
public void closeLogFile(){
}",0.4360902255639097
103775,"public void logMessage(SIPMessage message,String from,String to,String status,boolean sender){
  if (sender) {
    logger.trace(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ status+ ""String_Node_Str""+ message);
  }
 else {
    logger.trace(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ status+ ""String_Node_Str""+ message);
  }
}","/** 
 * Logs the specified message and details.
 * @param message the message to log
 * @param from the message sender
 * @param to the message addressee
 * @param status message status
 * @param sender determines whether we are the origin of this message.
 */
public void logMessage(SIPMessage message,String from,String to,String status,boolean sender){
  if (sender) {
    logger.trace(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ status+ ""String_Node_Str""+ message);
  }
 else {
    logger.trace(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ status+ ""String_Node_Str""+ message);
  }
}",0.7413280475718533
103776,"/** 
 * logs a stack trace. This helps to look at the stack frame.
 */
public void logStackTrace(int traceLevel){
  logger.trace(""String_Node_Str"",new Throwable());
}","/** 
 * logs a stack trace. This helps to look at the stack frame.
 * @param traceLevel currently unused.
 */
public void logStackTrace(int traceLevel){
  logger.trace(""String_Node_Str"",new Throwable());
}",0.894878706199461
103777,"public void setStackProperties(Properties stackProperties){
}","/** 
 * Dummy implementation for   {@link ServerLogger#setStackProperties(Properties)}
 */
public void setStackProperties(Properties stackProperties){
}",0.5727699530516432
103778,"public void setBuildTimeStamp(String buildTimeStamp){
  logger.trace(""String_Node_Str"" + buildTimeStamp);
}","/** 
 * Logs the build time stamp of the jain-sip reference implementation.
 * @param buildTimeStamp the build time stamp of the jain-sip referenceimplementation.
 */
public void setBuildTimeStamp(String buildTimeStamp){
  logger.trace(""String_Node_Str"" + buildTimeStamp);
}",0.5616797900262467
103779,"/** 
 * Return true/false if logging is enabled at a given level.
 * @param logLevel the level that we'd like to check loggability for.
 */
public boolean isLoggingEnabled(int logLevel){
  return true;
}","/** 
 * Return true/false if logging is enabled at a given level.
 * @param logLevel the level that we'd like to check loggability for.
 * @return always <tt>true</tt> regardless of <tt>logLevel</tt>'s value.
 */
public boolean isLoggingEnabled(int logLevel){
  return true;
}",0.8475991649269311
103780,"public void setSipStack(SipStack sipStack){
}","/** 
 * A dummy implementation.
 * @param sipStack ignored;
 */
public void setSipStack(SipStack sipStack){
}",0.5844155844155844
103781,"public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || e.getID() != KeyEvent.KEY_PRESSED)   return false;
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN || e.getKeyCode() == KeyEvent.VK_HOME || e.getKeyCode() == KeyEvent.VK_END)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_ESCAPE || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT || e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_CONTROL || e.getKeyCode() == KeyEvent.VK_ALT || e.getKeyCode() == KeyEvent.VK_SHIFT || e.getKeyCode() == KeyEvent.VK_META || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || e.getKeyCode() == KeyEvent.VK_F1 || e.getKeyCode() == KeyEvent.VK_F2 || e.getKeyCode() == KeyEvent.VK_F3 || e.getKeyCode() == KeyEvent.VK_F4 || e.getKeyCode() == KeyEvent.VK_F5 || e.getKeyCode() == KeyEvent.VK_F6 || e.getKeyCode() == KeyEvent.VK_F7 || e.getKeyCode() == KeyEvent.VK_F8 || e.getKeyCode() == KeyEvent.VK_F9 || e.getKeyCode() == KeyEvent.VK_F10 || e.getKeyCode() == KeyEvent.VK_F11 || e.getKeyCode() == KeyEvent.VK_F12 || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner()) {
    String searchText=""String_Node_Str"";
    if (searchField.getText() != null)     searchText+=searchField.getText() + e.getKeyChar();
 else     searchText+=e.getKeyChar();
    searchField.setText(searchText);
    searchField.requestFocus();
    return true;
  }
  return false;
}","public boolean dispatchKeyEvent(KeyEvent e){
  if (!isFocused() || e.getID() != KeyEvent.KEY_PRESSED)   return false;
  TreeContactList contactList=getContactListPanel().getContactList();
  if (searchField.isFocusOwner() && (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_PAGE_UP || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN || e.getKeyCode() == KeyEvent.VK_HOME || e.getKeyCode() == KeyEvent.VK_END)) {
    contactList.selectFirstContact();
    contactList.requestFocus();
    return false;
  }
  if (contactList.isFocusOwner() && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
    contactList.removeSelectionRows(contactList.getSelectionRows());
    if (searchField.getText() != null) {
      searchField.requestFocus();
    }
    return false;
  }
  TreePath selectionPath=contactList.getSelectionPath();
  if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_TAB || e.getKeyCode() == KeyEvent.VK_SPACE || (selectionPath != null && selectionPath.getLastPathComponent() instanceof GroupNode && (e.getKeyChar() == '+' || e.getKeyChar() == '-'))) {
    return false;
  }
  if (!searchField.isFocusOwner()) {
    String searchText=""String_Node_Str"";
    if (searchField.getText() != null)     searchText+=searchField.getText() + e.getKeyChar();
 else     searchText+=e.getKeyChar();
    searchField.setText(searchText);
    searchField.requestFocus();
    return true;
  }
  return false;
}",0.7673824130879345
103782,"/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (!path.equals(getSelectionPath()) && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if (lastComponent instanceof ContactNode) {
    ContactNode contactNode=(ContactNode)lastComponent;
    fireContactListEvent(contactNode.getMetaContact(),ContactListEvent.CONTACT_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=new ContactRightButtonMenu(contactNode.getMetaContact(),this);
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    GroupNode groupNode=(GroupNode)lastComponent;
    fireContactListEvent(groupNode.getMetaContactGroup(),ContactListEvent.GROUP_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=new GroupRightButtonMenu(GuiActivator.getUIService().getMainFrame(),groupNode.getMetaContactGroup());
      openRightButtonMenu(e.getPoint());
    }
  }
  dispatchEventToButtons(e);
}","/** 
 * When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 * @param e the <tt>MouseEvent</tt> that notified us of the press
 */
public void mousePressed(MouseEvent e){
  if (!isGroupClickConsumed) {
    for (    MouseListener listener : originalMouseListeners)     listener.mousePressed(e);
  }
  TreePath path=this.getPathForLocation(e.getX(),e.getY());
  if (path == null)   return;
  if (!path.equals(getSelectionPath()) && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    this.setSelectionPath(path);
  }
  Object lastComponent=path.getLastPathComponent();
  if (!(lastComponent instanceof TreeNode))   return;
  if (lastComponent instanceof ContactNode) {
    ContactNode contactNode=(ContactNode)lastComponent;
    fireContactListEvent(contactNode.getMetaContact(),ContactListEvent.CONTACT_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=new ContactRightButtonMenu(contactNode.getMetaContact(),this);
      openRightButtonMenu(e.getPoint());
    }
  }
 else   if (lastComponent instanceof GroupNode) {
    GroupNode groupNode=(GroupNode)lastComponent;
    fireContactListEvent(groupNode.getMetaContactGroup(),ContactListEvent.GROUP_CLICKED,e.getClickCount());
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      rightButtonMenu=new GroupRightButtonMenu(GuiActivator.getUIService().getMainFrame(),groupNode.getMetaContactGroup());
      openRightButtonMenu(e.getPoint());
    }
  }
  dispatchEventToButtons(e);
}",0.992496248124062
103783,"/** 
 * Returns a default contact for a specific operation (call, file transfer, IM ...)
 * @param operationSet the operation for which the default contact is needed
 * @return the default contact for the specified operation.
 */
public Contact getDefaultContact(Class<? extends OperationSet> operationSet){
  Contact defaultOpSetContact=null;
  if (getDefaultContact().getProtocolProvider().getOperationSet(operationSet) != null) {
    defaultOpSetContact=getDefaultContact();
  }
 else {
    for (    Contact protoContact : protoContacts) {
      PresenceStatus currentStatus=null;
      if (protoContact.getProtocolProvider().getOperationSet(operationSet) != null) {
        PresenceStatus contactStatus=protoContact.getPresenceStatus();
        if (currentStatus != null) {
          if (currentStatus.getStatus() < contactStatus.getStatus()) {
            currentStatus=contactStatus;
            defaultOpSetContact=protoContact;
          }
        }
 else {
          currentStatus=contactStatus;
          defaultOpSetContact=protoContact;
        }
      }
    }
  }
  return defaultOpSetContact;
}","/** 
 * Returns a default contact for a specific operation (call, file transfer, IM ...)
 * @param operationSet the operation for which the default contact is needed
 * @return the default contact for the specified operation.
 */
public Contact getDefaultContact(Class<? extends OperationSet> operationSet){
  Contact defaultOpSetContact=null;
  Contact defaultContact=getDefaultContact();
  if (defaultContact != null && defaultContact.getProtocolProvider().getOperationSet(operationSet) != null) {
    defaultOpSetContact=getDefaultContact();
  }
 else {
    for (    Contact protoContact : protoContacts) {
      PresenceStatus currentStatus=null;
      if (protoContact.getProtocolProvider().getOperationSet(operationSet) != null) {
        PresenceStatus contactStatus=protoContact.getPresenceStatus();
        if (currentStatus != null) {
          if (currentStatus.getStatus() < contactStatus.getStatus()) {
            currentStatus=contactStatus;
            defaultOpSetContact=protoContact;
          }
        }
 else {
          currentStatus=contactStatus;
          defaultOpSetContact=protoContact;
        }
      }
    }
  }
  return defaultOpSetContact;
}",0.9671484888304862
103784,"@Override public int getMaxSize(){
  return this.maxSize;
}","public int getMaxSize(){
  return this.maxSize;
}",0.9074074074074074
103785,"/** 
 * Notifies all registered listeners of the new event.
 * @param newAvatar the new avatar
 */
protected void fireAvatarChanged(byte[] newAvatar){
  AvatarEvent event=new AvatarEvent(this,this.parentProvider,newAvatar);
  Collection<AvatarListener> listeners;
synchronized (this.avatarListeners) {
    listeners=new ArrayList<AvatarListener>(this.avatarListeners);
  }
  for (  AvatarListener l : listeners)   l.avatarChanged(event);
}","/** 
 * Notifies all registered listeners of the new event.
 * @param newAvatar the new avatar
 */
protected void fireAvatarChanged(byte[] newAvatar){
  Collection<AvatarListener> listeners;
synchronized (this.avatarListeners) {
    listeners=new ArrayList<AvatarListener>(this.avatarListeners);
  }
  if (!listeners.isEmpty()) {
    AvatarEvent event=new AvatarEvent(this,this.parentProvider,newAvatar);
    for (    AvatarListener l : listeners)     l.avatarChanged(event);
  }
}",0.4956521739130435
103786,"@Override @SuppressWarnings(""String_Node_Str"") public void setAvatar(byte[] avatar){
  ImageDetail oldDetail=null;
  ImageDetail newDetail=new ImageDetail(""String_Node_Str"",avatar);
  Iterator<GenericDetail> imageDetails=this.accountInfoOpSet.getDetails(ServerStoredDetails.ImageDetail.class);
  if (imageDetails.hasNext()) {
    oldDetail=(ImageDetail)imageDetails.next();
  }
  try {
    if (oldDetail == null)     this.accountInfoOpSet.addDetail(newDetail);
 else     this.accountInfoOpSet.replaceDetail(oldDetail,newDetail);
  }
 catch (  OperationFailedException e) {
    logger.warn(""String_Node_Str"",e);
  }
  fireAvatarChanged(avatar);
}","public void setAvatar(byte[] avatar){
  ImageDetail oldDetail=null;
  ImageDetail newDetail=new ImageDetail(""String_Node_Str"",avatar);
  Iterator<GenericDetail> imageDetails=this.accountInfoOpSet.getDetails(ServerStoredDetails.ImageDetail.class);
  if (imageDetails.hasNext()) {
    oldDetail=(ImageDetail)imageDetails.next();
  }
  try {
    if (oldDetail == null)     this.accountInfoOpSet.addDetail(newDetail);
 else     this.accountInfoOpSet.replaceDetail(oldDetail,newDetail);
  }
 catch (  OperationFailedException e) {
    logger.warn(""String_Node_Str"",e);
  }
  fireAvatarChanged(avatar);
}",0.1592920353982301
103787,"@Override public byte[] getAvatar(){
  return AccountInfoUtils.getImage(this.accountInfoOpSet);
}","public byte[] getAvatar(){
  return AccountInfoUtils.getImage(this.accountInfoOpSet);
}",0.9456521739130436
103788,"@Override public void removeAvatarListener(AvatarListener listener){
synchronized (this.avatarListeners) {
    if (this.avatarListeners.contains(listener))     this.avatarListeners.remove(listener);
  }
}","public void removeAvatarListener(AvatarListener listener){
synchronized (this.avatarListeners) {
    if (this.avatarListeners.contains(listener))     this.avatarListeners.remove(listener);
  }
}",0.9748743718592964
103789,"@Override public void addAvatarListener(AvatarListener listener){
synchronized (this.avatarListeners) {
    if (!this.avatarListeners.contains(listener))     this.avatarListeners.add(listener);
  }
}","public void addAvatarListener(AvatarListener listener){
synchronized (this.avatarListeners) {
    if (!this.avatarListeners.contains(listener))     this.avatarListeners.add(listener);
  }
}",0.9742268041237112
103790,"@Override public int getMaxHeight(){
  return this.maxHeight;
}","public int getMaxHeight(){
  return this.maxHeight;
}",0.913793103448276
103791,"@Override public int getMaxWidth(){
  return this.maxWidth;
}","public int getMaxWidth(){
  return this.maxWidth;
}",0.9107142857142856
103792,"/** 
 * An ok here means that our registration has been accepted or terminated (depending on the corresponding REGISTER request). We change state notify listeners and (in the case of a new registration) schedule reregistration.
 * @param clientTransatcion the ClientTransaction that we created whensending the register request.
 * @param response the OK Response that we've just received.
 */
public void processOK(ClientTransaction clientTransatcion,Response response){
  int requestedExpiration=0;
  Request register=clientTransatcion.getRequest();
  ExpiresHeader expiresHeader=register.getExpires();
  if (expiresHeader != null)   requestedExpiration=expiresHeader.getExpires();
 else {
    ContactHeader contactHeader=(ContactHeader)register.getHeader(ContactHeader.NAME);
    if (contactHeader != null)     requestedExpiration=contactHeader.getExpires();
 else     requestedExpiration=0;
  }
  int grantedExpiration=registrationsExpiration;
  expiresHeader=response.getExpires();
  if (expiresHeader != null) {
    grantedExpiration=expiresHeader.getExpires();
  }
 else {
    ContactHeader contactHeader=(ContactHeader)response.getHeader(ContactHeader.NAME);
    if (contactHeader != null) {
      grantedExpiration=contactHeader.getExpires();
    }
 else {
      grantedExpiration=requestedExpiration;
    }
  }
  if (grantedExpiration <= 0 || requestedExpiration <= 0) {
    setRegistrationState(RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
  }
 else {
    int scheduleTime=grantedExpiration;
    String keepAliveMethod=sipProvider.getAccountID().getAccountPropertyString(KEEP_ALIVE_METHOD);
    if ((keepAliveMethod != null && keepAliveMethod.equalsIgnoreCase(""String_Node_Str"")) || keepAliveMethod == null) {
      int registrationInterval=sipProvider.getAccountID().getAccountPropertyInt(KEEP_ALIVE_INTERVAL,KEEP_ALIVE_INTERVAL_DEFAULT_VALUE);
      if (registrationInterval < grantedExpiration) {
        scheduleTime=registrationInterval;
      }
    }
    scheduleReRegistration(scheduleTime);
    setRegistrationState(RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  }
}","/** 
 * An ok here means that our registration has been accepted or terminated (depending on the corresponding REGISTER request). We change state notify listeners and (in the case of a new registration) schedule reregistration.
 * @param clientTransatcion the ClientTransaction that we created whensending the register request.
 * @param response the OK Response that we've just received.
 */
public void processOK(ClientTransaction clientTransatcion,Response response){
  int requestedExpiration=0;
  Request register=clientTransatcion.getRequest();
  ContactHeader contactHeader=(ContactHeader)register.getHeader(ContactHeader.NAME);
  if (contactHeader != null)   requestedExpiration=contactHeader.getExpires();
 else   requestedExpiration=0;
  if (requestedExpiration <= 0) {
    ExpiresHeader expiresHeader=register.getExpires();
    if (expiresHeader != null)     requestedExpiration=expiresHeader.getExpires();
  }
  int grantedExpiration=registrationsExpiration;
  expiresHeader=response.getExpires();
  if (expiresHeader != null) {
    grantedExpiration=expiresHeader.getExpires();
  }
 else {
    ContactHeader contactHeader=(ContactHeader)response.getHeader(ContactHeader.NAME);
    if (contactHeader != null) {
      grantedExpiration=contactHeader.getExpires();
    }
 else {
      grantedExpiration=requestedExpiration;
    }
  }
  if (grantedExpiration <= 0 || requestedExpiration <= 0) {
    setRegistrationState(RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
  }
 else {
    int scheduleTime=grantedExpiration;
    String keepAliveMethod=sipProvider.getAccountID().getAccountPropertyString(KEEP_ALIVE_METHOD);
    if ((keepAliveMethod != null && keepAliveMethod.equalsIgnoreCase(""String_Node_Str"")) || keepAliveMethod == null) {
      int registrationInterval=sipProvider.getAccountID().getAccountPropertyInt(KEEP_ALIVE_INTERVAL,KEEP_ALIVE_INTERVAL_DEFAULT_VALUE);
      if (registrationInterval < grantedExpiration) {
        scheduleTime=registrationInterval;
      }
    }
    scheduleReRegistration(scheduleTime);
    setRegistrationState(RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  }
}",0.927007299270073
103793,"/** 
 * An ok here means that our registration has been accepted or terminated (depending on the corresponding REGISTER request). We change state notify listeners and (in the case of a new registration) schedule reregistration.
 * @param clientTransatcion the ClientTransaction that we created whensending the register request.
 * @param response the OK Response that we've just received.
 */
public void processOK(ClientTransaction clientTransatcion,Response response){
  int requestedExpiration=0;
  Request register=clientTransatcion.getRequest();
  ContactHeader contactHeader=(ContactHeader)register.getHeader(ContactHeader.NAME);
  if (contactHeader != null)   requestedExpiration=contactHeader.getExpires();
 else   requestedExpiration=0;
  if (requestedExpiration <= 0) {
    ExpiresHeader expiresHeader=register.getExpires();
    if (expiresHeader != null)     requestedExpiration=expiresHeader.getExpires();
  }
  int grantedExpiration=registrationsExpiration;
  expiresHeader=response.getExpires();
  if (expiresHeader != null) {
    grantedExpiration=expiresHeader.getExpires();
  }
 else {
    ContactHeader contactHeader=(ContactHeader)response.getHeader(ContactHeader.NAME);
    if (contactHeader != null) {
      grantedExpiration=contactHeader.getExpires();
    }
 else {
      grantedExpiration=requestedExpiration;
    }
  }
  if (grantedExpiration <= 0 || requestedExpiration <= 0) {
    setRegistrationState(RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
  }
 else {
    int scheduleTime=grantedExpiration;
    String keepAliveMethod=sipProvider.getAccountID().getAccountPropertyString(KEEP_ALIVE_METHOD);
    if ((keepAliveMethod != null && keepAliveMethod.equalsIgnoreCase(""String_Node_Str"")) || keepAliveMethod == null) {
      int registrationInterval=sipProvider.getAccountID().getAccountPropertyInt(KEEP_ALIVE_INTERVAL,KEEP_ALIVE_INTERVAL_DEFAULT_VALUE);
      if (registrationInterval < grantedExpiration) {
        scheduleTime=registrationInterval;
      }
    }
    scheduleReRegistration(scheduleTime);
    setRegistrationState(RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  }
}","/** 
 * An ok here means that our registration has been accepted or terminated (depending on the corresponding REGISTER request). We change state notify listeners and (in the case of a new registration) schedule reregistration.
 * @param clientTransatcion the ClientTransaction that we created whensending the register request.
 * @param response the OK Response that we've just received.
 */
public void processOK(ClientTransaction clientTransatcion,Response response){
  int requestedExpiration=0;
  Request register=clientTransatcion.getRequest();
  ContactHeader contactHeader=(ContactHeader)register.getHeader(ContactHeader.NAME);
  if (contactHeader != null)   requestedExpiration=contactHeader.getExpires();
 else   requestedExpiration=0;
  if (requestedExpiration <= 0) {
    ExpiresHeader expiresHeader=register.getExpires();
    if (expiresHeader != null)     requestedExpiration=expiresHeader.getExpires();
  }
  int grantedExpiration=-1;
  ContactHeader responseContactHdr=(ContactHeader)response.getHeader(ContactHeader.NAME);
  if (responseContactHdr != null) {
    grantedExpiration=responseContactHdr.getExpires();
  }
  ExpiresHeader expiresHeader=response.getExpires();
  if (expiresHeader != null) {
    grantedExpiration=expiresHeader.getExpires();
  }
 else {
    grantedExpiration=requestedExpiration;
  }
  if (grantedExpiration <= 0 || requestedExpiration <= 0) {
    setRegistrationState(RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
  }
 else {
    int scheduleTime=grantedExpiration;
    String keepAliveMethod=sipProvider.getAccountID().getAccountPropertyString(KEEP_ALIVE_METHOD);
    if ((keepAliveMethod != null && keepAliveMethod.equalsIgnoreCase(""String_Node_Str"")) || keepAliveMethod == null) {
      int registrationInterval=sipProvider.getAccountID().getAccountPropertyInt(KEEP_ALIVE_INTERVAL,KEEP_ALIVE_INTERVAL_DEFAULT_VALUE);
      if (registrationInterval < grantedExpiration) {
        scheduleTime=registrationInterval;
      }
    }
    scheduleReRegistration(scheduleTime);
    setRegistrationState(RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  }
}",0.9002732240437158
103794,"/** 
 * Invites the given <tt>chatContacts</tt> to this chat.
 * @param inviteChatTransport the chat transport to use to send the invite
 * @param chatContacts the contacts to invite
 * @param reason the reason of the invite
 */
public void inviteContacts(ChatTransport inviteChatTransport,Collection<String> chatContacts,String reason){
  ChatSession conferenceChatSession=null;
  if (chatSession instanceof MetaContactChatSession) {
    chatContacts.add(inviteChatTransport.getName());
    ConferenceChatManager conferenceChatManager=GuiActivator.getUIService().getConferenceChatManager();
    if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetMultiUserChat.class) != null) {
      ChatRoomWrapper chatRoomWrapper=conferenceChatManager.createChatRoom(inviteChatTransport.getProtocolProvider(),chatContacts);
      conferenceChatSession=new ConferenceChatSession(this,chatRoomWrapper);
    }
 else     if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetAdHocMultiUserChat.class) != null) {
      AdHocChatRoomWrapper chatRoomWrapper=conferenceChatManager.createAdHocChatRoom(inviteChatTransport.getProtocolProvider(),chatContacts,reason);
      conferenceChatSession=new AdHocConferenceChatSession(this,chatRoomWrapper);
    }
    if (conferenceChatSession != null)     this.setChatSession(conferenceChatSession);
  }
 else {
    conferenceChatSession=chatSession;
    for (    String contactAddress : chatContacts) {
      conferenceChatSession.getCurrentChatTransport().inviteChatContact(contactAddress,reason);
    }
  }
}","/** 
 * Invites the given <tt>chatContacts</tt> to this chat.
 * @param inviteChatTransport the chat transport to use to send the invite
 * @param chatContacts the contacts to invite
 * @param reason the reason of the invitation
 */
public void inviteContacts(ChatTransport inviteChatTransport,Collection<String> chatContacts,String reason){
  ChatSession conferenceChatSession=null;
  if (chatSession instanceof MetaContactChatSession) {
    chatContacts.add(inviteChatTransport.getName());
    ConferenceChatManager conferenceChatManager=GuiActivator.getUIService().getConferenceChatManager();
    if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetMultiUserChat.class) != null) {
      ChatRoomWrapper chatRoomWrapper=conferenceChatManager.createChatRoom(inviteChatTransport.getProtocolProvider(),chatContacts,reason);
      conferenceChatSession=new ConferenceChatSession(this,chatRoomWrapper);
    }
 else     if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetAdHocMultiUserChat.class) != null) {
      AdHocChatRoomWrapper chatRoomWrapper=conferenceChatManager.createAdHocChatRoom(inviteChatTransport.getProtocolProvider(),chatContacts,reason);
      conferenceChatSession=new AdHocConferenceChatSession(this,chatRoomWrapper);
    }
    if (conferenceChatSession != null)     this.setChatSession(conferenceChatSession);
  }
 else {
    conferenceChatSession=chatSession;
    for (    String contactAddress : chatContacts) {
      conferenceChatSession.getCurrentChatTransport().inviteChatContact(contactAddress,reason);
    }
  }
}",0.995882166613874
103795,"/** 
 * Creates a chat room, by specifying the chat room name, the parent protocol provider and eventually, the contacts invited to participate in  this chat room.
 * @param roomName the name of the room
 * @param protocolProvider the parent protocol provider.
 * @param contacts the contacts invited when creating the chat room.
 * @return the <tt>ChatRoomWrapper</tt> corresponding to the created room
 */
public ChatRoomWrapper createChatRoom(String roomName,ProtocolProviderService protocolProvider,Collection<String> contacts){
  ChatRoomWrapper chatRoomWrapper=null;
  OperationSetMultiUserChat groupChatOpSet=protocolProvider.getOperationSet(OperationSetMultiUserChat.class);
  if (groupChatOpSet == null)   return null;
  ChatRoom chatRoom=null;
  try {
    Map<String,Object> members=new Hashtable<String,Object>();
    OperationSetPersistentPresence opSet=protocolProvider.getOperationSet(OperationSetPersistentPresence.class);
    for (    String contact : contacts)     members.put(contact,opSet.findContactByID(contact));
    chatRoom=groupChatOpSet.createChatRoom(roomName,members);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}),ex).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}),ex).showDialog();
  }
  if (chatRoom != null) {
    ChatRoomProviderWrapper parentProvider=chatRoomList.findServerWrapperFromProvider(protocolProvider);
    chatRoomWrapper=new ChatRoomWrapper(parentProvider,chatRoom);
    chatRoomList.addChatRoom(chatRoomWrapper);
    fireChatRoomListChangedEvent(chatRoomWrapper,ChatRoomListChangeEvent.CHAT_ROOM_ADDED);
  }
  return chatRoomWrapper;
}","/** 
 * Creates a chat room, by specifying the chat room name, the parent protocol provider and eventually, the contacts invited to participate in  this chat room.
 * @param roomName the name of the room
 * @param protocolProvider the parent protocol provider.
 * @param contacts the contacts invited when creating the chat room.
 * @param reason
 * @return the <tt>ChatRoomWrapper</tt> corresponding to the created room
 */
public ChatRoomWrapper createChatRoom(String roomName,ProtocolProviderService protocolProvider,Collection<String> contacts,String reason){
  ChatRoomWrapper chatRoomWrapper=null;
  OperationSetMultiUserChat groupChatOpSet=protocolProvider.getOperationSet(OperationSetMultiUserChat.class);
  if (groupChatOpSet == null)   return null;
  ChatRoom chatRoom=null;
  try {
    chatRoom=groupChatOpSet.createChatRoom(roomName,null);
    chatRoom.join();
    for (    String contact : contacts)     chatRoom.invite(contact,reason);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}),ex).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}),ex).showDialog();
  }
  if (chatRoom != null) {
    ChatRoomProviderWrapper parentProvider=chatRoomList.findServerWrapperFromProvider(protocolProvider);
    chatRoomWrapper=new ChatRoomWrapper(parentProvider,chatRoom);
    chatRoomList.addChatRoom(chatRoomWrapper);
    fireChatRoomListChangedEvent(chatRoomWrapper,ChatRoomListChangeEvent.CHAT_ROOM_ADDED);
  }
  return chatRoomWrapper;
}",0.8786489746682751
103796,"/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    for (int i=0; i < chatParticipants.size(); i++) {
      ChatContact cc=chatParticipants.get(i);
      if (((ChatRoomMember)cc.getDescriptor()).getContactAddress().equals(evt.getChatRoomMember().getContactAddress())) {
        chatParticipants.remove(i);
        sessionRenderer.removeChatContact(cc);
      }
    }
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}","/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}",0.9357502517623364
103797,"/** 
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    String chatRoomName=chatRoomPanel.getChatRoomName();
    GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName,chatRoomProvider.getProtocolProvider(),null);
  }
  this.dispose();
}","/** 
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    String chatRoomName=chatRoomPanel.getChatRoomName();
    GuiActivator.getUIService().getConferenceChatManager().createChatRoom(chatRoomName,chatRoomProvider.getProtocolProvider(),null,""String_Node_Str"");
  }
  this.dispose();
}",0.9768041237113402
103798,"/** 
 * Implements the Wizard.wizardFinished method.
 */
public void wizardFinished(WizardEvent e){
  if (e.getEventCode() == WizardEvent.SUCCESS) {
    GuiActivator.getUIService().getConferenceChatManager().createChatRoom(newChatRoom.getChatRoomName(),newChatRoom.getProtocolProvider(),null);
  }
}","/** 
 * Implements the Wizard.wizardFinished method.
 */
public void wizardFinished(WizardEvent e){
  if (e.getEventCode() == WizardEvent.SUCCESS) {
    GuiActivator.getUIService().getConferenceChatManager().createChatRoom(newChatRoom.getChatRoomName(),newChatRoom.getProtocolProvider(),null,""String_Node_Str"");
  }
}",0.9707792207792209
103799,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  ChatRoom room=null;
  if (roomName == null)   roomName=""String_Node_Str"" + StringUtils.randomString(4);
 else   room=findRoom(roomName);
  if (room == null) {
    logger.info(""String_Node_Str"");
    MultiUserChat muc=new MultiUserChat(getXmppConnection(),getCanonicalRoomName(roomName));
    try {
      muc.create(StringUtils.parseName(getXmppConnection().getUser()));
      muc.sendConfigurationForm(new Form(Form.TYPE_SUBMIT));
    }
 catch (    XMPPException ex) {
      logger.error(""String_Node_Str"",ex);
      throw new OperationFailedException(""String_Node_Str"",ex.getXMPPError().getCode(),ex.getCause());
    }
    room=createLocalChatRoomInstance(muc);
    room.setUserRole(ChatRoomMemberRole.OWNER);
  }
  room.join();
  return room;
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  ChatRoom room=null;
  if (roomName == null)   roomName=""String_Node_Str"" + StringUtils.randomString(4);
 else   room=findRoom(roomName);
  if (room == null) {
    logger.info(""String_Node_Str"");
    MultiUserChat muc=new MultiUserChat(getXmppConnection(),getCanonicalRoomName(roomName));
    try {
      muc.create(StringUtils.parseName(getXmppConnection().getUser()));
      muc.sendConfigurationForm(new Form(Form.TYPE_SUBMIT));
    }
 catch (    XMPPException ex) {
      logger.error(""String_Node_Str"",ex);
      throw new OperationFailedException(""String_Node_Str"",ex.getXMPPError().getCode(),ex.getCause());
    }
    room=createLocalChatRoomInstance(muc);
    room.setUserRole(ChatRoomMemberRole.OWNER);
  }
  return room;
}",0.9890795631825272
103800,"/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}","/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 * @param evt the <tt>ChatRoomMemberPresenceChangeEvent</tt> that notifiedus
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    for (    ChatContact cc : chatParticipants)     if (!cc.getUID().equals(chatContact.getUID()))     chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}",0.97913593256059
103801,"@Override public synchronized void open() throws ResourceUnavailableException {
  int width=0;
  int height=0;
  if (opened)   return;
  if (inputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  if (outputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  width=(int)((VideoFormat)outputFormat).getSize().getWidth();
  height=(int)((VideoFormat)outputFormat).getSize().getHeight();
  long avcodec=FFMPEG.avcodec_find_encoder(FFMPEG.CODEC_ID_H264);
  avcontext=FFMPEG.avcodec_alloc_context();
  FFMPEG.avcodeccontext_set_pix_fmt(avcontext,FFMPEG.PIX_FMT_YUV420P);
  FFMPEG.avcodeccontext_set_size(avcontext,width,height);
  FFMPEG.avcodeccontext_set_qcompress(avcontext,0.6f);
  int _bitRate=256000;
  FFMPEG.avcodeccontext_set_bit_rate(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_bit_rate_tolerance(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_rc_max_rate(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_sample_aspect_ratio(avcontext,0,0);
  FFMPEG.avcodeccontext_set_thread_count(avcontext,0);
  FFMPEG.avcodeccontext_set_time_base(avcontext,1000,25500);
  FFMPEG.avcodeccontext_set_quantizer(avcontext,10,51,4);
  FFMPEG.avcodeccontext_add_partitions(avcontext,0x111);
  FFMPEG.avcodeccontext_set_mb_decision(avcontext,FFMPEG.FF_MB_DECISION_SIMPLE);
  FFMPEG.avcodeccontext_set_rc_eq(avcontext,""String_Node_Str"");
  FFMPEG.avcodeccontext_add_flags(avcontext,FFMPEG.CODEC_FLAG_LOOP_FILTER);
  FFMPEG.avcodeccontext_set_me_method(avcontext,1);
  FFMPEG.avcodeccontext_set_me_subpel_quality(avcontext,6);
  FFMPEG.avcodeccontext_set_me_range(avcontext,16);
  FFMPEG.avcodeccontext_set_me_cmp(avcontext,FFMPEG.FF_CMP_CHROMA);
  FFMPEG.avcodeccontext_set_scenechange_threshold(avcontext,40);
  FFMPEG.avcodeccontext_set_crf(avcontext,0);
  FFMPEG.avcodeccontext_set_rc_buffer_size(avcontext,0);
  FFMPEG.avcodeccontext_set_gop_size(avcontext,IFRAME_INTERVAL);
  FFMPEG.avcodeccontext_set_i_quant_factor(avcontext,1f / 1.4f);
  if (FFMPEG.avcodec_open(avcontext,avcodec) < 0)   throw new RuntimeException(""String_Node_Str"");
  encFrameLen=(width * height * 3) / 2;
  rawFrameBuffer=FFMPEG.av_malloc(encFrameLen);
  avframe=FFMPEG.avcodec_alloc_frame();
  int size=width * height;
  FFMPEG.avframe_set_data(avframe,rawFrameBuffer,size,size / 4);
  FFMPEG.avframe_set_linesize(avframe,width,height / 2,width / 2);
  encFrameBuffer=new byte[encFrameLen];
  opened=true;
  super.open();
}","@Override public synchronized void open() throws ResourceUnavailableException {
  int width=0;
  int height=0;
  if (opened)   return;
  if (inputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  if (outputFormat == null)   throw new ResourceUnavailableException(""String_Node_Str"");
  width=(int)((VideoFormat)outputFormat).getSize().getWidth();
  height=(int)((VideoFormat)outputFormat).getSize().getHeight();
  long avcodec=FFMPEG.avcodec_find_encoder(FFMPEG.CODEC_ID_H264);
  avcontext=FFMPEG.avcodec_alloc_context();
  FFMPEG.avcodeccontext_set_pix_fmt(avcontext,FFMPEG.PIX_FMT_YUV420P);
  FFMPEG.avcodeccontext_set_size(avcontext,width,height);
  FFMPEG.avcodeccontext_set_qcompress(avcontext,0.6f);
  int _bitRate=256000;
  FFMPEG.avcodeccontext_set_bit_rate(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_bit_rate_tolerance(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_rc_max_rate(avcontext,_bitRate);
  FFMPEG.avcodeccontext_set_sample_aspect_ratio(avcontext,0,0);
  FFMPEG.avcodeccontext_set_thread_count(avcontext,0);
  FFMPEG.avcodeccontext_set_time_base(avcontext,1000,25500);
  FFMPEG.avcodeccontext_set_quantizer(avcontext,10,51,4);
  FFMPEG.avcodeccontext_add_partitions(avcontext,0x111);
  FFMPEG.avcodeccontext_set_mb_decision(avcontext,FFMPEG.FF_MB_DECISION_SIMPLE);
  FFMPEG.avcodeccontext_set_rc_eq(avcontext,""String_Node_Str"");
  FFMPEG.avcodeccontext_add_flags(avcontext,FFMPEG.CODEC_FLAG_LOOP_FILTER);
  FFMPEG.avcodeccontext_set_me_method(avcontext,1);
  FFMPEG.avcodeccontext_set_me_subpel_quality(avcontext,6);
  FFMPEG.avcodeccontext_set_me_range(avcontext,16);
  FFMPEG.avcodeccontext_set_me_cmp(avcontext,FFMPEG.FF_CMP_CHROMA);
  FFMPEG.avcodeccontext_set_scenechange_threshold(avcontext,40);
  FFMPEG.avcodeccontext_set_crf(avcontext,0);
  FFMPEG.avcodeccontext_set_rc_buffer_size(avcontext,0);
  FFMPEG.avcodeccontext_set_gop_size(avcontext,IFRAME_INTERVAL);
  FFMPEG.avcodeccontext_set_i_quant_factor(avcontext,1f / 1.4f);
  if (FFMPEG.avcodec_open(avcontext,avcodec) < 0)   throw new RuntimeException(""String_Node_Str"");
  encFrameLen=(width * height * 3) / 2;
  rawFrameBuffer=FFMPEG.av_malloc(encFrameLen);
  avframe=FFMPEG.avcodec_alloc_frame();
  int size=width * height;
  FFMPEG.avframe_set_data(avframe,rawFrameBuffer,size,size / 4);
  FFMPEG.avframe_set_linesize(avframe,width,width / 2,width / 2);
  encFrameBuffer=new byte[encFrameLen];
  opened=true;
  super.open();
}",0.997752808988764
103802,"/** 
 * Invites another user to this room. If we're not joined nothing will happen.
 * @param userAddress The identifier of the contact (email address or yahooid)
 * @param reason The invite reason, which is send to the invitee.
 */
public void invite(String userAddress,String reason){
  try {
    if (!opSetMuc.getAlreadyInvitedContactAddresses().contains(userAddress)) {
      provider.getYahooSession().extendConference(yahooConference,userAddress,reason);
    }
  }
 catch (  IOException ioe) {
    logger.debug(""String_Node_Str"" + userAddress + ""String_Node_Str""+ ioe);
  }
}","/** 
 * Invites another user to this room. If we're not joined nothing will happen.
 * @param userAddress The identifier of the contact (email address or yahooid)
 * @param reason The invite reason, which is send to the invitee.
 */
public void invite(String userAddress,String reason){
  try {
    provider.getYahooSession().extendConference(yahooConference,userAddress,reason);
  }
 catch (  IOException ioe) {
    logger.debug(""String_Node_Str"" + userAddress + ""String_Node_Str""+ ioe);
  }
}",0.7906976744186046
103803,"public void conferenceLogonReceived(SessionConferenceEvent ev){
  logger.debug(""String_Node_Str"" + ev.toString());
  try {
    AdHocChatRoomYahooImpl chatRoom=getLocalChatRoomInstance(ev.getRoom());
    if (chatRoom != null) {
      OperationSetPersistentPresenceYahooImpl presenceOpSet=(OperationSetPersistentPresenceYahooImpl)chatRoom.getParentProvider().getOperationSet(OperationSetPersistentPresence.class);
      Contact participant=presenceOpSet.findContactByID(ev.getFrom());
      if (alreadyInvitedContactAddresses.contains(participant.getAddress())) {
        alreadyInvitedContactAddresses.remove(participant.getAddress());
      }
      chatRoom.addChatRoomParticipant(participant);
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
}","public void conferenceLogonReceived(SessionConferenceEvent ev){
  logger.debug(""String_Node_Str"" + ev.toString());
  try {
    AdHocChatRoomYahooImpl chatRoom=getLocalChatRoomInstance(ev.getRoom());
    if (chatRoom != null) {
      OperationSetPersistentPresenceYahooImpl presenceOpSet=(OperationSetPersistentPresenceYahooImpl)chatRoom.getParentProvider().getOperationSet(OperationSetPersistentPresence.class);
      Contact participant=presenceOpSet.findContactByID(ev.getFrom());
      chatRoom.addChatRoomParticipant(participant);
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
}",0.8850574712643678
103804,"public void conferenceInviteReceived(SessionConferenceEvent ev){
  logger.debug(""String_Node_Str"" + ev.toString());
  try {
    AdHocChatRoom chatRoom=getLocalChatRoomInstance(ev.getRoom());
    if (chatRoom == null) {
      chatRoom=createLocalChatRoomInstance(ev.getRoom());
      fireInvitationEvent(chatRoom,ev.getFrom(),ev.getMessage());
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
}","public void conferenceInviteReceived(SessionConferenceEvent ev){
  logger.debug(""String_Node_Str"" + ev.toString());
  try {
    AdHocChatRoom chatRoom=getLocalChatRoomInstance(ev.getRoom());
    if (chatRoom == null) {
      chatRoom=createLocalChatRoomInstance(ev.getRoom(),ev.getFrom());
      fireInvitationEvent(chatRoom,ev.getFrom(),ev.getMessage());
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
}",0.9849012775842044
103805,"/** 
 * Creates a <tt>AdHocChatRoom</tt> instance from the specified Yahoo conference.
 * @param yahooConference The chat room model from the yahoo lib.
 * @return AdHocChatRoom the chat room that we've just created.
 */
private AdHocChatRoomYahooImpl createLocalChatRoomInstance(YahooConference yahooConference){
synchronized (chatRoomCache) {
    AdHocChatRoomYahooImpl newChatRoom=new AdHocChatRoomYahooImpl(yahooConference,yahooProvider);
    chatRoomCache.put(yahooConference.getName(),newChatRoom);
    return newChatRoom;
  }
}","/** 
 * Creates a <tt>AdHocChatRoom</tt> instance from the specified Yahoo conference.
 * @param yahooConference The chat room model from the yahoo lib.
 * @return AdHocChatRoom the chat room that we've just created.
 */
private AdHocChatRoomYahooImpl createLocalChatRoomInstance(YahooConference yahooConference,String inviterID){
synchronized (chatRoomCache) {
    AdHocChatRoomYahooImpl newChatRoom=new AdHocChatRoomYahooImpl(yahooConference,yahooProvider);
    OperationSetPersistentPresenceYahooImpl opSetPresence=(OperationSetPersistentPresenceYahooImpl)yahooProvider.getOperationSet(OperationSetPersistentPresence.class);
    newChatRoom.addChatRoomParticipant(opSetPresence.findContactByID(inviterID));
    chatRoomCache.put(yahooConference.getName(),newChatRoom);
    return newChatRoom;
  }
}",0.8
103806,"/** 
 * Checks if the contained call is a conference call.
 * @return <code>true</code> if the contained <tt>Call</tt> is a conferencecall, otherwise - returns <code>false</code>.
 */
public boolean isConference(){
  if (call.isConferenceFocus() && call.getCallPeerCount() > 1)   return true;
  Iterator<? extends CallPeer> callPeers=call.getCallPeers();
  while (callPeers.hasNext()) {
    CallPeer callPeer=callPeers.next();
    if (callPeer.isConferenceFocus())     return true;
  }
  return false;
}","/** 
 * Checks if the contained call is a conference call.
 * @return <code>true</code> if the contained <tt>Call</tt> is a conferencecall, otherwise - returns <code>false</code>.
 */
public boolean isConference(){
  if (call.isConferenceFocus())   return true;
  Iterator<? extends CallPeer> callPeers=call.getCallPeers();
  while (callPeers.hasNext()) {
    CallPeer callPeer=callPeers.next();
    if (callPeer.isConferenceFocus())     return true;
  }
  return false;
}",0.5887179487179487
103807,"/** 
 * Updates the sound level bar to reflect the new sound level value.
 * @param soundLevel the new sound level value
 */
public void updateSoundBar(int soundLevel){
  soundIndicator.updateSoundLevel(soundLevel);
}","/** 
 * Updates the sound level bar to reflect the new sound level value.
 * @param soundLevel the new sound level value
 */
public void updateSoundBar(int soundLevel){
  if (soundIndicator != null)   soundIndicator.updateSoundLevel(soundLevel);
}",0.9353448275862069
103808,"/** 
 * Enables or disables the single conference focus user interface.
 * @param isSingleFocusUI indicates if we should enable or disable theconference focus user interface.
 */
public void setSingleFocusUI(boolean isSingleFocusUI){
  this.isSingleFocusUI=isSingleFocusUI;
  if (isSingleFocusUI) {
    this.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
    this.remove(titleBar);
    this.remove(peerDetailsPanel);
  }
 else {
    this.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridx=0;
    constraints.gridy=0;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(0,0,0,0);
    this.add(titleBar,constraints);
    constraints.fill=GridBagConstraints.BOTH;
    constraints.gridx=0;
    constraints.gridy=1;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(0,0,0,0);
    this.add(peerDetailsPanel,constraints);
  }
  this.revalidate();
  this.repaint();
}","/** 
 * Enables or disables the single conference focus user interface.
 * @param isSingleFocusUI indicates if we should enable or disable theconference focus user interface.
 */
public void setSingleFocusUI(boolean isSingleFocusUI){
  if (!isFocusUI)   return;
  this.isSingleFocusUI=isSingleFocusUI;
  if (isSingleFocusUI) {
    this.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
    this.remove(titleBar);
    this.remove(peerDetailsPanel);
  }
 else {
    this.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridx=0;
    constraints.gridy=0;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(0,0,0,0);
    this.add(titleBar,constraints);
    constraints.fill=GridBagConstraints.BOTH;
    constraints.gridx=0;
    constraints.gridy=1;
    constraints.weightx=1;
    constraints.weighty=0;
    constraints.insets=new Insets(0,0,0,0);
    this.add(peerDetailsPanel,constraints);
  }
  this.revalidate();
  this.repaint();
}",0.9863945578231292
103809,"/** 
 * Creates a <tt>ConferencePeerPanel</tt>, that would be contained in the given <tt>callDialog</tt> and would correspond to the given <tt>callPeer</tt>.
 * @param callDialog the dialog, in which this panel is shown
 * @param callPeer The peer who own this UI
 */
public ConferencePeerPanel(CallDialog callDialog,CallPeer callPeer){
  this.callDialog=callDialog;
  this.callPeer=callPeer;
  this.setPeerName(callPeer.getDisplayName());
  if (callPeer.isConferenceFocus())   setFocusUI(true);
  this.initStatusBar(callPeer);
  callPeerMenu=new CallPeerMenu(callPeer);
  SIPCommMenuBar menuBar=new SIPCommMenuBar();
  menuBar.setLayout(new FlowLayout(FlowLayout.CENTER,0,0));
  menuBar.add(callPeerMenu);
  this.addToNameBar(menuBar);
  this.setTitleBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  for (  ConferenceMember member : callPeer.getConferenceMembers())   this.addConferenceMemberPanel(member);
}","/** 
 * Creates a <tt>ConferencePeerPanel</tt>, that would be contained in the given <tt>callDialog</tt> and would correspond to the given <tt>callPeer</tt>.
 * @param callDialog the dialog, in which this panel is shown
 * @param callPeer The peer who own this UI
 */
public ConferencePeerPanel(CallDialog callDialog,CallPeer callPeer){
  this.callDialog=callDialog;
  this.callPeer=callPeer;
  this.setPeerName(callPeer.getDisplayName());
  if (callPeer.getConferenceMemberCount() > 0)   setFocusUI(true);
  this.initStatusBar(callPeer);
  callPeerMenu=new CallPeerMenu(callPeer);
  SIPCommMenuBar menuBar=new SIPCommMenuBar();
  menuBar.setLayout(new FlowLayout(FlowLayout.CENTER,0,0));
  menuBar.add(callPeerMenu);
  this.addToNameBar(menuBar);
  this.setTitleBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  for (  ConferenceMember member : callPeer.getConferenceMembers())   this.addConferenceMemberPanel(member);
}",0.9846965699208444
103810,"/** 
 * Removes the corresponding <tt>ConferenceMemberPanel</tt> from this container when a <tt>ConferenceMember</tt> has been removed from the corresponding conference.
 * @param conferenceEvent the <tt>CallPeerConferenceEvent</tt> that has beentriggered
 */
public void conferenceMemberRemoved(CallPeerConferenceEvent conferenceEvent){
  ConferenceMember member=conferenceEvent.getConferenceMember();
  this.removeConferenceMemberPanel(member);
}","/** 
 * Removes the corresponding <tt>ConferenceMemberPanel</tt> from this container when a <tt>ConferenceMember</tt> has been removed from the corresponding conference.
 * @param conferenceEvent the <tt>CallPeerConferenceEvent</tt> that has beentriggered
 */
public void conferenceMemberRemoved(CallPeerConferenceEvent conferenceEvent){
  ConferenceMember member=conferenceEvent.getConferenceMember();
  if (callPeer.getConferenceMemberCount() == 0 && isFocusUI())   setFocusUI(false);
  this.removeConferenceMemberPanel(member);
}",0.9061224489795918
103811,"/** 
 * Delivers <tt>SoundLevelChangeEvent</tt>s on stream sound level change.
 * @param evt the notification event containing the list of changes.
 */
public void soundLevelChanged(SoundLevelChangeEvent evt){
  Object evtSource=evt.getSource();
  if ((evtSource instanceof CallPeer) && ((CallPeer)evtSource).isConferenceFocus())   updateSoundBar(evt.getLevel());
}","/** 
 * Delivers <tt>SoundLevelChangeEvent</tt>s on stream sound level change.
 * @param evt the notification event containing the list of changes.
 */
public void soundLevelChanged(SoundLevelChangeEvent evt){
  Object evtSource=evt.getSource();
  if (evtSource.equals(callPeer)) {
    updateSoundBar(evt.getLevel());
  }
}",0.8604651162790697
103812,"/** 
 * Enables or disables the conference focus UI depending on the change. When a peer changes its status from focus to not focus or the reverse. we must change its listeners. If the peer is focus we use conference member lister, cause we will receive its status and the statuses of its conference members. And if it is not a focus we must listen with stream sound level listener
 * @param conferenceEvent the conference event
 */
public void conferenceFocusChanged(CallPeerConferenceEvent conferenceEvent){
  if (conferenceEvent.getSourceCallPeer().equals(callPeer))   setFocusUI(callPeer.isConferenceFocus());
}","/** 
 * Enables or disables the conference focus UI depending on the change. When a peer changes its status from focus to not focus or the reverse. we must change its listeners. If the peer is focus we use conference member lister, cause we will receive its status and the statuses of its conference members. And if it is not a focus we must listen with stream sound level listener
 * @param conferenceEvent the conference event
 */
public void conferenceFocusChanged(CallPeerConferenceEvent conferenceEvent){
  if (conferenceEvent.getSourceCallPeer().equals(callPeer) && !callPeer.isConferenceFocus() && isFocusUI())   setFocusUI(false);
}",0.9370517928286852
103813,"/** 
 * Adds a <tt>ConferenceMemberPanel</tt> to this container when a <tt>ConferenceMember</tt> has been added to the corresponding conference.
 * @param conferenceEvent the <tt>CallPeerConferenceEvent</tt> that has beentriggered
 */
public void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent){
  ConferenceMember member=conferenceEvent.getConferenceMember();
  String memberAddress=member.getAddress();
  String localUserAddress=callPeer.getProtocolProvider().getAccountID().getAccountAddress();
  if (!addressesAreEqual(memberAddress,localUserAddress))   addConferenceMemberPanel(member);
}","/** 
 * Adds a <tt>ConferenceMemberPanel</tt> to this container when a <tt>ConferenceMember</tt> has been added to the corresponding conference.
 * @param conferenceEvent the <tt>CallPeerConferenceEvent</tt> that has beentriggered
 */
public void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent){
  ConferenceMember member=conferenceEvent.getConferenceMember();
  String memberAddress=member.getAddress();
  String localUserAddress=callPeer.getProtocolProvider().getAccountID().getAccountAddress();
  if (!isFocusUI())   setFocusUI(true);
  if (!addressesAreEqual(memberAddress,localUserAddress))   addConferenceMemberPanel(member);
}",0.9681528662420382
103814,"/** 
 * Creates a new bi-dimensional array containing all entries (if any) from the <tt>levels</tt> matrix and an extra entry for the specified <tt>csrc</tt> and <tt>level</tt>.
 * @param levels the bi-dimensional levels array that we'd like to add amapping to.
 * @param csrc the CSRC identifier that we'd like to add to the<tt>levels</tt> bi-dimensional array.
 * @param level the level corresponding to the <tt>csrc</tt> identifier.
 * @return a new matrix containing all entries from levels and a new onemapping <tt>csrc</tt> to <tt>level</tt>
 */
private long[][] appendCSRCToMatrix(long[][] levels,long csrc,int level){
  int newLength=1;
  if (levels != null && levels.length > 0) {
    newLength=levels.length + 1;
  }
  long[][] newLevels=new long[newLength][2];
  levels[0][0]=csrc;
  levels[0][1]=level;
  if (newLength == 1)   return newLevels;
  for (int i=0; i < levels.length; i++) {
    newLevels[i + 1][0]=levels[i][0];
    newLevels[i + 1][1]=levels[i][1];
  }
  return newLevels;
}","/** 
 * Creates a new bi-dimensional array containing all entries (if any) from the <tt>levels</tt> matrix and an extra entry for the specified <tt>csrc</tt> and <tt>level</tt>.
 * @param levels the bi-dimensional levels array that we'd like to add amapping to.
 * @param csrc the CSRC identifier that we'd like to add to the<tt>levels</tt> bi-dimensional array.
 * @param level the level corresponding to the <tt>csrc</tt> identifier.
 * @return a new matrix containing all entries from levels and a new onemapping <tt>csrc</tt> to <tt>level</tt>
 */
private long[][] appendCSRCToMatrix(long[][] levels,long csrc,int level){
  int newLength=1;
  if (levels != null && levels.length > 0) {
    newLength=levels.length + 1;
  }
  long[][] newLevels=new long[newLength][2];
  newLevels[0][0]=csrc;
  newLevels[0][1]=level;
  if (newLength == 1)   return newLevels;
  for (int i=0; i < levels.length; i++) {
    newLevels[i + 1][0]=levels[i][0];
    newLevels[i + 1][1]=levels[i][1];
  }
  return newLevels;
}",0.9950149551345964
103815,"/** 
 * Notifies this <tt>AudioMixer</tt> that an output <tt>AudioMixingPushBufferDataSource</tt> reading from it has been disconnected. The last of the many <tt>AudioMixingPushBufferDataSource</tt>s reading from this <tt>AudioMixer</tt> which gets disconnected causes it to disconnect from the input <tt>DataSource</tt>s it manages.
 */
void disconnect(){
synchronized (inputDataSources) {
    if (connected <= 0)     return;
    connected--;
    if (connected == 0) {
      outputStream=null;
      for (      InputDataSourceDesc inputDataSourceDesc : inputDataSources)       inputDataSourceDesc.getEffectiveInputDataSource().disconnect();
    }
  }
}","/** 
 * Notifies this <tt>AudioMixer</tt> that an output <tt>AudioMixingPushBufferDataSource</tt> reading from it has been disconnected. The last of the many <tt>AudioMixingPushBufferDataSource</tt>s reading from this <tt>AudioMixer</tt> which gets disconnected causes it to disconnect from the input <tt>DataSource</tt>s it manages.
 */
void disconnect(){
synchronized (inputDataSources) {
    if (connected <= 0)     return;
    connected--;
    if (connected == 0) {
      for (      InputDataSourceDesc inputDataSourceDesc : inputDataSources)       inputDataSourceDesc.disconnect();
      outputStream=null;
    }
  }
}",0.7931034482758621
103816,"/** 
 * Implements   {@link PushBufferStream#getFormat()}. Returns the <tt>AudioFormat</tt> in which this instance was configured to output its data.
 * @return the <tt>AudioFormat</tt> in which this instance wasconfigured to output its data
 */
public AudioFormat getFormat(){
  return outputFormat;
}","/** 
 * Gets the <tt>Format</tt> in which a specific <tt>SourceStream</tt> provides data.
 * @param stream the <tt>SourceStream</tt> for which the <tt>Format</tt> in which it provides data is to be determined
 * @return the <tt>Format</tt> in which the specified<tt>SourceStream</tt> provides data if it was determined; otherwise, <tt>null</tt>
 */
private static Format getFormat(SourceStream stream){
  if (stream instanceof PushBufferStream)   return ((PushBufferStream)stream).getFormat();
  if (stream instanceof PullBufferStream)   return ((PullBufferStream)stream).getFormat();
  return null;
}",0.0863787375415282
103817,"/** 
 * Implements   {@link Controls#getControl(String)}. Invokes  {@link #getControls()} and then looks for a control of the specifiedtype in the returned array of controls.
 * @param controlType a <tt>String</tt> value naming the type of thecontrol of this instance to be retrieved
 * @return an <tt>Object</tt> which represents the control of thisinstance with the specified type
 */
public Object getControl(String controlType){
  return AudioMixer.getControl(this,controlType);
}","/** 
 * Gets the control of a specific <tt>Controls</tt> implementation of a specific type if such a control is made available through  {@link Controls#getControls()}; otherwise, returns <tt>null</tt>.
 * @param controlsImpl the implementation of <tt>Controls</tt> which is tobe queried for its list of controls so that the control of the specified type can be looked for
 * @param controlType a <tt>String</tt> value which names the type of thecontrol to be retrieved
 * @return an <tt>Object</tt> which represents the control of<tt>controlsImpl</tt> of the specified <tt>controlType</tt> if such a control is made available through <tt>Controls#getControls()</tt>; otherwise, <tt>null</tt>
 */
public static Object getControl(Controls controlsImpl,String controlType){
  Object[] controls=controlsImpl.getControls();
  if ((controls != null) && (controls.length > 0)) {
    Class<?> controlClass;
    try {
      controlClass=Class.forName(controlType);
    }
 catch (    ClassNotFoundException cnfe) {
      controlClass=null;
      logger.warn(""String_Node_Str"" + controlType,cnfe);
    }
    if (controlClass != null)     for (    Object control : controls)     if (controlClass.isInstance(control))     return control;
  }
  return null;
}",0.3169462116830538
103818,"/** 
 * Implements   {@link PushBufferStream#read(Buffer)}. Reads audio samples from the input <tt>SourceStreams</tt> of this instance in various formats, converts the read audio samples to one and the same format and pushes them to the output <tt>AudioMixingPushBufferStream</tt>s for the very audio mixing.
 * @param buffer the <tt>Buffer</tt> in which the audio samples readfrom the input <tt>SourceStream</tt>s are to be returned to the caller
 * @throws IOException if any of the input <tt>SourceStream</tt>s throwsuch an exception while reading from them or anything else goes wrong
 */
public void read(Buffer buffer) throws IOException {
  InputStreamDesc[] inputStreams;
synchronized (inputStreamsSyncRoot) {
    if (this.inputStreams != null)     inputStreams=this.inputStreams.clone();
 else     inputStreams=null;
  }
  int inputStreamCount=(inputStreams == null) ? 0 : inputStreams.length;
  if (inputStreamCount <= 0)   return;
  AudioFormat outputFormat=getFormat();
  InputSampleDesc inputSampleDesc=new InputSampleDesc(new int[inputStreamCount][],inputStreams);
  int maxInputSampleCount;
  try {
    maxInputSampleCount=readInputPushBufferStreams(outputFormat,inputSampleDesc);
  }
 catch (  UnsupportedFormatException ufex) {
    IOException ioex=new IOException();
    ioex.initCause(ufex);
    throw ioex;
  }
  maxInputSampleCount=Math.max(maxInputSampleCount,readInputPullBufferStreams(outputFormat,maxInputSampleCount,inputSampleDesc));
  buffer.setData(inputSampleDesc);
  buffer.setLength(maxInputSampleCount);
  long timeStamp=inputSampleDesc.getTimeStamp();
  if (timeStamp != Buffer.TIME_UNKNOWN)   buffer.setTimeStamp(timeStamp);
}","/** 
 * Reads media from a specific <tt>PushBufferStream</tt> which belongs to a specific <tt>DataSource</tt> into a specific output <tt>Buffer</tt>. Allows extenders to tap into the reading and monitor and customize it.
 * @param stream the <tt>PushBufferStream</tt> to read media from and knownto belong to the specified <tt>DataSOurce</tt>
 * @param buffer the output <tt>Buffer</tt> in which the media read from thespecified <tt>stream</tt> is to be written so that it gets returned to the caller
 * @param dataSource the <tt>DataSource</tt> from which <tt>stream</tt>originated
 * @throws IOException if anything wrong happens while reading from thespecified <tt>stream</tt>
 */
protected void read(PushBufferStream stream,Buffer buffer,DataSource dataSource) throws IOException {
  stream.read(buffer);
}",0.1254552812626467
103819,"/** 
 * Adds a new input <tt>DataSource</tt> to the collection of input <tt>DataSource</tt>s from which this instance reads audio. If the specified <tt>DataSource</tt> indeed provides audio, the respective contributions to the mix will be excluded from the mix output provided through a specific <tt>AudioMixingPushBufferDataSource</tt>.
 * @param inputDataSource a new <tt>DataSource</tt> to input audio to thisinstance
 * @param outputDataSource the <tt>AudioMixingPushBufferDataSource</tt> tonot include the audio contributions of <tt>inputDataSource</tt> in the mix it outputs
 */
void addInputDataSource(DataSource inputDataSource,AudioMixingPushBufferDataSource outputDataSource){
  if (inputDataSource == null)   throw new IllegalArgumentException(""String_Node_Str"");
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     if (inputDataSource.equals(inputDataSourceDesc.inputDataSource))     throw new IllegalArgumentException(""String_Node_Str"");
    InputDataSourceDesc inputDataSourceDesc=new InputDataSourceDesc(inputDataSource,outputDataSource);
    boolean added=inputDataSources.add(inputDataSourceDesc);
    if (added) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + inputDataSource.hashCode());
      if (connected > 0) {
        try {
          connect(inputDataSourceDesc.getEffectiveInputDataSource(),inputDataSourceDesc.inputDataSource);
        }
 catch (        IOException ioe) {
          throw new UndeclaredThrowableException(ioe);
        }
      }
      if (outputStream != null)       getOutputStream();
      if (started > 0)       try {
        inputDataSourceDesc.getEffectiveInputDataSource().start();
      }
 catch (      IOException ioe) {
        throw new UndeclaredThrowableException(ioe);
      }
    }
  }
}","/** 
 * Adds a new input <tt>DataSource</tt> to the collection of input <tt>DataSource</tt>s from which this instance reads audio. If the specified <tt>DataSource</tt> indeed provides audio, the respective contributions to the mix will be excluded from the mix output provided through a specific <tt>AudioMixingPushBufferDataSource</tt>.
 * @param inputDataSource a new <tt>DataSource</tt> to input audio to thisinstance
 * @param outputDataSource the <tt>AudioMixingPushBufferDataSource</tt> tonot include the audio contributions of <tt>inputDataSource</tt> in the mix it outputs
 */
void addInputDataSource(DataSource inputDataSource,AudioMixingPushBufferDataSource outputDataSource){
  if (inputDataSource == null)   throw new IllegalArgumentException(""String_Node_Str"");
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     if (inputDataSource.equals(inputDataSourceDesc.inputDataSource))     throw new IllegalArgumentException(""String_Node_Str"");
    InputDataSourceDesc inputDataSourceDesc=new InputDataSourceDesc(inputDataSource,outputDataSource);
    boolean added=inputDataSources.add(inputDataSourceDesc);
    if (added) {
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + inputDataSource.hashCode());
      if (connected > 0)       try {
        connect(inputDataSourceDesc.getEffectiveInputDataSource(),inputDataSourceDesc.inputDataSource);
      }
 catch (      IOException ioex) {
        throw new UndeclaredThrowableException(ioex);
      }
      if (outputStream != null)       getOutputStream();
      if (started > 0)       try {
        inputDataSourceDesc.start();
      }
 catch (      IOException ioe) {
        throw new UndeclaredThrowableException(ioe);
      }
    }
  }
}",0.9795127353266888
103820,"/** 
 * Stops the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @throws IOException
 */
void stop() throws IOException {
synchronized (inputDataSources) {
    if (started <= 0)     return;
    started--;
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.getEffectiveInputDataSource().stop();
  }
}","/** 
 * Stops the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to stop. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> stops. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to stop it
 */
void stop(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started <= 0)     return;
    started--;
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.stop();
  }
}",0.5633575464083939
103821,"/** 
 * Gets the <tt>SourceStream</tt>s (in the form of <tt>InputStreamDesc</tt>) of the <tt>DataSource</tt>s from which this <tt>AudioMixer</tt> reads data which produce data in a specific <tt>AudioFormat</tt>. When an input <tt>DataSource</tt> does not have such <tt>SourceStream</tt>s, an attempt is made to transcode its tracks so that such <tt>SourceStream</tt>s can be retrieved from it after transcoding.
 * @param outputFormat the <tt>AudioFormat</tt> in which the retrieved <tt>SourceStream</tt>s are to produce data
 * @param existingInputStreams
 * @return a new collection of <tt>SourceStream</tt>s (in the form of<tt>InputStreamDesc</tt>) retrieved from the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and producing data in the specified <tt>AudioFormat</tt>
 * @throws IOException
 */
private Collection<InputStreamDesc> getInputStreamsFromInputDataSources(AudioFormat outputFormat,InputStreamDesc[] existingInputStreams) throws IOException {
  List<InputStreamDesc> inputStreams=new ArrayList<InputStreamDesc>();
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources) {
      boolean got=getInputStreamsFromInputDataSource(inputDataSourceDesc,outputFormat,existingInputStreams,inputStreams);
      if (!got) {
        DataSource transcodingDataSource=createTranscodingDataSource(inputDataSourceDesc.getEffectiveInputDataSource(),outputFormat);
        if (transcodingDataSource != null) {
          inputDataSourceDesc.setTranscodingDataSource(transcodingDataSource);
          getInputStreamsFromInputDataSource(inputDataSourceDesc,outputFormat,existingInputStreams,inputStreams);
        }
      }
    }
  }
  return inputStreams;
}","/** 
 * Gets the <tt>SourceStream</tt>s (in the form of <tt>InputStreamDesc</tt>) of the <tt>DataSource</tt>s from which this <tt>AudioMixer</tt> reads data which produce data in a specific <tt>AudioFormat</tt>. When an input <tt>DataSource</tt> does not have such <tt>SourceStream</tt>s, an attempt is made to transcode its tracks so that such <tt>SourceStream</tt>s can be retrieved from it after transcoding.
 * @param outputFormat the <tt>AudioFormat</tt> in which the retrieved<tt>SourceStream</tt>s are to produce data
 * @param existingInputStreams the <tt>SourceStream</tt>s which are alreadyknown to this <tt>AudioMixer</tt>
 * @return a new collection of <tt>SourceStream</tt>s (in the form of<tt>InputStreamDesc</tt>) retrieved from the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and producing data in the specified <tt>AudioFormat</tt>
 * @throws IOException if anything wrong goes while retrieving the input<tt>SourceStream</tt>s from the input <tt>DataSource</tt>s
 */
private Collection<InputStreamDesc> getInputStreamsFromInputDataSources(AudioFormat outputFormat,InputStreamDesc[] existingInputStreams) throws IOException {
  List<InputStreamDesc> inputStreams=new ArrayList<InputStreamDesc>();
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources) {
      boolean got=getInputStreamsFromInputDataSource(inputDataSourceDesc,outputFormat,existingInputStreams,inputStreams);
      if (!got) {
        DataSource transcodingDataSource=createTranscodingDataSource(inputDataSourceDesc.getEffectiveInputDataSource(),outputFormat);
        if (transcodingDataSource != null) {
          inputDataSourceDesc.setTranscodingDataSource(transcodingDataSource);
          getInputStreamsFromInputDataSource(inputDataSourceDesc,outputFormat,existingInputStreams,inputStreams);
        }
      }
    }
  }
  return inputStreams;
}",0.9481850928234968
103822,"/** 
 * Starts the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @throws IOException
 */
void start() throws IOException {
synchronized (inputDataSources) {
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.getEffectiveInputDataSource().start();
    started++;
  }
}","/** 
 * Starts the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt>.
 * @param outputStream the <tt>AudioMixerPushBufferStream</tt> whichrequests this <tt>AudioMixer</tt> to start. If <tt>outputStream</tt> is the current one and only <tt>AudioMixerPushBufferStream</tt> of this <tt>AudioMixer</tt>, this <tt>AudioMixer</tt> starts if it hasn't started yet. Otherwise, the request is ignored.
 * @throws IOException if any of the input <tt>DataSource</tt>s of this<tt>AudioMixer</tt> throws such an exception while attempting to start it
 */
void start(AudioMixerPushBufferStream outputStream) throws IOException {
synchronized (inputDataSources) {
    if (this.outputStream != outputStream)     return;
    if (started == 0)     for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources)     inputDataSourceDesc.start();
    started++;
  }
}",0.5278008298755187
103823,"/** 
 * Gets the <tt>AudioMixerPushBufferStream</tt>, first creating it if it does not exist already, which reads data from the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and pushes it to output <tt>AudioMixingPushBufferStream</tt>s for audio mixing.
 * @return the <tt>AudioMixerPushBufferStream</tt> which reads data fromthe input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and pushes it to output <tt>AudioMixingPushBufferStream</tt>s for audio mixing
 */
AudioMixerPushBufferStream getOutputStream(){
synchronized (inputDataSources) {
    AudioFormat outputFormat=getOutputFormatFromInputDataSources();
    setOutputFormatToInputDataSources(outputFormat);
    Collection<InputStreamDesc> inputStreams;
    try {
      inputStreams=getInputStreamsFromInputDataSources(outputFormat,(outputStream == null) ? null : outputStream.getInputStreams());
    }
 catch (    IOException ex) {
      throw new UndeclaredThrowableException(ex);
    }
    if (inputStreams.size() <= 0)     outputStream=null;
 else {
      if (outputStream == null)       outputStream=new AudioMixerPushBufferStream(outputFormat);
      outputStream.setInputStreams(inputStreams);
    }
    return outputStream;
  }
}","/** 
 * Gets the <tt>AudioMixerPushBufferStream</tt>, first creating it if it does not exist already, which reads data from the input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and pushes it to output <tt>AudioMixingPushBufferStream</tt>s for audio mixing.
 * @return the <tt>AudioMixerPushBufferStream</tt> which reads data fromthe input <tt>DataSource</tt>s of this <tt>AudioMixer</tt> and pushes it to output <tt>AudioMixingPushBufferStream</tt>s for audio mixing
 */
AudioMixerPushBufferStream getOutputStream(){
synchronized (inputDataSources) {
    AudioFormat outputFormat=(outputStream == null) ? getOutputFormatFromInputDataSources() : outputStream.getFormat();
    setOutputFormatToInputDataSources(outputFormat);
    Collection<InputStreamDesc> inputStreams;
    try {
      inputStreams=getInputStreamsFromInputDataSources(outputFormat,(outputStream == null) ? null : outputStream.getInputStreams());
    }
 catch (    IOException ioex) {
      throw new UndeclaredThrowableException(ioex);
    }
    if (outputStream == null)     outputStream=new AudioMixerPushBufferStream(this,outputFormat);
    outputStream.setInputStreams(inputStreams);
    return outputStream;
  }
}",0.9232693911592994
103824,"public void disconnect(){
  try {
    stop();
  }
 catch (  IOException ex) {
    throw new UndeclaredThrowableException(ex);
  }
  if (connected) {
    outputStream=null;
    connected=false;
    audioMixer.disconnect();
  }
}","/** 
 * Implements   {@link DataSource#disconnect()}. Marks this <tt>DataSource</tt> as disconnected and notifies the <tt>AudioMixer</tt> that one of its output <tt>PushBufferDataSources</tt> has been disconnected.
 */
public synchronized void disconnect(){
  try {
    stop();
  }
 catch (  IOException ioex) {
    throw new UndeclaredThrowableException(ioex);
  }
  if (connected) {
    outputStream=null;
    connected=false;
    audioMixer.disconnect();
  }
}",0.6434782608695652
103825,"/** 
 * Implements DataSource#getControl(String).
 * @param controlType a <tt>String</tt> value which names the type of thecontrol of this instance to be retrieved
 * @return an <tt>Object</tt> which represents the control of this instancewith the specified type if such a control is available; otherwise, <tt>null</tt>
 */
public Object getControl(String controlType){
  return AudioMixer.getControl(this,controlType);
}","/** 
 * Implements   {@link DataSource#getControl(String)}.
 * @param controlType a <tt>String</tt> value which names the type of thecontrol of this instance to be retrieved
 * @return an <tt>Object</tt> which represents the control of this instancewith the specified type if such a control is available; otherwise, <tt>null</tt>
 */
public Object getControl(String controlType){
  return AudioMixer.getControl(this,controlType);
}",0.988262910798122
103826,"/** 
 * Implements DataSource#getControls(). Gets an array of <tt>Object</tt>s which represent the controls available for this <tt>DataSource</tt>.
 * @return an array of <tt>Object</tt>s which represent the controlsavailable for this <tt>DataSource</tt>
 */
public Object[] getControls(){
  return getFormatControls();
}","/** 
 * Implements   {@link DataSource#getControls()}. Gets an array of <tt>Object</tt>s which represent the controls available for this <tt>DataSource</tt>.
 * @return an array of <tt>Object</tt>s which represent the controlsavailable for this <tt>DataSource</tt>
 */
public Object[] getControls(){
  BufferControl bufferControl=getBufferControl();
  FormatControl[] formatControls=getFormatControls();
  if (bufferControl == null)   return formatControls;
 else   if ((formatControls == null) || (formatControls.length < 1))   return new Object[]{bufferControl};
 else {
    Object[] controls=new Object[1 + formatControls.length];
    controls[0]=bufferControl;
    System.arraycopy(formatControls,0,controls,1,formatControls.length);
    return controls;
  }
}",0.5788018433179724
103827,"public FormatControl[] getFormatControls(){
  return audioMixer.getFormatControls();
}","/** 
 * Implements   {@link CaptureDevice#getFormatControls()}. Delegates to the associated <tt>AudioMixer</tt> because it knows which <tt>CaptureDevice</tt> is being wrapped.
 * @return an array of <tt>FormatControl</tt>s of the <tt>CaptureDevice</tt>of the associated <tt>AudioMixer</tt>
 */
public FormatControl[] getFormatControls(){
  return audioMixer.getFormatControls();
}",0.3690987124463519
103828,"/** 
 * Adds a new input <tt>DataSource</tt> to be mixed by the associated <tt>AudioMixer</tt> of this instance and to not have its audio contributions included in the mixing output represented by this <tt>DataSource</tt>.
 * @param inputDataSource a <tt>DataSource</tt> to be added for mixingto the <tt>AudioMixer</tt> associate with this instance and to not have its audio contributions included in the mixing output represented by this <tt>DataSource</tt>
 */
public void addInputDataSource(DataSource inputDataSource){
  audioMixer.addInputDataSource(inputDataSource,this);
}","/** 
 * Adds a new input <tt>DataSource</tt> to be mixed by the associated <tt>AudioMixer</tt> of this instance and to not have its audio contributions included in the mixing output represented by this <tt>DataSource</tt>.
 * @param inputDataSource a <tt>DataSource</tt> to be added for mixing tothe <tt>AudioMixer</tt> associate with this instance and to not have its audio contributions included in the mixing output represented by this <tt>DataSource</tt>
 */
public void addInputDataSource(DataSource inputDataSource){
  audioMixer.addInputDataSource(inputDataSource,this);
}",0.9948186528497408
103829,"public void start() throws IOException {
  if (!started) {
    if (outputStream != null)     outputStream.start();
    audioMixer.start();
    started=true;
  }
}","/** 
 * Implements   {@link DataSource#start()}. Starts the output <tt>PushBufferStream</tt> of this <tt>DataSource</tt> (if it exists) and notifies the <tt>AudioMixer</tt> that one of its output <tt>PushBufferDataSources</tt> has been started.
 * @throws IOException if anything wrong happens while starting the output<tt>PushBufferStream</tt> of this <tt>DataSource</tt>
 */
public synchronized void start() throws IOException {
  if (!started) {
    started=true;
    if (outputStream != null)     outputStream.start();
  }
}",0.3130434782608696
103830,"public CaptureDeviceInfo getCaptureDeviceInfo(){
  return audioMixer.getCaptureDeviceInfo();
}","/** 
 * Implements   {@link CaptureDevice#getCaptureDeviceInfo()}. Delegates to the associated <tt>AudioMixer</tt> because it knows which <tt>CaptureDevice</tt> is being wrapped.
 * @return the <tt>CaptureDeviceInfo</tt> of the <tt>CaptureDevice</tt> ofthe <tt>AudioMixer</tt>
 */
public CaptureDeviceInfo getCaptureDeviceInfo(){
  return audioMixer.getCaptureDeviceInfo();
}",0.4008528784648187
103831,"public Time getDuration(){
  return audioMixer.getDuration();
}","/** 
 * Implements   {@link DataSource#getDuration()}. Delegates to the associated <tt>AudioMixer</tt> because it manages the inputs and knows their characteristics.
 * @return a <tt>Time</tt> value which represents the duration of the mediabeing made available through this <tt>DataSource</tt>
 */
public Time getDuration(){
  return audioMixer.getDuration();
}",0.2964705882352941
103832,"public void stop() throws IOException {
  if (started) {
    audioMixer.stop();
    if (outputStream != null)     outputStream.stop();
    started=false;
  }
}","/** 
 * Implements   {@link DataSource#stop()}. Notifies the <tt>AudioMixer</tt> that one of its output <tt>PushBufferDataSources</tt> has been stopped and stops the output <tt>PushBufferStream</tt> of this <tt>DataSource</tt> (if it exists).
 * @throws IOException if anything wrong happens while stopping the output<tt>PushBufferStream</tt> of this <tt>DataSource</tt>
 */
public synchronized void stop() throws IOException {
  if (started) {
    started=false;
    if (outputStream != null)     outputStream.stop();
  }
}",0.1815519765739385
103833,"public String getContentType(){
  return audioMixer.getContentType();
}","/** 
 * Implements   {@link DataSource#getContentType()}. Delegates to the associated <tt>AudioMixer</tt> because it manages the inputs and knows their characteristics.
 * @return a <tt>String</tt> value which represents the type of the contentbeing made available by this <tt>DataSource</tt> i.e. the associated <tt>AudioMixer</tt>
 */
public String getContentType(){
  return audioMixer.getContentType();
}",0.2964509394572025
103834,"public PushBufferStream[] getStreams(){
  if (outputStream == null) {
    AudioMixer.AudioMixerPushBufferStream audioMixerOutputStream=audioMixer.getOutputStream();
    if (audioMixerOutputStream != null) {
      outputStream=new AudioMixingPushBufferStream(audioMixerOutputStream,this);
      if (started)       outputStream.start();
    }
  }
  return (outputStream == null) ? new PushBufferStream[0] : new PushBufferStream[]{outputStream};
}","/** 
 * Implements   {@link PushBufferDataSource#getStreams()}. Gets a <tt>PushBufferStream</tt> which reads data from the associated <tt>AudioMixer</tt> and mixes its inputs.
 * @return an array with a single <tt>PushBufferStream</tt> which reads datafrom the associated <tt>AudioMixer</tt> and mixes its inputs if this <tt>DataSource</tt> is connected; otherwise, an empty array
 */
public synchronized PushBufferStream[] getStreams(){
  if (connected && (outputStream == null)) {
    AudioMixerPushBufferStream audioMixerOutputStream=audioMixer.getOutputStream();
    if (audioMixerOutputStream != null) {
      outputStream=new AudioMixingPushBufferStream(audioMixerOutputStream,this);
      if (started)       try {
        outputStream.start();
      }
 catch (      IOException ioex) {
        logger.error(""String_Node_Str"" + outputStream.getClass().getSimpleName() + ""String_Node_Str""+ outputStream.hashCode(),ioex);
      }
    }
  }
  return (outputStream == null) ? new PushBufferStream[0] : new PushBufferStream[]{outputStream};
}",0.5823806321452589
103835,"public void connect() throws IOException {
  if (!connected) {
    audioMixer.connect();
    connected=true;
  }
}","/** 
 * Implements   {@link DataSource#connect()}. Lets the <tt>AudioMixer</tt> know that one of its output <tt>PushBufferDataSources</tt> has been connected and marks this <tt>DataSource</tt> as connected.
 * @throws IOException if the <tt>AudioMixer</tt> fails to connect
 */
public synchronized void connect() throws IOException {
  if (!connected) {
    audioMixer.connect();
    connected=true;
  }
}",0.3969171483622351
103836,"/** 
 * Creates a new <tt>MediaDescription</tt> instance according to the specified <tt>formats</tt>, <tt>connector</tt> and <tt>direction</tt>, and using the <tt>dynamicPayloadTypes</tt> registry to handle dynamic payload type registrations. The type (e.g. audio/video) of the media description is determined via from the type of the first <tt>MediaFormat</tt> in the <tt>formats</tt> list.
 * @param formats the list of formats that should be advertised in the newlycreated <tt>MediaDescription</tt>.
 * @param connector the socket couple that will be used for the media streamwhich we are advertising with the media description created here.
 * @param direction the direction of the media stream that we are describinghere.
 * @param supportedExtensions a list of <tt>RTPExtension</tt>s supported by the<tt>MediaDevice</tt> that we will be advertising.
 * @param dynamicPayloadTypes a reference to the<tt>DynamicPayloadTypeRegistry</tt> that we should be using to lookup and register dynamic RTP mappings.
 * @param rtpExtensionsRegistry a reference to the<tt>DynamicRTPExtensionRegistry</tt> that we should be using to lookup and register URN to ID mappings.
 * @return the newly create SDP <tt>MediaDescription</tt>.
 * @throws OperationFailedException in case we fail to get payload typenumbers for dynamic payload types or in case our SDP generation fails for some other reason.
 */
public static MediaDescription createMediaDescription(List<MediaFormat> formats,StreamConnector connector,MediaDirection direction,List<RTPExtension> supportedExtensions,DynamicPayloadTypeRegistry dynamicPayloadTypes,DynamicRTPExtensionsRegistry rtpExtensionsRegistry) throws OperationFailedException {
  int[] payloadTypesArray=new int[formats.size()];
  Vector<Attribute> mediaAttributes=new Vector<Attribute>(2 * payloadTypesArray.length + 1);
  MediaType mediaType=null;
  if (direction != MediaDirection.SENDRECV)   mediaAttributes.add(createDirectionAttribute(direction));
  for (int i=0; i < payloadTypesArray.length; i++) {
    MediaFormat format=formats.get(i);
    MediaType fmtMediaType=format.getMediaType();
    if (mediaType == null) {
      mediaType=fmtMediaType;
    }
    byte payloadType=format.getRTPPayloadType();
    if (payloadType == MediaFormat.RTP_PAYLOAD_TYPE_UNKNOWN) {
      try {
        payloadType=dynamicPayloadTypes.obtainPayloadTypeNumber(format);
      }
 catch (      IllegalStateException exception) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exception);
      }
    }
    String numChannelsStr=""String_Node_Str"";
    if (format instanceof AudioMediaFormat) {
      int channels=((AudioMediaFormat)format).getChannels();
      if (channels > 1)       numChannelsStr=""String_Node_Str"" + channels;
    }
    Attribute rtpmap=sdpFactory.createAttribute(SdpConstants.RTPMAP,payloadType + ""String_Node_Str"" + format.getEncoding()+ ""String_Node_Str""+ format.getClockRateString()+ numChannelsStr);
    mediaAttributes.add(rtpmap);
    if (format.getFormatParameters().size() > 0) {
      Attribute fmtp=sdpFactory.createAttribute(""String_Node_Str"",payloadType + ""String_Node_Str"" + encodeFmtp(format));
      mediaAttributes.add(fmtp);
    }
    payloadTypesArray[i]=payloadType;
  }
  int rtpPort=connector.getDataSocket().getLocalPort();
  int rtcpPort=connector.getControlSocket().getLocalPort();
  if ((rtpPort + 1) != rtcpPort) {
    Attribute rtcpAttr=sdpFactory.createAttribute(RTCP_ATTR,Integer.toString(rtcpPort));
    mediaAttributes.add(rtcpAttr);
  }
  for (  RTPExtension extension : supportedExtensions) {
    byte extID=rtpExtensionsRegistry.obtainExtensionMapping(extension);
    String uri=extension.getURI().toString();
    MediaDirection extDirection=extension.getDirection();
    String attributes=extension.getExtensionAttributes();
    String attrValue=Byte.toString(extID) + ((extDirection == MediaDirection.SENDRECV) ? ""String_Node_Str"" : (""String_Node_Str"" + extDirection.toString())) + ""String_Node_Str""+ uri+ (attributes == null ? ""String_Node_Str"" : (""String_Node_Str"" + attributes));
    Attribute extMapAttr=sdpFactory.createAttribute(EXTMAP_ATTR,attrValue);
    mediaAttributes.add(extMapAttr);
  }
  MediaDescription mediaDesc=null;
  try {
    mediaDesc=sdpFactory.createMediaDescription(mediaType.toString(),connector.getDataSocket().getLocalPort(),1,SdpConstants.RTP_AVP,payloadTypesArray);
    mediaDesc.setAttributes(mediaAttributes);
  }
 catch (  Exception cause) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,cause,logger);
  }
  return mediaDesc;
}","/** 
 * Creates a new <tt>MediaDescription</tt> instance according to the specified <tt>formats</tt>, <tt>connector</tt> and <tt>direction</tt>, and using the <tt>dynamicPayloadTypes</tt> registry to handle dynamic payload type registrations. The type (e.g. audio/video) of the media description is determined via from the type of the first <tt>MediaFormat</tt> in the <tt>formats</tt> list.
 * @param formats the list of formats that should be advertised in the newlycreated <tt>MediaDescription</tt>.
 * @param connector the socket couple that will be used for the media streamwhich we are advertising with the media description created here.
 * @param direction the direction of the media stream that we are describinghere.
 * @param rtpExtensions a list of <tt>RTPExtension</tt>s supported by the<tt>MediaDevice</tt> that we will be advertising.
 * @param dynamicPayloadTypes a reference to the<tt>DynamicPayloadTypeRegistry</tt> that we should be using to lookup and register dynamic RTP mappings.
 * @param rtpExtensionsRegistry a reference to the<tt>DynamicRTPExtensionRegistry</tt> that we should be using to lookup and register URN to ID mappings.
 * @return the newly create SDP <tt>MediaDescription</tt>.
 * @throws OperationFailedException in case we fail to get payload typenumbers for dynamic payload types or in case our SDP generation fails for some other reason.
 */
public static MediaDescription createMediaDescription(List<MediaFormat> formats,StreamConnector connector,MediaDirection direction,List<RTPExtension> rtpExtensions,DynamicPayloadTypeRegistry dynamicPayloadTypes,DynamicRTPExtensionsRegistry rtpExtensionsRegistry) throws OperationFailedException {
  int[] payloadTypesArray=new int[formats.size()];
  Vector<Attribute> mediaAttributes=new Vector<Attribute>(2 * payloadTypesArray.length + 1);
  MediaType mediaType=null;
  if (direction != MediaDirection.SENDRECV)   mediaAttributes.add(createDirectionAttribute(direction));
  for (int i=0; i < payloadTypesArray.length; i++) {
    MediaFormat format=formats.get(i);
    MediaType fmtMediaType=format.getMediaType();
    if (mediaType == null) {
      mediaType=fmtMediaType;
    }
    byte payloadType=format.getRTPPayloadType();
    if (payloadType == MediaFormat.RTP_PAYLOAD_TYPE_UNKNOWN) {
      try {
        payloadType=dynamicPayloadTypes.obtainPayloadTypeNumber(format);
      }
 catch (      IllegalStateException exception) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exception);
      }
    }
    String numChannelsStr=""String_Node_Str"";
    if (format instanceof AudioMediaFormat) {
      int channels=((AudioMediaFormat)format).getChannels();
      if (channels > 1)       numChannelsStr=""String_Node_Str"" + channels;
    }
    Attribute rtpmap=sdpFactory.createAttribute(SdpConstants.RTPMAP,payloadType + ""String_Node_Str"" + format.getEncoding()+ ""String_Node_Str""+ format.getClockRateString()+ numChannelsStr);
    mediaAttributes.add(rtpmap);
    if (format.getFormatParameters().size() > 0) {
      Attribute fmtp=sdpFactory.createAttribute(""String_Node_Str"",payloadType + ""String_Node_Str"" + encodeFmtp(format));
      mediaAttributes.add(fmtp);
    }
    payloadTypesArray[i]=payloadType;
  }
  int rtpPort=connector.getDataSocket().getLocalPort();
  int rtcpPort=connector.getControlSocket().getLocalPort();
  if ((rtpPort + 1) != rtcpPort) {
    Attribute rtcpAttr=sdpFactory.createAttribute(RTCP_ATTR,Integer.toString(rtcpPort));
    mediaAttributes.add(rtcpAttr);
  }
  if (rtpExtensions != null && rtpExtensions.size() > 0) {
    for (    RTPExtension extension : rtpExtensions) {
      byte extID=rtpExtensionsRegistry.obtainExtensionMapping(extension);
      String uri=extension.getURI().toString();
      MediaDirection extDirection=extension.getDirection();
      String attributes=extension.getExtensionAttributes();
      String attrValue=Byte.toString(extID) + ((extDirection == MediaDirection.SENDRECV) ? ""String_Node_Str"" : (""String_Node_Str"" + extDirection.toString())) + ""String_Node_Str""+ uri+ (attributes == null ? ""String_Node_Str"" : (""String_Node_Str"" + attributes));
      Attribute extMapAttr=sdpFactory.createAttribute(EXTMAP_ATTR,attrValue);
      mediaAttributes.add(extMapAttr);
    }
  }
  MediaDescription mediaDesc=null;
  try {
    mediaDesc=sdpFactory.createMediaDescription(mediaType.toString(),connector.getDataSocket().getLocalPort(),1,SdpConstants.RTP_AVP,payloadTypesArray);
    mediaDesc.setAttributes(mediaAttributes);
  }
 catch (  Exception cause) {
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,cause,logger);
  }
  return mediaDesc;
}",0.9864359713766956
103837,"/** 
 * Creates a new <tt>RawPacket</tt> from a specific <tt>DatagramPacket</tt> in order to have this instance receive its packet data through its  {@link #read(byte[],int,int)} method. Allows extenders to intercept thepacket data and possibly filter and/or modify it.
 * @param datagramPacket the <tt>DatagramPacket</tt> containing the packetdata
 * @return a new <tt>RawPacket</tt> containing the packet data of thespecified <tt>DatagramPacket</tt> or possibly its modification; <tt>null</tt> to ignore the packet data of the specified <tt>DatagramPacket</tt> and not make it available to this instance through its  {@link #read(byte[],int,int)} method 
 */
protected RawPacket createRawPacket(DatagramPacket datagramPacket){
  return new RawPacket(datagramPacket.getData(),datagramPacket.getOffset(),datagramPacket.getLength());
}","/** 
 * Creates a new <tt>RawPacket</tt> from a specific <tt>DatagramPacket</tt> in order to have this instance receive its packet data through its  {@link #read(byte[],int,int)} method. Allows extenders to intercept thepacket data and possibly filter and/or modify it.
 * @param datagramPacket the <tt>DatagramPacket</tt> containing the packetdata
 * @return a new <tt>RawPacket</tt> containing the packet data of thespecified <tt>DatagramPacket</tt> or possibly its modification; <tt>null</tt> to ignore the packet data of the specified <tt>DatagramPacket</tt> and not make it available to this instance through its  {@link #read(byte[],int,int)} method
 */
protected RawPacket createRawPacket(DatagramPacket datagramPacket){
  return new RawPacket(datagramPacket.getData(),datagramPacket.getOffset(),datagramPacket.getLength());
}",0.9994001199760048
103838,"public Object getControl(String controlType){
  return null;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#getControl(String)} that always returns<tt>null</tt>.
 * @param controlType ignored.
 * @return <tt>null</tt>, no matter what.
 */
public Object getControl(String controlType){
  return null;
}",0.3746223564954682
103839,"public Object[] getControls(){
  return EMPTY_CONTROLS;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#getControls()} that always returns<tt>EMPTY_CONTROLS</tt>.
 * @return <tt>EMPTY_CONTROLS</tt>, no matter what.
 */
public Object[] getControls(){
  return EMPTY_CONTROLS;
}",0.3737704918032787
103840,"public int read(byte[] inBuffer,int offset,int length) throws IOException {
  if (ioError)   return -1;
  int pktLength=pkt.getLength();
  if (length < pktLength)   throw new IOException(""String_Node_Str"" + pktLength);
  System.arraycopy(pkt.getBuffer(),pkt.getOffset(),inBuffer,offset,pktLength);
  return pktLength;
}","/** 
 * Copies the content of the most recently received packet into <tt>inBuffer</tt>.
 * @param inBuffer the <tt>byte[]</tt> that we'd like to copy the contentof the packet to.
 * @param offset the position where we are supposed to start writing in<tt>inBuffer</tt>.
 * @param length the number of <tt>byte</tt>s available for writing in<tt>inBuffer</tt>.
 * @return the number of bytes read
 * @throws IOException if <tt>length</tt> is less than the size of thepacket.
 */
public int read(byte[] inBuffer,int offset,int length) throws IOException {
  if (ioError)   return -1;
  int pktLength=pkt.getLength();
  if (length < pktLength)   throw new IOException(""String_Node_Str"" + pktLength);
  System.arraycopy(pkt.getBuffer(),pkt.getOffset(),inBuffer,offset,pktLength);
  return pktLength;
}",0.3267504488330341
103841,"public boolean endOfStream(){
  return false;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#endOfStream()} that always returns<tt>false</tt>.
 * @return <tt>false</tt>, no matter what.
 */
public boolean endOfStream(){
  return false;
}",0.352059925093633
103842,"public void setTransferHandler(SourceTransferHandler transferHandler){
  if (!closed)   this.transferHandler=transferHandler;
}","/** 
 * Sets the <tt>transferHandler</tt> that this connector should be notifying when new data is available for reading.
 * @param transferHandler the <tt>transferHandler</tt> that this connectorshould be notifying when new data is available for reading.
 */
public void setTransferHandler(SourceTransferHandler transferHandler){
  if (!closed)   this.transferHandler=transferHandler;
}",0.4941634241245136
103843,"public int getMinimumTransferSize(){
  return 2 * 1024;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#getMinimumTransferSize()} that always returns<tt>2 * 1024</tt>.
 * @return <tt>2 * 1024</tt>, no matter what.
 */
public int getMinimumTransferSize(){
  return 2 * 1024;
}",0.375
103844,"public void run(){
  while (!closed) {
    DatagramPacket p=new DatagramPacket(buffer,0,65535);
    try {
      socket.receive(p);
    }
 catch (    IOException e) {
      ioError=true;
      break;
    }
    pkt=createRawPacket(p);
    if ((pkt != null) && (transferHandler != null) && !closed)     transferHandler.transferData(this);
  }
}","/** 
 * Listens for incoming datagrams, stores them for reading by the <tt>read</tt> method and notifies the local <tt>transferHandler</tt> that there's data to be read.
 */
public void run(){
  while (!closed) {
    DatagramPacket p=new DatagramPacket(buffer,0,65535);
    try {
      socket.receive(p);
    }
 catch (    IOException e) {
      ioError=true;
      break;
    }
    pkt=createRawPacket(p);
    if ((pkt != null) && (transferHandler != null) && !closed)     transferHandler.transferData(this);
  }
}",0.7967289719626168
103845,"public ContentDescriptor getContentDescriptor(){
  return null;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#getContentDescriptor()} that always returns<tt>null</tt>.
 * @return <tt>null</tt>, no matter what.
 */
public ContentDescriptor getContentDescriptor(){
  return null;
}",0.4193548387096774
103846,"public long getContentLength(){
  return LENGTH_UNKNOWN;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnectorInputStream#getContentLength()} that always returns<tt>LENGTH_UNKNOWN</tt>.
 * @return <tt>LENGTH_UNKNOWN</tt>, no matter what.
 */
public long getContentLength(){
  return LENGTH_UNKNOWN;
}",0.3717948717948718
103847,"/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #device} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
catch (    UnsupportedFormatException ufe) {
      exception=ufe;
    }
    if (exception != null) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,exception);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
  if (deviceSessionPropertyChangeListener == null)   deviceSessionPropertyChangeListener=new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent event){
      if (MediaDeviceSession.OUTPUT_DATA_SOURCE.equals(event.getPropertyName()))       deviceSessionOutputDataSourceChanged();
 else       if (MediaDeviceSession.SSRC_LIST.equals(event.getPropertyName()))       deviceSessionSsrcListChanged(event);
    }
  }
;
  deviceSession.addPropertyChangeListener(deviceSessionPropertyChangeListener);
}","/** 
 * Creates new <tt>SendStream</tt> instances for the streams of  {@link #deviceSession} through {@link #rtpManager}.
 */
private void createSendStreams(){
  RTPManager rtpManager=getRTPManager();
  MediaDeviceSession deviceSession=getDeviceSession();
  DataSource dataSource=deviceSession.getOutputDataSource();
  int streamCount;
  if (dataSource instanceof PushBufferDataSource) {
    PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PushDataSource) {
    PushSourceStream[] streams=((PushDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullBufferDataSource) {
    PullBufferStream[] streams=((PullBufferDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   if (dataSource instanceof PullDataSource) {
    PullSourceStream[] streams=((PullDataSource)dataSource).getStreams();
    streamCount=(streams == null) ? 0 : streams.length;
  }
 else   streamCount=(dataSource == null) ? 0 : 1;
  for (int streamIndex=0; streamIndex < streamCount; streamIndex++) {
    Throwable exception=null;
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,streamIndex);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + ""String_Node_Str"" + sendStream.hashCode() + ""String_Node_Str""+ toString(dataSource)+ ""String_Node_Str""+ streamIndex+ ""String_Node_Str""+ rtpManager.hashCode());
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
catch (    UnsupportedFormatException ufe) {
      exception=ufe;
    }
    if (exception != null) {
      logger.error(""String_Node_Str"" + dataSource + ""String_Node_Str""+ streamIndex,exception);
    }
  }
  sendStreamsAreCreated=true;
  if (logger.isTraceEnabled()) {
    @SuppressWarnings(""String_Node_Str"") Vector<SendStream> sendStreams=rtpManager.getSendStreams();
    int sendStreamCount=(sendStreams == null) ? 0 : sendStreams.size();
    logger.trace(""String_Node_Str"" + rtpManager.hashCode() + ""String_Node_Str""+ sendStreamCount);
  }
  if (deviceSessionPropertyChangeListener == null)   deviceSessionPropertyChangeListener=new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent event){
      if (MediaDeviceSession.OUTPUT_DATA_SOURCE.equals(event.getPropertyName()))       deviceSessionOutputDataSourceChanged();
 else       if (MediaDeviceSession.SSRC_LIST.equals(event.getPropertyName()))       deviceSessionSsrcListChanged(event);
    }
  }
;
  deviceSession.addPropertyChangeListener(deviceSessionPropertyChangeListener);
}",0.998703943714127
103848,"/** 
 * Adds a new association in this <tt>MediaStream</tt> of the specified RTP payload type with the specified <tt>MediaFormat</tt> in order to allow it to report <tt>rtpPayloadType</tt> in RTP flows sending and receiving media in <tt>format</tt>. Usually, <tt>rtpPayloadType</tt> will be in the range of dynamic RTP payload types.
 * @param rtpPayloadType the RTP payload type to be associated in this<tt>MediaStream</tt> with the specified <tt>MediaFormat</tt>
 * @param format the <tt>MediaFormat</tt> to be associated in this<tt>MediaStream</tt> with <tt>rtpPayloadType</tt>
 * @see MediaStream#addDynamicRTPPayloadType(int,MediaFormat)
 */
public void addDynamicRTPPayloadType(byte rtpPayloadType,MediaFormat format){
  MediaFormatImpl<? extends Format> mediaFormatImpl=(MediaFormatImpl<? extends Format>)format;
synchronized (dynamicRTPPayloadTypes) {
    dynamicRTPPayloadTypes.put(Byte.valueOf(rtpPayloadType),format);
    if (rtpManager != null)     rtpManager.addFormat(mediaFormatImpl.getFormat(),rtpPayloadType);
  }
}","/** 
 * Adds a new association in this <tt>MediaStream</tt> of the specified RTP payload type with the specified <tt>MediaFormat</tt> in order to allow it to report <tt>rtpPayloadType</tt> in RTP flows sending and receiving media in <tt>format</tt>. Usually, <tt>rtpPayloadType</tt> will be in the range of dynamic RTP payload types.
 * @param rtpPayloadType the RTP payload type to be associated in this<tt>MediaStream</tt> with the specified <tt>MediaFormat</tt>
 * @param format the <tt>MediaFormat</tt> to be associated in this<tt>MediaStream</tt> with <tt>rtpPayloadType</tt>
 * @see MediaStream#addDynamicRTPPayloadType(byte,MediaFormat)
 */
public void addDynamicRTPPayloadType(byte rtpPayloadType,MediaFormat format){
  MediaFormatImpl<? extends Format> mediaFormatImpl=(MediaFormatImpl<? extends Format>)format;
synchronized (dynamicRTPPayloadTypes) {
    dynamicRTPPayloadTypes.put(Byte.valueOf(rtpPayloadType),format);
    if (rtpManager != null)     rtpManager.addFormat(mediaFormatImpl.getFormat(),rtpPayloadType);
  }
}",0.9966101694915256
103849,"/** 
 * Gets the existing associations in this <tt>MediaStream</tt> of RTP payload types to <tt>MediaFormat</tt>s. The returned <tt>Map</tt> only contains associations previously added in this instance with  {@link #addDynamicRTPPayloadType(int,MediaFormat)} and not globally orwell-known associations reported by {@link MediaFormat#getRTPPayloadType()}.
 * @return a <tt>Map</tt> of RTP payload type expressed as <tt>Byte</tt> to<tt>MediaFormat</tt> describing the existing (dynamic) associations in this instance of RTP payload types to <tt>MediaFormat</tt>s. The <tt>Map</tt> represents a snapshot of the existing associations at the time of the <tt>getDynamicRTPPayloadTypes()</tt> method call and modifications to it are not reflected on the internal storage
 * @see MediaStream#getDynamicRTPPayloadTypes()
 */
public Map<Byte,MediaFormat> getDynamicRTPPayloadTypes(){
synchronized (dynamicRTPPayloadTypes) {
    return new HashMap<Byte,MediaFormat>(dynamicRTPPayloadTypes);
  }
}","/** 
 * Gets the existing associations in this <tt>MediaStream</tt> of RTP payload types to <tt>MediaFormat</tt>s. The returned <tt>Map</tt> only contains associations previously added in this instance with  {@link #addDynamicRTPPayloadType(byte,MediaFormat)} and not globally orwell-known associations reported by {@link MediaFormat#getRTPPayloadType()}.
 * @return a <tt>Map</tt> of RTP payload type expressed as <tt>Byte</tt> to<tt>MediaFormat</tt> describing the existing (dynamic) associations in this instance of RTP payload types to <tt>MediaFormat</tt>s. The <tt>Map</tt> represents a snapshot of the existing associations at the time of the <tt>getDynamicRTPPayloadTypes()</tt> method call and modifications to it are not reflected on the internal storage
 * @see MediaStream#getDynamicRTPPayloadTypes()
 */
public Map<Byte,MediaFormat> getDynamicRTPPayloadTypes(){
synchronized (dynamicRTPPayloadTypes) {
    return new HashMap<Byte,MediaFormat>(dynamicRTPPayloadTypes);
  }
}",0.9964485032978184
103850,"public void run(){
  stopped=false;
  while (!stopped) {
    byte[] dataToProcess=null;
synchronized (this) {
      if (data == null)       try {
        wait();
      }
 catch (      InterruptedException ie) {
      }
      dataToProcess=data;
      data=null;
    }
    if (dataToProcess != null) {
      int newLevel=SoundLevelIndicatorEffect.calculateCurrentSignalPower(dataToProcess,0,dataToProcess.length,SoundLevelChangeEvent.MAX_LEVEL,SoundLevelChangeEvent.MIN_LEVEL,lastLevel);
      Map<Long,Integer> lev=new HashMap<Long,Integer>();
      MediaStream parentStream=deviceSession.getParentStream();
      lev.put(parentStream.getRemoteSourceID(),newLevel);
      SoundLevelChangeEvent soundLevelEvent=new SoundLevelChangeEvent(parentStream,lev);
      List<SoundLevelListener> listeners;
synchronized (stSoundLevelListeners) {
        listeners=new ArrayList<SoundLevelListener>(stSoundLevelListeners);
      }
      for (      SoundLevelListener listener : listeners)       listener.soundLevelChanged(soundLevelEvent);
      lastLevel=newLevel;
    }
  }
}","/** 
 * Runs the actual audio level calculations.
 */
public void run(){
  stopped=false;
  while (!stopped) {
    byte[] dataToProcess=null;
synchronized (this) {
      if (data == null)       try {
        wait();
      }
 catch (      InterruptedException ie) {
      }
      dataToProcess=data;
      data=null;
    }
    if (dataToProcess != null) {
      int newLevel=SoundLevelIndicatorEffect.calculateCurrentSignalPower(dataToProcess,0,dataToProcess.length,SoundLevelChangeEvent.MAX_LEVEL,SoundLevelChangeEvent.MIN_LEVEL,lastLevel);
      Map<Long,Integer> lev=new HashMap<Long,Integer>();
      MediaStream parentStream=deviceSession.getParentStream();
      lev.put(parentStream.getRemoteSourceID(),newLevel);
      SoundLevelChangeEvent soundLevelEvent=new SoundLevelChangeEvent(parentStream,lev);
      List<SoundLevelListener> listeners;
synchronized (stSoundLevelListeners) {
        listeners=new ArrayList<SoundLevelListener>(stSoundLevelListeners);
      }
      for (      SoundLevelListener listener : listeners)       listener.soundLevelChanged(soundLevelEvent);
      lastLevel=newLevel;
    }
  }
}",0.9752973467520586
103851,"/** 
 * Adds data to be processed.
 * @param buffer
 */
synchronized void addData(Buffer buffer){
  byte[] data=new byte[buffer.getLength()];
  System.arraycopy(buffer.getData(),buffer.getOffset(),data,0,data.length);
  this.data=data;
  notifyAll();
}","/** 
 * Adds data to be processed.
 * @param buffer the data that we'd like to queue for processing.
 */
synchronized void addData(Buffer buffer){
  byte[] data=new byte[buffer.getLength()];
  System.arraycopy(buffer.getData(),buffer.getOffset(),data,0,data.length);
  this.data=data;
  notifyAll();
}",0.9113924050632912
103852,"/** 
 * A default implementation for the  {@link MediaDevice#getSupportedExtensions()} method returning<tt>null</tt> and hence indicating support for no RTP extensions.
 * @return <tt>null</tt>, indicating that this device does not support anyRTP extensions.
 */
public List<RTPExtension> getSupportedExtensions(){
  if (getMediaType() != MediaType.AUDIO)   return null;
  if (rtpExtensions == null) {
    rtpExtensions=new ArrayList<RTPExtension>(1);
    URI csrcAudioLevelURN;
    try {
      csrcAudioLevelURN=new URI(RTPExtension.CSRC_AUDIO_LEVEL_URN);
    }
 catch (    URISyntaxException e) {
      logger.info(""String_Node_Str"",e);
      return null;
    }
    rtpExtensions.add(new RTPExtension(csrcAudioLevelURN,MediaDirection.RECVONLY));
  }
  return rtpExtensions;
}","/** 
 * Returns a <tt>List</tt> containing (at the time of writing) a single extension descriptor indicating <tt>RECVONLY</tt> support for mixer-to-client audio levels.
 * @return a <tt>List</tt> containing the <tt>CSRC_AUDIO_LEVEL_URN</tt>extension descriptor.
 */
public List<RTPExtension> getSupportedExtensions(){
  if (getMediaType() != MediaType.AUDIO)   return null;
  if (rtpExtensions == null) {
    rtpExtensions=new ArrayList<RTPExtension>(1);
    URI csrcAudioLevelURN;
    try {
      csrcAudioLevelURN=new URI(RTPExtension.CSRC_AUDIO_LEVEL_URN);
    }
 catch (    URISyntaxException e) {
      logger.info(""String_Node_Str"",e);
      return null;
    }
    rtpExtensions.add(new RTPExtension(csrcAudioLevelURN,MediaDirection.RECVONLY));
  }
  return rtpExtensions;
}",0.3314065510597302
103853,"/** 
 * Gets the duration of each one of the output streams produced by this <tt>AudioMixer</tt>.
 * @return the duration of each one of the output streams produced by this<tt>AudioMixer</tt>
 */
Time getDuration(){
  Time duration=null;
synchronized (inputDataSources) {
    for (    InputDataSourceDesc inputDataSourceDesc : inputDataSources) {
      Time inputDuration=inputDataSourceDesc.getEffectiveInputDataSource().getDuration();
      if (Duration.DURATION_UNBOUNDED.equals(inputDuration) || Duration.DURATION_UNKNOWN.equals(inputDuration))       return inputDuration;
      if ((duration == null) || (duration.getNanoseconds() < inputDuration.getNanoseconds()))       duration=inputDuration;
    }
  }
  return (duration == null) ? Duration.DURATION_UNKNOWN : duration;
}","/** 
 * Gets the duration of each one of the output streams produced by this <tt>AudioMixer</tt>.
 * @return the duration of each one of the output streams produced by this<tt>AudioMixer</tt>
 */
Time getDuration(){
  return ((DataSource)captureDevice).getDuration();
}",0.4671115347950429
103854,"/** 
 * Gets the <tt>AudioMixer</tt> which performs audio mixing in this <tt>MediaDevice</tt> (and rather the session it represents). If it still does not exist, it is created.
 * @return the <tt>AudioMixer</tt> which performs audio mixing in this<tt>MediaDevice</tt> (and rather the session it represents)
 */
private AudioMixer getAudioMixer(){
  if (audioMixer == null)   audioMixer=new AudioMixer(device.createCaptureDevice()){
    @Override protected void read(    PushBufferStream stream,    Buffer buffer,    DataSource dataSource) throws IOException {
      super.read(stream,buffer,dataSource);
      if (dataSource == captureDevice) {
      }
 else       if (dataSource instanceof ReceiveStreamPushBufferDataSource) {
        ReceiveStream receiveStream=((ReceiveStreamPushBufferDataSource)dataSource).getReceiveStream();
      }
    }
  }
;
  return audioMixer;
}","/** 
 * Gets the <tt>AudioMixer</tt> which performs audio mixing in this <tt>MediaDevice</tt> (and rather the session it represents). If it still does not exist, it is created.
 * @return the <tt>AudioMixer</tt> which performs audio mixing in this<tt>MediaDevice</tt> (and rather the session it represents)
 */
private synchronized AudioMixer getAudioMixer(){
  if (audioMixer == null)   audioMixer=new AudioMixer(device.createCaptureDevice()){
    @Override protected void read(    PushBufferStream stream,    Buffer buffer,    DataSource dataSource) throws IOException {
      super.read(stream,buffer,dataSource);
      if (dataSource == captureDevice) {
      }
 else       if (dataSource instanceof ReceiveStreamPushBufferDataSource) {
        ReceiveStream receiveStream=((ReceiveStreamPushBufferDataSource)dataSource).getReceiveStream();
      }
    }
  }
;
  return audioMixer;
}",0.9926178307779672
103855,"/** 
 * Removes a <tt>ReceiveStream</tt> from this <tt>MediaDeviceSession</tt> so that it no longer plays back on the associated <tt>MediaDevice</tt>.
 * @param receiveStream the <tt>ReceiveStream</tt> to be removed from this<tt>MediaDeviceSession</tt> and playback on the associated <tt>MediaDevice</tt>
 */
public void removeReceiveStream(ReceiveStream receiveStream){
  DataSource receiveStreamDataSource=receiveStreams.remove(receiveStream);
  if ((receiveStreamDataSource != null) && !receiveStreams.containsValue(receiveStreamDataSource)) synchronized (players) {
    Processor player=players.get(receiveStreamDataSource);
    if (player != null)     disposePlayer(player);
  }
}","/** 
 * Removes a <tt>ReceiveStream</tt> from this <tt>MediaDeviceSession</tt> so that it no longer plays back on the associated <tt>MediaDevice</tt>.
 * @param receiveStream the <tt>ReceiveStream</tt> to be removed from this<tt>MediaDeviceSession</tt> and playback on the associated <tt>MediaDevice</tt>
 */
public synchronized void removeReceiveStream(ReceiveStream receiveStream){
  DataSource receiveStreamDataSource=receiveStreams.remove(receiveStream);
  if ((receiveStreamDataSource != null) && !receiveStreams.containsValue(receiveStreamDataSource)) synchronized (players) {
    Processor player=players.get(receiveStreamDataSource);
    if (player != null)     disposePlayer(player);
  }
}",0.9906001446131598
103856,"/** 
 * Adds a <tt>ReceiveStream</tt> to this <tt>MediaDeviceSession</tt> to be played back on the associated <tt>MediaDevice</tt> and a specific <tt>DataSource</tt> is to be used to access its media data during the playback. The <tt>DataSource</tt> is explicitly specified in order to allow extenders to override the <tt>DataSource</tt> of the <tt>ReceiveStream</tt> (e.g. create a clone of it).
 * @param receiveStream the <tt>ReceiveStream</tt> to be played back by this<tt>MediaDeviceSession</tt> on its associated <tt>MediaDevice</tt>
 * @param receiveStreamDataSource the <tt>DataSource</tt> to be used foraccessing the media data of <tt>receiveStream</tt> during its playback
 */
protected void addReceiveStream(ReceiveStream receiveStream,DataSource receiveStreamDataSource){
  if (receiveStreamDataSource == null)   return;
  receiveStreams.put(receiveStream,receiveStreamDataSource);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + receiveStream.getSSRC());
synchronized (players) {
    Processor player=players.get(receiveStreamDataSource);
    if (player == null) {
      Throwable exception=null;
      try {
        player=Manager.createProcessor(receiveStreamDataSource);
      }
 catch (      IOException ioe) {
        exception=ioe;
      }
catch (      NoPlayerException npe) {
        exception=npe;
      }
      if (exception != null)       logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC(),exception);
 else       if (!waitForState(player,Processor.Configured))       logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC());
 else {
        player.setContentDescriptor(null);
        if (waitForState(player,Processor.Realized)) {
          player.start();
          realizeComplete(player);
          if (logger.isTraceEnabled())           logger.trace(""String_Node_Str"" + player.hashCode() + ""String_Node_Str""+ receiveStream.getSSRC());
          players.put(receiveStreamDataSource,player);
        }
 else         logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC());
      }
    }
  }
}","/** 
 * Adds a <tt>ReceiveStream</tt> to this <tt>MediaDeviceSession</tt> to be played back on the associated <tt>MediaDevice</tt> and a specific <tt>DataSource</tt> is to be used to access its media data during the playback. The <tt>DataSource</tt> is explicitly specified in order to allow extenders to override the <tt>DataSource</tt> of the <tt>ReceiveStream</tt> (e.g. create a clone of it).
 * @param receiveStream the <tt>ReceiveStream</tt> to be played back by this<tt>MediaDeviceSession</tt> on its associated <tt>MediaDevice</tt>
 * @param receiveStreamDataSource the <tt>DataSource</tt> to be used foraccessing the media data of <tt>receiveStream</tt> during its playback
 */
protected synchronized void addReceiveStream(ReceiveStream receiveStream,DataSource receiveStreamDataSource){
  if (receiveStreamDataSource == null)   return;
  receiveStreams.put(receiveStream,receiveStreamDataSource);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + receiveStream.getSSRC());
synchronized (players) {
    Processor player=players.get(receiveStreamDataSource);
    if (player == null) {
      Throwable exception=null;
      try {
        player=Manager.createProcessor(receiveStreamDataSource);
      }
 catch (      IOException ioe) {
        exception=ioe;
      }
catch (      NoPlayerException npe) {
        exception=npe;
      }
      if (exception != null)       logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC(),exception);
 else       if (!waitForState(player,Processor.Configured))       logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC());
 else {
        player.setContentDescriptor(null);
        if (waitForState(player,Processor.Realized)) {
          player.start();
          realizeComplete(player);
          if (logger.isTraceEnabled())           logger.trace(""String_Node_Str"" + player.hashCode() + ""String_Node_Str""+ receiveStream.getSSRC());
          players.put(receiveStreamDataSource,player);
        }
 else         logger.error(""String_Node_Str"" + ""String_Node_Str"" + receiveStream.getSSRC());
      }
    }
  }
}",0.9969230769230768
103857,"/** 
 * Gets the <tt>DataSource</tt> that this instance uses to read captured media from. If it does not exist yet, it is created.
 * @return the <tt>DataSource</tt> that this instance uses to read capturedmedia from
 */
protected DataSource getCaptureDevice(){
  if (captureDevice == null)   captureDevice=createCaptureDevice();
  return captureDevice;
}","/** 
 * Gets the <tt>DataSource</tt> that this instance uses to read captured media from. If it does not exist yet, it is created.
 * @return the <tt>DataSource</tt> that this instance uses to read capturedmedia from
 */
protected synchronized DataSource getCaptureDevice(){
  if (captureDevice == null)   captureDevice=createCaptureDevice();
  return captureDevice;
}",0.9820193637621024
103858,"public void setReceiveBufferSize(int size) throws IOException {
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#setReceiveBufferSize(int)}.
 * @param size ignored.
 */
public void setReceiveBufferSize(int size) throws IOException {
}",0.5179282868525896
103859,"public int getReceiveBufferSize(){
  return -1;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#getReceiveBufferSize()} that always returns <tt>-1</tt>.
 */
public int getReceiveBufferSize(){
  return -1;
}",0.4375
103860,"public double getRTCPBandwidthFraction(){
  return -1;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#getRTCPBandwidthFraction()} that always returns <tt>-1</tt>.
 */
public double getRTCPBandwidthFraction(){
  return -1;
}",0.4628099173553719
103861,"public void setSendBufferSize(int size) throws IOException {
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#setSendBufferSize(int)}.
 * @param size ignored.
 */
public void setSendBufferSize(int size) throws IOException {
}",0.512396694214876
103862,"public int getSendBufferSize(){
  return -1;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#getSendBufferSize()} that always returns <tt>-1</tt>.
 */
public int getSendBufferSize(){
  return -1;
}",0.427906976744186
103863,"public void close(){
  dataOutputStream=null;
  controlOutputStream=null;
  if (dataInputStream != null) {
    dataInputStream.close();
    dataInputStream=null;
  }
  if (controlInputStream != null) {
    controlInputStream.close();
    controlInputStream=null;
  }
  connector.close();
}","/** 
 * Closes all sockets, stream, and the <tt>StreamConnector</tt> that this <tt>RTPConnector</tt> is using.
 */
public void close(){
  dataOutputStream=null;
  controlOutputStream=null;
  if (dataInputStream != null) {
    dataInputStream.close();
    dataInputStream=null;
  }
  if (controlInputStream != null) {
    controlInputStream.close();
    controlInputStream=null;
  }
  connector.close();
}",0.834054834054834
103864,"public double getRTCPSenderBandwidthFraction(){
  return -1;
}","/** 
 * Provides a dummy implementation to   {@link RTPConnector#getRTCPSenderBandwidthFraction()} that always returns<tt>-1</tt>.
 */
public double getRTCPSenderBandwidthFraction(){
  return -1;
}",0.4787644787644787
103865,"public PacketTransformerChain(boolean isRtp){
  this.isRtp=isRtp;
}","/** 
 * Creates an instance of this packet transformer and prepares it to deal with RTP or RTCP according to the <tt>isRtp</tt> arg.
 * @param isRtp <tt>true</tt> if this transformer will be dealing withRTP (i.e. will transform packets via the RTP transformers in this chain rather than the RTCP ones) and <tt>false</tt> otherwise.
 */
public PacketTransformerChain(boolean isRtp){
  this.isRtp=isRtp;
}",0.2851063829787234
103866,"/** 
 * Returns the list of CSRC identifiers for all parties currently known to contribute to the media that this stream is sending toward its remote counter part. In other words, the method returns the list of CSRC IDs that this stream will include in outgoing RTP packets. This method will return an <tt>null</tt> in case this stream is not part of a mixed conference call.
 * @return a <tt>long[]</tt> array of CSRC IDs representing parties that arecurrently known to contribute to the media that this stream is sending or an <tt>null</tt> in case this <tt>MediaStream</tt> is not part of a conference call.
 */
public long[] getLocalContributingSourceIDs(){
  if (this.deviceSession == null)   return null;
  MediaDeviceSession deviceSession=getDeviceSession();
  long[] ssrcArray=deviceSession.getRemoteSSRCList();
  List<Long> csrcList=new ArrayList<Long>(ssrcArray.length);
  for (  long csrc : ssrcArray) {
    if (csrc != this.getRemoteSourceID())     csrcList.add(csrc);
  }
  int cc=csrcList.size();
  if (cc == 0)   return null;
  long[] csrcArray=new long[cc];
  for (int i=0; i < csrcArray.length; i++) {
    csrcArray[i]=csrcList.get(i);
  }
  return csrcArray;
}","/** 
 * Returns the list of CSRC identifiers for all parties currently known to contribute to the media that this stream is sending toward its remote counter part. In other words, the method returns the list of CSRC IDs that this stream will include in outgoing RTP packets. This method will return an <tt>null</tt> in case this stream is not part of a mixed conference call.
 * @return a <tt>long[]</tt> array of CSRC IDs representing parties that arecurrently known to contribute to the media that this stream is sending or an <tt>null</tt> in case this <tt>MediaStream</tt> is not part of a conference call.
 */
public long[] getLocalContributingSourceIDs(){
  if (this.deviceSession == null)   return null;
  MediaDeviceSession deviceSession=getDeviceSession();
  long[] ssrcArray=deviceSession.getRemoteSSRCList();
  List<Long> csrcList=new ArrayList<Long>(ssrcArray.length);
  for (  long csrc : ssrcArray) {
    if (csrc != this.getRemoteSourceID()) {
      csrcList.add(csrc);
    }
 else {
    }
  }
  csrcList.add(getLocalSourceID());
  int cc=csrcList.size();
  if (cc == 0)   return null;
  long[] csrcArray=new long[cc];
  for (int i=0; i < csrcArray.length; i++) {
    csrcArray[i]=csrcList.get(i);
  }
  return csrcArray;
}",0.9751655629139072
103867,"/** 
 * Replaces the existing CSRC list (even if empty) with <tt>newCsrcList</tt> and updates the CC (CSRC count) field of this <tt>RawPacket</tt> accordingly.
 * @param newCsrcList the list of CSRC identifiers that we'd like to set forthis <tt>RawPacket</tt>.
 */
public void setCsrcList(long[] newCsrcList){
  int newCsrcCount=newCsrcList.length;
  byte[] csrcBuff=new byte[newCsrcCount * 4];
  int csrcOffset=0;
  for (  long csrc : newCsrcList) {
    csrcBuff[csrcOffset]=(byte)(csrc >> 24);
    csrcBuff[csrcOffset + 1]=(byte)(csrc >> 16);
    csrcBuff[csrcOffset + 2]=(byte)(csrc >> 8);
    csrcBuff[csrcOffset + 3]=(byte)csrc;
    csrcOffset+=4;
  }
  int oldCsrcCount=getCsrcCount();
  byte[] oldBuffer=this.getBuffer();
  byte[] newBuffer=new byte[oldBuffer.length + csrcBuff.length - oldCsrcCount * 4];
  System.arraycopy(oldBuffer,0,newBuffer,0,offset + FIXED_HEADER_SIZE);
  System.arraycopy(csrcBuff,0,newBuffer,offset + FIXED_HEADER_SIZE,csrcBuff.length);
  int payloadOffsetForOldBuff=offset + FIXED_HEADER_SIZE + oldCsrcCount * 4;
  int payloadOffsetForNewBuff=offset + FIXED_HEADER_SIZE + newCsrcCount * 4;
  System.arraycopy(oldBuffer,payloadOffsetForOldBuff,newBuffer,payloadOffsetForNewBuff,csrcBuff.length - payloadOffsetForOldBuff);
  newBuffer[offset]=(byte)((newBuffer[offset] & 0xF0b) & newCsrcCount);
}","/** 
 * Replaces the existing CSRC list (even if empty) with <tt>newCsrcList</tt> and updates the CC (CSRC count) field of this <tt>RawPacket</tt> accordingly.
 * @param newCsrcList the list of CSRC identifiers that we'd like to set forthis <tt>RawPacket</tt>.
 */
public void setCsrcList(long[] newCsrcList){
  int newCsrcCount=newCsrcList.length;
  byte[] csrcBuff=new byte[newCsrcCount * 4];
  int csrcOffset=0;
  for (  long csrc : newCsrcList) {
    csrcBuff[csrcOffset]=(byte)(csrc >> 24);
    csrcBuff[csrcOffset + 1]=(byte)(csrc >> 16);
    csrcBuff[csrcOffset + 2]=(byte)(csrc >> 8);
    csrcBuff[csrcOffset + 3]=(byte)csrc;
    csrcOffset+=4;
  }
  int oldCsrcCount=getCsrcCount();
  byte[] oldBuffer=this.getBuffer();
  byte[] newBuffer=new byte[oldBuffer.length + csrcBuff.length - oldCsrcCount * 4];
  System.arraycopy(oldBuffer,0,newBuffer,0,offset + FIXED_HEADER_SIZE);
  System.arraycopy(csrcBuff,0,newBuffer,offset + FIXED_HEADER_SIZE,csrcBuff.length);
  int payloadOffsetForOldBuff=offset + FIXED_HEADER_SIZE + oldCsrcCount * 4;
  int payloadOffsetForNewBuff=offset + FIXED_HEADER_SIZE + newCsrcCount * 4;
  System.arraycopy(oldBuffer,payloadOffsetForOldBuff,newBuffer,payloadOffsetForNewBuff,oldBuffer.length - payloadOffsetForOldBuff);
  newBuffer[offset]=(byte)((newBuffer[offset] & 0xF0) | newCsrcCount);
  this.buffer=newBuffer;
  this.length=newBuffer.length;
}",0.9605602653888684
103868,"/** 
 * Returns the number of CSRC identifiers currently included in this packet.
 * @return the CSRC count for this <tt>RawPacket</tt>.
 */
public int getCsrcCount(){
  return (buffer[offset] & 0x0fb);
}","/** 
 * Returns the number of CSRC identifiers currently included in this packet.
 * @return the CSRC count for this <tt>RawPacket</tt>.
 */
public int getCsrcCount(){
  return (buffer[offset] & 0x0f);
}",0.9975429975429976
103869,"/** 
 * Puts all <tt>MediaStream</tt>s in this handler locally on or off hold (according to the value of <tt>locallyOnHold</tt>). This would also be taken into account when the next update offer is generated.
 * @param locallyOnHold <tt>true</tt> if we are to make our audio streamstop transmitting and <tt>false</tt> if we are to start transmitting again.
 */
public void setLocallyOnHold(boolean locallyOnHold){
  this.locallyOnHold=locallyOnHold;
  if (locallyOnHold) {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().and(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().and(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
 else {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().or(MediaDirection.SENDONLY));
      audioStream.setMute(false);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().or(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
}","/** 
 * Puts all <tt>MediaStream</tt>s in this handler locally on or off hold (according to the value of <tt>locallyOnHold</tt>). This would also be taken into account when the next update offer is generated.
 * @param locallyOnHold <tt>true</tt> if we are to make our audio streamstop transmitting and <tt>false</tt> if we are to start transmitting again.
 */
public void setLocallyOnHold(boolean locallyOnHold){
  this.locallyOnHold=locallyOnHold;
  if (locallyOnHold) {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().and(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().and(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
 else {
    if (audioStream != null) {
      audioStream.setDirection(audioStream.getDirection().or(MediaDirection.SENDONLY));
      audioStream.setMute(locallyOnHold);
    }
    if (videoStream != null) {
      videoStream.setDirection(videoStream.getDirection().or(MediaDirection.SENDONLY));
      videoStream.setMute(locallyOnHold);
    }
  }
}",0.9922145328719724
103870,"private SessionDescription createUpdateOffer(SessionDescription sdescToUpdate) throws OperationFailedException {
  Vector<MediaDescription> newMediaDescs=createMediaDescriptions();
  SessionDescription newOffer=SdpUtils.createSessionUpdateDescription(sdescToUpdate,getLastUsedLocalHost(),newMediaDescs);
  return newOffer;
}","private SessionDescription createUpdateOffer(SessionDescription sdescToUpdate) throws OperationFailedException {
  Vector<MediaDescription> newMediaDescs=createMediaDescriptions();
  SessionDescription newOffer=SdpUtils.createSessionUpdateDescription(sdescToUpdate,getLastUsedLocalHost(),newMediaDescs);
  this.localSess=newOffer;
  return newOffer;
}",0.96
103871,"/** 
 * Sets our state to CONNECTED, sends an ACK and processes the SDP description in the <tt>ok</tt> <tt>Response</tt>.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
public void processInviteOK(ClientTransaction clientTransaction,Response ok){
  try {
    getProtocolProvider().sendAck(clientTransaction);
  }
 catch (  InvalidArgumentException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
catch (  SipException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
  if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {
    setSdpDescription(new String(ok.getRawContent()));
  }
  try {
    if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {
      getMediaHandler().processAnswer(getSdpDescription());
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    try {
      setState(CallPeerState.CONNECTED);
      hangup();
    }
 catch (    Exception e) {
    }
 finally {
      logAndFail(""String_Node_Str"",exc);
    }
    return;
  }
  if (!CallPeerState.isOnHold(getState()))   setState(CallPeerState.CONNECTED);
}","/** 
 * Sets our state to CONNECTED, sends an ACK and processes the SDP description in the <tt>ok</tt> <tt>Response</tt>.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
public void processInviteOK(ClientTransaction clientTransaction,Response ok){
  try {
    getProtocolProvider().sendAck(clientTransaction);
  }
 catch (  InvalidArgumentException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
catch (  SipException ex) {
    logAndFail(""String_Node_Str"",ex);
    return;
  }
  try {
    if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {
      getMediaHandler().processAnswer(new String(ok.getRawContent()));
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    try {
      setState(CallPeerState.CONNECTED);
      hangup();
    }
 catch (    Exception e) {
    }
 finally {
      logAndFail(""String_Node_Str"",exc);
    }
    return;
  }
  if (!CallPeerState.isOnHold(getState()))   setState(CallPeerState.CONNECTED);
}",0.9150435142975548
103872,"/** 
 * Reinitializes the media session of the <tt>CallPeer</tt> that this INVITE request is destined to.
 * @param serverTransaction a reference to the {@link ServerTransaction}that contains the reINVITE request.
 */
public void processReInvite(ServerTransaction serverTransaction){
  Request invite=serverTransaction.getRequest();
  setLatestInviteTransaction(serverTransaction);
  ContentLengthHeader cl=invite.getContentLength();
  if (cl != null && cl.getContentLength() > 0) {
    setSdpDescription(new String(invite.getRawContent()));
  }
  Response response=null;
  try {
    response=messageFactory.createResponse(Response.OK,invite);
    String sdpAnswer=getMediaHandler().processOffer(getSdpDescription());
    response.setContent(sdpAnswer,getProtocolProvider().getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str""));
    logger.trace(""String_Node_Str"" + response);
    serverTransaction.sendResponse(response);
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    setState(CallPeerState.FAILED,""String_Node_Str"" + ex.getMessage());
    getProtocolProvider().sayErrorSilently(serverTransaction,Response.SERVER_INTERNAL_ERROR);
    return;
  }
  reevalRemoteHoldStatus();
}","/** 
 * Reinitializes the media session of the <tt>CallPeer</tt> that this INVITE request is destined to.
 * @param serverTransaction a reference to the {@link ServerTransaction}that contains the reINVITE request.
 */
public void processReInvite(ServerTransaction serverTransaction){
  Request invite=serverTransaction.getRequest();
  setLatestInviteTransaction(serverTransaction);
  String sdp=null;
  ContentLengthHeader cl=invite.getContentLength();
  if (cl != null && cl.getContentLength() > 0) {
    sdp=new String(invite.getRawContent());
  }
  Response response=null;
  try {
    response=messageFactory.createResponse(Response.OK,invite);
    String sdpAnswer;
    if (sdp == null)     sdpAnswer=getMediaHandler().processOffer(sdp);
 else     sdpAnswer=getMediaHandler().createOffer();
    response.setContent(sdpAnswer,getProtocolProvider().getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str""));
    logger.trace(""String_Node_Str"" + response);
    serverTransaction.sendResponse(response);
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    setState(CallPeerState.FAILED,""String_Node_Str"" + ex.getMessage());
    getProtocolProvider().sayErrorSilently(serverTransaction,Response.SERVER_INTERNAL_ERROR);
    return;
  }
  reevalRemoteHoldStatus();
}",0.9422120168388826
103873,"/** 
 * Updates the session description and sends the state of the corresponding call peer to CONNECTED.
 * @param serverTransaction the transaction that the ACK was received in.
 * @param ack the ACK <tt>Request</tt> we need to process
 */
public void processAck(ServerTransaction serverTransaction,Request ack){
  ContentLengthHeader contentLength=ack.getContentLength();
  if ((contentLength != null) && (contentLength.getContentLength() > 0)) {
    setSdpDescription(new String(ack.getRawContent()));
  }
  CallPeerState peerState=getState();
  if (!CallPeerState.isOnHold(peerState)) {
    setState(CallPeerState.CONNECTED);
  }
}","/** 
 * Updates the session description and sends the state of the corresponding call peer to CONNECTED.
 * @param serverTransaction the transaction that the ACK was received in.
 * @param ack the ACK <tt>Request</tt> we need to process
 */
public void processAck(ServerTransaction serverTransaction,Request ack){
  ContentLengthHeader contentLength=ack.getContentLength();
  if ((contentLength != null) && (contentLength.getContentLength() > 0)) {
    try {
      getMediaHandler().processAnswer(new String(ack.getRawContent()));
    }
 catch (    Exception exc) {
      logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
      return;
    }
  }
  CallPeerState peerState=getState();
  if (!CallPeerState.isOnHold(peerState)) {
    setState(CallPeerState.CONNECTED);
  }
}",0.8442622950819673
103874,"/** 
 * Handles early media in 183 Session Progress responses. Retrieves the SDP and makes sure that we start transmitting and playing early media that we receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
 * @param tran the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param response the 183 <tt>Response</tt> to process
 */
public void processSessionProgress(ClientTransaction tran,Response response){
  if (response.getContentLength().getContentLength() == 0) {
    logger.debug(""String_Node_Str"");
    return;
  }
  ContentTypeHeader contentTypeHeader=(ContentTypeHeader)response.getHeader(ContentTypeHeader.NAME);
  if (!contentTypeHeader.getContentType().equalsIgnoreCase(""String_Node_Str"") || !contentTypeHeader.getContentSubType().equalsIgnoreCase(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  setSdpDescription(new String(response.getRawContent()));
  try {
    getMediaHandler().processAnswer(getSdpDescription());
  }
 catch (  Exception exc) {
    logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    return;
  }
  setState(CallPeerState.CONNECTING_WITH_EARLY_MEDIA);
}","/** 
 * Handles early media in 183 Session Progress responses. Retrieves the SDP and makes sure that we start transmitting and playing early media that we receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
 * @param tran the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param response the 183 <tt>Response</tt> to process
 */
public void processSessionProgress(ClientTransaction tran,Response response){
  if (response.getContentLength().getContentLength() == 0) {
    logger.debug(""String_Node_Str"");
    return;
  }
  ContentTypeHeader contentTypeHeader=(ContentTypeHeader)response.getHeader(ContentTypeHeader.NAME);
  if (!contentTypeHeader.getContentType().equalsIgnoreCase(""String_Node_Str"") || !contentTypeHeader.getContentSubType().equalsIgnoreCase(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  try {
    getMediaHandler().processAnswer(new String(response.getRawContent()));
  }
 catch (  Exception exc) {
    logAndFail(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ getAddress()+ ""String_Node_Str"",exc);
    return;
  }
  setState(CallPeerState.CONNECTING_WITH_EARLY_MEDIA);
}",0.9456975772765246
103875,"/** 
 * Indicates a user request to answer an incoming call from this <tt>CallPeer</tt>. Sends an OK response to <tt>callPeer</tt>. Make sure that the call peer contains an SDP description when you call this method.
 * @throws OperationFailedException if we fail to create or send theresponse.
 */
public synchronized void answer() throws OperationFailedException {
  Transaction transaction=getLatestInviteTransaction();
  if (transaction == null || !(transaction instanceof ServerTransaction)) {
    setState(CallPeerState.DISCONNECTED);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallPeerState peerState=getState();
  if (peerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(peerState)) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  ServerTransaction serverTransaction=(ServerTransaction)transaction;
  Response ok=null;
  try {
    ok=messageFactory.createResponse(Response.OK,serverTransaction.getRequest());
  }
 catch (  ParseException ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex,logger);
  }
  ContentTypeHeader contentTypeHeader=null;
  try {
    contentTypeHeader=getProtocolProvider().getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ParseException ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex,logger);
  }
  try {
    String sdpOffer=getSdpDescription();
    String sdp;
    if ((sdpOffer != null) && (sdpOffer.length() > 0)) {
      sdp=getMediaHandler().processFirstOffer(SdpUtils.parseSdpString(sdpOffer)).toString();
    }
 else {
      sdp=getMediaHandler().createOffer();
    }
    ok.setContent(sdp,contentTypeHeader);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    getProtocolProvider().sayError(serverTransaction,Response.NOT_ACCEPTABLE_HERE);
  }
  try {
    serverTransaction.sendResponse(ok);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ok);
  }
 catch (  Exception ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE,ex,logger);
  }
}","/** 
 * Indicates a user request to answer an incoming call from this <tt>CallPeer</tt>. Sends an OK response to <tt>callPeer</tt>. Make sure that the call peer contains an SDP description when you call this method.
 * @throws OperationFailedException if we fail to create or send theresponse.
 */
public synchronized void answer() throws OperationFailedException {
  Transaction transaction=getLatestInviteTransaction();
  if (transaction == null || !(transaction instanceof ServerTransaction)) {
    setState(CallPeerState.DISCONNECTED);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  CallPeerState peerState=getState();
  if (peerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(peerState)) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  ServerTransaction serverTransaction=(ServerTransaction)transaction;
  Response ok=null;
  try {
    ok=messageFactory.createResponse(Response.OK,serverTransaction.getRequest());
  }
 catch (  ParseException ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex,logger);
  }
  ContentTypeHeader contentTypeHeader=null;
  try {
    contentTypeHeader=getProtocolProvider().getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ParseException ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex,logger);
  }
  try {
    String sdpOffer=null;
    Request invite=getLatestInviteTransaction().getRequest();
    ContentLengthHeader cl=invite.getContentLength();
    if (cl != null && cl.getContentLength() > 0) {
      sdpOffer=new String(invite.getRawContent());
    }
    ;
    String sdp;
    if ((sdpOffer != null) && (sdpOffer.length() > 0)) {
      sdp=getMediaHandler().processFirstOffer(SdpUtils.parseSdpString(sdpOffer)).toString();
    }
 else {
      sdp=getMediaHandler().createOffer();
    }
    ok.setContent(sdp,contentTypeHeader);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    getProtocolProvider().sayError(serverTransaction,Response.NOT_ACCEPTABLE_HERE);
  }
  try {
    serverTransaction.sendResponse(ok);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + ok);
  }
 catch (  Exception ex) {
    setState(CallPeerState.DISCONNECTED);
    ProtocolProviderServiceSipImpl.throwOperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE,ex,logger);
  }
}",0.9511865714836968
103876,"/** 
 * Overrides the
 */
public void setState(CallPeerState newState,String reason){
  super.setState(newState,reason);
  this.getMediaHandler().close();
}","/** 
 * Overrides the parent set state method in order to make sure that we close our media handler whenever we enter a disconnected state.
 * @param newState the <tt>CallPeerState</tt> that we are about to enter andthat we pass to our predecessor.
 * @param reason a reason phrase explaining the state (e.g. if newStateindicates a failure) and that we pass to our predecessor.
 */
public void setState(CallPeerState newState,String reason){
  super.setState(newState,reason);
  if (CallPeerState.DISCONNECTED.equals(newState) || CallPeerState.FAILED.equals(newState))   this.getMediaHandler().close();
}",0.4105263157894737
103877,"/** 
 * Creates a new call peer with address <tt>peerAddress</tt>.
 * @param peerAddress the JAIN SIP <tt>Address</tt> of the new call peer.
 * @param owningCall the call that contains this call peer.
 * @param containingTransaction the transaction that created the call peer.
 * @param sourceProvider the provider that the containingTransaction belongsto.
 */
public CallPeerSipImpl(Address peerAddress,CallSipImpl owningCall,Transaction containingTransaction,SipProvider sourceProvider){
  this.peerAddress=peerAddress;
  this.call=owningCall;
  this.parentOpSet=owningCall.getParentOperationSet();
  this.messageFactory=getProtocolProvider().getMessageFactory();
  this.mediaHandler=new CallPeerMediaHandler(this);
  setDialog(containingTransaction.getDialog());
  setLatestInviteTransaction(containingTransaction);
  setJainSipProvider(sourceProvider);
  this.peerID=String.valueOf(System.currentTimeMillis()) + String.valueOf(hashCode());
}","/** 
 * Creates a new call peer with address <tt>peerAddress</tt>.
 * @param peerAddress the JAIN SIP <tt>Address</tt> of the new call peer.
 * @param owningCall the call that contains this call peer.
 * @param containingTransaction the transaction that created the call peer.
 * @param sourceProvider the provider that the containingTransaction belongsto.
 */
public CallPeerSipImpl(Address peerAddress,CallSipImpl owningCall,Transaction containingTransaction,SipProvider sourceProvider){
  this.peerAddress=peerAddress;
  this.call=owningCall;
  this.messageFactory=getProtocolProvider().getMessageFactory();
  this.mediaHandler=new CallPeerMediaHandler(this);
  setDialog(containingTransaction.getDialog());
  setLatestInviteTransaction(containingTransaction);
  setJainSipProvider(sourceProvider);
  this.peerID=String.valueOf(System.currentTimeMillis()) + String.valueOf(hashCode());
}",0.9700272479564032
103878,"/** 
 * Creates a new call and sends a RINGING response.
 * @param jainSipProvider the provider containing<tt>sourceTransaction</tt>.
 * @param serverTran the transaction containing the received request.
 * @return CallPeerSipImpl the newly created call peer (the one that sentthe INVITE).
 */
public CallPeerSipImpl processInvite(SipProvider jainSipProvider,ServerTransaction serverTran){
  Request invite=serverTran.getRequest();
  CallPeerSipImpl peer=createCallPeerFor(serverTran,jainSipProvider);
  ContentLengthHeader cl=invite.getContentLength();
  if (cl != null && cl.getContentLength() > 0) {
    peer.setSdpDescription(new String(invite.getRawContent()));
  }
  Response response=null;
  try {
    logger.trace(""String_Node_Str"");
    response=messageFactory.createResponse(Response.RINGING,invite);
    serverTran.sendResponse(response);
    logger.debug(""String_Node_Str"" + response);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    peer.setState(CallPeerState.FAILED,""String_Node_Str"" + ex.getMessage());
    return peer;
  }
  return peer;
}","/** 
 * Creates a new call and sends a RINGING response.
 * @param jainSipProvider the provider containing<tt>sourceTransaction</tt>.
 * @param serverTran the transaction containing the received request.
 * @return CallPeerSipImpl the newly created call peer (the one that sentthe INVITE).
 */
public CallPeerSipImpl processInvite(SipProvider jainSipProvider,ServerTransaction serverTran){
  Request invite=serverTran.getRequest();
  CallPeerSipImpl peer=createCallPeerFor(serverTran,jainSipProvider);
  Response response=null;
  try {
    logger.trace(""String_Node_Str"");
    response=messageFactory.createResponse(Response.RINGING,invite);
    serverTran.sendResponse(response);
    logger.debug(""String_Node_Str"" + response);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    peer.setState(CallPeerState.FAILED,""String_Node_Str"" + ex.getMessage());
    return peer;
  }
  return peer;
}",0.9152882205513784
103879,"/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",16000,351);
  setEncodingPreference(""String_Node_Str"",32000,350);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,50);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  List<String> sdpPreferences=confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false);
  for (  String pName : sdpPreferences) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1).replaceAll(""String_Node_Str"",""String_Node_Str"");
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=-1;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}","/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
public void initializeFormatPreferences(){
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1100);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,1000);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,950);
  setEncodingPreference(""String_Node_Str"",VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,800);
  setEncodingPreference(""String_Node_Str"",8000,650);
  setEncodingPreference(""String_Node_Str"",8000,600);
  setEncodingPreference(""String_Node_Str"",8000,500);
  setEncodingPreference(""String_Node_Str"",8000,450);
  setEncodingPreference(""String_Node_Str"",8000,352);
  setEncodingPreference(""String_Node_Str"",16000,351);
  setEncodingPreference(""String_Node_Str"",32000,350);
  setEncodingPreference(""String_Node_Str"",8000,300);
  setEncodingPreference(""String_Node_Str"",16000,250);
  setEncodingPreference(""String_Node_Str"",8000,150);
  setEncodingPreference(""String_Node_Str"",8000,100);
  setEncodingPreference(""String_Node_Str"",8000,50);
  ConfigurationService confService=NeomediaActivator.getConfigurationService();
  for (  String pName : confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false)) {
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.') + 1).replaceAll(""String_Node_Str"",""String_Node_Str"");
    int preference=-1;
    String encoding;
    double clockRate;
    try {
      preference=Integer.parseInt(prefStr);
      int encodingClockRateSeparator=fmtName.lastIndexOf('/');
      if (encodingClockRateSeparator > -1) {
        encoding=fmtName.substring(0,encodingClockRateSeparator);
        clockRate=Double.parseDouble(fmtName.substring(encodingClockRateSeparator + 1));
      }
 else {
        encoding=fmtName;
        clockRate=MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;
      }
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",nfe);
      continue;
    }
    setEncodingPreference(encoding,clockRate,preference);
  }
  updateSupportedEncodings();
}",0.9704918032786886
103880,"/** 
 * Register in JMF the custom codecs we provide
 */
@SuppressWarnings(""String_Node_Str"") public void registerCustomCodecs(){
  Collection<String> registeredPlugins=new HashSet<String>(PlugInManager.getPlugInList(null,null,PlugInManager.CODEC));
  boolean commit=false;
  for (  String className : CUSTOM_CODECS) {
    if (className == null)     continue;
    if (registeredPlugins.contains(className)) {
      logger.debug(""String_Node_Str"" + className + ""String_Node_Str"");
    }
 else {
      commit=true;
      boolean registered;
      Throwable exception=null;
      try {
        Codec codec=(Codec)Class.forName(className).newInstance();
        registered=PlugInManager.addPlugIn(className,codec.getSupportedInputFormats(),codec.getSupportedOutputFormats(null),PlugInManager.CODEC);
      }
 catch (      Throwable ex) {
        registered=false;
        exception=ex;
      }
      if (registered)       logger.debug(""String_Node_Str"" + className + ""String_Node_Str"");
 else       logger.debug(""String_Node_Str"" + className + ""String_Node_Str"",exception);
    }
  }
  if (commit)   try {
    PlugInManager.commit();
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}","/** 
 * Register in JMF the custom codecs we provide
 */
public void registerCustomCodecs(){
  @SuppressWarnings(""String_Node_Str"") Collection<String> registeredPlugins=new HashSet<String>(PlugInManager.getPlugInList(null,null,PlugInManager.CODEC));
  boolean commit=false;
  for (  String className : CUSTOM_CODECS) {
    if (className == null)     continue;
    if (registeredPlugins.contains(className)) {
      logger.debug(""String_Node_Str"" + className + ""String_Node_Str"");
    }
 else {
      commit=true;
      boolean registered;
      Throwable exception=null;
      try {
        Codec codec=(Codec)Class.forName(className).newInstance();
        registered=PlugInManager.addPlugIn(className,codec.getSupportedInputFormats(),codec.getSupportedOutputFormats(null),PlugInManager.CODEC);
      }
 catch (      Throwable ex) {
        registered=false;
        exception=ex;
      }
      if (registered)       logger.debug(""String_Node_Str"" + className + ""String_Node_Str"");
 else       logger.debug(""String_Node_Str"" + className + ""String_Node_Str"",exception);
    }
  }
  if (commit)   try {
    PlugInManager.commit();
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.968516984258492
103881,"public MediaFormat[] getSupportedEncodings(MediaType type){
  Set<MediaFormat> supportedEncodings;
switch (type) {
case AUDIO:
    supportedEncodings=supportedAudioEncodings;
  break;
case VIDEO:
supportedEncodings=supportedVideoEncodings;
break;
default :
return MediaUtils.EMPTY_MEDIA_FORMATS;
}
return supportedEncodings.toArray(new MediaFormat[supportedEncodings.size()]);
}","/** 
 * Gets the supported <tt>MediaFormat</tt>s i.e. the enabled available <tt>MediaFormat</tt>s sorted in decreasing priority.
 * @param type the <tt>MediaType</tt> of the supported <tt>MediaFormat</tt>sto get
 * @return an array of the supported <tt>MediaFormat</tt>s i.e. the enabledavailable <tt>MediaFormat</tt>s sorted in decreasing priority
 */
public MediaFormat[] getSupportedEncodings(MediaType type){
  Set<MediaFormat> supportedEncodings;
switch (type) {
case AUDIO:
    if (supportedAudioEncodings == null)     supportedAudioEncodings=updateSupportedEncodings(type);
  supportedEncodings=supportedAudioEncodings;
break;
case VIDEO:
if (supportedVideoEncodings == null) supportedVideoEncodings=updateSupportedEncodings(type);
supportedEncodings=supportedVideoEncodings;
break;
default :
return MediaUtils.EMPTY_MEDIA_FORMATS;
}
return supportedEncodings.toArray(new MediaFormat[supportedEncodings.size()]);
}",0.5542725173210161
103882,"/** 
 * Updates the codecs in the supported sets according preferences in encodingPreferences. If value is ""0"" the codec is disabled.
 */
private void updateSupportedEncodings(){
  for (  MediaFormat format : getAvailableEncodings(MediaType.AUDIO)) {
    Integer pref1=encodingPreferences.get(format);
    int pref1IntValue=(pref1 == null) ? 0 : pref1;
    if (pref1IntValue > 0)     supportedAudioEncodings.add(format);
 else     supportedAudioEncodings.remove(format);
  }
  for (  MediaFormat format : getAvailableEncodings(MediaType.VIDEO)) {
    Integer pref1=encodingPreferences.get(format);
    int pref1IntValue=(pref1 == null) ? 0 : pref1;
    if (pref1IntValue > 0)     supportedVideoEncodings.add(format);
 else     supportedVideoEncodings.remove(format);
  }
}","/** 
 * Gets the <tt>Set</tt> of enabled available <tt>MediaFormat</tt>s with the specified <tt>MediaType</tt> sorted in decreasing priority.
 * @param type the <tt>MediaType</tt> of the <tt>MediaFormat</tt>s to get
 * @return a <tt>Set</tt> of enabled available <tt>MediaFormat</tt>s withthe specified <tt>MediaType</tt> sorted in decreasing priority
 */
private Set<MediaFormat> updateSupportedEncodings(MediaType type){
  Set<MediaFormat> supported=new TreeSet<MediaFormat>(encodingComparator);
  for (  MediaFormat format : getAvailableEncodings(type))   if (getPriority(format) > 0)   supported.add(format);
  return supported;
}",0.1877667140825035
103883,"/** 
 * Register in JMF the custom packages we provide
 */
@SuppressWarnings(""String_Node_Str"") public void registerCustomPackages(){
  Vector<String> currentPackagePrefix=PackageManager.getProtocolPrefixList();
  for (  String className : CUSTOM_PACKAGES) {
    if (!currentPackagePrefix.contains(className)) {
      currentPackagePrefix.add(className);
      logger.debug(""String_Node_Str"" + className);
    }
  }
  PackageManager.setProtocolPrefixList(currentPackagePrefix);
  PackageManager.commitProtocolPrefixList();
  logger.debug(""String_Node_Str"" + currentPackagePrefix);
}","/** 
 * Register in JMF the custom packages we provide
 */
public void registerCustomPackages(){
  @SuppressWarnings(""String_Node_Str"") Vector<String> currentPackagePrefix=PackageManager.getProtocolPrefixList();
  for (  String className : CUSTOM_PACKAGES) {
    if (!currentPackagePrefix.contains(className)) {
      currentPackagePrefix.add(className);
      logger.debug(""String_Node_Str"" + className);
    }
  }
  PackageManager.setProtocolPrefixList(currentPackagePrefix);
  PackageManager.commitProtocolPrefixList();
  logger.debug(""String_Node_Str"" + currentPackagePrefix);
}",0.9312714776632304
103884,"/** 
 * Sets <tt>pref</tt> as the preference associated with <tt>encoding</tt>. Use this method for both audio and video encodings and don't worry if preferences are equal since we rarely need to compare prefs of video encodings to those of audio encodings.
 * @param encoding a string containing the SDP int of the encoding whosepref we're setting.
 * @param priority a positive int indicating the preference for that encoding.
 */
public void setPriority(MediaFormat encoding,int priority){
  encodingPreferences.put(encoding,priority);
  NeomediaActivator.getConfigurationService().setProperty(PROP_SDP_PREFERENCE + ""String_Node_Str"" + encoding.getEncoding()+ ""String_Node_Str""+ ((long)encoding.getClockRate()),priority);
  updateSupportedEncodings();
}","/** 
 * Sets <tt>pref</tt> as the preference associated with <tt>encoding</tt>. Use this method for both audio and video encodings and don't worry if preferences are equal since we rarely need to compare prefs of video encodings to those of audio encodings.
 * @param encoding a string containing the SDP int of the encoding whosepref we're setting.
 * @param priority a positive int indicating the preference for that encoding.
 */
public void setPriority(MediaFormat encoding,int priority){
  encodingPreferences.put(encoding,priority);
  NeomediaActivator.getConfigurationService().setProperty(PROP_SDP_PREFERENCE + ""String_Node_Str"" + encoding.getEncoding()+ ""String_Node_Str""+ encoding.getClockRateString(),priority);
  updateSupportedEncodings();
}",0.990728476821192
103885,"/** 
 * Notifies this <tt>MediaStream</tt> that the <tt>MediaDevice</tt> (and respectively the <tt>MediaDeviceSession</tt> with it) which this instance uses for capture and playback of media has been changed. Makes sure that the <tt>VideoListener</tt>s of this instance get <tt>VideoEvent</tt>s for the new/current <tt>VideoMediaDeviceSession</tt> and not for the old one.
 * @param oldValue the <tt>MediaDeviceSession</tt> with the<tt>MediaDevice</tt> this instance used work with
 * @param newValue the <tt>MediaDeviceSession</tt> with the<tt>MediaDevice</tt> this instance is to work with
 * @see MediaStreamImpl#deviceSessionChanged(MediaDeviceSession,MediaDeviceSession)
 */
@Override protected void deviceSessionChanged(MediaDeviceSession oldValue,MediaDeviceSession newValue){
  super.deviceSessionChanged(oldValue,newValue);
  if (oldValue instanceof VideoMediaDeviceSession)   ((VideoMediaDeviceSession)oldValue).removeVideoListener(deviceSessionVideoListener);
  if (newValue instanceof VideoMediaDeviceSession)   ((VideoMediaDeviceSession)newValue).addVideoListener(deviceSessionVideoListener);
}","/** 
 * Notifies this <tt>MediaStream</tt> that the <tt>MediaDevice</tt> (and respectively the <tt>MediaDeviceSession</tt> with it) which this instance uses for capture and playback of media has been changed. Makes sure that the <tt>VideoListener</tt>s of this instance get <tt>VideoEvent</tt>s for the new/current <tt>VideoMediaDeviceSession</tt> and not for the old one.
 * @param oldValue the <tt>MediaDeviceSession</tt> with the<tt>MediaDevice</tt> this instance used work with
 * @param newValue the <tt>MediaDeviceSession</tt> with the<tt>MediaDevice</tt> this instance is to work with
 * @see MediaStreamImpl#deviceSessionChanged(MediaDeviceSession,MediaDeviceSession)
 */
@Override protected void deviceSessionChanged(MediaDeviceSession oldValue,MediaDeviceSession newValue){
  super.deviceSessionChanged(oldValue,newValue);
  if ((oldValue instanceof VideoMediaDeviceSession) && (deviceSessionVideoListener != null))   ((VideoMediaDeviceSession)oldValue).removeVideoListener(deviceSessionVideoListener);
  if (newValue instanceof VideoMediaDeviceSession) {
    if (deviceSessionVideoListener == null)     deviceSessionVideoListener=new VideoListener(){
      /** 
 * Notifies that a visual <tt>Component</tt> representing video has been added to the provider this listener has been added to.
 * @param e a <tt>VideoEvent</tt> describing the addedvisual <tt>Component</tt> representing video and the provider it was added into
 * @see VideoListener#videoAdded(VideoEvent)
 */
      public void videoAdded(      VideoEvent e){
        fireVideoEvent(e.getType(),e.getVisualComponent(),e.getOrigin());
      }
      /** 
 * Notifies that a visual <tt>Component</tt> representing video has been removed from the provider this listener has been added to.
 * @param e a <tt>VideoEvent</tt> describing the removedvisual <tt>Component</tt> representing video and the provider it was removed from
 * @see VideoListener#videoRemoved(VideoEvent)
 */
      public void videoRemoved(      VideoEvent e){
        fireVideoEvent(e.getType(),e.getVisualComponent(),e.getOrigin());
      }
    }
;
    ((VideoMediaDeviceSession)newValue).addVideoListener(deviceSessionVideoListener);
  }
}",0.6733576642335767
103886,"/** 
 * Gets the output <tt>DataSource</tt> of this instance which provides the captured (RTP) data to be sent by <tt>MediaStream</tt> to <tt>MediaStreamTarget</tt>.
 * @return the output <tt>DataSource</tt> of this instance which providesthe captured (RTP) data to be sent by <tt>MediaStream</tt> to <tt>MediaStreamTarget</tt>
 */
public DataSource getOutputDataSource(){
  Processor processor=getProcessor();
  return (processor == null) ? null : processor.getDataOutput();
}","/** 
 * Gets the output <tt>DataSource</tt> of this instance which provides the captured (RTP) data to be sent by <tt>MediaStream</tt> to <tt>MediaStreamTarget</tt>.
 * @return the output <tt>DataSource</tt> of this instance which providesthe captured (RTP) data to be sent by <tt>MediaStream</tt> to <tt>MediaStreamTarget</tt>
 */
public DataSource getOutputDataSource(){
  Processor processor=getProcessor();
  DataSource outputDataSource;
  if ((processor == null) || ((processor.getState() < Processor.Realized) && !waitForState(processor,Processor.Realized)))   outputDataSource=null;
 else   outputDataSource=processor.getDataOutput();
  return outputDataSource;
}",0.8038360941586749
103887,"/** 
 * Creates a DataSource for all encodings in the mediaDescriptions vector and initializes send streams in our rtp managers for every stream in the data source.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances as sent by the remote side with their SDP description.
 * @throws MediaException if we fail to create our data source with theproper encodings and/or fail to initialize the RTP managers with the necessary streams and/or don't find encodings supported by both the remote peer and the local controller.
 */
private void createSendStreams(Vector<MediaDescription> mediaDescriptions) throws MediaException {
  Hashtable<String,List<String>> mediaEncodings=extractMediaEncodings(mediaDescriptions);
  DataSource dataSource=mediaServCallback.getMediaControl(getCall()).createDataSourceForEncodings(mediaEncodings);
  PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
  for (int i=0; i < streams.length; i++) {
    PushBufferStream stream=streams[i];
    javax.media.Format format=stream.getFormat();
    RTPManager rtpManager=null;
    if (format instanceof VideoFormat) {
      rtpManager=getVideoRtpManager();
    }
 else     if (format instanceof AudioFormat) {
      rtpManager=getAudioRtpManager();
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ format);
      continue;
    }
    try {
      rtpManager.createSendStream(dataSource,i);
      logger.trace(""String_Node_Str"" + format);
    }
 catch (    Exception exc) {
      throw new MediaException(""String_Node_Str"" + format,MediaException.IO_ERROR,exc);
    }
  }
}","/** 
 * Creates a DataSource for all encodings in the mediaDescriptions vector and initializes send streams in our rtp managers for every stream in the data source.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances as sent by the remote side with their SDP description.
 * @throws MediaException if we fail to create our data source with theproper encodings and/or fail to initialize the RTP managers with the necessary streams and/or don't find encodings supported by both the remote peer and the local controller.
 */
private void createSendStreams(Vector<MediaDescription> mediaDescriptions) throws MediaException {
  Hashtable<String,List<String>> mediaEncodings=extractMediaEncodings(mediaDescriptions);
  DataSource dataSource=mediaServCallback.getMediaControl(getCall()).createDataSourceForEncodings(mediaEncodings);
  PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
  for (int i=0; i < streams.length; i++) {
    PushBufferStream stream=streams[i];
    javax.media.Format format=stream.getFormat();
    RTPManager rtpManager=null;
    if (format instanceof VideoFormat) {
      rtpManager=getVideoRtpManager();
    }
 else     if (format instanceof AudioFormat) {
      rtpManager=getAudioRtpManager();
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ format);
      continue;
    }
    try {
      SendStream sendStream=rtpManager.createSendStream(dataSource,i);
      TransformConnector transConnector=this.transConnectors.get(rtpManager);
      if (transConnector != null) {
        long ssrc=sendStream.getSSRC();
        ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
        engine.setOwnSSRC(ssrc);
      }
      logger.trace(""String_Node_Str"" + format);
    }
 catch (    Exception exc) {
      throw new MediaException(""String_Node_Str"" + format,MediaException.IO_ERROR,exc);
    }
  }
}",0.9161326274728336
103888,"/** 
 * The input data stream calls this method to transform incoming packets.
 * @see PacketTransformer#reverseTransform(RawPacket)
 */
public RawPacket reverseTransform(RawPacket pkt){
  if (!started && enableZrtp) {
    startZrtp();
  }
  byte[] buffer=pkt.getBuffer();
  int offset=pkt.getOffset();
  if ((buffer[offset] & 0x10) != 0x10) {
    if (srtpInTransformer == null) {
      return pkt;
    }
    pkt=srtpInTransformer.reverseTransform(pkt);
    if (pkt != null && started && zrtpEngine.inState(ZrtpStateClass.ZrtpStates.WaitConfAck)) {
      zrtpEngine.conf2AckSecure();
    }
    return pkt;
  }
  if (enableZrtp) {
    ZrtpRawPacket zPkt=new ZrtpRawPacket(pkt);
    if (!zPkt.checkCrc()) {
      securityEventManager.showMessage(ZrtpCodes.MessageSeverity.Warning,EnumSet.of(ZrtpCodes.WarningCodes.WarningCRCmismatch));
      return null;
    }
    if (!zPkt.hasMagic() || zrtpEngine == null) {
      return null;
    }
    byte[] extHeader=zPkt.getMessagePart();
    zrtpEngine.processZrtpMessage(extHeader,zPkt.getSSRC());
  }
  return null;
}","/** 
 * The input data stream calls this method to transform incoming packets.
 * @see PacketTransformer#reverseTransform(RawPacket)
 */
public RawPacket reverseTransform(RawPacket pkt){
  if (!started && enableZrtp && ownSSRC != 0) {
    startZrtp();
  }
  byte[] buffer=pkt.getBuffer();
  int offset=pkt.getOffset();
  if ((buffer[offset] & 0x10) != 0x10) {
    if (srtpInTransformer == null) {
      return pkt;
    }
    pkt=srtpInTransformer.reverseTransform(pkt);
    if (pkt != null && started && zrtpEngine.inState(ZrtpStateClass.ZrtpStates.WaitConfAck)) {
      zrtpEngine.conf2AckSecure();
    }
    return pkt;
  }
  if (enableZrtp && ownSSRC != 0) {
    ZrtpRawPacket zPkt=new ZrtpRawPacket(pkt);
    if (!zPkt.checkCrc()) {
      securityEventManager.showMessage(ZrtpCodes.MessageSeverity.Warning,EnumSet.of(ZrtpCodes.WarningCodes.WarningCRCmismatch));
      return null;
    }
    if (!zPkt.hasMagic() || zrtpEngine == null) {
      return null;
    }
    byte[] extHeader=zPkt.getMessagePart();
    zrtpEngine.processZrtpMessage(extHeader,zPkt.getSSRC());
  }
  return null;
}",0.9851162790697674
103889,"/** 
 * Adds a custom component at the end of the conversation.
 * @param component the component to add at the end of the conversation.
 */
public void addComponent(ChatConversationComponent component){
  Style style=document.getStyleSheet().addStyle(StyleConstants.ComponentElementName,document.getStyleSheet().getStyle(""String_Node_Str""));
  style.addAttribute(AbstractDocument.ElementNameAttribute,StyleConstants.ComponentElementName);
  TransparentPanel wrapPanel=new TransparentPanel(new BorderLayout());
  wrapPanel.add(component,BorderLayout.NORTH);
  style.addAttribute(StyleConstants.ComponentAttribute,wrapPanel);
  style.addAttribute(""String_Node_Str"",""String_Node_Str"");
  style.addAttribute(""String_Node_Str"",component.getDate().getTime());
  try {
    document.insertString(document.getLength(),""String_Node_Str"",style);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
  this.setCarretToEnd();
}","/** 
 * Adds a custom component at the end of the conversation.
 * @param component the component to add at the end of the conversation.
 */
public void addComponent(ChatConversationComponent component){
  Style style=document.getStyleSheet().addStyle(StyleConstants.ComponentElementName,document.getStyleSheet().getStyle(""String_Node_Str""));
  style.addAttribute(AbstractDocument.ElementNameAttribute,StyleConstants.ComponentElementName);
  TransparentPanel wrapPanel=new TransparentPanel(new BorderLayout());
  wrapPanel.add(component,BorderLayout.NORTH);
  style.addAttribute(StyleConstants.ComponentAttribute,wrapPanel);
  style.addAttribute(""String_Node_Str"",""String_Node_Str"");
  style.addAttribute(""String_Node_Str"",component.getDate().getTime());
  try {
    document.insertString(document.getLength(),""String_Node_Str"",style);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
  this.scrollToBottom();
}",0.9883597883597884
103890,"/** 
 * Inserts the given string at the beginning of the contained in this panel document.
 * @param chatString the string to insert
 */
public void insertMessageAfterStart(String chatString){
  Element root=this.document.getDefaultRootElement();
  try {
    this.document.insertBeforeStart(root.getElement(0),chatString);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (!isHistory)   this.ensureDocumentSize();
  this.setCarretToEnd();
}","/** 
 * Inserts the given string at the beginning of the contained in this panel document.
 * @param chatString the string to insert
 */
public void insertMessageAfterStart(String chatString){
  Element root=this.document.getDefaultRootElement();
  try {
    this.document.insertBeforeStart(root.getElement(0),chatString);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (!isHistory)   this.ensureDocumentSize();
  this.scrollToBottom();
}",0.97992700729927
103891,"/** 
 * Highlights keywords searched in the history.
 * @param message the source message
 * @param keyword the searched keyword
 * @return the formatted message
 */
private String processKeyword(String message,String contentType,String keyword){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=START_PLAINTEXT_TAG;
    endPlainTextTag=END_PLAINTEXT_TAG;
  }
  Pattern p=Pattern.compile(keyword,Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Highlights keywords searched in the history.
 * @param message the source message
 * @param contentType the content type
 * @param keyword the searched keyword
 * @return the formatted message
 */
private String processKeyword(String message,String contentType,String keyword){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=START_PLAINTEXT_TAG;
    endPlainTextTag=END_PLAINTEXT_TAG;
  }
  Pattern p=Pattern.compile(keyword,Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.9825190497534738
103892,"/** 
 * Formats message smileys.
 * @param message The source message string.
 * @return The message string with properly formated smileys.
 */
private String processSmileys(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (!HTML_CONTENT_TYPE.equals(contentType)) {
    startPlainTextTag=START_PLAINTEXT_TAG;
    endPlainTextTag=END_PLAINTEXT_TAG;
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  Collection<Smiley> smileys=ImageLoader.getDefaultSmileyPack();
  Matcher m=getSmileyPattern(smileys).matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  int prevEnd=0;
  while (m.find()) {
    msgBuffer.append(message.substring(prevEnd,m.start()));
    prevEnd=m.end();
    String smileyString=m.group().trim();
    msgBuffer.append(endPlainTextTag);
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(ImageLoader.getSmiley(smileyString).getImagePath());
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(smileyString);
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(startPlainTextTag);
  }
  msgBuffer.append(message.substring(prevEnd));
  return msgBuffer.toString();
}","/** 
 * Formats message smileys.
 * @param message the source message string
 * @param contentType the content type
 * @return the message string with properly formated smileys
 */
private String processSmileys(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (!HTML_CONTENT_TYPE.equals(contentType)) {
    startPlainTextTag=START_PLAINTEXT_TAG;
    endPlainTextTag=END_PLAINTEXT_TAG;
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  Collection<Smiley> smileys=ImageLoader.getDefaultSmileyPack();
  Matcher m=getSmileyPattern(smileys).matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  int prevEnd=0;
  while (m.find()) {
    msgBuffer.append(message.substring(prevEnd,m.start()));
    prevEnd=m.end();
    String smileyString=m.group().trim();
    msgBuffer.append(endPlainTextTag);
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(ImageLoader.getSmiley(smileyString).getImagePath());
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(smileyString);
    msgBuffer.append(""String_Node_Str"");
    msgBuffer.append(startPlainTextTag);
  }
  msgBuffer.append(message.substring(prevEnd));
  return msgBuffer.toString();
}",0.9760649087221096
103893,"/** 
 * Appends the given string at the end of the contained in this panel document.
 * @param chatString the string to append
 */
public void appendMessageToEnd(String chatString){
  Element root=this.document.getDefaultRootElement();
  try {
    this.document.insertAfterEnd(root.getElement(root.getElementCount() - 1),chatString);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (!isHistory)   this.ensureDocumentSize();
  this.setCarretToEnd();
}","/** 
 * Appends the given string at the end of the contained in this panel document.
 * @param chatString the string to append
 */
public void appendMessageToEnd(String chatString){
  Element root=this.document.getDefaultRootElement();
  try {
    this.document.insertAfterEnd(root.getElement(root.getElementCount() - 1),chatString);
  }
 catch (  BadLocationException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (!isHistory)   this.ensureDocumentSize();
  this.scrollToBottom();
}",0.9803220035778176
103894,"/** 
 * Returns the string to be used as the tooltip for <i>event</i>. 
 * @return the string to be used as the tooltip for <i>event</i>.
 */
public String getToolTipText(MouseEvent event){
  if (currentHref != null && currentHref.length() != 0)   return currentHref;
 else   return null;
}","/** 
 * Returns the string to be used as the tooltip for <i>event</i>. 
 * @param event the <tt>MouseEvent</tt> 
 * @return the string to be used as the tooltip for <i>event</i>.
 */
public String getToolTipText(MouseEvent event){
  if (currentHref != null && currentHref.length() != 0)   return currentHref;
 else   return null;
}",0.9339774557165862
103895,"/** 
 * Returns the text contained in the write area editor.
 * @return The text contained in the write area editor.
 */
public String getTextFromWriteArea(String mimeType){
  if (mimeType.equals(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE)) {
    return writeMessagePanel.getText();
  }
 else {
    return writeMessagePanel.getTextAsHtml();
  }
}","/** 
 * Returns the text contained in the write area editor.
 * @param mimeType the mime type
 * @return The text contained in the write area editor.
 */
public String getTextFromWriteArea(String mimeType){
  if (mimeType.equals(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE)) {
    return writeMessagePanel.getText();
  }
 else {
    return writeMessagePanel.getTextAsHtml();
  }
}",0.955585464333782
103896,"/** 
 * Handles file transfer status changed in order to remove completed file transfers from the list of active transfers.
 */
public void statusChanged(FileTransferStatusChangeEvent event){
  FileTransfer fileTransfer=event.getFileTransfer();
  int newStatus=event.getNewStatus();
  if (newStatus == FileTransferStatusChangeEvent.COMPLETED || newStatus == FileTransferStatusChangeEvent.CANCELED || newStatus == FileTransferStatusChangeEvent.FAILED || newStatus == FileTransferStatusChangeEvent.REFUSED) {
    removeActiveFileTransfer(fileTransfer.getID());
    fileTransfer.removeStatusListener(this);
  }
}","/** 
 * Handles file transfer status changed in order to remove completed file transfers from the list of active transfers.
 * @param event the file transfer status change event the notified us forthe change
 */
public void statusChanged(FileTransferStatusChangeEvent event){
  FileTransfer fileTransfer=event.getFileTransfer();
  int newStatus=event.getNewStatus();
  if (newStatus == FileTransferStatusChangeEvent.COMPLETED || newStatus == FileTransferStatusChangeEvent.CANCELED || newStatus == FileTransferStatusChangeEvent.FAILED || newStatus == FileTransferStatusChangeEvent.REFUSED) {
    removeActiveFileTransfer(fileTransfer.getID());
    fileTransfer.removeStatusListener(this);
  }
}",0.935483870967742
103897,"/** 
 * Updates the status of the given chat transport in the send via selector box and notifies the user for the status change.
 */
public void updateChatTransportStatus(ChatTransport chatTransport){
  if (transportSelectorBox != null)   transportSelectorBox.updateTransportStatus(chatTransport);
  this.addMessage(chatTransport.getName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatTransport.getStatus().getStatusName()}),""String_Node_Str"");
  if (ConfigurationManager.isMultiChatWindowEnabled()) {
    if (getChatWindow().getChatTabCount() > 0) {
      getChatWindow().setTabIcon(this,new ImageIcon(Constants.getStatusIcon(chatTransport.getStatus())));
    }
  }
}","/** 
 * Updates the status of the given chat transport in the send via selector box and notifies the user for the status change.
 * @param chatTransport the <tt>chatTransport</tt> to update
 */
public void updateChatTransportStatus(ChatTransport chatTransport){
  if (transportSelectorBox != null)   transportSelectorBox.updateTransportStatus(chatTransport);
  this.addMessage(chatTransport.getName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatTransport.getStatus().getStatusName()}),""String_Node_Str"");
  if (ConfigurationManager.isMultiChatWindowEnabled()) {
    if (getChatWindow().getChatTabCount() > 0) {
      getChatWindow().setTabIcon(this,new ImageIcon(Constants.getStatusIcon(chatTransport.getStatus())));
    }
  }
}",0.9607717041800644
103898,"/** 
 * Adds the given file transfer <tt>id</tt> to the list of active file transfers.
 * @param id the identifier of the file transfer to add
 */
public void addActiveFileTransfer(String id,Object descriptor){
synchronized (activeFileTransfers) {
    activeFileTransfers.put(id,descriptor);
  }
}","/** 
 * Adds the given file transfer <tt>id</tt> to the list of active file transfers.
 * @param id the identifier of the file transfer to add
 * @param descriptor the descriptor of the file transfer
 */
public void addActiveFileTransfer(String id,Object descriptor){
synchronized (activeFileTransfers) {
    activeFileTransfers.put(id,descriptor);
  }
}",0.912442396313364
103899,"public void setChatSubject(String subject){
  if (subjectPanel != null) {
    subjectPanel.setSubject(subject);
    this.addMessage(chatSession.getChatName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatSession.getChatName(),subject}),ChatConversationPanel.TEXT_CONTENT_TYPE);
  }
}","/** 
 * Sets the given <tt>subject</tt> to this chat.
 * @param subject the subject to set
 */
public void setChatSubject(String subject){
  if (subjectPanel != null) {
    subjectPanel.setSubject(subject);
    this.addMessage(chatSession.getChatName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatSession.getChatName(),subject}),ChatConversationPanel.TEXT_CONTENT_TYPE);
  }
}",0.8837209302325582
103900,"/** 
 * Shows or hides the Stylebar depending on the value of parameter b.
 * @param b if true, makes the Stylebar visible, otherwise hides the Stylebar
 */
public void setStylebarVisible(boolean b){
  this.writeMessagePanel.setStylebarVisible(b);
}","/** 
 * Shows or hides the Stylebar depending on the value of parameter b.
 * @param b if true, makes the Stylebar visible, otherwise hides theStylebar
 */
public void setStylebarVisible(boolean b){
  this.writeMessagePanel.setStylebarVisible(b);
}",0.9979879275653925
103901,"public void updateChatContactStatus(ChatContact chatContact,String statusMessage){
  this.addMessage(chatContact.getName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,statusMessage,ChatConversationPanel.TEXT_CONTENT_TYPE);
}","/** 
 * Updates the contact status.
 * @param chatContact the chat contact to update
 * @param statusMessage the status message to show
 */
public void updateChatContactStatus(ChatContact chatContact,String statusMessage){
  this.addMessage(chatContact.getName(),System.currentTimeMillis(),Chat.STATUS_MESSAGE,statusMessage,ChatConversationPanel.TEXT_CONTENT_TYPE);
}",0.7643097643097643
103902,"public void inviteContacts(ChatTransport inviteChatTransport,Collection<String> chatContacts,String reason){
  ChatSession conferenceChatSession=null;
  if (chatSession instanceof MetaContactChatSession) {
    String newChatName=inviteChatTransport.getDisplayName();
    chatContacts.add(inviteChatTransport.getName());
    ConferenceChatManager conferenceChatManager=GuiActivator.getUIService().getConferenceChatManager();
    if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetMultiUserChat.class) != null) {
      ChatRoomWrapper chatRoomWrapper=conferenceChatManager.createChatRoom(newChatName,inviteChatTransport.getProtocolProvider(),chatContacts);
      conferenceChatSession=new ConferenceChatSession(this,chatRoomWrapper);
    }
 else     if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetAdHocMultiUserChat.class) != null) {
      AdHocChatRoomWrapper chatRoomWrapper=conferenceChatManager.createAdHocChatRoom(newChatName,inviteChatTransport.getProtocolProvider(),chatContacts);
      conferenceChatSession=new AdHocConferenceChatSession(this,chatRoomWrapper);
    }
    if (conferenceChatSession != null)     this.setChatSession(conferenceChatSession);
  }
 else {
    conferenceChatSession=chatSession;
    for (    String contactAddress : chatContacts) {
      conferenceChatSession.getCurrentChatTransport().inviteChatContact(contactAddress,reason);
    }
  }
}","/** 
 * Invites the given <tt>chatContacts</tt> to this chat.
 * @param inviteChatTransport the chat transport to use to send the invite
 * @param chatContacts the contacts to invite
 * @param reason the reason of the invite
 */
public void inviteContacts(ChatTransport inviteChatTransport,Collection<String> chatContacts,String reason){
  ChatSession conferenceChatSession=null;
  if (chatSession instanceof MetaContactChatSession) {
    String newChatName=inviteChatTransport.getDisplayName();
    chatContacts.add(inviteChatTransport.getName());
    ConferenceChatManager conferenceChatManager=GuiActivator.getUIService().getConferenceChatManager();
    if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetMultiUserChat.class) != null) {
      ChatRoomWrapper chatRoomWrapper=conferenceChatManager.createChatRoom(newChatName,inviteChatTransport.getProtocolProvider(),chatContacts);
      conferenceChatSession=new ConferenceChatSession(this,chatRoomWrapper);
    }
 else     if (inviteChatTransport.getProtocolProvider().getOperationSet(OperationSetAdHocMultiUserChat.class) != null) {
      AdHocChatRoomWrapper chatRoomWrapper=conferenceChatManager.createAdHocChatRoom(newChatName,inviteChatTransport.getProtocolProvider(),chatContacts);
      conferenceChatSession=new AdHocConferenceChatSession(this,chatRoomWrapper);
    }
    if (conferenceChatSession != null)     this.setChatSession(conferenceChatSession);
  }
 else {
    conferenceChatSession=chatSession;
    for (    String contactAddress : chatContacts) {
      conferenceChatSession.getCurrentChatTransport().inviteChatContact(contactAddress,reason);
    }
  }
}",0.9254799869834038
103903,"/** 
 * Adds the given <tt>IncomingFileTransferRequest</tt> to the conversation panel in order to notify the user of the incoming file.
 * @param request the request to display in the conversation panel
 * @param date the date on which the request has been received
 */
public void addIncomingFileTransferRequest(OperationSetFileTransfer fileTransferOpSet,IncomingFileTransferRequest request,Date date){
  this.addActiveFileTransfer(request.getID(),request);
  ReceiveFileConversationComponent component=new ReceiveFileConversationComponent(this,fileTransferOpSet,request,date);
  if (ConfigurationManager.isHistoryShown() && !isHistoryLoaded) {
synchronized (incomingEventBuffer) {
      incomingEventBuffer.add(component);
    }
  }
 else   this.getChatConversationPanel().addComponent(component);
}","/** 
 * Adds the given <tt>IncomingFileTransferRequest</tt> to the conversation panel in order to notify the user of the incoming file.
 * @param fileTransferOpSet the file transfer operation set
 * @param request the request to display in the conversation panel
 * @param date the date on which the request has been received
 */
public void addIncomingFileTransferRequest(OperationSetFileTransfer fileTransferOpSet,IncomingFileTransferRequest request,Date date){
  this.addActiveFileTransfer(request.getID(),request);
  ReceiveFileConversationComponent component=new ReceiveFileConversationComponent(this,fileTransferOpSet,request,date);
  if (ConfigurationManager.isHistoryShown() && !isHistoryLoaded) {
synchronized (incomingEventBuffer) {
      incomingEventBuffer.add(component);
    }
  }
 else   this.getChatConversationPanel().addComponent(component);
}",0.9638989169675092
103904,"/** 
 * Adds the given error message to the chat window conversation area.
 * @param contactName the name of the contact, for which the error occured
 * @param message the error message
 */
public void addErrorMessage(String contactName,String title,String message){
  this.addMessage(contactName,System.currentTimeMillis(),Chat.ERROR_MESSAGE,title,message,""String_Node_Str"");
}","/** 
 * Adds the given error message to the chat window conversation area.
 * @param contactName the name of the contact, for which the error occurred
 * @param title the title of the error
 * @param message the error message
 */
public void addErrorMessage(String contactName,String title,String message){
  this.addMessage(contactName,System.currentTimeMillis(),Chat.ERROR_MESSAGE,title,message,""String_Node_Str"");
}",0.9447236180904522
103905,"public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if ((this.chatSession != null) && this.chatSession.isContactListSupported()) {
    messagePane.remove(conversationPanel);
    TransparentPanel rightPanel=new TransparentPanel(new BorderLayout(5,5));
    Dimension chatContactPanelSize=new Dimension(150,100);
    rightPanel.setMinimumSize(chatContactPanelSize);
    rightPanel.setPreferredSize(chatContactPanelSize);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    this.chatContactListPanel.setOpaque(false);
    topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    topSplitPane.setBorder(null);
    topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setOpaque(false);
    topSplitPane.setResizeWeight(1.0D);
    ChatTransport chatTransport=chatSession.getCurrentChatTransport();
    JLabel localUserLabel=new JLabel(chatTransport.getProtocolProvider().getAccountID().getDisplayName());
    localUserLabel.setFont(localUserLabel.getFont().deriveFont(Font.BOLD));
    rightPanel.add(localUserLabel,BorderLayout.NORTH);
    rightPanel.add(chatContactListPanel,BorderLayout.CENTER);
    topSplitPane.setLeftComponent(conversationPanel);
    topSplitPane.setRightComponent(rightPanel);
    messagePane.setTopComponent(topSplitPane);
  }
 else {
    if (topSplitPane != null) {
      if (chatContactListPanel != null) {
        topSplitPane.remove(chatContactListPanel);
        chatContactListPanel=null;
      }
      this.messagePane.remove(topSplitPane);
      topSplitPane=null;
    }
    this.messagePane.setTopComponent(conversationPanel);
  }
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      subjectPanel=null;
      this.revalidate();
      this.repaint();
    }
    initChatTransportSelectorBox();
    if (!transportSelectorBox.getMenu().isEnabled()) {
      getChatConversationPanel().appendMessageToEnd(""String_Node_Str"" + GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
    }
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    removeChatTransportSelectorBox();
  }
  if (chatContactListPanel != null) {
    Iterator<ChatContact> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext()) {
      chatContactListPanel.addContact(chatParticipants.next());
    }
  }
  if (!chatSession.getCurrentChatTransport().allowsSmsMessage())   sendSmsCheckBox.setEnabled(false);
}","/** 
 * Sets the chat session to associate to this chat panel.
 * @param chatSession the chat session to associate to this chat panel
 */
public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if ((this.chatSession != null) && this.chatSession.isContactListSupported()) {
    messagePane.remove(conversationPanel);
    TransparentPanel rightPanel=new TransparentPanel(new BorderLayout(5,5));
    Dimension chatContactPanelSize=new Dimension(150,100);
    rightPanel.setMinimumSize(chatContactPanelSize);
    rightPanel.setPreferredSize(chatContactPanelSize);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    this.chatContactListPanel.setOpaque(false);
    topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    topSplitPane.setBorder(null);
    topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setOpaque(false);
    topSplitPane.setResizeWeight(1.0D);
    ChatTransport chatTransport=chatSession.getCurrentChatTransport();
    JLabel localUserLabel=new JLabel(chatTransport.getProtocolProvider().getAccountID().getDisplayName());
    localUserLabel.setFont(localUserLabel.getFont().deriveFont(Font.BOLD));
    rightPanel.add(localUserLabel,BorderLayout.NORTH);
    rightPanel.add(chatContactListPanel,BorderLayout.CENTER);
    topSplitPane.setLeftComponent(conversationPanel);
    topSplitPane.setRightComponent(rightPanel);
    messagePane.setTopComponent(topSplitPane);
  }
 else {
    if (topSplitPane != null) {
      if (chatContactListPanel != null) {
        topSplitPane.remove(chatContactListPanel);
        chatContactListPanel=null;
      }
      this.messagePane.remove(topSplitPane);
      topSplitPane=null;
    }
    this.messagePane.setTopComponent(conversationPanel);
  }
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      subjectPanel=null;
      this.revalidate();
      this.repaint();
    }
    initChatTransportSelectorBox();
    if (!transportSelectorBox.getMenu().isEnabled()) {
      getChatConversationPanel().appendMessageToEnd(""String_Node_Str"" + GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
    }
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    removeChatTransportSelectorBox();
  }
  if (chatContactListPanel != null) {
    Iterator<ChatContact> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext()) {
      chatContactListPanel.addContact(chatParticipants.next());
    }
  }
  if (!chatSession.getCurrentChatTransport().allowsSmsMessage())   sendSmsCheckBox.setEnabled(false);
}",0.9757213230119636
103906,"public ChatSession getChatSession(){
  return chatSession;
}","/** 
 * Returns the chat session associated with this chat panel.
 * @return the chat session associated with this chat panel
 */
public ChatSession getChatSession(){
  return chatSession;
}",0.48
103907,"public static ResourceManagementService getResources(){
  if (resourcesService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(ResourceManagementService.class.getName());
    if (serviceReference == null)     return null;
    resourcesService=(ResourceManagementService)bundleContext.getService(serviceReference);
  }
  return resourcesService;
}","/** 
 * Gets the <tt>ResourceManagementService</tt> instance which provides common resources such as internationalized and localized strings, images to the MSN bundle.
 * @return the <tt>ResourceManagementService</tt> instance which providescommon resources such as internationalized and localized strings, images to the MSN bundle
 */
public static ResourceManagementService getResources(){
  if (resources == null)   resources=ResourceManagementServiceUtils.getService(bundleContext);
  return resources;
}",0.233970753655793
103908,"/** 
 * Called when this bundle is started so the Framework can perform the bundle-specific activities necessary to start this bundle.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  MsnActivator.bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,ProtocolNames.MSN);
  msnProviderFactory=new ProtocolProviderFactoryMsnImpl();
  msnPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),msnProviderFactory,hashtable);
}","/** 
 * Called when this bundle is started so the Framework can perform the bundle-specific activities necessary to start this bundle.
 * @param context The execution context of the bundle being started.
 * @throws Exception If this method throws an exception, this bundle ismarked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle.
 */
public void start(BundleContext context) throws Exception {
  MsnActivator.bundleContext=context;
  Hashtable<String,String> hashtable=new Hashtable<String,String>();
  hashtable.put(ProtocolProviderFactory.PROTOCOL,ProtocolNames.MSN);
  msnProviderFactory=new ProtocolProviderFactoryMsnImpl();
  ReferenceURLStreamHandlerService.registerService(bundleContext);
  msnPpFactoryServReg=context.registerService(ProtocolProviderFactory.class.getName(),msnProviderFactory,hashtable);
}",0.9625907314349526
103909,"/** 
 * Removes the specified group from the buddy list.
 * @param groupToRemove the group that we'd like removed.
 */
public void removeGroup(ContactGroupMsnImpl groupToRemove){
  if (groupToRemove.getSourceGroup().getGroupId().equals(""String_Node_Str""))   return;
  logger.trace(""String_Node_Str"" + groupToRemove);
  MsnContact[] contacts=groupToRemove.getSourceGroup().getContacts();
  ModListenerRemoveGroup removedContactsListener=new ModListenerRemoveGroup(contacts.length);
  contactListModManager.addModificationListener(removedContactsListener);
  for (int i=0; i < contacts.length; i++) {
    logger.trace(""String_Node_Str"" + contacts[i]);
    msnProvider.getMessenger().removeFriend(contacts[i].getEmail(),false);
  }
  removedContactsListener.waitForLastEvent(contacts.length * 1000);
  contactListModManager.removeModificationListener(removedContactsListener);
  msnProvider.getMessenger().removeGroup(groupToRemove.getSourceGroup().getGroupId());
}","/** 
 * Removes the specified group from the buddy list.
 * @param groupToRemove the group that we'd like removed.
 */
public void removeGroup(ContactGroupMsnImpl groupToRemove){
  if (groupToRemove.getSourceGroup().getGroupId().equals(""String_Node_Str""))   return;
  logger.trace(""String_Node_Str"" + groupToRemove);
  MsnContact[] contacts=groupToRemove.getSourceGroup().getContacts();
  ModListenerRemoveGroup removedContactsListener=new ModListenerRemoveGroup(contacts.length);
  contactListModManager.addModificationListener(removedContactsListener);
  for (int i=0; i < contacts.length; i++) {
    logger.trace(""String_Node_Str"" + contacts[i]);
    msnProvider.getMessenger().removeFriend(contacts[i].getEmail(),groupToRemove.getSourceGroup().getGroupId());
  }
  removedContactsListener.waitForLastEvent(contacts.length * 1000);
  contactListModManager.removeModificationListener(removedContactsListener);
  msnProvider.getMessenger().removeGroup(groupToRemove.getSourceGroup().getGroupId());
}",0.9755351681957186
103910,"/** 
 * Creates a test suite containing tests of this class in a specific order. We'll first execute tests beginning with the ""test"" prefix and then go to ordered tests.We first execture tests for receiving messagese, so that a volatile contact is created for the sender. we'll then be able to retrieve this volatile contact and send them a message on our turn. We need to do things this way as the contact corresponding to the tester agent has been removed in the previous test and we no longer have it in our contact list.
 * @return Test a testsuite containing all tests to execute.
 */
public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(new TestOperationSetBasicInstantMessaging(""String_Node_Str""));
  suite.addTestSuite(TestOperationSetBasicInstantMessaging.class);
  suite.addTest(new TestOperationSetBasicInstantMessaging(""String_Node_Str""));
  return suite;
}","/** 
 * Creates a test suite containing tests of this class in a specific order. We'll first execute tests beginning with the ""test"" prefix and then go to ordered tests.We first execture tests for receiving messagese, so that a volatile contact is created for the sender. we'll then be able to retrieve this volatile contact and send them a message on our turn. We need to do things this way as the contact corresponding to the tester agent has been removed in the previous test and we no longer have it in our contact list.
 * @return Test a testsuite containing all tests to execute.
 */
public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(new TestOperationSetBasicInstantMessaging(""String_Node_Str""));
  suite.addTestSuite(TestOperationSetBasicInstantMessaging.class);
  suite.addTest(new TestOperationSetBasicInstantMessaging(""String_Node_Str""));
  suite.addTest(new TestOperationSetBasicInstantMessaging(""String_Node_Str""));
  return suite;
}",0.9448903156768326
103911,"/** 
 * Executes the action associated with the ""Hang up"" button which may be invoked by clicking the button in question or closing this dialog.
 */
private void actionPerformedOnHangupButton(){
  Call call=getCall();
  if (call != null)   CallManager.hangupCall(call);
  this.dispose();
}","/** 
 * Executes the action associated with the ""Hang up"" button which may be invoked by clicking the button in question or closing this dialog.
 */
private void actionPerformedOnHangupButton(){
  Call call=getCall();
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  if (call != null)   CallManager.hangupCall(call);
  this.dispose();
}",0.8140845070422535
103912,"/** 
 * Implements CallListener.incomingCallReceived. When a call is received creates a <tt>ReceivedCallDialog</tt> and plays the ring phone sound to the user.
 */
public void incomingCallReceived(CallEvent event){
  Call sourceCall=event.getSourceCall();
  ReceivedCallDialog receivedCallDialog=new ReceivedCallDialog(sourceCall);
  receivedCallDialog.pack();
  receivedCallDialog.setVisible(true);
  NotificationManager.fireNotification(NotificationManager.INCOMING_CALL,""String_Node_Str"",""String_Node_Str"" + sourceCall.getCallPeers().next());
}","/** 
 * Implements CallListener.incomingCallReceived. When a call is received creates a <tt>ReceivedCallDialog</tt> and plays the ring phone sound to the user.
 * @param event the <tt>CallEvent</tt>
 */
public void incomingCallReceived(CallEvent event){
  Call sourceCall=event.getSourceCall();
  ReceivedCallDialog receivedCallDialog=new ReceivedCallDialog(sourceCall);
  receivedCallDialog.pack();
  receivedCallDialog.setVisible(true);
  NotificationManager.fireNotification(NotificationManager.INCOMING_CALL,""String_Node_Str"",""String_Node_Str"" + sourceCall.getCallPeers().next());
}",0.9655781112091792
103913,"/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hang up button.
 */
public void callEnded(CallEvent event){
  Call sourceCall=event.getSourceCall();
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  NotificationManager.stopSound(NotificationManager.INCOMING_CALL);
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  if (activeCalls.get(sourceCall) != null) {
    CallDialog callDialog=activeCalls.get(sourceCall);
    disposeCallDialogWait(callDialog);
  }
}","/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hang up button.
 * @param event the <tt>CallEvent</tt>
 */
public void callEnded(CallEvent event){
  Call sourceCall=event.getSourceCall();
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  NotificationManager.stopSound(NotificationManager.INCOMING_CALL);
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  if (activeCalls.get(sourceCall) != null) {
    CallDialog callDialog=activeCalls.get(sourceCall);
    disposeCallDialogWait(callDialog);
  }
}",0.9679539852095316
103914,"/** 
 * Hang ups the given call.
 * @param call the call to answer
 */
public static void hangupCall(final Call call){
  NotificationManager.stopSound(NotificationManager.BUSY_CALL);
  NotificationManager.stopSound(NotificationManager.INCOMING_CALL);
  NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);
  new HangupCallThread(call).start();
}","/** 
 * Hang ups the given call.
 * @param call the call to answer
 */
public static void hangupCall(final Call call){
  new HangupCallThread(call).start();
}",0.6124031007751938
103915,"/** 
 * Creates and opens a call dialog. Implements CallListener.outGoingCallCreated. .
 */
public void outgoingCallCreated(CallEvent event){
  Call sourceCall=event.getSourceCall();
  CallDialog callDialog=CallManager.openCallDialog(sourceCall);
  activeCalls.put(sourceCall,callDialog);
}","/** 
 * Creates and opens a call dialog. Implements CallListener.outGoingCallCreated.
 * @param event the <tt>CallEvent</tt>
 */
public void outgoingCallCreated(CallEvent event){
  Call sourceCall=event.getSourceCall();
  CallDialog callDialog=CallManager.openCallDialog(sourceCall);
  activeCalls.put(sourceCall,callDialog);
}",0.93354943273906
103916,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by pressing the call or the hangup buttons.
 * @param e The <tt>ActionEvent</tt> to handle.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    CallManager.answerCall(incomingCall);
  }
 else   if (buttonName.equals(HANGUP_BUTTON)) {
    CallManager.hangupCall(incomingCall);
  }
  this.dispose();
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by pressing the call or the hangup buttons.
 * @param e The <tt>ActionEvent</tt> to handle.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    CallManager.answerCall(incomingCall);
  }
 else   if (buttonName.equals(HANGUP_BUTTON)) {
    NotificationManager.stopSound(NotificationManager.INCOMING_CALL);
    CallManager.hangupCall(incomingCall);
  }
  this.dispose();
}",0.8762475049900199
103917,"public void outgoingCallCreated(CallEvent event){
}","/** 
 * Indicates that an outgoing call has been created.
 */
public void outgoingCallCreated(CallEvent event){
}",0.6219512195121951
103918,"public void incomingCallReceived(CallEvent event){
}","/** 
 * Indicates that an incoming call has been received.
 */
public void incomingCallReceived(CallEvent event){
}",0.6227544910179641
103919,"public void callEnded(CallEvent event){
  this.dispose();
}","/** 
 * When call is remotely ended we close this dialog.
 * @param event the <tt>CallEvent</tt> that has been triggered
 */
public void callEnded(CallEvent event){
  Call sourceCall=event.getSourceCall();
  if (sourceCall.equals(incomingCall)) {
    this.dispose();
  }
}",0.3504531722054381
103920,"@Override protected void close(boolean isEscaped){
}","/** 
 * Invoked when this dialog is closed.
 */
protected void close(boolean isEscaped){
}",0.676056338028169
103921,"/** 
 * Create the list to be sure that contacts exchanging messages exists in each other lists
 * @throws Exception
 */
public void prepareContactList() throws Exception {
  if (getContact1() == null && getContact2() == null)   fixture.clearProvidersLists();
  if (getContact1() == null) {
    Object o=new Object();
synchronized (o) {
      o.wait(2000);
    }
    try {
      opSetPresence1.setAuthorizationHandler(new AuthHandler());
      opSetPresence1.subscribe(fixture.userID2);
    }
 catch (    OperationFailedException ex) {
    }
  }
  if (getContact2() == null) {
    try {
      opSetPresence2.setAuthorizationHandler(new AuthHandler());
      opSetPresence2.subscribe(fixture.userID1);
    }
 catch (    OperationFailedException ex1) {
    }
    logger.info(""String_Node_Str"");
    Object o=new Object();
synchronized (o) {
      o.wait(2000);
    }
  }
}","/** 
 * Create the list to be sure that contacts exchanging messages exists in each other lists
 * @throws Exception
 */
public void prepareContactList() throws Exception {
  if (contact1 == null && contact2 == null) {
    fixture.clearProvidersLists();
  }
  if (getContact1() == null) {
    Object o=new Object();
synchronized (o) {
      o.wait(2000);
    }
    try {
      opSetPresence1.setAuthorizationHandler(new AuthHandler());
      opSetPresence1.subscribe(fixture.userID2);
    }
 catch (    OperationFailedException ex) {
    }
  }
  if (getContact2() == null) {
    try {
      opSetPresence2.setAuthorizationHandler(new AuthHandler());
      opSetPresence2.subscribe(fixture.userID1);
    }
 catch (    OperationFailedException ex1) {
    }
    logger.info(""String_Node_Str"");
    Object o=new Object();
synchronized (o) {
      o.wait(2000);
    }
  }
}",0.9769850402761796
103922,"protected OperationSetServerStoredContactInfoFacebookImpl(ProtocolProviderServiceFacebookImpl provider){
  this.parentProvider=provider;
}","/** 
 * Creates a new instance of this class using the specified parent <tt>provider</tt>.
 * @param provider the provider that's creating us.
 */
protected OperationSetServerStoredContactInfoFacebookImpl(ProtocolProviderServiceFacebookImpl provider){
  this.parentProvider=provider;
}",0.6524822695035462
103923,"public static byte[] getImage(String urlStr){
  ByteArrayOutputStream byteArrayOS=new ByteArrayOutputStream();
  try {
    URL url=new URL(urlStr);
    BufferedImage newAvatar=ImageIO.read(url);
    javax.imageio.ImageIO.write(newAvatar,""String_Node_Str"",byteArrayOS);
  }
 catch (  IOException e) {
    logger.warn(""String_Node_Str"",e);
    return null;
  }
 finally {
    try {
      byteArrayOS.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return byteArrayOS.toByteArray();
}","/** 
 * Returns the bytes of the image at the specified <tt>urlStr</tt> location or <tt>null</tt> if we fail to retrieve it for some reason.
 * @param urlStr
 * @return a <tt>byte[]</tt> array containing the bytes of the image at thespecified <tt>urlStr</tt> location or <tt>null</tt> if we fail to retrieve it for some reason.
 */
public static byte[] getImage(String urlStr){
  ByteArrayOutputStream byteArrayOS=new ByteArrayOutputStream();
  try {
    URL url=new URL(urlStr);
    BufferedImage newAvatar=ImageIO.read(url);
    javax.imageio.ImageIO.write(newAvatar,""String_Node_Str"",byteArrayOS);
  }
 catch (  IOException e) {
    logger.warn(""String_Node_Str"",e);
    return null;
  }
 finally {
    try {
      byteArrayOS.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return byteArrayOS.toByteArray();
}",0.7565982404692082
103924,"public void initialEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailInitMessage message,MsnContact contact){
}","/** 
 * Not interested in this event.
 */
public void initialEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailInitMessage message,MsnContact contact){
}",0.8531468531468531
103925,"public void switchboardClosed(MsnSwitchboard switchboard){
  AdHocChatRoomMsnImpl adHocChatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (adHocChatRoom == null)   return;
 else {
    adHocChatRoom.setSwitchboard(null);
    adHocChatRoom.leave();
    fireLocalUserPresenceEvent(adHocChatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED,""String_Node_Str"");
  }
}","/** 
 * Indicates that a switchboard has been closed.
 * @param switchboard the switchboard that has been closed
 */
public void switchboardClosed(MsnSwitchboard switchboard){
  AdHocChatRoomMsnImpl adHocChatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (adHocChatRoom == null)   return;
 else {
    adHocChatRoom.setSwitchboard(null);
    adHocChatRoom.leave();
    fireLocalUserPresenceEvent(adHocChatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED,""String_Node_Str"");
  }
}",0.8665906499429875
103926,"/** 
 * Creates an <tt>AdHocChatRoom</tt> whose name is _adHocRoomName with the properties contained in _adHocRoomProperties
 * @param adHocRoomName the name of the ad-hoc room
 * @param adHocRoomProperties the ad-hoc room's properties
 * @throws OperationFailedException
 * @throws OperationNotSupportedException
 */
public AdHocChatRoom createAdHocChatRoom(String adHocRoomName,Map<String,Object> adHocRoomProperties) throws OperationFailedException, OperationNotSupportedException {
  AdHocChatRoom adHocRoom=adHocChatRoomCache.get(adHocRoomName);
  if (adHocRoom == null) {
    assertConnected();
    Object id=new Object();
    this.provider.getMessenger().newSwitchboard(id);
    adHocRoom=createLocalAdHocChatRoomInstance(adHocRoomName,id);
  }
  return adHocRoom;
}","/** 
 * Creates an <tt>AdHocChatRoom</tt> whose name is _adHocRoomName with the properties contained in _adHocRoomProperties
 * @param adHocRoomName the name of the ad-hoc room
 * @param adHocRoomProperties the ad-hoc room's properties
 * @return the created ad-hoc room
 * @throws OperationFailedException
 * @throws OperationNotSupportedException
 */
public AdHocChatRoom createAdHocChatRoom(String adHocRoomName,Map<String,Object> adHocRoomProperties) throws OperationFailedException, OperationNotSupportedException {
  AdHocChatRoom adHocRoom=adHocChatRoomCache.get(adHocRoomName);
  if (adHocRoom == null) {
    assertConnected();
    Object id=new Object();
    this.provider.getMessenger().newSwitchboard(id);
    adHocRoom=createLocalAdHocChatRoomInstance(adHocRoomName,id);
  }
  return adHocRoom;
}",0.9778621125869704
103927,"public void initialEmailDataReceived(MsnSwitchboard switchboard,MsnEmailInitEmailData message,MsnContact contact){
}","/** 
 * Not interested in this event.
 */
public void initialEmailDataReceived(MsnSwitchboard switchboard,MsnEmailInitEmailData message,MsnContact contact){
}",0.8467153284671532
103928,"public void contactJoinSwitchboard(MsnSwitchboard switchboard,MsnContact msnContact){
  if (!isGroupChatMessage(switchboard))   return;
  try {
    AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
    if (chatRoom == null) {
      chatRoom=createLocalAdHocChatRoomInstance(switchboard);
    }
    OperationSetPersistentPresenceMsnImpl presenceOpSet=(OperationSetPersistentPresenceMsnImpl)provider.getOperationSet(OperationSetPersistentPresence.class);
    ContactMsnImpl contact=presenceOpSet.getServerStoredContactList().findContactById(msnContact.getEmail().getEmailAddress());
    if (contact == null)     contact=new ContactMsnImpl(msnContact,presenceOpSet.getServerStoredContactList(),false,false);
    chatRoom.addAdHocChatRoomParticipant(msnContact.getId(),contact);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","/** 
 * Indicates that the given <tt>msnContact</tt> has joined the given <tt>switchboard</tt>.
 * @param switchboard the switchboard
 * @param msnContact the contact that has joined
 */
public void contactJoinSwitchboard(MsnSwitchboard switchboard,MsnContact msnContact){
  if (!isGroupChatMessage(switchboard))   return;
  try {
    AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
    if (chatRoom == null) {
      chatRoom=createLocalAdHocChatRoomInstance(switchboard);
    }
    OperationSetPersistentPresenceMsnImpl presenceOpSet=(OperationSetPersistentPresenceMsnImpl)provider.getOperationSet(OperationSetPersistentPresence.class);
    ContactMsnImpl contact=presenceOpSet.getServerStoredContactList().findContactById(msnContact.getEmail().getEmailAddress());
    if (contact == null)     contact=new ContactMsnImpl(msnContact,presenceOpSet.getServerStoredContactList(),false,false);
    chatRoom.addAdHocChatRoomParticipant(msnContact.getId(),contact);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.9031589849818746
103929,"public void activityEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailActivityMessage message,MsnContact contact){
}","/** 
 * Not interested in this event.
 */
public void activityEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailActivityMessage message,MsnContact contact){
}",0.8581081081081081
103930,"public void contactLeaveSwitchboard(MsnSwitchboard switchboard,MsnContact contact){
  logger.debug(contact.getDisplayName() + ""String_Node_Str"");
  AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (chatRoom == null) {
    chatRoom=createLocalAdHocChatRoomInstance(switchboard);
  }
  String participantId=contact.getId();
  Contact participant=chatRoom.getAdHocChatRoomParticipant(participantId);
  if (participant != null) {
    chatRoom.removeParticipant(participantId);
  }
}","/** 
 * Indicates that the given <tt>contact</tt> has left the given <tt>switchboard</tt>.
 * @param switchboard the switchboard
 * @param contact the contact that has left
 */
public void contactLeaveSwitchboard(MsnSwitchboard switchboard,MsnContact contact){
  logger.debug(contact.getDisplayName() + ""String_Node_Str"");
  AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (chatRoom == null)   return;
  String participantId=contact.getId();
  Contact participant=chatRoom.getAdHocChatRoomParticipant(participantId);
  if (participant != null) {
    chatRoom.removeParticipant(participantId);
  }
}",0.7810026385224275
103931,"public void newEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailNotifyMessage message,MsnContact contact){
}","/** 
 * Not interested in this event.
 */
public void newEmailNotificationReceived(MsnSwitchboard switchboard,MsnEmailNotifyMessage message,MsnContact contact){
}",0.851063829787234
103932,"/** 
 * Creates an <tt>OperationSetAdHocMultiUserChatMsnImpl</tt> by specifying the parent provider.
 */
public OperationSetAdHocMultiUserChatMsnImpl(ProtocolProviderServiceMsnImpl provider){
  this.provider=provider;
  this.provider.addRegistrationStateChangeListener(new RegistrationStateListener());
}","/** 
 * Creates an <tt>OperationSetAdHocMultiUserChatMsnImpl</tt> by specifying the parent provider.
 * @param provider the Msn provider
 */
public OperationSetAdHocMultiUserChatMsnImpl(ProtocolProviderServiceMsnImpl provider){
  this.provider=provider;
  this.provider.addRegistrationStateChangeListener(new RegistrationStateListener());
}",0.9440993788819876
103933,"public void instantMessageReceived(MsnSwitchboard switchboard,MsnInstantMessage message,MsnContact contact){
  if (!isGroupChatMessage(switchboard))   return;
  Message newMessage=createMessage(message.getContent());
  logger.debug(""String_Node_Str"");
  AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (chatRoom == null) {
    chatRoom=createLocalAdHocChatRoomInstance(switchboard);
  }
  Contact participant=chatRoom.getAdHocChatRoomParticipant(contact.getId());
  AdHocChatRoomMessageReceivedEvent msgReceivedEvent=new AdHocChatRoomMessageReceivedEvent(chatRoom,participant,System.currentTimeMillis(),newMessage,AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
  chatRoom.fireMessageEvent(msgReceivedEvent);
}","/** 
 * Indicates that an instant message has been received.
 * @param switchboard the switchboard
 * @param message the message
 * @param contact the contact sending the message
 */
public void instantMessageReceived(MsnSwitchboard switchboard,MsnInstantMessage message,MsnContact contact){
  if (!isGroupChatMessage(switchboard))   return;
  Message newMessage=createMessage(message.getContent());
  logger.debug(""String_Node_Str"");
  AdHocChatRoomMsnImpl chatRoom=getLocalAdHocChatRoomInstance(switchboard);
  if (chatRoom == null) {
    chatRoom=createLocalAdHocChatRoomInstance(switchboard);
  }
  Contact participant=chatRoom.getAdHocChatRoomParticipant(contact.getId());
  AdHocChatRoomMessageReceivedEvent msgReceivedEvent=new AdHocChatRoomMessageReceivedEvent(chatRoom,participant,System.currentTimeMillis(),newMessage,AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
  chatRoom.fireMessageEvent(msgReceivedEvent);
}",0.892416225749559
103934,"public void switchboardStarted(MsnSwitchboard switchboard){
  Object switchboardID=switchboard.getAttachment();
  AdHocChatRoomMsnImpl adHocChatRoom=null;
  if (switchboardID != null && pendingAdHocChatRoomList.containsKey(switchboardID)) {
    adHocChatRoom=(AdHocChatRoomMsnImpl)pendingAdHocChatRoomList.get(switchboardID);
    pendingAdHocChatRoomList.remove(switchboardID);
    adHocChatRoom.setSwitchboard(switchboard);
    adHocChatRoom.updateParticipantsList(switchboard);
    adHocChatRoomCache.put(switchboard,adHocChatRoom);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}","/** 
 * Indicates that a switchboard has been started.
 * @param switchboard the switchboard that has been started
 */
public void switchboardStarted(MsnSwitchboard switchboard){
  Object switchboardID=switchboard.getAttachment();
  AdHocChatRoomMsnImpl adHocChatRoom=null;
  if (switchboardID != null && pendingAdHocChatRoomList.containsKey(switchboardID)) {
    adHocChatRoom=(AdHocChatRoomMsnImpl)pendingAdHocChatRoomList.get(switchboardID);
    pendingAdHocChatRoomList.remove(switchboardID);
    adHocChatRoom.setSwitchboard(switchboard);
    adHocChatRoom.updateParticipantsList(switchboard);
    adHocChatRoomCache.put(switchboard,adHocChatRoom);
  }
}",0.8653846153846154
103935,"/** 
 * Creates an <tt>AdHocChatRoomMsnImpl</tt> corresponding to the given <tt>switchboard</tt>.
 * @param switchboard  the Msn switchboard that will correspond to thecreated chat room
 * @return  an <tt>AdHocChatRoomMsnImpl</tt> corresponding to the given<tt>switchboard</tt>
 */
private AdHocChatRoomMsnImpl createLocalAdHocChatRoomInstance(MsnSwitchboard switchboard){
  AdHocChatRoomMsnImpl adHocChatRoom=(AdHocChatRoomMsnImpl)this.adHocChatRoomCache.get(String.valueOf(switchboard.hashCode()));
  if (adHocChatRoom == null) {
    String name=String.valueOf(switchboard.hashCode());
    adHocChatRoom=new AdHocChatRoomMsnImpl(name,provider,switchboard);
    this.adHocChatRoomCache.put(switchboard,adHocChatRoom);
    Object attachment=switchboard.getAttachment();
    if (attachment != null && pendingAdHocChatRoomList.containsKey(attachment)) {
      pendingAdHocChatRoomList.remove(attachment);
    }
  }
  adHocChatRoom.join();
  return adHocChatRoom;
}","/** 
 * Creates an <tt>AdHocChatRoomMsnImpl</tt> corresponding to the given <tt>switchboard</tt>.
 * @param switchboard  the Msn switchboard that will correspond to thecreated chat room
 * @return  an <tt>AdHocChatRoomMsnImpl</tt> corresponding to the given<tt>switchboard</tt>
 */
private AdHocChatRoomMsnImpl createLocalAdHocChatRoomInstance(MsnSwitchboard switchboard){
  AdHocChatRoomMsnImpl adHocChatRoom=(AdHocChatRoomMsnImpl)this.adHocChatRoomCache.get(switchboard);
  if (adHocChatRoom == null) {
    String name=String.valueOf(switchboard.hashCode());
    adHocChatRoom=new AdHocChatRoomMsnImpl(name,provider,switchboard);
    this.adHocChatRoomCache.put(switchboard,adHocChatRoom);
    Object attachment=switchboard.getAttachment();
    if (attachment != null && pendingAdHocChatRoomList.containsKey(attachment)) {
      pendingAdHocChatRoomList.remove(attachment);
    }
  }
  adHocChatRoom.join();
  return adHocChatRoom;
}",0.9214549288350028
103936,"/** 
 * Returns the buffered image corresponding to the given url image path.
 * @param imagePath the path indicating, where we can find the image.
 * @return the buffered image corresponding to the given url image path.
 */
public static BufferedImage getBufferedImage(URL imagePath){
  BufferedImage image=null;
  if (imagePath == null) {
    return null;
  }
  try {
    image=ImageIO.read(imagePath);
  }
 catch (  Exception exc) {
    logger.debug(""String_Node_Str"" + imagePath,exc);
  }
  return image;
}","/** 
 * Returns the buffered image corresponding to the given url image path.
 * @param imagePath the path indicating, where we can find the image.
 * @return the buffered image corresponding to the given url image path.
 */
public static BufferedImage getBufferedImage(URL imagePath){
  BufferedImage image=null;
  if (imagePath != null) {
    try {
      image=ImageIO.read(imagePath);
    }
 catch (    IOException ex) {
      logger.debug(""String_Node_Str"" + imagePath,ex);
    }
  }
  return image;
}",0.961576354679803
103937,"/** 
 * Returns a scaled image fitting within the given bounds while keeping the aspect ratio.
 * @param image the image to scale
 * @param width maximum width of the scaled image
 * @param height maximum height of the scaled image
 * @return the scaled image
 */
public static Image scaleImageWithinBounds(Image image,int width,int height){
  int initialWidth=image.getWidth(null);
  int initialHeight=image.getHeight(null);
  Image scaledImage;
  int scaleHint=Image.SCALE_SMOOTH;
  double originalRatio=(double)initialWidth / initialHeight;
  double areaRatio=(double)width / height;
  if (originalRatio > areaRatio) {
    scaledImage=image.getScaledInstance(width,-1,scaleHint);
  }
 else {
    scaledImage=image.getScaledInstance(-1,height,scaleHint);
  }
  return scaledImage;
}","/** 
 * Returns a scaled image fitting within the given bounds while keeping the aspect ratio.
 * @param image the image to scale
 * @param width maximum width of the scaled image
 * @param height maximum height of the scaled image
 * @return the scaled image
 */
public static Image scaleImageWithinBounds(Image image,int width,int height){
  int initialWidth=image.getWidth(null);
  int initialHeight=image.getHeight(null);
  Image scaledImage;
  int scaleHint=Image.SCALE_SMOOTH;
  double originalRatio=(double)initialWidth / initialHeight;
  double areaRatio=(double)width / height;
  if (originalRatio > areaRatio)   scaledImage=image.getScaledInstance(width,-1,scaleHint);
 else   scaledImage=image.getScaledInstance(-1,height,scaleHint);
  return scaledImage;
}",0.9587628865979382
103938,"/** 
 * Sets the image to display in the frame.
 * @param imageIcon the image to display in the frame
 */
public void setImageIcon(ImageIcon imageIcon){
  this.image=ImageUtils.getScaledRoundedImage(imageIcon.getImage(),width - 2,height - 2);
}","/** 
 * Sets the image to display in the frame.
 * @param imageIcon the image to display in the frame
 */
public void setImageIcon(ImageIcon imageIcon){
  image=ImageUtils.getScaledRoundedImage(imageIcon.getImage(),width - 2,height - 2);
}",0.989648033126294
103939,"/** 
 * Paints the contained image in a frame. Overrides   {@link JComponent#paintComponent(Graphics)}.
 */
public void paintComponent(Graphics g){
  if (image == null)   return;
  g.drawImage(image,width / 2 - image.getWidth(null) / 2,height / 2 - image.getHeight(null) / 2,null);
  g.drawImage(frameImage,width / 2 - frameImage.getWidth(null) / 2,height / 2 - frameImage.getHeight(null) / 2,null);
}","/** 
 * Paints the contained image in a frame. Overrides   {@link JComponent#paintComponent(Graphics)}.
 */
public void paintComponent(Graphics g){
  if (image != null) {
    int imageWidth=image.getWidth(this);
    int imageHeight=image.getHeight(this);
    if ((imageWidth != -1) && (imageHeight != -1))     g.drawImage(image,width / 2 - imageWidth / 2,height / 2 - imageHeight / 2,null);
  }
  int frameWidth=frameImage.getWidth(this);
  int frameHeight=frameImage.getHeight(this);
  if ((frameWidth != -1) && (frameHeight != -1))   g.drawImage(frameImage,width / 2 - frameWidth / 2,height / 2 - frameHeight / 2,null);
}",0.515625
103940,"/** 
 * Updates the global status by picking the most connected protocol provider status.
 */
private void updateGlobalStatus(){
  int status=0;
  Iterator<ProtocolProviderService> pProviders=mainFrame.getProtocolProviders();
  boolean isProtocolHidden;
  while (pProviders.hasNext()) {
    ProtocolProviderService protocolProvider=pProviders.next();
    isProtocolHidden=protocolProvider.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
    if (isProtocolHidden)     continue;
    OperationSetPresence presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
    if (presence == null) {
      if (protocolProvider.isRegistered() && status < PresenceStatus.AVAILABLE_THRESHOLD) {
        status=PresenceStatus.AVAILABLE_THRESHOLD;
      }
    }
 else {
      if (protocolProvider.isRegistered() && status < presence.getPresenceStatus().getStatus()) {
        status=presence.getPresenceStatus().getStatus();
      }
    }
  }
  JMenuItem item=getItemFromStatus(status);
  SelectedObject selectedObject=new SelectedObject(item.getText(),item.getIcon(),item);
  STATUS_STRING_WIDTH=SwingUtilities.computeStringWidth(this.getFontMetrics(this.getFont()),item.getText());
  setSelected(selectedObject);
  this.revalidate();
  setSystrayIcon(status);
}","/** 
 * Updates the global status by picking the most connected protocol provider status.
 */
private void updateGlobalStatus(){
  int status=0;
  Iterator<ProtocolProviderService> pProviders=mainFrame.getProtocolProviders();
  while (pProviders.hasNext()) {
    ProtocolProviderService protocolProvider=pProviders.next();
    boolean isProtocolHidden=protocolProvider.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
    if (isProtocolHidden)     continue;
    if (!protocolProvider.isRegistered())     continue;
    OperationSetPresence presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
    int presenceStatus=(presence == null) ? PresenceStatus.AVAILABLE_THRESHOLD : presence.getPresenceStatus().getStatus();
    if (status < presenceStatus)     status=presenceStatus;
  }
  JMenuItem item=getItemFromStatus(status);
  setSelected(new SelectedObject(item.getText(),item.getIcon(),item));
  computeTextWidth();
  this.revalidate();
  setSystrayIcon(status);
}",0.707874682472481
103941,"/** 
 * Overwrites the <tt>paintComponent(Graphics g)</tt> method in order to provide a new look and the mouse moves over this component.
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (STATUS_STRING_WIDTH != 0) {
    g=g.create();
    try {
      AntialiasingManager.activateAntialiasing(g);
      g.drawImage(arrowImage,STATUS_STRING_WIDTH + 2 * IMAGE_INDENT + 2,(this.getHeight() - arrowImage.getHeight(null)) / 2 + 3,null);
    }
  finally {
      g.dispose();
    }
  }
}","/** 
 * Overwrites the <tt>paintComponent(Graphics g)</tt> method in order to provide a new look and the mouse moves over this component.
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (textWidth != 0) {
    g=g.create();
    try {
      AntialiasingManager.activateAntialiasing(g);
      g.drawImage(arrowImage,textWidth + 2 * IMAGE_INDENT + 2,(this.getHeight() - arrowImage.getHeight(null)) / 2 + 3,null);
    }
  finally {
      g.dispose();
    }
  }
}",0.9474747474747476
103942,"/** 
 * Returns the last contact status saved in the configuration.
 * @param protocolProvider the protocol provider to which the statuscorresponds
 * @return the last contact status saved in the configuration.
 */
public String getLastStatusString(ProtocolProviderService protocolProvider){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String lastStatus=null;
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
      lastStatus=configService.getString(accountRootPropName + ""String_Node_Str"");
      if (lastStatus != null)       break;
    }
  }
  return lastStatus;
}","/** 
 * Returns the last contact status saved in the configuration.
 * @param protocolProvider the protocol provider to which the statuscorresponds
 * @return the last contact status saved in the configuration.
 */
public String getLastStatusString(ProtocolProviderService protocolProvider){
  String lastStatus=null;
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  String protocolProviderAccountUID=protocolProvider.getAccountID().getAccountUniqueID();
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProviderAccountUID)) {
      lastStatus=configService.getString(accountRootPropName + ""String_Node_Str"");
      if (lastStatus != null)       break;
    }
  }
  return lastStatus;
}",0.8385300668151447
103943,"/** 
 * Returns TRUE if there are selected status selector boxes, otherwise returns FALSE.
 */
public boolean hasSelectedMenus(){
  Enumeration<StatusSelectorMenu> statusMenus=accountMenus.elements();
  while (statusMenus.hasMoreElements()) {
    StatusSelectorMenu statusSelectorMenu=statusMenus.nextElement();
    if (statusSelectorMenu.isSelected()) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns TRUE if there are selected status selector boxes, otherwise returns FALSE.
 */
public boolean hasSelectedMenus(){
  for (  StatusSelectorMenu statusSelectorMenu : accountMenus.values())   if (statusSelectorMenu.isSelected())   return true;
  return false;
}",0.4510385756676557
103944,"/** 
 * Returns the last status that was stored in the configuration xml for the given protocol provider.
 * @param protocolProvider the protocol provider
 * @return the last status that was stored in the configuration xml for thegiven protocol provider
 */
public PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){
  String lastStatus=getLastStatusString(protocolProvider);
  OperationSetPresence presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
  if (presence == null)   return null;
  Iterator<PresenceStatus> i=presence.getSupportedStatusSet();
  if (lastStatus != null) {
    PresenceStatus status;
    while (i.hasNext()) {
      status=i.next();
      if (status.getStatusName().equals(lastStatus)) {
        return status;
      }
    }
  }
  return null;
}","/** 
 * Returns the last status that was stored in the configuration xml for the given protocol provider.
 * @param protocolProvider the protocol provider
 * @return the last status that was stored in the configuration xml for thegiven protocol provider
 */
public PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){
  String lastStatus=getLastStatusString(protocolProvider);
  if (lastStatus != null) {
    OperationSetPresence presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
    if (presence == null)     return null;
    Iterator<PresenceStatus> i=presence.getSupportedStatusSet();
    PresenceStatus status;
    while (i.hasNext()) {
      status=i.next();
      if (status.getStatusName().equals(lastStatus))       return status;
    }
  }
  return null;
}",0.7703349282296651
103945,"/** 
 * Creates an instance of <tt>SimpleStatusSelectorBox</tt>.
 * @param mainFrame The main application window.
 */
public GlobalStatusSelectorBox(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.setUI(new SIPCommStatusMenuUI());
  this.setOpaque(false);
  this.setText(""String_Node_Str"");
  this.setIcon(offlineIcon);
  String tooltip=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  onlineItem.setName(Constants.ONLINE_STATUS);
  offlineItem.setName(Constants.OFFLINE_STATUS);
  awayItem.setName(Constants.AWAY_STATUS);
  ffcItem.setName(Constants.FREE_FOR_CHAT_STATUS);
  onlineItem.addActionListener(this);
  offlineItem.addActionListener(this);
  awayItem.addActionListener(this);
  ffcItem.addActionListener(this);
  titleLabel=new JLabel(""String_Node_Str"");
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  this.add(onlineItem);
  this.add(ffcItem);
  this.add(awayItem);
  this.add(offlineItem);
  this.addSeparator();
}","/** 
 * Creates an instance of <tt>SimpleStatusSelectorBox</tt>.
 * @param mainFrame The main application window.
 */
public GlobalStatusSelectorBox(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  JLabel titleLabel=new JLabel(""String_Node_Str"");
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  onlineItem=createMenuItem(""String_Node_Str"",ImageLoader.USER_ONLINE_ICON,Constants.ONLINE_STATUS);
  ffcItem=createMenuItem(""String_Node_Str"",ImageLoader.USER_FFC_ICON,Constants.FREE_FOR_CHAT_STATUS);
  awayItem=createMenuItem(""String_Node_Str"",ImageLoader.USER_AWAY_ICON,Constants.AWAY_STATUS);
  offlineItem=createMenuItem(""String_Node_Str"",ImageLoader.USER_OFFLINE_ICON,Constants.OFFLINE_STATUS);
  this.addSeparator();
  this.setIcon(offlineItem.getIcon());
  this.setOpaque(false);
  this.setText(""String_Node_Str"");
  this.setToolTipText(""String_Node_Str"");
  this.setUI(new SIPCommStatusMenuUI());
  computeTextWidth();
}",0.4399447768062586
103946,"public void addAccount(ProtocolProviderService protocolProvider){
  OperationSetPersistentPresence presenceOpSet=(OperationSetPersistentPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
  boolean isHidden=protocolProvider.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
  if (isHidden)   return;
  StatusSelectorMenu statusSelectorMenu=null;
  if (presenceOpSet != null) {
    statusSelectorMenu=new PresenceStatusMenu(mainFrame,protocolProvider);
  }
 else {
    statusSelectorMenu=new SimpleStatusMenu(protocolProvider);
  }
  this.add(statusSelectorMenu);
  this.accountMenus.put(protocolProvider,statusSelectorMenu);
}","public void addAccount(ProtocolProviderService protocolProvider){
  boolean isHidden=protocolProvider.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
  if (isHidden)   return;
  OperationSetPersistentPresence presenceOpSet=(OperationSetPersistentPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
  StatusSelectorMenu statusSelectorMenu=(presenceOpSet != null) ? new PresenceStatusMenu(mainFrame,protocolProvider) : new SimpleStatusMenu(protocolProvider);
  this.add(statusSelectorMenu);
  this.accountMenus.put(protocolProvider,statusSelectorMenu);
}",0.5882352941176471
103947,"/** 
 * @param status Currently unused 
 */
public void updateStatus(Object status){
}","/** 
 * Stops the timer that manages the connecting animated icon.
 */
public void updateStatus(){
  String tooltip=this.getToolTipText();
  tooltip=tooltip.substring(0,tooltip.lastIndexOf(""String_Node_Str""));
  ImageIcon statusImage=ImageLoader.getAccountStatusImage(protocolProvider);
  JMenuItem menuItem=protocolProvider.isRegistered() ? onlineItem : offlineItem;
  setSelected(new SelectedObject(statusImage,menuItem));
  setToolTipText(tooltip.concat(""String_Node_Str"" + menuItem.getText()));
}",0.1569965870307167
103948,"private SimpleStatusMenu(ProtocolProviderService protocolProvider,String displayName,Image onlineImage){
  super(displayName,new ImageIcon(onlineImage));
  this.protocolProvider=protocolProvider;
  this.setToolTipText(""String_Node_Str"" + displayName + ""String_Node_Str"");
  JLabel titleLabel=new JLabel(displayName);
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  onlineItem=createMenuItem(""String_Node_Str"",getIcon(),Constants.ONLINE_STATUS);
  offlineItem=createMenuItem(""String_Node_Str"",new ImageIcon(LightGrayFilter.createDisabledImage(onlineImage)),Constants.OFFLINE_STATUS);
}","private SimpleStatusMenu(ProtocolProviderService protocolProvider,String displayName,Image onlineImage){
  super(displayName,new ImageIcon(onlineImage));
  this.protocolProvider=protocolProvider;
  this.setToolTipText(""String_Node_Str"" + displayName + ""String_Node_Str"");
  JLabel titleLabel=new JLabel(displayName);
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  onlineItem=createMenuItem(""String_Node_Str"",getIcon(),Constants.ONLINE_STATUS);
  offlineItem=createMenuItem(""String_Node_Str"",new ImageIcon(LightGrayFilter.createDisabledImage(onlineImage)),Constants.OFFLINE_STATUS);
  updateStatus();
}",0.987603305785124
103949,"/** 
 * Returns the service name - the server we are logging to if it is null which is not supposed to be - we return for compatibility the string we used in the first release for creating AccountID (Using this string is wrong, but used for compatibility for now)
 * @param accountProperties Map the properties table configuring the account
 * @return String the service name
 */
private static String getServiceName(Map accountProperties){
  String serviceName=(String)accountProperties.get(ProtocolProviderFactory.SERVER_ADDRESS);
  if (serviceName != null)   return serviceName;
 else   return ProtocolNames.IRC;
}","/** 
 * Returns the service name - the server we are logging to if it is null which is not supposed to be - we return for compatibility the string we used in the first release for creating AccountID (Using this string is wrong, but used for compatibility for now)
 * @param accountProperties Map the properties table configuring the account
 * @return String the service name
 */
private static String getServiceName(Map<String,String> accountProperties){
  String serviceName=accountProperties.get(ProtocolProviderFactory.SERVER_ADDRESS);
  return (serviceName == null) ? ProtocolNames.IRC : serviceName;
}",0.931372549019608
103950,"/** 
 * Returns the <tt>ResourceManagementService</tt>.
 * @return the <tt>ResourceManagementService</tt>.
 */
public static ResourceManagementService getResources(){
  if (resourceService == null) {
    ServiceReference serviceReference=bundleContext.getServiceReference(ResourceManagementService.class.getName());
    if (serviceReference == null)     return null;
    resourceService=(ResourceManagementService)bundleContext.getService(serviceReference);
  }
  return resourceService;
}","/** 
 * Returns the <tt>ResourceManagementService</tt>.
 * @return the <tt>ResourceManagementService</tt>.
 */
public static ResourceManagementService getResources(){
  if (resourceService == null)   resourceService=ResourceManagementServiceUtils.getService(bundleContext);
  return resourceService;
}",0.5620253164556962
103951,"/** 
 * This method is called whenever someone (possibly us) quits from the server. We will only observe this if the user was in one of the channels to which we are connected.
 * @param sourceNick The nick of the user that quit from the server.
 * @param sourceLogin The login of the user that quit from the server.
 * @param sourceHostname The host name of the user that quit from the server.
 * @param reason The reason given for quitting the server.
 */
protected void onQuit(String sourceNick,String sourceLogin,String sourceHostname,String reason){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + sourceNick + ""String_Node_Str""+ sourceLogin+ ""String_Node_Str""+ sourceHostname);
  Iterator joinedChatRooms=ircMUCOpSet.getCurrentlyJoinedChatRooms().iterator();
  while (joinedChatRooms.hasNext()) {
    ChatRoomIrcImpl chatRoom=(ChatRoomIrcImpl)joinedChatRooms.next();
    if (chatRoom.getUserNickname().equals(sourceNick))     ircMUCOpSet.fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED,reason);
 else {
      ChatRoomMember member=chatRoom.getChatRoomMember(sourceNick);
      if (member == null)       return;
      chatRoom.removeChatRoomMember(sourceNick);
      chatRoom.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT,reason);
    }
  }
}","/** 
 * This method is called whenever someone (possibly us) quits from the server. We will only observe this if the user was in one of the channels to which we are connected.
 * @param sourceNick The nick of the user that quit from the server.
 * @param sourceLogin The login of the user that quit from the server.
 * @param sourceHostname The host name of the user that quit from the server.
 * @param reason The reason given for quitting the server.
 */
protected void onQuit(String sourceNick,String sourceLogin,String sourceHostname,String reason){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + sourceNick + ""String_Node_Str""+ sourceLogin+ ""String_Node_Str""+ sourceHostname);
  for (  ChatRoom chatRoom : ircMUCOpSet.getCurrentlyJoinedChatRooms()) {
    ChatRoomIrcImpl chatRoomIrcImpl=(ChatRoomIrcImpl)chatRoom;
    if (chatRoom.getUserNickname().equals(sourceNick))     ircMUCOpSet.fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED,reason);
 else {
      ChatRoomMember member=chatRoomIrcImpl.getChatRoomMember(sourceNick);
      if (member == null)       return;
      chatRoomIrcImpl.removeChatRoomMember(sourceNick);
      chatRoomIrcImpl.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT,reason);
    }
  }
}",0.940910801656003
103952,"/** 
 * Who is.
 * @param userInfo
 */
private void onWhoIs(UserInfo userInfo){
  logger.trace(""String_Node_Str"" + userInfo.getNickName() + ""String_Node_Str""+ userInfo.getLogin()+ ""String_Node_Str""+ userInfo.getHostname());
  String whoisMessage=""String_Node_Str"" + userInfo.getNickName() + ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getHostname()+ ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getLogin()+ ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getServerInfo()+ ""String_Node_Str""+ ""String_Node_Str"";
  Iterator joinedChatRooms=userInfo.getJoinedChatRooms().iterator();
  while (joinedChatRooms.hasNext()) {
    whoisMessage+=""String_Node_Str"" + joinedChatRooms.next();
  }
  MessageIrcImpl message=new MessageIrcImpl(whoisMessage,MessageIrcImpl.DEFAULT_MIME_TYPE,MessageIrcImpl.DEFAULT_MIME_ENCODING,null);
  ChatRoomIrcImpl chatRoom=ircMUCOpSet.findSystemRoom();
  if (chatRoom == null || !chatRoom.isJoined())   return;
  ChatRoomMember sourceMember=ircMUCOpSet.findSystemMember();
  chatRoom.fireMessageReceivedEvent(message,sourceMember,System.currentTimeMillis(),ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);
}","/** 
 * Who is.
 * @param userInfo
 */
private void onWhoIs(UserInfo userInfo){
  ChatRoomIrcImpl chatRoom=ircMUCOpSet.findSystemRoom();
  if ((chatRoom == null) || !chatRoom.isJoined())   return;
  logger.trace(""String_Node_Str"" + userInfo.getNickName() + ""String_Node_Str""+ userInfo.getLogin()+ ""String_Node_Str""+ userInfo.getHostname());
  String whoisMessage=""String_Node_Str"" + userInfo.getNickName() + ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getHostname()+ ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getLogin()+ ""String_Node_Str""+ ""String_Node_Str""+ userInfo.getServerInfo()+ ""String_Node_Str""+ ""String_Node_Str"";
  for (  String joinedChatRoom : userInfo.getJoinedChatRooms())   whoisMessage+=""String_Node_Str"" + joinedChatRoom;
  MessageIrcImpl message=new MessageIrcImpl(whoisMessage,MessageIrcImpl.DEFAULT_MIME_TYPE,MessageIrcImpl.DEFAULT_MIME_ENCODING,null);
  chatRoom.fireMessageReceivedEvent(message,ircMUCOpSet.findSystemMember(),System.currentTimeMillis(),ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);
}",0.7303628847037207
103953,"/** 
 * This method is called whenever someone (possibly us) changes nick on any of the channels that we are on.
 * @param oldNick The old nick.
 * @param login The login of the user.
 * @param hostname The host name of the user.
 * @param newNick The new nick.
 */
protected void onNickChange(String oldNick,String login,String hostname,String newNick){
  logger.trace(""String_Node_Str"" + oldNick + ""String_Node_Str""+ newNick);
  this.notifyChatRoomOperation(0);
  Iterator joinedChatRoomsIter=ircMUCOpSet.getCurrentlyJoinedChatRooms().iterator();
  while (joinedChatRoomsIter.hasNext()) {
    ChatRoomIrcImpl chatRoom=(ChatRoomIrcImpl)joinedChatRoomsIter.next();
    if (chatRoom.getUserNickname().equals(oldNick)) {
      chatRoom.setNickName(newNick);
      return;
    }
    ChatRoomMember member=chatRoom.getChatRoomMember(oldNick);
    if (member == null)     continue;
    ChatRoomMemberPropertyChangeEvent evt=new ChatRoomMemberPropertyChangeEvent(member,chatRoom,ChatRoomMemberPropertyChangeEvent.MEMBER_NICKNAME,oldNick,newNick);
    chatRoom.fireMemberPropertyChangeEvent(evt);
  }
}","/** 
 * This method is called whenever someone (possibly us) changes nick on any of the channels that we are on.
 * @param oldNick The old nick.
 * @param login The login of the user.
 * @param hostname The host name of the user.
 * @param newNick The new nick.
 */
protected void onNickChange(String oldNick,String login,String hostname,String newNick){
  logger.trace(""String_Node_Str"" + oldNick + ""String_Node_Str""+ newNick);
  this.notifyChatRoomOperation(0);
  for (  ChatRoom chatRoom : ircMUCOpSet.getCurrentlyJoinedChatRooms()) {
    ChatRoomIrcImpl chatRoomIrcImpl=(ChatRoomIrcImpl)chatRoom;
    if (chatRoom.getUserNickname().equals(oldNick)) {
      chatRoomIrcImpl.setNickName(newNick);
      return;
    }
    ChatRoomMember member=chatRoomIrcImpl.getChatRoomMember(oldNick);
    if (member == null)     continue;
    ChatRoomMemberPropertyChangeEvent evt=new ChatRoomMemberPropertyChangeEvent(member,chatRoom,ChatRoomMemberPropertyChangeEvent.MEMBER_NICKNAME,oldNick,newNick);
    chatRoomIrcImpl.fireMemberPropertyChangeEvent(evt);
  }
}",0.9212855146716348
103954,"/** 
 * Returns the byte representation of the image corresponding to the given identifier.
 * @param imageID the identifier of the image
 * @return the byte representation of the image corresponding to the givenidentifier.
 */
private static byte[] getImageInBytes(String imageID){
  InputStream in=DictActivator.getResources().getImageInputStream(imageID);
  if (in == null)   return null;
  byte[] image=null;
  try {
    image=new byte[in.available()];
    in.read(image);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + imageID,e);
  }
  return image;
}","/** 
 * Returns the byte representation of the image corresponding to the given identifier.
 * @param imageID the identifier of the image
 * @return the byte representation of the image corresponding to the givenidentifier.
 */
private static byte[] getImageInBytes(String imageID){
  return ProtocolIconIrcImpl.getImageInBytes(imageID);
}",0.658669574700109
103955,"/** 
 * Returns the byte representation of the image corresponding to the given identifier.
 * @param imageID the identifier of the image
 * @return the byte representation of the image corresponding to the givenidentifier.
 */
public static byte[] getImageInBytes(String imageID){
  InputStream in=IrcActivator.getResources().getImageInputStream(imageID);
  if (in == null)   return null;
  byte[] image=null;
  try {
    image=new byte[in.available()];
    in.read(image);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + imageID,e);
  }
  return image;
}","/** 
 * Returns the byte representation of the image corresponding to the given identifier.
 * @param imageID the identifier of the image
 * @return the byte representation of the image corresponding to the givenidentifier.
 */
static byte[] getImageInBytes(String imageID){
  InputStream in=IrcActivator.getResources().getImageInputStream(imageID);
  byte[] image=null;
  if (in != null) {
    try {
      image=new byte[in.available()];
      in.read(image);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + imageID,e);
    }
  }
  return image;
}",0.9269565217391303
103956,"public OtrContactMenu(Contact contact){
  this.contact=contact;
  this.setText(contact.getDisplayName());
  getPopupMenu().addPopupMenuListener(this);
  OtrActivator.scOtrEngine.addListener(this);
  OtrActivator.scOtrKeyManager.addListener(this);
  setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));
  setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));
}","public OtrContactMenu(Contact contact,boolean inMacOSXScreenMenuBar){
  this.contact=contact;
  this.inMacOSXScreenMenuBar=inMacOSXScreenMenuBar;
  this.setText(contact.getDisplayName());
  if (!this.inMacOSXScreenMenuBar)   getPopupMenu().addPopupMenuListener(this);
  OtrActivator.scOtrEngine.addListener(this);
  OtrActivator.scOtrKeyManager.addListener(this);
  setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));
  setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));
}",0.8689809630459127
103957,"private void setSessionStatus(SessionStatus sessionStatus){
  if (sessionStatus != this.sessionStatus) {
    this.sessionStatus=sessionStatus;
    updateIcon();
    if (isPopupMenuVisible())     rebuildMenu();
  }
}","private void setSessionStatus(SessionStatus sessionStatus){
  if (sessionStatus != this.sessionStatus) {
    this.sessionStatus=sessionStatus;
    updateIcon();
    if (isPopupMenuVisible() || inMacOSXScreenMenuBar)     rebuildMenu();
  }
}",0.945054945054945
103958,"private void setOtrPolicy(OtrPolicy otrPolicy){
  if (!otrPolicy.equals(this.otrPolicy)) {
    this.otrPolicy=otrPolicy;
    if (isPopupMenuVisible())     rebuildMenu();
  }
}","private void setOtrPolicy(OtrPolicy otrPolicy){
  if (!otrPolicy.equals(this.otrPolicy)) {
    this.otrPolicy=otrPolicy;
    if (isPopupMenuVisible() || inMacOSXScreenMenuBar)     rebuildMenu();
  }
}",0.9333333333333332
103959,"public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  createOtrContactMenus(currentContact);
  if (whatsThis == null) {
    menu.addSeparator();
    whatsThis=new JMenuItem();
    whatsThis.setIcon(OtrActivator.resourceService.getImage(""String_Node_Str""));
    whatsThis.setText(OtrActivator.resourceService.getI18NString(""String_Node_Str""));
    whatsThis.addActionListener(this);
    menu.add(whatsThis);
  }
}","public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  createOtrContactMenus(currentContact);
  if (whatsThis == null) {
    JMenu menu=getMenu();
    menu.addSeparator();
    whatsThis=new JMenuItem();
    whatsThis.setIcon(OtrActivator.resourceService.getImage(""String_Node_Str""));
    whatsThis.setText(OtrActivator.resourceService.getI18NString(""String_Node_Str""));
    whatsThis.addActionListener(this);
    menu.add(whatsThis);
  }
}",0.9698375870069604
103960,"/** 
 * Gets the <code>JMenu</code> which is the component of this plugin. If it still doesn't exist, it's created.
 * @return the <code>JMenu</code> which is the component of this plugin
 */
private JMenu getMenu(){
  if (menu == null) {
    menu=new JMenu();
    menu.setText(getName());
    if (Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU.equals(getContainer())) {
      Icon icon=OtrActivator.resourceService.getImage(""String_Node_Str"");
      if (icon != null)       menu.setIcon(icon);
    }
    menu.getPopupMenu().addPopupMenuListener(this);
  }
  return menu;
}","/** 
 * Gets the <tt>JMenu</tt> which is the component of this plug-in. If it still doesn't exist, it's created.
 * @return the <tt>JMenu</tt> which is the component of this plug-in
 */
private JMenu getMenu(){
  if (menu == null) {
    menu=new JMenu();
    menu.setText(getName());
    if (Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU.equals(getContainer())) {
      Icon icon=OtrActivator.resourceService.getImage(""String_Node_Str"");
      if (icon != null)       menu.setIcon(icon);
    }
    if (!inMacOSXScreenMenuBar)     menu.getPopupMenu().addPopupMenuListener(this);
  }
  return menu;
}",0.8170940170940171
103961,"private void createOtrContactMenus(MetaContact metaContact){
  for (int itemIndex=0, itemCount=menu.getItemCount(); itemIndex < itemCount; ) {
    JMenuItem menuItem=menu.getItem(itemIndex);
    if (menuItem instanceof OtrContactMenu) {
      menu.remove(itemIndex);
      itemCount--;
      ((OtrContactMenu)menuItem).dispose();
    }
 else     itemIndex++;
  }
  if (metaContact != null) {
    Iterator<Contact> contacts=metaContact.getContacts();
    int itemIndex=0;
    while (contacts.hasNext()) {
      menu.insert(new OtrContactMenu(contacts.next()),itemIndex);
      itemIndex++;
    }
  }
}","private void createOtrContactMenus(MetaContact metaContact){
  JMenu menu=getMenu();
  for (int itemIndex=0, itemCount=menu.getItemCount(); itemIndex < itemCount; ) {
    JMenuItem menuItem=menu.getItem(itemIndex);
    if (menuItem instanceof OtrContactMenu) {
      menu.remove(itemIndex);
      itemCount--;
      ((OtrContactMenu)menuItem).dispose();
    }
 else     itemIndex++;
  }
  if (metaContact != null) {
    Iterator<Contact> contacts=metaContact.getContacts();
    int itemIndex=0;
    while (contacts.hasNext()) {
      menu.insert(new OtrContactMenu(contacts.next(),inMacOSXScreenMenuBar),itemIndex);
      itemIndex++;
    }
  }
}",0.9630818619582664
103962,"public void setCurrentContact(MetaContact metaContact){
  if (this.currentContact != metaContact) {
    this.currentContact=metaContact;
    if ((menu != null) && menu.isPopupMenuVisible())     createOtrContactMenus(currentContact);
  }
}","public void setCurrentContact(MetaContact metaContact){
  if (this.currentContact != metaContact) {
    this.currentContact=metaContact;
    if (inMacOSXScreenMenuBar)     popupMenuWillBecomeVisible(null);
 else     if ((menu != null) && menu.isPopupMenuVisible())     createOtrContactMenus(currentContact);
  }
}",0.8638838475499092
103963,"public OtrMetaContactMenu(Container container){
  super(container);
}","public OtrMetaContactMenu(Container container){
  super(container);
  inMacOSXScreenMenuBar=Container.CONTAINER_CHAT_MENU_BAR.equals(container) && OtrActivator.uiService.useMacOSXScreenMenuBar();
}",0.518796992481203
103964,"/** 
 * Implements the <tt>ChatPanel.sendMessage</tt> method. Obtains the appropriate operation set and sends the message, contained in the write area, through it.
 */
protected void sendInstantMessage(){
  String htmlText=getTextFromWriteArea(""String_Node_Str"");
  String plainText=getTextFromWriteArea(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE);
  String messageText;
  String mimeType;
  if ((htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1)) {
    messageText=htmlText;
    mimeType=OperationSetBasicInstantMessaging.HTML_MIME_TYPE;
  }
 else {
    messageText=plainText;
    mimeType=OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE;
  }
  try {
    chatSession.getCurrentChatTransport().sendInstantMessage(messageText,mimeType);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
    this.addMessage(chatSession.getCurrentChatTransport().getName(),System.currentTimeMillis(),Chat.OUTGOING_MESSAGE,messageText,mimeType);
    this.addErrorMessage(chatSession.getCurrentChatTransport().getName(),GuiActivator.getResources().getI18NString(""String_Node_Str""));
  }
catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.addMessage(chatSession.getCurrentChatTransport().getName(),System.currentTimeMillis(),Chat.OUTGOING_MESSAGE,messageText,mimeType);
    this.addErrorMessage(chatSession.getCurrentChatTransport().getName(),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{ex.getMessage()}));
  }
  if (chatSession.getCurrentChatTransport().allowsTypingNotifications()) {
    getChatWritePanel().stopTypingTimer();
  }
  this.refreshWriteArea();
  this.requestFocusInWriteArea();
}","/** 
 * Implements the <tt>ChatPanel.sendMessage</tt> method. Obtains the appropriate operation set and sends the message, contained in the write area, through it.
 */
protected void sendInstantMessage(){
  String htmlText=getTextFromWriteArea(""String_Node_Str"");
  String plainText=getTextFromWriteArea(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE);
  String messageText;
  String mimeType;
  if ((htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1)) {
    messageText=htmlText;
    mimeType=OperationSetBasicInstantMessaging.HTML_MIME_TYPE;
  }
 else {
    messageText=plainText;
    mimeType=OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE;
  }
  try {
    chatSession.getCurrentChatTransport().sendInstantMessage(messageText,mimeType);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
    this.addMessage(chatSession.getCurrentChatTransport().getName(),System.currentTimeMillis(),Chat.OUTGOING_MESSAGE,messageText,mimeType);
    this.addErrorMessage(chatSession.getCurrentChatTransport().getName(),GuiActivator.getResources().getI18NString(""String_Node_Str""));
  }
catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.addMessage(chatSession.getCurrentChatTransport().getName(),System.currentTimeMillis(),Chat.OUTGOING_MESSAGE,messageText,mimeType);
    this.addErrorMessage(chatSession.getCurrentChatTransport().getName(),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{ex.getMessage()}));
  }
  if (chatSession.getCurrentChatTransport().allowsTypingNotifications()) {
    getChatWritePanel().stopTypingTimer();
  }
  this.refreshWriteArea();
}",0.9905869324473976
103965,"/** 
 * Defines actions when send button is pressed.
 * @param evt The <tt>ActionEvent</tt> object.
 */
public void actionPerformed(ActionEvent evt){
  if (!chatPanel.isWriteAreaEmpty()) {
    new Thread(){
      public void run(){
        chatPanel.sendMessage();
      }
    }
.start();
  }
}","/** 
 * Defines actions when send button is pressed.
 * @param evt The <tt>ActionEvent</tt> object.
 */
public void actionPerformed(ActionEvent evt){
  if (!chatPanel.isWriteAreaEmpty()) {
    new Thread(){
      public void run(){
        chatPanel.sendMessage();
      }
    }
.start();
  }
  chatPanel.requestFocusInWriteArea();
}",0.937799043062201
103966,"/** 
 * Creates the file to download.
 * @return the file to download.
 */
private File createFile(IncomingFileTransferRequest fileTransferRequest){
  File downloadFile=null;
  File downloadDir=null;
  String incomingFileName=fileTransferRequest.getFileName();
  try {
    downloadDir=GuiActivator.getFileAccessService().getDefaultDownloadDirectory();
    if (!downloadDir.exists()) {
      if (!downloadDir.mkdirs()) {
        logger.error(""String_Node_Str"" + downloadDir.getAbsolutePath());
      }
      logger.debug(""String_Node_Str"" + downloadDir.getAbsolutePath());
    }
  }
 catch (  IOException e) {
    logger.debug(""String_Node_Str"",e);
  }
  downloadFile=new File(downloadDir,incomingFileName);
  int index=0;
  while (downloadFile.exists()) {
    String newFileName=incomingFileName.substring(0,incomingFileName.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"" + ++index+ incomingFileName.substring(incomingFileName.lastIndexOf(""String_Node_Str""));
    downloadFile=new File(downloadDir,newFileName);
  }
  fileLabel.setText(downloadFile.getName());
  return downloadFile;
}","/** 
 * Creates the file to download.
 * @return the file to download.
 */
private File createFile(IncomingFileTransferRequest fileTransferRequest){
  File downloadFile=null;
  File downloadDir=null;
  String incomingFileName=fileTransferRequest.getFileName();
  try {
    downloadDir=GuiActivator.getFileAccessService().getDefaultDownloadDirectory();
    if (!downloadDir.exists()) {
      if (!downloadDir.mkdirs()) {
        logger.error(""String_Node_Str"" + downloadDir.getAbsolutePath());
      }
      logger.debug(""String_Node_Str"" + downloadDir.getAbsolutePath());
    }
  }
 catch (  IOException e) {
    logger.debug(""String_Node_Str"",e);
  }
  downloadFile=new File(downloadDir,incomingFileName);
  int index=0;
  while (downloadFile.exists()) {
    String newFileName=incomingFileName.substring(0,incomingFileName.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"" + ++index+ incomingFileName.substring(incomingFileName.lastIndexOf(""String_Node_Str""));
    downloadFile=new File(downloadDir,newFileName);
  }
  if (!downloadFile.getName().equals(fileTransferRequest.getFileName())) {
    String fileName=getFileLabel(downloadFile.getName(),fileTransferRequest.getFileSize());
    fileLabel.setText(fileName);
  }
  return downloadFile;
}",0.8867037195382642
103967,"/** 
 * Initializes the dialog.
 */
private void init(){
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.getRootPane().setDefaultButton(addButton);
  this.addButton.setName(""String_Node_Str"");
  this.cancelButton.setName(""String_Node_Str"");
  this.addButton.addActionListener(this);
  this.cancelButton.addActionListener(this);
  this.addButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.buttonsPanel.add(addButton);
  this.buttonsPanel.add(cancelButton);
  this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5,10,0,10));
  this.mainPanel.add(groupPanel,BorderLayout.CENTER);
  this.mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
}","/** 
 * Initializes the dialog.
 */
private void init(){
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.getRootPane().setDefaultButton(addButton);
  this.addButton.setName(""String_Node_Str"");
  this.cancelButton.setName(""String_Node_Str"");
  this.addButton.addActionListener(this);
  this.cancelButton.addActionListener(this);
  this.addButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.buttonsPanel.add(addButton);
  this.buttonsPanel.add(cancelButton);
  this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5,10,0,10));
  this.mainPanel.add(groupPanel,BorderLayout.CENTER);
  this.mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
  this.addWindowFocusListener(this);
}",0.9787965616045844
103968,"/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.mainCallPanel=new MainCallPanel(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
    public void windowClosing(    WindowEvent event){
      MainFrame.this.windowClosing(event);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if ((glassPane != null) && glassPane.isVisible())       glassPane.revalidate();
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  this.init();
  this.initPluginComponents();
}","/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.mainCallPanel=new MainCallPanel(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if ((glassPane != null) && glassPane.isVisible())       glassPane.revalidate();
    }
  }
);
  this.initTitleFont();
  ResourceManagementService resources=GuiActivator.getResources();
  String applicationName=resources.getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  this.init();
  this.initPluginComponents();
}",0.953330312641595
103969,"/** 
 * @param event Currently not used
 */
protected void windowClosing(WindowEvent event){
  if (!GuiActivator.getUIService().getExitOnMainWindowClose()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (ConfigurationManager.isQuitWarningShown()) {
          MessageDialog dialog=new MessageDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),false);
          if (dialog.showDialog() == MessageDialog.OK_DONT_ASK_CODE)           ConfigurationManager.setQuitWarningShown(false);
        }
      }
    }
);
    ConfigurationManager.setApplicationVisible(false);
  }
}","protected void windowClosing(WindowEvent event){
  super.windowClosing(event);
  if (!GuiActivator.getUIService().getExitOnMainWindowClose()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (ConfigurationManager.isQuitWarningShown()) {
          MessageDialog dialog=new MessageDialog(null,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),false);
          if (dialog.showDialog() == MessageDialog.OK_DONT_ASK_CODE)           ConfigurationManager.setQuitWarningShown(false);
        }
      }
    }
);
    ConfigurationManager.setApplicationVisible(false);
  }
}",0.8998527245949927
103970,"/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recomended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    if (IcqAccountID.isAIM(accountID.getAccountProperties()))     USING_ICQ=false;
    supportedOperationSets.put(OperationSetInstantMessageTransform.class.getName(),new OperationSetInstantMessageTransformImpl());
    OperationSetPersistentPresence persistentPresence=new OperationSetPersistentPresenceIcqImpl(this,screenname);
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessaging basicInstantMessaging=new OperationSetBasicInstantMessagingIcqImpl(this);
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    OperationSetMultiUserChatIcqImpl multiUserOpSet=new OperationSetMultiUserChatIcqImpl(this);
    supportedOperationSets.put(OperationSetMultiUserChat.class.getName(),multiUserOpSet);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsIcqImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    if (USING_ICQ) {
      this.infoRetreiver=new InfoRetreiver(this,screenname);
      OperationSetServerStoredContactInfo serverStoredContactInfo=new OperationSetServerStoredContactInfoIcqImpl(infoRetreiver,this);
      supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),serverStoredContactInfo);
      OperationSetServerStoredAccountInfo serverStoredAccountInfo=new OperationSetServerStoredAccountInfoIcqImpl(infoRetreiver,screenname,this);
      supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),serverStoredAccountInfo);
      OperationSetWebAccountRegistration webAccountRegistration=new OperationSetWebAccountRegistrationIcqImpl();
      supportedOperationSets.put(OperationSetWebAccountRegistration.class.getName(),webAccountRegistration);
      OperationSetWebContactInfo webContactInfo=new OperationSetWebContactInfoIcqImpl();
      supportedOperationSets.put(OperationSetWebContactInfo.class.getName(),webContactInfo);
      OperationSetExtendedAuthorizationsIcqImpl extendedAuth=new OperationSetExtendedAuthorizationsIcqImpl(this);
      supportedOperationSets.put(OperationSetExtendedAuthorizations.class.getName(),extendedAuth);
      OperationSetFileTransferIcqImpl fileTransferOpSet=new OperationSetFileTransferIcqImpl(this);
      supportedOperationSets.put(OperationSetFileTransfer.class.getName(),fileTransferOpSet);
    }
    isInitialized=true;
  }
}","/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recomended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    if (IcqAccountID.isAIM(accountID.getAccountProperties()))     USING_ICQ=false;
    supportedOperationSets.put(OperationSetInstantMessageTransform.class.getName(),new OperationSetInstantMessageTransformImpl());
    OperationSetPersistentPresence persistentPresence=new OperationSetPersistentPresenceIcqImpl(this,screenname);
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessaging basicInstantMessaging=new OperationSetBasicInstantMessagingIcqImpl(this);
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    OperationSetMultiUserChatIcqImpl multiUserOpSet=new OperationSetMultiUserChatIcqImpl(this);
    supportedOperationSets.put(OperationSetMultiUserChat.class.getName(),multiUserOpSet);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsIcqImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    if (USING_ICQ) {
      this.infoRetreiver=new InfoRetreiver(this,screenname);
      OperationSetServerStoredContactInfo serverStoredContactInfo=new OperationSetServerStoredContactInfoIcqImpl(infoRetreiver,this);
      supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),serverStoredContactInfo);
      OperationSetServerStoredAccountInfo serverStoredAccountInfo=new OperationSetServerStoredAccountInfoIcqImpl(infoRetreiver,screenname,this);
      supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),serverStoredAccountInfo);
      OperationSetWebAccountRegistration webAccountRegistration=new OperationSetWebAccountRegistrationIcqImpl();
      supportedOperationSets.put(OperationSetWebAccountRegistration.class.getName(),webAccountRegistration);
      OperationSetWebContactInfo webContactInfo=new OperationSetWebContactInfoIcqImpl();
      supportedOperationSets.put(OperationSetWebContactInfo.class.getName(),webContactInfo);
      OperationSetExtendedAuthorizationsIcqImpl extendedAuth=new OperationSetExtendedAuthorizationsIcqImpl(this);
      supportedOperationSets.put(OperationSetExtendedAuthorizations.class.getName(),extendedAuth);
    }
    OperationSetFileTransferIcqImpl fileTransferOpSet=new OperationSetFileTransferIcqImpl(this);
    supportedOperationSets.put(OperationSetFileTransfer.class.getName(),fileTransferOpSet);
    isInitialized=true;
  }
}",0.9911811023622048
103971,"public void popupMenuCanceled(PopupMenuEvent e){
  hiddenWindow.setVisible(false);
  popupVisible=false;
}","public void popupMenuCanceled(PopupMenuEvent e){
  if (hiddenWindow != null) {
    hiddenWindow.dispose();
    hiddenWindow=null;
  }
}",0.6556016597510373
103972,"public void mouseReleased(MouseEvent e){
  if (e.getButton() == MouseEvent.BUTTON3 && !popupVisible) {
    int x=e.getX(), y=e.getY();
    hiddenWindow.setLocation(x,y);
    hiddenWindow.setVisible(true);
    this.popup.show(hiddenWindow,0,0);
    hiddenWindow.toFront();
    popupVisible=true;
  }
 else {
    popup.setVisible(false);
    popupVisible=false;
  }
}","@Override public void mouseReleased(MouseEvent e){
  showPopupMenu(e);
}",0.2562929061784897
103973,"public void popupMenuWillBecomeInvisible(PopupMenuEvent e){
  hiddenWindow.setVisible(false);
  popupVisible=false;
}","public void popupMenuWillBecomeInvisible(PopupMenuEvent e){
  if (hiddenWindow != null) {
    hiddenWindow.dispose();
    hiddenWindow=null;
  }
}",0.6844106463878327
103974,"public AWTMouseAdapter(JPopupMenu p){
  hiddenWindow=new JWindow();
  hiddenWindow.setAlwaysOnTop(true);
  this.popup=p;
  this.popup.addPopupMenuListener(new PopupMenuListener(){
    public void popupMenuWillBecomeVisible(    PopupMenuEvent e){
    }
    public void popupMenuWillBecomeInvisible(    PopupMenuEvent e){
      hiddenWindow.setVisible(false);
      popupVisible=false;
    }
    public void popupMenuCanceled(    PopupMenuEvent e){
      hiddenWindow.setVisible(false);
      popupVisible=false;
    }
  }
);
}","public AWTMouseAdapter(JPopupMenu p){
  this.popup=p;
  this.popup.addPopupMenuListener(new PopupMenuListener(){
    public void popupMenuWillBecomeVisible(    PopupMenuEvent e){
    }
    public void popupMenuWillBecomeInvisible(    PopupMenuEvent e){
      if (hiddenWindow != null) {
        hiddenWindow.dispose();
        hiddenWindow=null;
      }
    }
    public void popupMenuCanceled(    PopupMenuEvent e){
      if (hiddenWindow != null) {
        hiddenWindow.dispose();
        hiddenWindow=null;
      }
    }
  }
);
}",0.7417218543046358
103975,"/** 
 * Requests the focus in the write message area.
 */
public void requestFocusInWriteArea(){
  getChatWritePanel().getEditorPane().requestFocus();
}","/** 
 * Requests the focus in the write message area.
 */
public void requestFocusInWriteArea(){
  getChatWritePanel().getEditorPane().requestFocusInWindow();
}",0.9743589743589745
103976,"/** 
 * Compares the two dates. The comparison is based only on the day, month and year values. Returns 0 if the two dates are equals, a value < 0 if the first date is before the second one and > 0 if the first date is after the second one.
 * @param date1 the first date to compare
 * @param date2 the second date to compare with 
 * @return Returns 0 if the two dates are equals, a value < 0 ifthe first date is before the second one and > 0 if the first date is after the second one
 */
public static int compareDatesOnly(long date1,long date2){
  c1.setTimeInMillis(date1);
  c2.setTimeInMillis(date2);
  int day1=c1.get(Calendar.DAY_OF_MONTH);
  int month1=c1.get(Calendar.MONTH);
  int year1=c1.get(Calendar.YEAR);
  int day2=c2.get(Calendar.DAY_OF_MONTH);
  int month2=c2.get(Calendar.MONTH);
  int year2=c2.get(Calendar.YEAR);
  if ((day1 == day2) && (month1 == month2) && (year1 == year2)) {
    return 0;
  }
 else   if ((day1 < day2) && (month1 <= month2) && (year1 <= year2)) {
    return -1;
  }
 else {
    return 1;
  }
}","/** 
 * Compares the two dates. The comparison is based only on the day, month and year values. Returns 0 if the two dates are equals, a value < 0 if the first date is before the second one and > 0 if the first date is after the second one.
 * @param date1 the first date to compare
 * @param date2 the second date to compare with 
 * @return Returns 0 if the two dates are equals, a value < 0 ifthe first date is before the second one and > 0 if the first date is after the second one
 */
public static int compareDatesOnly(long date1,long date2){
  c1.setTimeInMillis(date1);
  c2.setTimeInMillis(date2);
  int day1=c1.get(Calendar.DAY_OF_MONTH);
  int month1=c1.get(Calendar.MONTH);
  int year1=c1.get(Calendar.YEAR);
  int day2=c2.get(Calendar.DAY_OF_MONTH);
  int month2=c2.get(Calendar.MONTH);
  int year2=c2.get(Calendar.YEAR);
  if (year1 < year2) {
    return -1;
  }
 else   if (year1 == year2) {
    if (month1 < month2)     return -1;
 else     if (month1 == month2) {
      if (day1 < day2)       return -1;
 else       if (day1 == day2)       return 0;
 else       return 1;
    }
 else     return 1;
  }
 else {
    return 1;
  }
}",0.8175985334555453
103977,"public JButton getNextButton(){
  return this.nextButton;
}","/** 
 * Returns the next wizard button.
 * @return the next wizard button
 */
public JButton getNextButton(){
  return this.nextButton;
}",0.6020408163265306
103978,"public JButton getBackButton(){
  return this.backButton;
}","/** 
 * Returns the back wizard button.
 * @return the back wizard button
 */
public JButton getBackButton(){
  return this.backButton;
}",0.6020408163265306
103979,"/** 
 * Implements the <tt>WizardContainer.setFinishButtonText()</tt> method.
 */
public void setFinishButtonText(String text){
  FINISH_TEXT=text;
}","/** 
 * Sets the text label of the ""Finish"" wizard button.
 * @param text the new label of the button
 */
public void setFinishButtonText(String text){
  this.setFinishButtonDefaultText(text);
}",0.5889212827988338
103980,"public void refresh(){
  this.pack();
  this.repaint();
}","/** 
 * Refreshes this wizard dialog.
 */
public void refresh(){
  this.pack();
  this.repaint();
}",0.7307692307692307
103981,"/** 
 * Resets the buttons to support the original panel rules, including whether the next or back buttons are enabled or disabled, or if the panel is finishable. If the panel in question has another panel behind it, enables the back button. Otherwise, disables it. If the panel in question has one or more panels in front of it, enables the next button. Otherwise, disables it.
 */
void resetButtonsToPanelRules(){
  WizardModel model=wizard.getModel();
  WizardPage page=model.getCurrentWizardPage();
  model.setCancelButtonText(Wizard.CANCEL_TEXT);
  Object backPageIdentifier=page.getBackPageIdentifier();
  model.setBackButtonEnabled((backPageIdentifier != null) && !WizardPage.DEFAULT_PAGE_IDENTIFIER.equals(backPageIdentifier));
  model.setBackButtonText(Wizard.BACK_TEXT);
  model.setNextFinishButtonEnabled(page.getNextPageIdentifier() != null);
  if (page.getNextPageIdentifier().equals(WizardPage.FINISH_PAGE_IDENTIFIER)) {
    model.setNextFinishButtonText(Wizard.FINISH_TEXT);
  }
 else {
    model.setNextFinishButtonText(Wizard.NEXT_TEXT);
  }
}","/** 
 * Resets the buttons to support the original panel rules, including whether the next or back buttons are enabled or disabled, or if the panel is finish-able. If the panel in question has another panel behind it, enables the back button. Otherwise, disables it. If the panel in question has one or more panels in front of it, enables the next button. Otherwise, disables it.
 */
void resetButtonsToPanelRules(){
  WizardModel model=wizard.getModel();
  WizardPage page=model.getCurrentWizardPage();
  model.setCancelButtonText(wizard.getCancelButtonDefaultText());
  Object backPageIdentifier=page.getBackPageIdentifier();
  model.setBackButtonEnabled((backPageIdentifier != null) && !WizardPage.DEFAULT_PAGE_IDENTIFIER.equals(backPageIdentifier));
  model.setBackButtonText(wizard.getBackButtonDefaultText());
  model.setNextFinishButtonEnabled(page.getNextPageIdentifier() != null);
  if (page.getNextPageIdentifier().equals(WizardPage.FINISH_PAGE_IDENTIFIER)) {
    model.setNextFinishButtonText(wizard.getFinishButtonDefaultText());
  }
 else {
    model.setNextFinishButtonText(wizard.getNextButtonDefaultText());
  }
}",0.8844221105527639
103982,"/** 
 * Removes the specified contact from this contact group
 * @param contact the contact to remove.
 */
void removeContact(ContactIcqImpl contact){
  buddies.remove(contact);
}","/** 
 * Removes the specified contact from this contact group
 * @param contact the contact to remove.
 */
void removeContact(ContactIcqImpl contact){
  for (Iterator<Map.Entry<String,Contact>> buddyIter=buddies.entrySet().iterator(); buddyIter.hasNext(); ) {
    if (buddyIter.next().getKey().equals(contact)) {
      buddyIter.remove();
      break;
    }
  }
}",0.5756457564575646
103983,"/** 
 * Creates an ICQ group using the specified <tt>joustSimGroup</tt> as a source. The newly created group will always return the name of the underlying joustSimGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl. <p> Note that we MUST NOT use the list of buddies obtained through the getBuddiesCopy() of the joustSimGroup arg as we'd later need to be able to directly compare ( == ) instances of buddies we've stored and others that are returned by the framework. <p>
 * @param joustSimGroup the JoustSIM Group correspoinding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupIcqImpl(MutableGroup joustSimGroup,List<Buddy> groupMembers,ServerStoredContactListIcqImpl ssclCallback,boolean isResolved){
  this.joustSimSourceGroup=joustSimGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  initNameCopy();
  Iterator<Buddy> buddies=groupMembers.iterator();
  while (buddies.hasNext()) {
    Buddy buddy=buddies.next();
    if (ssclCallback.findContactByJoustSimBuddy(buddy) != null) {
      continue;
    }
    addContact(new ContactIcqImpl(buddy,ssclCallback,true,true));
  }
}","/** 
 * Creates an ICQ group using the specified <tt>joustSimGroup</tt> as a source. The newly created group will always return the name of the underlying joustSimGroup and would thus automatically adapt to changes. It would, however, not receive or try to poll for modifications of the buddies it contains and would therefore have to be updated manually by ServerStoredContactListImpl. <p> Note that we MUST NOT use the list of buddies obtained through the getBuddiesCopy() of the joustSimGroup arg as we'd later need to be able to directly compare ( == ) instances of buddies we've stored and others that are returned by the framework. <p>
 * @param joustSimGroup the JoustSIM Group corresponding to the group
 * @param groupMembers the group members that we should add to the group.
 * @param ssclCallback a callback to the server stored contact listwe're creating.
 * @param isResolved a boolean indicating whether or not the group has beenresolved against the server.
 */
ContactGroupIcqImpl(MutableGroup joustSimGroup,List<Buddy> groupMembers,ServerStoredContactListIcqImpl ssclCallback,boolean isResolved){
  this.joustSimSourceGroup=joustSimGroup;
  this.isResolved=isResolved;
  this.ssclCallback=ssclCallback;
  initNameCopy();
  Iterator<Buddy> buddies=groupMembers.iterator();
  while (buddies.hasNext()) {
    Buddy buddy=buddies.next();
    if (ssclCallback.findContactByJoustSimBuddy(buddy) != null) {
      continue;
    }
    addContact(new ContactIcqImpl(buddy,ssclCallback,true,true));
  }
}",0.9996689837802052
103984,"/** 
 * Returns the icq contact encapsulating with the spcieified screen name or null if no such contact was found.
 * @param screenName the screenName (or icq UIN) for the contact we'relooking for.
 * @return the <tt>ContactIcqImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactIcqImpl findContact(String screenName){
  if (screenName == null)   return null;
  String lcScreenName=screenName.toLowerCase();
  return (ContactIcqImpl)buddies.get(lcScreenName);
}","/** 
 * Returns the icq contact encapsulating with the specified screen name or null if no such contact was found.
 * @param screenName the screenName (or icq UIN) for the contact we'relooking for.
 * @return the <tt>ContactIcqImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactIcqImpl findContact(String screenName){
  if (screenName == null)   return null;
  String lcScreenName=screenName.toLowerCase();
  return (ContactIcqImpl)buddies.get(lcScreenName);
}",0.9950641658440276
103985,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any members it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}",0.9984825493171472
103986,"public boolean authorizationRequired(Screenname screenname,Group parentGroup){
  logger.trace(""String_Node_Str"" + screenname);
  logger.trace(""String_Node_Str"" + screenname);
  ContactIcqImpl srcContact=ssContactList.findContactByScreenName(screenname.getFormatted());
  if (srcContact == null) {
    ContactGroupIcqImpl parent=ssContactList.findContactGroup(parentGroup);
    srcContact=ssContactList.createUnresolvedContact((ContactGroupIcqImpl)parent,screenname);
    Buddy buddy=((ContactIcqImpl)srcContact).getJoustSimBuddy();
    if (buddy instanceof VolatileBuddy)     ((VolatileBuddy)buddy).setAwaitingAuthorization(true);
    ContactGroupIcqImpl theAwaitingAuthorizationGroup=ssContactList.findContactGroup(ServerStoredContactListIcqImpl.awaitingAuthorizationGroupName);
    if (theAwaitingAuthorizationGroup == null) {
      List emptyBuddies=new LinkedList();
      theAwaitingAuthorizationGroup=new ContactGroupIcqImpl(new VolatileGroup(ServerStoredContactListIcqImpl.awaitingAuthorizationGroupName),emptyBuddies,ssContactList,false);
      ((RootContactGroupIcqImpl)ssContactList.getRootGroup()).addSubGroup(theAwaitingAuthorizationGroup);
      ssContactList.fireGroupEvent(theAwaitingAuthorizationGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    ((ContactGroupIcqImpl)parent).removeContact(srcContact);
    theAwaitingAuthorizationGroup.addContact(srcContact);
    Object lock=new Object();
synchronized (lock) {
      try {
        lock.wait(500);
      }
 catch (      Exception e) {
      }
    }
    fireSubscriptionMovedEvent(srcContact,parent,theAwaitingAuthorizationGroup);
  }
  AuthorizationRequest authRequest=authorizationHandler.createAuthorizationRequest(srcContact);
  if (authRequest == null)   return false;
  parentProvider.getAimConnection().getSsiService().sendFutureBuddyAuthorization(screenname,authRequest.getReason());
  parentProvider.getAimConnection().getSsiService().requestBuddyAuthorization(screenname,authRequest.getReason());
  return true;
}","public boolean authorizationRequired(Screenname screenname,Group parentGroup){
  logger.trace(""String_Node_Str"" + screenname);
  logger.trace(""String_Node_Str"" + screenname);
  ContactIcqImpl srcContact=ssContactList.findContactByScreenName(screenname.getFormatted());
  if (srcContact == null) {
    ContactGroupIcqImpl parent=ssContactList.findContactGroup(parentGroup);
    srcContact=ssContactList.createUnresolvedContact((ContactGroupIcqImpl)parent,screenname);
    Buddy buddy=((ContactIcqImpl)srcContact).getJoustSimBuddy();
    if (buddy instanceof VolatileBuddy)     ((VolatileBuddy)buddy).setAwaitingAuthorization(true);
    ContactGroupIcqImpl theAwaitingAuthorizationGroup=ssContactList.findContactGroup(ServerStoredContactListIcqImpl.awaitingAuthorizationGroupName);
    if (theAwaitingAuthorizationGroup == null) {
      List emptyBuddies=new LinkedList();
      theAwaitingAuthorizationGroup=new ContactGroupIcqImpl(new VolatileGroup(ServerStoredContactListIcqImpl.awaitingAuthorizationGroupName),emptyBuddies,ssContactList,false);
      ((RootContactGroupIcqImpl)ssContactList.getRootGroup()).addSubGroup(theAwaitingAuthorizationGroup);
      ssContactList.fireGroupEvent(theAwaitingAuthorizationGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
    }
    ((ContactGroupIcqImpl)parent).removeContact(srcContact);
    theAwaitingAuthorizationGroup.addContact(srcContact);
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException ex) {
    }
    fireSubscriptionMovedEvent(srcContact,parent,theAwaitingAuthorizationGroup);
  }
  AuthorizationRequest authRequest=authorizationHandler.createAuthorizationRequest(srcContact);
  if (authRequest == null)   return false;
  parentProvider.getAimConnection().getSsiService().sendFutureBuddyAuthorization(screenname,authRequest.getReason());
  parentProvider.getAimConnection().getSsiService().requestBuddyAuthorization(screenname,authRequest.getReason());
  return true;
}",0.9733975171015962
103987,"/** 
 * Fills the Account ID, Identity File and Known Hosts File fields in this panel with the data comming from the given protocolProvider.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> to load thedata from.
 */
public void loadAccount(ProtocolProviderService protocolProvider){
  ProtocolProviderFactorySSH protocolProviderSSH=(ProtocolProviderFactorySSH)protocolProvider;
  AccountID accountID=protocolProvider.getAccountID();
  String identityFile=accountID.getAccountPropertyString(ProtocolProviderFactorySSH.IDENTITY_FILE);
  String knownHostsFile=accountID.getAccountPropertyString(ProtocolProviderFactorySSH.KNOWN_HOSTS_FILE);
  this.userIDField.setText(accountID.getUserID());
  this.identityFileField.setText(identityFile);
  this.knownHostsFileField.setText(knownHostsFile);
}","/** 
 * Fills the Account ID, Identity File and Known Hosts File fields in this panel with the data coming from the given protocolProvider.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> to load thedata from.
 */
public void loadAccount(ProtocolProviderService protocolProvider){
  if (!(protocolProvider instanceof ProtocolProviderServiceSSHImpl))   throw new ClassCastException(""String_Node_Str"");
  AccountID accountID=protocolProvider.getAccountID();
  String identityFile=accountID.getAccountPropertyString(ProtocolProviderFactorySSH.IDENTITY_FILE);
  String knownHostsFile=accountID.getAccountPropertyString(ProtocolProviderFactorySSH.KNOWN_HOSTS_FILE);
  this.userIDField.setText(accountID.getUserID());
  this.identityFileField.setText(identityFile);
  this.knownHostsFileField.setText(knownHostsFile);
}",0.8763769889840881
103988,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)value;
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  this.setText(wizard.getProtocolName());
  byte[] icon=wizard.getIcon();
  if (icon != null && icon.length > 0) {
    this.setIcon(new ImageIcon(ImageLoader.getBytesInImage(icon)));
  }
 else {
    this.setIcon(null);
  }
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)value;
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  this.setText(wizard.getProtocolName());
  byte[] icon=wizard.getIcon();
  if (icon != null && icon.length > 0) {
    this.setIcon(new ImageIcon(icon));
  }
 else {
    this.setIcon(null);
  }
  return this;
}",0.8997632202052092
103989,"/** 
 * Clears all mouse over effects for the given smiley item. This method should be invoked when the mouse has exited the smiley area or when a smiley has been selected and the popup menu is closed.
 * @param smileyItem the item for which we clear mouse over effects.
 */
private void clearMouseOverEffects(JMenuItem smileyItem,Smiley smiley){
  ImageIcon imageIcon=new ImageIcon(ImageLoader.getImage(smiley.getImageID()));
  smileyItem.setIcon(imageIcon);
  smileyItem.setText(null);
  smileyTextLabel.setText(""String_Node_Str"");
  smileyDescriptionLabel.setText(""String_Node_Str"");
}","/** 
 * Clears all mouse over effects for the given smiley item. This method should be invoked when the mouse has exited the smiley area or when a smiley has been selected and the popup menu is closed.
 * @param smileyItem the item for which we clear mouse over effects.
 */
private void clearMouseOverEffects(JMenuItem smileyItem,Smiley smiley){
  ImageIcon imageIcon=new ImageIcon(ImageLoader.getImage(smiley.getImageID()));
  smileyItem.setIcon(imageIcon);
  smileyTextLabel.setText(""String_Node_Str"");
  smileyDescriptionLabel.setText(""String_Node_Str"");
}",0.975609756097561
103990,"/** 
 * Changes the static image of the underlying smiley with a dynamic one. Also shows the description and smiley string in the description area.
 */
public void mouseEntered(MouseEvent e){
  JMenuItem smileyItem=(JMenuItem)e.getSource();
  Smiley smiley=smileysList.get(smileyItem);
  String smileyIconHtml=""String_Node_Str"" + ImageLoader.getSmiley(smiley.getDefaultString()).getImagePath() + ""String_Node_Str"";
  smileyItem.setIcon(null);
  smileyItem.setText(smileyIconHtml);
  smileyDescriptionLabel.setText(smiley.getDescription());
  smileyTextLabel.setText(smiley.getSmileyStrings()[0]);
}","/** 
 * Changes the static image of the underlying smiley with a dynamic one. Also shows the description and smiley string in the description area.
 */
public void mouseEntered(MouseEvent e){
  JMenuItem smileyItem=(JMenuItem)e.getSource();
  Smiley smiley=smileysList.get(smileyItem);
  ImageIcon imageIcon=GuiActivator.getResources().getImage(smiley.getImageID().getId());
  smileyItem.setIcon(imageIcon);
  smileyDescriptionLabel.setText(smiley.getDescription());
  smileyTextLabel.setText(smiley.getSmileyStrings()[0]);
}",0.7711487088156723
103991,"/** 
 * Loads the given <tt>ConfigurationForm</tt>.
 * @param configForm the <tt>ConfigurationForm</tt> to load
 */
public ConfigFormDescriptor(ConfigurationForm configForm){
  this.configForm=configForm;
  byte[] icon=null;
  try {
    icon=configForm.getIcon();
    configFormTitle=configForm.getTitle();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  if (icon != null)   configFormIcon=new ImageIcon(ImageLoader.getBytesInImage(icon));
}","/** 
 * Loads the given <tt>ConfigurationForm</tt>.
 * @param configForm the <tt>ConfigurationForm</tt> to load
 */
public ConfigFormDescriptor(ConfigurationForm configForm){
  this.configForm=configForm;
  byte[] icon=null;
  try {
    icon=configForm.getIcon();
    configFormTitle=configForm.getTitle();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  if (icon != null)   configFormIcon=new ImageIcon(icon);
}",0.9591160220994476
103992,"/** 
 * Creates a customized tooltip for this contact list.
 * @return The customized tooltip.
 */
public JToolTip createToolTip(){
  Point currentMouseLocation=MouseInfo.getPointerInfo().getLocation();
  SwingUtilities.convertPointFromScreen(currentMouseLocation,this);
  int index=this.locationToIndex(currentMouseLocation);
  Object element=getModel().getElementAt(index);
  ExtendedTooltip tip=new ExtendedTooltip();
  if (element instanceof MetaContact) {
    MetaContact metaContact=(MetaContact)element;
    byte[] avatarImage=metaContact.getAvatar();
    if (avatarImage != null && avatarImage.length > 0)     tip.setImage(new ImageIcon(avatarImage));
    tip.setTitle(metaContact.getDisplayName());
    Iterator<Contact> i=metaContact.getContacts();
    while (i.hasNext()) {
      Contact protocolContact=i.next();
      Image protocolStatusIcon=ImageLoader.getBytesInImage(protocolContact.getPresenceStatus().getStatusIcon());
      String contactAddress=protocolContact.getAddress();
      tip.addLine(new ImageIcon(protocolStatusIcon),contactAddress);
    }
  }
 else   if (element instanceof MetaContactGroup) {
    MetaContactGroup metaGroup=(MetaContactGroup)element;
    tip.setTitle(metaGroup.getGroupName());
  }
 else   if (element instanceof ChatContact) {
    ChatContact chatContact=(ChatContact)element;
    ImageIcon avatarImage=chatContact.getAvatar();
    if (avatarImage != null)     tip.setImage(avatarImage);
    tip.setTitle(chatContact.getName());
  }
  tip.setComponent(this);
  return tip;
}","/** 
 * Creates a customized tooltip for this contact list.
 * @return The customized tooltip.
 */
public JToolTip createToolTip(){
  Point currentMouseLocation=MouseInfo.getPointerInfo().getLocation();
  SwingUtilities.convertPointFromScreen(currentMouseLocation,this);
  int index=this.locationToIndex(currentMouseLocation);
  Object element=getModel().getElementAt(index);
  ExtendedTooltip tip=new ExtendedTooltip();
  if (element instanceof MetaContact) {
    MetaContact metaContact=(MetaContact)element;
    byte[] avatarImage=metaContact.getAvatar();
    if (avatarImage != null && avatarImage.length > 0)     tip.setImage(new ImageIcon(avatarImage));
    tip.setTitle(metaContact.getDisplayName());
    Iterator<Contact> i=metaContact.getContacts();
    while (i.hasNext()) {
      Contact protocolContact=i.next();
      ImageIcon protocolStatusIcon=new ImageIcon(protocolContact.getPresenceStatus().getStatusIcon());
      String contactAddress=protocolContact.getAddress();
      tip.addLine(protocolStatusIcon,contactAddress);
    }
  }
 else   if (element instanceof MetaContactGroup) {
    MetaContactGroup metaGroup=(MetaContactGroup)element;
    tip.setTitle(metaGroup.getGroupName());
  }
 else   if (element instanceof ChatContact) {
    ChatContact chatContact=(ChatContact)element;
    ImageIcon avatarImage=chatContact.getAvatar();
    if (avatarImage != null)     tip.setImage(avatarImage);
    tip.setTitle(chatContact.getName());
  }
  tip.setComponent(this);
  return tip;
}",0.8866115702479339
103993,"/** 
 * Creates an instance of <tt>StatusSelectorBox</tt> and initializes the selector box with data.
 * @param mainFrame The main application window.
 * @param protocolProvider The protocol provider.
 * @param accountIndex If we have more than one account for a protocol, eachaccount has an index.
 */
public PresenceStatusMenu(MainFrame mainFrame,ProtocolProviderService protocolProvider){
  super(protocolProvider.getAccountID().getDisplayName(),new ImageIcon(ImageLoader.getAccountStatusImage(protocolProvider)));
  this.protocolProvider=protocolProvider;
  this.mainFrame=mainFrame;
  this.presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
  this.statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getDisplayName() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleLabel=new JLabel(protocolProvider.getAccountID().getDisplayName());
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=statusIterator.next();
    int connectivity=status.getStatus();
    if (connectivity < 1) {
      this.offlineStatus=status;
    }
 else     if ((onlineStatus != null && (onlineStatus.getStatus() < connectivity)) || (onlineStatus == null && (connectivity > 50 && connectivity < 80))) {
      this.onlineStatus=status;
    }
    this.addItem(status.getStatusName(),new ImageIcon(ImageLoader.getBytesInImage(status.getStatusIcon())),new ItemActionListener());
  }
  this.addSeparator();
  this.add(new StatusMessageMenu(protocolProvider));
  this.setSelectedStatus(offlineStatus);
}","/** 
 * Creates an instance of <tt>StatusSelectorBox</tt> and initializes the selector box with data.
 * @param mainFrame The main application window.
 * @param protocolProvider The protocol provider.
 * @param accountIndex If we have more than one account for a protocol, eachaccount has an index.
 */
public PresenceStatusMenu(MainFrame mainFrame,ProtocolProviderService protocolProvider){
  super(protocolProvider.getAccountID().getDisplayName(),new ImageIcon(ImageLoader.getAccountStatusImage(protocolProvider)));
  this.protocolProvider=protocolProvider;
  this.mainFrame=mainFrame;
  this.presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
  this.statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getDisplayName() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleLabel=new JLabel(protocolProvider.getAccountID().getDisplayName());
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=statusIterator.next();
    int connectivity=status.getStatus();
    if (connectivity < 1) {
      this.offlineStatus=status;
    }
 else     if ((onlineStatus != null && (onlineStatus.getStatus() < connectivity)) || (onlineStatus == null && (connectivity > 50 && connectivity < 80))) {
      this.onlineStatus=status;
    }
    this.addItem(status.getStatusName(),new ImageIcon(status.getStatusIcon()),new ItemActionListener());
  }
  this.addSeparator();
  this.add(new StatusMessageMenu(protocolProvider));
  this.setSelectedStatus(offlineStatus);
}",0.9805139791019486
103994,"/** 
 * Sets the Password associated with this contact
 * @param password
 */
public void setPassword(String password){
  this.sshConfigurationForm.setPasswordField(password);
  savePersistentDetails();
}","/** 
 * Sets the Password associated with this contact
 * @param password
 */
public void setPassword(String password){
  this.sshConfigurationForm.setPasswordField(password);
  System.out.println(""String_Node_Str"");
  savePersistentDetails();
}",0.9086859688195992
103995,"/** 
 * Saves the details of contact in persistentData seperated by ""service.gui.JANUARY"" Passowrd is saved unsecurely using Base64 encoding
 */
public void savePersistentDetails(){
  persistentData=this.sshConfigurationForm.getHostName() + ""String_Node_Str"" + this.sshConfigurationForm.getUserName()+ ""String_Node_Str""+ new String(Base64.encode(this.sshConfigurationForm.getPassword().getBytes()))+ ""String_Node_Str""+ sshConfigurationForm.getPort()+ ""String_Node_Str""+ sshConfigurationForm.getTerminalType()+ ""String_Node_Str""+ sshConfigurationForm.getUpdateInterval();
}","/** 
 * Saves the details of contact in persistentData seperated by separator Passowrd is saved unsecurely using Base64 encoding
 */
public void savePersistentDetails(){
  persistentData=this.sshConfigurationForm.getHostName() + separator + this.sshConfigurationForm.getUserName()+ separator+ new String(Base64.encode(this.sshConfigurationForm.getPassword().getBytes()))+ separator+ sshConfigurationForm.getPort()+ separator+ sshConfigurationForm.getTerminalType()+ separator+ sshConfigurationForm.getUpdateInterval();
}",0.7747252747252747
103996,"/** 
 * Stores persistent data in fields of the contact seperated by ""service.gui.JANUARY"".
 * @param persistentData of the contact
 */
public void setPersistentData(String persistentData){
  this.persistentData=persistentData;
  int firstCommaIndex=this.persistentData.indexOf(""String_Node_Str"");
  int secondCommaIndex=this.persistentData.indexOf(""String_Node_Str"",firstCommaIndex + 1);
  int thirdCommaIndex=this.persistentData.indexOf(""String_Node_Str"",secondCommaIndex + 1);
  int fourthCommaIndex=this.persistentData.indexOf(""String_Node_Str"",thirdCommaIndex + 1);
  int fifthCommaIndex=this.persistentData.indexOf(""String_Node_Str"",fourthCommaIndex + 1);
  logger.debug(""String_Node_Str"" + firstCommaIndex + ""String_Node_Str""+ secondCommaIndex+ ""String_Node_Str""+ thirdCommaIndex+ ""String_Node_Str""+ fourthCommaIndex+ ""String_Node_Str""+ fifthCommaIndex);
  this.sshConfigurationForm.setHostNameField(this.persistentData.substring(0,firstCommaIndex));
  this.sshConfigurationForm.setUserNameField(this.persistentData.substring(firstCommaIndex + 1,secondCommaIndex));
  if ((thirdCommaIndex - secondCommaIndex) > 1) {
    if (this.persistentData.substring(secondCommaIndex + 1).length() > 0)     this.sshConfigurationForm.setPasswordField(new String(Base64.decode(this.persistentData.substring(secondCommaIndex + 1,thirdCommaIndex))));
  }
  this.sshConfigurationForm.setPort(this.persistentData.substring(thirdCommaIndex + 1,fourthCommaIndex));
  this.sshConfigurationForm.setTerminalType(this.persistentData.substring(fourthCommaIndex + 1,fifthCommaIndex));
  this.sshConfigurationForm.setUpdateInterval(Integer.parseInt(this.persistentData.substring(fifthCommaIndex + 1)));
}","/** 
 * Stores persistent data in fields of the contact seperated by separator.
 * @param persistentData of the contact
 */
public void setPersistentData(String persistentData){
  try {
    this.persistentData=persistentData;
    int firstCommaIndex=this.persistentData.indexOf(separator);
    int secondCommaIndex=this.persistentData.indexOf(separator,firstCommaIndex + 1);
    int thirdCommaIndex=this.persistentData.indexOf(separator,secondCommaIndex + 1);
    int fourthCommaIndex=this.persistentData.indexOf(separator,thirdCommaIndex + 1);
    int fifthCommaIndex=this.persistentData.indexOf(separator,fourthCommaIndex + 1);
    logger.debug(""String_Node_Str"" + firstCommaIndex + ""String_Node_Str""+ secondCommaIndex+ ""String_Node_Str""+ thirdCommaIndex+ ""String_Node_Str""+ fourthCommaIndex+ ""String_Node_Str""+ fifthCommaIndex);
    this.sshConfigurationForm.setHostNameField(this.persistentData.substring(0,firstCommaIndex));
    this.sshConfigurationForm.setUserNameField(this.persistentData.substring(firstCommaIndex + 1,secondCommaIndex));
    if ((thirdCommaIndex - secondCommaIndex) > 1) {
      if (this.persistentData.substring(secondCommaIndex + 1).length() > 0)       this.sshConfigurationForm.setPasswordField(new String(Base64.decode(this.persistentData.substring(secondCommaIndex + 1,thirdCommaIndex))));
    }
    this.sshConfigurationForm.setPort(this.persistentData.substring(thirdCommaIndex + 1,fourthCommaIndex));
    this.sshConfigurationForm.setTerminalType(this.persistentData.substring(fourthCommaIndex + 1,fifthCommaIndex));
    this.sshConfigurationForm.setUpdateInterval(Integer.parseInt(this.persistentData.substring(fifthCommaIndex + 1)));
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.6814469078179697
103997,"/** 
 * initialize the form.
 */
public void initForm(){
  updateTimer.setValue(30);
  MaskFormatter maskFormatter=new MaskFormatter();
  try {
    maskFormatter.setMask(""String_Node_Str"");
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
  }
  maskFormatter.setAllowsInvalid(false);
  portField=new JFormattedTextField(maskFormatter);
  portField.setValue(22);
  userNameField.setEnabled(false);
  passwordField.setEditable(false);
  portField.setEnabled(false);
  terminalTypeField.setEnabled(false);
  updateTimer.setEnabled(false);
  mainPanel.setLayout(new BoxLayout(mainPanel,BoxLayout.Y_AXIS));
  machinePanel.setLayout(new BoxLayout(machinePanel,BoxLayout.X_AXIS));
  detailNamesPanel.setLayout(new BoxLayout(detailNamesPanel,BoxLayout.Y_AXIS));
  detailFieldsPanel.setLayout(new BoxLayout(detailFieldsPanel,BoxLayout.Y_AXIS));
  detailsPanel.setLayout(new BoxLayout(detailsPanel,BoxLayout.X_AXIS));
  machinePanel.add(machineID);
  machinePanel.add(machineIDField);
  detailNamesPanel.add(userName);
  detailNamesPanel.add(emptyPanel1);
  detailNamesPanel.add(password);
  detailNamesPanel.add(emptyPanel2);
  detailNamesPanel.add(port);
  detailNamesPanel.add(emptyPanel3);
  detailNamesPanel.add(statusUpdate);
  detailNamesPanel.add(emptyPanel4);
  detailNamesPanel.add(terminalType);
  detailFieldsPanel.add(userNameField);
  detailFieldsPanel.add(emptyPanel5);
  detailFieldsPanel.add(passwordField);
  detailFieldsPanel.add(emptyPanel6);
  detailFieldsPanel.add(portField);
  detailFieldsPanel.add(emptyPanel7);
  detailFieldsPanel.add(updateTimer);
  detailFieldsPanel.add(emptyPanel8);
  detailFieldsPanel.add(terminalTypeField);
  detailsPanel.add(detailNamesPanel);
  detailsPanel.add(detailFieldsPanel);
  detailsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  mainPanel.add(emptyPanel9);
  mainPanel.add(machinePanel);
  mainPanel.add(addDetailsCheckBox);
  mainPanel.add(detailsPanel);
  mainPanel.add(emptyPanel10);
  mainPanel.add(doneButton);
  mainPanel.add(emptyPanel11);
  addDetailsCheckBox.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      addDetailsCheckBox.setEnabled(false);
      userNameField.setEnabled(true);
      passwordField.setEditable(true);
      portField.setEnabled(true);
      terminalTypeField.setEnabled(true);
      updateTimer.setEnabled(true);
      userNameField.grabFocus();
    }
  }
);
  doneButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      if (machineIDField.getText().equals(""String_Node_Str"")) {
        machineIDField.setText(""String_Node_Str"");
        return;
      }
      sshContact.savePersistentDetails();
      setVisible(false);
    }
  }
);
}","/** 
 * initialize the form.
 */
public void initForm(){
  updateTimer.setValue(30);
  MaskFormatter maskFormatter=new MaskFormatter();
  try {
    maskFormatter.setMask(""String_Node_Str"");
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
  }
  maskFormatter.setAllowsInvalid(false);
  portField=new JFormattedTextField(maskFormatter);
  portField.setValue(22);
  userNameField.setEnabled(false);
  passwordField.setEditable(false);
  portField.setEnabled(false);
  terminalTypeField.setEnabled(false);
  updateTimer.setEnabled(false);
  mainPanel.setLayout(new BoxLayout(mainPanel,BoxLayout.Y_AXIS));
  machinePanel.setLayout(new BoxLayout(machinePanel,BoxLayout.X_AXIS));
  detailNamesPanel.setLayout(new BoxLayout(detailNamesPanel,BoxLayout.Y_AXIS));
  detailFieldsPanel.setLayout(new BoxLayout(detailFieldsPanel,BoxLayout.Y_AXIS));
  detailsPanel.setLayout(new BoxLayout(detailsPanel,BoxLayout.X_AXIS));
  machinePanel.add(machineID);
  machinePanel.add(machineIDField);
  detailNamesPanel.add(userName);
  detailNamesPanel.add(emptyPanel1);
  detailNamesPanel.add(password);
  detailNamesPanel.add(emptyPanel2);
  detailNamesPanel.add(port);
  detailNamesPanel.add(emptyPanel3);
  detailNamesPanel.add(statusUpdate);
  detailNamesPanel.add(emptyPanel4);
  detailNamesPanel.add(terminalType);
  detailFieldsPanel.add(userNameField);
  detailFieldsPanel.add(emptyPanel5);
  detailFieldsPanel.add(passwordField);
  detailFieldsPanel.add(emptyPanel6);
  detailFieldsPanel.add(portField);
  detailFieldsPanel.add(emptyPanel7);
  detailFieldsPanel.add(updateTimer);
  detailFieldsPanel.add(emptyPanel8);
  detailFieldsPanel.add(terminalTypeField);
  detailsPanel.add(detailNamesPanel);
  detailsPanel.add(detailFieldsPanel);
  detailsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  mainPanel.add(emptyPanel9);
  mainPanel.add(machinePanel);
  mainPanel.add(addDetailsCheckBox);
  mainPanel.add(detailsPanel);
  mainPanel.add(emptyPanel10);
  mainPanel.add(doneButton);
  mainPanel.add(emptyPanel11);
  addDetailsCheckBox.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      addDetailsCheckBox.setEnabled(false);
      userNameField.setEnabled(true);
      passwordField.setEditable(true);
      portField.setEnabled(true);
      terminalTypeField.setEnabled(true);
      updateTimer.setEnabled(true);
      userNameField.grabFocus();
    }
  }
);
  doneButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      if (machineIDField.getText().equals(""String_Node_Str"")) {
        machineIDField.setText(""String_Node_Str"");
        return;
      }
      sshContact.savePersistentDetails();
      ((OperationSetPersistentPresenceSSHImpl)sshContact.getParentPresenceOperationSet()).addContactToList(sshContact.getParentContactGroup(),sshContact);
      setVisible(false);
    }
  }
);
}",0.9726872246696036
103998,"public void actionPerformed(ActionEvent event){
  if (machineIDField.getText().equals(""String_Node_Str"")) {
    machineIDField.setText(""String_Node_Str"");
    return;
  }
  sshContact.savePersistentDetails();
  setVisible(false);
}","public void actionPerformed(ActionEvent event){
  if (machineIDField.getText().equals(""String_Node_Str"")) {
    machineIDField.setText(""String_Node_Str"");
    return;
  }
  sshContact.savePersistentDetails();
  ((OperationSetPersistentPresenceSSHImpl)sshContact.getParentPresenceOperationSet()).addContactToList(sshContact.getParentContactGroup(),sshContact);
  setVisible(false);
}",0.7536704730831973
103999,"/** 
 * Sets the Password associated with this contact
 * @param password
 */
public void setPassword(String password){
  this.sshConfigurationForm.setPasswordField(password);
  System.out.println(""String_Node_Str"");
  savePersistentDetails();
}","/** 
 * Sets the Password associated with this contact
 * @param password
 */
public void setPassword(String password){
  this.sshConfigurationForm.setPasswordField(password);
  savePersistentDetails();
}",0.9086859688195992
104000,"/** 
 * Sets the showOffline property.
 * @param isShowOffline TRUE to show all offline users, FALSE to hideoffline users.
 */
public void setShowOffline(boolean isShowOffline){
  Object selectedObject=null;
  int currentlySelectedIndex=this.getSelectedIndex();
  if (currentlySelectedIndex != -1) {
    selectedObject=listModel.getElementAt(currentlySelectedIndex);
  }
  int listSize=listModel.getSize();
  listModel.setShowOffline(isShowOffline);
  ConfigurationManager.setShowOffline(isShowOffline);
  int newListSize=listModel.getSize();
  if (!isShowOffline && listSize > 0) {
    if (newListSize > 0) {
      listModel.contentChanged(0,newListSize - 1);
      listModel.contentRemoved(newListSize - 1,listSize - 1);
    }
 else     listModel.contentRemoved(0,listSize - 1);
  }
 else   if (isShowOffline && newListSize > 0) {
    if (listSize > 0) {
      listModel.contentChanged(0,listSize - 1);
      listModel.contentAdded(listSize - 1,newListSize - 1);
    }
 else     listModel.contentAdded(0,newListSize - 1);
  }
  if (selectedObject != null) {
    if (selectedObject instanceof MetaContact) {
      this.setSelectedIndex(listModel.indexOf(selectedObject));
    }
 else {
      this.setSelectedIndex(listModel.indexOf(selectedObject));
    }
  }
}","/** 
 * Sets the showOffline property.
 * @param isShowOffline TRUE to show all offline users, FALSE to hideoffline users.
 */
public void setShowOffline(boolean isShowOffline){
  Object selectedObject=null;
  int currentlySelectedIndex=this.getSelectedIndex();
  if (currentlySelectedIndex != -1) {
    selectedObject=listModel.getElementAt(currentlySelectedIndex);
  }
  int listSize=listModel.getSize();
  listModel.setShowOffline(isShowOffline);
  ConfigurationManager.setShowOffline(isShowOffline);
  int newListSize=listModel.getSize();
  if (!isShowOffline && listSize > 0) {
    if (newListSize > 0) {
      listModel.contentChanged(0,newListSize - 1);
      listModel.contentRemoved(newListSize - 1,listSize - 1);
    }
 else     listModel.contentRemoved(0,listSize - 1);
  }
 else   if (isShowOffline && newListSize > 0) {
    if (listSize > 0) {
      listModel.contentChanged(0,listSize - 1);
      listModel.contentAdded(listSize - 1,newListSize - 1);
    }
 else     listModel.contentAdded(0,newListSize - 1);
  }
  if (selectedObject != null) {
    this.setSelectedIndex(listModel.indexOf(selectedObject));
  }
}",0.9074926747593136
