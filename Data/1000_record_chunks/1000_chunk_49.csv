record_number,buggy_code,fixed_code,code_similarity
48001,"@Override public Set<QueryableEntry> getSubRecords(ComparisonType comparisonType,Comparable searchedValue){
  MultiResultSet results=new MultiResultSet();
  indexStore.getSubRecords(results,comparisonType,convert(searchedValue));
  return results;
}","@Override public Set<QueryableEntry> getSubRecords(ComparisonType comparisonType,Comparable searchedValue){
  MultiResultSet results=new MultiResultSet();
  if (attributeType != null) {
    indexStore.getSubRecords(results,comparisonType,convert(searchedValue));
  }
  return results;
}",0.930841121495327
48002,"@Override public void saveEntryIndex(QueryableEntry e) throws QueryException {
  Data key=e.getIndexKey();
  Comparable oldValue=recordValues.remove(key);
  Comparable newValue=e.getAttribute(attribute);
  if (newValue == null) {
    newValue=NULL;
  }
 else   if (newValue.getClass().isEnum()) {
    newValue=TypeConverters.ENUM_CONVERTER.convert(newValue);
  }
  recordValues.put(key,newValue);
  if (oldValue == null) {
    indexStore.newIndex(newValue,e);
  }
 else {
    indexStore.removeIndex(oldValue,key);
    indexStore.newIndex(newValue,e);
  }
  if (attributeType == null) {
    attributeType=e.getAttributeType(attribute);
  }
}","@Override public void saveEntryIndex(QueryableEntry e) throws QueryException {
  if (attributeType == null) {
    attributeType=e.getAttributeType(attribute);
  }
  Data key=e.getIndexKey();
  Comparable oldValue=recordValues.remove(key);
  Comparable newValue=e.getAttribute(attribute);
  if (newValue == null) {
    newValue=NULL;
  }
 else   if (newValue.getClass().isEnum()) {
    newValue=TypeConverters.ENUM_CONVERTER.convert(newValue);
  }
  recordValues.put(key,newValue);
  if (oldValue == null) {
    indexStore.newIndex(newValue,e);
  }
 else {
    indexStore.removeIndex(oldValue,key);
    indexStore.newIndex(newValue,e);
  }
}",0.86875
48003,"@Override public void clear(){
  recordValues.clear();
  indexStore.clear();
}","@Override public void clear(){
  recordValues.clear();
  indexStore.clear();
  attributeType=null;
}",0.8764044943820225
48004,"@Override public Set<QueryableEntry> getRecords(Comparable value){
  return indexStore.getRecords(convert(value));
}","@Override public Set<QueryableEntry> getRecords(Comparable value){
  if (attributeType != null) {
    return indexStore.getRecords(convert(value));
  }
 else {
    return new SingleResultSet(null);
  }
}",0.7272727272727273
48005,"@Override public Set<QueryableEntry> getSubRecordsBetween(Comparable from,Comparable to){
  MultiResultSet results=new MultiResultSet();
  indexStore.getSubRecordsBetween(results,convert(from),convert(to));
  return results;
}","@Override public Set<QueryableEntry> getSubRecordsBetween(Comparable from,Comparable to){
  MultiResultSet results=new MultiResultSet();
  if (attributeType != null) {
    indexStore.getSubRecordsBetween(results,convert(from),convert(to));
  }
  return results;
}",0.9243353783231084
48006,"public boolean containsEntry(K key,V value){
  Data keyData=toData(key);
  Data valueData=toData(value);
  ClientRequest request;
  if (keyData == null) {
    request=new ContainsRequest(name,valueData);
  }
 else {
    request=new KeyBasedContainsRequest(name,keyData,valueData);
  }
  Boolean result=invoke(request,keyData);
  return result;
}","public boolean containsEntry(K key,V value){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Data keyData=toData(key);
  Data valueData=toData(value);
  ClientRequest request=new KeyBasedContainsRequest(name,keyData,valueData);
  Boolean result=invoke(request,keyData);
  return result;
}",0.5514157973174366
48007,"@Override public Set<String> loadAllKeys(){
  sleepMillis(MS_LOAD_DELAY);
  return store.keySet();
}","@Override public Set<String> loadAllKeys(){
  if (sleepBeforeLoadAllKeys) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  countLoadAllKeys.incrementAndGet();
  Set<String> result=new HashSet<String>(store.keySet());
  List<String> resultList=new ArrayList<String>(result);
  Collections.sort(resultList);
  return result;
}",0.1975806451612903
48008,"@Override public String load(String key){
  sleepMillis(MS_PER_LOAD);
  saveInfoAboutCurrentLoaderThread();
  return store.get(key);
}","@Override public String load(String key){
  if (msPerLoad > 0) {
    try {
      Thread.sleep(msPerLoad);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  Thread thread=Thread.currentThread();
  ClassLoader contextClassLoader=thread.getContextClassLoader();
  contextClassLoaders.putIfAbsent(thread.getName(),contextClassLoader != null);
  return store.get(key);
}",0.2932330827067669
48009,"@Override public void deleteAll(Collection<String> keys){
  for (  String key : keys) {
    store.remove(key);
  }
}","@Override public void deleteAll(Collection<String> keys){
  List<String> keysList=new ArrayList<String>(keys);
  Collections.sort(keysList);
  for (  String key : keys) {
    store.remove(key);
  }
}",0.7365079365079366
48010,"@Override public Map<String,String> loadAll(Collection<String> keys){
  saveInfoAboutCurrentLoaderThread();
  Map<String,String> result=new HashMap<String,String>();
  for (  String key : keys) {
    sleepMillis(MS_PER_LOAD);
    String value=store.get(key);
    if (value != null) {
      result.put(key,value);
    }
  }
  return result;
}","@Override public Map<String,String> loadAll(Collection<String> keys){
  List<String> keysList=new ArrayList<String>(keys);
  Collections.sort(keysList);
  Thread thread=Thread.currentThread();
  ClassLoader contextClassLoader=thread.getContextClassLoader();
  contextClassLoaders.putIfAbsent(thread.getName(),contextClassLoader != null);
  Map<String,String> result=new HashMap<String,String>();
  for (  String key : keys) {
    if (msPerLoad > 0) {
      try {
        Thread.sleep(msPerLoad);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    String value=store.get(key);
    if (value != null) {
      result.put(key,value);
    }
  }
  return result;
}",0.2818791946308724
48011,"@Override public Set<QueryableEntry> getSubRecords(ComparisonType comparisonType,Comparable searchedValue){
  MultiResultSet results=new MultiResultSet();
  indexStore.getSubRecords(results,comparisonType,convert(searchedValue));
  return results;
}","@Override public Set<QueryableEntry> getSubRecords(ComparisonType comparisonType,Comparable searchedValue){
  MultiResultSet results=new MultiResultSet();
  if (attributeType != null) {
    indexStore.getSubRecords(results,comparisonType,convert(searchedValue));
  }
  return results;
}",0.930841121495327
48012,"@Override public void saveEntryIndex(QueryableEntry e) throws QueryException {
  Data key=e.getIndexKey();
  Comparable oldValue=recordValues.remove(key);
  Comparable newValue=e.getAttribute(attribute);
  if (newValue == null) {
    newValue=NULL;
  }
 else   if (newValue.getClass().isEnum()) {
    newValue=TypeConverters.ENUM_CONVERTER.convert(newValue);
  }
  recordValues.put(key,newValue);
  if (oldValue == null) {
    indexStore.newIndex(newValue,e);
  }
 else {
    indexStore.removeIndex(oldValue,key);
    indexStore.newIndex(newValue,e);
  }
  if (attributeType == null) {
    attributeType=e.getAttributeType(attribute);
  }
}","@Override public void saveEntryIndex(QueryableEntry e) throws QueryException {
  if (attributeType == null) {
    attributeType=e.getAttributeType(attribute);
  }
  Data key=e.getIndexKey();
  Comparable oldValue=recordValues.remove(key);
  Comparable newValue=e.getAttribute(attribute);
  if (newValue == null) {
    newValue=NULL;
  }
 else   if (newValue.getClass().isEnum()) {
    newValue=TypeConverters.ENUM_CONVERTER.convert(newValue);
  }
  recordValues.put(key,newValue);
  if (oldValue == null) {
    indexStore.newIndex(newValue,e);
  }
 else {
    indexStore.removeIndex(oldValue,key);
    indexStore.newIndex(newValue,e);
  }
}",0.86875
48013,"@Override public void clear(){
  recordValues.clear();
  indexStore.clear();
}","@Override public void clear(){
  recordValues.clear();
  indexStore.clear();
  attributeType=null;
}",0.8764044943820225
48014,"@Override public Set<QueryableEntry> getRecords(Comparable value){
  return indexStore.getRecords(convert(value));
}","@Override public Set<QueryableEntry> getRecords(Comparable value){
  if (attributeType != null) {
    return indexStore.getRecords(convert(value));
  }
 else {
    return new SingleResultSet(null);
  }
}",0.7272727272727273
48015,"@Override public Set<QueryableEntry> getSubRecordsBetween(Comparable from,Comparable to){
  MultiResultSet results=new MultiResultSet();
  indexStore.getSubRecordsBetween(results,convert(from),convert(to));
  return results;
}","@Override public Set<QueryableEntry> getSubRecordsBetween(Comparable from,Comparable to){
  MultiResultSet results=new MultiResultSet();
  if (attributeType != null) {
    indexStore.getSubRecordsBetween(results,convert(from),convert(to));
  }
  return results;
}",0.9243353783231084
48016,"protected MapEventPublishingService(MapServiceContext mapServiceContext){
  this.mapServiceContext=mapServiceContext;
  this.nodeEngine=mapServiceContext.getNodeEngine();
  this.logger=nodeEngine.getLogger(getClass());
}","protected MapEventPublishingService(MapServiceContext mapServiceContext){
  this.mapServiceContext=mapServiceContext;
  this.nodeEngine=mapServiceContext.getNodeEngine();
}",0.8775510204081632
48017,"public boolean containsValue(Object value){
  Data valueData=toData(value);
  ContainsRequest request=new ContainsRequest(name,null,valueData);
  Boolean result=invoke(request);
  return result;
}","public boolean containsValue(Object value){
  Data valueData=toData(value);
  ClientRequest request=new ContainsRequest(name,valueData);
  Boolean result=invoke(request);
  return result;
}",0.9662337662337662
48018,"public boolean containsEntry(K key,V value){
  Data keyData=toData(key);
  Data valueData=toData(value);
  ContainsRequest request=new ContainsRequest(name,keyData,valueData);
  Boolean result=invoke(request,keyData);
  return result;
}","public boolean containsEntry(K key,V value){
  Data keyData=toData(key);
  Data valueData=toData(value);
  ClientRequest request;
  if (keyData == null) {
    request=new ContainsRequest(name,valueData);
  }
 else {
    request=new KeyBasedContainsRequest(name,keyData,valueData);
  }
  Boolean result=invoke(request,keyData);
  return result;
}",0.5197934595524957
48019,"public boolean containsKey(K key){
  Data keyData=toData(key);
  ContainsRequest request=new ContainsRequest(name,keyData,null);
  Boolean result=invoke(request,keyData);
  return result;
}","public boolean containsKey(K key){
  Data keyData=toData(key);
  ClientRequest request=new KeyBasedContainsRequest(name,keyData,null);
  Boolean result=invoke(request,keyData);
  return result;
}",0.9583333333333334
48020,"public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable>[] constructors=new ConstructorFunction[TXN_MM_REMOVEALL + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  constructors[REMOVE_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveEntryListenerRequest();
    }
  }
;
  constructors[TXN_MM_REMOVEALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveAllRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}","public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable>[] constructors=new ConstructorFunction[KEY_BASED_CONTAINS + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  constructors[REMOVE_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveEntryListenerRequest();
    }
  }
;
  constructors[TXN_MM_REMOVEALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveAllRequest();
    }
  }
;
  constructors[KEY_BASED_CONTAINS]=new ConstructorFunction<Integer,Portable>(){
    @Override public Portable createNew(    Integer arg){
      return new KeyBasedContainsRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}",0.9702198061923896
48021,"public Portable createNew(Integer arg){
  return new TxnMultiMapRemoveAllRequest();
}","@Override public Portable createNew(Integer arg){
  return new KeyBasedContainsRequest();
}",0.7727272727272727
48022,"public ContainsRequest(String name,Data key,Data value){
  super(name);
  this.key=key;
  this.value=value;
}","public ContainsRequest(String name,Data value){
  super(name);
  this.value=value;
}",0.8704663212435233
48023,"public void read(PortableReader reader) throws IOException {
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  key=IOUtil.readNullableData(in);
  value=IOUtil.readNullableData(in);
}","public void read(PortableReader reader) throws IOException {
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  value=IOUtil.readNullableData(in);
}",0.908616187989556
48024,"@Override public String getMethodName(){
  if (key != null && value != null) {
    return ""String_Node_Str"";
  }
 else   if (key != null) {
    return ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","@Override public String getMethodName(){
  return ""String_Node_Str"";
}",0.5128205128205128
48025,"protected OperationFactory createOperationFactory(){
  return new MultiMapOperationFactory(name,MultiMapOperationFactory.OperationFactoryType.CONTAINS,key,value);
}","protected OperationFactory createOperationFactory(){
  return new MultiMapOperationFactory(name,MultiMapOperationFactory.OperationFactoryType.CONTAINS,null,value);
}",0.9787234042553192
48026,"@Override public Object[] getParameters(){
  if (key != null && value != null) {
    return new Object[]{key,value};
  }
 else   if (key != null) {
    return new Object[]{key};
  }
  return new Object[]{value};
}","@Override public Object[] getParameters(){
  return new Object[]{value};
}",0.5156794425087108
48027,"public void write(PortableWriter writer) throws IOException {
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  IOUtil.writeNullableData(out,key);
  IOUtil.writeNullableData(out,value);
}","public void write(PortableWriter writer) throws IOException {
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  IOUtil.writeNullableData(out,value);
}",0.9072681704260652
48028,"@Test public void testContainsEntry() throws IOException {
  MultiMap mm=getMultiMap();
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  final SimpleClient client=getClient();
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str""),ss.toData(""String_Node_Str"")));
  boolean result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str""),ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertFalse(result);
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str""),null));
  result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str""),null));
  result=(Boolean)client.receive();
  assertFalse(result);
  client.send(new ContainsRequest(name,null,ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new ContainsRequest(name,null,ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertFalse(result);
}","@Test public void testContainsEntry() throws IOException {
  MultiMap mm=getMultiMap();
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  final SimpleClient client=getClient();
  client.send(new KeyBasedContainsRequest(name,ss.toData(""String_Node_Str""),ss.toData(""String_Node_Str"")));
  boolean result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new KeyBasedContainsRequest(name,ss.toData(""String_Node_Str""),ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertFalse(result);
  client.send(new KeyBasedContainsRequest(name,ss.toData(""String_Node_Str""),null));
  result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new KeyBasedContainsRequest(name,ss.toData(""String_Node_Str""),null));
  result=(Boolean)client.receive();
  assertFalse(result);
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertTrue(result);
  client.send(new ContainsRequest(name,ss.toData(""String_Node_Str"")));
  result=(Boolean)client.receive();
  assertFalse(result);
}",0.9816593886462882
48029,"@Override public void setMinEvictionCheckMillis(long checkIfEvictableAfterMillis){
  throw new UnsupportedOperationException(""String_Node_Str"" + getName());
}","@Override public MapConfig setMinEvictionCheckMillis(long checkIfEvictableAfterMillis){
  throw new UnsupportedOperationException(""String_Node_Str"" + getName());
}",0.97196261682243
48030,"@Test public void testIssue1085WriteBehindBackup() throws InterruptedException {
  Config config=new Config();
  String name=""String_Node_Str"";
  MapConfig writeBehindBackup=config.getMapConfig(name);
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setWriteDelaySeconds(5);
  int size=1000;
  MapStoreWithStoreCount mapStore=new MapStoreWithStoreCount(size,120);
  mapStoreConfig.setImplementation(mapStore);
  writeBehindBackup.setMapStoreConfig(mapStoreConfig);
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  HazelcastInstance instance=factory.newHazelcastInstance(config);
  HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final IMap map=instance.getMap(name);
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  instance2.getLifecycleService().terminate();
  mapStore.awaitStores();
}","@Test public void testIssue1085WriteBehindBackup() throws InterruptedException {
  Config config=new Config();
  String name=""String_Node_Str"";
  MapConfig writeBehindBackup=config.getMapConfig(name);
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setWriteDelaySeconds(5);
  int size=1000;
  MapStoreWithStoreCount mapStore=new MapStoreWithStoreCount(size,120);
  mapStoreConfig.setImplementation(mapStore);
  writeBehindBackup.setMapStoreConfig(mapStoreConfig);
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  HazelcastInstance instance=factory.newHazelcastInstance(config);
  HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final IMap map=instance.getMap(name);
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  instance2.getLifecycleService().shutdown();
  mapStore.awaitStores();
}",0.9901677270098322
48031,"/** 
 * @param connectionTimeout Timeout value in millis for nodes to accept client connection client.
 * @return configured {@link com.hazelcast.client.config.ClientNetworkConfig} for chaining
 */
public ClientNetworkConfig setConnectionTimeout(int connectionTimeout){
  this.connectionTimeout=connectionTimeout;
  return this;
}","/** 
 * @param connectionTimeout Timeout value in millis for nodes to accept client connection requests.
 * @return configured {@link com.hazelcast.client.config.ClientNetworkConfig} for chaining
 */
public ClientNetworkConfig setConnectionTimeout(int connectionTimeout){
  this.connectionTimeout=connectionTimeout;
  return this;
}",0.9788519637462236
48032,"/** 
 * Timeout value in millis for nodes to accept client connection client.
 * @return connection timeout value in millis
 */
public int getConnectionTimeout(){
  return connectionTimeout;
}","/** 
 * Timeout value in millis for nodes to accept client connection requests.
 * @return connection timeout value in millis
 */
public int getConnectionTimeout(){
  return connectionTimeout;
}",0.9740932642487048
48033,"/** 
 * Version for internal client. This version can be configured per class by overriding this method. <p/> <p> This should be updated/incremented when serialization of a request changes. </p>
 */
@Override public int getClassVersion(){
  return 1;
}","/** 
 * Version for internal requests. This version can be configured per class by overriding this method. <p/> <p> This should be updated/incremented when serialization of a request changes. </p>
 */
@Override public int getClassVersion(){
  return 1;
}",0.9723320158102768
48034,"/** 
 * Used for   {@link com.hazelcast.security.SecurityInterceptor}Method name which called via a distributedObject for map.put, methodName will be 'put' For client which do not produced via a distributedObject should return null, for example internal client.
 * @return
 */
String getMethodName();","/** 
 * Used for   {@link com.hazelcast.security.SecurityInterceptor}Method name which called via a distributedObject for map.put, methodName will be 'put' For requests which do not produced via a distributedObject should return null, for example internal client.
 * @return
 */
String getMethodName();",0.9767441860465116
48035,"/** 
 * Sets the trusted interfaces. <p/> By default, so when the set of trusted interfaces is empty, a Hazelcast member will accept join-client from every member. With a trusted interface you can control the members you want to receive join request from. <p/> The interface is an ip address where the last octet can be a wildcard '*' or a range '10-20'.
 * @param interfaces the new trusted interfaces.
 * @return the updated MulticastConfig.
 * @see IllegalArgumentException if interfaces is null.
 */
public MulticastConfig setTrustedInterfaces(Set<String> interfaces){
  isNotNull(interfaces,""String_Node_Str"");
  trustedInterfaces.clear();
  trustedInterfaces.addAll(interfaces);
  return this;
}","/** 
 * Sets the trusted interfaces. <p/> By default, so when the set of trusted interfaces is empty, a Hazelcast member will accept join-requests from every member. With a trusted interface you can control the members you want to receive join request from. <p/> The interface is an ip address where the last octet can be a wildcard '*' or a range '10-20'.
 * @param interfaces the new trusted interfaces.
 * @return the updated MulticastConfig.
 * @see IllegalArgumentException if interfaces is null.
 */
public MulticastConfig setTrustedInterfaces(Set<String> interfaces){
  isNotNull(interfaces,""String_Node_Str"");
  trustedInterfaces.clear();
  trustedInterfaces.addAll(interfaces);
  return this;
}",0.99002849002849
48036,"private void doInvokeRemote(){
  long callId=operationService.registerInvocation(this);
  boolean sent=operationService.send(op,invTarget);
  if (!sent) {
    operationService.deregisterInvocation(this);
    notify(new RetryableIOException(""String_Node_Str"" + invTarget));
  }
}","private void doInvokeRemote(){
  operationService.registerInvocation(this);
  boolean sent=operationService.send(op,invTarget);
  if (!sent) {
    operationService.deregisterInvocation(this);
    notify(new RetryableIOException(""String_Node_Str"" + invTarget));
  }
}",0.9779411764705882
48037,"public long registerInvocation(BasicInvocation invocation){
  long callId=callIdGen.getAndIncrement();
  Operation op=invocation.op;
  if (op.getCallId() != 0) {
    invocations.remove(op.getCallId());
  }
  invocations.put(callId,invocation);
  setCallId(invocation.op,callId);
  return callId;
}","public void registerInvocation(BasicInvocation invocation){
  long callId=callIdGen.getAndIncrement();
  Operation op=invocation.op;
  if (op.getCallId() != 0) {
    invocations.remove(op.getCallId());
  }
  invocations.put(callId,invocation);
  setCallId(invocation.op,callId);
}",0.9566724436741768
48038,"private void doInvokeRemote(){
  long callId=operationService.registerInvocation(this);
  boolean sent=operationService.send(op,invTarget);
  if (!sent) {
    operationService.deregisterInvocation(this);
    notify(new RetryableIOException(""String_Node_Str"" + invTarget));
  }
}","private void doInvokeRemote(){
  operationService.registerInvocation(this);
  boolean sent=operationService.send(op,invTarget);
  if (!sent) {
    operationService.deregisterInvocation(this);
    notify(new RetryableIOException(""String_Node_Str"" + invTarget));
  }
}",0.9779411764705882
48039,"public long registerInvocation(BasicInvocation invocation){
  long callId=callIdGen.getAndIncrement();
  Operation op=invocation.op;
  if (op.getCallId() != 0) {
    invocations.remove(op.getCallId());
  }
  invocations.put(callId,invocation);
  setCallId(invocation.op,callId);
  return callId;
}","public void registerInvocation(BasicInvocation invocation){
  long callId=callIdGen.getAndIncrement();
  Operation op=invocation.op;
  if (op.getCallId() != 0) {
    invocations.remove(op.getCallId());
  }
  invocations.put(callId,invocation);
  setCallId(invocation.op,callId);
}",0.9566724436741768
48040,"@Test public void testIssue1085WriteBehindBackup() throws InterruptedException {
  Config config=new Config();
  String name=""String_Node_Str"";
  MapConfig writeBehindBackup=config.getMapConfig(name);
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setWriteDelaySeconds(5);
  int size=1000;
  MapStoreWithStoreCount mapStore=new MapStoreWithStoreCount(size,120);
  mapStoreConfig.setImplementation(mapStore);
  writeBehindBackup.setMapStoreConfig(mapStoreConfig);
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  HazelcastInstance instance=factory.newHazelcastInstance(config);
  HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final IMap map=instance.getMap(name);
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  instance2.getLifecycleService().terminate();
  mapStore.awaitStores();
}","@Test public void testIssue1085WriteBehindBackup() throws InterruptedException {
  Config config=new Config();
  String name=""String_Node_Str"";
  MapConfig writeBehindBackup=config.getMapConfig(name);
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setWriteDelaySeconds(5);
  int size=1000;
  MapStoreWithStoreCount mapStore=new MapStoreWithStoreCount(size,120);
  mapStoreConfig.setImplementation(mapStore);
  writeBehindBackup.setMapStoreConfig(mapStoreConfig);
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  HazelcastInstance instance=factory.newHazelcastInstance(config);
  HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final IMap map=instance.getMap(name);
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  instance2.getLifecycleService().shutdown();
  mapStore.awaitStores();
}",0.9901677270098322
48041,"@Override protected HazelcastHttpSession createNewSession(RequestWrapper requestWrapper,String existingSessionId){
  HazelcastHttpSession session=super.createNewSession(requestWrapper,existingSessionId);
  ApplicationContext appContext=WebApplicationContextUtils.getWebApplicationContext(servletContext);
  if (appContext != null) {
    ensureSessionRegistryInitialized(appContext);
    if (sessionRegistry != null) {
      String originalSessionId=session.getOriginalSessionId();
      sessionRegistry.removeSessionInformation(originalSessionId);
      if (!isSessionRegistered(session.getId())) {
        appContext.publishEvent(new HttpSessionCreatedEvent(session));
        if (LOGGER.isLoggable(Level.FINEST)) {
          LOGGER.finest(""String_Node_Str"" + session);
        }
      }
    }
  }
  return session;
}","@Override protected HazelcastHttpSession createNewSession(RequestWrapper requestWrapper,String existingSessionId){
  HazelcastHttpSession session=super.createNewSession(requestWrapper,existingSessionId);
  ApplicationContext appContext=WebApplicationContextUtils.getWebApplicationContext(servletContext);
  if (appContext != null) {
    ensureSessionRegistryInitialized(appContext);
    if (sessionRegistry != null) {
      String originalSessionId=session.getOriginalSessionId();
      sessionRegistry.removeSessionInformation(originalSessionId);
      if (!isSessionRegistered(session.getId())) {
        appContext.publishEvent(new HttpSessionCreatedEvent(session));
        LOGGER.finest(""String_Node_Str"" + session.getId());
      }
    }
  }
  return session;
}",0.937539432176656
48042,"@Override protected void destroySession(HazelcastHttpSession session,boolean invalidate){
  super.destroySession(session,invalidate);
  if (invalidate) {
    ApplicationContext appContext=WebApplicationContextUtils.getWebApplicationContext(servletContext);
    if (appContext != null) {
      ensureSessionRegistryInitialized(appContext);
      if (sessionRegistry != null) {
        String originalSessionId=session.getOriginalSessionId();
        sessionRegistry.removeSessionInformation(originalSessionId);
        appContext.publishEvent(new HttpSessionDestroyedEvent(session));
        if (LOGGER.isLoggable(Level.FINEST)) {
          LOGGER.finest(""String_Node_Str"" + session);
        }
      }
    }
  }
}","@Override protected void destroySession(HazelcastHttpSession session,boolean invalidate){
  super.destroySession(session,invalidate);
  if (invalidate) {
    ApplicationContext appContext=WebApplicationContextUtils.getWebApplicationContext(servletContext);
    if (appContext != null) {
      ensureSessionRegistryInitialized(appContext);
      if (sessionRegistry != null) {
        String originalSessionId=session.getOriginalSessionId();
        sessionRegistry.removeSessionInformation(originalSessionId);
        appContext.publishEvent(new HttpSessionDestroyedEvent(session));
        LOGGER.finest(""String_Node_Str"" + session.getId());
      }
    }
  }
}",0.9512727272727272
48043,"private void handleSelectFailure(Throwable e){
  logger.warning(e.toString(),e);
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException i) {
    Thread.currentThread().interrupt();
  }
}","private void handleSelectFailure(Throwable e){
  logger.warning(e.toString(),e);
  try {
    Thread.sleep(SELECT_FAILURE_PAUSE_MILLIS);
  }
 catch (  InterruptedException i) {
    Thread.currentThread().interrupt();
  }
}",0.9260143198090692
48044,"/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  IMap<Object,Object> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  assertEquals(value,map.get(key));
}","/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  String key=""String_Node_Str"";
  String value=""String_Node_Str"";
  IMap<String,String> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  assertEquals(value,map.get(key));
}",0.9656160458452722
48045,"@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}","@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz);
  shutdownAndWait(hz2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz3);
  shutdownAndWait(hz4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
}",0.615687561535937
48046,"@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}","@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz6);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz2);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz5);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz3);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz4);
  waitForSafeStateAndCheckSize(size,hz,map);
}",0.4862023653088042
48047,"private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}","private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap<Integer,String> map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}",0.9933166248955724
48048,"@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}","@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m2=h2.getMap(MAP_NAME);
  shutdownAndWait(h1);
  waitForSafeStateAndCheckSize(size,h2,m2);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m3=h3.getMap(MAP_NAME);
  shutdownAndWait(h2);
  waitForSafeStateAndCheckSize(size,h3,m3);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m4=h4.getMap(MAP_NAME);
  shutdownAndWait(h3);
  waitForSafeStateAndCheckSize(size,h4,m4);
}",0.7878426698450537
48049,"/** 
 * Test for issue #259.
 */
@Test public void testBackupPutWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Object,Object> map=hz2.getMap(name);
  final int size=100000;
  final byte[] data=new byte[250];
  final int threads=100;
  final int l=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() < size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * l); j < (n + 1) * l; j++) {
          map.put(j,data);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
            return;
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",size,map.size());
  }
  finally {
    ex.shutdownNow();
  }
}","/** 
 * Test for issue #259.
 */
@Test public void testBackupPutWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Integer,byte[]> map=hz2.getMap(name);
  final int size=100000;
  final byte[] data=new byte[250];
  final int threads=100;
  final int l=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() < size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * l); j < (n + 1) * l; j++) {
          map.put(j,data);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
            return;
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",size,map.size());
  }
  finally {
    ex.shutdownNow();
  }
}",0.9914236706689536
48050,"/** 
 * Test for issue #259.
 */
@Test public void testBackupRemoveWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Object,Object> map=hz2.getMap(name);
  final int size=100000;
  final int threads=100;
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  final int loadCount=10;
  final CountDownLatch loadLatch=new CountDownLatch(loadCount);
  for (int i=0; i < loadCount; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        int chunk=size / loadCount;
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.put(j,j);
        }
        loadLatch.countDown();
      }
    }
);
  }
  loadLatch.await();
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() > size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  final int chunk=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.remove(j);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",0,map.size());
  }
  finally {
    ex.shutdown();
  }
}","/** 
 * Test for issue #259.
 */
@Test public void testBackupRemoveWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Integer,Integer> map=hz2.getMap(name);
  final int size=100000;
  final int threads=100;
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  final int loadCount=10;
  final CountDownLatch loadLatch=new CountDownLatch(loadCount);
  for (int i=0; i < loadCount; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        int chunk=size / loadCount;
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.put(j,j);
        }
        loadLatch.countDown();
      }
    }
);
  }
  loadLatch.await();
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() > size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  final int chunk=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.remove(j);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",0,map.size());
  }
  finally {
    ex.shutdown();
  }
}",0.99284140969163
48051,"/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  String key=""String_Node_Str"";
  String value=""String_Node_Str"";
  IMap<String,String> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  Assert.assertEquals(value,map.get(key));
}","/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  String key=""String_Node_Str"";
  String value=""String_Node_Str"";
  IMap<String,String> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  assertEquals(value,map.get(key));
}",0.9950106913756236
48052,"private void shutdownAndWait(HazelcastInstance instance){
  instance.shutdown();
  waitForTermination(instance);
}","private void shutdownAndWait(HazelcastInstance instance){
  long migrationActivationDelay=findMigrationActivationDelayTime(instance);
  instance.shutdown();
  waitForTermination(instance,migrationActivationDelay);
}",0.6930091185410334
48053,"@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz2,map2);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz);
  shutdownAndWait(hz2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz3);
  shutdownAndWait(hz4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
}","@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz);
  shutdownAndWait(hz2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz3);
  shutdownAndWait(hz4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
}",0.9386236825790452
48054,"@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz2,map2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz6);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz2,map2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz2);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz5);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz3);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz4);
  waitForMigrationAndCheckSize(size,hz,map);
}","@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  waitForSafeStateAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz6);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz2,map2);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz2);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  waitForSafeStateAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz5);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz3,map3);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz3);
  waitForSafeStateAndCheckSize(size,hz,map);
  waitForSafeStateAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz4);
  waitForSafeStateAndCheckSize(size,hz,map);
}",0.9122379327157484
48055,"@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m2=h2.getMap(MAP_NAME);
  shutdownAndWait(h1);
  waitForMigrationAndCheckSize(size,h2,m2);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m3=h3.getMap(MAP_NAME);
  shutdownAndWait(h2);
  waitForMigrationAndCheckSize(size,h3,m3);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m4=h4.getMap(MAP_NAME);
  shutdownAndWait(h3);
  waitForMigrationAndCheckSize(size,h4,m4);
}","@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m2=h2.getMap(MAP_NAME);
  shutdownAndWait(h1);
  waitForSafeStateAndCheckSize(size,h2,m2);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m3=h3.getMap(MAP_NAME);
  shutdownAndWait(h2);
  waitForSafeStateAndCheckSize(size,h3,m3);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m4=h4.getMap(MAP_NAME);
  shutdownAndWait(h3);
  waitForSafeStateAndCheckSize(size,h4,m4);
}",0.97
48056,"private void waitForTermination(final HazelcastInstance instance){
  final Node node=TestUtil.getNode(instance);
  if (node != null) {
    assertTrueEventually(new AssertTask(){
      public void run(){
        assertFalse(node.isActive());
      }
    }
);
  }
  sleepSeconds(3);
  for (  HazelcastInstance hz : HazelcastInstanceFactory.getAllHazelcastInstances()) {
    if (hz != instance) {
      waitForMigration(instance);
    }
  }
}","private void waitForTermination(final HazelcastInstance instance,final long migrationActivationDelay){
  final Node node=TestUtil.getNode(instance);
  if (node != null) {
    assertTrueEventually(new AssertTask(){
      public void run(){
        assertFalse(node.isActive());
      }
    }
);
  }
  sleepMillis((int)migrationActivationDelay);
  assertTrueEventually(new AssertTask(){
    public void run(){
      boolean allNodesAreInSafeState=true;
      for (      HazelcastInstance hz : HazelcastInstanceFactory.getAllHazelcastInstances()) {
        if (hz != instance) {
          if (!isInSafeState(hz)) {
            allNodesAreInSafeState=false;
            break;
          }
        }
      }
      assertTrue(allNodesAreInSafeState);
    }
  }
);
}",0.6377295492487479
48057,"private void doChunkedLoad(Map<Data,Object> loadedKeys,NodeEngine nodeEngine){
  final int mapLoadChunkSize=getLoadBatchSize();
  final Queue<Map> chunks=new LinkedList<Map>();
  Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
  final int partitionId=this.partitionId;
  Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<Data,Object> entry=iterator.next();
    final Data data=entry.getKey();
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
      partitionKeys.put(data,entry.getValue());
      if (partitionKeys.size() >= mapLoadChunkSize) {
        chunks.add(partitionKeys);
        partitionKeys=new HashMap<Data,Object>();
      }
      iterator.remove();
    }
  }
  if (!partitionKeys.isEmpty()) {
    chunks.add(partitionKeys);
  }
  if (chunks.isEmpty()) {
    setLoaded(true);
    return;
  }
  try {
    this.throwable=null;
    final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
    ExecutionService executionService=nodeEngine.getExecutionService();
    Map<Data,Object> chunkedKeys;
    while ((chunkedKeys=chunks.poll()) != null) {
      final Callback<Throwable> callback=createCallbackForThrowable();
      executionService.submit(ExecutionService.MAP_LOADER_EXECUTOR,new MapLoadAllTask(chunkedKeys,checkIfMapLoaded,callback));
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","private void doChunkedLoad(Map<Data,Object> loadedKeys,NodeEngine nodeEngine){
  final int mapLoadChunkSize=getLoadBatchSize();
  final Queue<Map> chunks=new LinkedList<Map>();
  Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
  final int partitionId=this.partitionId;
  Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<Data,Object> entry=iterator.next();
    final Data data=entry.getKey();
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
      partitionKeys.put(data,entry.getValue());
      if (partitionKeys.size() >= mapLoadChunkSize) {
        chunks.add(partitionKeys);
        partitionKeys=new HashMap<Data,Object>();
      }
      iterator.remove();
    }
  }
  if (!partitionKeys.isEmpty()) {
    chunks.add(partitionKeys);
  }
  if (chunks.isEmpty()) {
    setLoaded(true);
    return;
  }
  try {
    this.throwable=null;
    final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
    ExecutionService executionService=nodeEngine.getExecutionService();
    Map<Data,Object> chunkedKeys;
    while ((chunkedKeys=chunks.poll()) != null) {
      final Callback<Throwable> callback=createCallbackForThrowable();
      MapLoadAllTask task=new MapLoadAllTask(chunkedKeys,checkIfMapLoaded,callback);
      executionService.submit(ExecutionService.MAP_LOADER_EXECUTOR,task);
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.950575490859851
48058,"/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  IMap<Object,Object> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  Assert.assertEquals(value,map.get(key));
}","/** 
 * Tests data safety when multiple nodes start and a non-master node is shutdown immediately after start and doing a partition based operation.
 */
@Test public void testGracefulShutdown_Issue2804(){
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  String key=""String_Node_Str"";
  String value=""String_Node_Str"";
  IMap<String,String> map=h1.getMap(MAP_NAME);
  map.put(key,value);
  h2.shutdown();
  Assert.assertEquals(value,map.get(key));
}",0.9659574468085106
48059,"@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}","@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz2,map2);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz);
  shutdownAndWait(hz2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz3);
  shutdownAndWait(hz4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
}",0.615687561535937
48060,"@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}","@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Integer,Integer> map6=hz6.getMap(MAP_NAME);
  waitForMigrationAndCheckSize(size,hz2,map2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  waitForMigrationAndCheckSize(size,hz6,map6);
  shutdownAndWait(hz6);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz2,map2);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz2);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  waitForMigrationAndCheckSize(size,hz5,map5);
  shutdownAndWait(hz5);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz3,map3);
  waitForMigrationAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz3);
  waitForMigrationAndCheckSize(size,hz,map);
  waitForMigrationAndCheckSize(size,hz4,map4);
  shutdownAndWait(hz4);
  waitForMigrationAndCheckSize(size,hz,map);
}",0.4862023653088042
48061,"private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}","private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap<Integer,String> map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}",0.9933166248955724
48062,"@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}","@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m2=h2.getMap(MAP_NAME);
  shutdownAndWait(h1);
  waitForMigrationAndCheckSize(size,h2,m2);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m3=h3.getMap(MAP_NAME);
  shutdownAndWait(h2);
  waitForMigrationAndCheckSize(size,h3,m3);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> m4=h4.getMap(MAP_NAME);
  shutdownAndWait(h3);
  waitForMigrationAndCheckSize(size,h4,m4);
}",0.7878426698450537
48063,"/** 
 * Test for issue #259.
 */
@Test public void testBackupPutWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Object,Object> map=hz2.getMap(name);
  final int size=100000;
  final byte[] data=new byte[250];
  final int threads=100;
  final int l=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() < size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * l); j < (n + 1) * l; j++) {
          map.put(j,data);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
            return;
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",size,map.size());
  }
  finally {
    ex.shutdownNow();
  }
}","/** 
 * Test for issue #259.
 */
@Test public void testBackupPutWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Integer,byte[]> map=hz2.getMap(name);
  final int size=100000;
  final byte[] data=new byte[250];
  final int threads=100;
  final int l=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() < size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * l); j < (n + 1) * l; j++) {
          map.put(j,data);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
            return;
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",size,map.size());
  }
  finally {
    ex.shutdownNow();
  }
}",0.9914236706689536
48064,"/** 
 * Test for issue #259.
 */
@Test public void testBackupRemoveWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Object,Object> map=hz2.getMap(name);
  final int size=100000;
  final int threads=100;
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  final int loadCount=10;
  final CountDownLatch loadLatch=new CountDownLatch(loadCount);
  for (int i=0; i < loadCount; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        int chunk=size / loadCount;
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.put(j,j);
        }
        loadLatch.countDown();
      }
    }
);
  }
  loadLatch.await();
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() > size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  final int chunk=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.remove(j);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",0,map.size());
  }
  finally {
    ex.shutdown();
  }
}","/** 
 * Test for issue #259.
 */
@Test public void testBackupRemoveWhenOwnerNodeDead() throws InterruptedException {
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  final String name=MAP_NAME;
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance();
  final HazelcastInstance hz2=nodeFactory.newHazelcastInstance();
  final IMap<Integer,Integer> map=hz2.getMap(name);
  final int size=100000;
  final int threads=100;
  ExecutorService ex=Executors.newFixedThreadPool(threads);
  final int loadCount=10;
  final CountDownLatch loadLatch=new CountDownLatch(loadCount);
  for (int i=0; i < loadCount; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        int chunk=size / loadCount;
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.put(j,j);
        }
        loadLatch.countDown();
      }
    }
);
  }
  loadLatch.await();
  new Thread(){
    public void run(){
      while (hz.getMap(name).size() > size / 2) {
        try {
          sleep(5);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      TestUtil.terminateInstance(hz);
    }
  }
.start();
  final int chunk=size / threads;
  final CountDownLatch latch=new CountDownLatch(threads);
  for (int i=0; i < threads; i++) {
    final int n=i;
    ex.execute(new Runnable(){
      public void run(){
        for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
          map.remove(j);
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException ignored) {
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    assertTrue(latch.await(5,TimeUnit.MINUTES));
    assertEquals(""String_Node_Str"",0,map.size());
  }
  finally {
    ex.shutdown();
  }
}",0.99284140969163
48065,"@Test public void testDestroyTopicRemovesStatistics(){
  HazelcastInstance instance=createHazelcastInstance();
  final ITopic topic=instance.getTopic(""String_Node_Str"");
  topic.publish(""String_Node_Str"");
  sleepSeconds(1);
  topic.destroy();
  final TopicService topicService=getNode(instance).nodeEngine.getService(TopicService.SERVICE_NAME);
  assertTrueEventually(new AssertTask(){
    @Override public void run(){
      boolean containsStats=topicService.statsMap.containsKey(topic.getName());
      assertFalse(containsStats);
    }
  }
);
}","@Test public void testDestroyTopicRemovesStatistics(){
  HazelcastInstance instance=createHazelcastInstance();
  final ITopic topic=instance.getTopic(""String_Node_Str"");
  topic.publish(""String_Node_Str"");
  sleepSeconds(1);
  topic.destroy();
  final TopicService topicService=getNode(instance).nodeEngine.getService(TopicService.SERVICE_NAME);
  assertTrueEventually(new AssertTask(){
    @Override public void run(){
      boolean containsStats=topicService.getStatsMap().containsKey(topic.getName());
      assertFalse(containsStats);
    }
  }
);
}",0.9936421435059036
48066,"@PrivateApi public static <V>Collection<V> returnWithDeadline(Collection<Future> futures,long overallTimeout,TimeUnit overallTimeUnit,long perFutureTimeout,TimeUnit perFutureTimeUnit,ExceptionHandler exceptionHandler) throws TimeoutException {
  long overallTimeoutNanos=calculateTimeout(overallTimeout,overallTimeUnit);
  long perFutureTimeoutNanos=calculateTimeout(perFutureTimeout,perFutureTimeUnit);
  long deadline=System.nanoTime() + overallTimeoutNanos;
  List<V> results=new ArrayList<V>(futures.size());
  for (  Future<V> future : futures) {
    try {
      long timeoutNanos=calculateFutureTimeout(perFutureTimeoutNanos,deadline);
      V value=executeWithDeadline(future,timeoutNanos,exceptionHandler);
      if (value != null) {
        results.add(value);
      }
    }
 catch (    TimeoutException e) {
      if (deadline - System.nanoTime() <= 0) {
        cancelAllFutures(futures);
        throw (TimeoutException)e;
      }
    }
catch (    Exception e) {
      cancelAllFutures(futures);
      ExceptionUtil.sneakyThrow(e);
    }
  }
  return results;
}","@PrivateApi public static <V>Collection<V> returnWithDeadline(Collection<Future> futures,long overallTimeout,TimeUnit overallTimeUnit,long perFutureTimeout,TimeUnit perFutureTimeUnit,ExceptionHandler exceptionHandler) throws TimeoutException {
  long overallTimeoutNanos=calculateTimeout(overallTimeout,overallTimeUnit);
  long perFutureTimeoutNanos=calculateTimeout(perFutureTimeout,perFutureTimeUnit);
  long deadline=System.nanoTime() + overallTimeoutNanos;
  List<V> results=new ArrayList<V>(futures.size());
  for (  Future<V> future : futures) {
    try {
      long timeoutNanos=calculateFutureTimeout(perFutureTimeoutNanos,deadline);
      V value=executeWithDeadline(future,timeoutNanos,exceptionHandler);
      if (value != null) {
        results.add(value);
      }
    }
 catch (    TimeoutException e) {
      cancelAllFutures(futures);
      throw (TimeoutException)e;
    }
catch (    RuntimeException e) {
      cancelAllFutures(futures);
      throw (RuntimeException)e;
    }
catch (    Exception e) {
      cancelAllFutures(futures);
      throw new RuntimeException(e);
    }
  }
  return results;
}",0.8901048791609667
48067,"@PrivateApi public static void waitWithDeadline(Collection<Future> futures,long overallTimeout,TimeUnit overallTimeUnit,long perFutureTimeout,TimeUnit perFutureTimeUnit,ExceptionHandler exceptionHandler) throws TimeoutException {
  long overallTimeoutNanos=calculateTimeout(overallTimeout,overallTimeUnit);
  long perFutureTimeoutNanos=calculateTimeout(perFutureTimeout,perFutureTimeUnit);
  long deadline=System.nanoTime() + overallTimeoutNanos;
  for (  Future future : futures) {
    try {
      long timeoutNanos=calculateFutureTimeout(perFutureTimeoutNanos,deadline);
      executeWithDeadline(future,timeoutNanos,exceptionHandler);
    }
 catch (    TimeoutException e) {
      if (deadline - System.nanoTime() <= 0) {
        cancelAllFutures(futures);
        throw (TimeoutException)e;
      }
    }
catch (    Exception e) {
      cancelAllFutures(futures);
      ExceptionUtil.sneakyThrow(e);
    }
  }
}","@PrivateApi public static void waitWithDeadline(Collection<Future> futures,long overallTimeout,TimeUnit overallTimeUnit,long perFutureTimeout,TimeUnit perFutureTimeUnit,ExceptionHandler exceptionHandler) throws TimeoutException {
  long overallTimeoutNanos=calculateTimeout(overallTimeout,overallTimeUnit);
  long perFutureTimeoutNanos=calculateTimeout(perFutureTimeout,perFutureTimeUnit);
  long deadline=System.nanoTime() + overallTimeoutNanos;
  for (  Future future : futures) {
    try {
      long timeoutNanos=calculateFutureTimeout(perFutureTimeoutNanos,deadline);
      executeWithDeadline(future,timeoutNanos,exceptionHandler);
    }
 catch (    TimeoutException e) {
      cancelAllFutures(futures);
      throw (TimeoutException)e;
    }
catch (    RuntimeException e) {
      cancelAllFutures(futures);
      throw (RuntimeException)e;
    }
catch (    Exception e) {
      cancelAllFutures(futures);
      throw new RuntimeException(e);
    }
  }
}",0.8151305274374001
48068,"@Override public void run(){
  if (waitLock.compareAndSet(true,false)) {
    try {
      for (; ; ) {
        Thread.sleep(100);
      }
    }
 catch (    InterruptedException ignored) {
      interrupted.set(true);
    }
  }
}","@Override public void run(){
  long start=System.nanoTime();
  if (waitLock.compareAndSet(true,false)) {
    try {
      for (; ; ) {
        Thread.sleep(100);
      }
    }
 catch (    InterruptedException ignored) {
      deltaToInterrupted.set(System.nanoTime() - start);
      interrupted.set(true);
    }
  }
}",0.7108655616942909
48069,"@Test @Category(NightlyTest.class) public void testIssue1085EvictionBackup() throws InterruptedException {
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setTimeToLiveSeconds(3);
  HazelcastInstance[] instances=createHazelcastInstanceFactory(3).newInstances(config);
  int size=1000;
  final CountDownLatch latch=new CountDownLatch(size);
  final IMap map=instances[0].getMap(""String_Node_Str"");
  map.addEntryListener(new EntryAdapter(){
    @Override public void entryEvicted(    EntryEvent event){
      super.entryEvicted(event);
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  instances[1].shutdown();
  instances[2].shutdown();
  assertOpenEventually(latch);
  assertSizeEventually(0,map);
}","@Test public void testIssue1085EvictionBackup() throws InterruptedException {
  final String mapName=randomMapName();
  int entryCount=10;
  Config config=new Config();
  config.getMapConfig(mapName).setTimeToLiveSeconds(3);
  HazelcastInstance[] instances=createHazelcastInstanceFactory(2).newInstances(config);
  final CountDownLatch latch=new CountDownLatch(entryCount);
  final IMap map=instances[0].getMap(mapName);
  map.addEntryListener(new EntryAdapter(){
    @Override public void entryEvicted(    EntryEvent event){
      super.entryEvicted(event);
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < entryCount; i++) {
    map.put(i,i);
  }
  assertOpenEventually(latch);
  assertSizeEventually(0,map);
  assertHeapCostsZeroEventually(mapName,instances);
}",0.6155827430779137
48070,"@Override public QueryResult queryOnPartition(String mapName,Predicate predicate,int partitionId){
  final QueryResult result=new QueryResult();
  final PartitionContainer container=mapServiceContext.getPartitionContainer(partitionId);
  final RecordStore recordStore=container.getRecordStore(mapName);
  final SerializationService serializationService=nodeEngine.getSerializationService();
  final PagingPredicate pagingPredicate=predicate instanceof PagingPredicate ? (PagingPredicate)predicate : null;
  List<QueryEntry> list=new LinkedList<QueryEntry>();
  final Iterator<Record> iterator=recordStore.loadAwareIterator();
  while (iterator.hasNext()) {
    final Record record=iterator.next();
    Data key=record.getKey();
    Object value=record.getValue();
    if (value == null) {
      continue;
    }
    QueryEntry queryEntry=new QueryEntry(serializationService,key,key,value);
    if (predicate.apply(queryEntry)) {
      if (pagingPredicate != null) {
        Map.Entry anchor=pagingPredicate.getAnchor();
        if (anchor != null && SortingUtil.compare(pagingPredicate.getComparator(),pagingPredicate.getIterationType(),anchor,queryEntry) >= 0) {
          continue;
        }
      }
      list.add(queryEntry);
    }
  }
  list=getPage(list,pagingPredicate);
  for (  QueryEntry entry : list) {
    result.add(new QueryResultEntryImpl(entry.getKeyData(),entry.getKeyData(),entry.getValueData()));
  }
  return result;
}","@Override public Collection<QueryableEntry> queryOnPartition(String mapName,Predicate predicate,int partitionId){
  final PartitionContainer container=mapServiceContext.getPartitionContainer(partitionId);
  final RecordStore recordStore=container.getRecordStore(mapName);
  final SerializationService serializationService=nodeEngine.getSerializationService();
  final PagingPredicate pagingPredicate=predicate instanceof PagingPredicate ? (PagingPredicate)predicate : null;
  List<QueryEntry> list=new LinkedList<QueryEntry>();
  final Iterator<Record> iterator=recordStore.loadAwareIterator();
  while (iterator.hasNext()) {
    final Record record=iterator.next();
    Data key=record.getKey();
    Object value=getValueOrCachedValue(record);
    if (value == null) {
      continue;
    }
    QueryEntry queryEntry=new QueryEntry(serializationService,key,key,value);
    if (predicate.apply(queryEntry)) {
      if (pagingPredicate != null) {
        Map.Entry anchor=pagingPredicate.getAnchor();
        if (anchor != null && SortingUtil.compare(pagingPredicate.getComparator(),pagingPredicate.getIterationType(),anchor,queryEntry) >= 0) {
          continue;
        }
      }
      list.add(queryEntry);
    }
  }
  return getPage(list,pagingPredicate);
}",0.8932542624166049
48071,"/** 
 * Query a specific partition.
 * @param mapName     map name.
 * @param predicate   any predicate.
 * @param partitionId partition id.
 * @return {@link com.hazelcast.map.QueryResult}
 */
QueryResult queryOnPartition(String mapName,Predicate predicate,int partitionId);","/** 
 * Query a specific partition.
 * @param mapName     map name.
 * @param predicate   any predicate.
 * @param partitionId partition id.
 * @return result of query
 */
Collection<QueryableEntry> queryOnPartition(String mapName,Predicate predicate,int partitionId);",0.8397790055248618
48072,"public Set<QueryResultEntry> getResult(){
  return result;
}","public Collection<QueryResultEntry> getResult(){
  return result;
}",0.9291338582677166
48073,"public Collection<QueryableEntry> call() throws Exception {
  final PartitionContainer container=mapService.getMapServiceContext().getPartitionContainer(partition);
  final RecordStore recordStore=container.getRecordStore(name);
  LinkedList<QueryableEntry> partitionResult=new LinkedList<QueryableEntry>();
  final Iterator<Record> iterator=recordStore.loadAwareIterator();
  while (iterator.hasNext()) {
    final Record record=iterator.next();
    final Data key=record.getKey();
    final Object value=getValueOrCachedValue(record);
    if (value == null) {
      continue;
    }
    final QueryEntry queryEntry=new QueryEntry(ss,key,key,value);
    if (predicate.apply(queryEntry)) {
      if (pagingPredicate != null) {
        Map.Entry anchor=pagingPredicate.getAnchor();
        final Comparator comparator=pagingPredicate.getComparator();
        if (anchor != null && SortingUtil.compare(comparator,pagingPredicate.getIterationType(),anchor,queryEntry) >= 0) {
          continue;
        }
      }
      partitionResult.add(queryEntry);
    }
  }
  if (pagingPredicate != null) {
    Collections.sort(partitionResult,wrapperComparator);
    if (partitionResult.size() > pagingPredicate.getPageSize()) {
      return partitionResult.subList(0,pagingPredicate.getPageSize());
    }
  }
  return partitionResult;
}","public Collection<QueryableEntry> call() throws Exception {
  MapContextQuerySupport mapContextQuerySupport=mapService.getMapServiceContext().getMapContextQuerySupport();
  return mapContextQuerySupport.queryOnPartition(name,predicate,partition);
}",0.1400381922342457
48074,"protected void runParallelForPaging(List<Integer> initialPartitions) throws InterruptedException, ExecutionException {
  final NodeEngine nodeEngine=getNodeEngine();
  final SerializationService ss=nodeEngine.getSerializationService();
  final ExecutorService executor=nodeEngine.getExecutionService().getExecutor(ExecutionService.QUERY_EXECUTOR);
  final List<Future<Collection<QueryableEntry>>> lsFutures=new ArrayList<Future<Collection<QueryableEntry>>>(initialPartitions.size());
  final Comparator<Map.Entry> wrapperComparator=SortingUtil.newComparator(pagingPredicate);
  for (  final Integer partition : initialPartitions) {
    Future<Collection<QueryableEntry>> f=executor.submit(new PartitionCallable(ss,partition,wrapperComparator));
    lsFutures.add(f);
  }
  List<QueryableEntry> toMerge=new LinkedList<QueryableEntry>();
  for (  Future<Collection<QueryableEntry>> future : lsFutures) {
    final Collection<QueryableEntry> collection=future.get();
    toMerge.addAll(collection);
  }
  Collections.sort(toMerge,wrapperComparator);
  if (toMerge.size() > pagingPredicate.getPageSize()) {
    toMerge=toMerge.subList(0,pagingPredicate.getPageSize());
  }
  for (  QueryableEntry entry : toMerge) {
    result.add(new QueryResultEntryImpl(entry.getKeyData(),entry.getKeyData(),entry.getValueData()));
  }
}","protected void runParallelForPaging(List<Integer> initialPartitions) throws InterruptedException, ExecutionException {
  final NodeEngine nodeEngine=getNodeEngine();
  final ExecutorService executor=nodeEngine.getExecutionService().getExecutor(ExecutionService.QUERY_EXECUTOR);
  final List<Future<Collection<QueryableEntry>>> lsFutures=new ArrayList<Future<Collection<QueryableEntry>>>(initialPartitions.size());
  final Comparator<Map.Entry> wrapperComparator=SortingUtil.newComparator(pagingPredicate);
  for (  final Integer partitionId : initialPartitions) {
    Future<Collection<QueryableEntry>> f=executor.submit(new PartitionCallable(partitionId));
    lsFutures.add(f);
  }
  List<QueryableEntry> toMerge=new LinkedList<QueryableEntry>();
  for (  Future<Collection<QueryableEntry>> future : lsFutures) {
    final Collection<QueryableEntry> collection=future.get();
    toMerge.addAll(collection);
  }
  Collections.sort(toMerge,wrapperComparator);
  if (toMerge.size() > pagingPredicate.getPageSize()) {
    toMerge=toMerge.subList(0,pagingPredicate.getPageSize());
  }
  for (  QueryableEntry entry : toMerge) {
    result.add(new QueryResultEntryImpl(entry.getKeyData(),entry.getKeyData(),entry.getValueData()));
  }
}",0.7322618580948648
48075,"private PartitionCallable(SerializationService ss,int partition,Comparator<Map.Entry> wrapperComparator){
  this.ss=ss;
  this.partition=partition;
  this.wrapperComparator=wrapperComparator;
}","private PartitionCallable(int partitionId){
  this.partition=partitionId;
}",0.5298507462686567
48076,"protected void runParallel(final List<Integer> initialPartitions) throws InterruptedException, ExecutionException {
  final NodeEngine nodeEngine=getNodeEngine();
  final SerializationService ss=nodeEngine.getSerializationService();
  final ExecutorService executor=nodeEngine.getExecutionService().getExecutor(ExecutionService.QUERY_EXECUTOR);
  final List<Future<Collection<QueryableEntry>>> lsFutures=new ArrayList<Future<Collection<QueryableEntry>>>(initialPartitions.size());
  for (  final Integer partition : initialPartitions) {
    Future<Collection<QueryableEntry>> f=executor.submit(new PartitionCallable(ss,partition,null));
    lsFutures.add(f);
  }
  for (  Future<Collection<QueryableEntry>> future : lsFutures) {
    final Collection<QueryableEntry> collection=future.get();
    if (collection != null) {
      for (      QueryableEntry entry : collection) {
        result.add(new QueryResultEntryImpl(entry.getKeyData(),entry.getKeyData(),entry.getValueData()));
      }
    }
  }
}","protected void runParallel(final List<Integer> initialPartitions) throws InterruptedException, ExecutionException {
  final NodeEngine nodeEngine=getNodeEngine();
  final ExecutorService executor=nodeEngine.getExecutionService().getExecutor(ExecutionService.QUERY_EXECUTOR);
  final List<Future<Collection<QueryableEntry>>> lsFutures=new ArrayList<Future<Collection<QueryableEntry>>>(initialPartitions.size());
  for (  Integer partitionId : initialPartitions) {
    Future<Collection<QueryableEntry>> f=executor.submit(new PartitionCallable(partitionId));
    lsFutures.add(f);
  }
  for (  Future<Collection<QueryableEntry>> future : lsFutures) {
    final Collection<QueryableEntry> collection=future.get();
    if (collection != null) {
      for (      QueryableEntry entry : collection) {
        result.add(new QueryResultEntryImpl(entry.getKeyData(),entry.getKeyData(),entry.getValueData()));
      }
    }
  }
}",0.9541666666666668
48077,"public void run(){
  result=mapService.getMapServiceContext().getMapContextQuerySupport().queryOnPartition(name,predicate,getPartitionId());
}","public void run(){
  Collection<QueryableEntry> queryableEntries=mapService.getMapServiceContext().getMapContextQuerySupport().queryOnPartition(name,predicate,getPartitionId());
  result=new QueryResult(queryableEntries);
}",0.7452054794520548
48078,"private void advance(){
  while (iterator.hasNext()) {
    nextRecord=iterator.next();
    nextRecord=nullIfExpired(nextRecord);
    if (nextRecord != null) {
      break;
    }
  }
}","private void advance(){
  while (iterator.hasNext()) {
    nextRecord=iterator.next();
    nextRecord=nullIfExpired(nextRecord);
    if (nextRecord != null) {
      return;
    }
  }
  nextRecord=null;
}",0.922279792746114
48079,"private MultiExecutionCallbackWrapper(final int memberSize,final MultiExecutionCallback multiExecutionCallback){
  this.multiExecutionCallback=multiExecutionCallback;
  this.values=new HashMap<Member,Object>(memberSize);
  this.members=new AtomicInteger(memberSize);
}","private MultiExecutionCallbackWrapper(final int memberSize,final MultiExecutionCallback multiExecutionCallback){
  this.multiExecutionCallback=multiExecutionCallback;
  this.values=new ConcurrentHashMap<Member,Object>(memberSize);
  this.members=new AtomicInteger(memberSize);
}",0.9816849816849816
48080,"/** 
 * fails randomly. Example stack trace is here: https://hazelcast-l337.ci.cloudbees.com/job/Hazelcast-3.x-OpenJDK7/com.hazelcast$hazelcast-client/133/testReport/com.hazelcast.client.executor/ClientExecutorServiceSubmitTest/submitCallableToMember_withMultiExecutionCallback/
 */
@Test @Category(ProblematicTest.class) public void submitCallableToMember_withMultiExecutionCallback() throws Exception {
  final IExecutorService service=client.getExecutorService(randomString());
  final CountDownLatch responseLatch=new CountDownLatch(CLUSTER_SIZE);
  final CountDownLatch completeLatch=new CountDownLatch(CLUSTER_SIZE);
  final String msg=randomString();
  final Callable callable=new AppendCallable(msg);
  final Collection<Member> collection=instance2.getCluster().getMembers();
  service.submitToMembers(callable,collection,new MultiExecutionCallback(){
    public void onResponse(    final Member member,    final Object value){
      if (value.equals(msg + AppendCallable.APPENDAGE)) {
        responseLatch.countDown();
      }
    }
    public void onComplete(    final Map<Member,Object> values){
      for (      final Member member : values.keySet()) {
        final Object value=values.get(member);
        if (value.equals(msg + AppendCallable.APPENDAGE)) {
          completeLatch.countDown();
        }
      }
    }
  }
);
  assertOpenEventually(""String_Node_Str"",responseLatch);
  assertOpenEventually(""String_Node_Str"",completeLatch);
}","@Test public void submitCallableToMember_withMultiExecutionCallback() throws Exception {
  final IExecutorService service=client.getExecutorService(randomString());
  final CountDownLatch responseLatch=new CountDownLatch(CLUSTER_SIZE);
  final CountDownLatch completeLatch=new CountDownLatch(CLUSTER_SIZE);
  final String msg=randomString();
  final Callable<String> callable=new AppendCallable(msg);
  final Collection<Member> collection=instance2.getCluster().getMembers();
  service.submitToMembers(callable,collection,new MultiExecutionCallback(){
    public void onResponse(    final Member member,    final Object value){
      if (value.equals(msg + AppendCallable.APPENDAGE)) {
        responseLatch.countDown();
      }
    }
    public void onComplete(    final Map<Member,Object> values){
      for (      final Member member : values.keySet()) {
        final Object value=values.get(member);
        if (value.equals(msg + AppendCallable.APPENDAGE)) {
          completeLatch.countDown();
        }
      }
    }
  }
);
  assertOpenEventually(""String_Node_Str"",responseLatch);
  assertOpenEventually(""String_Node_Str"",completeLatch);
}",0.8625192012288786
48081,"@Override public <T>void submitToAllMembers(Callable<T> task,MultiExecutionCallback callback){
  final Collection<MemberImpl> memberList=getContext().getClusterService().getMemberList();
  MultiExecutionCallbackWrapper multiExecutionCallbackWrapper=new MultiExecutionCallbackWrapper(memberList.size(),callback);
  for (  Member member : memberList) {
    final ExecutionCallbackWrapper executionCallback=new ExecutionCallbackWrapper(multiExecutionCallbackWrapper,member);
    submitToMember(task,member,executionCallback);
  }
}","@Override public <T>void submitToAllMembers(Callable<T> task,MultiExecutionCallback callback){
  final Collection<MemberImpl> memberList=getContext().getClusterService().getMemberList();
  MultiExecutionCallbackWrapper multiExecutionCallbackWrapper=new MultiExecutionCallbackWrapper(memberList.size(),callback);
  for (  Member member : memberList) {
    final ExecutionCallbackWrapper<T> executionCallback=new ExecutionCallbackWrapper<T>(multiExecutionCallbackWrapper,member);
    submitToMember(task,member,executionCallback);
  }
}",0.9943502824858758
48082,"public void onResponse(Member member,Object value){
  multiExecutionCallback.onResponse(member,value);
  values.put(member,value);
  int waitingResponse=members.decrementAndGet();
  if (waitingResponse == 0) {
    onComplete(values);
  }
}","public void onResponse(final Member member,final Object value){
  multiExecutionCallback.onResponse(member,value);
  values.put(member,value);
  int waitingResponse=members.decrementAndGet();
  if (waitingResponse == 0) {
    onComplete(values);
  }
}",0.9755102040816328
48083,"private MultiExecutionCallbackWrapper(int memberSize,MultiExecutionCallback multiExecutionCallback){
  this.multiExecutionCallback=multiExecutionCallback;
  this.members=new AtomicInteger(memberSize);
  values=new HashMap<Member,Object>(memberSize);
}","private MultiExecutionCallbackWrapper(final int memberSize,final MultiExecutionCallback multiExecutionCallback){
  this.multiExecutionCallback=multiExecutionCallback;
  this.values=new HashMap<Member,Object>(memberSize);
  this.members=new AtomicInteger(memberSize);
}",0.789980732177264
48084,"public void onComplete(Map<Member,Object> values){
  multiExecutionCallback.onComplete(values);
}","public void onComplete(final Map<Member,Object> values){
  multiExecutionCallback.onComplete(values);
}",0.97
48085,"private ICompletableFuture invokeFuture(TargetCallableRequest request){
  try {
    return getContext().getInvocationService().invokeOnTarget(request,request.getTarget());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","private <T>ICompletableFuture<T> invokeFuture(TargetCallableRequest request){
  try {
    return getContext().getInvocationService().invokeOnTarget(request,request.getTarget());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9877551020408164
48086,"public boolean isShutdown(){
  try {
    final IsShutdownRequest request=new IsShutdownRequest(name);
    Boolean result=invoke(request);
    return result;
  }
 catch (  DistributedObjectDestroyedException e) {
    return true;
  }
}","public boolean isShutdown(){
  try {
    final IsShutdownRequest request=new IsShutdownRequest(name);
    return (Boolean)invoke(request);
  }
 catch (  DistributedObjectDestroyedException e) {
    return true;
  }
}",0.92
48087,"@Test public void testExecuteOnMembers(){
  final IExecutorService service=client.getExecutorService(randomString());
  final String mapName=randomString();
  final Collection collection=new ArrayList();
  final Member member1=instance1.getCluster().getLocalMember();
  final Member member3=instance3.getCluster().getLocalMember();
  collection.add(member1);
  collection.add(member3);
  service.executeOnMembers(new MapPutRunnable(mapName),collection);
  final IMap map=client.getMap(mapName);
  assertTrueEventually(new AssertTask(){
    public void run() throws Exception {
      assertTrue(map.containsKey(member1.getUuid()));
      assertTrue(map.containsKey(member3.getUuid()));
    }
  }
);
}","@Test public void testExecuteOnMembers(){
  final IExecutorService service=client.getExecutorService(randomString());
  final String mapName=randomString();
  final Collection<Member> collection=new ArrayList<Member>();
  final Member member1=instance1.getCluster().getLocalMember();
  final Member member3=instance3.getCluster().getLocalMember();
  collection.add(member1);
  collection.add(member3);
  service.executeOnMembers(new MapPutRunnable(mapName),collection);
  final IMap map=client.getMap(mapName);
  assertTrueEventually(new AssertTask(){
    public void run() throws Exception {
      assertTrue(map.containsKey(member1.getUuid()));
      assertTrue(map.containsKey(member3.getUuid()));
    }
  }
);
}",0.9886845827439888
48088,"@Test(expected=IllegalArgumentException.class) public void testExecuteOnMembers_whenSelectorNull(){
  IExecutorService service=client.getExecutorService(randomString());
  MemberSelector selector=null;
  service.executeOnMembers(new MapPutRunnable(""String_Node_Str""),selector);
}","@Test(expected=IllegalArgumentException.class) public void testExecuteOnMembers_whenSelectorNull(){
  final IExecutorService service=client.getExecutorService(randomString());
  final MemberSelector selector=null;
  service.executeOnMembers(new MapPutRunnable(""String_Node_Str""),selector);
}",0.9789473684210528
48089,"@Test public void testExecuteOnMembers_withEmptyCollection(){
  final IExecutorService service=client.getExecutorService(randomString());
  final String mapName=randomString();
  final Collection collection=new ArrayList();
  service.executeOnMembers(new MapPutRunnable(mapName),collection);
  final IMap map=client.getMap(mapName);
  assertSizeEventually(0,map);
}","@Test public void testExecuteOnMembers_withEmptyCollection(){
  final IExecutorService service=client.getExecutorService(randomString());
  final String mapName=randomString();
  final Collection<Member> collection=new ArrayList<Member>();
  service.executeOnMembers(new MapPutRunnable(mapName),collection);
  final IMap map=client.getMap(mapName);
  assertSizeEventually(0,map);
}",0.9785522788203752
48090,"@Test(expected=NullPointerException.class) public void testExecuteOnMembers_WhenCollectionNull(){
  IExecutorService service=client.getExecutorService(randomString());
  Collection collection=null;
  service.executeOnMembers(new MapPutRunnable(""String_Node_Str""),collection);
}","@Test(expected=NullPointerException.class) public void testExecuteOnMembers_WhenCollectionNull(){
  final IExecutorService service=client.getExecutorService(randomString());
  final Collection<Member> collection=null;
  service.executeOnMembers(new MapPutRunnable(""String_Node_Str""),collection);
}",0.9651567944250872
48091,"@Test(expected=NullPointerException.class) public void testExecute_whenTaskNull(){
  IExecutorService service=client.getExecutorService(randomString());
  service.execute(null);
}","@Test(expected=NullPointerException.class) public void testExecute_whenTaskNull(){
  final IExecutorService service=client.getExecutorService(randomString());
  service.execute(null);
}",0.9835164835164836
48092,"@Test(expected=UnsupportedOperationException.class) public void testInvokeAll_withTimeOut() throws Throwable {
  IExecutorService service=client.getExecutorService(randomString());
  Collection c=new ArrayList();
  c.add(new AppendCallable());
  c.add(new AppendCallable());
  service.invokeAll(c,1,TimeUnit.MINUTES);
}","@Test(expected=UnsupportedOperationException.class) public void testInvokeAll_withTimeOut() throws Throwable {
  final IExecutorService service=client.getExecutorService(randomString());
  final Collection<Callable<String>> collection=new ArrayList<Callable<String>>();
  collection.add(new AppendCallable());
  collection.add(new AppendCallable());
  service.invokeAll(collection,1,TimeUnit.MINUTES);
}",0.8781163434903048
48093,"@Test(expected=UnsupportedOperationException.class) public void testInvokeAnyTimeOut() throws Throwable, InterruptedException {
  IExecutorService service=client.getExecutorService(randomString());
  Collection c=new ArrayList();
  c.add(new AppendCallable());
  c.add(new AppendCallable());
  service.invokeAny(c,1,TimeUnit.MINUTES);
}","@Test(expected=UnsupportedOperationException.class) public void testInvokeAnyTimeOut() throws Throwable {
  final IExecutorService service=client.getExecutorService(randomString());
  final Collection<Callable<String>> collection=new ArrayList<Callable<String>>();
  collection.add(new AppendCallable());
  collection.add(new AppendCallable());
  service.invokeAny(collection,1,TimeUnit.MINUTES);
}",0.7193460490463215
48094,"@Test(expected=UnsupportedOperationException.class) public void testInvokeAny() throws Throwable, InterruptedException {
  IExecutorService service=client.getExecutorService(randomString());
  Collection c=new ArrayList();
  c.add(new AppendCallable());
  c.add(new AppendCallable());
  service.invokeAny(c);
}","@Test(expected=UnsupportedOperationException.class) public void testInvokeAny() throws Throwable {
  final IExecutorService service=client.getExecutorService(randomString());
  final Collection<Callable<String>> collection=new ArrayList<Callable<String>>();
  collection.add(new AppendCallable());
  collection.add(new AppendCallable());
  service.invokeAny(collection);
}",0.6979472140762464
48095,"@Test public void testInvokeAll() throws Throwable {
  IExecutorService service=client.getExecutorService(randomString());
  String msg=randomString();
  Collection c=new ArrayList();
  c.add(new AppendCallable(msg));
  c.add(new AppendCallable(msg));
  List<Future> results=service.invokeAll(c);
  for (  Future result : results) {
    assertEquals(msg + AppendCallable.APPENDAGE,result.get());
  }
}","@Test public void testInvokeAll() throws Throwable {
  final IExecutorService service=client.getExecutorService(randomString());
  final String msg=randomString();
  final Collection<Callable<String>> collection=new ArrayList<Callable<String>>();
  collection.add(new AppendCallable(msg));
  collection.add(new AppendCallable(msg));
  final List<Future<String>> results=service.invokeAll(collection);
  for (  final Future<String> result : results) {
    assertEquals(msg + AppendCallable.APPENDAGE,result.get());
  }
}",0.8521739130434782
48096,"public void shutdown(final boolean terminate){
  long start=Clock.currentTimeMillis();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + String.valueOf(active));
  }
  if (!terminate && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    if (!partitionService.prepareToSafeShutdown(maxWaitSeconds,TimeUnit.SECONDS)) {
      logger.warning(""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    if (!terminate) {
      clusterService.sendShutdownMessage();
    }
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    versionCheck.shutdown();
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.finest(""String_Node_Str"");
    nodeEngine.shutdown(terminate);
    if (multicastService != null) {
      logger.finest(""String_Node_Str"");
      multicastService.stop();
    }
    logger.finest(""String_Node_Str"");
    connectionManager.shutdown();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    serializationService.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      if (thread.isAlive()) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + thread.getName());
        }
        thread.interrupt();
      }
    }
    failedConnections.clear();
    systemLogService.shutdown();
    logger.info(""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}","public void shutdown(final boolean terminate){
  long start=Clock.currentTimeMillis();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + String.valueOf(active));
  }
  if (!terminate && isActive() && joined()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    if (!partitionService.prepareToSafeShutdown(maxWaitSeconds,TimeUnit.SECONDS)) {
      logger.warning(""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    if (!terminate) {
      clusterService.sendShutdownMessage();
    }
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    versionCheck.shutdown();
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.finest(""String_Node_Str"");
    nodeEngine.shutdown(terminate);
    if (multicastService != null) {
      logger.finest(""String_Node_Str"");
      multicastService.stop();
    }
    logger.finest(""String_Node_Str"");
    connectionManager.shutdown();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    serializationService.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      if (thread.isAlive()) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + thread.getName());
        }
        thread.interrupt();
      }
    }
    failedConnections.clear();
    systemLogService.shutdown();
    logger.info(""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}",0.9968635650810246
48097,"void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"" + node.isActive() + ""String_Node_Str""+ node.joined()+ ""String_Node_Str"");
      }
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.warning(""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.severe(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.warning(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    PartitionInfo[] state=partitionState.getPartitions();
    filterAndLogUnknownAddressesInPartitionTable(sender,state);
    finalizeOrRollbackMigration(partitionState,state);
    stateVersion.set(partitionState.getVersion());
    initialized=true;
  }
  finally {
    lock.unlock();
  }
}","void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"" + node.isActive() + ""String_Node_Str""+ node.joined()+ ""String_Node_Str"");
      }
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.warning(""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.severe(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.warning(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    stateVersion.set(partitionState.getVersion());
    initialized=true;
    PartitionInfo[] state=partitionState.getPartitions();
    filterAndLogUnknownAddressesInPartitionTable(sender,state);
    finalizeOrRollbackMigration(partitionState,state);
  }
  finally {
    lock.unlock();
  }
}",0.94283476898982
48098,"private boolean checkReplicaSyncState(){
  if (!initialized || !node.joined()) {
    return true;
  }
  if (getMemberGroupsSize() < 2) {
    return true;
  }
  final Address thisAddress=node.getThisAddress();
  final Semaphore s=new Semaphore(0);
  final AtomicBoolean ok=new AtomicBoolean(true);
  final Callback<Object> callback=new Callback<Object>(){
    @Override public void notify(    Object object){
      if (Boolean.FALSE.equals(object)) {
        ok.compareAndSet(true,false);
      }
 else       if (object instanceof Throwable) {
        ok.compareAndSet(true,false);
      }
      s.release();
    }
  }
;
  int notOwnedCount=syncReplicaVersion(thisAddress,s,ok,callback);
  s.release(notOwnedCount);
  try {
    if (ok.get()) {
      return s.tryAcquire(partitionCount,DEFAULT_SLEEP_MILLIS,TimeUnit.SECONDS) && ok.get();
    }
 else {
      return false;
    }
  }
 catch (  InterruptedException ignored) {
    return false;
  }
}","private boolean checkReplicaSyncState(){
  if (!initialized) {
    return true;
  }
  if (getMemberGroupsSize() < 2) {
    return true;
  }
  final Address thisAddress=node.getThisAddress();
  final Semaphore s=new Semaphore(0);
  final AtomicBoolean ok=new AtomicBoolean(true);
  final Callback<Object> callback=new Callback<Object>(){
    @Override public void notify(    Object object){
      if (Boolean.FALSE.equals(object)) {
        ok.compareAndSet(true,false);
      }
 else       if (object instanceof Throwable) {
        ok.compareAndSet(true,false);
      }
      s.release();
    }
  }
;
  int notOwnedCount=syncReplicaVersion(thisAddress,s,ok,callback);
  s.release(notOwnedCount);
  try {
    if (ok.get()) {
      return s.tryAcquire(partitionCount,DEFAULT_SLEEP_MILLIS,TimeUnit.SECONDS) && ok.get();
    }
 else {
      return false;
    }
  }
 catch (  InterruptedException ignored) {
    return false;
  }
}",0.9903846153846154
48099,"@Override public boolean prepareToSafeShutdown(long timeout,TimeUnit unit){
  long timeoutInMillis=unit.toMillis(timeout);
  int sleep=DEFAULT_PAUSE_MILLIS;
  while (timeoutInMillis > 0) {
    while (timeoutInMillis > 0 && shouldWaitMigrationOrBackups(Level.INFO)) {
      timeoutInMillis=sleepWithBusyWait(timeoutInMillis,sleep);
    }
    if (timeoutInMillis <= 0) {
      return false;
    }
    if (node.isMaster()) {
      syncPartitionRuntimeState();
    }
 else {
      timeoutInMillis=waitForOngoingMigrations(timeoutInMillis,sleep);
      if (timeoutInMillis <= 0) {
        return false;
      }
    }
    long start=Clock.currentTimeMillis();
    boolean ok=checkReplicaSyncState();
    timeoutInMillis-=(Clock.currentTimeMillis() - start);
    if (ok) {
      logger.finest(""String_Node_Str"");
      return true;
    }
 else {
      if (timeoutInMillis <= 0) {
        return false;
      }
      logger.info(""String_Node_Str"" + timeoutInMillis + ""String_Node_Str"");
      timeoutInMillis=sleepWithBusyWait(timeoutInMillis,sleep);
    }
  }
  return false;
}","@Override public boolean prepareToSafeShutdown(long timeout,TimeUnit unit){
  long timeoutInMillis=unit.toMillis(timeout);
  int sleep=DEFAULT_PAUSE_MILLIS;
  while (timeoutInMillis > 0) {
    while (timeoutInMillis > 0 && shouldWaitMigrationOrBackups(Level.INFO)) {
      timeoutInMillis=sleepWithBusyWait(timeoutInMillis,sleep);
    }
    if (timeoutInMillis <= 0) {
      break;
    }
    if (node.isMaster()) {
      syncPartitionRuntimeState();
    }
 else {
      timeoutInMillis=waitForOngoingMigrations(timeoutInMillis,sleep);
      if (timeoutInMillis <= 0) {
        break;
      }
    }
    long start=Clock.currentTimeMillis();
    boolean ok=checkReplicaSyncState();
    timeoutInMillis-=(Clock.currentTimeMillis() - start);
    if (ok) {
      logger.finest(""String_Node_Str"");
      return true;
    }
 else {
      if (timeoutInMillis <= 0) {
        break;
      }
      logger.info(""String_Node_Str"" + timeoutInMillis + ""String_Node_Str"");
      timeoutInMillis=sleepWithBusyWait(timeoutInMillis,sleep);
    }
  }
  return false;
}",0.975932043416706
48100,"public int backup() throws Exception {
  int requestedSyncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? min(InternalPartition.MAX_BACKUP_COUNT,backupAwareOp.getSyncBackupCount()) : 0;
  int requestedAsyncBackupCount=backupAwareOp.getAsyncBackupCount() > 0 ? min(InternalPartition.MAX_BACKUP_COUNT - requestedSyncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  int totalRequestedBackupCount=requestedSyncBackupCount + requestedAsyncBackupCount;
  if (totalRequestedBackupCount == 0) {
    return 0;
  }
  long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(partitionId,totalRequestedBackupCount);
  int maxPossibleBackupCount=min(partitionService.getMemberGroupsSize() - 1,InternalPartition.MAX_BACKUP_COUNT);
  int syncBackupCount=min(maxPossibleBackupCount,requestedSyncBackupCount);
  int asyncBackupCount=min(maxPossibleBackupCount - syncBackupCount,requestedAsyncBackupCount);
  if (!op.returnsResponse()) {
    asyncBackupCount+=syncBackupCount;
    syncBackupCount=0;
  }
  int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount == 0) {
    return 0;
  }
  return makeBackups(replicaVersions,syncBackupCount,totalBackupCount);
}","public int backup(BackupAwareOperation backupAwareOp) throws Exception {
  int requestedSyncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? min(InternalPartition.MAX_BACKUP_COUNT,backupAwareOp.getSyncBackupCount()) : 0;
  int requestedAsyncBackupCount=backupAwareOp.getAsyncBackupCount() > 0 ? min(InternalPartition.MAX_BACKUP_COUNT - requestedSyncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  int totalRequestedBackupCount=requestedSyncBackupCount + requestedAsyncBackupCount;
  if (totalRequestedBackupCount == 0) {
    return 0;
  }
  Operation op=(Operation)backupAwareOp;
  InternalPartitionService partitionService=node.getPartitionService();
  long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(op.getPartitionId(),totalRequestedBackupCount);
  int maxPossibleBackupCount=min(partitionService.getMemberGroupsSize() - 1,InternalPartition.MAX_BACKUP_COUNT);
  int syncBackupCount=min(maxPossibleBackupCount,requestedSyncBackupCount);
  int asyncBackupCount=min(maxPossibleBackupCount - syncBackupCount,requestedAsyncBackupCount);
  int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount == 0) {
    return 0;
  }
  if (!op.returnsResponse()) {
    syncBackupCount=0;
  }
  return makeBackups(backupAwareOp,op.getPartitionId(),replicaVersions,syncBackupCount,totalBackupCount);
}",0.8119590873328089
48101,"private Operation initBackupOperation(int replicaIndex){
  Operation backupOp=backupAwareOp.getBackupOperation();
  if (backupOp == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);
  return backupOp;
}","private Operation initBackupOperation(BackupAwareOperation backupAwareOp,int replicaIndex){
  Operation backupOp=backupAwareOp.getBackupOperation();
  if (backupOp == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Operation op=(Operation)backupAwareOp;
  backupOp.setPartitionId(op.getPartitionId()).setReplicaIndex(replicaIndex).setServiceName(op.getServiceName());
  return backupOp;
}",0.8419618528610354
48102,"private int makeBackups(long[] replicaVersions,int syncBackupCount,int totalBackupCount){
  int sentSyncBackupCount=0;
  InternalPartition partition=partitionService.getPartition(partitionId);
  for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
    Address target=partition.getReplicaAddress(replicaIndex);
    if (target == null) {
      continue;
    }
    assertNoBackupOnPrimaryMember(partition,target);
    boolean isSyncBackup=replicaIndex <= syncBackupCount;
    makeBackup(replicaVersions,replicaIndex,target,isSyncBackup);
    if (isSyncBackup) {
      sentSyncBackupCount++;
    }
  }
  return sentSyncBackupCount;
}","private int makeBackups(BackupAwareOperation backupAwareOp,int partitionId,long[] replicaVersions,int syncBackupCount,int totalBackupCount){
  int sentSyncBackupCount=0;
  InternalPartitionService partitionService=node.getPartitionService();
  InternalPartition partition=partitionService.getPartition(partitionId);
  for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
    Address target=partition.getReplicaAddress(replicaIndex);
    if (target == null) {
      continue;
    }
    assertNoBackupOnPrimaryMember(partition,target);
    boolean isSyncBackup=replicaIndex <= syncBackupCount;
    Backup backup=newBackup(backupAwareOp,replicaVersions,replicaIndex,isSyncBackup);
    send(backup,target);
    if (isSyncBackup) {
      sentSyncBackupCount++;
    }
  }
  return sentSyncBackupCount;
}",0.8534599728629579
48103,"/** 
 * Verfies that the backup of a partition doesn't end up at the member that also has the primary.
 */
private void assertNoBackupOnPrimaryMember(InternalPartition partition,Address target){
  if (target.equals(node.getThisAddress())) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + partition);
  }
}","/** 
 * Verifies that the backup of a partition doesn't end up at the member that also has the primary.
 */
private void assertNoBackupOnPrimaryMember(InternalPartition partition,Address target){
  if (target.equals(node.getThisAddress())) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + partition);
  }
}",0.9985052316890882
48104,"BasicOperationService(NodeEngineImpl nodeEngine){
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class);
  this.defaultCallTimeout=node.getGroupProperties().OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  this.executionService=nodeEngine.getExecutionService();
  int coreSize=Runtime.getRuntime().availableProcessors();
  boolean reallyMultiCore=coreSize >= CORE_SIZE_CHECK;
  int concurrencyLevel=reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;
  this.executingCalls=new ConcurrentHashMap<RemoteCallKey,RemoteCallKey>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.invocations=new ConcurrentHashMap<Long,BasicInvocation>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.scheduler=new BasicOperationScheduler(node,executionService,new BasicDispatcherImpl());
  this.operationHandler=new OperationHandler();
  this.operationPacketHandler=new OperationPacketHandler();
  this.responsePacketHandler=new ResponsePacketHandler();
}","BasicOperationService(NodeEngineImpl nodeEngine){
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class);
  this.defaultCallTimeout=node.getGroupProperties().OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  this.executionService=nodeEngine.getExecutionService();
  int coreSize=Runtime.getRuntime().availableProcessors();
  boolean reallyMultiCore=coreSize >= CORE_SIZE_CHECK;
  int concurrencyLevel=reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;
  this.executingCalls=new ConcurrentHashMap<RemoteCallKey,RemoteCallKey>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.invocations=new ConcurrentHashMap<Long,BasicInvocation>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.scheduler=new BasicOperationScheduler(node,executionService,new BasicDispatcherImpl());
  this.operationHandler=new OperationHandler();
  this.operationBackupHandler=new OperationBackupHandler();
  this.operationPacketHandler=new OperationPacketHandler();
  this.responsePacketHandler=new ResponsePacketHandler();
}",0.97134670487106
48105,"private Backup newBackup(long[] replicaVersions,int replicaIndex,boolean isSyncBackup){
  Operation backupOp=initBackupOperation(replicaIndex);
  Data backupOpData=nodeEngine.getSerializationService().toData(backupOp);
  Backup backup=new Backup(backupOpData,op.getCallerAddress(),replicaVersions,isSyncBackup);
  backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName).setCallerUuid(nodeEngine.getLocalMember().getUuid());
  setCallId(backup,op.getCallId());
  return backup;
}","private Backup newBackup(BackupAwareOperation backupAwareOp,long[] replicaVersions,int replicaIndex,boolean isSyncBackup){
  Operation op=(Operation)backupAwareOp;
  Operation backupOp=initBackupOperation(backupAwareOp,replicaIndex);
  Data backupOpData=nodeEngine.getSerializationService().toData(backupOp);
  Backup backup=new Backup(backupOpData,op.getCallerAddress(),replicaVersions,isSyncBackup);
  backup.setPartitionId(op.getPartitionId()).setReplicaIndex(replicaIndex).setServiceName(op.getServiceName()).setCallerUuid(nodeEngine.getLocalMember().getUuid());
  setCallId(backup,op.getCallId());
  return backup;
}",0.8380281690140845
48106,"private void handleResponse(Operation op) throws Exception {
  boolean returnsResponse=op.returnsResponse();
  Object response=null;
  if (op instanceof BackupAwareOperation) {
    BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
    int syncBackupCount=0;
    if (backupAwareOp.shouldBackup()) {
      syncBackupCount=new OperationBackupHandler(backupAwareOp).backup();
    }
    if (returnsResponse) {
      response=new NormalResponse(op.getResponse(),op.getCallId(),syncBackupCount,op.isUrgent());
    }
  }
  if (returnsResponse) {
    if (response == null) {
      response=op.getResponse();
    }
    ResponseHandler responseHandler=op.getResponseHandler();
    if (responseHandler == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    responseHandler.sendResponse(response);
  }
}","private void handleResponse(Operation op) throws Exception {
  boolean returnsResponse=op.returnsResponse();
  Object response=null;
  if (op instanceof BackupAwareOperation) {
    BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
    int syncBackupCount=0;
    if (backupAwareOp.shouldBackup()) {
      syncBackupCount=operationBackupHandler.backup(backupAwareOp);
    }
    if (returnsResponse) {
      response=new NormalResponse(op.getResponse(),op.getCallId(),syncBackupCount,op.isUrgent());
    }
  }
  if (returnsResponse) {
    if (response == null) {
      response=op.getResponse();
    }
    ResponseHandler responseHandler=op.getResponseHandler();
    if (responseHandler == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    responseHandler.sendResponse(response);
  }
}",0.9793187347931872
48107,"@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=200000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}","@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}",0.9725144214455378
48108,"@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=200000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}","@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}",0.9774184555338724
48109,"private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    final CountDownLatch latch=new CountDownLatch(1);
    instances[ix].getLifecycleService().addLifecycleListener(new LifecycleListener(){
      @Override public void stateChanged(      LifecycleEvent event){
        if (event.getState().equals(LifecycleEvent.LifecycleState.SHUTDOWN)) {
          latch.countDown();
        }
      }
    }
);
    latch.await(5,TimeUnit.SECONDS);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}","private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}",0.813953488372093
48110,"@Test public void testGracefulShutdown() throws Exception {
  int size=250000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}","@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}",0.9516819571865444
48111,"/** 
 * Test for the issue https://code.google.com/p/hazelcast/issues/detail?id=395.
 */
@Test public void testBackupMigrationAndRecovery2() throws Exception {
  testBackupMigrationAndRecovery(6,2,50000);
}","/** 
 * Test for the issue https://code.google.com/p/hazelcast/issues/detail?id=395.
 */
@Test public void testBackupMigrationAndRecovery2() throws Exception {
  testBackupMigrationAndRecovery(6,2,5000);
}",0.9975669099756692
48112,"public void shutdown(final boolean terminate){
  long start=Clock.currentTimeMillis();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + String.valueOf(active));
  }
  if (!terminate && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    if (!partitionService.prepareToSafeShutdown(maxWaitSeconds,TimeUnit.SECONDS)) {
      logger.warning(""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    if (!terminate) {
      clusterService.sendShutdownMessage();
    }
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    versionCheck.shutdown();
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.finest(""String_Node_Str"");
    nodeEngine.shutdown(terminate);
    if (multicastService != null) {
      logger.finest(""String_Node_Str"");
      multicastService.stop();
    }
    logger.finest(""String_Node_Str"");
    connectionManager.shutdown();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    serializationService.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      if (thread.isAlive()) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + thread.getName());
        }
        thread.interrupt();
      }
    }
    failedConnections.clear();
    systemLogService.shutdown();
    logger.info(""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}","public void shutdown(final boolean terminate){
  long start=Clock.currentTimeMillis();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + String.valueOf(active));
  }
  if (!terminate && isActive() && joined()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    if (!partitionService.prepareToSafeShutdown(maxWaitSeconds,TimeUnit.SECONDS)) {
      logger.warning(""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    if (!terminate) {
      clusterService.sendShutdownMessage();
    }
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    versionCheck.shutdown();
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.finest(""String_Node_Str"");
    nodeEngine.shutdown(terminate);
    if (multicastService != null) {
      logger.finest(""String_Node_Str"");
      multicastService.stop();
    }
    logger.finest(""String_Node_Str"");
    connectionManager.shutdown();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    serializationService.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      if (thread.isAlive()) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + thread.getName());
        }
        thread.interrupt();
      }
    }
    failedConnections.clear();
    systemLogService.shutdown();
    logger.info(""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}",0.9968635650810246
48113,"private boolean checkReplicaSyncState(){
  if (!initialized || !node.joined()) {
    return true;
  }
  if (getMemberGroupsSize() < 2) {
    return true;
  }
  final Address thisAddress=node.getThisAddress();
  final Semaphore s=new Semaphore(0);
  final AtomicBoolean ok=new AtomicBoolean(true);
  final Callback<Object> callback=new Callback<Object>(){
    @Override public void notify(    Object object){
      if (Boolean.FALSE.equals(object)) {
        ok.compareAndSet(true,false);
      }
 else       if (object instanceof Throwable) {
        ok.compareAndSet(true,false);
      }
      s.release();
    }
  }
;
  int notOwnedCount=0;
  for (  InternalPartitionImpl partition : partitions) {
    Address owner=partition.getOwner();
    if (thisAddress.equals(owner)) {
      if (partition.getReplicaAddress(1) != null) {
        SyncReplicaVersion op=new SyncReplicaVersion(1,callback);
        op.setService(this);
        op.setNodeEngine(nodeEngine);
        op.setResponseHandler(ResponseHandlerFactory.createErrorLoggingResponseHandler(node.getLogger(SyncReplicaVersion.class)));
        op.setPartitionId(partition.getPartitionId());
        nodeEngine.getOperationService().executeOperation(op);
      }
 else {
        ok.set(false);
        s.release();
      }
    }
 else {
      if (owner == null) {
        ok.set(false);
      }
      notOwnedCount++;
    }
  }
  s.release(notOwnedCount);
  try {
    if (ok.get()) {
      return s.tryAcquire(partitionCount,10,TimeUnit.SECONDS) && ok.get();
    }
 else {
      return false;
    }
  }
 catch (  InterruptedException ignored) {
    return false;
  }
}","private boolean checkReplicaSyncState(){
  if (!initialized) {
    return true;
  }
  if (getMemberGroupsSize() < 2) {
    return true;
  }
  final Address thisAddress=node.getThisAddress();
  final Semaphore s=new Semaphore(0);
  final AtomicBoolean ok=new AtomicBoolean(true);
  final Callback<Object> callback=new Callback<Object>(){
    @Override public void notify(    Object object){
      if (Boolean.FALSE.equals(object)) {
        ok.compareAndSet(true,false);
      }
 else       if (object instanceof Throwable) {
        ok.compareAndSet(true,false);
      }
      s.release();
    }
  }
;
  int notOwnedCount=0;
  for (  InternalPartitionImpl partition : partitions) {
    Address owner=partition.getOwner();
    if (thisAddress.equals(owner)) {
      if (partition.getReplicaAddress(1) != null) {
        SyncReplicaVersion op=new SyncReplicaVersion(1,callback);
        op.setService(this);
        op.setNodeEngine(nodeEngine);
        op.setResponseHandler(ResponseHandlerFactory.createErrorLoggingResponseHandler(node.getLogger(SyncReplicaVersion.class)));
        op.setPartitionId(partition.getPartitionId());
        nodeEngine.getOperationService().executeOperation(op);
      }
 else {
        ok.set(false);
        s.release();
      }
    }
 else {
      if (owner == null) {
        ok.set(false);
      }
      notOwnedCount++;
    }
  }
  s.release(notOwnedCount);
  try {
    if (ok.get()) {
      return s.tryAcquire(partitionCount,10,TimeUnit.SECONDS) && ok.get();
    }
 else {
      return false;
    }
  }
 catch (  InterruptedException ignored) {
    return false;
  }
}",0.9944272445820432
48114,"void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"" + node.isActive() + ""String_Node_Str""+ node.joined()+ ""String_Node_Str"");
      }
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.warning(""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.severe(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.warning(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    final Set<Address> unknownAddresses=new HashSet<Address>();
    PartitionInfo[] state=partitionState.getPartitions();
    for (int partitionId=0; partitionId < state.length; partitionId++) {
      PartitionInfo partitionInfo=state[partitionId];
      InternalPartitionImpl currentPartition=partitions[partitionId];
      for (int index=0; index < InternalPartition.MAX_REPLICA_COUNT; index++) {
        Address address=partitionInfo.getReplicaAddress(index);
        if (address != null && getMember(address) == null) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + address + ""String_Node_Str""+ sender+ ""String_Node_Str""+ partitionId);
          }
          unknownAddresses.add(address);
        }
      }
      currentPartition.setOwner(partitionInfo.getReplicaAddress(0));
    }
    if (!unknownAddresses.isEmpty() && logger.isLoggable(Level.WARNING)) {
      StringBuilder s=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(sender).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
      for (      Address address : unknownAddresses) {
        s.append(""String_Node_Str"").append(address);
      }
      s.append(""String_Node_Str"");
      logger.warning(s.toString());
    }
    Collection<MigrationInfo> completedMigrations=partitionState.getCompletedMigrations();
    for (    MigrationInfo completedMigration : completedMigrations) {
      addCompletedMigration(completedMigration);
      finalizeActiveMigration(completedMigration);
    }
    if (!activeMigrations.isEmpty()) {
      final MemberImpl masterMember=getMasterMember();
      rollbackActiveMigrationsFromPreviousMaster(masterMember.getUuid());
    }
    for (int partitionId=0; partitionId < partitionCount; partitionId++) {
      InternalPartitionImpl partition=partitions[partitionId];
      Address[] replicas=state[partitionId].getReplicaAddresses();
      partition.setPartitionInfo(replicas);
    }
    stateVersion.set(partitionState.getVersion());
    initialized=true;
  }
  finally {
    lock.unlock();
  }
}","void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"" + node.isActive() + ""String_Node_Str""+ node.joined()+ ""String_Node_Str"");
      }
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.warning(""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.severe(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.warning(""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    final Set<Address> unknownAddresses=new HashSet<Address>();
    PartitionInfo[] state=partitionState.getPartitions();
    for (int partitionId=0; partitionId < state.length; partitionId++) {
      PartitionInfo partitionInfo=state[partitionId];
      InternalPartitionImpl currentPartition=partitions[partitionId];
      for (int index=0; index < InternalPartition.MAX_REPLICA_COUNT; index++) {
        Address address=partitionInfo.getReplicaAddress(index);
        if (address != null && getMember(address) == null) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + address + ""String_Node_Str""+ sender+ ""String_Node_Str""+ partitionId);
          }
          unknownAddresses.add(address);
        }
      }
      currentPartition.setOwner(partitionInfo.getReplicaAddress(0));
    }
    if (!unknownAddresses.isEmpty() && logger.isLoggable(Level.WARNING)) {
      StringBuilder s=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(sender).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
      for (      Address address : unknownAddresses) {
        s.append(""String_Node_Str"").append(address);
      }
      s.append(""String_Node_Str"");
      logger.warning(s.toString());
    }
    stateVersion.set(partitionState.getVersion());
    initialized=true;
    Collection<MigrationInfo> completedMigrations=partitionState.getCompletedMigrations();
    for (    MigrationInfo completedMigration : completedMigrations) {
      addCompletedMigration(completedMigration);
      finalizeActiveMigration(completedMigration);
    }
    if (!activeMigrations.isEmpty()) {
      final MemberImpl masterMember=getMasterMember();
      rollbackActiveMigrationsFromPreviousMaster(masterMember.getUuid());
    }
    for (int partitionId=0; partitionId < partitionCount; partitionId++) {
      InternalPartitionImpl partition=partitions[partitionId];
      Address[] replicas=state[partitionId].getReplicaAddresses();
      partition.setPartitionInfo(replicas);
    }
  }
  finally {
    lock.unlock();
  }
}",0.9762369791666666
48115,"@Override public boolean prepareToSafeShutdown(long timeout,TimeUnit unit){
  long timeoutInMillis=unit.toMillis(timeout);
  int sleep=1000;
  while (timeoutInMillis > 0) {
    while (timeoutInMillis > 0 && shouldWaitMigrationOrBackups(Level.INFO)) {
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
    if (timeoutInMillis <= 0) {
      return false;
    }
    if (node.isMaster()) {
      syncPartitionRuntimeState();
    }
 else {
      while (timeoutInMillis > 0 && hasOnGoingMigrationMaster(Level.WARNING)) {
        logger.info(""String_Node_Str"");
        try {
          Thread.sleep(sleep);
        }
 catch (        InterruptedException ignored) {
        }
        timeoutInMillis-=sleep;
      }
      if (timeoutInMillis <= 0) {
        return false;
      }
    }
    long start=Clock.currentTimeMillis();
    boolean ok=checkReplicaSyncState();
    timeoutInMillis-=(Clock.currentTimeMillis() - start);
    if (ok) {
      logger.finest(""String_Node_Str"");
      return true;
    }
 else {
      if (timeoutInMillis <= 0) {
        return false;
      }
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + timeoutInMillis + ""String_Node_Str"");
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
  }
  return false;
}","@Override public boolean prepareToSafeShutdown(long timeout,TimeUnit unit){
  long timeoutInMillis=unit.toMillis(timeout);
  int sleep=1000;
  while (timeoutInMillis > 0) {
    while (timeoutInMillis > 0 && shouldWaitMigrationOrBackups(Level.INFO)) {
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
    if (timeoutInMillis <= 0) {
      break;
    }
    if (node.isMaster()) {
      syncPartitionRuntimeState();
    }
 else {
      while (timeoutInMillis > 0 && hasOnGoingMigrationMaster(Level.WARNING)) {
        logger.info(""String_Node_Str"");
        try {
          Thread.sleep(sleep);
        }
 catch (        InterruptedException ignored) {
        }
        timeoutInMillis-=sleep;
      }
      if (timeoutInMillis <= 0) {
        break;
      }
    }
    long start=Clock.currentTimeMillis();
    boolean ok=checkReplicaSyncState();
    timeoutInMillis-=(Clock.currentTimeMillis() - start);
    if (ok) {
      logger.finest(""String_Node_Str"");
      return true;
    }
 else {
      if (timeoutInMillis <= 0) {
        break;
      }
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + timeoutInMillis + ""String_Node_Str"");
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
  }
  return false;
}",0.9818311364446028
48116,"@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=200000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}","@Test public void testGracefulShutdown2() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(2);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz.shutdown();
  hz2.shutdown();
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz3.shutdown();
  hz4.shutdown();
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
}",0.9725144214455378
48117,"@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=200000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}","@Test public void testGracefulShutdown3() throws Exception {
  Config config=new Config();
  config.getMapConfig(MAP_NAME).setBackupCount(1);
  TestHazelcastInstanceFactory f=createHazelcastInstanceFactory(6);
  final HazelcastInstance hz=f.newHazelcastInstance(config);
  final IMap<Object,Object> map=hz.getMap(MAP_NAME);
  final int size=50000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final HazelcastInstance hz2=f.newHazelcastInstance(config);
  final IMap<Object,Object> map2=hz2.getMap(MAP_NAME);
  final HazelcastInstance hz3=f.newHazelcastInstance(config);
  final IMap<Object,Object> map3=hz3.getMap(MAP_NAME);
  final HazelcastInstance hz4=f.newHazelcastInstance(config);
  final IMap<Object,Object> map4=hz4.getMap(MAP_NAME);
  final HazelcastInstance hz5=f.newHazelcastInstance(config);
  final IMap<Object,Object> map5=hz5.getMap(MAP_NAME);
  final HazelcastInstance hz6=f.newHazelcastInstance(config);
  final IMap<Object,Object> map6=hz6.getMap(MAP_NAME);
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  assertEquals(size,map6.size());
  hz6.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz2.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  assertEquals(size,map5.size());
  hz5.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map3.size());
  assertEquals(size,map4.size());
  hz3.shutdown();
  assertEquals(size,map.size());
  assertEquals(size,map4.size());
  hz4.shutdown();
  assertEquals(size,map.size());
}",0.9774184555338724
48118,"private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    final CountDownLatch latch=new CountDownLatch(1);
    instances[ix].getLifecycleService().addLifecycleListener(new LifecycleListener(){
      @Override public void stateChanged(      LifecycleEvent event){
        if (event.getState().equals(LifecycleEvent.LifecycleState.SHUTDOWN)) {
          latch.countDown();
        }
      }
    }
);
    latch.await(5,TimeUnit.SECONDS);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}","private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}",0.813953488372093
48119,"@Test public void testGracefulShutdown() throws Exception {
  int size=250000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}","@Test public void testGracefulShutdown() throws Exception {
  int size=50000;
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final Config config=new Config();
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap m1=h1.getMap(MAP_NAME);
  for (int i=0; i < size; i++) {
    m1.put(i,i);
  }
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap m2=h2.getMap(MAP_NAME);
  h1.shutdown();
  assertEquals(size,m2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap m3=h3.getMap(MAP_NAME);
  h2.shutdown();
  assertEquals(size,m3.size());
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(config);
  IMap m4=h4.getMap(MAP_NAME);
  h3.shutdown();
  assertEquals(size,m4.size());
}",0.9516819571865444
48120,"/** 
 * Test for the issue https://code.google.com/p/hazelcast/issues/detail?id=395.
 */
@Test public void testBackupMigrationAndRecovery2() throws Exception {
  testBackupMigrationAndRecovery(6,2,50000);
}","/** 
 * Test for the issue https://code.google.com/p/hazelcast/issues/detail?id=395.
 */
@Test public void testBackupMigrationAndRecovery2() throws Exception {
  testBackupMigrationAndRecovery(6,2,5000);
}",0.9975669099756692
48121,"private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
      final boolean portIsDefined=addressHolder.port != -1 || !networkConfig.isPortAutoIncrement();
      final int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,null,InetAddress.getByName(matchedAddress),port,count);
        }
      }
 else {
        final String host=addressHolder.address;
        final InterfacesConfig interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.warning(e);
    }
  }
  return possibleAddresses;
}","private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
    try {
      boolean portIsDefined=addressHolder.port != -1 || !networkConfig.isPortAutoIncrement();
      int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      int port=addressHolder.port != -1 ? addressHolder.port : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,null,InetAddress.getByName(matchedAddress),port,count);
        }
      }
 else {
        final String host=addressHolder.address;
        final InterfacesConfig interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.warning(""String_Node_Str"" + addressHolder.address + ""String_Node_Str"");
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"",e);
      }
    }
  }
  return possibleAddresses;
}",0.959563283461383
48122,"private void addPossibleAddresses(final Set<Address> possibleAddresses,final String host,final InetAddress inetAddress,final int port,final int count) throws UnknownHostException {
  for (int i=0; i < count; i++) {
    final int currentPort=port + i;
    final Address address=host != null ? new Address(host,currentPort) : new Address(inetAddress,currentPort);
    if (!isLocalAddress(address)) {
      possibleAddresses.add(address);
    }
  }
}","private void addPossibleAddresses(final Set<Address> possibleAddresses,final String host,final InetAddress inetAddress,final int port,final int count) throws UnknownHostException {
  for (int i=0; i < count; i++) {
    int currentPort=port + i;
    Address address=host != null ? new Address(host,currentPort) : new Address(inetAddress,currentPort);
    if (!isLocalAddress(address)) {
      possibleAddresses.add(address);
    }
  }
}",0.9863945578231292
48123,"private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Map<String,String> addressDomainMap;
  final TcpIpConfig tcpIpConfig=networkConfig.getJoin().getTcpIpConfig();
  if (tcpIpConfig.isEnabled()) {
    addressDomainMap=new LinkedHashMap<String,String>();
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).address;
      if (AddressUtil.isIpAddress(s)) {
        if (!addressDomainMap.containsKey(s)) {
          addressDomainMap.put(s,null);
        }
      }
 else {
        try {
          final Collection<String> addresses=resolveDomainNames(s);
          for (          String address : addresses) {
            addressDomainMap.put(address,s);
          }
        }
 catch (        UnknownHostException e) {
          logger.severe(""String_Node_Str"" + s);
        }
      }
    }
  }
 else {
    addressDomainMap=Collections.emptyMap();
  }
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        String hostname=findHostnameMatchingInterface(addressDomainMap,configInterface);
        interfaces.add(new InterfaceDefinition(hostname,configInterface));
      }
 else {
        logger.info(""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (tcpIpConfig.isEnabled()) {
    for (    Entry<String,String> entry : addressDomainMap.entrySet()) {
      interfaces.add(new InterfaceDefinition(entry.getValue(),entry.getKey()));
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}","private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Map<String,String> addressDomainMap;
  final TcpIpConfig tcpIpConfig=networkConfig.getJoin().getTcpIpConfig();
  if (tcpIpConfig.isEnabled()) {
    addressDomainMap=new LinkedHashMap<String,String>();
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).address;
      if (AddressUtil.isIpAddress(s)) {
        if (!addressDomainMap.containsKey(s)) {
          addressDomainMap.put(s,null);
        }
      }
 else {
        try {
          final Collection<String> addresses=resolveDomainNames(s);
          for (          String address : addresses) {
            addressDomainMap.put(address,s);
          }
        }
 catch (        UnknownHostException e) {
          logger.warning(""String_Node_Str"" + s + ""String_Node_Str"");
        }
      }
    }
  }
 else {
    addressDomainMap=Collections.emptyMap();
  }
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        String hostname=findHostnameMatchingInterface(addressDomainMap,configInterface);
        interfaces.add(new InterfaceDefinition(hostname,configInterface));
      }
 else {
        logger.info(""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (tcpIpConfig.isEnabled()) {
    for (    Entry<String,String> entry : addressDomainMap.entrySet()) {
      interfaces.add(new InterfaceDefinition(entry.getValue(),entry.getKey()));
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}",0.9921071513991868
48124,"private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
      final boolean portIsDefined=addressHolder.getPort() != -1 || !networkConfig.isPortAutoIncrement();
      final int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      final int port=addressHolder.getPort() != -1 ? addressHolder.getPort() : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.getAddress());
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.getAddress());
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,null,InetAddress.getByName(matchedAddress),port,count);
        }
      }
 else {
        final String host=addressHolder.getAddress();
        final InterfacesConfig interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.warning(e);
    }
  }
  return possibleAddresses;
}","private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
    try {
      boolean portIsDefined=addressHolder.getPort() != -1 || !networkConfig.isPortAutoIncrement();
      int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      int port=addressHolder.getPort() != -1 ? addressHolder.getPort() : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.getAddress());
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.getAddress());
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,null,InetAddress.getByName(matchedAddress),port,count);
        }
      }
 else {
        final String host=addressHolder.getAddress();
        final InterfacesConfig interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.warning(""String_Node_Str"" + addressHolder.getAddress() + ""String_Node_Str"");
      if (logger.isFinestEnabled()) {
        logger.finest(""String_Node_Str"",e);
      }
    }
  }
  return possibleAddresses;
}",0.9590900019956096
48125,"private void addPossibleAddresses(final Set<Address> possibleAddresses,final String host,final InetAddress inetAddress,final int port,final int count) throws UnknownHostException {
  for (int i=0; i < count; i++) {
    final int currentPort=port + i;
    final Address address=host != null ? new Address(host,currentPort) : new Address(inetAddress,currentPort);
    if (!isLocalAddress(address)) {
      possibleAddresses.add(address);
    }
  }
}","private void addPossibleAddresses(final Set<Address> possibleAddresses,final String host,final InetAddress inetAddress,final int port,final int count) throws UnknownHostException {
  for (int i=0; i < count; i++) {
    int currentPort=port + i;
    Address address=host != null ? new Address(host,currentPort) : new Address(inetAddress,currentPort);
    if (!isLocalAddress(address)) {
      possibleAddresses.add(address);
    }
  }
}",0.9863945578231292
48126,"private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Map<String,String> addressDomainMap;
  final TcpIpConfig tcpIpConfig=networkConfig.getJoin().getTcpIpConfig();
  if (tcpIpConfig.isEnabled()) {
    addressDomainMap=new LinkedHashMap<String,String>();
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).getAddress();
      if (AddressUtil.isIpAddress(s)) {
        if (!addressDomainMap.containsKey(s)) {
          addressDomainMap.put(s,null);
        }
      }
 else {
        try {
          final Collection<String> addresses=resolveDomainNames(s);
          for (          String address : addresses) {
            addressDomainMap.put(address,s);
          }
        }
 catch (        UnknownHostException e) {
          logger.severe(""String_Node_Str"" + s);
        }
      }
    }
  }
 else {
    addressDomainMap=Collections.emptyMap();
  }
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        String hostname=findHostnameMatchingInterface(addressDomainMap,configInterface);
        interfaces.add(new InterfaceDefinition(hostname,configInterface));
      }
 else {
        logger.info(""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (tcpIpConfig.isEnabled()) {
    for (    Entry<String,String> entry : addressDomainMap.entrySet()) {
      interfaces.add(new InterfaceDefinition(entry.getValue(),entry.getKey()));
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}","private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Map<String,String> addressDomainMap;
  final TcpIpConfig tcpIpConfig=networkConfig.getJoin().getTcpIpConfig();
  if (tcpIpConfig.isEnabled()) {
    addressDomainMap=new LinkedHashMap<String,String>();
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).getAddress();
      if (AddressUtil.isIpAddress(s)) {
        if (!addressDomainMap.containsKey(s)) {
          addressDomainMap.put(s,null);
        }
      }
 else {
        try {
          final Collection<String> addresses=resolveDomainNames(s);
          for (          String address : addresses) {
            addressDomainMap.put(address,s);
          }
        }
 catch (        UnknownHostException e) {
          logger.warning(""String_Node_Str"" + s + ""String_Node_Str"");
        }
      }
    }
  }
 else {
    addressDomainMap=Collections.emptyMap();
  }
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        String hostname=findHostnameMatchingInterface(addressDomainMap,configInterface);
        interfaces.add(new InterfaceDefinition(hostname,configInterface));
      }
 else {
        logger.info(""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (tcpIpConfig.isEnabled()) {
    for (    Entry<String,String> entry : addressDomainMap.entrySet()) {
      interfaces.add(new InterfaceDefinition(entry.getValue(),entry.getKey()));
    }
    log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}",0.9921259842519684
48127,"@Override public void init(final NodeEngine nodeEngine,Properties properties){
  final int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  final PartitionContainer[] partitionContainers=mapServiceContext.getPartitionContainers();
  for (int i=0; i < partitionCount; i++) {
    partitionContainers[i]=new PartitionContainer(mapServiceContext.getService(),i);
  }
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.registerLockStoreConstructor(mapServiceContext.serviceName(),new ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
      public LockStoreInfo createNew(      final ObjectNamespace key){
        final MapContainer mapContainer=mapServiceContext.getMapContainer(key.getObjectName());
        return new LockStoreInfo(){
          public int getBackupCount(){
            return mapContainer.getBackupCount();
          }
          public int getAsyncBackupCount(){
            return mapContainer.getAsyncBackupCount();
          }
        }
;
      }
    }
);
  }
  mapServiceContext.getExpirationManager().start();
}","@Override public void init(final NodeEngine nodeEngine,Properties properties){
  mapServiceContext.initPartitionsContainers();
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.registerLockStoreConstructor(mapServiceContext.serviceName(),new ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
      public LockStoreInfo createNew(      final ObjectNamespace key){
        final MapContainer mapContainer=mapServiceContext.getMapContainer(key.getObjectName());
        return new LockStoreInfo(){
          public int getBackupCount(){
            return mapContainer.getBackupCount();
          }
          public int getAsyncBackupCount(){
            return mapContainer.getAsyncBackupCount();
          }
        }
;
      }
    }
);
  }
  mapServiceContext.getExpirationManager().start();
}",0.8402777777777778
48128,"private Object resolveCallTimeout(){
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + toString());
  }
  if (op instanceof WaitSupport) {
    long waitTimeout=op.getWaitTimeout();
    waitTimeout-=callTimeout;
    op.setWaitTimeout(waitTimeout);
  }
  invokeCount--;
  return RETRY_RESPONSE;
}","@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") private Object resolveCallTimeout(){
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + toString());
  }
  if (op instanceof WaitSupport) {
    long waitTimeout=op.getWaitTimeout();
    waitTimeout-=callTimeout;
    op.setWaitTimeout(waitTimeout);
  }
  invokeCount--;
  return RETRY_RESPONSE;
}",0.8552097428958051
48129,"private static Getter createGetter(QueryableEntry entry,String attribute){
  String paramAttribute=attribute;
  Object obj;
  if (paramAttribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (paramAttribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      paramAttribute=paramAttribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + paramAttribute;
  Getter getter=GETTER_CACHE.get(cacheKey);
  if (getter != null) {
    return getter;
  }
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(INITIAL_CAPACITY);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
            EmptyStatement.ignore(ignored);
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
            EmptyStatement.ignore(ignored);
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      Getter foundGetter=GETTER_CACHE.putIfAbsent(cacheKey,getter);
      if (foundGetter != null) {
        getter=foundGetter;
      }
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}","private static Getter createGetter(QueryableEntry entry,String attribute){
  String paramAttribute=attribute;
  Object obj;
  if (paramAttribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (paramAttribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      paramAttribute=paramAttribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + paramAttribute;
  Getter getter=GETTER_CACHE.get(cacheKey);
  if (getter != null) {
    return getter;
  }
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(INITIAL_CAPACITY);
    for (    final String name : paramAttribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
            EmptyStatement.ignore(ignored);
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
            EmptyStatement.ignore(ignored);
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      Getter foundGetter=GETTER_CACHE.putIfAbsent(cacheKey,getter);
      if (foundGetter != null) {
        getter=foundGetter;
      }
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}",0.9987941429801896
48130,"private LoadAllKeysTask(Collection<Data> keys,boolean replaceExistingValues,AtomicBoolean loaded){
  this.keys=keys;
  this.replaceExistingValues=replaceExistingValues;
  this.loaded=loaded;
}","private LoadAllKeysTask(Collection<Data> keys,boolean replaceExistingValues){
  this.keys=keys;
  this.replaceExistingValues=replaceExistingValues;
}",0.873900293255132
48131,"@Override public void loadAllFromStore(Collection<Data> keys,boolean replaceExistingValues){
  if (keys.isEmpty()) {
    return;
  }
  loaded.set(false);
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  ExecutionService executionService=nodeEngine.getExecutionService();
  executionService.submit(""String_Node_Str"",new LoadAllKeysTask(keys,replaceExistingValues,loaded));
}","@Override public void loadAllFromStore(Collection<Data> keys,boolean replaceExistingValues){
  if (keys.isEmpty()) {
    return;
  }
  loaded.set(false);
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  ExecutionService executionService=nodeEngine.getExecutionService();
  executionService.submit(""String_Node_Str"",new LoadAllKeysTask(keys,replaceExistingValues));
}",0.990801576872536
48132,"private Object evict0(Data key){
  Record record=records.get(key);
  Object value=null;
  if (record != null) {
    value=record.getValue();
    final long lastUpdateTime=record.getLastUpdateTime();
    putEvictionStagingArea(key,value,lastUpdateTime);
    mapService.interceptRemove(name,value);
    updateSizeEstimator(-calculateRecordSize(record));
    deleteRecord(key);
    removeIndex(key);
  }
  return value;
}","private Object evict0(Data key){
  Record record=records.get(key);
  Object value=null;
  if (record != null) {
    value=record.getValue();
    final long lastUpdateTime=record.getLastUpdateTime();
    putEvictionStagingArea(key,value,lastUpdateTime);
    mapService.interceptRemove(name,value);
    updateSizeEstimator(-calculateRecordSize(record));
    deleteRecord(key);
    removeIndex(key);
  }
  removeFromWriteBehindWaitingDeletions(key);
  return value;
}",0.947845804988662
48133,"public Object put(Data key,Object value,long ttl){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  markRecordStoreExpirable(ttl);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(key));
    }
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(key,value,null,now);
    record=mapService.createRecord(name,key,value,ttl,now);
    records.put(key,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    value=mapStoreWrite(key,value,record,now);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value,now);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
    saveIndex(record);
  }
  removeFromWriteBehindWaitingDeletions(key);
  return oldValue;
}","public Object put(Data key,Object value,long ttl){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  markRecordStoreExpirable(ttl);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=loadFromStoreOrStagingArea(key);
    }
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(key,value,null,now);
    record=mapService.createRecord(name,key,value,ttl,now);
    records.put(key,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    value=mapStoreWrite(key,value,record,now);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value,now);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
    saveIndex(record);
  }
  removeFromWriteBehindWaitingDeletions(key);
  return oldValue;
}",0.5451880801172447
48134,"private Record getRecordInternal(Data dataKey,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL,getNow());
      records.put(dataKey,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}","private Record getRecordInternal(Data key,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=loadFromStoreOrStagingArea(key);
    if (value != null) {
      record=mapService.createRecord(name,key,value,DEFAULT_TTL,getNow());
      records.put(key,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}",0.8984293193717278
48135,"@Override public Object get(Data key){
  checkIfLoaded();
  if (hasWaitingWriteBehindDeleteOperation(key)) {
    return null;
  }
  long now=getNow();
  Record record=records.get(key);
  record=nullIfExpired(record);
  Object value=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=getFromStoreOrEvictionStagingArea(key);
      if (value != null) {
        record=mapService.createRecord(name,key,value,DEFAULT_TTL,now);
        records.put(key,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record,now);
    value=record.getValue();
  }
  value=mapService.interceptGet(name,value);
  postReadCleanUp(now);
  return value;
}","@Override public Object get(Data key){
  checkIfLoaded();
  long now=getNow();
  Record record=records.get(key);
  record=nullIfExpired(record);
  Object value=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=loadFromStoreOrStagingArea(key);
      if (value != null) {
        record=mapService.createRecord(name,key,value,DEFAULT_TTL,now);
        records.put(key,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record,now);
    value=record.getValue();
  }
  value=mapService.interceptGet(name,value);
  postReadCleanUp(now);
  return value;
}",0.9386892177589852
48136,"@Override public boolean containsKey(Data key){
  checkIfLoaded();
  final long now=getNow();
  Record record=records.get(key);
  if (hasWaitingWriteBehindDeleteOperation(key)) {
    return false;
  }
  record=nullIfExpired(record);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=getFromStoreOrEvictionStagingArea(key);
      if (value != null) {
        record=mapService.createRecord(name,key,value,DEFAULT_TTL,now);
        records.put(key,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
  boolean contains=record != null;
  if (contains) {
    accessRecord(record,now);
  }
  postReadCleanUp(now);
  return contains;
}","@Override public boolean containsKey(Data key){
  checkIfLoaded();
  final long now=getNow();
  Record record=records.get(key);
  record=nullIfExpired(record);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=loadFromStoreOrStagingArea(key);
      if (value != null) {
        record=mapService.createRecord(name,key,value,DEFAULT_TTL,now);
        records.put(key,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
  boolean contains=record != null;
  if (contains) {
    accessRecord(record,now);
  }
  postReadCleanUp(now);
  return contains;
}",0.933130699088146
48137,"@Override public Object remove(Data key){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=getFromStoreOrEvictionStagingArea(key);
      if (oldValue != null) {
        removeIndex(key);
        mapStoreDelete(null,key,now);
      }
    }
  }
 else {
    oldValue=record.getValue();
    oldValue=mapService.interceptRemove(name,oldValue);
    if (oldValue != null) {
      removeIndex(key);
      mapStoreDelete(record,key,now);
    }
    updateSizeEstimator(-calculateRecordSize(record));
    deleteRecord(key);
  }
  return oldValue;
}","@Override public Object remove(Data key){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=loadFromStoreOrStagingArea(key);
      if (oldValue != null) {
        removeIndex(key);
        mapStoreDelete(null,key,now);
      }
    }
  }
 else {
    oldValue=record.getValue();
    oldValue=mapService.interceptRemove(name,oldValue);
    if (oldValue != null) {
      removeIndex(key);
      mapStoreDelete(record,key,now);
    }
    updateSizeEstimator(-calculateRecordSize(record));
    deleteRecord(key);
  }
  return oldValue;
}",0.9892318736539842
48138,"@Override public MapEntrySet getAll(Set<Data> keySet){
  checkIfLoaded();
  final long now=getNow();
  final MapEntrySet mapEntrySet=new MapEntrySet();
  Map<Object,Data> keyMapForLoader=Collections.emptyMap();
  if (mapContainer.getStore() != null) {
    keyMapForLoader=new HashMap<Object,Data>();
  }
  for (  Data dataKey : keySet) {
    Record record=records.get(dataKey);
    if (hasWaitingWriteBehindDeleteOperation(dataKey)) {
      continue;
    }
    if (record == null) {
      if (mapContainer.getStore() != null) {
        keyMapForLoader.put(mapService.toObject(dataKey),dataKey);
      }
    }
 else {
      accessRecord(record);
      Object value=record.getValue();
      value=mapService.interceptGet(name,value);
      if (value != null) {
        mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
      }
    }
  }
  if (mapContainer.getStore() == null || keyMapForLoader.size() == 0) {
    return mapEntrySet;
  }
  final Map<Object,Object> fromEvictionStagingArea=getFromEvictionStagingArea(keySet);
  for (  Object o : fromEvictionStagingArea.keySet()) {
    keyMapForLoader.remove(o);
  }
  final Map<Object,Object> loadedKeys=mapContainer.getStore().loadAll(keyMapForLoader.keySet());
  for (  Map.Entry entry : loadedKeys.entrySet()) {
    final Object objectKey=entry.getKey();
    Object value=entry.getValue();
    Data dataKey=keyMapForLoader.get(objectKey);
    if (hasWaitingWriteBehindDeleteOperation(dataKey)) {
      continue;
    }
    if (value != null) {
      Record record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL,now);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
    value=mapService.interceptGet(name,value);
    if (value != null) {
      mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
    }
  }
  postReadCleanUp(now);
  return mapEntrySet;
}","@Override public MapEntrySet getAll(Set<Data> keySet){
  checkIfLoaded();
  final long now=getNow();
  final MapEntrySet mapEntrySet=new MapEntrySet();
  Map<Object,Data> keyMapForLoader=Collections.emptyMap();
  if (mapContainer.getStore() != null) {
    keyMapForLoader=new HashMap<Object,Data>();
  }
  for (  Data dataKey : keySet) {
    Record record=records.get(dataKey);
    if (record == null) {
      if (mapContainer.getStore() != null) {
        keyMapForLoader.put(mapService.toObject(dataKey),dataKey);
      }
    }
 else {
      accessRecord(record);
      Object value=record.getValue();
      value=mapService.interceptGet(name,value);
      if (value != null) {
        mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
      }
    }
  }
  if (mapContainer.getStore() == null || keyMapForLoader.size() == 0) {
    return mapEntrySet;
  }
  final Map<Object,Object> fromEvictionStagingArea=getFromEvictionStagingArea(keySet);
  for (  Object o : fromEvictionStagingArea.keySet()) {
    keyMapForLoader.remove(o);
  }
  final Map<Object,Object> loadedKeys=mapContainer.getStore().loadAll(keyMapForLoader.keySet());
  for (  Map.Entry entry : loadedKeys.entrySet()) {
    final Object objectKey=entry.getKey();
    Object value=entry.getValue();
    Data dataKey=keyMapForLoader.get(objectKey);
    if (hasWaitingWriteBehindDeleteOperation(dataKey)) {
      continue;
    }
    if (value != null) {
      Record record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL,now);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
    value=mapService.interceptGet(name,value);
    if (value != null) {
      mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
    }
  }
  postReadCleanUp(now);
  return mapEntrySet;
}",0.9794217244073976
48139,"public Object putIfAbsent(Data key,Object value,long ttl){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  markRecordStoreExpirable(ttl);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(key));
      if (oldValue != null) {
        record=mapService.createRecord(name,key,oldValue,DEFAULT_TTL,now);
        records.put(key,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record,now);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(key,value,record,now);
    record=mapService.createRecord(name,key,value,ttl,now);
    records.put(key,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  removeFromWriteBehindWaitingDeletions(key);
  return oldValue;
}","public Object putIfAbsent(Data key,Object value,long ttl){
  checkIfLoaded();
  final long now=getNow();
  earlyWriteCleanup(now);
  markRecordStoreExpirable(ttl);
  Record record=records.get(key);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=loadFromStoreOrStagingArea(key);
      if (oldValue != null) {
        record=mapService.createRecord(name,key,oldValue,DEFAULT_TTL,now);
        records.put(key,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record,now);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(key,value,record,now);
    record=mapService.createRecord(name,key,value,ttl,now);
    records.put(key,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  removeFromWriteBehindWaitingDeletions(key);
  return oldValue;
}",0.9643031784841076
48140,"private void processTask(){
  InputStream inputStream=null;
  try {
    inputStream=openTaskInputStream();
    BufferedReader in=new BufferedReader(new InputStreamReader(inputStream));
    StringBuilder sb=new StringBuilder();
    String input;
    while ((input=in.readLine()) != null) {
      sb.append(input);
    }
    JsonObject request=JsonObject.readFrom(sb.toString());
    if (!request.isEmpty()) {
      JsonObject innerRequest=getObject(request,""String_Node_Str"");
      final int type=getInt(innerRequest,""String_Node_Str"");
      final int taskId=getInt(request,""String_Node_Str"");
      Class<? extends ConsoleRequest> requestClass=consoleRequests.get(type);
      if (requestClass == null) {
        throw new RuntimeException(""String_Node_Str"" + type);
      }
      ConsoleRequest task=requestClass.newInstance();
      task.fromJson(getObject(innerRequest,""String_Node_Str""));
      processTaskAndSendResponse(taskId,task);
    }
  }
 catch (  Exception e) {
    logger.warning(e);
  }
 finally {
    IOUtil.closeResource(inputStream);
  }
}","private void processTask(){
  InputStream inputStream=null;
  InputStreamReader reader=null;
  try {
    inputStream=openTaskInputStream();
    reader=new InputStreamReader(inputStream,""String_Node_Str"");
    JsonObject request=JsonValue.readFrom(reader).asObject();
    if (!request.isEmpty()) {
      JsonObject innerRequest=getObject(request,""String_Node_Str"");
      final int type=getInt(innerRequest,""String_Node_Str"");
      final int taskId=getInt(request,""String_Node_Str"");
      Class<? extends ConsoleRequest> requestClass=consoleRequests.get(type);
      if (requestClass == null) {
        throw new RuntimeException(""String_Node_Str"" + type);
      }
      ConsoleRequest task=requestClass.newInstance();
      task.fromJson(getObject(innerRequest,""String_Node_Str""));
      processTaskAndSendResponse(taskId,task);
    }
  }
 catch (  Exception e) {
    logger.warning(e);
  }
 finally {
    IOUtil.closeResource(reader);
    IOUtil.closeResource(inputStream);
  }
}",0.8172464478196962
48141,"private void sendState() throws InterruptedException, MalformedURLException {
  URL url=newCollectorUrl();
  try {
    HttpURLConnection connection=openConnection(url);
    OutputStream outputStream=connection.getOutputStream();
    final OutputStreamWriter writer=new OutputStreamWriter(outputStream);
    try {
      JsonObject root=new JsonObject();
      root.add(""String_Node_Str"",identifier.toJson());
      TimedMemberState timedMemberState=timedMemberStateFactory.createTimedMemberState();
      root.add(""String_Node_Str"",timedMemberState.toJson());
      root.writeTo(writer);
      writer.flush();
      outputStream.flush();
      post(connection);
    }
  finally {
      closeResource(writer);
      closeResource(outputStream);
    }
  }
 catch (  ConnectException e) {
    if (logger.isFinestEnabled()) {
      logger.finest(e);
    }
 else {
      logger.info(""String_Node_Str"" + url);
    }
  }
catch (  Exception e) {
    logger.warning(e);
  }
}","private void sendState() throws InterruptedException, MalformedURLException {
  URL url=newCollectorUrl();
  try {
    HttpURLConnection connection=openConnection(url);
    OutputStream outputStream=connection.getOutputStream();
    final OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    try {
      JsonObject root=new JsonObject();
      root.add(""String_Node_Str"",identifier.toJson());
      TimedMemberState timedMemberState=timedMemberStateFactory.createTimedMemberState();
      root.add(""String_Node_Str"",timedMemberState.toJson());
      root.writeTo(writer);
      writer.flush();
      outputStream.flush();
      post(connection);
    }
  finally {
      closeResource(writer);
      closeResource(outputStream);
    }
  }
 catch (  ConnectException e) {
    if (logger.isFinestEnabled()) {
      logger.finest(e);
    }
 else {
      logger.info(""String_Node_Str"" + url);
    }
  }
catch (  Exception e) {
    logger.warning(e);
  }
}",0.9907597535934292
48142,"public void processTaskAndSendResponse(int taskId,ConsoleRequest task){
  try {
    HttpURLConnection connection=openPostResponseConnection();
    OutputStream outputStream=connection.getOutputStream();
    final OutputStreamWriter writer=new OutputStreamWriter(outputStream);
    try {
      JsonObject root=new JsonObject();
      root.add(""String_Node_Str"",identifier.toJson());
      root.add(""String_Node_Str"",taskId);
      root.add(""String_Node_Str"",task.getType());
      task.writeResponse(ManagementCenterService.this,root);
      root.writeTo(writer);
      writer.flush();
      outputStream.flush();
      post(connection);
    }
  finally {
      closeResource(writer);
      closeResource(outputStream);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + task,e);
  }
}","public void processTaskAndSendResponse(int taskId,ConsoleRequest task){
  try {
    HttpURLConnection connection=openPostResponseConnection();
    OutputStream outputStream=connection.getOutputStream();
    final OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    try {
      JsonObject root=new JsonObject();
      root.add(""String_Node_Str"",identifier.toJson());
      root.add(""String_Node_Str"",taskId);
      root.add(""String_Node_Str"",task.getType());
      task.writeResponse(ManagementCenterService.this,root);
      root.writeTo(writer);
      writer.flush();
      outputStream.flush();
      post(connection);
    }
  finally {
      closeResource(writer);
      closeResource(outputStream);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + task,e);
  }
}",0.9889705882352942
48143,"public boolean set(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  earlyWriteCleanup();
  Record record=records.get(dataKey);
  boolean newRecord=false;
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(dataKey,value,null);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    value=mapStoreWrite(dataKey,value,record);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return newRecord;
}","public boolean set(Data key,Object value,long ttl){
  checkIfLoaded();
  earlyWriteCleanup();
  Record record=records.get(key);
  boolean newRecord=false;
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    value=mapStoreWrite(key,value,null);
    record=mapService.createRecord(name,key,value,ttl);
    records.put(key,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    value=mapStoreWrite(key,value,record);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  removeFromWriteBehindWaitingDeletions(key);
  return newRecord;
}",0.9488778054862844
48144,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  constructors[HASH_MAP_ADAPTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new HashMapAdapter();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9783409724094544
48145,"@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new PostPonePartitionProcessing();
}","@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new HashMapAdapter();
}",0.8450704225352113
48146,"public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  Map<KeyIn,Chunk> chunkMap=new HashMap<KeyIn,Chunk>(combiners.size());
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  collected.set(0);
  return chunkMap;
}","public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  int mapSize=MapReduceUtil.mapSize(combiners.size());
  Map<KeyIn,Chunk> chunkMap=new HashMapAdapter<KeyIn,Chunk>(mapSize);
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    if (chunk != null) {
      chunkMap.put(entry.getKey(),chunk);
    }
  }
  collected.set(0);
  return chunkMap;
}",0.7545219638242894
48147,"public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapsize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMap<Object,Object>(mapsize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}","public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapSize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMapAdapter<Object,Object>(mapSize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}",0.9888551165146908
48148,"public void checkFullyProcessed(JobProcessInformation processInformation){
  if (isOwnerNode()) {
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    for (    JobPartitionState partitionState : partitionStates) {
      if (partitionState == null || partitionState.getState() != JobPartitionState.State.PROCESSED) {
        return;
      }
    }
    String name=configuration.getName();
    String jobId=configuration.getJobId();
    NodeEngine nodeEngine=configuration.getNodeEngine();
    GetResultOperationFactory operationFactory=new GetResultOperationFactory(name,jobId);
    List<Map> results=MapReduceUtil.executeOperation(operationFactory,mapReduceService,nodeEngine,true);
    boolean reducedResult=configuration.getReducerFactory() != null;
    if (results != null) {
      Map<Object,Object> mergedResults=new HashMap<Object,Object>();
      for (      Map<?,?> map : results) {
        for (        Map.Entry entry : map.entrySet()) {
          collectResults(reducedResult,mergedResults,entry);
        }
      }
      TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
      jobTracker.unregisterMapCombineTask(jobId);
      jobTracker.unregisterReducerTask(jobId);
      mapReduceService.destroyJobSupervisor(this);
      future.setResult(mergedResults);
    }
  }
}","public void checkFullyProcessed(JobProcessInformation processInformation){
  if (isOwnerNode()) {
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    for (    JobPartitionState partitionState : partitionStates) {
      if (partitionState == null || partitionState.getState() != JobPartitionState.State.PROCESSED) {
        return;
      }
    }
    String name=configuration.getName();
    String jobId=configuration.getJobId();
    NodeEngine nodeEngine=configuration.getNodeEngine();
    GetResultOperationFactory operationFactory=new GetResultOperationFactory(name,jobId);
    try {
      List<Map> results=MapReduceUtil.executeOperation(operationFactory,mapReduceService,nodeEngine,true);
      boolean reducedResult=configuration.getReducerFactory() != null;
      if (results != null) {
        Map<Object,Object> mergedResults=new HashMap<Object,Object>();
        for (        Map<?,?> map : results) {
          for (          Map.Entry entry : map.entrySet()) {
            collectResults(reducedResult,mergedResults,entry);
          }
        }
        TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
        jobTracker.unregisterMapCombineTask(jobId);
        jobTracker.unregisterReducerTask(jobId);
        mapReduceService.destroyJobSupervisor(this);
        future.setResult(mergedResults);
      }
    }
 catch (    Exception e) {
      TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
      jobTracker.unregisterMapCombineTask(jobId);
      jobTracker.unregisterReducerTask(jobId);
      mapReduceService.destroyJobSupervisor(this);
      future.setResult(e);
    }
  }
}",0.8890374331550802
48149,"@Override public void setResult(Object result){
  Object finalResult=result;
  if (collator != null) {
    finalResult=collator.collate(((Map)finalResult).entrySet());
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}","@Override public void setResult(Object result){
  Object finalResult=result;
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    if (!(finalResult instanceof CancellationException)) {
      finalResult=new ExecutionException((Throwable)finalResult);
    }
    super.setResult(finalResult);
    latch.countDown();
    return;
  }
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}",0.6771653543307087
48150,"private Set<String> selectKeys(){
  Set<String> keys=new HashSet<String>();
  if (!deferredWrite) {
    for (    String qualifiedAttributeKey : getClusterMap().keySet(new SessionAttributePredicate(id))) {
      keys.add(extractAttributeKey(qualifiedAttributeKey));
    }
  }
 else {
    for (    Entry<String,LocalCacheEntry> entry : localCache.entrySet()) {
      if (!entry.getValue().removed) {
        keys.add(entry.getKey());
      }
    }
  }
  return keys;
}","private Set<String> selectKeys(){
  Set<String> keys=new HashSet<String>();
  if (!deferredWrite) {
    for (    String qualifiedAttributeKey : getClusterMap().keySet(new SessionAttributePredicate(id))) {
      keys.add(extractAttributeKey(qualifiedAttributeKey));
    }
  }
 else {
    for (    Entry<String,LocalCacheEntry> entry : localCache.entrySet()) {
      if (!entry.getValue().removed && entry.getValue() != NULL_ENTRY) {
        keys.add(entry.getKey());
      }
    }
  }
  return keys;
}",0.9648033126293996
48151,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  HttpSession session=req.getSession();
  if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    Object value=session.getAttribute(""String_Node_Str"");
    resp.getWriter().write(value == null ? ""String_Node_Str"" : value.toString());
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.removeAttribute(""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    session=req.getSession();
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  HttpSession session=req.getSession();
  if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    Object value=session.getAttribute(""String_Node_Str"");
    resp.getWriter().write(value == null ? ""String_Node_Str"" : value.toString());
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.removeAttribute(""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    List<String> names=Collections.list(session.getAttributeNames());
    String nameList=names.toString();
    resp.getWriter().write(nameList.substring(1,nameList.length() - 1).replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    session=req.getSession();
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
}",0.8996231586159644
48152,"private Set<String> selectKeys(){
  Set<String> keys=new HashSet<String>();
  if (!deferredWrite) {
    for (    String qualifiedAttributeKey : getClusterMap().keySet(new SessionAttributePredicate(id))) {
      keys.add(extractAttributeKey(qualifiedAttributeKey));
    }
  }
 else {
    for (    Entry<String,LocalCacheEntry> entry : localCache.entrySet()) {
      if (!entry.getValue().removed) {
        keys.add(entry.getKey());
      }
    }
  }
  return keys;
}","private Set<String> selectKeys(){
  Set<String> keys=new HashSet<String>();
  if (!deferredWrite) {
    for (    String qualifiedAttributeKey : getClusterMap().keySet(new SessionAttributePredicate(id))) {
      keys.add(extractAttributeKey(qualifiedAttributeKey));
    }
  }
 else {
    for (    Entry<String,LocalCacheEntry> entry : localCache.entrySet()) {
      if (!entry.getValue().removed && entry.getValue() != NULL_ENTRY) {
        keys.add(entry.getKey());
      }
    }
  }
  return keys;
}",0.9648033126293996
48153,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  HttpSession session=req.getSession();
  if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    Object value=session.getAttribute(""String_Node_Str"");
    resp.getWriter().write(value == null ? ""String_Node_Str"" : value.toString());
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.removeAttribute(""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    session=req.getSession();
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  HttpSession session=req.getSession();
  if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    Object value=session.getAttribute(""String_Node_Str"");
    resp.getWriter().write(value == null ? ""String_Node_Str"" : value.toString());
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.removeAttribute(""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    List<String> names=Collections.list(session.getAttributeNames());
    String nameList=names.toString();
    resp.getWriter().write(nameList.substring(1,nameList.length() - 1).replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (req.getRequestURI().endsWith(""String_Node_Str"")) {
    session.invalidate();
    session=req.getSession();
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    resp.getWriter().write(""String_Node_Str"");
  }
}",0.8996231586159644
48154,"@Override protected Operation prepareOperation(){
  return new CallableTaskOperation(name,uuid,callable);
}","@Override protected Operation prepareOperation(){
  SecurityContext securityContext=getClientEngine().getSecurityContext();
  if (securityContext != null) {
    callable=securityContext.createSecureCallable(getEndpoint().getSubject(),callable);
  }
  return new CallableTaskOperation(name,uuid,callable);
}",0.5181598062953995
48155,"@Override protected Operation prepareOperation(){
  return new CallableTaskOperation(name,uuid,callable);
}","@Override protected Operation prepareOperation(){
  SecurityContext securityContext=getClientEngine().getSecurityContext();
  if (securityContext != null) {
    callable=securityContext.createSecureCallable(getEndpoint().getSubject(),callable);
  }
  return new CallableTaskOperation(name,uuid,callable);
}",0.5181598062953995
48156,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  constructors[HASH_MAP_ADAPTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new HashMapAdapter();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9783409724094544
48157,"@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new PostPonePartitionProcessing();
}","@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new HashMapAdapter();
}",0.8450704225352113
48158,"public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  Map<KeyIn,Chunk> chunkMap=new HashMap<KeyIn,Chunk>(combiners.size());
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  COLLECTED_UPDATER.set(this,0);
  return chunkMap;
}","public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  int mapSize=MapReduceUtil.mapSize(combiners.size());
  Map<KeyIn,Chunk> chunkMap=new HashMapAdapter<KeyIn,Chunk>(mapSize);
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    if (chunk != null) {
      chunkMap.put(entry.getKey(),chunk);
    }
  }
  COLLECTED_UPDATER.set(this,0);
  return chunkMap;
}",0.7625
48159,"public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapsize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMap<Object,Object>(mapsize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}","public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapSize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMapAdapter<Object,Object>(mapSize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}",0.9888551165146908
48160,"public void checkFullyProcessed(JobProcessInformation processInformation){
  if (isOwnerNode()) {
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    for (    JobPartitionState partitionState : partitionStates) {
      if (partitionState == null || partitionState.getState() != JobPartitionState.State.PROCESSED) {
        return;
      }
    }
    String name=configuration.getName();
    String jobId=configuration.getJobId();
    NodeEngine nodeEngine=configuration.getNodeEngine();
    GetResultOperationFactory operationFactory=new GetResultOperationFactory(name,jobId);
    List<Map> results=MapReduceUtil.executeOperation(operationFactory,mapReduceService,nodeEngine,true);
    boolean reducedResult=configuration.getReducerFactory() != null;
    if (results != null) {
      Map<Object,Object> mergedResults=new HashMap<Object,Object>();
      for (      Map<?,?> map : results) {
        for (        Map.Entry entry : map.entrySet()) {
          collectResults(reducedResult,mergedResults,entry);
        }
      }
      TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
      jobTracker.unregisterMapCombineTask(jobId);
      jobTracker.unregisterReducerTask(jobId);
      mapReduceService.destroyJobSupervisor(this);
      future.setResult(mergedResults);
    }
  }
}","public void checkFullyProcessed(JobProcessInformation processInformation){
  if (isOwnerNode()) {
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    for (    JobPartitionState partitionState : partitionStates) {
      if (partitionState == null || partitionState.getState() != JobPartitionState.State.PROCESSED) {
        return;
      }
    }
    String name=configuration.getName();
    String jobId=configuration.getJobId();
    NodeEngine nodeEngine=configuration.getNodeEngine();
    GetResultOperationFactory operationFactory=new GetResultOperationFactory(name,jobId);
    try {
      List<Map> results=MapReduceUtil.executeOperation(operationFactory,mapReduceService,nodeEngine,true);
      boolean reducedResult=configuration.getReducerFactory() != null;
      if (results != null) {
        Map<Object,Object> mergedResults=new HashMap<Object,Object>();
        for (        Map<?,?> map : results) {
          for (          Map.Entry entry : map.entrySet()) {
            collectResults(reducedResult,mergedResults,entry);
          }
        }
        TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
        jobTracker.unregisterMapCombineTask(jobId);
        jobTracker.unregisterReducerTask(jobId);
        mapReduceService.destroyJobSupervisor(this);
        future.setResult(mergedResults);
      }
    }
 catch (    Exception e) {
      TrackableJobFuture future=jobTracker.unregisterTrackableJob(jobId);
      jobTracker.unregisterMapCombineTask(jobId);
      jobTracker.unregisterReducerTask(jobId);
      mapReduceService.destroyJobSupervisor(this);
      future.setResult(e);
    }
  }
}",0.8890374331550802
48161,"@Override public void setResult(Object result){
  Object finalResult=result;
  if (collator != null) {
    finalResult=collator.collate(((Map)finalResult).entrySet());
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}","@Override public void setResult(Object result){
  Object finalResult=result;
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    if (!(finalResult instanceof CancellationException)) {
      finalResult=new ExecutionException((Throwable)finalResult);
    }
    super.setResult(finalResult);
    latch.countDown();
    return;
  }
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}",0.6771653543307087
48162,"@Override public void setResult(Object result){
  if (result instanceof Throwable && !(result instanceof CancellationException)) {
    if (!(result instanceof CancellationException)) {
      result=new ExecutionException((Throwable)result);
    }
    super.setResult(result);
    latch.countDown();
    return;
  }
  Object finalResult=result;
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}","@Override public void setResult(Object result){
  Object finalResult=result;
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    if (!(finalResult instanceof CancellationException)) {
      finalResult=new ExecutionException((Throwable)finalResult);
    }
    super.setResult(finalResult);
    latch.countDown();
    return;
  }
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}",0.6194331983805668
48163,"private void createMemberState(MemberStateImpl memberState){
  final Node node=instance.node;
  memberState.setAddress(node.getThisAddress());
  final HashSet<SerializableClientEndPoint> serializableClientEndPoints=new HashSet<SerializableClientEndPoint>();
  for (  Client client : instance.node.clientEngine.getClients()) {
    serializableClientEndPoints.add(new SerializableClientEndPoint(client));
  }
  memberState.setClients(serializableClientEndPoints);
  final EventService es=instance.node.nodeEngine.getEventService();
  final OperationService os=instance.node.nodeEngine.getOperationService();
  final ConnectionManager cm=instance.node.connectionManager;
  final InternalPartitionService ps=instance.node.partitionService;
  final ProxyService proxyService=instance.node.nodeEngine.getProxyService();
  final ExecutionService executionService=instance.node.nodeEngine.getExecutionService();
  final SerializableEventServiceBean esBean=new SerializableEventServiceBean(es);
  memberState.setEventServiceBean(esBean);
  final SerializableOperationServiceBean osBean=new SerializableOperationServiceBean(os);
  memberState.setOperationServiceBean(osBean);
  final SerializableConnectionManagerBean cmBean=new SerializableConnectionManagerBean(cm);
  memberState.setConnectionManagerBean(cmBean);
  final SerializablePartitionServiceBean psBean=new SerializablePartitionServiceBean(ps,instance);
  memberState.setPartitionServiceBean(psBean);
  final SerializableProxyServiceBean proxyServiceBean=new SerializableProxyServiceBean(proxyService);
  memberState.setProxyServiceBean(proxyServiceBean);
  final ManagedExecutorService systemExecutor=executionService.getExecutor(ExecutionService.SYSTEM_EXECUTOR);
  final ManagedExecutorService operationExecutor=executionService.getExecutor(ExecutionService.OPERATION_EXECUTOR);
  final ManagedExecutorService asyncExecutor=executionService.getExecutor(ExecutionService.ASYNC_EXECUTOR);
  final ManagedExecutorService scheduledExecutor=executionService.getExecutor(ExecutionService.SCHEDULED_EXECUTOR);
  final ManagedExecutorService clientExecutor=executionService.getExecutor(ExecutionService.CLIENT_EXECUTOR);
  final ManagedExecutorService queryExecutor=executionService.getExecutor(ExecutionService.QUERY_EXECUTOR);
  final ManagedExecutorService ioExecutor=executionService.getExecutor(ExecutionService.IO_EXECUTOR);
  final SerializableManagedExecutorBean systemExecutorBean=new SerializableManagedExecutorBean(systemExecutor);
  final SerializableManagedExecutorBean operationExecutorBean=new SerializableManagedExecutorBean(operationExecutor);
  final SerializableManagedExecutorBean asyncExecutorBean=new SerializableManagedExecutorBean(asyncExecutor);
  final SerializableManagedExecutorBean scheduledExecutorBean=new SerializableManagedExecutorBean(scheduledExecutor);
  final SerializableManagedExecutorBean clientExecutorBean=new SerializableManagedExecutorBean(clientExecutor);
  final SerializableManagedExecutorBean queryExecutorBean=new SerializableManagedExecutorBean(queryExecutor);
  final SerializableManagedExecutorBean ioExecutorBean=new SerializableManagedExecutorBean(ioExecutor);
  memberState.putManagedExecutor(ExecutionService.SYSTEM_EXECUTOR,systemExecutorBean);
  memberState.putManagedExecutor(ExecutionService.OPERATION_EXECUTOR,operationExecutorBean);
  memberState.putManagedExecutor(ExecutionService.ASYNC_EXECUTOR,asyncExecutorBean);
  memberState.putManagedExecutor(ExecutionService.SCHEDULED_EXECUTOR,scheduledExecutorBean);
  memberState.putManagedExecutor(ExecutionService.CLIENT_EXECUTOR,clientExecutorBean);
  memberState.putManagedExecutor(ExecutionService.QUERY_EXECUTOR,queryExecutorBean);
  memberState.putManagedExecutor(ExecutionService.IO_EXECUTOR,ioExecutorBean);
  PartitionService partitionService=instance.getPartitionService();
  Set<Partition> partitions=partitionService.getPartitions();
  memberState.clearPartitions();
  for (  Partition partition : partitions) {
    if (partition.getOwner() != null && partition.getOwner().localMember()) {
      memberState.addPartition(partition.getPartitionId());
    }
  }
  Collection<DistributedObject> proxyObjects=new ArrayList<DistributedObject>(instance.getDistributedObjects());
  createRuntimeProps(memberState);
  createMemState(memberState,proxyObjects);
}","private void createMemberState(MemberStateImpl memberState){
  final Node node=instance.node;
  memberState.setAddress(node.getThisAddress());
  final HashSet<SerializableClientEndPoint> serializableClientEndPoints=new HashSet<SerializableClientEndPoint>();
  for (  Client client : instance.node.clientEngine.getClients()) {
    serializableClientEndPoints.add(new SerializableClientEndPoint(client));
  }
  memberState.setClients(serializableClientEndPoints);
  createJMXBeans(memberState);
  PartitionService partitionService=instance.getPartitionService();
  Set<Partition> partitions=partitionService.getPartitions();
  memberState.clearPartitions();
  for (  Partition partition : partitions) {
    if (partition.getOwner() != null && partition.getOwner().localMember()) {
      memberState.addPartition(partition.getPartitionId());
    }
  }
  Collection<DistributedObject> proxyObjects=new ArrayList<DistributedObject>(instance.getDistributedObjects());
  createRuntimeProps(memberState);
  createMemState(memberState,proxyObjects);
}",0.3808990859914195
48164,"@Override public void writeData(ObjectDataOutput out) throws IOException {
  address.writeData(out);
  out.writeInt(mapStats.size());
  for (  Map.Entry<String,LocalMapStatsImpl> entry : mapStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(multiMapStats.size());
  for (  Map.Entry<String,LocalMultiMapStatsImpl> entry : multiMapStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(queueStats.size());
  for (  Map.Entry<String,LocalQueueStatsImpl> entry : queueStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(topicStats.size());
  for (  Map.Entry<String,LocalTopicStatsImpl> entry : topicStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(executorStats.size());
  for (  Map.Entry<String,LocalExecutorStatsImpl> entry : executorStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(runtimeProps.size());
  for (  Map.Entry<String,Long> entry : runtimeProps.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeLong(entry.getValue());
  }
  out.writeInt(partitions.size());
  for (  Integer lsPartition : partitions) {
    out.writeInt(lsPartition);
  }
  out.writeInt(clients.size());
  for (  SerializableClientEndPoint client : clients) {
    client.writeData(out);
  }
  out.writeInt(managedExecutorBeans.size());
  for (  Map.Entry<String,SerializableManagedExecutorBean> entry : managedExecutorBeans.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  eventServiceBean.writeData(out);
  operationServiceBean.writeData(out);
  connectionManagerBean.writeData(out);
  partitionServiceBean.writeData(out);
  proxyServiceBean.writeData(out);
}","@Override public void writeData(ObjectDataOutput out) throws IOException {
  address.writeData(out);
  out.writeInt(mapStats.size());
  for (  Map.Entry<String,LocalMapStatsImpl> entry : mapStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(multiMapStats.size());
  for (  Map.Entry<String,LocalMultiMapStatsImpl> entry : multiMapStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(queueStats.size());
  for (  Map.Entry<String,LocalQueueStatsImpl> entry : queueStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(topicStats.size());
  for (  Map.Entry<String,LocalTopicStatsImpl> entry : topicStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(executorStats.size());
  for (  Map.Entry<String,LocalExecutorStatsImpl> entry : executorStats.entrySet()) {
    out.writeUTF(entry.getKey());
    entry.getValue().writeData(out);
  }
  out.writeInt(runtimeProps.size());
  for (  Map.Entry<String,Long> entry : runtimeProps.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeLong(entry.getValue());
  }
  out.writeInt(partitions.size());
  for (  Integer lsPartition : partitions) {
    out.writeInt(lsPartition);
  }
  out.writeInt(clients.size());
  for (  SerializableClientEndPoint client : clients) {
    client.writeData(out);
  }
  beans.writeData(out);
}",0.8837072018890201
48165,"@Override public void readData(ObjectDataInput in) throws IOException {
  address.readData(in);
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalMapStatsImpl impl=new LocalMapStatsImpl();
    impl.readData(in);
    mapStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalMultiMapStatsImpl impl=new LocalMultiMapStatsImpl();
    impl.readData(in);
    multiMapStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalQueueStatsImpl impl=new LocalQueueStatsImpl();
    impl.readData(in);
    queueStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalTopicStatsImpl impl=new LocalTopicStatsImpl();
    impl.readData(in);
    topicStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalExecutorStatsImpl impl=new LocalExecutorStatsImpl();
    impl.readData(in);
    executorStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    runtimeProps.put(name,in.readLong());
  }
  for (int i=in.readInt(); i > 0; i--) {
    partitions.add(in.readInt());
  }
  for (int i=in.readInt(); i > 0; i--) {
    SerializableClientEndPoint ci=new SerializableClientEndPoint();
    ci.readData(in);
    clients.add(ci);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    SerializableManagedExecutorBean managedExecutorBean=new SerializableManagedExecutorBean();
    managedExecutorBean.readData(in);
    managedExecutorBeans.put(name,managedExecutorBean);
  }
  eventServiceBean=new SerializableEventServiceBean();
  eventServiceBean.readData(in);
  operationServiceBean=new SerializableOperationServiceBean();
  operationServiceBean.readData(in);
  connectionManagerBean=new SerializableConnectionManagerBean();
  connectionManagerBean.readData(in);
  partitionServiceBean=new SerializablePartitionServiceBean();
  partitionServiceBean.readData(in);
  proxyServiceBean=new SerializableProxyServiceBean();
  proxyServiceBean.readData(in);
}","@Override public void readData(ObjectDataInput in) throws IOException {
  address.readData(in);
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalMapStatsImpl impl=new LocalMapStatsImpl();
    impl.readData(in);
    mapStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalMultiMapStatsImpl impl=new LocalMultiMapStatsImpl();
    impl.readData(in);
    multiMapStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalQueueStatsImpl impl=new LocalQueueStatsImpl();
    impl.readData(in);
    queueStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalTopicStatsImpl impl=new LocalTopicStatsImpl();
    impl.readData(in);
    topicStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    LocalExecutorStatsImpl impl=new LocalExecutorStatsImpl();
    impl.readData(in);
    executorStats.put(name,impl);
  }
  for (int i=in.readInt(); i > 0; i--) {
    String name=in.readUTF();
    runtimeProps.put(name,in.readLong());
  }
  for (int i=in.readInt(); i > 0; i--) {
    partitions.add(in.readInt());
  }
  for (int i=in.readInt(); i > 0; i--) {
    SerializableClientEndPoint ci=new SerializableClientEndPoint();
    ci.readData(in);
    clients.add(ci);
  }
  beans.readData(in);
}",0.7937765205091938
48166,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  constructors[HASH_MAP_ADAPTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new HashMapAdapter();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9783409724094544
48167,"@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new PostPonePartitionProcessing();
}","@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new HashMapAdapter();
}",0.8450704225352113
48168,"public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  Map<KeyIn,Chunk> chunkMap=new HashMap<KeyIn,Chunk>(combiners.size());
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  COLLECTED_UPDATER.set(this,0);
  return chunkMap;
}","public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  int mapSize=MapReduceUtil.mapSize(combiners.size());
  Map<KeyIn,Chunk> chunkMap=new HashMapAdapter<KeyIn,Chunk>(mapSize);
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  COLLECTED_UPDATER.set(this,0);
  return chunkMap;
}",0.7953063885267275
48169,"public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapsize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMap<Object,Object>(mapsize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}","public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapSize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMapAdapter<Object,Object>(mapSize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}",0.9888551165146908
48170,"public void putRecord(Data key,Record record){
  records.put(key,record);
}","public Record putRecord(Data key,Record record){
  return records.put(key,record);
}",0.9182389937106918
48171,"void putRecord(Data key,Record record);","Record putRecord(Data key,Record record);",0.925
48172,"private void updateSizeEstimator(Record record,RecordStore recordStore){
  final long cost=recordStore.getSizeEstimator().getCost(record);
  recordStore.getSizeEstimator().add(cost);
}","private void updateSizeEstimator(long recordSize,SizeEstimator sizeEstimator){
  sizeEstimator.add(recordSize);
}",0.5454545454545454
48173,"public void run(){
  MapService mapService=getService();
  if (data != null) {
    for (    Entry<String,Set<RecordReplicationInfo>> dataEntry : data.entrySet()) {
      Set<RecordReplicationInfo> recordReplicationInfos=dataEntry.getValue();
      final String mapName=dataEntry.getKey();
      RecordStore recordStore=mapService.getRecordStore(getPartitionId(),mapName);
      for (      RecordReplicationInfo recordReplicationInfo : recordReplicationInfos) {
        Data key=recordReplicationInfo.getKey();
        Record newRecord=mapService.createRecord(mapName,key,recordReplicationInfo.getValue(),-1,false);
        mapService.applyRecordInfo(newRecord,mapName,recordReplicationInfo);
        recordStore.putRecord(key,newRecord);
        updateSizeEstimator(newRecord,recordStore);
      }
    }
  }
  if (mapInitialLoadInfo != null) {
    for (    String mapName : mapInitialLoadInfo.keySet()) {
      RecordStore recordStore=mapService.getRecordStore(getPartitionId(),mapName);
      recordStore.setLoaded(mapInitialLoadInfo.get(mapName));
    }
  }
}","public void run(){
  MapService mapService=getService();
  if (data != null) {
    for (    Entry<String,Set<RecordReplicationInfo>> dataEntry : data.entrySet()) {
      Set<RecordReplicationInfo> recordReplicationInfos=dataEntry.getValue();
      final String mapName=dataEntry.getKey();
      RecordStore recordStore=mapService.getRecordStore(getPartitionId(),mapName);
      for (      RecordReplicationInfo recordReplicationInfo : recordReplicationInfos) {
        Data key=recordReplicationInfo.getKey();
        Record newRecord=mapService.createRecord(mapName,key,recordReplicationInfo.getValue(),-1,false);
        mapService.applyRecordInfo(newRecord,mapName,recordReplicationInfo);
        final Record existingRecord=recordStore.putRecord(key,newRecord);
        final SizeEstimator sizeEstimator=recordStore.getSizeEstimator();
        updateSizeEstimator(-calculateRecordSize(existingRecord,sizeEstimator),sizeEstimator);
        updateSizeEstimator(calculateRecordSize(newRecord,sizeEstimator),sizeEstimator);
      }
    }
  }
  if (mapInitialLoadInfo != null) {
    for (    String mapName : mapInitialLoadInfo.keySet()) {
      RecordStore recordStore=mapService.getRecordStore(getPartitionId(),mapName);
      recordStore.setLoaded(mapInitialLoadInfo.get(mapName));
    }
  }
}",0.8913412563667232
48174,"public void putForReplication(Data key,Record record){
  records.put(key,record);
  updateSizeEstimator(calculateRecordSize(record));
  removeFromWriteBehindWaitingDeletions(key);
}","public void putForReplication(Data key,Record record){
  final Record existingRecord=records.get(key);
  updateSizeEstimator(-calculateRecordSize(existingRecord));
  records.put(key,record);
  updateSizeEstimator(calculateRecordSize(record));
  removeFromWriteBehindWaitingDeletions(key);
}",0.7685774946921444
48175,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  constructors[HASH_MAP_ADAPTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new HashMapAdapter();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9783409724094544
48176,"@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new PostPonePartitionProcessing();
}","@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new HashMapAdapter();
}",0.8450704225352113
48177,"public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  Map<KeyIn,Chunk> chunkMap=new HashMap<KeyIn,Chunk>(combiners.size());
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  collected.set(0);
  return chunkMap;
}","public <Chunk>Map<KeyIn,Chunk> requestChunk(){
  int mapSize=MapReduceUtil.mapSize(combiners.size());
  Map<KeyIn,Chunk> chunkMap=new HashMapAdapter<KeyIn,Chunk>(mapSize);
  for (  Map.Entry<KeyIn,Combiner<KeyIn,ValueIn,?>> entry : combiners.entrySet()) {
    Chunk chunk=(Chunk)entry.getValue().finalizeChunk();
    chunkMap.put(entry.getKey(),chunk);
  }
  collected.set(0);
  return chunkMap;
}",0.3670715249662618
48178,"public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapsize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMap<Object,Object>(mapsize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}","public Map<Object,Object> getJobResults(){
  Map<Object,Object> result;
  if (configuration.getReducerFactory() != null) {
    int mapSize=MapReduceUtil.mapSize(reducers.size());
    result=new HashMapAdapter<Object,Object>(mapSize);
    for (    Map.Entry<Object,Reducer> entry : reducers.entrySet()) {
      result.put(entry.getKey(),entry.getValue().finalizeReduce());
    }
  }
 else {
    DefaultContext currentContext=context.get();
    result=currentContext.finish();
  }
  return result;
}",0.9888551165146908
48179,"@Override public void setResult(Object result){
  if (result instanceof Throwable && !(result instanceof CancellationException)) {
    if (!(result instanceof CancellationException)) {
      result=new ExecutionException((Throwable)result);
    }
    super.setResult(result);
    latch.countDown();
    return;
  }
  Object finalResult=result;
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}","@Override public void setResult(Object result){
  Object finalResult=result;
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    if (!(finalResult instanceof CancellationException)) {
      finalResult=new ExecutionException((Throwable)finalResult);
    }
    super.setResult(finalResult);
    latch.countDown();
    return;
  }
  if (collator != null) {
    try {
      finalResult=collator.collate(((Map)finalResult).entrySet());
    }
 catch (    Exception e) {
      finalResult=e;
    }
  }
  if (finalResult instanceof Throwable && !(finalResult instanceof CancellationException)) {
    finalResult=new ExecutionException((Throwable)finalResult);
  }
  super.setResult(finalResult);
  latch.countDown();
}",0.6194331983805668
48180,"Integer getClassVersion(int factoryId,int classId);","int getClassVersion(int factoryId,int classId);",0.9387755102040816
48181,"static void compress(byte[] input,DataOutput out) throws IOException {
  Deflater deflater=new Deflater();
  deflater.setLevel(Deflater.DEFAULT_COMPRESSION);
  deflater.setStrategy(Deflater.FILTERED);
  deflater.setInput(input);
  deflater.finish();
  byte[] buf=new byte[1024];
  while (!deflater.finished()) {
    int count=deflater.deflate(buf);
    out.write(buf,0,count);
  }
  deflater.end();
}","static void compress(byte[] input,DataOutput out) throws IOException {
  Deflater deflater=new Deflater();
  deflater.setLevel(Deflater.DEFAULT_COMPRESSION);
  deflater.setStrategy(Deflater.FILTERED);
  deflater.setInput(input);
  deflater.finish();
  byte[] buf=new byte[COMPRESSION_BUFFER_LENGTH];
  while (!deflater.finished()) {
    int count=deflater.deflate(buf);
    out.write(buf,0,count);
  }
  deflater.end();
}",0.9646772228989038
48182,"Integer getClassVersion(int classId){
  return currentClassVersions.get(classId);
}","int getClassVersion(int classId){
  Integer version=currentClassVersions.get(classId);
  return version != null ? version : -1;
}",0.7075471698113207
48183,"void setClassVersion(int classId,int version){
  Integer current;
  if ((current=currentClassVersions.putIfAbsent(classId,version)) != null) {
    if (current != version) {
      throw new IllegalArgumentException(""String_Node_Str"" + classId + ""String_Node_Str"");
    }
  }
}","void setClassVersion(int classId,int version){
  Integer current=currentClassVersions.putIfAbsent(classId,version);
  if (current != null && current != version) {
    throw new IllegalArgumentException(""String_Node_Str"" + classId + ""String_Node_Str"");
  }
}",0.8947368421052632
48184,"static void decompress(byte[] compressedData,DataOutput out) throws IOException {
  Inflater inflater=new Inflater();
  inflater.setInput(compressedData);
  byte[] buf=new byte[1024];
  while (!inflater.finished()) {
    try {
      int count=inflater.inflate(buf);
      out.write(buf,0,count);
    }
 catch (    DataFormatException e) {
      throw new IOException(e);
    }
  }
  inflater.end();
}","static void decompress(byte[] compressedData,DataOutput out) throws IOException {
  Inflater inflater=new Inflater();
  inflater.setInput(compressedData);
  byte[] buf=new byte[COMPRESSION_BUFFER_LENGTH];
  while (!inflater.finished()) {
    try {
      int count=inflater.inflate(buf);
      out.write(buf,0,count);
    }
 catch (    DataFormatException e) {
      throw new IOException(e);
    }
  }
  inflater.end();
}",0.9646772228989038
48185,"ClassDefinition create(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  if (cd.getVersion() < 0) {
    throw new IOException(""String_Node_Str"" + cd);
  }
  cd.setBinary(compressedBinary);
  return register(cd);
}","ClassDefinition create(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final byte[] binary=getClassDefBinary(compressedBinary);
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  if (cd.getVersion() < 0) {
    throw new IOException(""String_Node_Str"" + cd);
  }
  cd.setBinary(compressedBinary);
  return register(cd);
}",0.8044030482641829
48186,"ClassDefinition register(ClassDefinition cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof ClassDefinitionImpl) {
    final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
    if (cdImpl.getVersion() < 0) {
      cdImpl.version=getVersion();
    }
    if (cdImpl.getBinary() == null) {
      final BufferObjectDataOutput out=serializationService.pop();
      try {
        cdImpl.writeData(out);
        final byte[] binary=out.toByteArray();
        out.clear();
        compress(binary,out);
        cdImpl.setBinary(out.toByteArray());
      }
 catch (      IOException e) {
        throw new HazelcastSerializationException(e);
      }
 finally {
        serializationService.push(out);
      }
    }
    registerNestedDefinitions(cdImpl);
  }
  final long versionedClassId=combineToLong(cd.getClassId(),cd.getVersion());
  final ClassDefinition currentCd=versionedDefinitions.putIfAbsent(versionedClassId,cd);
  if (currentCd == null) {
    return cd;
  }
  if (currentCd instanceof ClassDefinitionImpl) {
    return currentCd;
  }
  versionedDefinitions.put(versionedClassId,cd);
  return cd;
}","ClassDefinition register(ClassDefinition cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof ClassDefinitionImpl) {
    final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
    if (cdImpl.getVersion() < 0) {
      cdImpl.version=getVersion();
    }
    setClassDefBinary(cdImpl);
    registerNestedDefinitions(cdImpl);
  }
  final long versionedClassId=combineToLong(cd.getClassId(),cd.getVersion());
  final ClassDefinition currentCd=versionedDefinitions.putIfAbsent(versionedClassId,cd);
  if (currentCd == null) {
    return cd;
  }
  if (currentCd instanceof ClassDefinitionImpl) {
    return currentCd;
  }
  versionedDefinitions.put(versionedClassId,cd);
  return cd;
}",0.7442116868798236
48187,"Portable read(ObjectDataInput in,int factoryId,int classId,int version) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(classId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + classId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  Integer currentVersion=context.getClassVersion(factoryId,classId);
  if (currentVersion == null) {
    currentVersion=PortableVersionHelper.getVersion(portable,context.getVersion());
    if (currentVersion > 0) {
      context.setClassVersion(factoryId,classId,currentVersion);
    }
  }
  if (version < 0) {
    version=context.getVersion();
  }
  cd=context.lookup(factoryId,classId,version);
  if (cd == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ classId+ ""String_Node_Str""+ version);
  }
  if (currentVersion == version) {
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}","Portable read(ObjectDataInput in,int factoryId,int classId,int version) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(classId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + classId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  int effectiveVersion=version;
  if (version < 0) {
    effectiveVersion=context.getVersion();
  }
  int currentVersion=context.getClassVersion(factoryId,classId);
  if (currentVersion < 0) {
    currentVersion=PortableVersionHelper.getVersion(portable,context.getVersion());
    if (currentVersion > 0) {
      context.setClassVersion(factoryId,classId,currentVersion);
    }
  }
  cd=context.lookup(factoryId,classId,effectiveVersion);
  if (cd == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ classId+ ""String_Node_Str""+ effectiveVersion);
  }
  if (currentVersion == effectiveVersion) {
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}",0.793713163064833
48188,"private ClassDefinition lookupClassDefinition(Portable portable){
  final int version=PortableVersionHelper.getVersion(portable,serializationContext.version);
  return serializationContext.lookup(portable.getFactoryId(),portable.getClassId(),version);
}","private ClassDefinition lookupClassDefinition(Portable portable){
  final int version=PortableVersionHelper.getVersion(portable,serializationContext.getVersion());
  return serializationContext.lookup(portable.getFactoryId(),portable.getClassId(),version);
}",0.9628180039138944
48189,"protected final ClientContext getContext(){
  final ClientContext ctx=context;
  if (ctx == null) {
    throw new HazelcastInstanceNotActiveException();
  }
  return context;
}","protected final ClientContext getContext(){
  final ClientContext ctx=context;
  if (ctx == null) {
    throw new HazelcastInstanceNotActiveException();
  }
  return ctx;
}",0.9885057471264368
48190,"protected final ClientContext getContext(){
  final ClientContext ctx=context;
  if (ctx == null) {
    throw new HazelcastInstanceNotActiveException();
  }
  return context;
}","protected final ClientContext getContext(){
  final ClientContext ctx=context;
  if (ctx == null) {
    throw new HazelcastInstanceNotActiveException();
  }
  return ctx;
}",0.9885057471264368
48191,"public MultiReplicationMessage(String name,ReplicationMessage[] replicationMessages){
  this.name=name;
  this.replicationMessages=replicationMessages;
}","@SuppressWarnings(""String_Node_Str"") public MultiReplicationMessage(String name,ReplicationMessage[] replicationMessages){
  this.name=name;
  this.replicationMessages=replicationMessages;
}",0.892128279883382
48192,"public ReplicationMessage[] getReplicationMessages(){
  return replicationMessages;
}","@SuppressWarnings(""String_Node_Str"") public ReplicationMessage[] getReplicationMessages(){
  return replicationMessages;
}",0.821256038647343
48193,"public ReplicatedMapInitChunkOperation(String name,Member origin,ReplicatedRecord[] replicatedRecords,int recordCount,boolean finalChunk){
  this.name=name;
  this.origin=origin;
  this.replicatedRecords=replicatedRecords;
  this.recordCount=recordCount;
  this.finalChunk=finalChunk;
}","@SuppressWarnings(""String_Node_Str"") public ReplicatedMapInitChunkOperation(String name,Member origin,ReplicatedRecord[] replicatedRecords,int recordCount,boolean finalChunk){
  this.name=name;
  this.origin=origin;
  this.replicatedRecords=replicatedRecords;
  this.recordCount=recordCount;
  this.finalChunk=finalChunk;
}",0.9392446633825944
48194,"public ReplicatedMapPostJoinOperation(MemberMapPair[] replicatedMaps,int chunkSize){
  this.replicatedMaps=replicatedMaps;
  this.chunkSize=chunkSize;
}","public ReplicatedMapPostJoinOperation(MemberMapPair[] replicatedMaps,int chunkSize){
  this.replicatedMaps=Arrays.copyOf(replicatedMaps,replicatedMaps.length);
  this.chunkSize=chunkSize;
}",0.8914956011730205
48195,"public static Collection<InetSocketAddress> getSocketAddresses(String address){
  final AddressHolder addressHolder=AddressUtil.getAddressHolder(address,-1);
  final String scopedAddress=addressHolder.scopeId != null ? addressHolder.address + ""String_Node_Str"" + addressHolder.scopeId : addressHolder.address;
  InetAddress inetAddress=null;
  try {
    inetAddress=InetAddress.getByName(scopedAddress);
  }
 catch (  UnknownHostException ignored) {
  }
  return getPossibleSocketAddresses(inetAddress,addressHolder.port,scopedAddress);
}","public static Collection<InetSocketAddress> getSocketAddresses(String address){
  final AddressHolder addressHolder=AddressUtil.getAddressHolder(address,-1);
  final String scopedAddress=addressHolder.getScopeId() != null ? addressHolder.getAddress() + ""String_Node_Str"" + addressHolder.getScopeId() : addressHolder.getAddress();
  InetAddress inetAddress=null;
  try {
    inetAddress=InetAddress.getByName(scopedAddress);
  }
 catch (  UnknownHostException ignored) {
    Logger.getLogger(AddressHelper.class).finest(""String_Node_Str"",ignored);
  }
  return getPossibleSocketAddresses(inetAddress,addressHolder.getPort(),scopedAddress);
}",0.8794567062818336
48196,"public static Collection<InetSocketAddress> getPossibleSocketAddresses(InetAddress inetAddress,int port,String scopedAddress){
  int portTryCount=1;
  if (port == -1) {
    portTryCount=MAX_PORT_TRIES;
    port=5701;
  }
  final Collection<InetSocketAddress> socketAddresses=new LinkedList<InetSocketAddress>();
  if (inetAddress == null) {
    for (int i=0; i < portTryCount; i++) {
      socketAddresses.add(new InetSocketAddress(scopedAddress,port + i));
    }
  }
 else   if (inetAddress instanceof Inet4Address) {
    for (int i=0; i < portTryCount; i++) {
      socketAddresses.add(new InetSocketAddress(inetAddress,port + i));
    }
  }
 else   if (inetAddress instanceof Inet6Address) {
    final Collection<Inet6Address> addresses=getPossibleInetAddressesFor((Inet6Address)inetAddress);
    for (    Inet6Address inet6Address : addresses) {
      for (int i=0; i < portTryCount; i++) {
        socketAddresses.add(new InetSocketAddress(inet6Address,port + i));
      }
    }
  }
  return socketAddresses;
}","public static Collection<InetSocketAddress> getPossibleSocketAddresses(InetAddress inetAddress,int port,String scopedAddress){
  int possiblePort=port;
  int portTryCount=1;
  if (possiblePort == -1) {
    portTryCount=MAX_PORT_TRIES;
    possiblePort=INITIAL_FIRST_PORT;
  }
  final Collection<InetSocketAddress> socketAddresses=new LinkedList<InetSocketAddress>();
  if (inetAddress == null) {
    for (int i=0; i < portTryCount; i++) {
      socketAddresses.add(new InetSocketAddress(scopedAddress,possiblePort + i));
    }
  }
 else   if (inetAddress instanceof Inet4Address) {
    for (int i=0; i < portTryCount; i++) {
      socketAddresses.add(new InetSocketAddress(inetAddress,possiblePort + i));
    }
  }
 else   if (inetAddress instanceof Inet6Address) {
    final Collection<Inet6Address> addresses=getPossibleInetAddressesFor((Inet6Address)inetAddress);
    for (    Inet6Address inet6Address : addresses) {
      for (int i=0; i < portTryCount; i++) {
        socketAddresses.add(new InetSocketAddress(inet6Address,possiblePort + i));
      }
    }
  }
  return socketAddresses;
}",0.9559032716927454
48197,"@Override public Future<V> removeAsync(final K key){
  final Data keyData=toData(key);
  MapRemoveRequest request=new MapRemoveRequest(name,keyData,ThreadUtil.getThreadId());
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Future<V> removeAsync(final K key){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapRemoveRequest request=new MapRemoveRequest(name,keyData,ThreadUtil.getThreadId());
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9651416122004356
48198,"@Override public V replace(K key,V value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapReplaceRequest request=new MapReplaceRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  return invoke(request,keyData);
}","@Override public V replace(K key,V value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapReplaceRequest request=new MapReplaceRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  return invoke(request,keyData);
}",0.9398496240601504
48199,"@Override public void putTransient(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutTransientRequest request=new MapPutTransientRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  invoke(request);
}","@Override public void putTransient(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutTransientRequest request=new MapPutTransientRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  invoke(request);
}",0.950920245398773
48200,"@Override public V put(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}","@Override public V put(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}",0.9485530546623794
48201,"@Override public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapTryPutRequest request=new MapTryPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapTryPutRequest request=new MapTryPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}",0.9545454545454546
48202,"@Override public void delete(Object key){
  final Data keyData=toData(key);
  MapDeleteRequest request=new MapDeleteRequest(name,keyData,ThreadUtil.getThreadId());
  invoke(request,keyData);
}","@Override public void delete(Object key){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapDeleteRequest request=new MapDeleteRequest(name,keyData,ThreadUtil.getThreadId());
  invoke(request,keyData);
}",0.9230769230769232
48203,"@Override public boolean remove(Object key,Object value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapRemoveIfSameRequest request=new MapRemoveIfSameRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean remove(Object key,Object value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapRemoveIfSameRequest request=new MapRemoveIfSameRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  Boolean result=invoke(request,keyData);
  return result;
}",0.9493670886075948
48204,"@Override public Future<V> putAsync(final K key,final V value,final long ttl,final TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Future<V> putAsync(final K key,final V value,final long ttl,final TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9724612736660928
48205,"@Override public boolean tryRemove(K key,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  MapTryRemoveRequest request=new MapTryRemoveRequest(name,keyData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean tryRemove(K key,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapTryRemoveRequest request=new MapTryRemoveRequest(name,keyData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}",0.9475409836065574
48206,"@Override public void putAll(Map<? extends K,? extends V> m){
  MapEntrySet entrySet=new MapEntrySet();
  for (  Entry<? extends K,? extends V> entry : m.entrySet()) {
    entrySet.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(toData(entry.getKey()),toData(entry.getValue())));
  }
  MapPutAllRequest request=new MapPutAllRequest(name,entrySet);
  invoke(request);
}","@Override public void putAll(Map<? extends K,? extends V> m){
  MapEntrySet entrySet=new MapEntrySet();
  for (  Entry<? extends K,? extends V> entry : m.entrySet()) {
    final Data keyData=toData(entry.getKey());
    invalidateNearCache(keyData);
    entrySet.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(keyData,toData(entry.getValue())));
  }
  MapPutAllRequest request=new MapPutAllRequest(name,entrySet);
  invoke(request);
}",0.8641975308641975
48207,"@Override public V putIfAbsent(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutIfAbsentRequest request=new MapPutIfAbsentRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}","@Override public V putIfAbsent(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutIfAbsentRequest request=new MapPutIfAbsentRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}",0.9522388059701492
48208,"@Override public Future<V> removeAsync(final K key){
  final Data keyData=toData(key);
  MapRemoveRequest request=new MapRemoveRequest(name,keyData,ThreadUtil.getThreadId());
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Future<V> removeAsync(final K key){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapRemoveRequest request=new MapRemoveRequest(name,keyData,ThreadUtil.getThreadId());
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9651416122004356
48209,"@Override public V replace(K key,V value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapReplaceRequest request=new MapReplaceRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  return invoke(request,keyData);
}","@Override public V replace(K key,V value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapReplaceRequest request=new MapReplaceRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  return invoke(request,keyData);
}",0.9398496240601504
48210,"@Override public void putTransient(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutTransientRequest request=new MapPutTransientRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  invoke(request);
}","@Override public void putTransient(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutTransientRequest request=new MapPutTransientRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  invoke(request);
}",0.950920245398773
48211,"@Override public V put(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}","@Override public V put(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}",0.9485530546623794
48212,"@Override public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapTryPutRequest request=new MapTryPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapTryPutRequest request=new MapTryPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}",0.9545454545454546
48213,"@Override public void delete(Object key){
  final Data keyData=toData(key);
  MapDeleteRequest request=new MapDeleteRequest(name,keyData,ThreadUtil.getThreadId());
  invoke(request,keyData);
}","@Override public void delete(Object key){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapDeleteRequest request=new MapDeleteRequest(name,keyData,ThreadUtil.getThreadId());
  invoke(request,keyData);
}",0.9230769230769232
48214,"@Override public boolean remove(Object key,Object value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapRemoveIfSameRequest request=new MapRemoveIfSameRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean remove(Object key,Object value){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapRemoveIfSameRequest request=new MapRemoveIfSameRequest(name,keyData,valueData,ThreadUtil.getThreadId());
  Boolean result=invoke(request,keyData);
  return result;
}",0.9493670886075948
48215,"@Override public Future<V> putAsync(final K key,final V value,final long ttl,final TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Future<V> putAsync(final K key,final V value,final long ttl,final TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutRequest request=new MapPutRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  try {
    final ICompletableFuture future=getContext().getInvocationService().invokeOnKeyOwner(request,keyData);
    return new DelegatingFuture<V>(future,getContext().getSerializationService());
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9724612736660928
48216,"@Override public boolean tryRemove(K key,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  MapTryRemoveRequest request=new MapTryRemoveRequest(name,keyData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}","@Override public boolean tryRemove(K key,long timeout,TimeUnit timeunit){
  final Data keyData=toData(key);
  invalidateNearCache(keyData);
  MapTryRemoveRequest request=new MapTryRemoveRequest(name,keyData,ThreadUtil.getThreadId(),timeunit.toMillis(timeout));
  Boolean result=invoke(request,keyData);
  return result;
}",0.9475409836065574
48217,"@Override public void putAll(Map<? extends K,? extends V> m){
  MapEntrySet entrySet=new MapEntrySet();
  for (  Entry<? extends K,? extends V> entry : m.entrySet()) {
    entrySet.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(toData(entry.getKey()),toData(entry.getValue())));
  }
  MapPutAllRequest request=new MapPutAllRequest(name,entrySet);
  invoke(request);
}","@Override public void putAll(Map<? extends K,? extends V> m){
  MapEntrySet entrySet=new MapEntrySet();
  for (  Entry<? extends K,? extends V> entry : m.entrySet()) {
    final Data keyData=toData(entry.getKey());
    invalidateNearCache(keyData);
    entrySet.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(keyData,toData(entry.getValue())));
  }
  MapPutAllRequest request=new MapPutAllRequest(name,entrySet);
  invoke(request);
}",0.8641975308641975
48218,"@Override public V putIfAbsent(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  MapPutIfAbsentRequest request=new MapPutIfAbsentRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}","@Override public V putIfAbsent(K key,V value,long ttl,TimeUnit timeunit){
  final Data keyData=toData(key);
  final Data valueData=toData(value);
  invalidateNearCache(keyData);
  MapPutIfAbsentRequest request=new MapPutIfAbsentRequest(name,keyData,valueData,ThreadUtil.getThreadId(),getTimeInMillis(ttl,timeunit));
  return invoke(request,keyData);
}",0.9522388059701492
48219,"public static void notifyRemoteException(JobSupervisor supervisor,Throwable throwable){
  String name=supervisor.getConfiguration().getName();
  String jobId=supervisor.getConfiguration().getJobId();
  NotifyRemoteExceptionOperation operation=new NotifyRemoteExceptionOperation(name,jobId,throwable);
  MapReduceService mapReduceService=supervisor.getMapReduceService();
  NodeEngine nodeEngine=mapReduceService.getNodeEngine();
  OperationService os=nodeEngine.getOperationService();
  Address jobOwner=supervisor.getJobOwner();
  os.send(operation,jobOwner);
}","public static void notifyRemoteException(JobSupervisor supervisor,Throwable throwable){
  MapReduceService mapReduceService=supervisor.getMapReduceService();
  NodeEngine nodeEngine=mapReduceService.getNodeEngine();
  try {
    Address jobOwner=supervisor.getJobOwner();
    if (supervisor.isOwnerNode()) {
      supervisor.notifyRemoteException(jobOwner,throwable);
    }
 else {
      String name=supervisor.getConfiguration().getName();
      String jobId=supervisor.getConfiguration().getJobId();
      NotifyRemoteExceptionOperation operation=new NotifyRemoteExceptionOperation(name,jobId,throwable);
      OperationService os=nodeEngine.getOperationService();
      os.send(operation,jobOwner);
    }
  }
 catch (  Exception e) {
    ILogger logger=nodeEngine.getLogger(MapReduceUtil.class);
    logger.warning(""String_Node_Str"",e);
  }
}",0.337126600284495
48220,"public static void notifyRemoteException(JobSupervisor supervisor,Throwable throwable){
  String name=supervisor.getConfiguration().getName();
  String jobId=supervisor.getConfiguration().getJobId();
  NotifyRemoteExceptionOperation operation=new NotifyRemoteExceptionOperation(name,jobId,throwable);
  MapReduceService mapReduceService=supervisor.getMapReduceService();
  NodeEngine nodeEngine=mapReduceService.getNodeEngine();
  OperationService os=nodeEngine.getOperationService();
  Address jobOwner=supervisor.getJobOwner();
  os.send(operation,jobOwner);
}","public static void notifyRemoteException(JobSupervisor supervisor,Throwable throwable){
  MapReduceService mapReduceService=supervisor.getMapReduceService();
  NodeEngine nodeEngine=mapReduceService.getNodeEngine();
  try {
    Address jobOwner=supervisor.getJobOwner();
    if (supervisor.isOwnerNode()) {
      supervisor.notifyRemoteException(jobOwner,throwable);
    }
 else {
      String name=supervisor.getConfiguration().getName();
      String jobId=supervisor.getConfiguration().getJobId();
      NotifyRemoteExceptionOperation operation=new NotifyRemoteExceptionOperation(name,jobId,throwable);
      OperationService os=nodeEngine.getOperationService();
      os.send(operation,jobOwner);
    }
  }
 catch (  Exception e) {
    ILogger logger=nodeEngine.getLogger(MapReduceUtil.class);
    logger.warning(""String_Node_Str"",e);
  }
}",0.337126600284495
48221,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=parse(factoryId,classLoader);
  final ClassLoader hazelcastClassLoader=ServiceLoader.class.getClassLoader();
  if (hazelcastClassLoader != classLoader) {
    final Set<ServiceDefinition> systemDefinitions=parse(factoryId,hazelcastClassLoader);
    serviceDefinitions.addAll(systemDefinitions);
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Set<ClassLoader> classLoaders=selectClassLoaders(classLoader);
  final Set<URLDefinition> factoryUrls=new HashSet<URLDefinition>();
  for (  ClassLoader selectedClassLoader : classLoaders) {
    factoryUrls.addAll(collectFactoryUrls(factoryId,selectedClassLoader));
  }
  final Set<ServiceDefinition> serviceDefinitions=new HashSet<ServiceDefinition>();
  for (  URLDefinition urlDefinition : factoryUrls) {
    serviceDefinitions.addAll(parse(urlDefinition));
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.7443637753152464
48222,"public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iter=iterator(clazz,factoryId,classLoader);
  if (iter.hasNext()) {
    return iter.next();
  }
  return null;
}","public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iterator=iterator(clazz,factoryId,classLoader);
  if (iterator.hasNext()) {
    return iterator.next();
  }
  return null;
}",0.9747899159663864
48223,"@Override public int hashCode(){
  return className != null ? className.hashCode() : 0;
}","@Override public int hashCode(){
  int result=url != null ? url.hashCode() : 0;
  result=31 * result + (classLoader != null ? classLoader.hashCode() : 0);
  return result;
}",0.5419847328244275
48224,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  ServiceDefinition that=(ServiceDefinition)o;
  if (className != null ? !className.equals(that.className) : that.className != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  URLDefinition that=(URLDefinition)o;
  if (classLoader != null ? !classLoader.equals(that.classLoader) : that.classLoader != null) {
    return false;
  }
  if (url != null ? !url.equals(that.url) : that.url != null) {
    return false;
  }
  return true;
}",0.5586592178770949
48225,"private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,cl));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  return Collections.emptySet();
}","private static Set<ServiceDefinition> parse(URLDefinition urlDefinition){
  try {
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    BufferedReader r=null;
    try {
      URL url=urlDefinition.url;
      r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
      while (true) {
        String line=r.readLine();
        if (line == null) {
          break;
        }
        int comment=line.indexOf('#');
        if (comment >= 0) {
          line=line.substring(0,comment);
        }
        String name=line.trim();
        if (name.length() == 0) {
          continue;
        }
        names.add(new ServiceDefinition(name,urlDefinition.classLoader));
      }
    }
  finally {
      IOUtil.closeResource(r);
    }
    return names;
  }
 catch (  Exception e) {
    LOGGER.severe(e);
  }
  return Collections.emptySet();
}",0.4761037778789258
48226,"private ServiceDefinition(String className,ClassLoader classLoader){
  this.className=className;
  this.classLoader=classLoader;
}","private ServiceDefinition(String className,ClassLoader classLoader){
  ValidationUtil.isNotNull(className,""String_Node_Str"");
  ValidationUtil.isNotNull(classLoader,""String_Node_Str"");
  this.className=className;
  this.classLoader=classLoader;
}",0.6914893617021277
48227,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=parse(factoryId,classLoader);
  final ClassLoader hazelcastClassLoader=ServiceLoader.class.getClassLoader();
  if (hazelcastClassLoader != classLoader) {
    final Set<ServiceDefinition> systemDefinitions=parse(factoryId,hazelcastClassLoader);
    serviceDefinitions.addAll(systemDefinitions);
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=new HashSet<ServiceDefinition>();
  final Set<ClassLoader> classLoaders=selectClassLoaders(classLoader);
  for (  ClassLoader selectedClassLoader : classLoaders) {
    serviceDefinitions.addAll(parse(factoryId,selectedClassLoader));
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.8029617441382148
48228,"public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iter=iterator(clazz,factoryId,classLoader);
  if (iter.hasNext()) {
    return iter.next();
  }
  return null;
}","public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iterator=iterator(clazz,factoryId,classLoader);
  if (iterator.hasNext()) {
    return iterator.next();
  }
  return null;
}",0.9747899159663864
48229,"@Override public int hashCode(){
  return className != null ? className.hashCode() : 0;
}","@Override public int hashCode(){
  int result=className.hashCode();
  result=31 * result + classLoader.hashCode();
  return result;
}",0.5855855855855856
48230,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  ServiceDefinition that=(ServiceDefinition)o;
  if (className != null ? !className.equals(that.className) : that.className != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  ServiceDefinition that=(ServiceDefinition)o;
  if (!classLoader.equals(that.classLoader)) {
    return false;
  }
  if (!className.equals(that.className)) {
    return false;
  }
  return true;
}",0.5504587155963303
48231,"private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,cl));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  return Collections.emptySet();
}","private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (classLoader != null) {
      configs=classLoader.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,classLoader));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    LOGGER.severe(e);
  }
  return Collections.emptySet();
}",0.9419152276295132
48232,"private ServiceDefinition(String className,ClassLoader classLoader){
  this.className=className;
  this.classLoader=classLoader;
}","private ServiceDefinition(String className,ClassLoader classLoader){
  ValidationUtil.isNotNull(className,""String_Node_Str"");
  ValidationUtil.isNotNull(classLoader,""String_Node_Str"");
  this.className=className;
  this.classLoader=classLoader;
}",0.6914893617021277
48233,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=parse(factoryId,classLoader);
  final ClassLoader hazelcastClassLoader=ServiceLoader.class.getClassLoader();
  if (hazelcastClassLoader != classLoader) {
    final Set<ServiceDefinition> systemDefinitions=parse(factoryId,hazelcastClassLoader);
    serviceDefinitions.addAll(systemDefinitions);
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Set<ClassLoader> classLoaders=selectClassLoaders(classLoader);
  final Set<URLDefinition> factoryUrls=new HashSet<URLDefinition>();
  for (  ClassLoader selectedClassLoader : classLoaders) {
    factoryUrls.addAll(collectFactoryUrls(factoryId,selectedClassLoader));
  }
  final Set<ServiceDefinition> serviceDefinitions=new HashSet<ServiceDefinition>();
  for (  URLDefinition urlDefinition : factoryUrls) {
    serviceDefinitions.addAll(parse(urlDefinition));
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.7443637753152464
48234,"public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iter=iterator(clazz,factoryId,classLoader);
  if (iter.hasNext()) {
    return iter.next();
  }
  return null;
}","public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iterator=iterator(clazz,factoryId,classLoader);
  if (iterator.hasNext()) {
    return iterator.next();
  }
  return null;
}",0.9747899159663864
48235,"@Override public int hashCode(){
  return className != null ? className.hashCode() : 0;
}","@Override public int hashCode(){
  int result=url != null ? url.hashCode() : 0;
  result=31 * result + (classLoader != null ? classLoader.hashCode() : 0);
  return result;
}",0.5419847328244275
48236,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  ServiceDefinition that=(ServiceDefinition)o;
  if (className != null ? !className.equals(that.className) : that.className != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  URLDefinition that=(URLDefinition)o;
  if (classLoader != null ? !classLoader.equals(that.classLoader) : that.classLoader != null) {
    return false;
  }
  if (url != null ? !url.equals(that.url) : that.url != null) {
    return false;
  }
  return true;
}",0.5586592178770949
48237,"private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,cl));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  return Collections.emptySet();
}","private static Set<ServiceDefinition> parse(URLDefinition urlDefinition){
  try {
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    BufferedReader r=null;
    try {
      URL url=urlDefinition.url;
      r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
      while (true) {
        String line=r.readLine();
        if (line == null) {
          break;
        }
        int comment=line.indexOf('#');
        if (comment >= 0) {
          line=line.substring(0,comment);
        }
        String name=line.trim();
        if (name.length() == 0) {
          continue;
        }
        names.add(new ServiceDefinition(name,urlDefinition.classLoader));
      }
    }
  finally {
      IOUtil.closeResource(r);
    }
    return names;
  }
 catch (  Exception e) {
    LOGGER.severe(e);
  }
  return Collections.emptySet();
}",0.4761037778789258
48238,"private ServiceDefinition(String className,ClassLoader classLoader){
  this.className=className;
  this.classLoader=classLoader;
}","private ServiceDefinition(String className,ClassLoader classLoader){
  ValidationUtil.isNotNull(className,""String_Node_Str"");
  ValidationUtil.isNotNull(classLoader,""String_Node_Str"");
  this.className=className;
  this.classLoader=classLoader;
}",0.6914893617021277
48239,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=parse(factoryId,classLoader);
  final ClassLoader hazelcastClassLoader=ServiceLoader.class.getClassLoader();
  if (hazelcastClassLoader != classLoader) {
    final Set<ServiceDefinition> systemDefinitions=parse(factoryId,hazelcastClassLoader);
    serviceDefinitions.addAll(systemDefinitions);
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> serviceDefinitions=new HashSet<ServiceDefinition>();
  final Set<ClassLoader> classLoaders=selectClassLoaders(classLoader);
  for (  ClassLoader selectedClassLoader : classLoaders) {
    serviceDefinitions.addAll(parse(factoryId,selectedClassLoader));
  }
  if (serviceDefinitions.isEmpty()) {
    Logger.getLogger(ServiceLoader.class).warning(""String_Node_Str"" + factoryId + ""String_Node_Str"");
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> iterator=serviceDefinitions.iterator();
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public T next(){
      final ServiceDefinition definition=iterator.next();
      try {
        String className=definition.className;
        ClassLoader classLoader=definition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.8029617441382148
48240,"public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iter=iterator(clazz,factoryId,classLoader);
  if (iter.hasNext()) {
    return iter.next();
  }
  return null;
}","public static <T>T load(Class<T> clazz,String factoryId,ClassLoader classLoader) throws Exception {
  final Iterator<T> iterator=iterator(clazz,factoryId,classLoader);
  if (iterator.hasNext()) {
    return iterator.next();
  }
  return null;
}",0.9747899159663864
48241,"@Override public int hashCode(){
  return className != null ? className.hashCode() : 0;
}","@Override public int hashCode(){
  int result=className.hashCode();
  result=31 * result + classLoader.hashCode();
  return result;
}",0.5855855855855856
48242,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  ServiceDefinition that=(ServiceDefinition)o;
  if (className != null ? !className.equals(that.className) : that.className != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  ServiceDefinition that=(ServiceDefinition)o;
  if (!classLoader.equals(that.classLoader)) {
    return false;
  }
  if (!className.equals(that.className)) {
    return false;
  }
  return true;
}",0.5504587155963303
48243,"private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,cl));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  return Collections.emptySet();
}","private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (classLoader != null) {
      configs=classLoader.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,classLoader));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    LOGGER.severe(e);
  }
  return Collections.emptySet();
}",0.9419152276295132
48244,"private ServiceDefinition(String className,ClassLoader classLoader){
  this.className=className;
  this.classLoader=classLoader;
}","private ServiceDefinition(String className,ClassLoader classLoader){
  ValidationUtil.isNotNull(className,""String_Node_Str"");
  ValidationUtil.isNotNull(classLoader,""String_Node_Str"");
  this.className=className;
  this.classLoader=classLoader;
}",0.6914893617021277
48245,"public Collection values(Predicate predicate){
  checkTransactionState();
  if (predicate == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final MapService service=getService();
  final QueryResultSet queryResultSet=(QueryResultSet)queryInternal(predicate,IterationType.VALUE,false);
  final Set<Object> valueSet=new HashSet<Object>(queryResultSet);
  for (  final Map.Entry<Object,TxnValueWrapper> entry : txMap.entrySet()) {
    if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {
      final Object value=entry.getValue().value instanceof Data ? service.toObject(entry.getValue().value) : entry.getValue().value;
      final QueryEntry queryEntry=new QueryEntry(null,service.toData(entry.getKey()),entry.getKey(),value);
      if (predicate.apply(queryEntry)) {
        valueSet.add(entry.getValue().value);
      }
    }
 else {
      valueSet.remove(entry.getValue());
    }
  }
  return valueSet;
}","public Collection values(Predicate predicate){
  checkTransactionState();
  if (predicate == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final MapService service=getService();
  final QueryResultSet queryResultSet=(QueryResultSet)queryInternal(predicate,IterationType.VALUE,false);
  final Set<Object> valueSet=new HashSet<Object>(queryResultSet);
  for (  final Map.Entry<Object,TxnValueWrapper> entry : txMap.entrySet()) {
    if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {
      final Object value=entry.getValue().value instanceof Data ? service.toObject(entry.getValue().value) : entry.getValue().value;
      final QueryEntry queryEntry=new QueryEntry(null,service.toData(entry.getKey()),entry.getKey(),value);
      if (predicate.apply(queryEntry)) {
        valueSet.add(entry.getValue().value);
      }
    }
 else {
      valueSet.remove(entry.getValue().value);
    }
  }
  return valueSet;
}",0.9968253968253968
48246,"public Boolean execute(TransactionalTaskContext context) throws TransactionException {
  final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
  assertEquals(0,txMap.values(new SqlPredicate(""String_Node_Str"")).size());
  txMap.put(2,emp2);
  Collection coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  Iterator<Object> iterator=coll.iterator();
  while (iterator.hasNext()) {
    final SampleObjects.Employee e=(SampleObjects.Employee)iterator.next();
    assertEquals(emp2,e);
  }
  coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  iterator=coll.iterator();
  while (iterator.hasNext()) {
    final SampleObjects.Employee e=(SampleObjects.Employee)iterator.next();
    assertEquals(emp1,e);
  }
  txMap.remove(2);
  coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(0,coll.size());
  return true;
}","public Boolean execute(TransactionalTaskContext context) throws TransactionException {
  final TransactionalMap<Object,Object> txMap=context.getMap(mapName);
  txMap.remove(1);
  Collection<Object> coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(0,coll.size());
  return true;
}",0.486254295532646
48247,"public Collection values(Predicate predicate){
  checkTransactionState();
  if (predicate == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final MapService service=getService();
  final QueryResultSet queryResultSet=(QueryResultSet)queryInternal(predicate,IterationType.VALUE,false);
  final Set<Object> valueSet=new HashSet<Object>(queryResultSet);
  for (  final Map.Entry<Object,TxnValueWrapper> entry : txMap.entrySet()) {
    if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {
      final Object value=entry.getValue().value instanceof Data ? service.toObject(entry.getValue().value) : entry.getValue().value;
      final QueryEntry queryEntry=new QueryEntry(null,service.toData(entry.getKey()),entry.getKey(),value);
      if (predicate.apply(queryEntry)) {
        valueSet.add(entry.getValue().value);
      }
    }
 else {
      valueSet.remove(entry.getValue());
    }
  }
  return valueSet;
}","public Collection values(Predicate predicate){
  checkTransactionState();
  if (predicate == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final MapService service=getService();
  final QueryResultSet queryResultSet=(QueryResultSet)queryInternal(predicate,IterationType.VALUE,false);
  final Set<Object> valueSet=new HashSet<Object>(queryResultSet);
  for (  final Map.Entry<Object,TxnValueWrapper> entry : txMap.entrySet()) {
    if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {
      final Object value=entry.getValue().value instanceof Data ? service.toObject(entry.getValue().value) : entry.getValue().value;
      final QueryEntry queryEntry=new QueryEntry(null,service.toData(entry.getKey()),entry.getKey(),value);
      if (predicate.apply(queryEntry)) {
        valueSet.add(entry.getValue().value);
      }
    }
 else {
      valueSet.remove(entry.getValue().value);
    }
  }
  return valueSet;
}",0.9968253968253968
48248,"public Boolean execute(TransactionalTaskContext context) throws TransactionException {
  final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
  assertEquals(0,txMap.values(new SqlPredicate(""String_Node_Str"")).size());
  txMap.put(2,emp2);
  Collection coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  Iterator<Object> iterator=coll.iterator();
  while (iterator.hasNext()) {
    final SampleObjects.Employee e=(SampleObjects.Employee)iterator.next();
    assertEquals(emp2,e);
  }
  coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  iterator=coll.iterator();
  while (iterator.hasNext()) {
    final SampleObjects.Employee e=(SampleObjects.Employee)iterator.next();
    assertEquals(emp1,e);
  }
  txMap.remove(2);
  coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(0,coll.size());
  return true;
}","public Boolean execute(TransactionalTaskContext context) throws TransactionException {
  final TransactionalMap<Object,Object> txMap=context.getMap(mapName);
  txMap.remove(1);
  Collection<Object> coll=txMap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(0,coll.size());
  return true;
}",0.486254295532646
48249,"@Test public void testSubmitToKeyOwnerCallable() throws Exception {
  final int k=simpleTestNodeCount;
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(new Config());
  final AtomicInteger count=new AtomicInteger(0);
  final CountDownLatch latch=new CountDownLatch(k / 2);
  final ExecutionCallback callback=new ExecutionCallback(){
    public void onResponse(    Object response){
      if ((Boolean)response)       count.incrementAndGet();
      latch.countDown();
    }
    public void onFailure(    Throwable t){
    }
  }
;
  for (int i=0; i < k; i++) {
    final HazelcastInstance instance=instances[i];
    final IExecutorService service=instance.getExecutorService(""String_Node_Str"");
    final String script=""String_Node_Str"";
    final HashMap map=new HashMap();
    final Member localMember=instance.getCluster().getLocalMember();
    map.put(""String_Node_Str"",localMember);
    int key=0;
    while (!localMember.equals(instance.getPartitionService().getPartition(++key).getOwner()))     ;
    if (i % 2 == 0) {
      final Future f=service.submitToKeyOwner(new ScriptCallable(script,map),key);
      assertTrue((Boolean)f.get(5,TimeUnit.SECONDS));
    }
 else {
      service.submitToKeyOwner(new ScriptCallable(script,map),key,callback);
    }
  }
  assertTrue(latch.await(30,TimeUnit.SECONDS));
  assertEquals(k / 2,count.get());
}","@Test public void testSubmitToKeyOwnerCallable() throws Exception {
  final int k=simpleTestNodeCount;
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(new Config());
  final AtomicInteger count=new AtomicInteger(0);
  final CountDownLatch latch=new CountDownLatch(k / 2);
  final ExecutionCallback callback=new ExecutionCallback(){
    public void onResponse(    Object response){
      if ((Boolean)response)       count.incrementAndGet();
      latch.countDown();
    }
    public void onFailure(    Throwable t){
    }
  }
;
  for (int i=0; i < k; i++) {
    final HazelcastInstance instance=instances[i];
    final IExecutorService service=instance.getExecutorService(""String_Node_Str"");
    final String script=""String_Node_Str"";
    final HashMap map=new HashMap();
    final Member localMember=instance.getCluster().getLocalMember();
    map.put(""String_Node_Str"",localMember);
    int key=0;
    while (!localMember.equals(instance.getPartitionService().getPartition(++key).getOwner()))     ;
    if (i % 2 == 0) {
      final Future f=service.submitToKeyOwner(new ScriptCallable(script,map),key);
      assertTrue((Boolean)f.get(60,TimeUnit.SECONDS));
    }
 else {
      service.submitToKeyOwner(new ScriptCallable(script,map),key,callback);
    }
  }
  assertOpenEventually(latch);
  assertEquals(k / 2,count.get());
}",0.9831223628691984
48250,"public void lock(K key,long leaseTime,TimeUnit timeUnit){
  final Data keyData=toData(key);
  MultiMapLockRequest request=new MultiMapLockRequest(keyData,ThreadUtil.getThreadId(),getTimeInMillis(leaseTime,timeUnit),-1,name);
  invoke(request,keyData);
}","public void lock(K key,long leaseTime,TimeUnit timeUnit){
  isNotNegative(leaseTime,""String_Node_Str"");
  final Data keyData=toData(key);
  MultiMapLockRequest request=new MultiMapLockRequest(keyData,ThreadUtil.getThreadId(),getTimeInMillis(leaseTime,timeUnit),-1,name);
  invoke(request,keyData);
}",0.9166666666666666
48251,"@Test(expected=NullPointerException.class) @Category(ProblematicTest.class) public void testAddListener_whenListenerNull() throws InterruptedException {
  final MultiMap mm=client.getMultiMap(randomString());
  mm.addEntryListener(null,true);
}","@Test(expected=IllegalArgumentException.class) public void testAddListener_whenListenerNull() throws InterruptedException {
  final MultiMap mm=client.getMultiMap(randomString());
  mm.addEntryListener(null,true);
}",0.8714596949891068
48252,"@Category(ProblematicTest.class) @Test(expected=IllegalArgumentException.class) public void testLockTTL_whenNegativeTimeout() throws Exception {
  final MultiMap mm=client.getMultiMap(randomString());
  final Object key=""String_Node_Str"";
  mm.lock(key,-1,TimeUnit.SECONDS);
}","@Test(expected=IllegalArgumentException.class) public void testLockTTL_whenNegativeTimeout() throws Exception {
  final MultiMap mm=client.getMultiMap(randomString());
  final Object key=""String_Node_Str"";
  mm.lock(key,-1,TimeUnit.SECONDS);
}",0.9364161849710982
48253,"public static void isNotNegative(int permits,String argumentName){
  if (permits < 0) {
    throw new IllegalArgumentException(argumentName + ""String_Node_Str"");
  }
}","public static void isNotNegative(long value,String argumentName){
  if (value < 0) {
    throw new IllegalArgumentException(argumentName + ""String_Node_Str"");
  }
}",0.9244712990936556
48254,"private void increaseRecordEvictionCounter(Record record,MapConfig.EvictionPolicy evictionPolicy){
switch (evictionPolicy) {
case LRU:
    record.setAccessCounter(++lruAccessCounter);
  break;
case LFU:
long lfuCounter=record.getAccessCounter();
record.setAccessCounter(++lfuCounter);
break;
case NONE:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + evictionPolicy + ']');
}
}","private void increaseRecordEvictionCounter(Record record,MapConfig.EvictionPolicy evictionPolicy){
switch (evictionPolicy) {
case LRU:
    record.setAccessCounter(++lruAccessCounter);
  break;
case LFU:
record.setAccessCounter(record.getAccessCounter() + 1L);
break;
case NONE:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + evictionPolicy + ']');
}
}",0.8648648648648649
48255,"public void lock(K key,long leaseTime,TimeUnit timeUnit){
  final Data keyData=toData(key);
  MultiMapLockRequest request=new MultiMapLockRequest(keyData,ThreadUtil.getThreadId(),getTimeInMillis(leaseTime,timeUnit),-1,name);
  invoke(request,keyData);
}","public void lock(K key,long leaseTime,TimeUnit timeUnit){
  isNotNegative(leaseTime,""String_Node_Str"");
  final Data keyData=toData(key);
  MultiMapLockRequest request=new MultiMapLockRequest(keyData,ThreadUtil.getThreadId(),getTimeInMillis(leaseTime,timeUnit),-1,name);
  invoke(request,keyData);
}",0.9166666666666666
48256,"@Test(expected=NullPointerException.class) @Category(ProblematicTest.class) public void testAddListener_whenListenerNull() throws InterruptedException {
  final MultiMap mm=client.getMultiMap(randomString());
  mm.addEntryListener(null,true);
}","@Test(expected=IllegalArgumentException.class) public void testAddListener_whenListenerNull() throws InterruptedException {
  final MultiMap mm=client.getMultiMap(randomString());
  mm.addEntryListener(null,true);
}",0.8714596949891068
48257,"@Category(ProblematicTest.class) @Test(expected=IllegalArgumentException.class) public void testLockTTL_whenNegativeTimeout() throws Exception {
  final MultiMap mm=client.getMultiMap(randomString());
  final Object key=""String_Node_Str"";
  mm.lock(key,-1,TimeUnit.SECONDS);
}","@Test(expected=IllegalArgumentException.class) public void testLockTTL_whenNegativeTimeout() throws Exception {
  final MultiMap mm=client.getMultiMap(randomString());
  final Object key=""String_Node_Str"";
  mm.lock(key,-1,TimeUnit.SECONDS);
}",0.9364161849710982
48258,"public static void isNotNegative(int permits,String argumentName){
  if (permits < 0) {
    throw new IllegalArgumentException(argumentName + ""String_Node_Str"");
  }
}","public static void isNotNegative(long value,String argumentName){
  if (value < 0) {
    throw new IllegalArgumentException(argumentName + ""String_Node_Str"");
  }
}",0.9244712990936556
48259,"public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  setPosition(fieldName);
  final int len=portables == null ? 0 : portables.length;
  out.writeInt(len);
  if (len > 0) {
    final int offset=out.position();
    out.position(offset + len * 4);
    for (int i=0; i < portables.length; i++) {
      out.writeInt(offset + i * 4,out.position());
      final Portable portable=portables[i];
      serializer.write(out,portable);
    }
  }
}","public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  setPosition(fieldName);
  final int len=portables == null ? 0 : portables.length;
  out.writeInt(len);
  if (len > 0) {
    final int offset=out.position();
    out.writeZeroBytes(len * 4);
    for (int i=0; i < portables.length; i++) {
      out.writeInt(offset + i * 4,out.position());
      final Portable portable=portables[i];
      serializer.write(out,portable);
    }
  }
}",0.9652996845425869
48260,"public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    newValue=writeMapStore(dataKey,newValue,null);
    record=mapService.createRecord(name,dataKey,newValue,DEFAULT_TTL);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getCost(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      deleteRecord(dataKey);
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    newValue=writeMapStore(dataKey,newValue,record);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}","public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    newValue=writeMapStore(dataKey,newValue,null);
    record=mapService.createRecord(name,dataKey,newValue,DEFAULT_TTL);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=mapService.createSimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record);
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      deleteRecord(dataKey);
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    newValue=writeMapStore(dataKey,newValue,record);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}",0.9707278481012658
48261,"private void accessRecord(Record record){
  record.onAccess();
  final int maxIdleSeconds=mapContainer.getMapConfig().getMaxIdleSeconds();
  if (maxIdleSeconds > 0) {
    mapService.scheduleIdleEviction(name,record.getKey(),TimeUnit.SECONDS.toMillis(maxIdleSeconds));
  }
}","private void accessRecord(Record record){
  increaseRecordEvictionCounter(record,mapContainer.getMapConfig().getEvictionPolicy());
  record.onAccess();
  final int maxIdleSeconds=mapContainer.getMapConfig().getMaxIdleSeconds();
  if (maxIdleSeconds > 0) {
    mapService.scheduleIdleEviction(name,record.getKey(),TimeUnit.SECONDS.toMillis(maxIdleSeconds));
  }
}",0.8598425196850393
48262,"public void clearPartition(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  cancelAssociatedSchedulers(records.keySet());
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void clearPartition(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  cancelAssociatedSchedulers(records.keySet());
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  resetAccessCounter();
}",0.9801324503311258
48263,"public void reset(){
  checkIfLoaded();
  cancelAssociatedSchedulers(records.keySet());
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void reset(){
  checkIfLoaded();
  cancelAssociatedSchedulers(records.keySet());
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  resetAccessCounter();
}",0.9337016574585636
48264,"public void clear(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Collection<Object> keysObject=new ArrayList<Object>(keysToDelete.size());
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
  cancelAssociatedSchedulers(keysToDelete);
}","public void clear(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Collection<Object> keysObject=new ArrayList<Object>(keysToDelete.size());
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
  cancelAssociatedSchedulers(keysToDelete);
  resetAccessCounter();
}",0.987866531850354
48265,"public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  setPosition(fieldName);
  final int len=portables == null ? 0 : portables.length;
  out.writeInt(len);
  if (len > 0) {
    final int offset=out.position();
    out.position(offset + len * 4);
    for (int i=0; i < portables.length; i++) {
      out.writeInt(offset + i * 4,out.position());
      final Portable portable=portables[i];
      serializer.write(out,portable);
    }
  }
}","public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  setPosition(fieldName);
  final int len=portables == null ? 0 : portables.length;
  out.writeInt(len);
  if (len > 0) {
    final int offset=out.position();
    out.writeZeroBytes(len * 4);
    for (int i=0; i < portables.length; i++) {
      out.writeInt(offset + i * 4,out.position());
      final Portable portable=portables[i];
      serializer.write(out,portable);
    }
  }
}",0.9652996845425869
48266,"NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}","public NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}",0.9731800766283524
48267,"protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return evictSuccess;
}","protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return evictSuccess;
}",0.9894291754756872
48268,"protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return putSuccessful;
}","protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return putSuccessful;
}",0.992412746585736
48269,"public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateLocalNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9969861362266426
48270,"protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9917627677100496
48271,"protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.99009900990099
48272,"protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9954914337240758
48273,"protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.9917627677100496
48274,"/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateLocalNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9972987574284172
48275,"protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.996078431372549
48276,"protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9848942598187312
48277,"protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.98989898989899
48278,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}",0.998626750892612
48279,"public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateLocalNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9973998959958398
48280,"protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9923664122137404
48281,"protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9911190053285968
48282,"protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return result;
}","protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return result;
}",0.989517819706499
48283,"public Object getFromNearCache(String mapName,Data key){
  NearCache nearCache=getNearCache(mapName);
  return nearCache.get(key);
}","public Object getFromNearCache(String mapName,Data key){
  if (!isNearCacheEnabled(mapName)) {
    return null;
  }
  NearCache nearCache=getNearCache(mapName);
  return nearCache.get(key);
}",0.8173374613003096
48284,"public void invalidateNearCache(String mapName,Set<Data> keys){
  NearCache nearCache=getNearCache(mapName);
  nearCache.invalidate(keys);
}","public void invalidateNearCache(String mapName,Set<Data> keys){
  if (!isNearCacheEnabled(mapName)) {
    return;
  }
  NearCache nearCache=getNearCache(mapName);
  nearCache.invalidate(keys);
}",0.8383233532934131
48285,"public void putNearCache(String mapName,Data key,Data value){
  NearCache nearCache=getNearCache(mapName);
  nearCache.put(key,value);
}","public void putNearCache(String mapName,Data key,Data value){
  if (!isNearCacheEnabled(mapName)) {
    return;
  }
  NearCache nearCache=getNearCache(mapName);
  nearCache.put(key,value);
}",0.8343558282208589
48286,"public void clearNearCache(String mapName){
  final NearCache nearCache=nearCacheMap.get(mapName);
  if (nearCache != null) {
    nearCache.clear();
  }
}","public void clearNearCache(String mapName){
  if (!isNearCacheEnabled(mapName)) {
    return;
  }
  final NearCache nearCache=nearCacheMap.get(mapName);
  if (nearCache != null) {
    nearCache.clear();
  }
}",0.850828729281768
48287,"NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}","public NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}",0.9731800766283524
48288,"public void invalidateAllNearCaches(String mapName,Set<Data> keys){
  if (keys == null || keys.isEmpty())   return;
  Operation operation=new NearCacheKeySetInvalidationOperation(mapName,keys).setServiceName(SERVICE_NAME);
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : members) {
    try {
      if (member.localMember())       continue;
      nodeEngine.getOperationService().send(operation,member.getAddress());
    }
 catch (    Throwable throwable) {
      logger.warning(throwable);
    }
  }
  for (  final Data key : keys) {
    invalidateNearCache(mapName,key);
  }
}","public void invalidateAllNearCaches(String mapName,Set<Data> keys){
  if (!isNearCacheEnabled(mapName)) {
    return;
  }
  if (keys == null || keys.isEmpty()) {
    return;
  }
  Operation operation=new NearCacheKeySetInvalidationOperation(mapName,keys).setServiceName(SERVICE_NAME);
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : members) {
    try {
      if (member.localMember())       continue;
      nodeEngine.getOperationService().send(operation,member.getAddress());
    }
 catch (    Throwable throwable) {
      logger.warning(throwable);
    }
  }
  for (  final Data key : keys) {
    invalidateNearCache(mapName,key);
  }
}",0.953731343283582
48289,"protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return evictSuccess;
}","protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return evictSuccess;
}",0.9894291754756872
48290,"protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return putSuccessful;
}","protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return putSuccessful;
}",0.992412746585736
48291,"public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateLocalNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9969861362266426
48292,"protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9917627677100496
48293,"protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.99009900990099
48294,"protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9954914337240758
48295,"protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.9917627677100496
48296,"/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateLocalNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9972987574284172
48297,"protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.996078431372549
48298,"protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9848942598187312
48299,"protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.98989898989899
48300,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}",0.998626750892612
48301,"public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateLocalNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9973998959958398
48302,"protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9923664122137404
48303,"protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9911190053285968
48304,"protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return result;
}","protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return result;
}",0.989517819706499
48305,"NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}","public NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}",0.9731800766283524
48306,"protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return evictSuccess;
}","protected boolean evictInternal(final Data key){
  EvictOperation operation=new EvictOperation(name,key,false);
  final boolean evictSuccess=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return evictSuccess;
}",0.9894291754756872
48307,"protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return putSuccessful;
}","protected boolean tryPutInternal(final Data key,final Data value,final long timeout,final TimeUnit timeunit){
  TryPutOperation operation=new TryPutOperation(name,key,value,getTimeInMillis(timeout,timeunit));
  boolean putSuccessful=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return putSuccessful;
}",0.992412746585736
48308,"public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateLocalNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9969861362266426
48309,"protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9917627677100496
48310,"protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean removeInternal(final Data key,final Data value){
  RemoveIfSameOperation operation=new RemoveIfSameOperation(name,key,value);
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.99009900990099
48311,"protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> removeAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  RemoveOperation operation=new RemoveOperation(name,key);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9954914337240758
48312,"protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return removed;
}","protected boolean tryRemoveInternal(final Data key,final long timeout,final TimeUnit timeunit){
  TryRemoveOperation operation=new TryRemoveOperation(name,key,getTimeInMillis(timeout,timeunit));
  boolean removed=(Boolean)invokeOperation(key,operation);
  invalidateNearCache(key);
  return removed;
}",0.9917627677100496
48313,"/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateLocalNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","/** 
 * {@link IMap#executeOnEntries(EntryProcessor,Predicate)}
 */
public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9972987574284172
48314,"protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateLocalNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> putAsyncInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  PutOperation operation=new PutOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    ICompletableFuture<Data> future=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    invalidateNearCache(key);
    return future;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.996078431372549
48315,"protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void deleteInternal(Data key){
  RemoveOperation operation=new RemoveOperation(name,key);
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9848942598187312
48316,"protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void setInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  SetOperation operation=new SetOperation(name,key,value,timeunit.toMillis(ttl));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.98989898989899
48317,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(mapService.toObject(key),mapService.toObject(cachedValue));
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}",0.998626750892612
48318,"public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateLocalNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9973998959958398
48319,"protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return previousValue;
}","protected Data putIfAbsentInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutIfAbsentOperation operation=new PutIfAbsentOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  Data previousValue=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return previousValue;
}",0.9923664122137404
48320,"protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateLocalNearCache(key);
}","protected void putTransientInternal(final Data key,final Data value,final long ttl,final TimeUnit timeunit){
  PutTransientOperation operation=new PutTransientOperation(name,key,value,getTimeInMillis(ttl,timeunit));
  invokeOperation(key,operation);
  invalidateNearCache(key);
}",0.9911190053285968
48321,"protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateLocalNearCache(key);
  return result;
}","protected Data replaceInternal(final Data key,final Data value){
  ReplaceOperation operation=new ReplaceOperation(name,key,value);
  final Data result=(Data)invokeOperation(key,operation);
  invalidateNearCache(key);
  return result;
}",0.989517819706499
48322,"public void setAttribute(final String name,final Object value){
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry == null) {
      entry=new LocalCacheEntry();
      localCache.put(name,entry);
    }
    entry.value=value;
    entry.dirty=true;
  }
 else {
    getClusterMap().put(buildAttributeName(name),value);
  }
}","public void setAttribute(final String name,final Object value){
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry == null || entry == NULL_ENTRY) {
      entry=new LocalCacheEntry();
      localCache.put(name,entry);
    }
    entry.value=value;
    entry.dirty=true;
  }
 else {
    getClusterMap().put(buildAttributeName(name),value);
  }
}",0.9784037558685446
48323,"public void removeAttribute(final String name){
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry != null) {
      entry.value=null;
      entry.removed=true;
      entry.dirty=true;
    }
  }
 else {
    getClusterMap().delete(buildAttributeName(name));
  }
}","public void removeAttribute(final String name){
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry != null && entry != NULL_ENTRY) {
      entry.value=null;
      entry.removed=true;
      entry.dirty=true;
    }
  }
 else {
    getClusterMap().delete(buildAttributeName(name));
  }
}",0.9624796084828712
48324,"public void setAttribute(final String name,final Object value){
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry == null) {
      entry=new LocalCacheEntry();
      localCache.put(name,entry);
    }
    entry.value=value;
    entry.dirty=true;
  }
 else {
    getClusterMap().put(buildAttributeName(name),value);
  }
}","public void setAttribute(final String name,final Object value){
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry == null || entry == NULL_ENTRY) {
      entry=new LocalCacheEntry();
      localCache.put(name,entry);
    }
    entry.value=value;
    entry.dirty=true;
  }
 else {
    getClusterMap().put(buildAttributeName(name),value);
  }
}",0.9784037558685446
48325,"public void removeAttribute(final String name){
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry != null) {
      entry.value=null;
      entry.removed=true;
      entry.dirty=true;
    }
  }
 else {
    getClusterMap().delete(buildAttributeName(name));
  }
}","public void removeAttribute(final String name){
  if (deferredWrite) {
    LocalCacheEntry entry=localCache.get(name);
    if (entry != null && entry != NULL_ENTRY) {
      entry.value=null;
      entry.removed=true;
      entry.dirty=true;
    }
  }
 else {
    getClusterMap().delete(buildAttributeName(name));
  }
}",0.9624796084828712
48326,"boolean offerInternal(Data data,long timeout) throws InterruptedException {
  throwExceptionIfNull(data);
  OfferOperation operation=new OfferOperation(name,timeout,data);
  try {
    return invokeAndGet(operation);
  }
 catch (  Throwable throwable) {
    throw ExceptionUtil.rethrowAllowInterrupted(throwable);
  }
}","boolean offerInternal(Data data,long timeout) throws InterruptedException {
  throwExceptionIfNull(data);
  OfferOperation operation=new OfferOperation(name,timeout,data);
  try {
    return (Boolean)invokeAndGet(operation);
  }
 catch (  Throwable throwable) {
    throw ExceptionUtil.rethrowAllowInterrupted(throwable);
  }
}",0.986046511627907
48327,"private void runAsynchronous(final ExecutionCallback<E> callback,Executor executor){
  executor.execute(new Runnable(){
    @Override public void run(){
      try {
        Object resp=resolveResponse(response);
        if (resp == null || !(resp instanceof Throwable)) {
          callback.onResponse((E)resp);
        }
 else {
          callback.onFailure((Throwable)resp);
        }
      }
 catch (      Throwable t) {
        basicInvocation.logger.severe(""String_Node_Str"" + basicInvocation,t);
      }
    }
  }
);
}","private void runAsynchronous(final ExecutionCallback<E> callback,Executor executor){
  try {
    executor.execute(new Runnable(){
      @Override public void run(){
        try {
          Object resp=resolveResponse(response);
          if (resp == null || !(resp instanceof Throwable)) {
            callback.onResponse((E)resp);
          }
 else {
            callback.onFailure((Throwable)resp);
          }
        }
 catch (        Throwable t) {
          basicInvocation.logger.severe(""String_Node_Str"" + basicInvocation,t);
        }
      }
    }
);
  }
 catch (  RejectedExecutionException ignore) {
    basicInvocation.logger.finest(ignore);
  }
}",0.8496621621621622
48328,"public GroupProperties(Config config){
  HOSTED_MANAGEMENT_ENABLED=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_ENABLED,""String_Node_Str"");
  HOSTED_MANAGEMENT_URL=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_URL,""String_Node_Str"");
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS=new GroupProperty(config,PROP_MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_OPERATIONS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}","public GroupProperties(Config config){
  HOSTED_MANAGEMENT_ENABLED=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_ENABLED,""String_Node_Str"");
  HOSTED_MANAGEMENT_URL=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_URL,""String_Node_Str"");
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS=new GroupProperty(config,PROP_MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_OPERATIONS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITION_BACKUP_SYNC_INTERVAL=new GroupProperty(config,PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}",0.9912348147009072
48329,"private void logBackupVersionMismatch(long currentVersion){
  getLogger().info(""String_Node_Str"" + ""String_Node_Str"" + currentVersion + ""String_Node_Str""+ version);
}","private void logBackupVersionMismatch(long currentVersion){
  ILogger logger=getLogger();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + getPartitionId() + ""String_Node_Str""+ currentVersion+ ""String_Node_Str""+ version);
  }
}",0.7548076923076923
48330,"@Override public void run() throws Exception {
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  int replicaIndex=getReplicaIndex();
  long[] currentVersions=partitionService.getPartitionReplicaVersions(partitionId);
  long currentVersion=currentVersions[replicaIndex - 1];
  if (currentVersion == version) {
    response=true;
  }
 else {
    logBackupVersionMismatch(currentVersion);
    partitionService.syncPartitionReplica(partitionId,replicaIndex,false);
    response=false;
  }
}","@Override public void run() throws Exception {
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  int replicaIndex=getReplicaIndex();
  long[] currentVersions=partitionService.getPartitionReplicaVersions(partitionId);
  long currentVersion=currentVersions[replicaIndex - 1];
  if (currentVersion == version) {
    response=true;
  }
 else {
    logBackupVersionMismatch(currentVersion);
    partitionService.triggerPartitionReplicaSync(partitionId,replicaIndex);
    response=false;
  }
}",0.9263746505125816
48331,"@Override public void run(){
  InternalPartitionServiceImpl partitionService=getService();
  MigrationInfo migrationInfo=partitionService.getActiveMigration(getPartitionId());
  if (migrationInfo == null) {
    return;
  }
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  PartitionMigrationEvent event=new PartitionMigrationEvent(endpoint,getPartitionId());
  for (  MigrationAwareService service : nodeEngine.getServices(MigrationAwareService.class)) {
    finishMigration(event,service);
  }
  partitionService.removeActiveMigration(getPartitionId());
  if (success) {
    nodeEngine.onPartitionMigrate(migrationInfo);
  }
}","@Override public void run(){
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  MigrationInfo migrationInfo=partitionService.getActiveMigration(partitionId);
  if (migrationInfo == null) {
    return;
  }
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  PartitionMigrationEvent event=new PartitionMigrationEvent(endpoint,partitionId);
  for (  MigrationAwareService service : nodeEngine.getServices(MigrationAwareService.class)) {
    finishMigration(event,service);
  }
  partitionService.removeActiveMigration(partitionId);
  if (success) {
    nodeEngine.onPartitionMigrate(migrationInfo);
  }
}",0.8531898539584934
48332,"public GroupProperties(Config config){
  HOSTED_MANAGEMENT_ENABLED=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_ENABLED,""String_Node_Str"");
  HOSTED_MANAGEMENT_URL=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_URL,""String_Node_Str"");
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS=new GroupProperty(config,PROP_MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_OPERATIONS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}","public GroupProperties(Config config){
  HOSTED_MANAGEMENT_ENABLED=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_ENABLED,""String_Node_Str"");
  HOSTED_MANAGEMENT_URL=new GroupProperty(config,PROP_HOSTED_MANAGEMENT_URL,""String_Node_Str"");
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS=new GroupProperty(config,PROP_MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_OPERATIONS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITION_BACKUP_SYNC_INTERVAL=new GroupProperty(config,PROP_PARTITION_BACKUP_SYNC_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}",0.9912348147009072
48333,"private void logBackupVersionMismatch(long currentVersion){
  getLogger().info(""String_Node_Str"" + ""String_Node_Str"" + currentVersion + ""String_Node_Str""+ version);
}","private void logBackupVersionMismatch(long currentVersion){
  ILogger logger=getLogger();
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + getPartitionId() + ""String_Node_Str""+ currentVersion+ ""String_Node_Str""+ version);
  }
}",0.7548076923076923
48334,"@Override public void run() throws Exception {
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  int replicaIndex=getReplicaIndex();
  long[] currentVersions=partitionService.getPartitionReplicaVersions(partitionId);
  long currentVersion=currentVersions[replicaIndex - 1];
  if (currentVersion == version) {
    response=true;
  }
 else {
    logBackupVersionMismatch(currentVersion);
    partitionService.syncPartitionReplica(partitionId,replicaIndex,false);
    response=false;
  }
}","@Override public void run() throws Exception {
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  int replicaIndex=getReplicaIndex();
  long[] currentVersions=partitionService.getPartitionReplicaVersions(partitionId);
  long currentVersion=currentVersions[replicaIndex - 1];
  if (currentVersion == version) {
    response=true;
  }
 else {
    logBackupVersionMismatch(currentVersion);
    partitionService.triggerPartitionReplicaSync(partitionId,replicaIndex);
    response=false;
  }
}",0.9263746505125816
48335,"@Override public void run(){
  InternalPartitionServiceImpl partitionService=getService();
  MigrationInfo migrationInfo=partitionService.getActiveMigration(getPartitionId());
  if (migrationInfo == null) {
    return;
  }
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  PartitionMigrationEvent event=new PartitionMigrationEvent(endpoint,getPartitionId());
  for (  MigrationAwareService service : nodeEngine.getServices(MigrationAwareService.class)) {
    finishMigration(event,service);
  }
  partitionService.removeActiveMigration(getPartitionId());
  if (success) {
    nodeEngine.onPartitionMigrate(migrationInfo);
  }
}","@Override public void run(){
  InternalPartitionServiceImpl partitionService=getService();
  int partitionId=getPartitionId();
  MigrationInfo migrationInfo=partitionService.getActiveMigration(partitionId);
  if (migrationInfo == null) {
    return;
  }
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  PartitionMigrationEvent event=new PartitionMigrationEvent(endpoint,partitionId);
  for (  MigrationAwareService service : nodeEngine.getServices(MigrationAwareService.class)) {
    finishMigration(event,service);
  }
  partitionService.removeActiveMigration(partitionId);
  if (success) {
    nodeEngine.onPartitionMigrate(migrationInfo);
  }
}",0.8531898539584934
48336,"public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  buildInfo=BUILD_INFO_CONSTRUCTOR.createNew(null);
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  final Map<String,Object> memberAttributes=findMemberAttributes(config.getMemberAttributeConfig().asReadOnly());
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address),hazelcastInstance,memberAttributes);
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember,buildInfo);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new InternalPartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  VersionCheck.check(this,getBuildInfo().getBuild(),getBuildInfo().getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}","public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  buildInfo=BUILD_INFO_CONSTRUCTOR.createNew(null);
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,buildInfo);
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  final Map<String,Object> memberAttributes=findMemberAttributes(config.getMemberAttributeConfig().asReadOnly());
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address),hazelcastInstance,memberAttributes);
  loggingService.setThisMember(localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new InternalPartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  VersionCheck.check(this,getBuildInfo().getBuild(),getBuildInfo().getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}",0.8726389042306417
48337,"public LoggingServiceImpl(SystemLogService systemLogService,String groupName,String loggingType,MemberImpl thisMember,BuildInfo buildInfo){
  this.systemLogService=systemLogService;
  this.groupName=groupName;
  this.thisMember=thisMember;
  this.loggerFactory=Logger.newLoggerFactory(loggingType);
  this.thisAddressString=""String_Node_Str"" + thisMember.getAddress().getHost() + ""String_Node_Str""+ thisMember.getAddress().getPort();
  this.buildInfo=buildInfo;
}","public LoggingServiceImpl(SystemLogService systemLogService,String groupName,String loggingType,BuildInfo buildInfo){
  this.systemLogService=systemLogService;
  this.groupName=groupName;
  this.loggerFactory=Logger.newLoggerFactory(loggingType);
  this.buildInfo=buildInfo;
}",0.7469553450608931
48338,"public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  buildInfo=BUILD_INFO_CONSTRUCTOR.createNew(null);
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  final Map<String,Object> memberAttributes=findMemberAttributes(config.getMemberAttributeConfig().asReadOnly());
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address),hazelcastInstance,memberAttributes);
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember,buildInfo);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new InternalPartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  VersionCheck.check(this,getBuildInfo().getBuild(),getBuildInfo().getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}","public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  buildInfo=BUILD_INFO_CONSTRUCTOR.createNew(null);
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,buildInfo);
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  final Map<String,Object> memberAttributes=findMemberAttributes(config.getMemberAttributeConfig().asReadOnly());
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address),hazelcastInstance,memberAttributes);
  loggingService.setThisMember(localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new InternalPartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  VersionCheck.check(this,getBuildInfo().getBuild(),getBuildInfo().getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}",0.8726389042306417
48339,"public LoggingServiceImpl(SystemLogService systemLogService,String groupName,String loggingType,MemberImpl thisMember,BuildInfo buildInfo){
  this.systemLogService=systemLogService;
  this.groupName=groupName;
  this.thisMember=thisMember;
  this.loggerFactory=Logger.newLoggerFactory(loggingType);
  this.thisAddressString=""String_Node_Str"" + thisMember.getAddress().getHost() + ""String_Node_Str""+ thisMember.getAddress().getPort();
  this.buildInfo=buildInfo;
}","public LoggingServiceImpl(SystemLogService systemLogService,String groupName,String loggingType,BuildInfo buildInfo){
  this.systemLogService=systemLogService;
  this.groupName=groupName;
  this.loggerFactory=Logger.newLoggerFactory(loggingType);
  this.buildInfo=buildInfo;
}",0.7469553450608931
48340,"@Test public void testNearCachePopulatedAndHitsGenerated2() throws Exception {
  final IMap map=client.getMap(mapWithBasicCash + randomString());
  final int size=1278;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  System.out.println(""String_Node_Str"" + stats);
  assertEquals(size,stats.getOwnedEntryCount());
  assertEquals(size,stats.getHits());
}","@Test public void testNearCachePopulatedAndHitsGenerated2() throws Exception {
  final IMap map=client.getMap(mapWithBasicCashNoInvalidation + randomString());
  final int size=1278;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  System.out.println(""String_Node_Str"" + stats);
  assertEquals(size,stats.getOwnedEntryCount());
  assertEquals(size,stats.getHits());
}",0.9870609981515712
48341,"@Test public void testNearCacheMisses(){
  final IMap map=client.getMap(mapWithBasicCash + randomString());
  final int size=1321;
  for (int i=0; i < size; i++) {
    map.get(""String_Node_Str"" + i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertEquals(size,stats.getMisses());
  assertEquals(size,stats.getOwnedEntryCount());
}","@Test public void testNearCacheMisses(){
  final IMap map=client.getMap(mapWithBasicCashNoInvalidation + randomString());
  final int size=1321;
  for (int i=0; i < size; i++) {
    map.get(""String_Node_Str"" + i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertEquals(size,stats.getMisses());
  assertEquals(size,stats.getOwnedEntryCount());
}",0.9809782608695652
48342,"@Test @Category(ProblematicTest.class) public void testNearCachePopulatedAndHitsGenerated() throws Exception {
  final IMap map=client.getMap(mapWithBasicCash + randomString());
  final int size=1278;
  for (int i=0; i < size; i++) {
    map.put(i,i);
    map.get(i);
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  System.out.println(""String_Node_Str"" + stats);
  assertEquals(size,stats.getOwnedEntryCount());
  assertEquals(size,stats.getHits());
}","@Test public void testNearCachePopulatedAndHitsGenerated() throws Exception {
  final IMap map=client.getMap(mapWithBasicCashNoInvalidation + randomString());
  final int size=1278;
  for (int i=0; i < size; i++) {
    map.put(i,i);
    map.get(i);
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  System.out.println(""String_Node_Str"" + stats);
  assertEquals(size,stats.getOwnedEntryCount());
  assertEquals(size,stats.getHits());
}",0.9512953367875648
48343,"@Test public void testGetNearCacheStatsBeforePopulation(){
  final IMap map=client.getMap(mapWithBasicCash + randomString());
  final int size=101;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertNotNull(stats);
}","@Test public void testGetNearCacheStatsBeforePopulation(){
  final IMap map=client.getMap(mapWithBasicCashNoInvalidation + randomString());
  final int size=101;
  for (int i=0; i < size; i++) {
    map.put(i,i);
  }
  final NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertNotNull(stats);
}",0.9772727272727272
48344,"@BeforeClass public static void setup() throws Exception {
  h1=Hazelcast.newHazelcastInstance();
  h2=Hazelcast.newHazelcastInstance();
  ClientConfig clientConfig=new ClientConfig();
  NearCacheConfig basicConfig=new NearCacheConfig();
  basicConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  clientConfig.addNearCacheConfig(mapWithBasicCash + ""String_Node_Str"",basicConfig);
  NearCacheConfig maxSizeConfig=new NearCacheConfig();
  maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);
  clientConfig.addNearCacheConfig(mapWithMaxSizeCash + ""String_Node_Str"",maxSizeConfig);
  NearCacheConfig ttlConfig=new NearCacheConfig();
  ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);
  clientConfig.addNearCacheConfig(mapWithTTLCash + ""String_Node_Str"",ttlConfig);
  NearCacheConfig idleConfig=new NearCacheConfig();
  idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);
  clientConfig.addNearCacheConfig(mapWithIdleCash + ""String_Node_Str"",idleConfig);
  NearCacheConfig invalidateConfig=new NearCacheConfig();
  invalidateConfig.setInvalidateOnChange(true);
  clientConfig.addNearCacheConfig(mapWithInvalidateCash + ""String_Node_Str"",invalidateConfig);
  client=HazelcastClient.newHazelcastClient(clientConfig);
}","@BeforeClass public static void setup() throws Exception {
  h1=Hazelcast.newHazelcastInstance();
  h2=Hazelcast.newHazelcastInstance();
  ClientConfig clientConfig=new ClientConfig();
  NearCacheConfig basicConfig=new NearCacheConfig();
  basicConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  clientConfig.addNearCacheConfig(mapWithBasicCash + ""String_Node_Str"",basicConfig);
  NearCacheConfig basicConfigNoInvalidation=new NearCacheConfig();
  basicConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  basicConfigNoInvalidation.setInvalidateOnChange(false);
  clientConfig.addNearCacheConfig(mapWithBasicCashNoInvalidation + ""String_Node_Str"",basicConfigNoInvalidation);
  NearCacheConfig maxSizeConfig=new NearCacheConfig();
  maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);
  clientConfig.addNearCacheConfig(mapWithMaxSizeCash + ""String_Node_Str"",maxSizeConfig);
  NearCacheConfig ttlConfig=new NearCacheConfig();
  ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);
  clientConfig.addNearCacheConfig(mapWithTTLCash + ""String_Node_Str"",ttlConfig);
  NearCacheConfig idleConfig=new NearCacheConfig();
  idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);
  clientConfig.addNearCacheConfig(mapWithIdleCash + ""String_Node_Str"",idleConfig);
  NearCacheConfig invalidateConfig=new NearCacheConfig();
  invalidateConfig.setInvalidateOnChange(true);
  clientConfig.addNearCacheConfig(mapWithInvalidateCash + ""String_Node_Str"",invalidateConfig);
  client=HazelcastClient.newHazelcastClient(clientConfig);
}",0.8905435591958303
48345,"@Test public void testNearCacheStats() throws Exception {
  String mapName=""String_Node_Str"";
  Config config=new Config();
  config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(true));
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance[] instances=factory.newInstances(config);
  IMap<Integer,Integer> map=instances[0].getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    map.put(i,i);
  }
  for (int i=0; i < 1000; i++) {
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats.getOwnedEntryCount());
  assertTrue(""String_Node_Str"",1000 == stats.getMisses());
  for (int i=0; i < 1000; i++) {
    map.get(i);
  }
  NearCacheStats stats2=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats2.getHits());
  assertTrue(""String_Node_Str"",400 < stats2.getMisses());
  assertTrue(""String_Node_Str"",2000 == stats2.getHits() + stats2.getMisses());
}","@Test public void testNearCacheStats() throws Exception {
  String mapName=randomMapName();
  Config config=new Config();
  config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance[] instances=factory.newInstances(config);
  IMap<Integer,Integer> map=instances[0].getMap(mapName);
  for (int i=0; i < 1000; i++) {
    map.put(i,i);
  }
  for (int i=0; i < 1000; i++) {
    map.get(i);
  }
  NearCacheStats stats=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats.getOwnedEntryCount());
  assertTrue(""String_Node_Str"",1000 == stats.getMisses());
  for (int i=0; i < 1000; i++) {
    map.get(i);
  }
  NearCacheStats stats2=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats2.getHits());
  assertTrue(""String_Node_Str"",400 < stats2.getMisses());
  assertTrue(""String_Node_Str"",2000 == stats2.getHits() + stats2.getMisses());
}",0.9706589706589708
48346,"public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  try {
    Config hzConfig=hazelcastInstance.getConfig();
    String sessionTTL=getParam(""String_Node_Str"");
    if (sessionTTL != null) {
      MapConfig mapConfig=hzConfig.getMapConfig(clusterMapName);
      mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));
      hzConfig.addMapConfig(mapConfig);
    }
  }
 catch (  UnsupportedOperationException ignored) {
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  String deferredWriteParam=getParam(""String_Node_Str"");
  if (deferredWriteParam != null) {
    deferredWrite=Boolean.parseBoolean(deferredWriteParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener<String,Object>(){
      public void entryAdded(      EntryEvent<String,Object> entryEvent){
      }
      public void entryRemoved(      EntryEvent<String,Object> entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally(entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent<String,Object> entryEvent){
      }
      public void entryEvicted(      EntryEvent<String,Object> entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  if (logger.isLoggable(Level.FINEST)) {
    logger.finest(""String_Node_Str"" + stickySession + ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
  }
}","public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  try {
    Config hzConfig=hazelcastInstance.getConfig();
    String sessionTTL=getParam(""String_Node_Str"");
    if (sessionTTL != null) {
      MapConfig mapConfig=hzConfig.getMapConfig(clusterMapName);
      mapConfig.setTimeToLiveSeconds(Integer.parseInt(sessionTTL));
      hzConfig.addMapConfig(mapConfig);
    }
  }
 catch (  UnsupportedOperationException ignored) {
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  String deferredWriteParam=getParam(""String_Node_Str"");
  if (deferredWriteParam != null) {
    deferredWrite=Boolean.parseBoolean(deferredWriteParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener<String,Object>(){
      public void entryAdded(      EntryEvent<String,Object> entryEvent){
      }
      public void entryRemoved(      EntryEvent<String,Object> entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally(entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent<String,Object> entryEvent){
      }
      public void entryEvicted(      EntryEvent<String,Object> entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  if (logger.isLoggable(Level.FINEST)) {
    logger.finest(""String_Node_Str"" + stickySession + ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
  }
}",0.9970524661033602
48347,"public TextCommand parser(SocketTextReader socketTextReader,String cmd,int space){
  StringTokenizer st=new StringTokenizer(cmd);
  st.nextToken();
  String key=null;
  int valueLen=0;
  int flag=0;
  int expiration=0;
  boolean noReply=false;
  if (st.hasMoreTokens()) {
    key=st.nextToken();
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    flag=Integer.valueOf(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    expiration=Integer.parseInt(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    valueLen=Integer.parseInt(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    noReply=""String_Node_Str"".equals(st.nextToken());
  }
  return new SetCommand(type,key,flag,expiration,valueLen,noReply);
}","public TextCommand parser(SocketTextReader socketTextReader,String cmd,int space){
  StringTokenizer st=new StringTokenizer(cmd);
  st.nextToken();
  String key=null;
  int valueLen=0;
  int flag=0;
  int expiration=0;
  boolean noReply=false;
  if (st.hasMoreTokens()) {
    key=st.nextToken();
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    flag=Integer.parseInt(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    expiration=Integer.parseInt(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    valueLen=Integer.parseInt(st.nextToken());
  }
 else {
    return new ErrorCommand(ERROR_CLIENT);
  }
  if (st.hasMoreTokens()) {
    noReply=""String_Node_Str"".equals(st.nextToken());
  }
  return new SetCommand(type,key,flag,expiration,valueLen,noReply);
}",0.9917537108301264
48348,"/** 
 * Starts the test
 * @param args the number of threads to start
 */
public static void main(String[] args){
  int nThreads=(args.length == 0) ? 10 : new Integer(args[0]);
  final AllTest allTest=new AllTest(nThreads);
  allTest.start();
  Executors.newSingleThreadExecutor().execute(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * ONE_SECOND);
          System.out.println(""String_Node_Str"" + allTest.hazelcast.getCluster().getMembers().size());
          allTest.mapStats();
          allTest.qStats();
          allTest.topicStats();
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
    }
  }
);
}","/** 
 * Starts the test
 * @param args the number of threads to start
 */
public static void main(String[] args){
  int nThreads=(args.length == 0) ? 10 : Integer.parseInt(args[0]);
  final AllTest allTest=new AllTest(nThreads);
  allTest.start();
  Executors.newSingleThreadExecutor().execute(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * ONE_SECOND);
          System.out.println(""String_Node_Str"" + allTest.hazelcast.getCluster().getMembers().size());
          allTest.mapStats();
          allTest.qStats();
          allTest.topicStats();
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
    }
  }
);
}",0.9909407665505228
48349,"@SuppressWarnings(""String_Node_Str"") protected void handleLock(String[] args){
  String lockStr=args[0];
  String key=args[1];
  Lock lock=hazelcast.getLock(key);
  if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    lock.lock();
    println(""String_Node_Str"");
  }
 else   if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    lock.unlock();
    println(""String_Node_Str"");
  }
 else   if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    String timeout=args.length > 2 ? args[2] : null;
    if (timeout == null) {
      println(lock.tryLock());
    }
 else {
      long time=Long.valueOf(timeout);
      try {
        println(lock.tryLock(time,TimeUnit.SECONDS));
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") protected void handleLock(String[] args){
  String lockStr=args[0];
  String key=args[1];
  Lock lock=hazelcast.getLock(key);
  if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    lock.lock();
    println(""String_Node_Str"");
  }
 else   if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    lock.unlock();
    println(""String_Node_Str"");
  }
 else   if (lockStr.equalsIgnoreCase(""String_Node_Str"")) {
    String timeout=args.length > 2 ? args[2] : null;
    if (timeout == null) {
      println(lock.tryLock());
    }
 else {
      long time=Long.parseLong(timeout);
      try {
        println(lock.tryLock(time,TimeUnit.SECONDS));
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}",0.9895968790637192
48350,"protected void handleQOffer(String[] args){
  long timeout=0;
  if (args.length > 2) {
    timeout=Long.valueOf(args[2]);
  }
  try {
    boolean offered=getQueue().offer(args[1],timeout,TimeUnit.SECONDS);
    println(offered);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","protected void handleQOffer(String[] args){
  long timeout=0;
  if (args.length > 2) {
    timeout=Long.parseLong(args[2]);
  }
  try {
    boolean offered=getQueue().offer(args[1],timeout,TimeUnit.SECONDS);
    println(offered);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9732441471571908
48351,"protected void handleMultiMapTryLock(String[] args){
  String key=args[1];
  long time=(args.length > 2) ? Long.valueOf(args[2]) : 0;
  boolean locked;
  if (time == 0) {
    locked=getMultiMap().tryLock(key);
  }
 else {
    try {
      locked=getMultiMap().tryLock(key,time,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      locked=false;
    }
  }
  println(locked);
}","protected void handleMultiMapTryLock(String[] args){
  String key=args[1];
  long time=(args.length > 2) ? Long.parseLong(args[2]) : 0;
  boolean locked;
  if (time == 0) {
    locked=getMultiMap().tryLock(key);
  }
 else {
    try {
      locked=getMultiMap().tryLock(key,time,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      locked=false;
    }
  }
  println(locked);
}",0.9794871794871794
48352,"private void handleAtomicNumberSet(String[] args){
  long v=0;
  if (args.length > 1) {
    v=Long.valueOf(args[1]);
  }
  getAtomicNumber().set(v);
  println(getAtomicNumber().get());
}","private void handleAtomicNumberSet(String[] args){
  long v=0;
  if (args.length > 1) {
    v=Long.parseLong(args[1]);
  }
  getAtomicNumber().set(v);
  println(getAtomicNumber().get());
}",0.9679144385026738
48353,"protected void handleMapTryLock(String[] args){
  String key=args[1];
  long time=(args.length > 2) ? Long.valueOf(args[2]) : 0;
  boolean locked;
  if (time == 0) {
    locked=getMap().tryLock(key);
  }
 else {
    try {
      locked=getMap().tryLock(key,time,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      locked=false;
    }
  }
  println(locked);
}","protected void handleMapTryLock(String[] args){
  String key=args[1];
  long time=(args.length > 2) ? Long.parseLong(args[2]) : 0;
  boolean locked;
  if (time == 0) {
    locked=getMap().tryLock(key);
  }
 else {
    try {
      locked=getMap().tryLock(key,time,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      locked=false;
    }
  }
  println(locked);
}",0.9786666666666668
48354,"protected void handleQPoll(String[] args){
  long timeout=0;
  if (args.length > 1) {
    timeout=Long.valueOf(args[1]);
  }
  try {
    println(getQueue().poll(timeout,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","protected void handleQPoll(String[] args){
  long timeout=0;
  if (args.length > 1) {
    timeout=Long.parseLong(args[1]);
  }
  try {
    println(getQueue().poll(timeout,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9692307692307692
48355,"@Test @Category(ProblematicTest.class) public void concurrent_TryLock_WithTimeOutTest() throws InterruptedException {
  concurrent_LockTest(true);
}","@Test public void concurrent_TryLock_WithTimeOutTest() throws InterruptedException {
  concurrent_LockTest(true);
}",0.8745247148288974
48356,"@Test @Category(ProblematicTest.class) public void concurrent_MapTryLockTimeOutTest() throws InterruptedException {
  concurrent_MapTryLock(true);
}","@Test public void concurrent_MapTryLockTimeOutTest() throws InterruptedException {
  concurrent_MapTryLock(true);
}",0.8745247148288974
48357,"@Test @Category(ProblematicTest.class) public void concurrent_trySemaphoreWithTimeOutTest(){
  concurrent_trySemaphoreTest(true);
}","@Test public void concurrent_trySemaphoreWithTimeOutTest(){
  concurrent_trySemaphoreTest(true);
}",0.8558951965065502
48358,"public void updateManagementCenterUrl(String newUrl){
  if (newUrl == null) {
    return;
  }
  managementCenterUrl=newUrl;
  if (newUrl.equals(managementCenterUrl)) {
    return;
  }
  if (!isRunning()) {
    start();
  }
  urlChanged=true;
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + managementCenterUrl);
}","public void updateManagementCenterUrl(String newUrl){
  if (newUrl == null) {
    return;
  }
  if (newUrl.equals(managementCenterUrl)) {
    return;
  }
  managementCenterUrl=newUrl;
  if (!isRunning()) {
    start();
  }
  urlChanged=true;
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + managementCenterUrl);
}",0.8119122257053292
48359,"public void applyRecordInfo(Record record,String mapName,RecordInfo replicationInfo){
  record.setStatistics(replicationInfo.getStatistics());
  if (replicationInfo.getIdleDelayMillis() >= 0) {
    scheduleIdleEviction(mapName,record.getKey(),replicationInfo.getIdleDelayMillis());
  }
  if (replicationInfo.getTtlDelayMillis() >= 0) {
    scheduleTtlEviction(mapName,record,replicationInfo.getTtlDelayMillis());
  }
  if (replicationInfo.getMapStoreWriteDelayMillis() >= 0) {
    scheduleMapStoreWrite(mapName,record.getKey(),record.getValue(),replicationInfo.getMapStoreWriteDelayMillis());
  }
  if (replicationInfo.getMapStoreDeleteDelayMillis() >= 0) {
    scheduleMapStoreDelete(mapName,record.getKey(),replicationInfo.getMapStoreDeleteDelayMillis());
  }
}","public void applyRecordInfo(Record record,String mapName,RecordInfo replicationInfo){
  record.setStatistics(replicationInfo.getStatistics());
  record.setVersion(replicationInfo.getVersion());
  if (replicationInfo.getIdleDelayMillis() >= 0) {
    scheduleIdleEviction(mapName,record.getKey(),replicationInfo.getIdleDelayMillis());
  }
  if (replicationInfo.getTtlDelayMillis() >= 0) {
    scheduleTtlEviction(mapName,record,replicationInfo.getTtlDelayMillis());
  }
  if (replicationInfo.getMapStoreWriteDelayMillis() >= 0) {
    scheduleMapStoreWrite(mapName,record.getKey(),record.getValue(),replicationInfo.getMapStoreWriteDelayMillis());
  }
  if (replicationInfo.getMapStoreDeleteDelayMillis() >= 0) {
    scheduleMapStoreDelete(mapName,record.getKey(),replicationInfo.getMapStoreDeleteDelayMillis());
  }
}",0.9676601141407736
48360,"public RecordInfo createRecordInfo(MapContainer mapContainer,Record record,Data key){
  int backupDelay=getNodeEngine().getGroupProperties().MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS.getInteger() * 1000;
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(record.getKey());
  long idleDelay=idleScheduledEntry == null ? -1 : backupDelay + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : backupDelay + findDelayMillis(ttlScheduledEntry);
  final RecordInfo recordInfo=new RecordInfo(record.getStatistics(),idleDelay,ttlDelay);
  setDelays(recordInfo,backupDelay,mapContainer,key);
  return recordInfo;
}","public RecordInfo createRecordInfo(MapContainer mapContainer,Record record,Data key){
  final int backupDelay=getNodeEngine().getGroupProperties().MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS.getInteger() * 1000;
  return constructRecordInfo(mapContainer,record,key,backupDelay);
}",0.4090513489991297
48361,"public RecordReplicationInfo createRecordReplicationInfo(MapContainer mapContainer,Record record,Data key){
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(key);
  long idleDelay=idleScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(ttlScheduledEntry);
  final RecordReplicationInfo recordReplicationInfo=new RecordReplicationInfo(record.getKey(),toData(record.getValue()),record.getStatistics(),idleDelay,ttlDelay);
  setDelays(recordReplicationInfo,replicaWaitSecondsForScheduledTasks,mapContainer,key);
  return recordReplicationInfo;
}","public RecordReplicationInfo createRecordReplicationInfo(MapContainer mapContainer,Record record,Data key){
  final RecordInfo info=constructRecordInfo(mapContainer,record,key,replicaWaitSecondsForScheduledTasks);
  final RecordReplicationInfo replicationInfo=new RecordReplicationInfo(record.getKey(),toData(record.getValue()),info);
  return replicationInfo;
}",0.2826086956521739
48362,"private void setDelays(RecordInfo recordInfo,int extraDelay,MapContainer mapContainer,Data key){
  long deleteDelay=-1;
  long writeDelay=-1;
  if (mapContainer.getMapStoreScheduler() != null) {
    final ScheduledEntry scheduledEntry=mapContainer.getMapStoreScheduler().get(key);
    if (scheduledEntry != null) {
      if (scheduledEntry.getValue() == null) {
        deleteDelay=extraDelay + findDelayMillis(scheduledEntry);
      }
 else {
        writeDelay=extraDelay + findDelayMillis(scheduledEntry);
      }
    }
  }
  recordInfo.setMapStoreDeleteDelayMillis(deleteDelay);
  recordInfo.setMapStoreWriteDelayMillis(writeDelay);
}","private void setDelays(MapContainer mapContainer,RecordInfo info,Data key,int extraDelay){
  long deleteDelay=-1;
  long writeDelay=-1;
  long idleDelay;
  long ttlDelay;
  if (mapContainer.getMapStoreScheduler() != null) {
    final ScheduledEntry scheduledEntry=mapContainer.getMapStoreScheduler().get(key);
    if (scheduledEntry != null) {
      if (scheduledEntry.getValue() == null) {
        deleteDelay=extraDelay + findDelayMillis(scheduledEntry);
      }
 else {
        writeDelay=extraDelay + findDelayMillis(scheduledEntry);
      }
    }
  }
  idleDelay=getDelay(mapContainer.getIdleEvictionScheduler(),key,extraDelay);
  ttlDelay=getDelay(mapContainer.getTtlEvictionScheduler(),key,extraDelay);
  info.setMapStoreDeleteDelayMillis(deleteDelay);
  info.setMapStoreWriteDelayMillis(writeDelay);
  info.setIdleDelayMillis(idleDelay);
  info.setTtlDelayMillis(ttlDelay);
}",0.6561472715318869
48363,"@Override public void readData(ObjectDataInput in) throws IOException {
  boolean statsEnabled=in.readBoolean();
  if (statsEnabled) {
    statistics=new RecordStatistics();
    statistics.readData(in);
  }
  idleDelayMillis=in.readLong();
  ttlDelayMillis=in.readLong();
  mapStoreWriteDelayMillis=in.readLong();
  mapStoreDeleteDelayMillis=in.readLong();
}","@Override public void readData(ObjectDataInput in) throws IOException {
  boolean statsEnabled=in.readBoolean();
  if (statsEnabled) {
    statistics=new RecordStatistics();
    statistics.readData(in);
  }
  idleDelayMillis=in.readLong();
  ttlDelayMillis=in.readLong();
  mapStoreWriteDelayMillis=in.readLong();
  mapStoreDeleteDelayMillis=in.readLong();
  version=in.readLong();
}",0.9662618083670717
48364,"public RecordInfo(RecordStatistics statistics,long idleDelayMillis,long ttlDelayMillis){
  this(statistics,idleDelayMillis,ttlDelayMillis,-1,-1);
}","public RecordInfo(RecordInfo recordInfo){
  this.statistics=recordInfo.statistics;
  this.idleDelayMillis=recordInfo.idleDelayMillis;
  this.ttlDelayMillis=recordInfo.ttlDelayMillis;
  this.mapStoreWriteDelayMillis=recordInfo.mapStoreWriteDelayMillis;
  this.mapStoreDeleteDelayMillis=recordInfo.mapStoreDeleteDelayMillis;
  this.version=recordInfo.version;
}",0.1422924901185771
48365,"@Override public void writeData(ObjectDataOutput out) throws IOException {
  if (statistics != null) {
    out.writeBoolean(true);
    statistics.writeData(out);
  }
 else {
    out.writeBoolean(false);
  }
  out.writeLong(idleDelayMillis);
  out.writeLong(ttlDelayMillis);
  out.writeLong(mapStoreWriteDelayMillis);
  out.writeLong(mapStoreDeleteDelayMillis);
}","@Override public void writeData(ObjectDataOutput out) throws IOException {
  if (statistics != null) {
    out.writeBoolean(true);
    statistics.writeData(out);
  }
 else {
    out.writeBoolean(false);
  }
  out.writeLong(idleDelayMillis);
  out.writeLong(ttlDelayMillis);
  out.writeLong(mapStoreWriteDelayMillis);
  out.writeLong(mapStoreDeleteDelayMillis);
  out.writeLong(version);
}",0.9653333333333334
48366,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + statistics + ""String_Node_Str""+ idleDelayMillis+ ""String_Node_Str""+ ttlDelayMillis+ ""String_Node_Str""+ mapStoreWriteDelayMillis+ ""String_Node_Str""+ mapStoreDeleteDelayMillis+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + statistics + ""String_Node_Str""+ idleDelayMillis+ ""String_Node_Str""+ ttlDelayMillis+ ""String_Node_Str""+ mapStoreWriteDelayMillis+ ""String_Node_Str""+ mapStoreDeleteDelayMillis+ ""String_Node_Str""+ version+ '}';
}",0.95
48367,"private void flush(Data key){
  checkIfLoaded();
  EntryTaskScheduler writeScheduler=mapContainer.getMapStoreWriteScheduler();
  Set<Data> keys=new HashSet<Data>(1);
  keys.add(key);
  if (writeScheduler != null) {
    Set<Data> processedKeys=writeScheduler.flush(keys);
    for (    Data pkey : processedKeys) {
      records.get(pkey).onStore();
    }
  }
  EntryTaskScheduler deleteScheduler=mapContainer.getMapStoreDeleteScheduler();
  if (deleteScheduler != null) {
    if (toBeRemovedKeys.contains(key)) {
      deleteScheduler.flush(keys);
      toBeRemovedKeys.remove(key);
    }
  }
}","private void flush(Data key){
  checkIfLoaded();
  EntryTaskScheduler writeScheduler=mapContainer.getMapStoreScheduler();
  Set<Data> keys=new HashSet<Data>(1);
  keys.add(key);
  if (writeScheduler != null) {
    Set<Data> processedKeys=writeScheduler.flush(keys);
    for (    Data pkey : processedKeys) {
      records.get(pkey).onStore();
    }
  }
  EntryTaskScheduler deleteScheduler=mapContainer.getMapStoreScheduler();
  if (deleteScheduler != null) {
    if (toBeRemovedKeys.contains(key)) {
      deleteScheduler.flush(keys);
      toBeRemovedKeys.remove(key);
    }
  }
}",0.9906382978723404
48368,"public MapContainer(String name,MapConfig mapConfig,MapService mapService){
  Object store=null;
  this.name=name;
  this.mapConfig=mapConfig;
  this.mapService=mapService;
  this.partitioningStrategy=createPartitioningStrategy();
  this.mapStoreScheduledExecutorName=""String_Node_Str"" + name;
  NodeEngine nodeEngine=mapService.getNodeEngine();
switch (mapConfig.getInMemoryFormat()) {
case BINARY:
    recordFactory=new DataRecordFactory(mapConfig,nodeEngine.getSerializationService(),partitioningStrategy);
  break;
case OBJECT:
recordFactory=new ObjectRecordFactory(mapConfig,nodeEngine.getSerializationService());
break;
case OFFHEAP:
recordFactory=new OffHeapRecordFactory(mapConfig,nodeEngine.getOffHeapStorage(),nodeEngine.getSerializationService(),partitioningStrategy);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + mapConfig.getInMemoryFormat());
}
MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
if (mapStoreConfig != null && mapStoreConfig.isEnabled()) {
try {
MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
if (factory == null) {
String factoryClassName=mapStoreConfig.getFactoryClassName();
if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
factory=ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(),factoryClassName);
}
}
store=(factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties()));
if (store == null) {
String mapStoreClassName=mapStoreConfig.getClassName();
store=ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(),mapStoreClassName);
}
}
 catch (Exception e) {
throw ExceptionUtil.rethrow(e);
}
storeWrapper=new MapStoreWrapper(store,name,mapStoreConfig.isEnabled());
}
 else {
storeWrapper=null;
}
if (storeWrapper != null) {
if (store instanceof MapLoaderLifecycleSupport) {
((MapLoaderLifecycleSupport)store).init(nodeEngine.getHazelcastInstance(),mapStoreConfig.getProperties(),name);
}
loadInitialKeys();
if (mapStoreConfig.getWriteDelaySeconds() > 0) {
final ExecutionService executionService=nodeEngine.getExecutionService();
executionService.register(mapStoreScheduledExecutorName,1,100000,ExecutorType.CACHED);
ScheduledExecutorService scheduledExecutor=executionService.getScheduledExecutor(mapStoreScheduledExecutorName);
mapStoreWriteScheduler=EntryTaskSchedulerFactory.newScheduler(scheduledExecutor,new MapStoreWriteProcessor(this,mapService),ScheduleType.FOR_EACH);
mapStoreDeleteScheduler=EntryTaskSchedulerFactory.newScheduler(scheduledExecutor,new MapStoreDeleteProcessor(this,mapService),ScheduleType.SCHEDULE_IF_NEW);
}
 else {
mapStoreDeleteScheduler=null;
mapStoreWriteScheduler=null;
}
}
 else {
mapStoreDeleteScheduler=null;
mapStoreWriteScheduler=null;
}
ScheduledExecutorService defaultScheduledExecutor=nodeEngine.getExecutionService().getDefaultScheduledExecutor();
ttlEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(defaultScheduledExecutor,new EvictionProcessor(nodeEngine,mapService,name),ScheduleType.POSTPONE);
idleEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(defaultScheduledExecutor,new EvictionProcessor(nodeEngine,mapService,name),ScheduleType.POSTPONE);
WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
if (wanReplicationRef != null) {
this.wanReplicationPublisher=nodeEngine.getWanReplicationService().getWanReplicationListener(wanReplicationRef.getName());
this.wanMergePolicy=mapService.getMergePolicy(wanReplicationRef.getMergePolicy());
}
 else {
wanMergePolicy=null;
wanReplicationPublisher=null;
}
interceptors=new CopyOnWriteArrayList<MapInterceptor>();
interceptorMap=new ConcurrentHashMap<String,MapInterceptor>();
nearCacheEnabled=mapConfig.getNearCacheConfig() != null;
nearCacheSizeEstimator=SizeEstimators.createNearCacheSizeEstimator();
}","public MapContainer(String name,MapConfig mapConfig,MapService mapService){
  Object store=null;
  this.name=name;
  this.mapConfig=mapConfig;
  this.mapService=mapService;
  this.partitioningStrategy=createPartitioningStrategy();
  this.mapStoreScheduledExecutorName=""String_Node_Str"" + name;
  NodeEngine nodeEngine=mapService.getNodeEngine();
switch (mapConfig.getInMemoryFormat()) {
case BINARY:
    recordFactory=new DataRecordFactory(mapConfig,nodeEngine.getSerializationService(),partitioningStrategy);
  break;
case OBJECT:
recordFactory=new ObjectRecordFactory(mapConfig,nodeEngine.getSerializationService());
break;
case OFFHEAP:
recordFactory=new OffHeapRecordFactory(mapConfig,nodeEngine.getOffHeapStorage(),nodeEngine.getSerializationService(),partitioningStrategy);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + mapConfig.getInMemoryFormat());
}
MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
if (mapStoreConfig != null && mapStoreConfig.isEnabled()) {
try {
MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
if (factory == null) {
String factoryClassName=mapStoreConfig.getFactoryClassName();
if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
factory=ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(),factoryClassName);
}
}
store=(factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties()));
if (store == null) {
String mapStoreClassName=mapStoreConfig.getClassName();
store=ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(),mapStoreClassName);
}
}
 catch (Exception e) {
throw ExceptionUtil.rethrow(e);
}
storeWrapper=new MapStoreWrapper(store,name,mapStoreConfig.isEnabled());
}
 else {
storeWrapper=null;
}
if (storeWrapper != null) {
if (store instanceof MapLoaderLifecycleSupport) {
((MapLoaderLifecycleSupport)store).init(nodeEngine.getHazelcastInstance(),mapStoreConfig.getProperties(),name);
}
loadInitialKeys();
if (mapStoreConfig.getWriteDelaySeconds() > 0) {
final ExecutionService executionService=nodeEngine.getExecutionService();
executionService.register(mapStoreScheduledExecutorName,1,100000,ExecutorType.CACHED);
ScheduledExecutorService scheduledExecutor=executionService.getScheduledExecutor(mapStoreScheduledExecutorName);
mapStoreScheduler=EntryTaskSchedulerFactory.newScheduler(scheduledExecutor,new MapStoreProcessor(this,mapService),ScheduleType.FOR_EACH);
}
 else {
mapStoreScheduler=null;
}
}
 else {
mapStoreScheduler=null;
}
ScheduledExecutorService defaultScheduledExecutor=nodeEngine.getExecutionService().getDefaultScheduledExecutor();
ttlEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(defaultScheduledExecutor,new EvictionProcessor(nodeEngine,mapService,name),ScheduleType.POSTPONE);
idleEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(defaultScheduledExecutor,new EvictionProcessor(nodeEngine,mapService,name),ScheduleType.POSTPONE);
WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
if (wanReplicationRef != null) {
this.wanReplicationPublisher=nodeEngine.getWanReplicationService().getWanReplicationListener(wanReplicationRef.getName());
this.wanMergePolicy=mapService.getMergePolicy(wanReplicationRef.getMergePolicy());
}
 else {
wanMergePolicy=null;
wanReplicationPublisher=null;
}
interceptors=new CopyOnWriteArrayList<MapInterceptor>();
interceptorMap=new ConcurrentHashMap<String,MapInterceptor>();
nearCacheEnabled=mapConfig.getNearCacheConfig() != null;
nearCacheSizeEstimator=SizeEstimators.createNearCacheSizeEstimator();
}",0.9681494422792636
48369,"public void scheduleMapStoreDelete(String mapName,Data key,long delay){
  getMapContainer(mapName).getMapStoreDeleteScheduler().schedule(delay,key,null);
}","public void scheduleMapStoreDelete(String mapName,Data key,long delay){
  getMapContainer(mapName).getMapStoreScheduler().schedule(delay,key,null);
}",0.9802631578947368
48370,"public RecordInfo createRecordInfo(MapContainer mapContainer,Record record,Data key){
  int backupDelay=getNodeEngine().getGroupProperties().MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS.getInteger() * 1000;
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(record.getKey());
  long idleDelay=idleScheduledEntry == null ? -1 : backupDelay + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : backupDelay + findDelayMillis(ttlScheduledEntry);
  ScheduledEntry writeScheduledEntry=mapContainer.getMapStoreWriteScheduler() == null ? null : mapContainer.getMapStoreWriteScheduler().get(key);
  long writeDelay=writeScheduledEntry == null ? -1 : backupDelay + findDelayMillis(writeScheduledEntry);
  ScheduledEntry deleteScheduledEntry=mapContainer.getMapStoreDeleteScheduler() == null ? null : mapContainer.getMapStoreDeleteScheduler().get(key);
  long deleteDelay=deleteScheduledEntry == null ? -1 : backupDelay + findDelayMillis(deleteScheduledEntry);
  return new RecordInfo(record.getStatistics(),idleDelay,ttlDelay,writeDelay,deleteDelay);
}","public RecordInfo createRecordInfo(MapContainer mapContainer,Record record,Data key){
  int backupDelay=getNodeEngine().getGroupProperties().MAP_REPLICA_WAIT_SECONDS_FOR_SCHEDULED_TASKS.getInteger() * 1000;
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(record.getKey());
  long idleDelay=idleScheduledEntry == null ? -1 : backupDelay + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : backupDelay + findDelayMillis(ttlScheduledEntry);
  final RecordInfo recordInfo=new RecordInfo(record.getStatistics(),idleDelay,ttlDelay);
  setDelays(recordInfo,backupDelay,mapContainer,key);
  return recordInfo;
}",0.6743436204514048
48371,"public RecordReplicationInfo createRecordReplicationInfo(MapContainer mapContainer,Record record,Data key){
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(key);
  long idleDelay=idleScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(ttlScheduledEntry);
  ScheduledEntry writeScheduledEntry=mapContainer.getMapStoreWriteScheduler() == null ? null : mapContainer.getMapStoreWriteScheduler().get(key);
  long writeDelay=writeScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(writeScheduledEntry);
  ScheduledEntry deleteScheduledEntry=mapContainer.getMapStoreDeleteScheduler() == null ? null : mapContainer.getMapStoreDeleteScheduler().get(key);
  long deleteDelay=deleteScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(deleteScheduledEntry);
  return new RecordReplicationInfo(record.getKey(),toData(record.getValue()),record.getStatistics(),idleDelay,ttlDelay,writeDelay,deleteDelay);
}","public RecordReplicationInfo createRecordReplicationInfo(MapContainer mapContainer,Record record,Data key){
  ScheduledEntry idleScheduledEntry=mapContainer.getIdleEvictionScheduler() == null ? null : mapContainer.getIdleEvictionScheduler().get(key);
  long idleDelay=idleScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(idleScheduledEntry);
  ScheduledEntry ttlScheduledEntry=mapContainer.getTtlEvictionScheduler() == null ? null : mapContainer.getTtlEvictionScheduler().get(key);
  long ttlDelay=ttlScheduledEntry == null ? -1 : replicaWaitSecondsForScheduledTasks + findDelayMillis(ttlScheduledEntry);
  final RecordReplicationInfo recordReplicationInfo=new RecordReplicationInfo(record.getKey(),toData(record.getValue()),record.getStatistics(),idleDelay,ttlDelay);
  setDelays(recordReplicationInfo,replicaWaitSecondsForScheduledTasks,mapContainer,key);
  return recordReplicationInfo;
}",0.6272606969563299
48372,"public void scheduleMapStoreWrite(String mapName,Data key,Object value,long delay){
  getMapContainer(mapName).getMapStoreWriteScheduler().schedule(delay,key,value);
}","public void scheduleMapStoreWrite(String mapName,Data key,Object value,long delay){
  getMapContainer(mapName).getMapStoreScheduler().schedule(delay,key,value);
}",0.9848024316109424
48373,"public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  long heapCost=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    InternalPartition partition=partitionService.getPartition(partitionId);
    Address owner=partition.getOwner();
    if (owner == null) {
    }
 else     if (owner.equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getExistingRecordStore(mapName);
      if (recordStore != null) {
        heapCost+=recordStore.getHeapCost();
        Map<Data,Record> records=recordStore.getReadonlyRecordMap();
        for (        Record record : records.values()) {
          RecordStatistics stats=record.getStatistics();
          ownedEntryCount++;
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(stats.getLastAccessTime());
          localMapStats.setLastUpdateTime(stats.getLastUpdateTime());
          hits+=stats.getHits();
          if (recordStore.isLocked(record.getKey())) {
            lockedEntryCount++;
          }
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          heapCost+=recordStore.getHeapCost();
          Map<Data,Record> records=recordStore.getReadonlyRecordMap();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.warning(""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  heapCost+=mapContainer.getNearCacheSizeEstimator().getSize();
  localMapStats.setHeapCost(heapCost);
  if (mapContainer.getMapConfig().isNearCacheEnabled()) {
    NearCacheStatsImpl nearCacheStats=getNearCache(mapName).getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
  }
  return localMapStats;
}","public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  long heapCost=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    InternalPartition partition=partitionService.getPartition(partitionId);
    Address owner=partition.getOwner();
    if (owner == null) {
    }
 else     if (owner.equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getExistingRecordStore(mapName);
      if (recordStore != null) {
        heapCost+=recordStore.getHeapCost();
        Map<Data,Record> records=recordStore.getReadonlyRecordMap();
        for (        Record record : records.values()) {
          RecordStatistics stats=record.getStatistics();
          ownedEntryCount++;
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(stats.getLastAccessTime());
          localMapStats.setLastUpdateTime(stats.getLastUpdateTime());
          hits+=stats.getHits();
          if (recordStore.isLocked(record.getKey())) {
            lockedEntryCount++;
          }
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          heapCost+=recordStore.getHeapCost();
          Map<Data,Record> records=recordStore.getReadonlyRecordMap();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.warning(""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  heapCost+=mapContainer.getNearCacheSizeEstimator().getSize();
  localMapStats.setHeapCost(heapCost);
  if (mapContainer.getMapConfig().isNearCacheEnabled()) {
    NearCacheStatsImpl nearCacheStats=getNearCache(mapName).getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
  }
  return localMapStats;
}",0.981345115365734
48374,"public RecordInfo(RecordStatistics statistics,long idleDelayMillis,long ttlDelayMillis,long mapStoreWriteDelayMillis,long mapStoreDeleteDelayMillis){
  this.statistics=statistics;
  this.idleDelayMillis=idleDelayMillis;
  this.ttlDelayMillis=ttlDelayMillis;
  this.mapStoreWriteDelayMillis=mapStoreWriteDelayMillis;
  this.mapStoreDeleteDelayMillis=mapStoreDeleteDelayMillis;
}","public RecordInfo(RecordStatistics statistics,long idleDelayMillis,long ttlDelayMillis){
  this(statistics,idleDelayMillis,ttlDelayMillis,-1,-1);
}",0.5229007633587787
48375,"@Override public <ValueOut>ReducingJob<EntryKey,Key,ValueOut> combiner(CombinerFactory<Key,Value,ValueOut> combinerFactory){
  ValidationUtil.isNotNull(combinerFactory,""String_Node_Str"");
  if (AbstractJob.this.combinerFactory != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  AbstractJob.this.combinerFactory=AbstractJob.this.combinerFactory;
  return new ReducingJobImpl<EntryKey,Key,ValueOut>();
}","@Override public <ValueOut>ReducingJob<EntryKey,Key,ValueOut> combiner(CombinerFactory<Key,Value,ValueOut> combinerFactory){
  ValidationUtil.isNotNull(combinerFactory,""String_Node_Str"");
  if (AbstractJob.this.combinerFactory != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  AbstractJob.this.combinerFactory=combinerFactory;
  return new ReducingJobImpl<EntryKey,Key,ValueOut>();
}",0.9794933655006032
48376,"@Override public void reduce(Integer value){
  sum+=value;
}","@Override public void reduce(Long value){
  sum+=value;
}",0.9401709401709402
48377,"@Override public Reducer<String,Integer,Integer> newReducer(String key){
  return new TestReducer();
}","@Override public Reducer<String,Long,Long> newReducer(String key){
  return new TestIntermediateReducer();
}",0.8761904761904762
48378,"@Override public Integer finalizeReduce(){
  return sum;
}","@Override public Long finalizeReduce(){
  return sum;
}",0.9380530973451328
48379,"@Override public Combiner<String,Integer,Integer> newCombiner(String key){
  return new TestCombiner();
}","@Override public Combiner<String,Integer,Long> newCombiner(String key){
  return new TestIntermediateCombiner();
}",0.91324200913242
48380,"@Override public Integer finalizeChunk(){
  int v=sum;
  sum=0;
  return v;
}","@Override public Long finalizeChunk(){
  int v=sum;
  sum=0;
  return Long.valueOf(v);
}",0.8727272727272727
48381,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  operationCallId=in.readLong();
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  serviceName=in.readUTF();
  identifier=in.readObject();
}",0.8184818481848185
48382,"@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeLong(operationCallId);
}","@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeUTF(serviceName);
  out.writeObject(identifier);
}",0.8291139240506329
48383,"private boolean isOperationExecuting(Address target){
  Boolean executing=Boolean.FALSE;
  try {
    final BasicInvocation inv=new BasicTargetInvocation(nodeEngine,serviceName,new IsStillExecuting(op.getCallId()),target,0,0,5000,null,null,true);
    Future f=inv.invoke();
    logger.warning(""String_Node_Str"" + toString());
    executing=(Boolean)nodeEngine.toObject(f.get(5000,TimeUnit.MILLISECONDS));
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + toString(),e);
  }
  logger.warning(""String_Node_Str"" + executing + ""String_Node_Str""+ toString());
  return executing;
}","private boolean isOperationExecuting(Address target){
  Boolean executing=Boolean.FALSE;
  try {
    Operation isStillExecuting;
    if (op instanceof TraceableOperation) {
      TraceableOperation traceable=(TraceableOperation)op;
      isStillExecuting=new TraceableIsStillExecuting(serviceName,traceable.getTraceIdentifier());
    }
 else {
      isStillExecuting=new IsStillExecuting(op.getCallId());
    }
    final BasicInvocation inv=new BasicTargetInvocation(nodeEngine,serviceName,isStillExecuting,target,0,0,5000,null,null,true);
    Future f=inv.invoke();
    logger.warning(""String_Node_Str"" + toString());
    executing=(Boolean)nodeEngine.toObject(f.get(5000,TimeUnit.MILLISECONDS));
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + toString(),e);
  }
  logger.warning(""String_Node_Str"" + executing + ""String_Node_Str""+ toString());
  return executing;
}",0.7527027027027027
48384,"@PrivateApi boolean isOperationExecuting(Address callerAddress,String callerUuid,long operationCallId){
  return executingCalls.containsKey(new RemoteCallKey(callerAddress,callerUuid,operationCallId));
}","@PrivateApi boolean isOperationExecuting(Address callerAddress,String callerUuid,String serviceName,Object identifier){
  Object service=nodeEngine.getService(serviceName);
  if (service == null) {
    logger.severe(""String_Node_Str"" + serviceName);
    return false;
  }
  if (service instanceof ExecutionTracingService) {
    return ((ExecutionTracingService)service).isOperationExecuting(callerAddress,callerUuid,identifier);
  }
  logger.severe(""String_Node_Str"" + service);
  return false;
}",0.2889842632331902
48385,"@Test public void testExecutorServiceStats() throws InterruptedException, ExecutionException {
  final IExecutorService executorService=createSingleNodeExecutorService(""String_Node_Str"");
  final int k=10;
  final CountDownLatch latch=new CountDownLatch(k);
  final int executionTime=200;
  for (int i=0; i < k; i++) {
    executorService.execute(new Runnable(){
      public void run(){
        try {
          Thread.sleep(executionTime);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        latch.countDown();
      }
    }
);
  }
  latch.await(2,TimeUnit.MINUTES);
  final Future<Boolean> f=executorService.submit(new CancellationAwareTask(10000));
  Thread.sleep(1000);
  f.cancel(true);
  try {
    f.get();
  }
 catch (  CancellationException e) {
  }
  final LocalExecutorStats stats=executorService.getLocalExecutorStats();
  assertEquals(k + 1,stats.getStartedTaskCount());
  assertEquals(k,stats.getCompletedTaskCount());
  assertEquals(0,stats.getPendingTaskCount());
  assertEquals(1,stats.getCancelledTaskCount());
}","@Test public void testExecutorServiceStats() throws InterruptedException, ExecutionException {
  final IExecutorService executorService=createSingleNodeExecutorService(""String_Node_Str"");
  final int k=10;
  final CountDownLatch latch=new CountDownLatch(k);
  final int executionTime=200;
  for (int i=0; i < k; i++) {
    executorService.execute(new Runnable(){
      public void run(){
        try {
          Thread.sleep(executionTime);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        latch.countDown();
      }
    }
);
  }
  latch.await(2,TimeUnit.MINUTES);
  final Future<Boolean> f=executorService.submit(new SleepingTask(10000));
  Thread.sleep(1000);
  f.cancel(true);
  try {
    f.get();
  }
 catch (  CancellationException e) {
  }
  final LocalExecutorStats stats=executorService.getLocalExecutorStats();
  assertEquals(k + 1,stats.getStartedTaskCount());
  assertEquals(k,stats.getCompletedTaskCount());
  assertEquals(0,stats.getPendingTaskCount());
  assertEquals(1,stats.getCancelledTaskCount());
}",0.9883558453656264
48386,"@Test public void testCancellationAwareTask2(){
  Callable task1=new CancellationAwareTask(5000);
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"",1);
  executor.submit(task1);
  Callable task2=new BasicTestTask();
  Future future=executor.submit(task2);
  assertFalse(future.isDone());
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException expected) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testCancellationAwareTask2(){
  Callable task1=new SleepingTask(5000);
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"",1);
  executor.submit(task1);
  Callable task2=new BasicTestTask();
  Future future=executor.submit(task2);
  assertFalse(future.isDone());
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException expected) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}",0.9785038693035254
48387,"@Test public void testInvokeAllTimeoutCancelled() throws Exception {
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"");
  assertFalse(executor.isShutdown());
  ArrayList<Callable<Boolean>> tasks=new ArrayList<Callable<Boolean>>();
  tasks.add(new CancellationAwareTask(0));
  List<Future<Boolean>> futures=executor.invokeAll(tasks,5,TimeUnit.SECONDS);
  assertEquals(futures.size(),1);
  assertEquals(futures.get(0).get(),Boolean.TRUE);
  tasks.clear();
  for (int i=0; i < COUNT; i++) {
    tasks.add(new CancellationAwareTask(i < 2 ? 0 : 20000));
  }
  futures=executor.invokeAll(tasks,5,TimeUnit.SECONDS);
  assertEquals(futures.size(),COUNT);
  for (int i=0; i < COUNT; i++) {
    if (i < 2) {
      assertEquals(futures.get(i).get(),Boolean.TRUE);
    }
 else {
      boolean excepted=false;
      try {
        futures.get(i).get();
      }
 catch (      CancellationException e) {
        excepted=true;
      }
      assertTrue(excepted);
    }
  }
}","@Test public void testInvokeAllTimeoutCancelled() throws Exception {
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"");
  assertFalse(executor.isShutdown());
  ArrayList<Callable<Boolean>> tasks=new ArrayList<Callable<Boolean>>();
  tasks.add(new SleepingTask(0));
  List<Future<Boolean>> futures=executor.invokeAll(tasks,5,TimeUnit.SECONDS);
  assertEquals(futures.size(),1);
  assertEquals(futures.get(0).get(),Boolean.TRUE);
  tasks.clear();
  for (int i=0; i < COUNT; i++) {
    tasks.add(new SleepingTask(i < 2 ? 0 : 20000));
  }
  futures=executor.invokeAll(tasks,5,TimeUnit.SECONDS);
  assertEquals(futures.size(),COUNT);
  for (int i=0; i < COUNT; i++) {
    if (i < 2) {
      assertEquals(futures.get(i).get(),Boolean.TRUE);
    }
 else {
      boolean excepted=false;
      try {
        futures.get(i).get();
      }
 catch (      CancellationException e) {
        excepted=true;
      }
      assertTrue(excepted);
    }
  }
}",0.9744114636642784
48388,"@Test public void testCancellationAwareTask() throws ExecutionException, InterruptedException {
  CancellationAwareTask task=new CancellationAwareTask(5000);
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"");
  Future future=executor.submit(task);
  try {
    future.get(2,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  TimeoutException expected) {
  }
  assertFalse(future.isDone());
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException expected) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testCancellationAwareTask() throws ExecutionException, InterruptedException {
  SleepingTask task=new SleepingTask(5000);
  ExecutorService executor=createSingleNodeExecutorService(""String_Node_Str"");
  Future future=executor.submit(task);
  try {
    future.get(2,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  TimeoutException expected) {
  }
  assertFalse(future.isDone());
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException expected) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}",0.9637681159420288
48389,"private Address getMemberAddress(Member member){
  MemberImpl m=getContext().getClusterService().getMember(member.getUuid());
  if (m == null) {
    throw new HazelcastException(""String_Node_Str"" + m + ""String_Node_Str"");
  }
  return m.getAddress();
}","private Address getMemberAddress(Member member){
  MemberImpl m=getContext().getClusterService().getMember(member.getUuid());
  if (m == null) {
    throw new HazelcastException(member + ""String_Node_Str"");
  }
  return m.getAddress();
}",0.9325153374233128
48390,"private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  BasicOperationService operationService=(BasicOperationService)nodeEngine.operationService;
  final long defaultCallTimeout=operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      return waitTimeoutMillis + (defaultCallTimeout > PLUS_TIMEOUT ? PLUS_TIMEOUT : defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}","private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  BasicOperationService operationService=(BasicOperationService)nodeEngine.operationService;
  final long defaultCallTimeout=operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      final long max=Math.max(waitTimeoutMillis,MIN_TIMEOUT);
      return Math.min(max,defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}",0.906801007556675
48391,"@Test(timeout=60000) @Category(ProblematicTest.class) public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final HazelcastInstance hz=createHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}","@Test(timeout=60000) public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final HazelcastInstance hz=createHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}",0.9794903666873834
48392,"private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  final long defaultCallTimeout=nodeEngine.operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      return waitTimeoutMillis + (defaultCallTimeout > PLUS_TIMEOUT ? PLUS_TIMEOUT : defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}","private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  final long defaultCallTimeout=nodeEngine.operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      final long max=Math.max(waitTimeoutMillis,MIN_TIMEOUT);
      return Math.min(max,defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}",0.8919182083739046
48393,"@Test @Ignore public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}","@Test public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}",0.9954022988505749
48394,"private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  final long defaultCallTimeout=nodeEngine.operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      final long max=Math.max(waitTimeoutMillis,MIN_TIMEOUT);
      return Math.min(max,defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}","private long getCallTimeout(long callTimeout){
  if (callTimeout > 0) {
    return callTimeout;
  }
  final long defaultCallTimeout=nodeEngine.operationService.getDefaultCallTimeout();
  if (op instanceof WaitSupport) {
    final long waitTimeoutMillis=((WaitSupport)op).getWaitTimeoutMillis();
    if (waitTimeoutMillis > 0 && waitTimeoutMillis < Long.MAX_VALUE) {
      return waitTimeoutMillis + (defaultCallTimeout > PLUS_TIMEOUT ? PLUS_TIMEOUT : defaultCallTimeout);
    }
  }
  return defaultCallTimeout;
}",0.8276533592989289
48395,"@Test public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}","@Test @Ignore public void testLockInterruption() throws InterruptedException {
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  final Lock lock=hz.getLock(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        lock.tryLock(60,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
        latch.countDown();
      }
    }
  }
);
  lock.lock();
  t.start();
  Thread.sleep(2000);
  t.interrupt();
  assertTrue(""String_Node_Str"",latch.await(30,TimeUnit.SECONDS));
  lock.unlock();
  assertTrue(""String_Node_Str"",lock.tryLock());
}",0.9954022988505749
48396,"public Object getAttribute(final String name){
  IMap<String,Object> clusterMap=getClusterMap();
  if (deferredWrite) {
    LocalCacheEntry cacheEntry=localCache.get(name);
    if (cacheEntry == null || cacheEntry.reload) {
      Object value=clusterMap.get(buildAttributeName(name));
      if (value == null) {
        cacheEntry=NULL_ENTRY;
      }
 else {
        cacheEntry=new LocalCacheEntry();
        cacheEntry.value=value;
        cacheEntry.reload=false;
      }
      localCache.put(name,NULL_ENTRY);
    }
    return cacheEntry != NULL_ENTRY ? cacheEntry.value : null;
  }
  return clusterMap.get(buildAttributeName(name));
}","public Object getAttribute(final String name){
  IMap<String,Object> clusterMap=getClusterMap();
  if (deferredWrite) {
    LocalCacheEntry cacheEntry=localCache.get(name);
    if (cacheEntry == null || cacheEntry.reload) {
      Object value=clusterMap.get(buildAttributeName(name));
      if (value == null) {
        cacheEntry=NULL_ENTRY;
      }
 else {
        cacheEntry=new LocalCacheEntry();
        cacheEntry.value=value;
        cacheEntry.reload=false;
      }
      localCache.put(name,cacheEntry);
    }
    return cacheEntry != NULL_ENTRY ? cacheEntry.value : null;
  }
  return clusterMap.get(buildAttributeName(name));
}",0.9310344827586208
48397,"private Record getRecordInternal(Data dataKey,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}","private Record getRecordInternal(Data dataKey,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL);
      records.put(dataKey,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}",0.9865563598759048
48398,"public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getCost(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}","public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,DEFAULT_TTL);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getCost(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}",0.9948555599525128
48399,"public boolean containsKey(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
  boolean contains=record != null;
  if (contains) {
    accessRecord(record);
  }
  return contains;
}","public boolean containsKey(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
  boolean contains=record != null;
  if (contains) {
    accessRecord(record);
  }
  return contains;
}",0.9882988298829884
48400,"public Object get(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    value=record.getValue();
  }
  value=mapService.interceptGet(name,value);
  return value;
}","public Object get(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    value=record.getValue();
  }
  value=mapService.interceptGet(name,value);
  return value;
}",0.9894050529747352
48401,"public MapEntrySet getAll(Set<Data> keySet){
  checkIfLoaded();
  final MapEntrySet mapEntrySet=new MapEntrySet();
  Map<Object,Data> keyMapForLoader=null;
  if (mapContainer.getStore() != null) {
    keyMapForLoader=new HashMap<Object,Data>();
  }
  for (  Data dataKey : keySet) {
    Record record=records.get(dataKey);
    if (record == null) {
      if (mapContainer.getStore() != null) {
        keyMapForLoader.put(mapService.toObject(dataKey),dataKey);
      }
    }
 else {
      accessRecord(record);
      Object value=record.getValue();
      value=mapService.interceptGet(name,value);
      if (value != null) {
        mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
      }
    }
  }
  if (mapContainer.getStore() == null || keyMapForLoader.size() == 0) {
    return mapEntrySet;
  }
  final Map<Object,Object> loadedKeys=mapContainer.getStore().loadAll(keyMapForLoader.keySet());
  for (  Map.Entry entry : loadedKeys.entrySet()) {
    final Object objectKey=entry.getKey();
    Object value=entry.getValue();
    Data dataKey=keyMapForLoader.get(objectKey);
    if (value != null) {
      Record record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
    value=mapService.interceptGet(name,value);
    if (value != null) {
      mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
    }
  }
  return mapEntrySet;
}","public MapEntrySet getAll(Set<Data> keySet){
  checkIfLoaded();
  final MapEntrySet mapEntrySet=new MapEntrySet();
  Map<Object,Data> keyMapForLoader=null;
  if (mapContainer.getStore() != null) {
    keyMapForLoader=new HashMap<Object,Data>();
  }
  for (  Data dataKey : keySet) {
    Record record=records.get(dataKey);
    if (record == null) {
      if (mapContainer.getStore() != null) {
        keyMapForLoader.put(mapService.toObject(dataKey),dataKey);
      }
    }
 else {
      accessRecord(record);
      Object value=record.getValue();
      value=mapService.interceptGet(name,value);
      if (value != null) {
        mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
      }
    }
  }
  if (mapContainer.getStore() == null || keyMapForLoader.size() == 0) {
    return mapEntrySet;
  }
  final Map<Object,Object> loadedKeys=mapContainer.getStore().loadAll(keyMapForLoader.keySet());
  for (  Map.Entry entry : loadedKeys.entrySet()) {
    final Object objectKey=entry.getKey();
    Object value=entry.getValue();
    Data dataKey=keyMapForLoader.get(objectKey);
    if (value != null) {
      Record record=mapService.createRecord(name,dataKey,value,DEFAULT_TTL);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
    value=mapService.interceptGet(name,value);
    if (value != null) {
      mapEntrySet.add(new AbstractMap.SimpleImmutableEntry(dataKey,mapService.toData(value)));
    }
  }
  return mapEntrySet;
}",0.995766851188538
48402,"public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}","public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,DEFAULT_TTL);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}",0.9928374655647384
48403,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}","public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.putBackup(dataKey,entry.getValue());
    }
  }
}",0.9266331658291456
48404,"public void run(){
  Map.Entry entry;
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    Data dataKey=recordEntry.getKey();
    Record record=recordEntry.getValue();
    entry=new AbstractMap.SimpleEntry(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}","public void run(){
  Map.Entry entry;
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    Data dataKey=recordEntry.getKey();
    Record record=recordEntry.getValue();
    entry=new AbstractMap.SimpleEntry(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.putBackup(dataKey,entry.getValue());
    }
  }
}",0.9444021325209444
48405,"public void run(){
  Record record=recordStore.getRecord(dataKey);
  if (record == null) {
    record=mapService.createRecord(name,dataKey,dataValue,ttl,false);
    updateSizeEstimator(calculateRecordSize(record));
    recordStore.putRecord(dataKey,record);
  }
 else {
    updateSizeEstimator(-calculateRecordSize(record));
    mapContainer.getRecordFactory().setValue(record,dataValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  if (unlockKey) {
    recordStore.forceUnlock(dataKey);
  }
}","public void run(){
  recordStore.putBackup(dataKey,dataValue,ttl,false);
  if (unlockKey) {
    recordStore.forceUnlock(dataKey);
  }
}",0.3975155279503105
48406,"public Object getAttribute(final String name){
  IMap<String,Object> clusterMap=getClusterMap();
  if (deferredWrite) {
    LocalCacheEntry cacheEntry=localCache.get(name);
    if (cacheEntry == null || cacheEntry.reload) {
      Object value=clusterMap.get(buildAttributeName(name));
      if (value == null) {
        cacheEntry=NULL_ENTRY;
      }
 else {
        cacheEntry=new LocalCacheEntry();
        cacheEntry.value=value;
        cacheEntry.reload=false;
      }
      localCache.put(name,NULL_ENTRY);
    }
    return cacheEntry != NULL_ENTRY ? cacheEntry.value : null;
  }
  return clusterMap.get(buildAttributeName(name));
}","public Object getAttribute(final String name){
  IMap<String,Object> clusterMap=getClusterMap();
  if (deferredWrite) {
    LocalCacheEntry cacheEntry=localCache.get(name);
    if (cacheEntry == null || cacheEntry.reload) {
      Object value=clusterMap.get(buildAttributeName(name));
      if (value == null) {
        cacheEntry=NULL_ENTRY;
      }
 else {
        cacheEntry=new LocalCacheEntry();
        cacheEntry.value=value;
        cacheEntry.reload=false;
      }
      localCache.put(name,cacheEntry);
    }
    return cacheEntry != NULL_ENTRY ? cacheEntry.value : null;
  }
  return clusterMap.get(buildAttributeName(name));
}",0.9310344827586208
48407,"public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
      invalidateLocalNearCache(dataKey);
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}","public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9796526054590572
48408,"@Before public void setUp() throws Exception {
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(mapName);
  NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setEvictionPolicy(""String_Node_Str"");
  nearCacheConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  nearCacheConfig.setCacheLocalEntries(true);
  mapConfig.setNearCacheConfig(nearCacheConfig);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  hcInstance=factory.newHazelcastInstance(config);
  hcInstance2=factory.newHazelcastInstance(config);
}","@Before public void setUp() throws Exception {
  Config config=new Config();
  MapConfig mapConfig=config.getMapConfig(mapName);
  NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setEvictionPolicy(""String_Node_Str"");
  nearCacheConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  nearCacheConfig.setCacheLocalEntries(true);
  mapConfig.setNearCacheConfig(nearCacheConfig);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  hcInstance=factory.newHazelcastInstance(config);
  hcInstance2=factory.newHazelcastInstance(config);
}",0.9750830564784052
48409,"public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      return nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public ICompletableFuture executeOnKeyInternal(Data key,EntryProcessor entryProcessor,ExecutionCallback callback){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  EntryOperation operation=new EntryOperation(name,key,entryProcessor);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    if (callback == null) {
      return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
    }
 else {
      ICompletableFuture future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).setCallback(new MapExecutionCallbackAdapter(callback)).invoke();
      invalidateLocalNearCache(key);
      return future;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9426591052299936
48410,"private void invalidateLocalNearCache(Data key){
  final MapConfig config=mapConfig;
  final boolean nearCacheEnabled=config.isNearCacheEnabled();
  if (!nearCacheEnabled) {
    return;
  }
  final boolean cacheLocalEntries=config.getNearCacheConfig().isCacheLocalEntries();
  if (!cacheLocalEntries) {
    return;
  }
  final MapService mapService=getService();
  mapService.invalidateNearCache(name,key);
}","private void invalidateLocalNearCache(Set<Data> keys){
  if (keys == null || keys.isEmpty()) {
    return;
  }
  getService().invalidateLocalNearCache(name,keys);
}",0.4370629370629371
48411,"public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","public Map executeOnEntries(EntryProcessor entryProcessor,Predicate predicate){
  Map result=new HashMap();
  try {
    NodeEngine nodeEngine=getNodeEngine();
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new PartitionWideEntryWithPredicateOperationFactory(name,entryProcessor,predicate));
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          final Data key=entry.getKey();
          result.put(service.toObject(key),service.toObject(entry.getValue()));
          invalidateLocalNearCache(key);
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.939963614311704
48412,"public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","public Map executeOnKeysInternal(Set<Data> keys,EntryProcessor entryProcessor){
  Map result=new HashMap();
  final NodeEngine nodeEngine=getNodeEngine();
  final Collection<Integer> partitionsForKeys=getPartitionsForKeys(keys);
  try {
    MultipleEntryOperationFactory operationFactory=new MultipleEntryOperationFactory(name,keys,entryProcessor);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,operationFactory,partitionsForKeys);
    for (    Object o : results.values()) {
      if (o != null) {
        final MapService service=getService();
        final MapEntrySet mapEntrySet=(MapEntrySet)o;
        for (        Entry<Data,Data> entry : mapEntrySet.getEntrySet()) {
          result.put(service.toObject(entry.getKey()),service.toObject(entry.getValue()));
        }
      }
    }
    invalidateLocalNearCache(keys);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9809725158562368
48413,"@Override public Object process(Map.Entry<String,Text> entry){
  Text text=entry.getValue();
  text.setContent(""String_Node_Str"");
  entry.setValue(text);
  return ""String_Node_Str"";
}","@Override public Object process(Map.Entry<String,String> entry){
  entry.setValue(""String_Node_Str"");
  return ""String_Node_Str"";
}",0.7936507936507936
48414,"@Test public void testExecuteOnKeys(){
  final IMap<String,Text> map=hcInstance.getMap(mapName);
  for (int k=0; k < numIterations; k++) {
    String key=""String_Node_Str"" + String.valueOf(k);
    Text value0=new Text(""String_Node_Str"" + k);
    map.put(key,value0);
    map.get(key);
    Text value1=map.get(key);
    Text value2=map.get(key);
    assertTrue(""String_Node_Str"" + k + ""String_Node_Str""+ value1+ ""String_Node_Str""+ value2,value1 == value2);
    final HashSet<String> keys=new HashSet<String>();
    keys.add(key);
    map.executeOnKeys(keys,new ReadingEntryProcessor());
    map.executeOnKeys(keys,new WritingEntryProcessor());
    Text value4=map.get(key);
    assertFalse(""String_Node_Str"" + k + ""String_Node_Str"",value1 == value4);
  }
}","@Test public void testExecuteOnKeys(){
  final IMap<String,String> map=hcInstance.getMap(mapName);
  for (int k=0; k < numIterations; k++) {
    String key=""String_Node_Str"" + String.valueOf(k);
    final String expectedNull=map.get(key);
    assertNull(expectedNull);
    final HashSet<String> keys=new HashSet<String>();
    keys.add(key);
    final Object o=map.executeOnKeys(keys,new WritingEntryProcessor());
    final Map<String,String> result=(Map)o;
    for (    Map.Entry<String,String> e : result.entrySet()) {
      final String newValue=e.getValue();
      final String cachedValue=map.get(e.getKey());
      assertEquals(newValue,cachedValue);
    }
  }
}",0.2993675333801827
48415,"@After public void tearDown() throws Exception {
  hcInstance.getLifecycleService().shutdown();
}","@After public void tearDown() throws Exception {
  hcInstance.getLifecycleService().shutdown();
  hcInstance2.getLifecycleService().shutdown();
}",0.8016528925619835
48416,"@Test public void testExecuteOnKey(){
  final IMap<String,Text> map=hcInstance.getMap(mapName);
  for (int k=0; k < numIterations; k++) {
    String key=""String_Node_Str"" + String.valueOf(k);
    Text value0=new Text(""String_Node_Str"" + k);
    map.put(key,value0);
    map.get(key);
    Text value1=map.get(key);
    Text value2=map.get(key);
    assertTrue(""String_Node_Str"" + k + ""String_Node_Str""+ value1+ ""String_Node_Str""+ value2,value1 == value2);
    final HashSet<String> strings=new HashSet<String>();
    strings.add(key);
    map.executeOnKey(key,new ReadingEntryProcessor());
    map.executeOnKey(key,new WritingEntryProcessor());
    Text value4=map.get(key);
    assertFalse(""String_Node_Str"" + k + ""String_Node_Str"",value1 == value4);
  }
}","@Test public void testExecuteOnKey(){
  final IMap<String,String> map=hcInstance.getMap(mapName);
  for (int k=0; k < numIterations; k++) {
    String key=""String_Node_Str"" + String.valueOf(k);
    final String expectedNull=map.get(key);
    assertNull(expectedNull);
    final Object o=map.executeOnKey(key,new WritingEntryProcessor());
    final String newValue=(String)o;
    String value2=map.get(key);
    assertEquals(newValue,value2);
  }
}",0.3624272651704073
48417,"@Before public void setUp() throws Exception {
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(mapName);
  NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setEvictionPolicy(""String_Node_Str"");
  nearCacheConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  nearCacheConfig.setCacheLocalEntries(true);
  mapConfig.setNearCacheConfig(nearCacheConfig);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(1);
  hcInstance=factory.newHazelcastInstance(config);
}","@Before public void setUp() throws Exception {
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(mapName);
  NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setEvictionPolicy(""String_Node_Str"");
  nearCacheConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  nearCacheConfig.setCacheLocalEntries(true);
  mapConfig.setNearCacheConfig(nearCacheConfig);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  hcInstance=factory.newHazelcastInstance(config);
  hcInstance2=factory.newHazelcastInstance(config);
}",0.9430051813471504
48418,"private PortableContext getPortableContext(int factoryId){
  final PortableContext ctx=portableContextMap.get(factoryId);
  if (ctx == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  return ctx;
}","private PortableContext getPortableContext(int factoryId){
  return ConcurrencyUtil.getOrPutIfAbsent(portableContextMap,factoryId,constructorFunction);
}",0.55470737913486
48419,"SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  final Map<Integer,PortableContext> portableMap=new HashMap<Integer,PortableContext>();
  for (  int factoryId : portableFactories) {
    portableMap.put(factoryId,new PortableContext());
  }
  portableContextMap=portableMap;
}","SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  for (  int factoryId : portableFactories) {
    portableContextMap.put(factoryId,new PortableContext());
  }
}",0.7111716621253406
48420,"private PortableContext getPortableContext(int factoryId){
  final PortableContext ctx=portableContextMap.get(factoryId);
  if (ctx == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  return ctx;
}","private PortableContext getPortableContext(int factoryId){
  return ConcurrencyUtil.getOrPutIfAbsent(portableContextMap,factoryId,constructorFunction);
}",0.55470737913486
48421,"SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  final Map<Integer,PortableContext> portableMap=new HashMap<Integer,PortableContext>();
  for (  int factoryId : portableFactories) {
    portableMap.put(factoryId,new PortableContext());
  }
  portableContextMap=portableMap;
}","SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  for (  int factoryId : portableFactories) {
    portableContextMap.put(factoryId,new PortableContext());
  }
}",0.7111716621253406
48422,"@Test(timeout=1000 * 60) @Category(ProblematicTest.class) public void testQueryDuringAndAfterMigrationWithIndex() throws Exception {
  Config cfg=new Config();
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(cfg);
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  int size=50000;
  for (int i=0; i < size; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i & 1) == 1),(double)i));
  }
  assertEquals(size,imap.size());
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(cfg);
  long startNow=Clock.currentTimeMillis();
  while ((Clock.currentTimeMillis() - startNow) < 10000) {
    Collection<Employee> values=imap.values(new SqlPredicate(""String_Node_Str""));
    for (    Employee employee : values) {
      assertTrue(employee.isActive());
    }
    assertEquals(556,values.size());
  }
}","@Test public void testQueryDuringAndAfterMigrationWithIndex() throws Exception {
  Config cfg=new Config();
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  final HazelcastInstance h1=nodeFactory.newHazelcastInstance(cfg);
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  int size=500;
  for (int i=0; i < size; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i & 1) == 1),(double)i));
  }
  assertEquals(size,imap.size());
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance h4=nodeFactory.newHazelcastInstance(cfg);
  final IMap employees=h1.getMap(""String_Node_Str"");
  assertTrueAllTheTime(new AssertTask(){
    @Override public void run() throws Exception {
      Collection<Employee> values=employees.values(new SqlPredicate(""String_Node_Str""));
      for (      Employee employee : values) {
        assertTrue(employee.isActive());
      }
      assertEquals(6,values.size());
    }
  }
,3);
}",0.8565310492505354
48423,"@Test(timeout=1000 * 60) @Category(ProblematicTest.class) public void testTwoNodesWithPartialIndexes() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  for (int i=0; i < 5000; i++) {
    Employee employee=new Employee(i,""String_Node_Str"" + i % 100,""String_Node_Str"" + (i % 100),i % 60,((i & 1) == 1),(double)i);
    imap.put(String.valueOf(i),employee);
  }
  assertEquals(2,h1.getCluster().getMembers().size());
  assertEquals(2,h2.getCluster().getMembers().size());
  imap=h2.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  Collection<Employee> entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(50,entries.size());
  for (  Employee e : entries) {
    assertEquals(""String_Node_Str"",e.getName());
    assertEquals(""String_Node_Str"",e.getCity());
  }
  entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(50,entries.size());
  for (  Employee e : entries) {
    assertEquals(""String_Node_Str"",e.getName());
    assertEquals(""String_Node_Str"",e.getCity());
    assertTrue(e.getAge() > 2);
  }
  entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(50,entries.size());
  for (  Employee e : entries) {
    assertTrue(e.getName().startsWith(""String_Node_Str""));
    assertTrue(e.getCity().startsWith(""String_Node_Str""));
  }
}","@Test(timeout=1000 * 60) public void testTwoNodesWithPartialIndexes() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  for (int i=0; i < 500; i++) {
    Employee employee=new Employee(i,""String_Node_Str"" + i % 100,""String_Node_Str"" + (i % 100),i % 60,((i & 1) == 1),(double)i);
    imap.put(String.valueOf(i),employee);
  }
  assertEquals(2,h1.getCluster().getMembers().size());
  assertEquals(2,h2.getCluster().getMembers().size());
  imap=h2.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  Collection<Employee> entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(5,entries.size());
  for (  Employee e : entries) {
    assertEquals(""String_Node_Str"",e.getName());
    assertEquals(""String_Node_Str"",e.getCity());
  }
  entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(5,entries.size());
  for (  Employee e : entries) {
    assertEquals(""String_Node_Str"",e.getName());
    assertEquals(""String_Node_Str"",e.getCity());
    assertTrue(e.getAge() > 2);
  }
  entries=imap.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(5,entries.size());
  for (  Employee e : entries) {
    assertTrue(e.getName().startsWith(""String_Node_Str""));
    assertTrue(e.getCity().startsWith(""String_Node_Str""));
  }
}",0.9891844489915228
48424,"@Test(timeout=1000 * 60) @Category(ProblematicTest.class) public void testQueryWithIndexesWhileMigrating() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  for (int i=0; i < 500; i++) {
    Map temp=new HashMap(100);
    for (int j=0; j < 100; j++) {
      String key=String.valueOf((i * 100000) + j);
      temp.put(key,new Employee(""String_Node_Str"" + key,i % 60,((i & 1) == 1),(double)i));
    }
    imap.putAll(temp);
  }
  assertEquals(50000,imap.size());
  Set<Map.Entry> entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(6400,entries.size());
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  HazelcastInstance h4=nodeFactory.newHazelcastInstance();
  long startNow=Clock.currentTimeMillis();
  while ((Clock.currentTimeMillis() - startNow) < 10000) {
    entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
    assertEquals(6400,entries.size());
  }
}","@Test public void testQueryWithIndexesWhileMigrating() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(4);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  IMap imap=h1.getMap(""String_Node_Str"");
  imap.addIndex(""String_Node_Str"",false);
  imap.addIndex(""String_Node_Str"",true);
  imap.addIndex(""String_Node_Str"",false);
  for (int i=0; i < 50; i++) {
    Map temp=new HashMap(10);
    for (int j=0; j < 10; j++) {
      String key=String.valueOf((i * 100000) + j);
      temp.put(key,new Employee(""String_Node_Str"" + key,i % 60,((i & 1) == 1),(double)i));
    }
    imap.putAll(temp);
  }
  assertEquals(500,imap.size());
  Set<Map.Entry> entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(30,entries.size());
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  HazelcastInstance h4=nodeFactory.newHazelcastInstance();
  long startNow=Clock.currentTimeMillis();
  while ((Clock.currentTimeMillis() - startNow) < 10000) {
    entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
    assertEquals(30,entries.size());
  }
}",0.9730848861283644
48425,"private PortableContext getPortableContext(int factoryId){
  final PortableContext ctx=portableContextMap.get(factoryId);
  if (ctx == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  return ctx;
}","private PortableContext getPortableContext(int factoryId){
  return ConcurrencyUtil.getOrPutIfAbsent(portableContextMap,factoryId,constructorFunction);
}",0.55470737913486
48426,"SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  final Map<Integer,PortableContext> portableMap=new HashMap<Integer,PortableContext>();
  for (  int factoryId : portableFactories) {
    portableMap.put(factoryId,new PortableContext());
  }
  portableContextMap=portableMap;
}","SerializationContextImpl(SerializationServiceImpl serializationService,Collection<Integer> portableFactories,int version){
  this.serializationService=serializationService;
  this.version=version;
  for (  int factoryId : portableFactories) {
    portableContextMap.put(factoryId,new PortableContext());
  }
}",0.7111716621253406
48427,"public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}","public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
      invalidateLocalNearCache(dataKey);
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9796526054590572
48428,"@Override public void run() throws Exception {
  response=new MapEntrySet();
  final InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Object valueBeforeProcess=mapService.toObject(mapEntry.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(key,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(key);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      Data dataOldValue=mapService.toData(mapEntry.getValue());
      mapService.publishEvent(getCallerAddress(),name,eventType,key,dataOldValue,dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,key);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,key,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(key);
          Data tempValue=mapService.toData(dataValue);
          RecordStatistics statistics=r.getStatistics();
          long cost=r.getCost();
          long version=r.getVersion();
          SimpleEntryView entryView=new SimpleEntryView(key,tempValue,statistics,cost,version);
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","@Override public void run() throws Exception {
  response=new MapEntrySet();
  final InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Object valueBeforeProcess=mapService.toObject(mapEntry.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(key,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(key);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      Data dataOldValue=mapService.toData(mapEntry.getValue());
      mapService.publishEvent(getCallerAddress(),name,eventType,key,dataOldValue,dataValue);
      if (mapService.isNearCacheAndInvalidationEnabled(name)) {
        mapService.invalidateAllNearCaches(name,key);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,key,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(key);
          Data tempValue=mapService.toData(dataValue);
          RecordStatistics statistics=r.getStatistics();
          long cost=r.getCost();
          long version=r.getVersion();
          SimpleEntryView entryView=new SimpleEntryView(key,tempValue,statistics,cost,version);
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9754843811783314
48429,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getCost(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapService.isNearCacheAndInvalidationEnabled(name)) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getCost(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9758095981271948
48430,"@Test @Category(ProblematicTest.class) public void testIssue859And863() throws Exception {
  final int numberOfMessages=20000;
  final AtomicInteger count=new AtomicInteger();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=factory.newHazelcastInstance();
  HazelcastInstance instance2=factory.newHazelcastInstance();
  String inQueueName=""String_Node_Str"";
  String outQueueName=""String_Node_Str"";
  for (int i=0; i < numberOfMessages; i++) {
    if (!instance1.getQueue(inQueueName).offer(new byte[1024])) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
class MoveMessage extends Thread {
    private final HazelcastInstance hazelcastInstance;
    private final String inQueueName;
    private final String outQueueName;
    private volatile boolean active=true;
    public MoveMessage(    HazelcastInstance hazelcastInstance,    String inQueueName,    String outQueueName){
      this.hazelcastInstance=hazelcastInstance;
      this.inQueueName=inQueueName;
      this.outQueueName=outQueueName;
    }
    public void run(){
      while (active && count.get() != numberOfMessages && hazelcastInstance.getLifecycleService().isRunning()) {
        TransactionContext transactionContext=hazelcastInstance.newTransactionContext();
        try {
          transactionContext.beginTransaction();
        }
 catch (        HazelcastInstanceNotActiveException ignored) {
          break;
        }
        try {
          TransactionalQueue<Object> queue=transactionContext.getQueue(inQueueName);
          Object value=queue.poll();
          if (value != null) {
            TransactionalQueue<Object> outQueue=transactionContext.getQueue(outQueueName);
            if (!outQueue.offer(value)) {
              throw new RuntimeException();
            }
          }
          transactionContext.commitTransaction();
          if (value != null) {
            count.incrementAndGet();
          }
        }
 catch (        Exception e) {
          try {
            transactionContext.rollbackTransaction();
          }
 catch (          HazelcastInstanceNotActiveException ignored) {
          }
        }
      }
    }
  }
  MoveMessage moveMessage1=new MoveMessage(instance1,inQueueName,outQueueName);
  MoveMessage moveMessage2=new MoveMessage(instance2,inQueueName,outQueueName);
  moveMessage1.start();
  moveMessage2.start();
  while (count.get() < numberOfMessages / 2) {
    Thread.sleep(10);
  }
  instance2.getLifecycleService().terminate();
  moveMessage2.active=false;
  moveMessage2.join(10000);
  moveMessage1.join(30000);
  try {
    assertEquals(numberOfMessages,instance1.getQueue(outQueueName).size());
    assertTrue(instance1.getQueue(inQueueName).isEmpty());
  }
  finally {
    moveMessage1.active=false;
  }
}","/** 
 * Moved from   {@link com.hazelcast.test.annotation.ProblematicTest}
 * @throws Exception
 */
@Test public void testIssue859And863() throws Exception {
  final int numberOfMessages=2000;
  final AtomicInteger count=new AtomicInteger();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=factory.newHazelcastInstance();
  HazelcastInstance instance2=factory.newHazelcastInstance();
  String inQueueName=""String_Node_Str"";
  String outQueueName=""String_Node_Str"";
  for (int i=0; i < numberOfMessages; i++) {
    if (!instance1.getQueue(inQueueName).offer(i)) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
class MoveMessage extends Thread {
    private final HazelcastInstance hazelcastInstance;
    private final String inQueueName;
    private final String outQueueName;
    private volatile boolean active=true;
    public MoveMessage(    HazelcastInstance hazelcastInstance,    String inQueueName,    String outQueueName){
      this.hazelcastInstance=hazelcastInstance;
      this.inQueueName=inQueueName;
      this.outQueueName=outQueueName;
    }
    public void run(){
      while (active && count.get() != numberOfMessages && hazelcastInstance.getLifecycleService().isRunning()) {
        TransactionContext transactionContext=hazelcastInstance.newTransactionContext();
        try {
          transactionContext.beginTransaction();
        }
 catch (        HazelcastInstanceNotActiveException ignored) {
          break;
        }
        try {
          TransactionalQueue<Object> queue=transactionContext.getQueue(inQueueName);
          Object value=queue.poll();
          if (value != null) {
            TransactionalQueue<Object> outQueue=transactionContext.getQueue(outQueueName);
            if (!outQueue.offer(value)) {
              throw new RuntimeException();
            }
          }
          transactionContext.commitTransaction();
          if (value != null) {
            count.incrementAndGet();
          }
        }
 catch (        Exception e) {
          try {
            transactionContext.rollbackTransaction();
          }
 catch (          HazelcastInstanceNotActiveException ignored) {
          }
        }
      }
    }
  }
  MoveMessage moveMessage1=new MoveMessage(instance1,inQueueName,outQueueName);
  MoveMessage moveMessage2=new MoveMessage(instance2,inQueueName,outQueueName);
  moveMessage1.start();
  moveMessage2.start();
  while (count.get() < numberOfMessages / 2) {
    sleepMillis(1);
  }
  instance2.getLifecycleService().terminate();
  moveMessage2.active=false;
  moveMessage2.join(10000);
  moveMessage1.join(10000);
  try {
    assertEquals(numberOfMessages,instance1.getQueue(outQueueName).size());
    assertTrue(instance1.getQueue(inQueueName).isEmpty());
  }
  finally {
    moveMessage1.active=false;
  }
}",0.9708222811671088
48431,"@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  for (int i=0; i < maxSizePerNode * instanceCount; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= instanceCount * maxSizePerNode);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=maxSizePerNode * instanceCount; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}","@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  final int expectedMaxSizeAfterEvictions=maxSizePerNode * instanceCount;
  for (int i=0; i < expectedMaxSizeAfterEvictions; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= expectedMaxSizeAfterEvictions);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=expectedMaxSizeAfterEvictions; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}",0.9387653086728318
48432,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}","public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.putBackup(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}",0.994263862332696
48433,"@Override public void run() throws Exception {
  final InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Object valueBeforeProcess=mapService.toObject(mapEntry.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    backupProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(key);
    }
 else {
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,entry.getValue()));
    }
  }
}","@Override public void run() throws Exception {
  final InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Object valueBeforeProcess=mapService.toObject(mapEntry.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    backupProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(key);
    }
 else {
      recordStore.putBackup(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,entry.getValue()));
    }
  }
}",0.9964285714285714
48434,"public void run(){
  Map.Entry entry;
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    Data dataKey=recordEntry.getKey();
    Record record=recordEntry.getValue();
    Object objectKey=mapService.toObject(record.getKey());
    Object valueBeforeProcess=mapService.toObject(record.getValue());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new AbstractMap.SimpleEntry(objectKey,valueBeforeProcess);
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}","public void run(){
  Map.Entry entry;
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    Data dataKey=recordEntry.getKey();
    Record record=recordEntry.getValue();
    Object objectKey=mapService.toObject(record.getKey());
    Object valueBeforeProcess=mapService.toObject(record.getValue());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new AbstractMap.SimpleEntry(objectKey,valueBeforeProcess);
    entryProcessor.processBackup(entry);
    if (entry.getValue() == null) {
      recordStore.remove(dataKey);
    }
 else {
      recordStore.putBackup(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
    }
  }
}",0.997002997002997
48435,"@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"" + randomString();
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  for (int i=0; i < maxSizePerNode * instanceCount; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= instanceCount * maxSizePerNode);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=maxSizePerNode * instanceCount; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}","@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  for (int i=0; i < maxSizePerNode * instanceCount; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= instanceCount * maxSizePerNode);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=maxSizePerNode * instanceCount; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}",0.9956929313402584
48436,"@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  final int expectedMaxSizeAfterEvictions=maxSizePerNode * instanceCount;
  for (int i=0; i < expectedMaxSizeAfterEvictions; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= expectedMaxSizeAfterEvictions);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=expectedMaxSizeAfterEvictions; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}","@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
    map1.put(i,i);
  }
  assertOpenEventually(latch);
  assertEquals(0,map1.size());
  assertEquals(0,map2.size());
  assertEquals(0,map3.size());
  assertEquals(0,getNearCache(mapName,instance1).size());
  assertEquals(0,getNearCache(mapName,instance2).size());
  assertEquals(0,getNearCache(mapName,instance3).size());
}",0.8078108941418294
48437,"@Test @Category(ProblematicTest.class) public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mc=cfg.getMapConfig(mapName);
  mc.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig msc=new MaxSizeConfig();
  msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  msc.setSize(50);
  mc.setMaxSizeConfig(msc);
  final int maxTTL=2;
  final int size=100000;
  final int nsize=size / 5;
  mc.setTimeToLiveSeconds(maxTTL);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - nsize);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  for (int i=0; i < nsize; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  latch.await(30,TimeUnit.SECONDS);
  assertEquals(0,map1.size());
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=0; i < nsize; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}","@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"" + randomString();
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size - maxSizePerNode);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  for (int i=0; i < maxSizePerNode * instanceCount; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertTrue(map1.size() <= instanceCount * maxSizePerNode);
  assertEquals(map1.size(),map2.size());
  assertEquals(map1.size(),map3.size());
  for (int i=maxSizePerNode * instanceCount; i < size; i++) {
    assertNull(map1.get(i));
    assertNull(map2.get(i));
    assertNull(map3.get(i));
  }
}",0.8244638602065131
48438,"@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int maxSizePerNode=50;
  final int instanceCount=3;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  final MaxSizeConfig maxSizeConfig=new MaxSizeConfig();
  maxSizeConfig.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  maxSizeConfig.setSize(maxSizePerNode);
  mapConfig.setMaxSizeConfig(maxSizeConfig);
  final int ttl=1;
  final int size=1000;
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.get(i);
    map2.get(i);
    map3.get(i);
    map1.put(i,i);
  }
  assertOpenEventually(latch);
  assertEquals(0,map1.size());
  assertEquals(0,map2.size());
  assertEquals(0,map3.size());
  assertEquals(0,getNearCache(mapName,instance1).size());
  assertEquals(0,getNearCache(mapName,instance2).size());
  assertEquals(0,getNearCache(mapName,instance3).size());
}","@Test public void testNearCacheEvictionByUsingMapTTLEviction() throws InterruptedException {
  final int instanceCount=3;
  final int ttl=1;
  final int size=1000;
  final Config cfg=new Config();
  final String mapName=""String_Node_Str"";
  final NearCacheConfig nearCacheConfig=new NearCacheConfig();
  nearCacheConfig.setInvalidateOnChange(true);
  nearCacheConfig.setInMemoryFormat(InMemoryFormat.OBJECT);
  cfg.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);
  final MapConfig mapConfig=cfg.getMapConfig(mapName);
  mapConfig.setTimeToLiveSeconds(ttl);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(instanceCount);
  final HazelcastInstance instance1=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance2=factory.newHazelcastInstance(cfg);
  final HazelcastInstance instance3=factory.newHazelcastInstance(cfg);
  final IMap map1=instance1.getMap(mapName);
  final IMap map2=instance2.getMap(mapName);
  final IMap map3=instance3.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(size);
  map1.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    EntryEvent event){
      latch.countDown();
    }
  }
,false);
  for (int i=0; i < size; i++) {
    map1.put(i,i);
    map1.get(i);
    map2.get(i);
    map3.get(i);
  }
  assertOpenEventually(latch);
  assertEquals(0,map1.size());
  assertEquals(0,map2.size());
  assertEquals(0,map3.size());
  assertEquals(0,countNotNullValuesInNearCacheSize(mapName,instance1));
  assertEquals(0,countNotNullValuesInNearCacheSize(mapName,instance2));
  assertEquals(0,countNotNullValuesInNearCacheSize(mapName,instance3));
}",0.6678072426575421
48439,"public Data read() throws IOException {
  ClientPacket packet=new ClientPacket(serializationService.getSerializationContext());
  while (true) {
    if (readFromSocket) {
      int readBytes=socketChannelWrapper.read(readBuffer);
      if (readBytes == -1) {
        throw new EOFException(""String_Node_Str"");
      }
      readBuffer.flip();
    }
    boolean complete=packet.readFrom(readBuffer);
    if (complete) {
      if (readBuffer.hasRemaining()) {
        readFromSocket=false;
      }
 else {
        readBuffer.compact();
      }
      return packet.getData();
    }
    readFromSocket=true;
    readBuffer.clear();
  }
}","public Data read() throws IOException {
  ClientPacket packet=new ClientPacket(serializationService.getSerializationContext());
  while (true) {
    if (readFromSocket) {
      int readBytes=socketChannelWrapper.read(readBuffer);
      if (readBytes == -1) {
        throw new EOFException(""String_Node_Str"");
      }
      readBuffer.flip();
    }
    boolean complete=packet.readFrom(readBuffer);
    if (complete) {
      if (readBuffer.hasRemaining()) {
        readFromSocket=false;
      }
 else {
        readBuffer.compact();
        readFromSocket=true;
      }
      return packet.getData();
    }
    readFromSocket=true;
    readBuffer.clear();
  }
}",0.9776061776061776
48440,"public static void writeAttributeValue(Object value,ObjectDataOutput out) throws IOException {
  Class<?> type=value.getClass();
  if (type.equals(Boolean.class)) {
    out.writeByte(PRIMITIVE_TYPE_BOOLEAN);
    out.writeBoolean((Boolean)value);
  }
 else   if (type.equals(Byte.class)) {
    out.writeByte(PRIMITIVE_TYPE_BYTE);
    out.writeByte((Byte)value);
  }
 else   if (type.equals(Short.class)) {
    out.writeByte(PRIMITIVE_TYPE_SHORT);
    out.writeShort((Short)value);
  }
 else   if (type.equals(Integer.class)) {
    out.writeByte(PRIMITIVE_TYPE_INTEGER);
    out.writeInt((Integer)value);
  }
 else   if (type.equals(Long.class)) {
    out.writeByte(PRIMITIVE_TYPE_LONG);
    out.writeLong((Long)value);
  }
 else   if (type.equals(Float.class)) {
    out.writeByte(PRIMITIVE_TYPE_FLOAT);
    out.writeFloat((Float)value);
  }
 else   if (type.equals(Double.class)) {
    out.writeByte(PRIMITIVE_TYPE_DOUBLE);
    out.writeDouble((Double)value);
  }
 else   if (type.equals(String.class)) {
    out.writeByte(PRIMITIVE_TYPE_UTF);
    out.writeUTF((String)value);
  }
}","public static void writeAttributeValue(Object value,ObjectDataOutput out) throws IOException {
  Class<?> type=value.getClass();
  if (type.equals(Boolean.class)) {
    out.writeByte(PRIMITIVE_TYPE_BOOLEAN);
    out.writeBoolean((Boolean)value);
  }
 else   if (type.equals(Byte.class)) {
    out.writeByte(PRIMITIVE_TYPE_BYTE);
    out.writeByte((Byte)value);
  }
 else   if (type.equals(Short.class)) {
    out.writeByte(PRIMITIVE_TYPE_SHORT);
    out.writeShort((Short)value);
  }
 else   if (type.equals(Integer.class)) {
    out.writeByte(PRIMITIVE_TYPE_INTEGER);
    out.writeInt((Integer)value);
  }
 else   if (type.equals(Long.class)) {
    out.writeByte(PRIMITIVE_TYPE_LONG);
    out.writeLong((Long)value);
  }
 else   if (type.equals(Float.class)) {
    out.writeByte(PRIMITIVE_TYPE_FLOAT);
    out.writeFloat((Float)value);
  }
 else   if (type.equals(Double.class)) {
    out.writeByte(PRIMITIVE_TYPE_DOUBLE);
    out.writeDouble((Double)value);
  }
 else   if (type.equals(String.class)) {
    out.writeByte(PRIMITIVE_TYPE_UTF);
    out.writeUTF((String)value);
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.9695340501792116
48441,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null && !NearCache.NULL_OBJECT.equals(cachedValue)) {
        result.put(key,cachedValue);
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(key,cachedValue);
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}",0.9909553420011306
48442,"protected Object getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (cached.equals(NearCache.NULL_OBJECT)) {
        cached=null;
      }
      mapService.interceptAfterGet(name,cached);
      return cached;
    }
  }
  NodeEngine nodeEngine=getNodeEngine();
  if (mapConfig.isReadBackupData()) {
    int backupCount=mapConfig.getTotalBackupCount();
    InternalPartitionService partitionService=mapService.getNodeEngine().getPartitionService();
    for (int i=0; i <= backupCount; i++) {
      int partitionId=partitionService.getPartitionId(key);
      InternalPartition partition=partitionService.getPartition(partitionId);
      if (nodeEngine.getThisAddress().equals(partition.getReplicaAddress(i))) {
        Object val=mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
        if (val != null) {
          mapService.interceptAfterGet(name,val);
          return mapService.toData(val);
        }
      }
    }
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}","protected Object getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (NearCache.NULL_OBJECT.equals(cached)) {
        cached=null;
      }
      mapService.interceptAfterGet(name,cached);
      return cached;
    }
  }
  NodeEngine nodeEngine=getNodeEngine();
  if (mapConfig.isReadBackupData()) {
    int backupCount=mapConfig.getTotalBackupCount();
    InternalPartitionService partitionService=mapService.getNodeEngine().getPartitionService();
    for (int i=0; i <= backupCount; i++) {
      int partitionId=partitionService.getPartitionId(key);
      InternalPartition partition=partitionService.getPartition(partitionId);
      if (nodeEngine.getThisAddress().equals(partition.getReplicaAddress(i))) {
        Object val=mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
        if (val != null) {
          mapService.interceptAfterGet(name,val);
          return mapService.toData(val);
        }
      }
    }
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}",0.9913419913419912
48443,"protected ICompletableFuture<Data> getAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null && NearCache.NULL_OBJECT.equals(cached)) {
      return new CompletedFuture<Data>(nodeEngine.getSerializationService(),cached,nodeEngine.getExecutionService().getExecutor(ExecutionService.ASYNC_EXECUTOR));
    }
  }
  GetOperation operation=new GetOperation(name,key);
  try {
    return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> getAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (NearCache.NULL_OBJECT.equals(cached)) {
        cached=null;
      }
      return new CompletedFuture<Data>(nodeEngine.getSerializationService(),cached,nodeEngine.getExecutionService().getExecutor(ExecutionService.ASYNC_EXECUTOR));
    }
  }
  GetOperation operation=new GetOperation(name,key);
  try {
    return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9729418537708692
48444,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null && !NearCache.NULL_OBJECT.equals(cachedValue)) {
        result.put(key,cachedValue);
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Map<Object,Object> result=new HashMap<Object,Object>();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    final Iterator<Data> iterator=keys.iterator();
    while (iterator.hasNext()) {
      Data key=iterator.next();
      Object cachedValue=mapService.getFromNearCache(name,key);
      if (cachedValue != null) {
        if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
          result.put(key,cachedValue);
        }
        iterator.remove();
      }
    }
  }
  if (keys.isEmpty()) {
    return result;
  }
  Collection<Integer> partitions=getPartitionsForKeys(keys);
  Map<Integer,Object> responses=null;
  try {
    responses=nodeEngine.getOperationService().invokeOnPartitions(SERVICE_NAME,new MapGetAllOperationFactory(name,keys),partitions);
    for (    Object response : responses.values()) {
      Set<Map.Entry<Data,Data>> entries=((MapEntrySet)mapService.toObject(response)).getEntrySet();
      for (      Entry<Data,Data> entry : entries) {
        result.put(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
        if (nearCacheEnabled) {
          int partitionId=nodeEngine.getPartitionService().getPartitionId(entry.getKey());
          if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
            mapService.putNearCache(name,entry.getKey(),entry.getValue());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  return result;
}",0.9909553420011306
48445,"protected Object getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (cached.equals(NearCache.NULL_OBJECT)) {
        cached=null;
      }
      mapService.interceptAfterGet(name,cached);
      return cached;
    }
  }
  NodeEngine nodeEngine=getNodeEngine();
  if (mapConfig.isReadBackupData()) {
    int backupCount=mapConfig.getTotalBackupCount();
    InternalPartitionService partitionService=mapService.getNodeEngine().getPartitionService();
    for (int i=0; i <= backupCount; i++) {
      int partitionId=partitionService.getPartitionId(key);
      InternalPartition partition=partitionService.getPartition(partitionId);
      if (nodeEngine.getThisAddress().equals(partition.getReplicaAddress(i))) {
        Object val=mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
        if (val != null) {
          mapService.interceptAfterGet(name,val);
          return mapService.toData(val);
        }
      }
    }
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}","protected Object getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (NearCache.NULL_OBJECT.equals(cached)) {
        cached=null;
      }
      mapService.interceptAfterGet(name,cached);
      return cached;
    }
  }
  NodeEngine nodeEngine=getNodeEngine();
  if (mapConfig.isReadBackupData()) {
    int backupCount=mapConfig.getTotalBackupCount();
    InternalPartitionService partitionService=mapService.getNodeEngine().getPartitionService();
    for (int i=0; i <= backupCount; i++) {
      int partitionId=partitionService.getPartitionId(key);
      InternalPartition partition=partitionService.getPartition(partitionId);
      if (nodeEngine.getThisAddress().equals(partition.getReplicaAddress(i))) {
        Object val=mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
        if (val != null) {
          mapService.interceptAfterGet(name,val);
          return mapService.toData(val);
        }
      }
    }
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (!nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress()) || mapConfig.getNearCacheConfig().isCacheLocalEntries()) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}",0.9913419913419912
48446,"protected ICompletableFuture<Data> getAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null && NearCache.NULL_OBJECT.equals(cached)) {
      return new CompletedFuture<Data>(nodeEngine.getSerializationService(),cached,nodeEngine.getExecutionService().getExecutor(ExecutionService.ASYNC_EXECUTOR));
    }
  }
  GetOperation operation=new GetOperation(name,key);
  try {
    return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected ICompletableFuture<Data> getAsyncInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  final boolean nearCacheEnabled=mapConfig.isNearCacheEnabled();
  if (nearCacheEnabled) {
    Object cached=mapService.getFromNearCache(name,key);
    if (cached != null) {
      if (NearCache.NULL_OBJECT.equals(cached)) {
        cached=null;
      }
      return new CompletedFuture<Data>(nodeEngine.getSerializationService(),cached,nodeEngine.getExecutionService().getExecutor(ExecutionService.ASYNC_EXECUTOR));
    }
  }
  GetOperation operation=new GetOperation(name,key);
  try {
    return nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9729418537708692
48447,"@Test public void testGetAsync() throws Exception {
  final String mapName=""String_Node_Str"";
  Config config=new Config();
  config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());
  final TestHazelcastInstanceFactory hazelcastInstanceFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=hazelcastInstanceFactory.newHazelcastInstance(config);
  HazelcastInstance instance2=hazelcastInstanceFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> map=instance1.getMap(mapName);
  HashSet keys=new HashSet();
  int size=1000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
    keys.add(i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  for (int i=0; i < size; i++) {
    final Future<Integer> async=map.getAsync(i);
    System.out.println(async.get());
  }
  NearCacheStats stats2=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats2.getHits());
}","@Test public void testGetAsync() throws Exception {
  final String mapName=""String_Node_Str"";
  Config config=new Config();
  config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());
  final TestHazelcastInstanceFactory hazelcastInstanceFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=hazelcastInstanceFactory.newHazelcastInstance(config);
  HazelcastInstance instance2=hazelcastInstanceFactory.newHazelcastInstance(config);
  IMap<Integer,Integer> map=instance1.getMap(mapName);
  HashSet keys=new HashSet();
  int size=1000;
  for (int i=0; i < size; i++) {
    map.put(i,i);
    keys.add(i);
  }
  for (int i=0; i < size; i++) {
    map.get(i);
  }
  for (int i=0; i < size; i++) {
    final Future<Integer> async=map.getAsync(i);
  }
  NearCacheStats stats2=map.getLocalMapStats().getNearCacheStats();
  assertTrue(""String_Node_Str"",400 < stats2.getHits());
}",0.9799240368963646
48448,"@Override public Collection<V> values(Predicate predicate){
  PagingPredicate pagingPredicate=null;
  if (predicate instanceof PagingPredicate) {
    pagingPredicate=(PagingPredicate)predicate;
    pagingPredicate.setIterationType(IterationType.VALUE);
    if (pagingPredicate.getPage() > 0 && pagingPredicate.getAnchor() == null) {
      pagingPredicate.previousPage();
      values(pagingPredicate);
      pagingPredicate.nextPage();
    }
  }
  MapQueryRequest request=new MapQueryRequest(name,predicate,IterationType.VALUE);
  QueryResultSet result=invoke(request);
  List<V> values=new ArrayList<V>(result.size());
  for (  Object data : result) {
    V value=toObject((Data)data);
    values.add(value);
  }
  if (pagingPredicate != null) {
    Collections.sort(values,SortingUtil.newComparator(pagingPredicate.getComparator()));
    if (values.size() > pagingPredicate.getPageSize()) {
      values=values.subList(0,pagingPredicate.getPageSize());
    }
    Object anchor=null;
    if (values.size() != 0) {
      anchor=values.get(values.size() - 1);
    }
    PagingPredicateAccessor.setPagingPredicateAnchor(pagingPredicate,new AbstractMap.SimpleImmutableEntry(null,anchor));
  }
  return values;
}","@Override public Collection<V> values(Predicate predicate){
  PagingPredicate pagingPredicate=null;
  if (predicate instanceof PagingPredicate) {
    pagingPredicate=(PagingPredicate)predicate;
    pagingPredicate.setIterationType(IterationType.VALUE);
    if (pagingPredicate.getPage() > 0 && pagingPredicate.getAnchor() == null) {
      pagingPredicate.previousPage();
      values(pagingPredicate);
      pagingPredicate.nextPage();
    }
  }
  MapQueryRequest request=new MapQueryRequest(name,predicate,IterationType.VALUE);
  QueryResultSet result=invoke(request);
  if (pagingPredicate == null) {
    final ArrayList<V> values=new ArrayList<V>(result.size());
    for (    Object data : result) {
      V value=toObject(data);
      values.add(value);
    }
    return values;
  }
  List<Entry<Object,V>> valueEntryList=new ArrayList<Entry<Object,V>>(result.size());
  for (  QueryResultEntry entry : result.getEntries()) {
    K key=toObject(entry.getKeyData());
    V value=toObject(entry.getValueData());
    valueEntryList.add(new AbstractMap.SimpleImmutableEntry<Object,V>(key,value));
  }
  Collections.sort(valueEntryList,SortingUtil.newComparator(pagingPredicate.getComparator(),IterationType.VALUE));
  if (valueEntryList.size() > pagingPredicate.getPageSize()) {
    valueEntryList=valueEntryList.subList(0,pagingPredicate.getPageSize());
  }
  Entry anchor=null;
  if (valueEntryList.size() != 0) {
    anchor=valueEntryList.get(valueEntryList.size() - 1);
  }
  PagingPredicateAccessor.setPagingPredicateAnchor(pagingPredicate,anchor);
  final ArrayList<V> values=new ArrayList<V>(valueEntryList.size());
  for (  Entry<Object,V> objectVEntry : valueEntryList) {
    values.add(objectVEntry.getValue());
  }
  return values;
}",0.508130081300813
48449,"@Override public Set<K> keySet(Predicate predicate){
  PagingPredicate pagingPredicate=null;
  if (predicate instanceof PagingPredicate) {
    pagingPredicate=(PagingPredicate)predicate;
    pagingPredicate.setIterationType(IterationType.KEY);
    if (pagingPredicate.getPage() > 0 && pagingPredicate.getAnchor() == null) {
      pagingPredicate.previousPage();
      keySet(pagingPredicate);
      pagingPredicate.nextPage();
    }
  }
  MapQueryRequest request=new MapQueryRequest(name,predicate,IterationType.KEY);
  QueryResultSet result=invoke(request);
  List<K> keyList=new ArrayList<K>(result.size());
  for (  Object data : result) {
    K key=toObject((Data)data);
    keyList.add(key);
  }
  if (pagingPredicate != null) {
    Collections.sort(keyList,SortingUtil.newComparator(pagingPredicate.getComparator()));
    if (keyList.size() > pagingPredicate.getPageSize()) {
      keyList=keyList.subList(0,pagingPredicate.getPageSize());
    }
    Object anchor=null;
    if (keyList.size() != 0) {
      anchor=keyList.get(keyList.size() - 1);
    }
    PagingPredicateAccessor.setPagingPredicateAnchor(pagingPredicate,new AbstractMap.SimpleImmutableEntry(anchor,null));
  }
  return new HashSet<K>(keyList);
}","@Override public Set<K> keySet(Predicate predicate){
  PagingPredicate pagingPredicate=null;
  if (predicate instanceof PagingPredicate) {
    pagingPredicate=(PagingPredicate)predicate;
    pagingPredicate.setIterationType(IterationType.KEY);
    if (pagingPredicate.getPage() > 0 && pagingPredicate.getAnchor() == null) {
      pagingPredicate.previousPage();
      keySet(pagingPredicate);
      pagingPredicate.nextPage();
    }
  }
  MapQueryRequest request=new MapQueryRequest(name,predicate,IterationType.KEY);
  QueryResultSet result=invoke(request);
  if (pagingPredicate == null) {
    final HashSet<K> keySet=new HashSet<K>();
    for (    Object o : result) {
      final K key=toObject(o);
      keySet.add(key);
    }
    return keySet;
  }
  final Comparator<Entry> comparator=SortingUtil.newComparator(pagingPredicate.getComparator(),IterationType.KEY);
  final SortedQueryResultSet sortedResult=new SortedQueryResultSet(comparator,IterationType.KEY,pagingPredicate.getPageSize());
  for (  QueryResultEntry entry : result.getEntries()) {
    final K key=toObject(entry.getKeyData());
    final V value=toObject(entry.getValueData());
    sortedResult.add(new AbstractMap.SimpleImmutableEntry<K,V>(key,value));
  }
  PagingPredicateAccessor.setPagingPredicateAnchor(pagingPredicate,sortedResult.last());
  return (Set<K>)sortedResult;
}",0.602878257487359
48450,"@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MapService mapService=nei.getService(MapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  RecordStore recordStore=mapService.getRecordStore(partitionId,mapName);
  iterator=recordStore.entrySetData().iterator();
  return true;
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  PartitionService ps=nei.getPartitionService();
  MapService mapService=nei.getService(MapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  Address partitionOwner=ps.getPartitionOwner(partitionId);
  if (partitionOwner == null) {
    return false;
  }
  RecordStore recordStore=mapService.getRecordStore(partitionId,mapName);
  iterator=recordStore.entrySetData().iterator();
  return true;
}",0.8084606345475911
48451,"@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MultiMapService multiMapService=nei.getService(MultiMapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  multiMapContainer=multiMapService.getOrCreateCollectionContainer(partitionId,multiMapName);
  isBinary=multiMapContainer.getConfig().isBinary();
  keyIterator=multiMapContainer.keySet().iterator();
  return true;
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  PartitionService ps=nei.getPartitionService();
  MultiMapService multiMapService=nei.getService(MultiMapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  Address partitionOwner=ps.getPartitionOwner(partitionId);
  if (partitionOwner == null) {
    return false;
  }
  multiMapContainer=multiMapService.getOrCreateCollectionContainer(partitionId,multiMapName);
  isBinary=multiMapContainer.getConfig().isBinary();
  keyIterator=multiMapContainer.keySet().iterator();
  return true;
}",0.8422071636011617
48452,"@Override public void run() throws Exception {
  MapReduceService mapReduceService=getService();
  JobSupervisor supervisor=mapReduceService.getJobSupervisor(getName(),getJobId());
  if (supervisor == null) {
    result=new RequestPartitionResult(NO_SUPERVISOR,-1);
    return;
  }
  JobProcessInformationImpl processInformation=supervisor.getJobProcessInformation();
  while (true) {
    JobPartitionState.State newState=JobPartitionState.State.WAITING;
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    JobPartitionState oldPartitionState=partitionStates[partitionId];
    if (oldPartitionState == null || getCallerAddress().equals(oldPartitionState.getOwner())) {
      result=new RequestPartitionResult(CHECK_STATE_FAILED,partitionId);
      return;
    }
    JobPartitionState newPartitionState=new JobPartitionStateImpl(getCallerAddress(),newState);
    if (processInformation.updatePartitionState(partitionId,oldPartitionState,newPartitionState)) {
      result=new RequestPartitionResult(SUCCESSFUL,partitionId);
      return;
    }
  }
}","@Override public void run() throws Exception {
  MapReduceService mapReduceService=getService();
  JobSupervisor supervisor=mapReduceService.getJobSupervisor(getName(),getJobId());
  if (supervisor == null) {
    result=new RequestPartitionResult(NO_SUPERVISOR,-1);
    return;
  }
  JobProcessInformationImpl processInformation=supervisor.getJobProcessInformation();
  while (true) {
    JobPartitionState[] partitionStates=processInformation.getPartitionStates();
    JobPartitionState oldPartitionState=partitionStates[partitionId];
    if (oldPartitionState == null || !getCallerAddress().equals(oldPartitionState.getOwner())) {
      result=new RequestPartitionResult(CHECK_STATE_FAILED,partitionId);
      return;
    }
    if (processInformation.updatePartitionState(partitionId,oldPartitionState,null)) {
      result=new RequestPartitionResult(SUCCESSFUL,partitionId);
      return;
    }
  }
}",0.8336693548387096
48453,"private void postponePartitionProcessing(int partitionId) throws Exception {
  RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new PostPonePartitionProcessing(name,jobId,partitionId),name);
  if (result.getResultState() != SUCCESSFUL) {
    throw new RuntimeException(""String_Node_Str"" + partitionId);
  }
}","private void postponePartitionProcessing(int partitionId) throws Exception {
  RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new PostPonePartitionProcessing(name,jobId,partitionId),name);
  if (result.getResultState() != SUCCESSFUL) {
    throw new RuntimeException(""String_Node_Str"" + partitionId + ""String_Node_Str""+ result.getResultState());
  }
}",0.9389416553595658
48454,"private MapStoreConfig createMapStoreConfig(final org.w3c.dom.Node node){
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  final NamedNodeMap atts=node.getAttributes();
  for (int a=0; a < atts.getLength(); a++) {
    final org.w3c.dom.Node att=atts.item(a);
    final String value=getTextContent(att).trim();
    if (att.getNodeName().equals(""String_Node_Str"")) {
      mapStoreConfig.setEnabled(checkTrue(value));
    }
 else     if (""String_Node_Str"".equals(att.getNodeName())) {
      final MapStoreConfig.InitialLoadMode mode=att != null ? MapStoreConfig.InitialLoadMode.valueOf(upperCaseInternal(getTextContent(att))) : MapStoreConfig.InitialLoadMode.LAZY;
      mapStoreConfig.setInitialLoadMode(mode);
    }
  }
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setClassName(getTextContent(n).trim());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setFactoryClassName(getTextContent(n).trim());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setWriteDelaySeconds(getIntegerValue(""String_Node_Str"",getTextContent(n).trim(),MapStoreConfig.DEFAULT_WRITE_DELAY_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      fillProperties(n,mapStoreConfig.getProperties());
    }
  }
  return mapStoreConfig;
}","private MapStoreConfig createMapStoreConfig(final org.w3c.dom.Node node){
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  final NamedNodeMap atts=node.getAttributes();
  for (int a=0; a < atts.getLength(); a++) {
    final org.w3c.dom.Node att=atts.item(a);
    final String value=getTextContent(att).trim();
    if (""String_Node_Str"".equals(att.getNodeName())) {
      mapStoreConfig.setEnabled(checkTrue(value));
    }
 else     if (""String_Node_Str"".equals(att.getNodeName())) {
      final MapStoreConfig.InitialLoadMode mode=att != null ? MapStoreConfig.InitialLoadMode.valueOf(upperCaseInternal(getTextContent(att))) : MapStoreConfig.InitialLoadMode.LAZY;
      mapStoreConfig.setInitialLoadMode(mode);
    }
  }
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setClassName(getTextContent(n).trim());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setFactoryClassName(getTextContent(n).trim());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapStoreConfig.setWriteDelaySeconds(getIntegerValue(""String_Node_Str"",getTextContent(n).trim(),MapStoreConfig.DEFAULT_WRITE_DELAY_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      fillProperties(n,mapStoreConfig.getProperties());
    }
  }
  return mapStoreConfig;
}",0.9765355417529332
48455,"private void doRemoveEndpoint(Connection connection,ClientEndpoint endpoint){
  removeEndpoint(connection,true);
  if (!endpoint.isFirstConnection()) {
    return;
  }
  NodeEngine nodeEngine=node.nodeEngine;
  Collection<MemberImpl> memberList=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : memberList) {
    ClientDisconnectionOperation op=new ClientDisconnectionOperation(endpoint.getUuid());
    op.setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME).setService(this).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
    if (member.localMember()) {
      nodeEngine.getOperationService().runOperation(op);
    }
 else {
      nodeEngine.getOperationService().send(op,member.getAddress());
    }
  }
}","private void doRemoveEndpoint(Connection connection,ClientEndpoint endpoint){
  removeEndpoint(connection,true);
  if (!endpoint.isFirstConnection()) {
    return;
  }
  NodeEngine nodeEngine=node.nodeEngine;
  Collection<MemberImpl> memberList=nodeEngine.getClusterService().getMemberList();
  OperationService operationService=nodeEngine.getOperationService();
  for (  MemberImpl member : memberList) {
    ClientDisconnectionOperation op=new ClientDisconnectionOperation(endpoint.getUuid());
    op.setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME).setService(ClientEngineImpl.this).setResponseHandler(createEmptyResponseHandler());
    if (member.localMember()) {
      operationService.runOperation(op);
    }
 else {
      operationService.send(op,member.getAddress());
    }
  }
}",0.8622908622908623
48456,"@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    int partitionId=result.getPartitionId();
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    if (delegate.open(nodeEngine)) {
      DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
      processMapping(partitionId,context,delegate);
      delegate.close();
      finalizeMapping(partitionId,context);
    }
 else {
      postponePartitionProcessing(partitionId);
    }
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
    if (t instanceof Error) {
      ExceptionUtil.sneakyThrow(t);
    }
  }
}","@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    int partitionId=result.getPartitionId();
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    if (delegate.open(nodeEngine)) {
      DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
      processMapping(partitionId,context,delegate);
      delegate.close();
      finalizeMapping(partitionId,context);
    }
 else {
      postponePartitionProcessing(partitionId);
    }
  }
 catch (  Throwable t) {
    handleProcessorThrowable(t);
  }
}",0.9384023099133784
48457,"@Override @SuppressWarnings({""String_Node_Str""}) public JobPartitionState[] getPartitionStates(){
  return partitionStates;
}","@Override @SuppressWarnings(""String_Node_Str"") public JobPartitionState[] getPartitionStates(){
  return partitionStates;
}",0.9919354838709676
48458,"@Override @SuppressWarnings({""String_Node_Str""}) public JobPartitionState[] getPartitionStates(){
  return partitionStates;
}","@Override @SuppressWarnings(""String_Node_Str"") public JobPartitionState[] getPartitionStates(){
  return partitionStates;
}",0.9919354838709676
48459,"private void handleManagementCenterConfig(final Node node){
  NamedNodeMap attrs=node.getAttributes();
  final Node enabledNode=attrs.getNamedItem(""String_Node_Str"");
  boolean enabled=enabledNode != null && checkTrue(getTextContent(enabledNode));
  final Node intervalNode=attrs.getNamedItem(""String_Node_Str"");
  final int interval=intervalNode != null ? getIntegerValue(""String_Node_Str"",getTextContent(intervalNode),5) : 5;
  final Node securityTokenNode=attrs.getNamedItem(""String_Node_Str"");
  final String securityToken=getTextContent(securityTokenNode);
  if (securityToken != null && enabledNode == null) {
    enabled=true;
  }
  final Node clusterIdNode=attrs.getNamedItem(""String_Node_Str"");
  final String clusterId=getTextContent(clusterIdNode);
  final String url=getTextContent(node);
  ManagementCenterConfig managementCenterConfig=config.getManagementCenterConfig();
  managementCenterConfig.setEnabled(enabled);
  managementCenterConfig.setUpdateInterval(interval);
  managementCenterConfig.setSecurityToken(""String_Node_Str"".equals(securityToken) ? null : securityToken);
  managementCenterConfig.setClusterId(""String_Node_Str"".equals(clusterId) ? null : clusterId);
  managementCenterConfig.setUrl(""String_Node_Str"".equals(url) ? null : url);
}","private void handleManagementCenterConfig(final Node node){
  NamedNodeMap attrs=node.getAttributes();
  final Node enabledNode=attrs.getNamedItem(""String_Node_Str"");
  boolean enabled=enabledNode != null && checkTrue(getTextContent(enabledNode));
  final Node intervalNode=attrs.getNamedItem(""String_Node_Str"");
  final int interval=intervalNode != null ? getIntegerValue(""String_Node_Str"",getTextContent(intervalNode),5) : 5;
  final Node securityTokenNode=attrs.getNamedItem(""String_Node_Str"");
  final String securityToken=getTextContent(securityTokenNode);
  if ((securityToken != null && !""String_Node_Str"".equals(securityToken)) && enabledNode == null) {
    enabled=true;
  }
  final Node clusterIdNode=attrs.getNamedItem(""String_Node_Str"");
  final String clusterId=getTextContent(clusterIdNode);
  final String url=getTextContent(node);
  ManagementCenterConfig managementCenterConfig=config.getManagementCenterConfig();
  managementCenterConfig.setEnabled(enabled);
  managementCenterConfig.setUpdateInterval(interval);
  managementCenterConfig.setSecurityToken(""String_Node_Str"".equals(securityToken) ? null : securityToken);
  managementCenterConfig.setClusterId(""String_Node_Str"".equals(clusterId) ? null : clusterId);
  managementCenterConfig.setUrl(""String_Node_Str"".equals(url) ? null : url);
}",0.9821428571428572
48460,"private SimpleMapTest(final int threadCount,final int entryCount,final int valueSize,final int getPercentage,final int putPercentage,final boolean load){
  this.threadCount=threadCount;
  this.entryCount=entryCount;
  this.valueSize=valueSize;
  this.getPercentage=getPercentage;
  this.putPercentage=putPercentage;
  this.load=load;
  Config cfg=new XmlConfigBuilder().build();
  cfg.getManagementCenterConfig().setEnabled(true);
  instance=Hazelcast.newHazelcastInstance(cfg);
  logger=instance.getLoggingService().getLogger(""String_Node_Str"");
}","private SimpleMapTest(final int threadCount,final int entryCount,final int valueSize,final int getPercentage,final int putPercentage,final boolean load){
  this.threadCount=threadCount;
  this.entryCount=entryCount;
  this.valueSize=valueSize;
  this.getPercentage=getPercentage;
  this.putPercentage=putPercentage;
  this.load=load;
  Config cfg=new XmlConfigBuilder().build();
  instance=Hazelcast.newHazelcastInstance(cfg);
  logger=instance.getLoggingService().getLogger(""String_Node_Str"");
}",0.950191570881226
48461,"public void destroy(){
  if (registrationId != null) {
    BaseClientRemoveListenerRequest request;
    if (cacheType == ClientNearCacheType.Map) {
      request=new MapRemoveEntryListenerRequest(mapName,registrationId);
    }
 else     if (cacheType == ClientNearCacheType.ReplicatedMap) {
      request=new ClientReplicatedMapRemoveEntryListenerRequest(mapName,registrationId);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
    ListenerUtil.stopListening(context,request,registrationId);
  }
  cache.clear();
}","public void destroy(){
  if (registrationId != null) {
    BaseClientRemoveListenerRequest request;
    if (cacheType == ClientNearCacheType.Map) {
      request=new MapRemoveEntryListenerRequest(mapName,registrationId);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
    ListenerUtil.stopListening(context,request,registrationId);
  }
  cache.clear();
}",0.8288482238966631
48462,"private void addInvalidateListener(){
}","private void addInvalidateListener(){
  try {
    ClientRequest request;
    EventHandler handler;
    if (cacheType == ClientNearCacheType.Map) {
      request=new MapAddEntryListenerRequest(mapName,false);
      handler=new EventHandler<PortableEntryEvent>(){
        public void handle(        PortableEntryEvent event){
          cache.remove(event.getKey());
        }
      }
;
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
    registrationId=ListenerUtil.listen(context,request,null,handler);
  }
 catch (  Exception e) {
    Logger.getLogger(ClientNearCache.class).severe(""String_Node_Str"",e);
  }
}",0.1150442477876106
48463,"@Override public void publishReplicationEvent(String serviceName,ReplicationEventObject eventObject){
  WanReplicationEvent replicationEvent=new WanReplicationEvent(serviceName,eventObject);
  if (!q.offer(replicationEvent)) {
    q.poll();
    q.offer(replicationEvent);
  }
}","@Override public void publishReplicationEvent(String serviceName,ReplicationEventObject eventObject){
  WanReplicationEvent replicationEvent=new WanReplicationEvent(serviceName,eventObject);
  if (eventQueue.offer(replicationEvent)) {
    return;
  }
  eventQueue.poll();
  if (!eventQueue.offer(replicationEvent)) {
    logger.warning(""String_Node_Str"" + replicationEvent);
  }
}",0.7275494672754946
48464,"public void run(){
  Connection conn=null;
  while (running) {
    try {
      WanReplicationEvent event=(failureQ.size() > 0) ? failureQ.removeFirst() : q.take();
      if (conn == null) {
        conn=getConnection();
        if (conn != null) {
          boolean authorized=checkAuthorization(groupName,password,conn.getEndPoint());
          if (!authorized) {
            conn.close();
            conn=null;
            if (logger != null) {
              logger.severe(""String_Node_Str"");
            }
          }
        }
      }
      if (conn != null && conn.live()) {
        Data data=node.nodeEngine.getSerializationService().toData(event);
        Packet packet=new Packet(data,node.nodeEngine.getSerializationContext());
        packet.setHeader(Packet.HEADER_WAN_REPLICATION);
        node.nodeEngine.send(packet,conn);
      }
 else {
        failureQ.addFirst(event);
        conn=null;
      }
    }
 catch (    InterruptedException e) {
      running=false;
    }
catch (    Throwable e) {
      if (logger != null) {
        logger.warning(e);
      }
      conn=null;
    }
  }
}","public void run(){
  Connection conn=null;
  while (running) {
    try {
      WanReplicationEvent event=(failureQ.size() > 0) ? failureQ.removeFirst() : eventQueue.take();
      if (conn == null) {
        conn=getConnection();
        if (conn != null) {
          boolean authorized=checkAuthorization(groupName,password,conn.getEndPoint());
          if (!authorized) {
            conn.close();
            conn=null;
            if (logger != null) {
              logger.severe(""String_Node_Str"");
            }
          }
        }
      }
      if (conn != null && conn.live()) {
        Data data=node.nodeEngine.getSerializationService().toData(event);
        Packet packet=new Packet(data,node.nodeEngine.getSerializationContext());
        packet.setHeader(Packet.HEADER_WAN_REPLICATION);
        node.nodeEngine.send(packet,conn);
      }
 else {
        failureQ.addFirst(event);
        conn=null;
      }
    }
 catch (    InterruptedException e) {
      running=false;
    }
catch (    Throwable e) {
      if (logger != null) {
        logger.warning(e);
      }
      conn=null;
    }
  }
}",0.9950338600451468
48465,"@Override public <T>T executeTransaction(TransactionOptions options,TransactionalTask<T> task) throws TransactionException {
  final TransactionContext context=newTransactionContext(options);
  context.beginTransaction();
  try {
    final T value=task.execute(context);
    context.commitTransaction();
    return value;
  }
 catch (  Throwable e) {
    context.rollbackTransaction();
    if (e instanceof TransactionException) {
      throw (TransactionException)e;
    }
    if (e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new TransactionException(e);
  }
}","@Override public <T>T executeTransaction(TransactionOptions options,TransactionalTask<T> task) throws TransactionException {
  return transactionManager.executeTransaction(options,task);
}",0.375
48466,"private HazelcastClient(ClientConfig config){
  this.config=config;
  final GroupConfig groupConfig=config.getGroupConfig();
  instanceName=""String_Node_Str"" + id + (groupConfig != null ? ""String_Node_Str"" + groupConfig.getName() : ""String_Node_Str"");
  threadGroup=new ThreadGroup(instanceName);
  lifecycleService=new LifecycleServiceImpl(this);
  try {
    String partitioningStrategyClassName=System.getProperty(GroupProperties.PROP_PARTITIONING_STRATEGY_CLASS);
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(config.getClassLoader(),partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    serializationService=new SerializationServiceBuilder().setManagedContext(new HazelcastClientManagedContext(this,config.getManagedContext())).setClassLoader(config.getClassLoader()).setConfig(config.getSerializationConfig()).setPartitioningStrategy(partitioningStrategy).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  proxyManager=new ProxyManager(this);
  executionService=new ClientExecutionServiceImpl(instanceName,threadGroup,Thread.currentThread().getContextClassLoader(),config.getExecutorPoolSize());
  LoadBalancer loadBalancer=config.getLoadBalancer();
  if (loadBalancer == null) {
    loadBalancer=new RoundRobinLB();
  }
  connectionManager=new ClientConnectionManagerImpl(this,loadBalancer);
  clusterService=new ClientClusterServiceImpl(this);
  invocationService=new ClientInvocationServiceImpl(this);
  userContext=new ConcurrentHashMap<String,Object>();
  loadBalancer.init(getCluster(),config);
  proxyManager.init(config);
  partitionService=new ClientPartitionServiceImpl(this);
}","private HazelcastClient(ClientConfig config){
  this.config=config;
  final GroupConfig groupConfig=config.getGroupConfig();
  instanceName=""String_Node_Str"" + id + (groupConfig != null ? ""String_Node_Str"" + groupConfig.getName() : ""String_Node_Str"");
  threadGroup=new ThreadGroup(instanceName);
  lifecycleService=new LifecycleServiceImpl(this);
  try {
    String partitioningStrategyClassName=System.getProperty(GroupProperties.PROP_PARTITIONING_STRATEGY_CLASS);
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(config.getClassLoader(),partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    serializationService=new SerializationServiceBuilder().setManagedContext(new HazelcastClientManagedContext(this,config.getManagedContext())).setClassLoader(config.getClassLoader()).setConfig(config.getSerializationConfig()).setPartitioningStrategy(partitioningStrategy).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  proxyManager=new ProxyManager(this);
  executionService=new ClientExecutionServiceImpl(instanceName,threadGroup,Thread.currentThread().getContextClassLoader(),config.getExecutorPoolSize());
  transactionManager=new ClientTransactionManager(this);
  LoadBalancer loadBalancer=config.getLoadBalancer();
  if (loadBalancer == null) {
    loadBalancer=new RoundRobinLB();
  }
  connectionManager=new ClientConnectionManagerImpl(this,loadBalancer);
  clusterService=new ClientClusterServiceImpl(this);
  invocationService=new ClientInvocationServiceImpl(this);
  userContext=new ConcurrentHashMap<String,Object>();
  loadBalancer.init(getCluster(),config);
  proxyManager.init(config);
  partitionService=new ClientPartitionServiceImpl(this);
}",0.9847797062750334
48467,"@Override public TransactionContext newTransactionContext(TransactionOptions options){
  return new TransactionContextProxy(this,options);
}","@Override public TransactionContext newTransactionContext(TransactionOptions options){
  return transactionManager.newTransactionContext(options);
}",0.8958333333333334
48468,"void doShutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  connectionManager.shutdown();
  proxyManager.destroy();
}","void doShutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  transactionManager.shutdown();
  connectionManager.shutdown();
  proxyManager.destroy();
}",0.9172932330827068
48469,"public XAResource getXaResource(){
  throw new UnsupportedOperationException();
}","public XAResource getXaResource(){
  if (xaResource == null) {
    xaResource=new XaResourceProxy(this);
  }
  return xaResource;
}",0.5094339622641509
48470,"public TransactionContextProxy(HazelcastClient client,TransactionOptions options){
  try {
    this.connection=client.getConnectionManager().tryToConnect(null);
  }
 catch (  Exception e) {
    throw new HazelcastException(""String_Node_Str"",e);
  }
  this.client=client;
  this.transaction=new TransactionProxy(client,options,connection);
}","public TransactionContextProxy(ClientTransactionManager transactionManager,TransactionOptions options){
  this.transactionManager=transactionManager;
  this.client=transactionManager.getClient();
  try {
    this.connection=client.getConnectionManager().tryToConnect(null);
  }
 catch (  Exception e) {
    throw new HazelcastException(""String_Node_Str"",e);
  }
  this.transaction=new TransactionProxy(client,options,connection);
}",0.7833981841763943
48471,"public void commitTransaction() throws TransactionException {
  transaction.commit();
}","public void commitTransaction() throws TransactionException {
  transaction.commit(true);
}",0.9775280898876404
48472,"@Override public <T>T executeTransaction(TransactionOptions options,TransactionalTask<T> task) throws TransactionException {
  final TransactionContext context=newTransactionContext(options);
  context.beginTransaction();
  try {
    final T value=task.execute(context);
    context.commitTransaction();
    return value;
  }
 catch (  Throwable e) {
    context.rollbackTransaction();
    if (e instanceof TransactionException) {
      throw (TransactionException)e;
    }
    if (e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new TransactionException(e);
  }
}","@Override public <T>T executeTransaction(TransactionOptions options,TransactionalTask<T> task) throws TransactionException {
  return transactionManager.executeTransaction(options,task);
}",0.375
48473,"private HazelcastClient(ClientConfig config){
  this.config=config;
  final GroupConfig groupConfig=config.getGroupConfig();
  instanceName=""String_Node_Str"" + id + (groupConfig != null ? ""String_Node_Str"" + groupConfig.getName() : ""String_Node_Str"");
  threadGroup=new ThreadGroup(instanceName);
  lifecycleService=new LifecycleServiceImpl(this);
  try {
    String partitioningStrategyClassName=System.getProperty(GroupProperties.PROP_PARTITIONING_STRATEGY_CLASS);
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(config.getClassLoader(),partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    serializationService=new SerializationServiceBuilder().setManagedContext(new HazelcastClientManagedContext(this,config.getManagedContext())).setClassLoader(config.getClassLoader()).setConfig(config.getSerializationConfig()).setPartitioningStrategy(partitioningStrategy).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  proxyManager=new ProxyManager(this);
  executionService=new ClientExecutionServiceImpl(instanceName,threadGroup,Thread.currentThread().getContextClassLoader(),config.getExecutorPoolSize());
  clusterService=new ClientClusterServiceImpl(this);
  LoadBalancer loadBalancer=config.getLoadBalancer();
  if (loadBalancer == null) {
    loadBalancer=new RoundRobinLB();
  }
  if (config.isSmartRouting()) {
    connectionManager=new SmartClientConnectionManager(this,clusterService.getAuthenticator(),loadBalancer);
  }
 else {
    connectionManager=new DummyClientConnectionManager(this,clusterService.getAuthenticator(),loadBalancer);
  }
  invocationService=new ClientInvocationServiceImpl(this);
  userContext=new ConcurrentHashMap<String,Object>();
  loadBalancer.init(getCluster(),config);
  proxyManager.init(config);
  partitionService=new ClientPartitionServiceImpl(this);
}","private HazelcastClient(ClientConfig config){
  this.config=config;
  final GroupConfig groupConfig=config.getGroupConfig();
  instanceName=""String_Node_Str"" + id + (groupConfig != null ? ""String_Node_Str"" + groupConfig.getName() : ""String_Node_Str"");
  threadGroup=new ThreadGroup(instanceName);
  lifecycleService=new LifecycleServiceImpl(this);
  try {
    String partitioningStrategyClassName=System.getProperty(GroupProperties.PROP_PARTITIONING_STRATEGY_CLASS);
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(config.getClassLoader(),partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    serializationService=new SerializationServiceBuilder().setManagedContext(new HazelcastClientManagedContext(this,config.getManagedContext())).setClassLoader(config.getClassLoader()).setConfig(config.getSerializationConfig()).setPartitioningStrategy(partitioningStrategy).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  proxyManager=new ProxyManager(this);
  transactionManager=new ClientTransactionManager(this);
  executionService=new ClientExecutionServiceImpl(instanceName,threadGroup,Thread.currentThread().getContextClassLoader(),config.getExecutorPoolSize());
  clusterService=new ClientClusterServiceImpl(this);
  LoadBalancer loadBalancer=config.getLoadBalancer();
  if (loadBalancer == null) {
    loadBalancer=new RoundRobinLB();
  }
  if (config.isSmartRouting()) {
    connectionManager=new SmartClientConnectionManager(this,clusterService.getAuthenticator(),loadBalancer);
  }
 else {
    connectionManager=new DummyClientConnectionManager(this,clusterService.getAuthenticator(),loadBalancer);
  }
  invocationService=new ClientInvocationServiceImpl(this);
  userContext=new ConcurrentHashMap<String,Object>();
  loadBalancer.init(getCluster(),config);
  proxyManager.init(config);
  partitionService=new ClientPartitionServiceImpl(this);
}",0.9862152357920192
48474,"@Override public TransactionContext newTransactionContext(TransactionOptions options){
  return new TransactionContextProxy(this,options);
}","@Override public TransactionContext newTransactionContext(TransactionOptions options){
  return transactionManager.newTransactionContext(options);
}",0.8958333333333334
48475,"public XAResource getXaResource(){
  throw new UnsupportedOperationException();
}","public XAResource getXaResource(){
  if (xaResource == null) {
    xaResource=new XaResourceProxy(this);
  }
  return xaResource;
}",0.5094339622641509
48476,"public TransactionContextProxy(HazelcastClient client,TransactionOptions options){
  this.client=client;
  this.connection=connect();
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  this.transaction=new TransactionProxy(client,options,connection);
}","public TransactionContextProxy(ClientTransactionManager transactionManager,TransactionOptions options){
  this.transactionManager=transactionManager;
  this.client=transactionManager.getClient();
  this.connection=transactionManager.connect();
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  this.transaction=new TransactionProxy(client,options,connection);
}",0.6967930029154519
48477,"public void commitTransaction() throws TransactionException {
  transaction.commit();
}","public void commitTransaction() throws TransactionException {
  transaction.commit(true);
}",0.9775280898876404
48478,"private void handleMap(HttpPostCommand command,String uri){
  int indexEnd=uri.indexOf('/',URI_MAPS.length());
  String mapName=uri.substring(URI_MAPS.length(),indexEnd);
  String key=uri.substring(indexEnd + 1);
  byte[] data=command.getData();
  textCommandService.put(mapName,key,new RestValue(data,command.getContentType()),0);
  command.setResponse(HttpCommand.RES_204);
}","private void handleMap(HttpPostCommand command,String uri){
  int indexEnd=uri.indexOf('/',URI_MAPS.length());
  String mapName=uri.substring(URI_MAPS.length(),indexEnd);
  String key=uri.substring(indexEnd + 1);
  byte[] data=command.getData();
  textCommandService.put(mapName,key,new RestValue(data,command.getContentType()),-1);
  command.setResponse(HttpCommand.RES_204);
}",0.9960264900662252
48479,"private boolean doAwait(long time,TimeUnit unit,long threadId) throws InterruptedException {
  final long timeoutInMillis=unit.toMillis(time);
  AwaitRequest awaitRequest=new AwaitRequest(namespace,lockProxy.getName(),timeoutInMillis,threadId,conditionId);
  return invoke(awaitRequest);
}","private boolean doAwait(long time,TimeUnit unit,long threadId) throws InterruptedException {
  final long timeoutInMillis=unit.toMillis(time);
  AwaitRequest awaitRequest=new AwaitRequest(namespace,lockProxy.getName(),timeoutInMillis,threadId,conditionId);
  final Boolean result=invoke(awaitRequest);
  return result;
}",0.9261083743842364
48480,"public void handle(HttpPostCommand command){
  try {
    String uri=command.getURI();
    if (uri.startsWith(URI_MAPS)) {
      int indexEnd=uri.indexOf('/',URI_MAPS.length());
      String mapName=uri.substring(URI_MAPS.length(),indexEnd);
      String key=uri.substring(indexEnd + 1);
      byte[] data=command.getData();
      textCommandService.put(mapName,key,new RestValue(data,command.getContentType()),0);
      command.setResponse(HttpCommand.RES_204);
    }
 else     if (uri.startsWith(URI_MANCENTER_CHANGE_URL)) {
      if (textCommandService.getNode().getGroupProperties().MC_URL_CHANGE_ENABLED.getBoolean()) {
        byte[] res=HttpCommand.RES_204;
        byte[] data=command.getData();
        String[] strList=new String(data).split(""String_Node_Str"");
        String cluster=URLDecoder.decode(strList[0],""String_Node_Str"");
        String pass=URLDecoder.decode(strList[1],""String_Node_Str"");
        String url=URLDecoder.decode(strList[2],""String_Node_Str"");
        ManagementCenterService managementCenterService=textCommandService.getNode().getManagementCenterService();
        if (managementCenterService != null) {
          res=managementCenterService.changeWebServerUrlOverCluster(cluster,pass,url);
        }
        command.setResponse(res);
      }
 else {
        command.setResponse(HttpCommand.RES_503);
      }
    }
 else     if (uri.startsWith(URI_QUEUES)) {
      String queueName=null;
      String simpleValue=null;
      String suffix;
      if (uri.endsWith(""String_Node_Str"")) {
        suffix=uri.substring(URI_QUEUES.length(),uri.length() - 1);
      }
 else {
        suffix=uri.substring(URI_QUEUES.length(),uri.length());
      }
      int indexSlash=suffix.lastIndexOf(""String_Node_Str"");
      if (indexSlash == -1) {
        queueName=suffix;
      }
 else {
        queueName=suffix.substring(0,indexSlash);
        simpleValue=suffix.substring(indexSlash + 1,suffix.length());
      }
      byte[] data;
      byte[] contentType;
      if (simpleValue == null) {
        data=command.getData();
        contentType=command.getContentType();
      }
 else {
        data=simpleValue.getBytes();
        contentType=QUEUE_SIMPLE_VALUE_CONTENT_TYPE;
      }
      boolean offerResult=textCommandService.offer(queueName,new RestValue(data,contentType));
      if (offerResult) {
        command.setResponse(HttpCommand.RES_204);
      }
 else {
        command.setResponse(HttpCommand.RES_503);
      }
    }
 else {
      command.setResponse(HttpCommand.RES_400);
    }
  }
 catch (  Exception e) {
    command.setResponse(HttpCommand.RES_500);
  }
  textCommandService.sendResponse(command);
}","public void handle(HttpPostCommand command){
  try {
    String uri=command.getURI();
    if (uri.startsWith(URI_MAPS)) {
      int indexEnd=uri.indexOf('/',URI_MAPS.length());
      String mapName=uri.substring(URI_MAPS.length(),indexEnd);
      String key=uri.substring(indexEnd + 1);
      byte[] data=command.getData();
      textCommandService.put(mapName,key,new RestValue(data,command.getContentType()),-1);
      command.setResponse(HttpCommand.RES_204);
    }
 else     if (uri.startsWith(URI_MANCENTER_CHANGE_URL)) {
      if (textCommandService.getNode().getGroupProperties().MC_URL_CHANGE_ENABLED.getBoolean()) {
        byte[] res=HttpCommand.RES_204;
        byte[] data=command.getData();
        String[] strList=new String(data).split(""String_Node_Str"");
        String cluster=URLDecoder.decode(strList[0],""String_Node_Str"");
        String pass=URLDecoder.decode(strList[1],""String_Node_Str"");
        String url=URLDecoder.decode(strList[2],""String_Node_Str"");
        ManagementCenterService managementCenterService=textCommandService.getNode().getManagementCenterService();
        if (managementCenterService != null) {
          res=managementCenterService.changeWebServerUrlOverCluster(cluster,pass,url);
        }
        command.setResponse(res);
      }
 else {
        command.setResponse(HttpCommand.RES_503);
      }
    }
 else     if (uri.startsWith(URI_QUEUES)) {
      String queueName=null;
      String simpleValue=null;
      String suffix;
      if (uri.endsWith(""String_Node_Str"")) {
        suffix=uri.substring(URI_QUEUES.length(),uri.length() - 1);
      }
 else {
        suffix=uri.substring(URI_QUEUES.length(),uri.length());
      }
      int indexSlash=suffix.lastIndexOf(""String_Node_Str"");
      if (indexSlash == -1) {
        queueName=suffix;
      }
 else {
        queueName=suffix.substring(0,indexSlash);
        simpleValue=suffix.substring(indexSlash + 1,suffix.length());
      }
      byte[] data;
      byte[] contentType;
      if (simpleValue == null) {
        data=command.getData();
        contentType=command.getContentType();
      }
 else {
        data=simpleValue.getBytes();
        contentType=QUEUE_SIMPLE_VALUE_CONTENT_TYPE;
      }
      boolean offerResult=textCommandService.offer(queueName,new RestValue(data,contentType));
      if (offerResult) {
        command.setResponse(HttpCommand.RES_204);
      }
 else {
        command.setResponse(HttpCommand.RES_503);
      }
    }
 else {
      command.setResponse(HttpCommand.RES_400);
    }
  }
 catch (  Exception e) {
    command.setResponse(HttpCommand.RES_500);
  }
  textCommandService.sendResponse(command);
}",0.9994329994329996
48481,"public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  long heapCost=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final com.hazelcast.partition.PartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    InternalPartition partition=partitionService.getPartition(partitionId);
    Address owner=partition.getOwner();
    if (owner == null) {
    }
 else     if (owner.equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getRecordStore(mapName);
      heapCost+=recordStore.getHeapCost();
      Map<Data,Record> records=recordStore.getReadonlyRecordMap();
      for (      Record record : records.values()) {
        RecordStatistics stats=record.getStatistics();
        ownedEntryCount++;
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(stats.getLastAccessTime());
        localMapStats.setLastUpdateTime(stats.getLastUpdateTime());
        hits+=stats.getHits();
        if (recordStore.isLocked(record.getKey())) {
          lockedEntryCount++;
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          heapCost+=recordStore.getHeapCost();
          Map<Data,Record> records=recordStore.getReadonlyRecordMap();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.warning(""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  heapCost+=mapContainer.getNearCacheSizeEstimator().getSize();
  localMapStats.setHeapCost(heapCost);
  if (mapContainer.getMapConfig().isNearCacheEnabled()) {
    NearCacheStatsImpl nearCacheStats=getNearCache(mapName).getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
  }
  return localMapStats;
}","public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  long heapCost=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final com.hazelcast.partition.PartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    InternalPartition partition=partitionService.getPartition(partitionId);
    Address owner=partition.getOwner();
    if (owner == null) {
    }
 else     if (owner.equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getExistingRecordStore(mapName);
      if (recordStore != null) {
        heapCost+=recordStore.getHeapCost();
        Map<Data,Record> records=recordStore.getReadonlyRecordMap();
        for (        Record record : records.values()) {
          RecordStatistics stats=record.getStatistics();
          ownedEntryCount++;
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(stats.getLastAccessTime());
          localMapStats.setLastUpdateTime(stats.getLastUpdateTime());
          hits+=stats.getHits();
          if (recordStore.isLocked(record.getKey())) {
            lockedEntryCount++;
          }
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          heapCost+=recordStore.getHeapCost();
          Map<Data,Record> records=recordStore.getReadonlyRecordMap();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.warning(""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  heapCost+=mapContainer.getNearCacheSizeEstimator().getSize();
  localMapStats.setHeapCost(heapCost);
  if (mapContainer.getMapConfig().isNearCacheEnabled()) {
    NearCacheStatsImpl nearCacheStats=getNearCache(mapName).getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
  }
  return localMapStats;
}",0.9906291834002676
48482,"private void fireEvictCache(){
  if (canEvict.compareAndSet(true,false)) {
    try {
      context.getExecutionService().execute(new Runnable(){
        public void run(){
          try {
            TreeSet<CacheRecord<K>> records=new TreeSet<CacheRecord<K>>(cache.values());
            int evictSize=cache.size() * evictionPercentage / 100;
            int i=0;
            for (            CacheRecord<K> record : records) {
              cache.remove(record.key);
              if (++i > evictSize)               break;
            }
          }
  finally {
            canEvict.set(true);
          }
        }
      }
);
    }
 catch (    RejectedExecutionException e) {
      canEvict.set(true);
    }
catch (    Exception e) {
      throw ExceptionUtil.rethrow(e);
    }
  }
}","private void fireEvictCache(){
  if (canEvict.compareAndSet(true,false)) {
    try {
      context.getExecutionService().execute(new Runnable(){
        public void run(){
          try {
            TreeSet<CacheRecord<K>> records=new TreeSet<CacheRecord<K>>(comparator);
            records.addAll(cache.values());
            int evictSize=cache.size() * evictionPercentage / 100;
            int i=0;
            for (            CacheRecord<K> record : records) {
              cache.remove(record.key);
              if (++i > evictSize)               break;
            }
          }
  finally {
            canEvict.set(true);
          }
        }
      }
);
    }
 catch (    RejectedExecutionException e) {
      canEvict.set(true);
    }
catch (    Exception e) {
      throw ExceptionUtil.rethrow(e);
    }
  }
}",0.9751552795031057
48483,"private EventHandler<PortableEntryEvent> createHandler(final EntryListener<K,V> listener,final boolean includeValue){
  return new EventHandler<PortableEntryEvent>(){
    public void handle(    PortableEntryEvent event){
      V value=null;
      V oldValue=null;
      if (includeValue) {
        value=toObject(event.getValue());
        oldValue=toObject(event.getOldValue());
      }
      K key=toObject(event.getKey());
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}
}
;
}","private EventHandler<PortableEntryEvent> createHandler(final EntryListener<K,V> listener,final boolean includeValue){
  return new EventHandler<PortableEntryEvent>(){
    public void handle(    PortableEntryEvent event){
      V value=null;
      V oldValue=null;
      if (includeValue) {
        value=toObject(event.getValue());
        oldValue=toObject(event.getOldValue());
      }
      K key=toObject(event.getKey());
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}
}
;
}",0.9536354056902002
48484,"public void handle(PortableEntryEvent event){
  V value=null;
  V oldValue=null;
  if (includeValue) {
    value=toObject(event.getValue());
    oldValue=toObject(event.getOldValue());
  }
  K key=toObject(event.getKey());
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}","public void handle(PortableEntryEvent event){
  V value=null;
  V oldValue=null;
  if (includeValue) {
    value=toObject(event.getValue());
    oldValue=toObject(event.getOldValue());
  }
  K key=toObject(event.getKey());
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}",0.9387186629526464
48485,"@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  latch.await(timeout,unit);
  if (!isDone()) {
    throw new TimeoutException(""String_Node_Str"");
  }
  return getResult();
}","@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  if (!latch.await(timeout,unit) || !isDone()) {
    throw new TimeoutException(""String_Node_Str"");
  }
  return getResult();
}",0.692436974789916
48486,"private EventHandler<PortableEntryEvent> createHandler(final EntryListener<K,V> listener,final boolean includeValue){
  return new EventHandler<PortableEntryEvent>(){
    public void handle(    PortableEntryEvent event){
      V value=null;
      V oldValue=null;
      if (includeValue) {
        value=(V)toObject(event.getValue());
        oldValue=(V)toObject(event.getOldValue());
      }
      K key=(K)toObject(event.getKey());
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}
}
;
}","private EventHandler<PortableEntryEvent> createHandler(final EntryListener<K,V> listener,final boolean includeValue){
  return new EventHandler<PortableEntryEvent>(){
    public void handle(    PortableEntryEvent event){
      V value=null;
      V oldValue=null;
      if (includeValue) {
        value=(V)toObject(event.getValue());
        oldValue=(V)toObject(event.getOldValue());
      }
      K key=(K)toObject(event.getKey());
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}
}
;
}",0.954070981210856
48487,"public void handle(PortableEntryEvent event){
  V value=null;
  V oldValue=null;
  if (includeValue) {
    value=(V)toObject(event.getValue());
    oldValue=(V)toObject(event.getOldValue());
  }
  K key=(K)toObject(event.getKey());
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}","public void handle(PortableEntryEvent event){
  V value=null;
  V oldValue=null;
  if (includeValue) {
    value=(V)toObject(event.getValue());
    oldValue=(V)toObject(event.getOldValue());
  }
  K key=(K)toObject(event.getKey());
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(name,member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}",0.939477303988996
48488,"public void handle(ReplicatedMapPortableEntryEvent event){
  V value=(V)event.getValue();
  V oldValue=(V)event.getOldValue();
  K key=(K)event.getKey();
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(getName(),member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}","public void handle(ReplicatedMapPortableEntryEvent event){
  V value=(V)event.getValue();
  V oldValue=(V)event.getOldValue();
  K key=(K)event.getKey();
  Member member=getContext().getClusterService().getMember(event.getUuid());
  EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(getName(),member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(entryEvent);
  break;
case REMOVED:
listener.entryRemoved(entryEvent);
break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}",0.9327217125382264
48489,"private EventHandler<ReplicatedMapPortableEntryEvent> createHandler(final EntryListener<K,V> listener){
  return new EventHandler<ReplicatedMapPortableEntryEvent>(){
    public void handle(    ReplicatedMapPortableEntryEvent event){
      V value=(V)event.getValue();
      V oldValue=(V)event.getOldValue();
      K key=(K)event.getKey();
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(getName(),member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
}
}
}
;
}","private EventHandler<ReplicatedMapPortableEntryEvent> createHandler(final EntryListener<K,V> listener){
  return new EventHandler<ReplicatedMapPortableEntryEvent>(){
    public void handle(    ReplicatedMapPortableEntryEvent event){
      V value=(V)event.getValue();
      V oldValue=(V)event.getOldValue();
      K key=(K)event.getKey();
      Member member=getContext().getClusterService().getMember(event.getUuid());
      EntryEvent<K,V> entryEvent=new EntryEvent<K,V>(getName(),member,event.getEventType().getType(),key,oldValue,value);
switch (event.getEventType()) {
case ADDED:
        listener.entryAdded(entryEvent);
      break;
case REMOVED:
    listener.entryRemoved(entryEvent);
  break;
case UPDATED:
listener.entryUpdated(entryEvent);
break;
case EVICTED:
listener.entryEvicted(entryEvent);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
}
}
;
}",0.9493087557603688
48490,"private boolean resend(){
  reSendCount++;
  if (reSendCount > MAX_RESEND_COUNT) {
    return false;
  }
  executionService.execute(new ReSendTask());
  return true;
}","private boolean resend(){
  if (reSendCount.incrementAndGet() > MAX_RESEND_COUNT) {
    return false;
  }
  executionService.execute(new ReSendTask());
  return true;
}",0.8955223880597015
48491,"public void init(final NodeEngine nodeEngine,Properties properties){
  long mergeFirstRunDelay=node.getGroupProperties().MERGE_FIRST_RUN_DELAY_SECONDS.getLong() * 1000;
  mergeFirstRunDelay=mergeFirstRunDelay <= 0 ? 100 : mergeFirstRunDelay;
  ExecutionService executionService=nodeEngine.getExecutionService();
  final String executor=""String_Node_Str"";
  executionService.register(executor,8,100000);
  long mergeNextRunDelay=node.getGroupProperties().MERGE_NEXT_RUN_DELAY_SECONDS.getLong() * 1000;
  mergeNextRunDelay=mergeNextRunDelay <= 0 ? 100 : mergeNextRunDelay;
  executionService.scheduleWithFixedDelay(executor,new SplitBrainHandler(node),mergeFirstRunDelay,mergeNextRunDelay,TimeUnit.MILLISECONDS);
  long heartbeatInterval=node.groupProperties.HEARTBEAT_INTERVAL_SECONDS.getInteger();
  heartbeatInterval=heartbeatInterval <= 0 ? 1 : heartbeatInterval;
  executionService.scheduleWithFixedDelay(executor,new Runnable(){
    public void run(){
      heartBeater();
    }
  }
,heartbeatInterval,heartbeatInterval,TimeUnit.SECONDS);
  long masterConfirmationInterval=node.groupProperties.MASTER_CONFIRMATION_INTERVAL_SECONDS.getInteger();
  masterConfirmationInterval=masterConfirmationInterval <= 0 ? 1 : masterConfirmationInterval;
  executionService.scheduleWithFixedDelay(executor,new Runnable(){
    public void run(){
      sendMasterConfirmation();
    }
  }
,masterConfirmationInterval,masterConfirmationInterval,TimeUnit.SECONDS);
  long memberListPublishInterval=node.groupProperties.MEMBER_LIST_PUBLISH_INTERVAL_SECONDS.getInteger();
  memberListPublishInterval=memberListPublishInterval <= 0 ? 1 : memberListPublishInterval;
  executionService.scheduleWithFixedDelay(executor,new Runnable(){
    public void run(){
      sendMemberListToOthers();
    }
  }
,memberListPublishInterval,memberListPublishInterval,TimeUnit.SECONDS);
}","public void init(final NodeEngine nodeEngine,Properties properties){
  long mergeFirstRunDelay=node.getGroupProperties().MERGE_FIRST_RUN_DELAY_SECONDS.getLong() * 1000;
  mergeFirstRunDelay=mergeFirstRunDelay <= 0 ? 100 : mergeFirstRunDelay;
  ExecutionService executionService=nodeEngine.getExecutionService();
  String executorName=""String_Node_Str"";
  executionService.register(executorName,8,100000);
  long mergeNextRunDelay=node.getGroupProperties().MERGE_NEXT_RUN_DELAY_SECONDS.getLong() * 1000;
  mergeNextRunDelay=mergeNextRunDelay <= 0 ? 100 : mergeNextRunDelay;
  executionService.scheduleWithFixedDelay(executorName,new SplitBrainHandler(node),mergeFirstRunDelay,mergeNextRunDelay,TimeUnit.MILLISECONDS);
  long heartbeatInterval=node.groupProperties.HEARTBEAT_INTERVAL_SECONDS.getInteger();
  heartbeatInterval=heartbeatInterval <= 0 ? 1 : heartbeatInterval;
  executionService.scheduleWithFixedDelay(executorName,new Runnable(){
    public void run(){
      heartBeater();
    }
  }
,heartbeatInterval,heartbeatInterval,TimeUnit.SECONDS);
  long masterConfirmationInterval=node.groupProperties.MASTER_CONFIRMATION_INTERVAL_SECONDS.getInteger();
  masterConfirmationInterval=masterConfirmationInterval <= 0 ? 1 : masterConfirmationInterval;
  executionService.scheduleWithFixedDelay(executorName,new Runnable(){
    public void run(){
      sendMasterConfirmation();
    }
  }
,masterConfirmationInterval,masterConfirmationInterval,TimeUnit.SECONDS);
  long memberListPublishInterval=node.groupProperties.MEMBER_LIST_PUBLISH_INTERVAL_SECONDS.getInteger();
  memberListPublishInterval=memberListPublishInterval <= 0 ? 1 : memberListPublishInterval;
  executionService.scheduleWithFixedDelay(executorName,new Runnable(){
    public void run(){
      sendMemberListToOthers();
    }
  }
,memberListPublishInterval,memberListPublishInterval,TimeUnit.SECONDS);
}",0.983879634605051
48492,"public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}","public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getCost(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}",0.9932027189124352
48493,"@SuppressWarnings(""String_Node_Str"") public void dispatchEvent(EventData eventData,EntryListener listener){
  Member member=nodeEngine.getClusterService().getMember(eventData.getCaller());
  EntryEvent event=new DataAwareEntryEvent(member,eventData.getEventType(),eventData.getMapName(),eventData.getDataKey(),eventData.getDataNewValue(),eventData.getDataOldValue(),getSerializationService());
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(event);
  break;
case EVICTED:
listener.entryEvicted(event);
break;
case UPDATED:
listener.entryUpdated(event);
break;
case REMOVED:
listener.entryRemoved(event);
break;
}
MapContainer mapContainer=getMapContainer(eventData.getMapName());
if (mapContainer.getMapConfig().isStatisticsEnabled()) {
getLocalMapStatsImpl(eventData.getMapName()).incrementReceivedEvents();
}
}","@SuppressWarnings(""String_Node_Str"") public void dispatchEvent(EventData eventData,EntryListener listener){
  Member member=nodeEngine.getClusterService().getMember(eventData.getCaller());
  EntryEvent event=new DataAwareEntryEvent(member,eventData.getEventType(),eventData.getMapName(),eventData.getDataKey(),eventData.getDataNewValue(),eventData.getDataOldValue(),getSerializationService());
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(event);
  break;
case EVICTED:
listener.entryEvicted(event);
break;
case UPDATED:
listener.entryUpdated(event);
break;
case REMOVED:
listener.entryRemoved(event);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event.getEventType());
}
MapContainer mapContainer=getMapContainer(eventData.getMapName());
if (mapContainer.getMapConfig().isStatisticsEnabled()) {
getLocalMapStatsImpl(eventData.getMapName()).incrementReceivedEvents();
}
}",0.9498289623717218
48494,"public Permission getRequiredPermission(){
  String action=ActionConstants.ACTION_READ;
switch (requestType) {
case PUT:
case PUT_IF_ABSENT:
case REPLACE:
case REPLACE_IF_SAME:
case SET:
    action=ActionConstants.ACTION_PUT;
  break;
case REMOVE:
case DELETE:
case REMOVE_IF_SAME:
action=ActionConstants.ACTION_REMOVE;
break;
}
return new MapPermission(name,action);
}","public Permission getRequiredPermission(){
  String action=ActionConstants.ACTION_READ;
switch (requestType) {
case PUT:
case PUT_IF_ABSENT:
case REPLACE:
case REPLACE_IF_SAME:
case SET:
    action=ActionConstants.ACTION_PUT;
  break;
case REMOVE:
case DELETE:
case REMOVE_IF_SAME:
action=ActionConstants.ACTION_REMOVE;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + requestType);
}
return new MapPermission(name,action);
}",0.9033047735618116
48495,"public void afterRun(){
  mapService.interceptAfterPut(name,dataValue);
  if (eventType == null)   eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    Record record=recordStore.getRecord(dataKey);
    SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
    mapService.publishWanReplicationUpdate(name,entryView);
  }
}","public void afterRun(){
  mapService.interceptAfterPut(name,dataValue);
  if (eventType == null)   eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    Record record=recordStore.getRecord(dataKey);
    SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getCost(),record.getVersion());
    mapService.publishWanReplicationUpdate(name,entryView);
  }
}",0.9870525514089872
48496,"public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}","public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getCost(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.9891095451633568
48497,"public void run(){
  MapService mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Record record=recordStore.getRecord(dataKey);
  if (record != null) {
    result=new SimpleEntryView(record.getKey(),mapService.toData(record.getValue()),record.getStatistics(),record.getVersion());
  }
}","public void run(){
  MapService mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Record record=recordStore.getRecord(dataKey);
  if (record != null) {
    result=new SimpleEntryView(record.getKey(),mapService.toData(record.getValue()),record.getStatistics(),record.getCost(),record.getVersion());
  }
}",0.9763560500695412
48498,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getCost(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9974160206718348
48499,"public void run(){
  backupEntrySet=new MapEntrySet();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Set<Map.Entry<Data,Data>> entries=entrySet.getEntrySet();
  PartitionService partitionService=getNodeEngine().getPartitionService();
  for (  Map.Entry<Data,Data> entry : entries) {
    Data dataKey=entry.getKey();
    Data dataValue=entry.getValue();
    if (partitionId == partitionService.getPartitionId(dataKey)) {
      Data dataOldValue=null;
      if (initialLoad) {
        recordStore.putFromLoad(dataKey,dataValue,-1);
      }
 else {
        dataOldValue=mapService.toData(recordStore.put(dataKey,dataValue,-1));
      }
      mapService.interceptAfterPut(name,dataValue);
      EntryEventType eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
      invalidateNearCaches(dataKey);
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        Record record=recordStore.getRecord(dataKey);
        SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
        mapService.publishWanReplicationUpdate(name,entryView);
      }
      backupEntrySet.add(entry);
    }
  }
}","public void run(){
  backupEntrySet=new MapEntrySet();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Set<Map.Entry<Data,Data>> entries=entrySet.getEntrySet();
  PartitionService partitionService=getNodeEngine().getPartitionService();
  for (  Map.Entry<Data,Data> entry : entries) {
    Data dataKey=entry.getKey();
    Data dataValue=entry.getValue();
    if (partitionId == partitionService.getPartitionId(dataKey)) {
      Data dataOldValue=null;
      if (initialLoad) {
        recordStore.putFromLoad(dataKey,dataValue,-1);
      }
 else {
        dataOldValue=mapService.toData(recordStore.put(dataKey,dataValue,-1));
      }
      mapService.interceptAfterPut(name,dataValue);
      EntryEventType eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
      invalidateNearCaches(dataKey);
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        Record record=recordStore.getRecord(dataKey);
        SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getCost(),record.getVersion());
        mapService.publishWanReplicationUpdate(name,entryView);
      }
      backupEntrySet.add(entry);
    }
  }
}",0.9939480242079032
48500,"public void readData(ObjectDataInput in) throws IOException {
  hits=in.readInt();
  lastStoredTime=in.readLong();
  lastUpdateTime=in.readLong();
  lastAccessTime=in.readLong();
  cost=in.readLong();
}","public void readData(ObjectDataInput in) throws IOException {
  hits=in.readInt();
  lastStoredTime=in.readLong();
  lastUpdateTime=in.readLong();
  lastAccessTime=in.readLong();
  in.readLong();
}",0.987468671679198
48501,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(hits);
  out.writeLong(lastStoredTime);
  out.writeLong(lastUpdateTime);
  out.writeLong(lastAccessTime);
  out.writeLong(cost);
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(hits);
  out.writeLong(lastStoredTime);
  out.writeLong(lastUpdateTime);
  out.writeLong(lastAccessTime);
  out.writeLong(0l);
}",0.985645933014354
48502,"public long size(){
  return 6 * (Long.SIZE / Byte.SIZE) + (Integer.SIZE / Byte.SIZE);
}","public long size(){
  return 5 * (Long.SIZE / Byte.SIZE) + (Integer.SIZE / Byte.SIZE);
}",0.9886363636363636
48503,"@Test public void testPuts() throws InterruptedException {
  final String MAP_NAME=""String_Node_Str"";
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(1);
  final HazelcastInstance h=factory.newHazelcastInstance(config);
  final IMap<Integer,Long> map=h.getMap(MAP_NAME);
  map.put(0,10L);
  Assert.assertEquals(156,map.getLocalMapStats().getHeapCost());
}","@Test public void testPuts() throws InterruptedException {
  final String MAP_NAME=""String_Node_Str"";
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(1);
  final HazelcastInstance h=factory.newHazelcastInstance(config);
  final IMap<Integer,Long> map=h.getMap(MAP_NAME);
  map.put(0,10L);
  Assert.assertEquals(148,map.getLocalMapStats().getHeapCost());
}",0.9951573849878934
48504,"@Override public void readData(ObjectDataInput in) throws IOException {
  key=in.readUTF();
  member=new MemberImpl();
  member.readData(in);
  int operation=in.readByte();
switch (operation) {
case DELTA_MEMBER_PROPERTIES_OP_PUT:
    operationType=MapOperationType.PUT;
  value=IOUtil.readAttributeValue(in);
break;
case DELTA_MEMBER_PROPERTIES_OP_REMOVE:
operationType=MapOperationType.REMOVE;
break;
}
this.source=member;
}","@Override public void readData(ObjectDataInput in) throws IOException {
  key=in.readUTF();
  member=new MemberImpl();
  member.readData(in);
  int operation=in.readByte();
switch (operation) {
case DELTA_MEMBER_PROPERTIES_OP_PUT:
    operationType=MapOperationType.PUT;
  value=IOUtil.readAttributeValue(in);
break;
case DELTA_MEMBER_PROPERTIES_OP_REMOVE:
operationType=MapOperationType.REMOVE;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + operationType);
}
this.source=member;
}",0.9161290322580644
48505,"@Override public void writeData(ObjectDataOutput out) throws IOException {
  out.writeUTF(key);
  member.writeData(out);
switch (operationType) {
case PUT:
    out.writeByte(DELTA_MEMBER_PROPERTIES_OP_PUT);
  IOUtil.writeAttributeValue(value,out);
break;
case REMOVE:
out.writeByte(DELTA_MEMBER_PROPERTIES_OP_REMOVE);
break;
}
}","@Override public void writeData(ObjectDataOutput out) throws IOException {
  out.writeUTF(key);
  member.writeData(out);
switch (operationType) {
case PUT:
    out.writeByte(DELTA_MEMBER_PROPERTIES_OP_PUT);
  IOUtil.writeAttributeValue(value,out);
break;
case REMOVE:
out.writeByte(DELTA_MEMBER_PROPERTIES_OP_REMOVE);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + operationType);
}
}",0.8937329700272479
48506,"public Collection<V> remove(Object key){
  TxnMultiMapRemoveRequest request=new TxnMultiMapRemoveRequest(getName(),toData(key));
  PortableCollection portableCollection=invoke(request);
  final Collection<Data> collection=portableCollection.getCollection();
  Collection<V> coll;
  if (collection instanceof List) {
    coll=new ArrayList<V>(collection.size());
  }
 else {
    coll=new HashSet<V>(collection.size());
  }
  for (  Data data : collection) {
    coll.add((V)toObject(data));
  }
  return coll;
}","public Collection<V> remove(Object key){
  TxnMultiMapRemoveAllRequest request=new TxnMultiMapRemoveAllRequest(getName(),toData(key));
  PortableCollection portableCollection=invoke(request);
  final Collection<Data> collection=portableCollection.getCollection();
  Collection<V> coll;
  if (collection instanceof List) {
    coll=new ArrayList<V>(collection.size());
  }
 else {
    coll=new HashSet<V>(collection.size());
  }
  for (  Data data : collection) {
    coll.add((V)toObject(data));
  }
  return coll;
}",0.9941520467836256
48507,"public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[REMOVE_ENTRY_LISTENER + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsEntryRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  constructors[REMOVE_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveEntryListenerRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}","public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[TXN_MM_REMOVEALL + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsEntryRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  constructors[REMOVE_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveEntryListenerRequest();
    }
  }
;
  constructors[TXN_MM_REMOVEALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveAllRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}",0.9714638665843112
48508,"public Portable createNew(Integer arg){
  return new RemoveEntryListenerRequest();
}","public Portable createNew(Integer arg){
  return new TxnMultiMapRemoveAllRequest();
}",0.8402366863905325
48509,"public int getClassId(){
  return MultiMapPortableHook.TXN_MM_GET;
}","public int getClassId(){
  return MultiMapPortableHook.TXN_MM_REMOVE;
}",0.9496402877697842
48510,"public Object innerCall() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext(txnId);
  final TransactionalMultiMap<Object,Object> multiMap=context.getMultiMap(name);
  if (value == null) {
    final Collection<Object> objects=multiMap.remove(key);
    Collection<Data> coll=createCollection(objects.size());
    for (    Object object : objects) {
      final Data data=toData(object);
      coll.add(data);
    }
    return new PortableCollection(coll);
  }
 else {
    return multiMap.remove(key,value);
  }
}","public Object innerCall() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext(txnId);
  final TransactionalMultiMap<Object,Object> multiMap=context.getMultiMap(name);
  return multiMap.remove(key,value);
}",0.6128625472887768
48511,"/** 
 * This method is called before accessing the key-value pairs of this KeyValueSource
 * @param nodeEngine nodeEngine of this cluster node
 */
public abstract void open(NodeEngine nodeEngine);","/** 
 * This method is called before accessing the key-value pairs of this KeyValueSource
 * @param nodeEngine nodeEngine of this cluster node
 * @return true if operation succeed otherwise false
 */
public abstract boolean open(NodeEngine nodeEngine);",0.8571428571428571
48512,"@Override public void open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  ss=nei.getSerializationService();
  Address thisAddress=nei.getThisAddress();
  PartitionService ps=nei.getPartitionService();
  Data data=ss.toData(listName,StringAndPartitionAwarePartitioningStrategy.INSTANCE);
  int partitionId=ps.getPartitionId(data);
  if (!thisAddress.equals(ps.getPartitionOwner(partitionId))) {
    return;
  }
  ListService listService=nei.getService(ListService.SERVICE_NAME);
  ListContainer listContainer=listService.getOrCreateContainer(listName,false);
  List<CollectionItem> items=new ArrayList<CollectionItem>(listContainer.getCollection());
  iterator=items.iterator();
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  ss=nei.getSerializationService();
  Address thisAddress=nei.getThisAddress();
  PartitionService ps=nei.getPartitionService();
  Data data=ss.toData(listName,StringAndPartitionAwarePartitioningStrategy.INSTANCE);
  int partitionId=ps.getPartitionId(data);
  Address partitionOwner=ps.getPartitionOwner(partitionId);
  if (partitionOwner == null) {
    return false;
  }
  if (thisAddress.equals(partitionOwner)) {
    ListService listService=nei.getService(ListService.SERVICE_NAME);
    ListContainer listContainer=listService.getOrCreateContainer(listName,false);
    List<CollectionItem> items=new ArrayList<CollectionItem>(listContainer.getCollection());
    iterator=items.iterator();
  }
  return true;
}",0.8791064388961892
48513,"@Override public void open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MapService mapService=nei.getService(MapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  RecordStore recordStore=mapService.getRecordStore(partitionId,mapName);
  iterator=recordStore.entrySetData().iterator();
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MapService mapService=nei.getService(MapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  RecordStore recordStore=mapService.getRecordStore(partitionId,mapName);
  iterator=recordStore.entrySetData().iterator();
  return true;
}",0.9611940298507464
48514,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[PROCESS_STATS_UPDATE_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ProcessStatsUpdateOperation();
    }
  }
;
  constructors[NOTIFY_REMOTE_EXCEPTION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new NotifyRemoteExceptionOperation();
    }
  }
;
  constructors[CANCEL_JOB_SUPERVISOR_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new CancelJobSupervisorOperation();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_LIST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ListKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new SetKeyValueSource();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentResult();
    }
  }
;
  constructors[KEYS_ASSIGNMENT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeysAssignmentOperation();
    }
  }
;
  constructors[POSTPONE_PARTITION_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new PostPonePartitionProcessing();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9739979348540316
48515,"@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new KeysAssignmentOperation();
}","@Override public IdentifiedDataSerializable createNew(Integer arg){
  return new PostPonePartitionProcessing();
}",0.8288288288288288
48516,"@Override public void open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MultiMapService multiMapService=nei.getService(MultiMapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  multiMapContainer=multiMapService.getOrCreateCollectionContainer(partitionId,multiMapName);
  isBinary=multiMapContainer.getConfig().isBinary();
  keyIterator=multiMapContainer.keySet().iterator();
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  MultiMapService multiMapService=nei.getService(MultiMapService.SERVICE_NAME);
  ss=nei.getSerializationService();
  multiMapContainer=multiMapService.getOrCreateCollectionContainer(partitionId,multiMapName);
  isBinary=multiMapContainer.getConfig().isBinary();
  keyIterator=multiMapContainer.keySet().iterator();
  return true;
}",0.9694835680751174
48517,"@Override public void open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  ss=nei.getSerializationService();
  Address thisAddress=nei.getThisAddress();
  PartitionService ps=nei.getPartitionService();
  Data data=ss.toData(setName,StringAndPartitionAwarePartitioningStrategy.INSTANCE);
  int partitionId=ps.getPartitionId(data);
  if (!thisAddress.equals(ps.getPartitionOwner(partitionId))) {
    return;
  }
  SetService setService=nei.getService(SetService.SERVICE_NAME);
  SetContainer setContainer=setService.getOrCreateContainer(setName,false);
  List<CollectionItem> items=new ArrayList<CollectionItem>(setContainer.getCollection());
  iterator=items.iterator();
}","@Override public boolean open(NodeEngine nodeEngine){
  NodeEngineImpl nei=(NodeEngineImpl)nodeEngine;
  ss=nei.getSerializationService();
  Address thisAddress=nei.getThisAddress();
  PartitionService ps=nei.getPartitionService();
  Data data=ss.toData(setName,StringAndPartitionAwarePartitioningStrategy.INSTANCE);
  int partitionId=ps.getPartitionId(data);
  Address partitionOwner=ps.getPartitionOwner(partitionId);
  if (partitionOwner == null) {
    return false;
  }
  if (thisAddress.equals(partitionOwner)) {
    SetService setService=nei.getService(SetService.SERVICE_NAME);
    SetContainer setContainer=setService.getOrCreateContainer(setName,false);
    List<CollectionItem> items=new ArrayList<CollectionItem>(setContainer.getCollection());
    iterator=items.iterator();
  }
  return true;
}",0.8776595744680851
48518,"@Override public void open(NodeEngine nodeEngine){
  keyValueSource.open(nodeEngine);
}","@Override public boolean open(NodeEngine nodeEngine){
  return keyValueSource.open(nodeEngine);
}",0.9130434782608696
48519,"@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    delegate.open(nodeEngine);
    DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
    processMapping(result.getPartitionId(),context,delegate);
    delegate.close();
    finalizeMapping(result.getPartitionId(),context);
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
    if (t instanceof Error) {
      ExceptionUtil.sneakyThrow(t);
    }
  }
}","@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    int partitionId=result.getPartitionId();
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    if (delegate.open(nodeEngine)) {
      DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
      processMapping(partitionId,context,delegate);
      delegate.close();
      finalizeMapping(partitionId,context);
    }
 else {
      postponePartitionProcessing(partitionId);
    }
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
    if (t instanceof Error) {
      ExceptionUtil.sneakyThrow(t);
    }
  }
}",0.8428223844282239
48520,"@Override public void open(NodeEngine nodeEngine){
  entries=new ArrayList<Map.Entry<String,Integer>>();
  for (int i=0; i < 1000; i++) {
    entries.add(new AbstractMap.SimpleEntry<String,Integer>(String.valueOf(i),i));
  }
  iterator=entries.iterator();
}","@Override public boolean open(NodeEngine nodeEngine){
  entries=new ArrayList<Map.Entry<String,Integer>>();
  for (int i=0; i < 1000; i++) {
    entries.add(new AbstractMap.SimpleEntry<String,Integer>(String.valueOf(i),i));
  }
  iterator=entries.iterator();
  return true;
}",0.9511278195488722
48521,"public Collection<V> remove(Object key){
  int threadId=(int)Thread.currentThread().getId();
  TxnMultiMapRemoveRequest request=new TxnMultiMapRemoveRequest(getName(),toData(key),threadId);
  PortableCollection portableCollection=invoke(request);
  final Collection<Data> collection=portableCollection.getCollection();
  Collection<V> coll;
  if (collection instanceof List) {
    coll=new ArrayList<V>(collection.size());
  }
 else {
    coll=new HashSet<V>(collection.size());
  }
  for (  Data data : collection) {
    coll.add((V)toObject(data));
  }
  return coll;
}","public Collection<V> remove(Object key){
  throwExceptionIfNull(key);
  int threadId=(int)Thread.currentThread().getId();
  TxnMultiMapRemoveAllRequest request=new TxnMultiMapRemoveAllRequest(getName(),toData(key),threadId);
  PortableCollection portableCollection=invoke(request);
  final Collection<Data> collection=portableCollection.getCollection();
  Collection<V> coll;
  if (collection instanceof List) {
    coll=new ArrayList<V>(collection.size());
  }
 else {
    coll=new HashSet<V>(collection.size());
  }
  for (  Data data : collection) {
    coll.add((V)toObject(data));
  }
  return coll;
}",0.9702633814783348
48522,"public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[TXN_MM_SIZE + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsEntryRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}","public PortableFactory createFactory(){
  ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[TXN_MM_REMOVEALL + 1];
  constructors[CLEAR]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ClearRequest();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ContainsEntryRequest();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new CountRequest();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new EntrySetRequest();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new GetAllRequest();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new KeySetRequest();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PutRequest();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveAllRequest();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new RemoveRequest();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new SizeRequest();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new ValuesRequest();
    }
  }
;
  constructors[ADD_ENTRY_LISTENER]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new AddEntryListenerRequest();
    }
  }
;
  constructors[ENTRY_SET_RESPONSE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new PortableEntrySetResponse();
    }
  }
;
  constructors[LOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapLockRequest();
    }
  }
;
  constructors[UNLOCK]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapUnlockRequest();
    }
  }
;
  constructors[IS_LOCKED]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new MultiMapIsLockedRequest();
    }
  }
;
  constructors[TXN_MM_PUT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapPutRequest();
    }
  }
;
  constructors[TXN_MM_GET]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapGetRequest();
    }
  }
;
  constructors[TXN_MM_REMOVE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveRequest();
    }
  }
;
  constructors[TXN_MM_VALUE_COUNT]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapValueCountRequest();
    }
  }
;
  constructors[TXN_MM_SIZE]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapSizeRequest();
    }
  }
;
  constructors[TXN_MM_REMOVEALL]=new ConstructorFunction<Integer,Portable>(){
    public Portable createNew(    Integer arg){
      return new TxnMultiMapRemoveAllRequest();
    }
  }
;
  return new ArrayPortableFactory(constructors);
}",0.9715768981181052
48523,"public Portable createNew(Integer arg){
  return new TxnMultiMapSizeRequest();
}","public Portable createNew(Integer arg){
  return new TxnMultiMapRemoveAllRequest();
}",0.9333333333333332
48524,"public int getClassId(){
  return MultiMapPortableHook.TXN_MM_GET;
}","public int getClassId(){
  return MultiMapPortableHook.TXN_MM_REMOVE;
}",0.9496402877697842
48525,"public Object innerCall() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMultiMap<Object,Object> multiMap=context.getMultiMap(name);
  if (value == null) {
    final Collection<Object> objects=multiMap.remove(key);
    Collection<Data> coll=createCollection(objects.size());
    for (    Object object : objects) {
      final Data data=toData(object);
      coll.add(data);
    }
    return new PortableCollection(coll);
  }
 else {
    return multiMap.remove(key,value);
  }
}","public Object innerCall() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMultiMap<Object,Object> multiMap=context.getMultiMap(name);
  return multiMap.remove(key,value);
}",0.6079182630906769
48526,"public boolean isIndexed(QueryContext queryContext){
  if (predicate instanceof IndexAwarePredicate) {
    return ((IndexAwarePredicate)predicate).isIndexed(queryContext);
  }
  return false;
}","@Override public boolean isIndexed(QueryContext queryContext){
  if (predicate instanceof IndexAwarePredicate) {
    return ((IndexAwarePredicate)predicate).isIndexed(queryContext);
  }
  return false;
}",0.9747474747474748
48527,"public void readData(ObjectDataInput in) throws IOException {
  sql=in.readUTF();
  predicate=createPredicate(sql);
}","@Override public void readData(ObjectDataInput in) throws IOException {
  sql=in.readUTF();
  predicate=createPredicate(sql);
}",0.9590163934426228
48528,"public boolean apply(Map.Entry mapEntry){
  return predicate.apply(mapEntry);
}","@Override public boolean apply(Map.Entry mapEntry){
  return predicate.apply(mapEntry);
}",0.9404761904761904
48529,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeUTF(sql);
}","@Override public void writeData(ObjectDataOutput out) throws IOException {
  out.writeUTF(sql);
}",0.9456521739130436
48530,"public Set<QueryableEntry> filter(QueryContext queryContext){
  return ((IndexAwarePredicate)predicate).filter(queryContext);
}","@Override public Set<QueryableEntry> filter(QueryContext queryContext){
  return ((IndexAwarePredicate)predicate).filter(queryContext);
}",0.9621212121212122
48531,"private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null)   return getter;
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      getterCache.putIfAbsent(cacheKey,getter);
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}","private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null) {
    return getter;
  }
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      Getter foundGetter=getterCache.putIfAbsent(cacheKey,getter);
      if (foundGetter != null) {
        getter=foundGetter;
      }
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}",0.9761816151842204
48532,"public void init(NodeEngine nodeEngine,CollectionService service){
  this.nodeEngine=nodeEngine;
  this.service=service;
}","public void init(NodeEngine nodeEngine){
  this.nodeEngine=nodeEngine;
}",0.7422680412371134
48533,"protected CollectionContainer(String name,NodeEngine nodeEngine,CollectionService service){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.service=service;
  logger=nodeEngine.getLogger(getClass());
}","protected CollectionContainer(String name,NodeEngine nodeEngine){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.logger=nodeEngine.getLogger(getClass());
}",0.8787061994609164
48534,"@Override public void run() throws Exception {
  CollectionService service=getService();
  for (  Map.Entry<String,CollectionContainer> entry : migrationData.entrySet()) {
    String name=entry.getKey();
    CollectionContainer container=entry.getValue();
    container.init(getNodeEngine(),service);
    service.addContainer(name,container);
  }
}","@Override public void run() throws Exception {
  CollectionService service=getService();
  for (  Map.Entry<String,CollectionContainer> entry : migrationData.entrySet()) {
    String name=entry.getKey();
    CollectionContainer container=entry.getValue();
    container.init(getNodeEngine());
    service.addContainer(name,container);
  }
}",0.8953488372093024
48535,"public ListContainer(String name,NodeEngine nodeEngine,CollectionService service){
  super(name,nodeEngine,service);
}","public ListContainer(String name,NodeEngine nodeEngine){
  super(name,nodeEngine);
}",0.8316831683168316
48536,"@Override public ListContainer getOrCreateContainer(String name,boolean backup){
  ListContainer container=containerMap.get(name);
  if (container == null) {
    container=new ListContainer(name,nodeEngine,this);
    final ListContainer current=containerMap.putIfAbsent(name,container);
    if (current != null) {
      container=current;
    }
  }
  return container;
}","@Override public ListContainer getOrCreateContainer(String name,boolean backup){
  ListContainer container=containerMap.get(name);
  if (container == null) {
    container=new ListContainer(name,nodeEngine);
    final ListContainer current=containerMap.putIfAbsent(name,container);
    if (current != null) {
      container=current;
    }
  }
  return container;
}",0.9931972789115646
48537,"public SetContainer(String name,NodeEngine nodeEngine,CollectionService service){
  super(name,nodeEngine,service);
}","public SetContainer(String name,NodeEngine nodeEngine){
  super(name,nodeEngine);
}",0.83
48538,"@Override public SetContainer getOrCreateContainer(String name,boolean backup){
  SetContainer container=containerMap.get(name);
  if (container == null) {
    container=new SetContainer(name,nodeEngine,this);
    final SetContainer current=containerMap.putIfAbsent(name,container);
    if (current != null) {
      container=current;
    }
  }
  return container;
}","@Override public SetContainer getOrCreateContainer(String name,boolean backup){
  SetContainer container=containerMap.get(name);
  if (container == null) {
    container=new SetContainer(name,nodeEngine);
    final SetContainer current=containerMap.putIfAbsent(name,container);
    if (current != null) {
      container=current;
    }
  }
  return container;
}",0.9931224209078404
48539,"public void run() throws Exception {
  MultiMapWrapper wrapper=getOrCreateContainer().getMultiMapWrapper(dataKey);
  Collection coll=null;
  if (wrapper != null) {
    wrapper.incrementHit();
    coll=wrapper.getCollection();
  }
  begin=Clock.currentTimeMillis();
  response=new MultiMapResponse(coll);
}","public void run() throws Exception {
  MultiMapWrapper wrapper=getOrCreateContainer().getMultiMapWrapper(dataKey);
  Collection coll=null;
  if (wrapper != null) {
    wrapper.incrementHit();
    coll=wrapper.getCollection();
  }
  response=new MultiMapResponse(coll);
}",0.9391304347826088
48540,"public void run() throws Exception {
  begin=Clock.currentTimeMillis();
  MultiMapContainer container=getOrCreateContainer();
  recordId=container.nextId();
  MultiMapRecord record=new MultiMapRecord(recordId,isBinary() ? value : toObject(value));
  Collection<MultiMapRecord> coll=container.getOrCreateMultiMapWrapper(dataKey).getCollection();
  if (index == -1) {
    response=coll.add(record);
  }
 else {
    try {
      ((List<MultiMapRecord>)coll).add(index,record);
      response=true;
    }
 catch (    IndexOutOfBoundsException e) {
      response=e;
    }
  }
}","public void run() throws Exception {
  MultiMapContainer container=getOrCreateContainer();
  recordId=container.nextId();
  MultiMapRecord record=new MultiMapRecord(recordId,isBinary() ? value : toObject(value));
  Collection<MultiMapRecord> coll=container.getOrCreateMultiMapWrapper(dataKey).getCollection();
  if (index == -1) {
    response=coll.add(record);
  }
 else {
    try {
      ((List<MultiMapRecord>)coll).add(index,record);
      response=true;
    }
 catch (    IndexOutOfBoundsException e) {
      response=e;
    }
  }
}",0.9684400360685302
48541,"public void run() throws Exception {
  begin=Clock.currentTimeMillis();
  coll=remove();
  response=new MultiMapResponse(coll);
}","public void run() throws Exception {
  coll=remove();
  response=new MultiMapResponse(coll);
}",0.8430493273542601
48542,"public void run() throws Exception {
  begin=Clock.currentTimeMillis();
  response=false;
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null) {
    return;
  }
  Collection<MultiMapRecord> coll=wrapper.getCollection();
  MultiMapRecord record=new MultiMapRecord(isBinary() ? value : toObject(value));
  Iterator<MultiMapRecord> iter=coll.iterator();
  while (iter.hasNext()) {
    MultiMapRecord r=iter.next();
    if (r.equals(record)) {
      iter.remove();
      recordId=r.getRecordId();
      response=true;
      if (coll.isEmpty()) {
        remove();
      }
      break;
    }
  }
}","public void run() throws Exception {
  response=false;
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null) {
    return;
  }
  Collection<MultiMapRecord> coll=wrapper.getCollection();
  MultiMapRecord record=new MultiMapRecord(isBinary() ? value : toObject(value));
  Iterator<MultiMapRecord> iter=coll.iterator();
  while (iter.hasNext()) {
    MultiMapRecord r=iter.next();
    if (r.equals(record)) {
      iter.remove();
      recordId=r.getRecordId();
      response=true;
      if (coll.isEmpty()) {
        remove();
      }
      break;
    }
  }
}",0.9705634987384356
48543,"private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=map.get(name);
  if (t == null) {
    final Set<String> tNames=map.keySet();
    for (    final String pattern : tNames) {
      if (nameMatches(name,pattern)) {
        return map.get(pattern);
      }
    }
  }
  return t;
}","private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=map.get(name);
  if (t == null) {
    for (    Map.Entry<String,T> entry : map.entrySet()) {
      String pattern=entry.getKey();
      T value=entry.getValue();
      if (nameMatches(name,pattern)) {
        return value;
      }
    }
  }
  return t;
}",0.6878980891719745
48544,"private void handleLoginModules(final Node node,final BeanDefinitionBuilder securityConfigBuilder,boolean member){
  final String name=(member ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"";
  final List lms=new ManagedList();
  for (  org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(child.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleLoginModule(child,lms);
    }
  }
  if (member) {
    securityConfigBuilder.addPropertyValue(""String_Node_Str"",lms);
  }
 else {
    securityConfigBuilder.addPropertyValue(""String_Node_Str"",lms);
  }
}","private void handleLoginModules(final Node node,final BeanDefinitionBuilder securityConfigBuilder,boolean member){
  final List lms=new ManagedList();
  for (  org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(child.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleLoginModule(child,lms);
    }
  }
  if (member) {
    securityConfigBuilder.addPropertyValue(""String_Node_Str"",lms);
  }
 else {
    securityConfigBuilder.addPropertyValue(""String_Node_Str"",lms);
  }
}",0.9246231155778896
48545,"public void storeAll(Map map){
  for (  Object key : map.keySet()) {
    store(key,map.get(key));
  }
}","public void storeAll(Map map){
  for (  Map.Entry entry : (Set<Map.Entry>)map.entrySet()) {
    Object key=entry.getKey();
    Object value=entry.getValue();
    store(key,value);
  }
}",0.5694444444444444
48546,"public Map loadAll(Collection keys){
  Map map=new HashMap();
  BasicDBList dbo=new BasicDBList();
  for (  Object key : keys) {
    dbo.add(new BasicDBObject(""String_Node_Str"",key));
  }
  BasicDBObject dbb=new BasicDBObject(""String_Node_Str"",dbo);
  DBCursor cursor=coll.find(dbb);
  while (cursor.hasNext()) {
    try {
      DBObject obj=cursor.next();
      Class clazz=null;
      clazz=Class.forName(obj.get(""String_Node_Str"").toString());
      map.put(obj.get(""String_Node_Str""),converter.toObject(clazz,obj));
    }
 catch (    ClassNotFoundException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  return map;
}","public Map loadAll(Collection keys){
  Map map=new HashMap();
  BasicDBList dbo=new BasicDBList();
  for (  Object key : keys) {
    dbo.add(new BasicDBObject(""String_Node_Str"",key));
  }
  BasicDBObject dbb=new BasicDBObject(""String_Node_Str"",dbo);
  DBCursor cursor=coll.find(dbb);
  while (cursor.hasNext()) {
    try {
      DBObject obj=cursor.next();
      Class clazz=Class.forName(obj.get(""String_Node_Str"").toString());
      map.put(obj.get(""String_Node_Str""),converter.toObject(clazz,obj));
    }
 catch (    ClassNotFoundException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  return map;
}",0.985759493670886
48547,"@Override public void dispatchEvent(MembershipEvent event,MembershipListener listener){
  if (event.getEventType() == MembershipEvent.MEMBER_ADDED) {
    listener.memberAdded(event);
  }
 else   if (event.getEventType() == MembershipEvent.MEMBER_REMOVED) {
    listener.memberRemoved(event);
  }
 else   if (event.getEventType() == MembershipEvent.MEMBER_ATTRIBUTE_CHANGED) {
    listener.memberAttributeChanged((MemberAttributeEvent)event);
  }
}","@Override public void dispatchEvent(MembershipEvent event,MembershipListener listener){
switch (event.getEventType()) {
case MembershipEvent.MEMBER_ADDED:
    listener.memberAdded(event);
  break;
case MembershipEvent.MEMBER_REMOVED:
listener.memberRemoved(event);
break;
case MembershipEvent.MEMBER_ATTRIBUTE_CHANGED:
listener.memberAttributeChanged((MemberAttributeEvent)event);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + event);
}
}",0.6739846322722283
48548,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  key=in.readUTF();
  int operation=in.readByte();
switch (operation) {
case DELTA_MEMBER_PROPERTIES_OP_PUT:
    operationType=MapOperationType.PUT;
  value=in.readObject();
break;
case DELTA_MEMBER_PROPERTIES_OP_REMOVE:
operationType=MapOperationType.REMOVE;
break;
}
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  key=in.readUTF();
  int operation=in.readByte();
switch (operation) {
case DELTA_MEMBER_PROPERTIES_OP_PUT:
    operationType=MapOperationType.PUT;
  value=in.readObject();
break;
case DELTA_MEMBER_PROPERTIES_OP_REMOVE:
operationType=MapOperationType.REMOVE;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + operationType);
}
}",0.9057971014492754
48549,"@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeUTF(key);
switch (operationType) {
case PUT:
    out.writeByte(DELTA_MEMBER_PROPERTIES_OP_PUT);
  out.writeObject(value);
break;
case REMOVE:
out.writeByte(DELTA_MEMBER_PROPERTIES_OP_REMOVE);
break;
}
}","@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeUTF(key);
switch (operationType) {
case PUT:
    out.writeByte(DELTA_MEMBER_PROPERTIES_OP_PUT);
  out.writeObject(value);
break;
case REMOVE:
out.writeByte(DELTA_MEMBER_PROPERTIES_OP_REMOVE);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + operationType);
}
}",0.8922651933701657
48550,"private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=map.get(name);
  if (t == null) {
    final Set<String> tNames=map.keySet();
    for (    final String pattern : tNames) {
      if (nameMatches(name,pattern)) {
        return map.get(pattern);
      }
    }
  }
  return t;
}","private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=map.get(name);
  if (t == null) {
    for (    Map.Entry<String,T> entry : map.entrySet()) {
      String pattern=entry.getKey();
      T value=entry.getValue();
      if (nameMatches(name,pattern)) {
        return value;
      }
    }
  }
  return t;
}",0.6878980891719745
48551,"/** 
 * Returns the membership event type; #MEMBER_ADDED or #MEMBER_REMOVED
 * @return the membership event type
 */
public int getEventType(){
  return eventType;
}","/** 
 * Returns the membership event type; #MEMBER_ADDED #MEMBER_REMOVED #MEMBER_ATTRIBUTE_CHANGED
 * @return the membership event type
 */
public int getEventType(){
  return eventType;
}",0.9178470254957508
48552,"@Override public String toString(){
  return ""String_Node_Str"" + member + ""String_Node_Str""+ ((eventType == MEMBER_ADDED) ? ""String_Node_Str"" : ""String_Node_Str"");
}","@Override public String toString(){
  String type;
switch (eventType) {
case MEMBER_ADDED:
    type=""String_Node_Str"";
  break;
case MEMBER_REMOVED:
type=""String_Node_Str"";
break;
case MEMBER_ATTRIBUTE_CHANGED:
type=""String_Node_Str"";
break;
default :
throw new IllegalStateException();
}
return format(""String_Node_Str"",member,type);
}",0.1796407185628742
48553,"public void start(){
  final Stats stats=new Stats();
  for (int i=0; i < threadCount; i++) {
    es.submit(new Runnable(){
      public void run(){
        Map<String,byte[]> map=hazelcast.getMap(""String_Node_Str"");
        while (running) {
          try {
            int key=(int)(Math.random() * entryCount);
            int operation=((int)(Math.random() * 100)) % 10;
            if (operation < 4) {
              map.put(String.valueOf(key),new byte[valueSize]);
              stats.mapPuts.incrementAndGet();
            }
 else             if (operation < 8) {
              map.get(String.valueOf(key));
              stats.mapGets.incrementAndGet();
            }
 else {
              map.remove(String.valueOf(key));
              stats.mapRemoves.incrementAndGet();
            }
          }
 catch (          HazelcastInstanceNotActiveException ignored) {
          }
catch (          Throwable e) {
            e.printStackTrace();
          }
        }
      }
    }
);
  }
  esStats.submit(new Runnable(){
    public void run(){
      final ILogger logger=hazelcast.getLoggingService().getLogger(hazelcast.getName());
      while (running) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          int clusterSize=hazelcast.getCluster().getMembers().size();
          Stats currentStats=stats.getAndReset();
          logger.info(""String_Node_Str"" + clusterSize + ""String_Node_Str""+ (currentStats.total() / STATS_SECONDS));
        }
 catch (        HazelcastInstanceNotActiveException ignored) {
        }
catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}","public void start(){
  final Stats stats=new Stats();
  for (int i=0; i < threadCount; i++) {
    es.submit(new Runnable(){
      public void run(){
        Random random=new Random();
        Map<String,byte[]> map=hazelcast.getMap(""String_Node_Str"");
        while (running) {
          try {
            int key=(int)(Math.random() * entryCount);
            int operation=random(10);
            if (operation < 4) {
              map.put(String.valueOf(key),new byte[valueSize]);
              stats.mapPuts.incrementAndGet();
            }
 else             if (operation < 8) {
              map.get(String.valueOf(key));
              stats.mapGets.incrementAndGet();
            }
 else {
              map.remove(String.valueOf(key));
              stats.mapRemoves.incrementAndGet();
            }
          }
 catch (          HazelcastInstanceNotActiveException ignored) {
          }
catch (          Throwable e) {
            e.printStackTrace();
          }
        }
      }
    }
);
  }
  esStats.submit(new Runnable(){
    public void run(){
      final ILogger logger=hazelcast.getLoggingService().getLogger(hazelcast.getName());
      while (running) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          int clusterSize=hazelcast.getCluster().getMembers().size();
          Stats currentStats=stats.getAndReset();
          logger.info(""String_Node_Str"" + clusterSize + ""String_Node_Str""+ (currentStats.total() / STATS_SECONDS));
        }
 catch (        HazelcastInstanceNotActiveException ignored) {
        }
catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}",0.977141115513563
48554,"public static void main(String[] args){
  int threadCount=40;
  final Stats stats=new Stats();
  final HazelcastInstance hazelcast=Hazelcast.newHazelcastInstance(null);
  ExecutorService es=Executors.newFixedThreadPool(threadCount);
  for (int i=0; i < threadCount; i++) {
    es.submit(new Runnable(){
      public void run(){
        IMap map=hazelcast.getMap(""String_Node_Str"");
        while (true) {
          int keyInt=(int)(Math.random() * ENTRY_COUNT);
          int operation=((int)(Math.random() * 1000)) % 20;
          Object key=String.valueOf(keyInt);
          if (operation < 1) {
            map.size();
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 2) {
            map.get(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 3) {
            map.remove(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 4) {
            map.containsKey(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 5) {
            Object value=new String(String.valueOf(key));
            map.containsValue(value);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 6) {
            map.putIfAbsent(key,createValue());
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 7) {
            Collection col=map.values();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 8) {
            Collection col=map.keySet();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 9) {
            Collection col=map.entrySet();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else {
            map.put(key,createValue());
            stats.increment(""String_Node_Str"");
          }
        }
      }
    }
);
  }
  Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          System.out.println(""String_Node_Str"" + hazelcast.getCluster().getMembers().size());
          Stats currentStats=stats.getAndReset();
          System.out.println(currentStats);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}","public static void main(String[] args){
  int threadCount=40;
  final Stats stats=new Stats();
  final HazelcastInstance hazelcast=Hazelcast.newHazelcastInstance(null);
  ExecutorService es=Executors.newFixedThreadPool(threadCount);
  for (int i=0; i < threadCount; i++) {
    es.submit(new Runnable(){
      public void run(){
        IMap map=hazelcast.getMap(""String_Node_Str"");
        while (true) {
          int keyInt=(int)(Math.random() * ENTRY_COUNT);
          int operation=((int)(Math.random() * 1000)) % 20;
          Object key=String.valueOf(keyInt);
          if (operation < 1) {
            map.size();
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 2) {
            map.get(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 3) {
            map.remove(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 4) {
            map.containsKey(key);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 5) {
            Object value=String.valueOf(key);
            map.containsValue(value);
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 6) {
            map.putIfAbsent(key,createValue());
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 7) {
            Collection col=map.values();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 8) {
            Collection col=map.keySet();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else           if (operation < 9) {
            Collection col=map.entrySet();
            for (            Object o : col) {
            }
            stats.increment(""String_Node_Str"");
          }
 else {
            map.put(key,createValue());
            stats.increment(""String_Node_Str"");
          }
        }
      }
    }
);
  }
  Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          System.out.println(""String_Node_Str"" + hazelcast.getCluster().getMembers().size());
          Stats currentStats=stats.getAndReset();
          System.out.println(currentStats);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}",0.9976825028968712
48555,"void set(HazelcastInstanceProxy proxy){
  this.hz=proxy;
synchronized (this) {
    notifyAll();
  }
}","void set(HazelcastInstanceProxy proxy){
synchronized (this) {
    this.hz=proxy;
    notifyAll();
  }
}",0.8235294117647058
48556,"public void setFailure(Throwable throwable){
  this.throwable=throwable;
synchronized (this) {
    notifyAll();
  }
}","public void setFailure(Throwable throwable){
synchronized (this) {
    this.throwable=throwable;
    notifyAll();
  }
}",0.8050847457627118
48557,"@Override public ReplicatedRecordStore createNew(String name){
  ReplicatedMapConfig replicatedMapConfig=getReplicatedMapConfig(name);
  InMemoryFormat inMemoryFormat=replicatedMapConfig.getInMemoryFormat();
  AbstractReplicatedRecordStore replicatedRecordStorage=null;
switch (inMemoryFormat) {
case OBJECT:
    replicatedRecordStorage=new ObjectReplicatedRecordStorage(name,nodeEngine,cleanerRegistrator,ReplicatedMapService.this);
  break;
case BINARY:
replicatedRecordStorage=new DataReplicatedRecordStore(name,nodeEngine,cleanerRegistrator,ReplicatedMapService.this);
break;
}
if (replicatedRecordStorage == null) {
throw new IllegalStateException(""String_Node_Str"");
}
return replicatedRecordStorage;
}","@Override public ReplicatedRecordStore createNew(String name){
  ReplicatedMapConfig replicatedMapConfig=getReplicatedMapConfig(name);
  InMemoryFormat inMemoryFormat=replicatedMapConfig.getInMemoryFormat();
  AbstractReplicatedRecordStore replicatedRecordStorage=null;
switch (inMemoryFormat) {
case OBJECT:
    replicatedRecordStorage=new ObjectReplicatedRecordStorage(name,nodeEngine,cleanerRegistrator,ReplicatedMapService.this);
  break;
case BINARY:
replicatedRecordStorage=new DataReplicatedRecordStore(name,nodeEngine,cleanerRegistrator,ReplicatedMapService.this);
break;
case OFFHEAP:
throw new IllegalStateException(""String_Node_Str"");
default :
throw new IllegalStateException(""String_Node_Str"" + inMemoryFormat);
}
return replicatedRecordStorage;
}",0.9100817438692098
48558,"public void init() throws IOException {
  out.write(Protocols.CLIENT_BINARY.getBytes());
  out.write(ClientTypes.JAVA.getBytes());
  out.flush();
}","public void init() throws IOException {
  out.write(stringToBytes(Protocols.CLIENT_BINARY));
  out.write(stringToBytes(ClientTypes.JAVA));
  out.flush();
}",0.8410596026490066
48559,"public static String calculateRFC2104HMAC(String data,String key) throws SignatureException {
  String result;
  try {
    SecretKeySpec signingKey=new SecretKeySpec(key.getBytes(),SIGNATURE_METHOD);
    Mac mac=Mac.getInstance(SIGNATURE_METHOD);
    mac.init(signingKey);
    byte[] rawSignature=mac.doFinal(data.getBytes());
    result=new String(encode(rawSignature));
    result=result.trim();
  }
 catch (  Exception e) {
    throw new SignatureException(""String_Node_Str"" + e.getMessage());
  }
  return result;
}","public static String calculateRFC2104HMAC(String data,String key) throws SignatureException {
  String result;
  try {
    SecretKeySpec signingKey=new SecretKeySpec(stringToBytes(key),SIGNATURE_METHOD);
    Mac mac=Mac.getInstance(SIGNATURE_METHOD);
    mac.init(signingKey);
    byte[] rawSignature=mac.doFinal(stringToBytes(data));
    result=bytesToString(encode(rawSignature));
    result=result.trim();
  }
 catch (  Exception e) {
    throw new SignatureException(""String_Node_Str"" + e.getMessage());
  }
  return result;
}",0.9437559580552908
48560,"@Override public String toString(){
  return ""String_Node_Str"" + new String(response.array()) + ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + bytesToString(response.array()) + ""String_Node_Str"";
}",0.9617021276595744
48561,"public ErrorCommand(TextCommandType type,String message){
  super(type);
  byte[] error=ERROR;
  if (type == TextCommandType.ERROR_CLIENT) {
    error=CLIENT_ERROR;
  }
 else   if (type == TextCommandType.ERROR_SERVER) {
    error=SERVER_ERROR;
  }
  this.message=message;
  byte[] msg=(message == null) ? null : message.getBytes();
  int total=error.length;
  if (msg != null) {
    total+=msg.length;
  }
  total+=2;
  response=ByteBuffer.allocate(total);
  response.put(error);
  if (msg != null) {
    response.put(msg);
  }
  response.put(RETURN);
  response.flip();
}","public ErrorCommand(TextCommandType type,String message){
  super(type);
  byte[] error=ERROR;
  if (type == TextCommandType.ERROR_CLIENT) {
    error=CLIENT_ERROR;
  }
 else   if (type == TextCommandType.ERROR_SERVER) {
    error=SERVER_ERROR;
  }
  this.message=message;
  byte[] msg=(message == null) ? null : stringToBytes(message);
  int total=error.length;
  if (msg != null) {
    total+=msg.length;
  }
  total+=2;
  response=ByteBuffer.allocate(total);
  response.put(error);
  if (msg != null) {
    response.put(msg);
  }
  response.put(RETURN);
  response.flip();
}",0.977391304347826
48562,"public void handle(GetCommand getCommand){
  String key=null;
  try {
    key=URLDecoder.decode(getCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else     if (value instanceof byte[]) {
      entry=new MemcacheEntry(getCommand.getKey(),((byte[])value),0);
    }
 else     if (value instanceof String) {
      entry=new MemcacheEntry(getCommand.getKey(),((String)value).getBytes(),0);
    }
 else {
      try {
        entry=new MemcacheEntry(getCommand.getKey(),textCommandService.toByteArray(value),0);
      }
 catch (      Exception e) {
        logger.warning(e);
      }
    }
  }
  if (entry != null) {
    textCommandService.incrementGetHitCount();
  }
 else {
    textCommandService.incrementGetMissCount();
  }
  getCommand.setValue(entry,single);
  textCommandService.sendResponse(getCommand);
}","public void handle(GetCommand getCommand){
  String key=null;
  try {
    key=URLDecoder.decode(getCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else     if (value instanceof byte[]) {
      entry=new MemcacheEntry(getCommand.getKey(),((byte[])value),0);
    }
 else     if (value instanceof String) {
      entry=new MemcacheEntry(getCommand.getKey(),stringToBytes((String)value),0);
    }
 else {
      try {
        entry=new MemcacheEntry(getCommand.getKey(),textCommandService.toByteArray(value),0);
      }
 catch (      Exception e) {
        logger.warning(e);
      }
    }
  }
  if (entry != null) {
    textCommandService.incrementGetHitCount();
  }
 else {
    textCommandService.incrementGetMissCount();
  }
  getCommand.setValue(entry,single);
  textCommandService.sendResponse(getCommand);
}",0.9903769045709704
48563,"public void handle(IncrementCommand incrementCommand){
  String key=null;
  try {
    key=URLDecoder.decode(incrementCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  try {
    textCommandService.lock(mapName,key);
  }
 catch (  Exception e) {
    incrementCommand.setResponse(NOT_FOUND);
    if (incrementCommand.shouldReply()) {
      textCommandService.sendResponse(incrementCommand);
    }
    return;
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else     if (value instanceof byte[]) {
      entry=new MemcacheEntry(incrementCommand.getKey(),(byte[])value,0);
    }
 else     if (value instanceof String) {
      entry=new MemcacheEntry(incrementCommand.getKey(),((String)value).getBytes(),0);
    }
 else {
      try {
        entry=new MemcacheEntry(incrementCommand.getKey(),textCommandService.toByteArray(value),0);
      }
 catch (      Exception e) {
        throw ExceptionUtil.rethrow(e);
      }
    }
    final byte[] value1=entry.getValue();
    final long current=(value1 == null || value1.length == 0) ? 0 : byteArrayToLong(value1);
    long result=-1;
    if (incrementCommand.getType() == TextCommandType.INCREMENT) {
      result=current + incrementCommand.getValue();
      result=0 > result ? Long.MAX_VALUE : result;
      textCommandService.incrementIncHitCount();
    }
 else     if (incrementCommand.getType() == TextCommandType.DECREMENT) {
      result=current - incrementCommand.getValue();
      result=0 > result ? 0 : result;
      textCommandService.incrementDecrHitCount();
    }
    incrementCommand.setResponse(ByteUtil.concatenate(String.valueOf(result).getBytes(),RETURN));
    MemcacheEntry newValue=new MemcacheEntry(key,longToByteArray(result),entry.getFlag());
    textCommandService.put(mapName,key,newValue);
  }
 else {
    if (incrementCommand.getType() == TextCommandType.INCREMENT)     textCommandService.incrementIncMissCount();
 else     textCommandService.incrementDecrMissCount();
    incrementCommand.setResponse(NOT_FOUND);
  }
  textCommandService.unlock(mapName,key);
  if (incrementCommand.shouldReply()) {
    textCommandService.sendResponse(incrementCommand);
  }
}","public void handle(IncrementCommand incrementCommand){
  String key=null;
  try {
    key=URLDecoder.decode(incrementCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  try {
    textCommandService.lock(mapName,key);
  }
 catch (  Exception e) {
    incrementCommand.setResponse(NOT_FOUND);
    if (incrementCommand.shouldReply()) {
      textCommandService.sendResponse(incrementCommand);
    }
    return;
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else     if (value instanceof byte[]) {
      entry=new MemcacheEntry(incrementCommand.getKey(),(byte[])value,0);
    }
 else     if (value instanceof String) {
      entry=new MemcacheEntry(incrementCommand.getKey(),stringToBytes((String)value),0);
    }
 else {
      try {
        entry=new MemcacheEntry(incrementCommand.getKey(),textCommandService.toByteArray(value),0);
      }
 catch (      Exception e) {
        throw ExceptionUtil.rethrow(e);
      }
    }
    final byte[] value1=entry.getValue();
    final long current=(value1 == null || value1.length == 0) ? 0 : byteArrayToLong(value1);
    long result=-1;
    if (incrementCommand.getType() == TextCommandType.INCREMENT) {
      result=current + incrementCommand.getValue();
      result=0 > result ? Long.MAX_VALUE : result;
      textCommandService.incrementIncHitCount();
    }
 else     if (incrementCommand.getType() == TextCommandType.DECREMENT) {
      result=current - incrementCommand.getValue();
      result=0 > result ? 0 : result;
      textCommandService.incrementDecrHitCount();
    }
    incrementCommand.setResponse(ByteUtil.concatenate(stringToBytes(String.valueOf(result)),RETURN));
    MemcacheEntry newValue=new MemcacheEntry(key,longToByteArray(result),entry.getFlag());
    textCommandService.put(mapName,key,newValue);
  }
 else {
    if (incrementCommand.getType() == TextCommandType.INCREMENT)     textCommandService.incrementIncMissCount();
 else     textCommandService.incrementDecrMissCount();
    incrementCommand.setResponse(NOT_FOUND);
  }
  textCommandService.unlock(mapName,key);
  if (incrementCommand.shouldReply()) {
    textCommandService.sendResponse(incrementCommand);
  }
}",0.9905025722200236
48564,"public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + new String(bytes) + ""String_Node_Str""+ flag+ '}';
}","public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + bytesToString(bytes) + ""String_Node_Str""+ flag+ '}';
}",0.9647058823529412
48565,"/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand setCommand){
  String key=null;
  try {
    key=URLDecoder.decode(setCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=new MemcacheEntry(setCommand.getKey(),setCommand.getValue(),setCommand.getFlag());
  int ttl=textCommandService.getAdjustedTTLSeconds(setCommand.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == setCommand.getType()) {
    textCommandService.put(mapName,key,value,ttl);
    setCommand.setResponse(STORED);
  }
 else   if (ADD == setCommand.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
  }
 else   if (REPLACE == setCommand.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
  }
 else   if (APPEND == setCommand.getType()) {
    try {
      textCommandService.lock(mapName,key);
    }
 catch (    Exception e) {
      setCommand.setResponse(NOT_STORED);
      if (setCommand.shouldReply()) {
        textCommandService.sendResponse(setCommand);
      }
      return;
    }
    Object oldValue=textCommandService.get(mapName,key);
    MemcacheEntry entry=null;
    if (oldValue != null) {
      if (oldValue instanceof MemcacheEntry) {
        final MemcacheEntry oldEntry=(MemcacheEntry)oldValue;
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(oldEntry.getValue(),setCommand.getValue()),0);
      }
 else       if (oldValue instanceof byte[]) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(((byte[])oldValue),setCommand.getValue()),0);
      }
 else       if (oldValue instanceof String) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(((String)oldValue).getBytes(),setCommand.getValue()),0);
      }
 else {
        try {
          entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(textCommandService.toByteArray(oldValue),setCommand.getValue()),0);
        }
 catch (        Exception e) {
          logger.warning(e);
        }
      }
      textCommandService.put(mapName,key,entry,ttl);
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
    textCommandService.unlock(mapName,key);
  }
 else   if (PREPEND == setCommand.getType()) {
    try {
      textCommandService.lock(mapName,key);
    }
 catch (    Exception e) {
      setCommand.setResponse(NOT_STORED);
      if (setCommand.shouldReply()) {
        textCommandService.sendResponse(setCommand);
      }
      return;
    }
    Object oldValue=textCommandService.get(mapName,key);
    MemcacheEntry entry=null;
    if (oldValue != null) {
      if (oldValue instanceof MemcacheEntry) {
        final MemcacheEntry oldEntry=(MemcacheEntry)oldValue;
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),oldEntry.getValue()),oldEntry.getFlag());
      }
 else       if (oldValue instanceof byte[]) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),((byte[])oldValue)),0);
      }
 else       if (oldValue instanceof String) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),((String)oldValue).getBytes()),0);
      }
 else {
        try {
          entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),textCommandService.toByteArray(oldValue)),0);
        }
 catch (        Exception e) {
          logger.warning(e);
        }
      }
      textCommandService.put(mapName,key,entry,ttl);
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
    textCommandService.unlock(mapName,key);
  }
  if (setCommand.shouldReply()) {
    textCommandService.sendResponse(setCommand);
  }
}","/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand setCommand){
  String key=null;
  try {
    key=URLDecoder.decode(setCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new HazelcastException(e);
  }
  String mapName=DefaultMapName;
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=MapNamePreceder + key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=new MemcacheEntry(setCommand.getKey(),setCommand.getValue(),setCommand.getFlag());
  int ttl=textCommandService.getAdjustedTTLSeconds(setCommand.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == setCommand.getType()) {
    textCommandService.put(mapName,key,value,ttl);
    setCommand.setResponse(STORED);
  }
 else   if (ADD == setCommand.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
  }
 else   if (REPLACE == setCommand.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
  }
 else   if (APPEND == setCommand.getType()) {
    try {
      textCommandService.lock(mapName,key);
    }
 catch (    Exception e) {
      setCommand.setResponse(NOT_STORED);
      if (setCommand.shouldReply()) {
        textCommandService.sendResponse(setCommand);
      }
      return;
    }
    Object oldValue=textCommandService.get(mapName,key);
    MemcacheEntry entry=null;
    if (oldValue != null) {
      if (oldValue instanceof MemcacheEntry) {
        final MemcacheEntry oldEntry=(MemcacheEntry)oldValue;
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(oldEntry.getValue(),setCommand.getValue()),0);
      }
 else       if (oldValue instanceof byte[]) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(((byte[])oldValue),setCommand.getValue()),0);
      }
 else       if (oldValue instanceof String) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(stringToBytes((String)oldValue),setCommand.getValue()),0);
      }
 else {
        try {
          entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(textCommandService.toByteArray(oldValue),setCommand.getValue()),0);
        }
 catch (        Exception e) {
          logger.warning(e);
        }
      }
      textCommandService.put(mapName,key,entry,ttl);
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
    textCommandService.unlock(mapName,key);
  }
 else   if (PREPEND == setCommand.getType()) {
    try {
      textCommandService.lock(mapName,key);
    }
 catch (    Exception e) {
      setCommand.setResponse(NOT_STORED);
      if (setCommand.shouldReply()) {
        textCommandService.sendResponse(setCommand);
      }
      return;
    }
    Object oldValue=textCommandService.get(mapName,key);
    MemcacheEntry entry=null;
    if (oldValue != null) {
      if (oldValue instanceof MemcacheEntry) {
        final MemcacheEntry oldEntry=(MemcacheEntry)oldValue;
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),oldEntry.getValue()),oldEntry.getFlag());
      }
 else       if (oldValue instanceof byte[]) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),((byte[])oldValue)),0);
      }
 else       if (oldValue instanceof String) {
        entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),stringToBytes((String)oldValue)),0);
      }
 else {
        try {
          entry=new MemcacheEntry(setCommand.getKey(),ByteUtil.concatenate(setCommand.getValue(),textCommandService.toByteArray(oldValue)),0);
        }
 catch (        Exception e) {
          logger.warning(e);
        }
      }
      textCommandService.put(mapName,key,entry,ttl);
      setCommand.setResponse(STORED);
    }
 else {
      setCommand.setResponse(NOT_STORED);
    }
    textCommandService.unlock(mapName,key);
  }
  if (setCommand.shouldReply()) {
    textCommandService.sendResponse(setCommand);
  }
}",0.9951199674664498
48566,"private void putInt(byte[] name,int value){
  response.put(STAT);
  response.put(name);
  response.put(String.valueOf(value).getBytes());
  response.put(RETURN);
}","private void putInt(byte[] name,int value){
  response.put(STAT);
  response.put(name);
  response.put(stringToBytes(String.valueOf(value)));
  response.put(RETURN);
}",0.9272727272727272
48567,"private void putLong(byte[] name,long value){
  response.put(STAT);
  response.put(name);
  response.put(String.valueOf(value).getBytes());
  response.put(RETURN);
}","private void putLong(byte[] name,long value){
  response.put(STAT);
  response.put(name);
  response.put(stringToBytes(String.valueOf(value)));
  response.put(RETURN);
}",0.9281437125748504
48568,"/** 
 * HTTP/1.0 200 OK Date: Fri, 31 Dec 1999 23:59:59 GMT Content-TextCommandType: text/html Content-Length: 1354
 * @param contentType
 * @param value
 */
public void setResponse(byte[] contentType,byte[] value){
  int valueSize=(value == null) ? 0 : value.length;
  byte[] len=String.valueOf(valueSize).getBytes();
  int size=RES_200.length;
  if (contentType != null) {
    size+=CONTENT_TYPE.length;
    size+=contentType.length;
    size+=RETURN.length;
  }
  size+=CONTENT_LENGTH.length;
  size+=len.length;
  size+=RETURN.length;
  size+=RETURN.length;
  size+=valueSize;
  size+=RETURN.length;
  this.response=ByteBuffer.allocate(size);
  response.put(RES_200);
  if (contentType != null) {
    response.put(CONTENT_TYPE);
    response.put(contentType);
    response.put(RETURN);
  }
  response.put(CONTENT_LENGTH);
  response.put(len);
  response.put(RETURN);
  response.put(RETURN);
  if (value != null) {
    response.put(value);
  }
  response.put(RETURN);
  response.flip();
}","/** 
 * HTTP/1.0 200 OK Date: Fri, 31 Dec 1999 23:59:59 GMT Content-TextCommandType: text/html Content-Length: 1354
 * @param contentType
 * @param value
 */
public void setResponse(byte[] contentType,byte[] value){
  int valueSize=(value == null) ? 0 : value.length;
  byte[] len=stringToBytes(String.valueOf(valueSize));
  int size=RES_200.length;
  if (contentType != null) {
    size+=CONTENT_TYPE.length;
    size+=contentType.length;
    size+=RETURN.length;
  }
  size+=CONTENT_LENGTH.length;
  size+=len.length;
  size+=RETURN.length;
  size+=RETURN.length;
  size+=valueSize;
  size+=RETURN.length;
  this.response=ByteBuffer.allocate(size);
  response.put(RES_200);
  if (contentType != null) {
    response.put(CONTENT_TYPE);
    response.put(contentType);
    response.put(RETURN);
  }
  response.put(CONTENT_LENGTH);
  response.put(len);
  response.put(RETURN);
  response.put(RETURN);
  if (value != null) {
    response.put(value);
  }
  response.put(RETURN);
  response.flip();
}",0.9879154078549848
48569,"public void handle(HttpDeleteCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    if (indexEnd == -1) {
      String mapName=uri.substring(URI_MAPS.length(),uri.length());
      textCommandService.deleteAll(mapName);
      command.send204();
    }
 else {
      String mapName=uri.substring(URI_MAPS.length(),indexEnd);
      String key=uri.substring(indexEnd + 1);
      Object value=textCommandService.delete(mapName,key);
      command.send204();
    }
  }
 else   if (uri.startsWith(URI_QUEUES)) {
    int indexEnd=uri.indexOf('/',URI_QUEUES.length());
    String queueName=uri.substring(URI_QUEUES.length(),indexEnd);
    String secondStr=(uri.length() > (indexEnd + 1)) ? uri.substring(indexEnd + 1) : null;
    int seconds=(secondStr == null) ? 0 : Integer.parseInt(secondStr);
    Object value=textCommandService.poll(queueName,seconds);
    if (value == null) {
      command.send204();
    }
 else {
      if (value instanceof byte[]) {
        command.setResponse(null,(byte[])value);
      }
 else       if (value instanceof RestValue) {
        RestValue restValue=(RestValue)value;
        command.setResponse(restValue.getContentType(),restValue.getValue());
      }
 else       if (value instanceof String) {
        command.setResponse(HttpCommand.CONTENT_TYPE_PLAIN_TEXT,((String)value).getBytes());
      }
 else {
        command.setResponse(null,textCommandService.toByteArray(value));
      }
    }
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}","public void handle(HttpDeleteCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    if (indexEnd == -1) {
      String mapName=uri.substring(URI_MAPS.length(),uri.length());
      textCommandService.deleteAll(mapName);
      command.send204();
    }
 else {
      String mapName=uri.substring(URI_MAPS.length(),indexEnd);
      String key=uri.substring(indexEnd + 1);
      Object value=textCommandService.delete(mapName,key);
      command.send204();
    }
  }
 else   if (uri.startsWith(URI_QUEUES)) {
    int indexEnd=uri.indexOf('/',URI_QUEUES.length());
    String queueName=uri.substring(URI_QUEUES.length(),indexEnd);
    String secondStr=(uri.length() > (indexEnd + 1)) ? uri.substring(indexEnd + 1) : null;
    int seconds=(secondStr == null) ? 0 : Integer.parseInt(secondStr);
    Object value=textCommandService.poll(queueName,seconds);
    if (value == null) {
      command.send204();
    }
 else {
      if (value instanceof byte[]) {
        command.setResponse(null,(byte[])value);
      }
 else       if (value instanceof RestValue) {
        RestValue restValue=(RestValue)value;
        command.setResponse(restValue.getContentType(),restValue.getValue());
      }
 else       if (value instanceof String) {
        command.setResponse(HttpCommand.CONTENT_TYPE_PLAIN_TEXT,stringToBytes((String)value));
      }
 else {
        command.setResponse(null,textCommandService.toByteArray(value));
      }
    }
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}",0.9874450721908348
48570,"@Override public PortableFactory createFactory(){
  return new PortableFactory(){
    final ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[LENGTH];
{
      constructors[CLIENT_JOB_PROCESS_INFO_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientJobProcessInformationRequest();
        }
      }
;
      constructors[CLIENT_CANCELLATION_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientCancellationRequest();
        }
      }
;
      constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientMapReduceRequest();
        }
      }
;
      constructors[TRANSFERABLE_PROCESS_INFORMATION]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new TransferableJobProcessInformation();
        }
      }
;
    }
    public Portable create(    int classId){
      return (classId > 0 && classId <= constructors.length) ? constructors[classId].createNew(classId) : null;
    }
  }
;
}","@Override public PortableFactory createFactory(){
  return new PortableFactory(){
    private final ConstructorFunction<Integer,Portable> constructors[]=new ConstructorFunction[LENGTH];
{
      constructors[CLIENT_JOB_PROCESS_INFO_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientJobProcessInformationRequest();
        }
      }
;
      constructors[CLIENT_CANCELLATION_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientCancellationRequest();
        }
      }
;
      constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new ClientMapReduceRequest();
        }
      }
;
      constructors[TRANSFERABLE_PROCESS_INFORMATION]=new ConstructorFunction<Integer,Portable>(){
        @Override public Portable createNew(        Integer arg){
          return new TransferableJobProcessInformation();
        }
      }
;
    }
    public Portable create(    int classId){
      return (classId > 0 && classId <= constructors.length) ? constructors[classId].createNew(classId) : null;
    }
  }
;
}",0.9969159599074788
48571,"public boolean registerJobSupervisorCancellation(String name,String jobId,Address jobOwner){
  NodeJobTracker jobTracker=(NodeJobTracker)createDistributedObject(name);
  if (jobTracker != null) {
    if (jobTracker.registerJobSupervisorCancellation(jobId) && getLocalAddress().equals(jobOwner)) {
      for (      MemberImpl member : clusterService.getMemberList()) {
        if (!member.getAddress().equals(jobOwner)) {
          try {
            ProcessingOperation operation=new CancelJobSupervisorOperation(name,jobId,jobOwner);
            processRequest(member.getAddress(),operation,name);
          }
 catch (          Exception ignore) {
          }
        }
      }
      return true;
    }
  }
  return false;
}","public boolean registerJobSupervisorCancellation(String name,String jobId,Address jobOwner){
  NodeJobTracker jobTracker=(NodeJobTracker)createDistributedObject(name);
  if (jobTracker != null) {
    if (jobTracker.registerJobSupervisorCancellation(jobId) && getLocalAddress().equals(jobOwner)) {
      for (      MemberImpl member : clusterService.getMemberList()) {
        if (!member.getAddress().equals(jobOwner)) {
          try {
            ProcessingOperation operation=new CancelJobSupervisorOperation(name,jobId);
            processRequest(member.getAddress(),operation,name);
          }
 catch (          Exception ignore) {
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.993745656706046
48572,"public CancelJobSupervisorOperation(String name,String jobId,Address jobOwner){
  super(name,jobId);
}","public CancelJobSupervisorOperation(String name,String jobId){
  super(name,jobId);
}",0.9090909090909092
48573,"private void processReducerFinished0(ReducingFinishedNotification notification){
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  int partitionId=notification.getPartitionId();
  Address reducerAddress=notification.getAddress();
  if (checkPartitionReductionCompleted(partitionId,reducerAddress)) {
    try {
      RequestPartitionResult result=mapReduceService.processRequest(jobOwner,new RequestPartitionProcessed(name,jobId,partitionId,REDUCING),name);
      if (result.getResultState() != SUCCESSFUL) {
        throw new RuntimeException(""String_Node_Str"" + partitionId);
      }
    }
 catch (    Throwable t) {
      MapReduceUtil.notifyRemoteException(this,t);
    }
  }
}","private void processReducerFinished0(ReducingFinishedNotification notification){
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  int partitionId=notification.getPartitionId();
  Address reducerAddress=notification.getAddress();
  if (checkPartitionReductionCompleted(partitionId,reducerAddress)) {
    try {
      RequestPartitionResult result=mapReduceService.processRequest(jobOwner,new RequestPartitionProcessed(name,jobId,partitionId,REDUCING),name);
      if (result.getResultState() != SUCCESSFUL) {
        throw new RuntimeException(""String_Node_Str"" + partitionId);
      }
    }
 catch (    Throwable t) {
      MapReduceUtil.notifyRemoteException(this,t);
      if (t instanceof Error) {
        ExceptionUtil.sneakyThrow(t);
      }
    }
  }
}",0.948069241011984
48574,"@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    delegate.open(nodeEngine);
    DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
    processMapping(result.getPartitionId(),context,delegate);
    delegate.close();
    finalizeMapping(result.getPartitionId(),context);
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
  }
}","@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    delegate.open(nodeEngine);
    DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
    processMapping(result.getPartitionId(),context,delegate);
    delegate.close();
    finalizeMapping(result.getPartitionId(),context);
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
    if (t instanceof Error) {
      ExceptionUtil.sneakyThrow(t);
    }
  }
}",0.9617021276595744
48575,"@Override public void run(){
  try {
    ReducerChunk<Key,Chunk> reducerChunk;
    while ((reducerChunk=reducerQueue.poll()) != null) {
      if (cancelled.get()) {
        return;
      }
      reduceChunk(reducerChunk.chunk);
      processProcessedState(reducerChunk);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    active.compareAndSet(true,false);
  }
}","@Override public void run(){
  try {
    ReducerChunk<Key,Chunk> reducerChunk;
    while ((reducerChunk=reducerQueue.poll()) != null) {
      if (cancelled.get()) {
        return;
      }
      reduceChunk(reducerChunk.chunk);
      processProcessedState(reducerChunk);
    }
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
    if (t instanceof Error) {
      ExceptionUtil.sneakyThrow(t);
    }
  }
 finally {
    active.compareAndSet(true,false);
  }
}",0.745958429561201
48576,"@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  long deadline=timeout == 0L ? -1 : Clock.currentTimeMillis() + unit.toMillis(timeout);
  for (; ; ) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw e;
    }
    if (isDone()) {
      break;
    }
    long delta=deadline - Clock.currentTimeMillis();
    if (delta <= 0L) {
      throw new TimeoutException(""String_Node_Str"");
    }
  }
  return getResult();
}","@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  long deadline=timeout == 0L ? -1 : Clock.currentTimeMillis() + unit.toMillis(timeout);
  for (; ; ) {
    Thread.sleep(100);
    if (isDone()) {
      break;
    }
    long delta=deadline - Clock.currentTimeMillis();
    if (delta <= 0L) {
      throw new TimeoutException(""String_Node_Str"");
    }
  }
  return getResult();
}",0.6865116279069767
48577,"private void cancelRemoteOperations(Set<Address> addresses){
  String name=getConfiguration().getName();
  String jobId=getConfiguration().getJobId();
  for (  Address address : addresses) {
    try {
      CancelJobSupervisorOperation operation=new CancelJobSupervisorOperation(name,jobId,jobOwner);
      mapReduceService.processRequest(address,operation,name);
    }
 catch (    Exception ignore) {
    }
  }
}","private void cancelRemoteOperations(Set<Address> addresses){
  String name=getConfiguration().getName();
  String jobId=getConfiguration().getJobId();
  for (  Address address : addresses) {
    try {
      CancelJobSupervisorOperation operation=new CancelJobSupervisorOperation(name,jobId);
      mapReduceService.processRequest(address,operation,name);
    }
 catch (    Exception ignore) {
    }
  }
}",0.988984088127295
48578,"public Connection newConnection(Address address,Authenticator authenticator) throws IOException ;","public Connection newConnection(Address address,Authenticator authenticator,boolean ownerConnection) throws IOException ;",0.8899082568807339
48579,"public ConnectionImpl(Address address,SocketOptions options,SerializationService serializationService) throws IOException {
  final InetSocketAddress isa=address.getInetSocketAddress();
  SocketFactory socketFactory=options.getSocketFactory();
  if (socketFactory == null) {
    socketFactory=new DefaultSocketFactory();
  }
  final Socket socket=socketFactory.createSocket();
  try {
    socket.setKeepAlive(options.isKeepAlive());
    socket.setTcpNoDelay(options.isTcpNoDelay());
    socket.setReuseAddress(options.isReuseAddress());
    if (options.getLingerSeconds() > 0) {
      socket.setSoLinger(true,options.getLingerSeconds());
    }
    if (options.getTimeout() > 0) {
      socket.setSoTimeout(options.getTimeout());
    }
    int bufferSize=options.getBufferSize() * 1024;
    if (bufferSize < 0) {
      bufferSize=BUFFER_SIZE;
    }
    socket.setSendBufferSize(bufferSize);
    socket.setReceiveBufferSize(bufferSize);
    socket.connect(isa,3000);
    this.socket=socket;
    out=serializationService.createObjectDataOutputStream(new BufferedOutputStream(socket.getOutputStream(),bufferSize));
    in=serializationService.createObjectDataInputStream(new BufferedInputStream(socket.getInputStream(),bufferSize));
  }
 catch (  IOException e) {
    socket.close();
    throw e;
  }
}","public ConnectionImpl(Address address,SocketOptions options,SerializationService serializationService,boolean ownerConnection) throws IOException {
  final InetSocketAddress isa=address.getInetSocketAddress();
  SocketFactory socketFactory=options.getSocketFactory();
  if (socketFactory == null) {
    socketFactory=new DefaultSocketFactory();
  }
  final Socket socket=socketFactory.createSocket();
  try {
    socket.setKeepAlive(options.isKeepAlive());
    socket.setTcpNoDelay(options.isTcpNoDelay());
    socket.setReuseAddress(options.isReuseAddress());
    if (options.getLingerSeconds() > 0) {
      socket.setSoLinger(true,options.getLingerSeconds());
    }
    if (options.getTimeout() > 0 && !ownerConnection) {
      socket.setSoTimeout(options.getTimeout());
    }
    int bufferSize=options.getBufferSize() * 1024;
    if (bufferSize < 0) {
      bufferSize=BUFFER_SIZE;
    }
    socket.setSendBufferSize(bufferSize);
    socket.setReceiveBufferSize(bufferSize);
    socket.connect(isa,3000);
    this.socket=socket;
    out=serializationService.createObjectDataOutputStream(new BufferedOutputStream(socket.getOutputStream(),bufferSize));
    in=serializationService.createObjectDataInputStream(new BufferedInputStream(socket.getInputStream(),bufferSize));
  }
 catch (  IOException e) {
    socket.close();
    throw e;
  }
}",0.9833333333333332
48580,"public ObjectPool<ConnectionWrapper> createNew(final Address address){
  return new QueueBasedObjectPool<ConnectionWrapper>(poolSize,new Factory<ConnectionWrapper>(){
    public ConnectionWrapper create() throws IOException {
      return new ConnectionWrapper(newConnection(address,authenticator));
    }
  }
,new Destructor<ConnectionWrapper>(){
    public void destroy(    ConnectionWrapper connection){
      connection.close();
    }
  }
);
}","public ObjectPool<ConnectionWrapper> createNew(final Address address){
  return new QueueBasedObjectPool<ConnectionWrapper>(poolSize,new Factory<ConnectionWrapper>(){
    public ConnectionWrapper create() throws IOException {
      return new ConnectionWrapper(newConnection(address,authenticator,false));
    }
  }
,new Destructor<ConnectionWrapper>(){
    public void destroy(    ConnectionWrapper connection){
      connection.close();
    }
  }
);
}",0.9933333333333332
48581,"public Connection newConnection(Address address,Authenticator authenticator) throws IOException {
  checkLive();
  final ConnectionImpl connection=new ConnectionImpl(address,socketOptions,client.getSerializationService());
  if (socketInterceptor != null) {
    socketInterceptor.onConnect(connection.getSocket());
  }
  connection.init();
  authenticator.auth(connection);
  return connection;
}","public Connection newConnection(Address address,Authenticator authenticator,boolean ownerConnection) throws IOException {
  checkLive();
  final ConnectionImpl connection=new ConnectionImpl(address,socketOptions,client.getSerializationService(),ownerConnection);
  if (socketInterceptor != null) {
    socketInterceptor.onConnect(connection.getSocket());
  }
  connection.init();
  authenticator.auth(connection);
  return connection;
}",0.9519230769230768
48582,"public ConnectionWrapper create() throws IOException {
  return new ConnectionWrapper(newConnection(address,authenticator));
}","public ConnectionWrapper create() throws IOException {
  return new ConnectionWrapper(newConnection(address,authenticator,false));
}",0.9767441860465116
48583,"private Connection connectToOne(final Collection<InetSocketAddress> socketAddresses) throws Exception {
  final int connectionAttemptLimit=getClientConfig().getConnectionAttemptLimit();
  final ManagerAuthenticator authenticator=new ManagerAuthenticator();
  int attempt=0;
  Throwable lastError=null;
  while (true) {
    final long nextTry=Clock.currentTimeMillis() + getClientConfig().getConnectionAttemptPeriod();
    for (    InetSocketAddress isa : socketAddresses) {
      Address address=new Address(isa);
      try {
        final Connection connection=getConnectionManager().firstConnection(address,authenticator);
        active=true;
        fireConnectionEvent(false);
        return connection;
      }
 catch (      IOException e) {
        active=false;
        lastError=e;
        logger.finest(""String_Node_Str"",e);
      }
catch (      AuthenticationException e) {
        active=false;
        lastError=e;
        logger.warning(""String_Node_Str"" + address,e);
      }
    }
    if (attempt++ >= connectionAttemptLimit) {
      break;
    }
    final long remainingTime=nextTry - Clock.currentTimeMillis();
    logger.warning(String.format(""String_Node_Str"" + ""String_Node_Str"",Math.max(0,remainingTime),attempt,connectionAttemptLimit));
    if (remainingTime > 0) {
      try {
        Thread.sleep(remainingTime);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"",lastError);
}","private Connection connectToOne(final Collection<InetSocketAddress> socketAddresses) throws Exception {
  final int connectionAttemptLimit=getClientConfig().getConnectionAttemptLimit();
  final ManagerAuthenticator authenticator=new ManagerAuthenticator();
  int attempt=0;
  Throwable lastError=null;
  while (true) {
    final long nextTry=Clock.currentTimeMillis() + getClientConfig().getConnectionAttemptPeriod();
    for (    InetSocketAddress isa : socketAddresses) {
      Address address=new Address(isa);
      try {
        final Connection connection=getConnectionManager().newConnection(address,authenticator,true);
        active=true;
        fireConnectionEvent(false);
        return connection;
      }
 catch (      IOException e) {
        active=false;
        lastError=e;
        logger.finest(""String_Node_Str"",e);
      }
catch (      AuthenticationException e) {
        active=false;
        lastError=e;
        logger.warning(""String_Node_Str"" + address,e);
      }
    }
    if (attempt++ >= connectionAttemptLimit) {
      break;
    }
    final long remainingTime=nextTry - Clock.currentTimeMillis();
    logger.warning(String.format(""String_Node_Str"" + ""String_Node_Str"",Math.max(0,remainingTime),attempt,connectionAttemptLimit));
    if (remainingTime > 0) {
      try {
        Thread.sleep(remainingTime);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"",lastError);
}",0.9956243688993603
48584,"public final void processMapping(int partitionId,KeyValueSource<KeyIn,ValueIn> keyValueSource) throws Exception {
  DefaultContext<KeyOut,ValueOut> context=supervisor.createContext(this);
  context.setPartitionId(partitionId);
  if (mapper instanceof LifecycleMapper) {
    ((LifecycleMapper)mapper).initialize(context);
  }
  mappingPhase.executeMappingPhase(keyValueSource,mapper,context);
  if (mapper instanceof LifecycleMapper) {
    ((LifecycleMapper)mapper).finalized(context);
  }
  if (cancelled.get()) {
    return;
  }
  RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestPartitionReducing(name,jobId,partitionId),name);
  if (result.getResultState() == SUCCESSFUL) {
    if (supervisor.getConfiguration().getReducerFactory() != null) {
      Map<KeyOut,Chunk> chunkMap=context.finish();
      if (chunkMap.size() > 0) {
        sendLastChunkToAssignedReducers(partitionId,chunkMap);
      }
 else {
        result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestPartitionProcessed(name,jobId,partitionId,REDUCING),name);
        if (result.getResultState() != SUCCESSFUL) {
          throw new RuntimeException(""String_Node_Str"" + partitionId);
        }
      }
    }
  }
}","public final void processMapping(int partitionId,DefaultContext<KeyOut,ValueOut> context,KeyValueSource<KeyIn,ValueIn> keyValueSource) throws Exception {
  context.setPartitionId(partitionId);
  if (mapper instanceof LifecycleMapper) {
    ((LifecycleMapper)mapper).initialize(context);
  }
  mappingPhase.executeMappingPhase(keyValueSource,mapper,context);
  if (mapper instanceof LifecycleMapper) {
    ((LifecycleMapper)mapper).finalized(context);
  }
  if (cancelled.get()) {
    return;
  }
}",0.4937142857142857
48585,"@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    delegate.open(nodeEngine);
    processMapping(result.getPartitionId(),delegate);
    delegate.close();
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
  }
}","@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    KeyValueSource<KeyIn,ValueIn> delegate=keyValueSource;
    if (supervisor.getConfiguration().isCommunicateStats()) {
      delegate=new KeyValueSourceFacade<KeyIn,ValueIn>(keyValueSource,supervisor);
    }
    delegate.reset();
    delegate.open(nodeEngine);
    DefaultContext<KeyOut,ValueOut> context=supervisor.getOrCreateContext(MapCombineTask.this);
    processMapping(result.getPartitionId(),context,delegate);
    delegate.close();
    finalizeMapping(result.getPartitionId(),context);
  }
 catch (  Throwable t) {
    notifyRemoteException(supervisor,t);
  }
}",0.8593939393939394
48586,"@Test(timeout=60000) public void testMapperReducerChunked() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  JobCompletableFuture<Map<String,Integer>> future=job.chunkSize(10).mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  final TrackableJob trackableJob=tracker.getTrackableJob(future.getJobId());
  final JobProcessInformation processInformation=trackableJob.getJobProcessInformation();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 10000; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
  assertTrueEventually(new AssertTask(){
    @Override public void run(){
      assertEquals(10000,processInformation.getProcessedRecords());
    }
  }
);
}","@Test(timeout=60000) public void testMapperReducerChunked() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  final HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  final HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  final HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  assertTrueEventually(new AssertTask(){
    @Override public void run(){
      assertEquals(3,h1.getCluster().getMembers().size());
    }
  }
);
  final IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  JobCompletableFuture<Map<String,Integer>> future=job.chunkSize(10).mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  final TrackableJob trackableJob=tracker.getTrackableJob(future.getJobId());
  final JobProcessInformation processInformation=trackableJob.getJobProcessInformation();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 10000; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
  assertTrueEventually(new AssertTask(){
    @Override public void run(){
      if (processInformation.getProcessedRecords() < 10000) {
        System.err.println(processInformation.getProcessedRecords());
      }
      assertEquals(10000,processInformation.getProcessedRecords());
    }
  }
);
}",0.8943421949556919
48587,"@Override public void run(){
  assertEquals(10000,processInformation.getProcessedRecords());
}","@Override public void run(){
  if (processInformation.getProcessedRecords() < 10000) {
    System.err.println(processInformation.getProcessedRecords());
  }
  assertEquals(10000,processInformation.getProcessedRecords());
}",0.5949367088607594
48588,"public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  try {
    Map values=mapContainer.getStore().loadAll(keys.values());
    if (values == null || values.isEmpty()) {
      if (checkIfMapLoaded.decrementAndGet() == 0) {
        loaded.set(true);
      }
      return;
    }
    MapEntrySet entrySet=new MapEntrySet();
    for (    Data dataKey : keys.keySet()) {
      Object key=keys.get(dataKey);
      Object value=values.get(key);
      if (value != null) {
        Data dataValue=mapService.toData(value);
        entrySet.add(dataKey,dataValue);
      }
    }
    PutAllOperation operation=new PutAllOperation(name,entrySet,true);
    operation.setNodeEngine(nodeEngine);
    operation.setResponseHandler(new ResponseHandler(){
      @Override public void sendResponse(      Object obj){
        if (checkIfMapLoaded.decrementAndGet() == 0) {
          loaded.set(true);
        }
      }
      public boolean isLocal(){
        return true;
      }
    }
);
    operation.setPartitionId(partitionId);
    OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
    operation.setServiceName(MapService.SERVICE_NAME);
    nodeEngine.getOperationService().executeOperation(operation);
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + e.toString());
  }
}","public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  try {
    Map values=mapContainer.getStore().loadAll(keys.values());
    if (values == null || values.isEmpty()) {
      if (checkIfMapLoaded.decrementAndGet() == 0) {
        loaded.set(true);
      }
      return;
    }
    MapEntrySet entrySet=new MapEntrySet();
    for (    Data dataKey : keys.keySet()) {
      Object key=keys.get(dataKey);
      Object value=values.get(key);
      if (value != null) {
        Data dataValue=mapService.toData(value);
        entrySet.add(dataKey,dataValue);
      }
    }
    PutAllOperation operation=new PutAllOperation(name,entrySet,true);
    operation.setNodeEngine(nodeEngine);
    operation.setResponseHandler(new ResponseHandler(){
      @Override public void sendResponse(      Object obj){
        if (checkIfMapLoaded.decrementAndGet() == 0) {
          loaded.set(true);
        }
      }
      public boolean isLocal(){
        return true;
      }
    }
);
    operation.setPartitionId(partitionId);
    OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
    operation.setCallerUuid(nodeEngine.getLocalMember().getUuid());
    operation.setServiceName(MapService.SERVICE_NAME);
    nodeEngine.getOperationService().executeOperation(operation);
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + e.toString());
  }
}",0.9749447310243184
48589,"private void scheduleBackup(Operation op,Backup backup,int partitionId,int replicaIndex){
  final RemoteCallKey key=new RemoteCallKey(op.getCallerAddress(),op.getCallerUuid(),op.getCallId());
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + backup);
  }
  backupScheduler.schedule(500,key,new ScheduledBackup(backup,partitionId,replicaIndex));
}","private void scheduleBackup(Operation op,Backup backup,int partitionId,int replicaIndex){
  final RemoteCallKey key=new RemoteCallKey(op);
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + backup);
  }
  backupScheduler.schedule(500,key,new ScheduledBackup(backup,partitionId,replicaIndex));
}",0.9224011713030746
48590,"private RemoteCallKey(Address callerAddress,String callerUuid,long callId){
  this.callerAddress=callerAddress;
  this.callerUuid=callerUuid;
  this.callId=callId;
}","private RemoteCallKey(final Operation op){
  callerUuid=op.getCallerUuid();
  if (callerUuid == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + op);
  }
  callerAddress=op.getCallerAddress();
  if (callerAddress == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + op);
  }
  callId=op.getCallId();
}",0.1516966067864271
48591,"private RemoteCallKey beforeCallExecution(Operation op){
  RemoteCallKey callKey=null;
  if (op.getCallId() != 0 && op.returnsResponse()) {
    callKey=new RemoteCallKey(op.getCallerAddress(),op.getCallerUuid(),op.getCallId());
    RemoteCallKey current;
    if ((current=executingCalls.put(callKey,callKey)) != null) {
      logger.warning(""String_Node_Str"" + callKey + ""String_Node_Str""+ current+ ""String_Node_Str""+ op.getClass().getName());
    }
  }
  return callKey;
}","private RemoteCallKey beforeCallExecution(Operation op){
  RemoteCallKey callKey=null;
  if (op.getCallId() != 0 && op.returnsResponse()) {
    callKey=new RemoteCallKey(op);
    RemoteCallKey current;
    if ((current=executingCalls.put(callKey,callKey)) != null) {
      logger.warning(""String_Node_Str"" + callKey + ""String_Node_Str""+ current+ ""String_Node_Str""+ op.getClass().getName());
    }
  }
  return callKey;
}",0.9406494960806272
48592,"public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  try {
    Map values=mapContainer.getStore().loadAll(keys.values());
    if (values == null || values.isEmpty()) {
      if (checkIfMapLoaded.decrementAndGet() == 0) {
        loaded.set(true);
      }
      return;
    }
    MapEntrySet entrySet=new MapEntrySet();
    for (    Data dataKey : keys.keySet()) {
      Object key=keys.get(dataKey);
      Object value=values.get(key);
      if (value != null) {
        Data dataValue=mapService.toData(value);
        entrySet.add(dataKey,dataValue);
      }
    }
    PutAllOperation operation=new PutAllOperation(name,entrySet,true);
    operation.setNodeEngine(nodeEngine);
    operation.setResponseHandler(new ResponseHandler(){
      @Override public void sendResponse(      Object obj){
        if (checkIfMapLoaded.decrementAndGet() == 0) {
          loaded.set(true);
        }
      }
      public boolean isLocal(){
        return true;
      }
    }
);
    operation.setPartitionId(partitionId);
    OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
    operation.setServiceName(MapService.SERVICE_NAME);
    nodeEngine.getOperationService().executeOperation(operation);
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + e.toString());
  }
}","public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  try {
    Map values=mapContainer.getStore().loadAll(keys.values());
    if (values == null || values.isEmpty()) {
      if (checkIfMapLoaded.decrementAndGet() == 0) {
        loaded.set(true);
      }
      return;
    }
    MapEntrySet entrySet=new MapEntrySet();
    for (    Data dataKey : keys.keySet()) {
      Object key=keys.get(dataKey);
      Object value=values.get(key);
      if (value != null) {
        Data dataValue=mapService.toData(value);
        entrySet.add(dataKey,dataValue);
      }
    }
    PutAllOperation operation=new PutAllOperation(name,entrySet,true);
    operation.setNodeEngine(nodeEngine);
    operation.setResponseHandler(new ResponseHandler(){
      @Override public void sendResponse(      Object obj){
        if (checkIfMapLoaded.decrementAndGet() == 0) {
          loaded.set(true);
        }
      }
      public boolean isLocal(){
        return true;
      }
    }
);
    operation.setPartitionId(partitionId);
    OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
    operation.setCallerUuid(nodeEngine.getLocalMember().getUuid());
    operation.setServiceName(MapService.SERVICE_NAME);
    nodeEngine.getOperationService().executeOperation(operation);
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + e.toString());
  }
}",0.9749447310243184
48593,"private void scheduleBackup(Operation op,Backup backup,int partitionId,int replicaIndex){
  final RemoteCallKey key=new RemoteCallKey(op.getCallerAddress(),op.getCallerUuid(),op.getCallId());
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + backup);
  }
  backupScheduler.schedule(500,key,new ScheduledBackup(backup,partitionId,replicaIndex));
}","private void scheduleBackup(Operation op,Backup backup,int partitionId,int replicaIndex){
  final RemoteCallKey key=new RemoteCallKey(op);
  if (logger.isFinestEnabled()) {
    logger.finest(""String_Node_Str"" + backup);
  }
  backupScheduler.schedule(500,key,new ScheduledBackup(backup,partitionId,replicaIndex));
}",0.9224011713030746
48594,"private RemoteCallKey(Address callerAddress,String callerUuid,long callId){
  this.callerAddress=callerAddress;
  this.callerUuid=callerUuid;
  this.callId=callId;
}","private RemoteCallKey(final Operation op){
  callerUuid=op.getCallerUuid();
  if (callerUuid == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + op);
  }
  callerAddress=op.getCallerAddress();
  if (callerAddress == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + op);
  }
  callId=op.getCallId();
}",0.1516966067864271
48595,"private RemoteCallKey beforeCallExecution(Operation op){
  RemoteCallKey callKey=null;
  if (op.getCallId() != 0 && op.returnsResponse()) {
    callKey=new RemoteCallKey(op.getCallerAddress(),op.getCallerUuid(),op.getCallId());
    RemoteCallKey current;
    if ((current=executingCalls.put(callKey,callKey)) != null) {
      logger.warning(""String_Node_Str"" + callKey + ""String_Node_Str""+ current+ ""String_Node_Str""+ op.getClass().getName());
    }
  }
  return callKey;
}","private RemoteCallKey beforeCallExecution(Operation op){
  RemoteCallKey callKey=null;
  if (op.getCallId() != 0 && op.returnsResponse()) {
    callKey=new RemoteCallKey(op);
    RemoteCallKey current;
    if ((current=executingCalls.put(callKey,callKey)) != null) {
      logger.warning(""String_Node_Str"" + callKey + ""String_Node_Str""+ current+ ""String_Node_Str""+ op.getClass().getName());
    }
  }
  return callKey;
}",0.9406494960806272
48596,"public void initializeDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  registry.getProxy(name,true,true);
}","public void initializeDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  registry.createProxy(name,true,true);
}",0.988296488946684
48597,"DistributedObject destroyProxy(String name,boolean publishEvent){
  final DistributedObject proxy;
  if ((proxy=proxies.remove(name)) != null) {
    nodeEngine.eventService.executeEvent(new ProxyEventProcessor(DESTROYED,serviceName,proxy));
    if (publishEvent) {
      publish(new DistributedObjectEventPacket(DESTROYED,serviceName,name));
    }
    return proxy;
  }
  return null;
}","void destroyProxy(String name,boolean publishEvent){
  final DistributedObject proxy=proxies.remove(name);
  if (proxy != null) {
    nodeEngine.eventService.executeEvent(new ProxyEventProcessor(DESTROYED,serviceName,proxy));
    if (publishEvent) {
      publish(new DistributedObjectEventPacket(DESTROYED,serviceName,name));
    }
  }
}",0.6602209944751382
48598,"public void dispatchEvent(final DistributedObjectEventPacket eventPacket,Object ignore){
  final String serviceName=eventPacket.getServiceName();
  if (eventPacket.getEventType() == CREATED) {
    try {
      final ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
      if (!registry.contains(eventPacket.getName())) {
        registry.getProxy(eventPacket.getName(),false,true);
      }
    }
 catch (    HazelcastInstanceNotActiveException ignored) {
    }
  }
 else {
    final ProxyRegistry registry=registries.get(serviceName);
    if (registry != null) {
      registry.destroyProxy(eventPacket.getName(),false);
    }
  }
}","public void dispatchEvent(final DistributedObjectEventPacket eventPacket,Object ignore){
  final String serviceName=eventPacket.getServiceName();
  if (eventPacket.getEventType() == CREATED) {
    try {
      final ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
      if (!registry.contains(eventPacket.getName())) {
        registry.createProxy(eventPacket.getName(),false,true);
      }
    }
 catch (    HazelcastInstanceNotActiveException ignored) {
    }
  }
 else {
    final ProxyRegistry registry=registries.get(serviceName);
    if (registry != null) {
      registry.destroyProxy(eventPacket.getName(),false);
    }
  }
}",0.9934162399414777
48599,"public DistributedObject getDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  return registry.getProxy(name,true,true);
}","public DistributedObject getDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  return registry.getOrCreateProxy(name,true,true);
}",0.99
48600,"public void initializeDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  registry.getProxy(name,true,true);
}","public void initializeDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  registry.createProxy(name,true,true);
}",0.988296488946684
48601,"DistributedObject destroyProxy(String name,boolean publishEvent){
  final DistributedObject proxy;
  if ((proxy=proxies.remove(name)) != null) {
    nodeEngine.eventService.executeEvent(new ProxyEventProcessor(DESTROYED,serviceName,proxy));
    if (publishEvent) {
      publish(new DistributedObjectEventPacket(DESTROYED,serviceName,name));
    }
    return proxy;
  }
  return null;
}","void destroyProxy(String name,boolean publishEvent){
  final DistributedObject proxy=proxies.remove(name);
  if (proxy != null) {
    nodeEngine.eventService.executeEvent(new ProxyEventProcessor(DESTROYED,serviceName,proxy));
    if (publishEvent) {
      publish(new DistributedObjectEventPacket(DESTROYED,serviceName,name));
    }
  }
}",0.6602209944751382
48602,"public void dispatchEvent(final DistributedObjectEventPacket eventPacket,Object ignore){
  final String serviceName=eventPacket.getServiceName();
  if (eventPacket.getEventType() == CREATED) {
    try {
      final ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
      if (!registry.contains(eventPacket.getName())) {
        registry.getProxy(eventPacket.getName(),false,true);
      }
    }
 catch (    HazelcastInstanceNotActiveException ignored) {
    }
  }
 else {
    final ProxyRegistry registry=registries.get(serviceName);
    if (registry != null) {
      registry.destroyProxy(eventPacket.getName(),false);
    }
  }
}","public void dispatchEvent(final DistributedObjectEventPacket eventPacket,Object ignore){
  final String serviceName=eventPacket.getServiceName();
  if (eventPacket.getEventType() == CREATED) {
    try {
      final ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
      if (!registry.contains(eventPacket.getName())) {
        registry.createProxy(eventPacket.getName(),false,true);
      }
    }
 catch (    HazelcastInstanceNotActiveException ignored) {
    }
  }
 else {
    final ProxyRegistry registry=registries.get(serviceName);
    if (registry != null) {
      registry.destroyProxy(eventPacket.getName(),false);
    }
  }
}",0.9934162399414777
48603,"public DistributedObject getDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  return registry.getProxy(name,true,true);
}","public DistributedObject getDistributedObject(String serviceName,String name){
  if (serviceName == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ProxyRegistry registry=ConcurrencyUtil.getOrPutIfAbsent(registries,serviceName,registryConstructor);
  return registry.getOrCreateProxy(name,true,true);
}",0.99
48604,"public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,-1,versionedValue.version),versionedValue.version));
  return true;
}","public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,-1,versionedValue.version),versionedValue.version));
  return true;
}",0.8957617411225659
48605,"public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}","public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}",0.8902291917973462
48606,"public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8684546615581098
48607,"private VersionedValue lockAndGet(Data key,long timeout){
  final NodeEngine nodeEngine=getNodeEngine();
  TxnLockAndGetOperation operation=new TxnLockAndGetOperation(name,key,timeout,timeout);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(MapService.SERVICE_NAME,operation,partitionId).build();
    Future<VersionedValue> f=invocation.invoke();
    return f.get();
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","private VersionedValue lockAndGet(Data key,long timeout){
  VersionedValue versionedValue=valueMap.get(key);
  if (versionedValue != null) {
    return versionedValue;
  }
  final NodeEngine nodeEngine=getNodeEngine();
  TxnLockAndGetOperation operation=new TxnLockAndGetOperation(name,key,timeout,timeout);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(MapService.SERVICE_NAME,operation,partitionId).build();
    Future<VersionedValue> f=invocation.invoke();
    versionedValue=f.get();
    if (versionedValue == null) {
      throw new TransactionException(""String_Node_Str"");
    }
    valueMap.put(key,versionedValue);
    return versionedValue;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.8008021390374331
48608,"public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8647845468053492
48609,"public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8589147286821706
48610,"public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8894289185905225
48611,"@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final String map1=""String_Node_Str"";
  final String map2=""String_Node_Str"";
  final String key=""String_Node_Str"";
  boolean b=h1.executeTransaction(options,new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap1=context.getMap(map1);
      final TransactionalMap<Object,Object> txMap2=context.getMap(map2);
      txMap1.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap1.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap1.get(key));
      txMap2.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap2.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap2.get(key));
      assertEquals(true,txMap1.containsKey(key));
      assertEquals(true,txMap2.containsKey(key));
      assertNull(h2.getMap(map1).get(key));
      assertNull(h2.getMap(map2).get(key));
      return true;
    }
  }
);
  assertTrue(b);
  assertEquals(""String_Node_Str"",h1.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h1.getMap(map2).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map2).get(key));
}","@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final String map1=""String_Node_Str"";
  final String map2=""String_Node_Str"";
  final String key=""String_Node_Str"";
  boolean b=h1.executeTransaction(options,new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap1=context.getMap(map1);
      final TransactionalMap<Object,Object> txMap2=context.getMap(map2);
      txMap1.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap1.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap1.get(key));
      txMap2.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap2.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap2.get(key));
      assertEquals(true,txMap1.containsKey(key));
      assertEquals(true,txMap2.containsKey(key));
      assertNull(h2.getMap(map1).get(key));
      assertNull(h2.getMap(map2).get(key));
      return true;
    }
  }
);
  assertTrue(b);
  assertEquals(""String_Node_Str"",h1.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h1.getMap(map2).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map2).get(key));
  assertFalse(h1.getMap(map1).isLocked(key));
  assertFalse(h1.getMap(map2).isLocked(key));
}",0.9713038053649408
48612,"@Override protected <T>ICompletableFuture<T> invoke(final Collator collator){
  try {
    ClientContext context=getContext();
    ClientInvocationService cis=context.getInvocationService();
    ClientMapReduceRequest request=new ClientMapReduceRequest(name,jobId,keys,predicate,mapper,combinerFactory,reducerFactory,keyValueSource,chunkSize);
    final ClientCompletableFuture completableFuture=new ClientCompletableFuture(jobId);
    ClientCallFuture future=(ClientCallFuture)cis.invokeOnRandomTarget(request,new EventHandler(){
      @Override public void handle(      Object event){
        if (collator != null) {
          event=collator.collate(((Map)event).entrySet());
        }
        completableFuture.setResult(event);
        trackableJobs.remove(getJobId());
      }
    }
);
    Address runningMember=future.getConnection().getRemoteEndpoint();
    trackableJobs.putIfAbsent(jobId,new ClientTrackableJob<T>(jobId,runningMember,completableFuture));
    return completableFuture;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override protected <T>JobCompletableFuture<T> invoke(final Collator collator){
  try {
    final String jobId=UuidUtil.buildRandomUuidString();
    ClientContext context=getContext();
    ClientInvocationService cis=context.getInvocationService();
    ClientMapReduceRequest request=new ClientMapReduceRequest(name,jobId,keys,predicate,mapper,combinerFactory,reducerFactory,keyValueSource,chunkSize,topologyChangedStrategy);
    final ClientCompletableFuture completableFuture=new ClientCompletableFuture(jobId);
    ClientCallFuture future=(ClientCallFuture)cis.invokeOnRandomTarget(request,null);
    future.andThen(new ExecutionCallback(){
      @Override public void onResponse(      Object response){
        try {
          if (collator != null) {
            response=collator.collate(((Map)response).entrySet());
          }
        }
  finally {
          completableFuture.setResult(response);
          trackableJobs.remove(jobId);
        }
      }
      @Override public void onFailure(      Throwable t){
        try {
          if (t instanceof ExecutionException && t.getCause() instanceof CancellationException) {
            t=t.getCause();
          }
          completableFuture.setResult(t);
        }
  finally {
          trackableJobs.remove(jobId);
        }
      }
    }
);
    Address runningMember=future.getConnection().getRemoteEndpoint();
    trackableJobs.putIfAbsent(jobId,new ClientTrackableJob<T>(jobId,runningMember,completableFuture));
    return completableFuture;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.7708649468892261
48613,"@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  long deadline=timeout == 0L ? -1 : Clock.currentTimeMillis() + unit.toMillis(timeout);
  for (; ; ) {
    try {
      Thread.sleep(100);
    }
 catch (    Exception e) {
      if (e instanceof InterruptedException) {
        throw (InterruptedException)e;
      }
    }
    if (isDone()) {
      break;
    }
    long delta=deadline - Clock.currentTimeMillis();
    if (delta <= 0L) {
      throw new TimeoutException(""String_Node_Str"");
    }
  }
  return getResult();
}","@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  ValidationUtil.isNotNull(unit,""String_Node_Str"");
  long deadline=timeout == 0L ? -1 : Clock.currentTimeMillis() + unit.toMillis(timeout);
  for (; ; ) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw e;
    }
    if (isDone()) {
      break;
    }
    long delta=deadline - Clock.currentTimeMillis();
    if (delta <= 0L) {
      throw new TimeoutException(""String_Node_Str"");
    }
  }
  return getResult();
}",0.6852459016393443
48614,"@Test(timeout=30000) public void testMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
}","@Test(timeout=60000) public void testMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
}",0.9987819732034104
48615,"@Test(timeout=30000) public void testKeyedMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.onKeys(50).mapper(new TestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  assertEquals(50,result);
}","@Test(timeout=60000) public void testKeyedMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.onKeys(50).mapper(new TestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  assertEquals(50,result);
}",0.9987096774193548
48616,"@Test(timeout=30000) public void testAsyncMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,List<Integer>> listenerResults=new HashMap<String,List<Integer>>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TestMapper()).submit();
  future.andThen(new ExecutionCallback<Map<String,List<Integer>>>(){
    @Override public void onResponse(    Map<String,List<Integer>> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  semaphore.acquire();
  assertEquals(100,listenerResults.size());
  for (  List<Integer> value : listenerResults.values()) {
    assertEquals(1,value.size());
  }
}","@Test(timeout=60000) public void testAsyncMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,List<Integer>> listenerResults=new HashMap<String,List<Integer>>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TestMapper()).submit();
  future.andThen(new ExecutionCallback<Map<String,List<Integer>>>(){
    @Override public void onResponse(    Map<String,List<Integer>> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  semaphore.acquire();
  assertEquals(100,listenerResults.size());
  for (  List<Integer> value : listenerResults.values()) {
    assertEquals(1,value.size());
  }
}",0.9992458521870288
48617,"@Test(timeout=30000) public void testMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TestMapper()).submit();
  Map<String,List<Integer>> result=future.get();
  assertEquals(100,result.size());
  for (  List<Integer> value : result.values()) {
    assertEquals(1,value.size());
  }
}","@Test(timeout=60000) public void testMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TestMapper()).submit();
  Map<String,List<Integer>> result=future.get();
  assertEquals(100,result.size());
  for (  List<Integer> value : result.values()) {
    assertEquals(1,value.size());
  }
}",0.9988358556461
48618,"@Test(timeout=30000,expected=CancellationException.class) public void testInProcessCancellation() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TimeConsumingMapper()).submit();
  future.cancel(true);
  try {
    Map<String,List<Integer>> result=future.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","@Test(timeout=60000,expected=CancellationException.class) public void testInProcessCancellation() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new TimeConsumingMapper()).submit();
  future.cancel(true);
  try {
    Map<String,List<Integer>> result=future.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}",0.9944382647385984
48619,"@Test(timeout=30000) public void testKeyPredicateMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.keyPredicate(new TestKeyPredicate()).mapper(new TestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  assertEquals(50,result);
}","@Test(timeout=60000) public void testKeyPredicateMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.keyPredicate(new TestKeyPredicate()).mapper(new TestMapper()).submit(new GroupingTestCollator());
  int result=future.get();
  assertEquals(50,result);
}",0.9987623762376238
48620,"@Test(timeout=30000) public void testMapperReducer() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,Integer>> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 100; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
}","@Test(timeout=60000) public void testMapperReducer() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,Integer>> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 100; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
}",0.999003984063745
48621,"@Test(timeout=30000) public void testAsyncMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final int[] result=new int[1];
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).submit(new GroupingTestCollator());
  future.andThen(new ExecutionCallback<Integer>(){
    @Override public void onResponse(    Integer response){
      result[0]=response.intValue();
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result[0]);
  }
}","@Test(timeout=60000) public void testAsyncMapperCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final int[] result=new int[1];
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).submit(new GroupingTestCollator());
  future.andThen(new ExecutionCallback<Integer>(){
    @Override public void onResponse(    Integer response){
      result[0]=response.intValue();
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result[0]);
  }
}",0.999216914643696
48622,"@Test(timeout=30000) public void testAsyncMapperReducer() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,Integer> listenerResults=new HashMap<String,Integer>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,Integer>> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  future.andThen(new ExecutionCallback<Map<String,Integer>>(){
    @Override public void onResponse(    Map<String,Integer> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int[] expectedResults=new int[4];
  for (int i=0; i < 100; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)listenerResults.get(String.valueOf(i)));
  }
}","@Test(timeout=60000) public void testAsyncMapperReducer() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,Integer> listenerResults=new HashMap<String,Integer>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,Integer>> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  future.andThen(new ExecutionCallback<Map<String,Integer>>(){
    @Override public void onResponse(    Map<String,Integer> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int[] expectedResults=new int[4];
  for (int i=0; i < 100; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)listenerResults.get(String.valueOf(i)));
  }
}",0.9993074792243768
48623,"@Test(timeout=30000) public void testAsyncMapperReducerCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final int[] result=new int[1];
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit(new TestCollator());
  future.andThen(new ExecutionCallback<Integer>(){
    @Override public void onResponse(    Integer response){
      result[0]=response.intValue();
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result[0]);
  }
}","@Test(timeout=60000) public void testAsyncMapperReducerCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final int[] result=new int[1];
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit(new TestCollator());
  future.andThen(new ExecutionCallback<Integer>(){
    @Override public void onResponse(    Integer response){
      result[0]=response.intValue();
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  semaphore.acquire();
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result[0]);
  }
}",0.999236641221374
48624,"@Test(timeout=30000) public void testKeyedAsyncMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,List<Integer>> listenerResults=new HashMap<String,List<Integer>>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.onKeys(50).mapper(new TestMapper()).submit();
  future.andThen(new ExecutionCallback<Map<String,List<Integer>>>(){
    @Override public void onResponse(    Map<String,List<Integer>> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  semaphore.acquire();
  assertEquals(1,listenerResults.size());
  for (  List<Integer> value : listenerResults.values()) {
    assertEquals(1,value.size());
  }
}","@Test(timeout=60000) public void testKeyedAsyncMapper() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  final Map<String,List<Integer>> listenerResults=new HashMap<String,List<Integer>>();
  final Semaphore semaphore=new Semaphore(1);
  semaphore.acquire();
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.onKeys(50).mapper(new TestMapper()).submit();
  future.andThen(new ExecutionCallback<Map<String,List<Integer>>>(){
    @Override public void onResponse(    Map<String,List<Integer>> response){
      listenerResults.putAll(response);
      semaphore.release();
    }
    @Override public void onFailure(    Throwable t){
      semaphore.release();
    }
  }
);
  semaphore.acquire();
  assertEquals(1,listenerResults.size());
  for (  List<Integer> value : listenerResults.values()) {
    assertEquals(1,value.size());
  }
}",0.9992537313432835
48625,"@Test(timeout=30000,expected=NullPointerException.class) public void testExceptionDistribution() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new ExceptionThrowingMapper()).submit();
  try {
    Map<String,List<Integer>> result=future.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","@Test(timeout=60000,expected=ExecutionException.class) public void testExceptionDistribution() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Map<String,List<Integer>>> future=job.mapper(new ExceptionThrowingMapper()).submit();
  try {
    Map<String,List<Integer>> result=future.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
    assertTrue(e.getCause() instanceof NullPointerException);
    throw e;
  }
}",0.9493949394939494
48626,"@Test(timeout=30000) public void testMapperReducerCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit(new TestCollator());
  int result=future.get();
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result);
  }
}","@Test(timeout=60000) public void testMapperReducerCollator() throws Exception {
  Config config=buildConfig();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(null);
  IMap<Integer,Integer> m1=client.getMap(MAP_NAME);
  for (int i=0; i < 100; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=client.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> job=tracker.newJob(KeyValueSource.fromMap(m1));
  ICompletableFuture<Integer> future=job.mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit(new TestCollator());
  int result=future.get();
  int expectedResult=0;
  for (int i=0; i < 100; i++) {
    expectedResult+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResult,result);
  }
}",0.9989235737351992
48627,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_MAPPING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_REDUCING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionReducing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[GET_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[REDUCING_FINISHED_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducingFinishedNotification();
    }
  }
;
  constructors[FIRE_NOTIFICATION_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new FireNotificationOperation();
    }
  }
;
  constructors[REQUEST_MEMBERID_ASSIGNMENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestMemberIdAssignment();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9669546140134376
48628,"public MultiMapKeyValueSource(String multiMapName){
  this.simpleEntry=null;
  this.multiMapName=multiMapName;
}","public MultiMapKeyValueSource(String multiMapName){
  this.multiMapName=multiMapName;
}",0.8743718592964824
48629,"NodeJobTracker(String name,JobTrackerConfig jobTrackerConfig,NodeEngine nodeEngine,MapReduceService mapReduceService){
  super(name,jobTrackerConfig,nodeEngine,mapReduceService);
  ExecutionService es=nodeEngine.getExecutionService();
  PartitionService ps=nodeEngine.getPartitionService();
  int maxThreadSize=jobTrackerConfig.getMaxThreadSize();
  if (maxThreadSize <= 0) {
    maxThreadSize=Runtime.getRuntime().availableProcessors();
  }
  int retryCount=jobTrackerConfig.getRetryCount();
  int queueSize=jobTrackerConfig.getQueueSize();
  if (queueSize <= 0) {
    queueSize=ps.getPartitionCount() * 2;
  }
  es.register(name,maxThreadSize,queueSize);
}","NodeJobTracker(String name,JobTrackerConfig jobTrackerConfig,NodeEngine nodeEngine,MapReduceService mapReduceService){
  super(name,jobTrackerConfig,nodeEngine,mapReduceService);
  ExecutionService es=nodeEngine.getExecutionService();
  PartitionService ps=nodeEngine.getPartitionService();
  int maxThreadSize=jobTrackerConfig.getMaxThreadSize();
  if (maxThreadSize <= 0) {
    maxThreadSize=Runtime.getRuntime().availableProcessors();
  }
  int retryCount=jobTrackerConfig.getRetryCount();
  int queueSize=jobTrackerConfig.getQueueSize();
  if (queueSize <= 0) {
    queueSize=ps.getPartitionCount() * 2;
  }
  try {
    String executorName=MapReduceUtil.buildExecutorName(name);
    es.register(executorName,maxThreadSize,queueSize);
  }
 catch (  Exception ignore) {
  }
}",0.8989547038327527
48630,"public JobSupervisor(JobTaskConfiguration configuration,AbstractJobTracker jobTracker,boolean ownerNode,MapReduceService mapReduceService){
  this.jobTracker=jobTracker;
  this.ownerNode=ownerNode;
  this.configuration=configuration;
  this.mapReduceService=mapReduceService;
  this.jobOwner=configuration.getJobOwner();
  this.executorService=mapReduceService.getExecutorService(configuration.getName());
  this.jobProcessInformation=new JobProcessInformationImpl(configuration.getNodeEngine().getPartitionService().getPartitionCount(),this);
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  jobTracker.registerReducerTask(new ReducerTask(name,jobId,this));
}","public JobSupervisor(JobTaskConfiguration configuration,AbstractJobTracker jobTracker,boolean ownerNode,MapReduceService mapReduceService){
  this.jobTracker=jobTracker;
  this.ownerNode=ownerNode;
  this.configuration=configuration;
  this.mapReduceService=mapReduceService;
  this.jobOwner=configuration.getJobOwner();
  this.executorService=mapReduceService.getExecutorService(configuration.getName());
  NodeEngine nodeEngine=configuration.getNodeEngine();
  if (configuration.getKeyValueSource() instanceof PartitionIdAware) {
    int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
    this.jobProcessInformation=new JobProcessInformationImpl(partitionCount,this);
  }
 else {
    int partitionCount=nodeEngine.getClusterService().getMemberList().size();
    this.jobProcessInformation=new MemberAssigningJobProcessInformationImpl(partitionCount,this);
  }
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  jobTracker.registerReducerTask(new ReducerTask(name,jobId,this));
}",0.7485515643105446
48631,"public void process(){
  ExecutorService es=mapReduceService.getExecutorService(name);
  es.submit(new PartitionProcessor());
}","public void process(){
  ExecutorService es=mapReduceService.getExecutorService(name);
  if (keyValueSource instanceof PartitionIdAware) {
    es.submit(new PartitionProcessor());
  }
 else {
    es.submit(new SingleExecutionProcessor());
  }
}",0.6846361185983828
48632,"@Override public void run(){
  for (; ; ) {
    Integer partitionId=findNewPartitionProcessing();
    if (partitionId == null) {
      return;
    }
    if (partitionId == -1) {
      continue;
    }
    try {
      if (keyValueSource instanceof PartitionIdAware) {
        ((PartitionIdAware)keyValueSource).setPartitionId(partitionId);
      }
      keyValueSource.reset();
      keyValueSource.open(nodeEngine);
      processMapping(partitionId);
      keyValueSource.close();
    }
 catch (    IOException ignore) {
      ignore.printStackTrace();
    }
  }
}","@Override public void run(){
  try {
    RequestPartitionResult result=mapReduceService.processRequest(supervisor.getJobOwner(),new RequestMemberIdAssignment(name,jobId),name);
    if (result.getResultState() == NO_SUPERVISOR) {
      return;
    }
 else     if (result.getResultState() == NO_MORE_PARTITIONS) {
      return;
    }
    keyValueSource.reset();
    keyValueSource.open(nodeEngine);
    processMapping(result.getPartitionId());
    keyValueSource.close();
  }
 catch (  Exception ignore) {
    ignore.printStackTrace();
  }
}",0.4065335753176043
48633,"@Test public void testMapperReducerChunked() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> task=tracker.newJob(KeyValueSource.fromMap(m1));
  CompletableFuture<Map<String,Integer>> future=task.chunkSize(10).mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 10000; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
}","@Test(timeout=60000) public void testMapperReducerChunked() throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance();
  HazelcastInstance h2=nodeFactory.newHazelcastInstance();
  HazelcastInstance h3=nodeFactory.newHazelcastInstance();
  IMap<Integer,Integer> m1=h1.getMap(MAP_NAME);
  for (int i=0; i < 10000; i++) {
    m1.put(i,i);
  }
  JobTracker tracker=h1.getJobTracker(""String_Node_Str"");
  Job<Integer,Integer> task=tracker.newJob(KeyValueSource.fromMap(m1));
  CompletableFuture<Map<String,Integer>> future=task.chunkSize(10).mapper(new GroupingTestMapper()).reducer(new TestReducerFactory()).submit();
  Map<String,Integer> result=future.get();
  int[] expectedResults=new int[4];
  for (int i=0; i < 10000; i++) {
    int index=i % 4;
    expectedResults[index]+=i;
  }
  for (int i=0; i < 4; i++) {
    assertEquals(expectedResults[i],(int)result.get(String.valueOf(i)));
  }
}",0.9923508414074452
48634,"public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,versionedValue.version),versionedValue.version));
  return true;
}","public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,versionedValue.version),versionedValue.version));
  return true;
}",0.8660714285714286
48635,"public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}","public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}",0.8601398601398601
48636,"public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8362282878411911
48637,"private VersionedValue lockAndGet(Data key,long timeout){
  final NodeEngine nodeEngine=getNodeEngine();
  TxnLockAndGetOperation operation=new TxnLockAndGetOperation(name,key,timeout,timeout);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    Future<VersionedValue> f=nodeEngine.getOperationService().invokeOnPartition(MapService.SERVICE_NAME,operation,partitionId);
    return f.get();
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","private VersionedValue lockAndGet(Data key,long timeout){
  VersionedValue versionedValue=valueMap.get(key);
  if (versionedValue != null) {
    return versionedValue;
  }
  final NodeEngine nodeEngine=getNodeEngine();
  TxnLockAndGetOperation operation=new TxnLockAndGetOperation(name,key,timeout,timeout);
  operation.setThreadId(ThreadUtil.getThreadId());
  try {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    Future<VersionedValue> f=nodeEngine.getOperationService().invokeOnPartition(MapService.SERVICE_NAME,operation,partitionId);
    versionedValue=f.get();
    if (versionedValue == null) {
      throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
    }
    valueMap.put(key,versionedValue);
    return versionedValue;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.766928011404134
48638,"public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.3908045977011494
48639,"public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8219584569732937
48640,"public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + getService().toObject(key));
  }
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.8581560283687943
48641,"@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final String map1=""String_Node_Str"";
  final String map2=""String_Node_Str"";
  final String key=""String_Node_Str"";
  boolean b=h1.executeTransaction(options,new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap1=context.getMap(map1);
      final TransactionalMap<Object,Object> txMap2=context.getMap(map2);
      txMap1.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap1.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap1.get(key));
      txMap2.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap2.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap2.get(key));
      assertEquals(true,txMap1.containsKey(key));
      assertEquals(true,txMap2.containsKey(key));
      assertNull(h2.getMap(map1).get(key));
      assertNull(h2.getMap(map2).get(key));
      return true;
    }
  }
);
  assertTrue(b);
  assertEquals(""String_Node_Str"",h1.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h1.getMap(map2).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map2).get(key));
}","@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final String map1=""String_Node_Str"";
  final String map2=""String_Node_Str"";
  final String key=""String_Node_Str"";
  boolean b=h1.executeTransaction(options,new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap1=context.getMap(map1);
      final TransactionalMap<Object,Object> txMap2=context.getMap(map2);
      txMap1.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap1.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap1.get(key));
      txMap2.put(key,""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap2.put(key,""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap2.get(key));
      assertEquals(true,txMap1.containsKey(key));
      assertEquals(true,txMap2.containsKey(key));
      assertNull(h2.getMap(map1).get(key));
      assertNull(h2.getMap(map2).get(key));
      return true;
    }
  }
);
  assertTrue(b);
  assertEquals(""String_Node_Str"",h1.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map1).get(key));
  assertEquals(""String_Node_Str"",h1.getMap(map2).get(key));
  assertEquals(""String_Node_Str"",h2.getMap(map2).get(key));
  assertFalse(h1.getMap(map1).isLocked(key));
  assertFalse(h1.getMap(map2).isLocked(key));
}",0.9713038053649408
48642,"@Override protected void invoke(){
  OperationFactory factory=new KeyValueMapReduceOperationFactory(name,jobId,chunkSize,keys,predicate,keyValueSource,mapper,combinerFactory);
  ClientEndpoint endpoint=getEndpoint();
  ClientEngine engine=getClientEngine();
  SerializationService ss=engine.getSerializationService();
  PartitionService ps=engine.getPartitionService();
  Map<Integer,CompletableFuture> futures=new HashMap<Integer,CompletableFuture>();
  Map<Integer,List> mappedKeys=MapReduceUtil.mapKeys(ps,keys);
  for (  Map.Entry<Integer,List> entry : mappedKeys.entrySet()) {
    Operation op=factory.createOperation(entry.getKey(),entry.getValue());
    InvocationBuilder builder=createInvocationBuilder(getServiceName(),op,entry.getKey());
    futures.put(entry.getKey(),builder.invoke());
  }
  Map<Integer,Object> results=new HashMap<Integer,Object>();
  for (  Map.Entry<Integer,CompletableFuture> entry : futures.entrySet()) {
    try {
      results.put(entry.getKey(),toObject(ss,entry.getValue().get()));
    }
 catch (    Throwable t) {
      results.put(entry.getKey(),t);
    }
  }
  List<Integer> failedPartitions=new LinkedList<Integer>();
  for (  Map.Entry<Integer,Object> entry : results.entrySet()) {
    if (entry.getValue() instanceof Throwable) {
      failedPartitions.add(entry.getKey());
    }
  }
  for (  Integer partitionId : failedPartitions) {
    List keys=mappedKeys.get(partitionId);
    Operation operation=factory.createOperation(partitionId,keys);
    InvocationBuilder builder=createInvocationBuilder(getServiceName(),operation,partitionId);
    results.put(partitionId,builder.invoke());
  }
  for (  Integer failedPartition : failedPartitions) {
    try {
      Future<?> future=(Future<?>)results.get(failedPartition);
      Object result=future.get();
      results.put(failedPartition,result);
    }
 catch (    Throwable t) {
      results.put(failedPartition,t);
    }
  }
  engine.sendResponse(endpoint,results);
}","@Override protected void invoke(){
  MapReduceOperationFactory factory=buildFactoryAdapter();
  ClientEndpoint endpoint=getEndpoint();
  ClientEngine engine=getClientEngine();
  SerializationService ss=engine.getSerializationService();
  PartitionService ps=engine.getPartitionService();
  Map<Integer,CompletableFuture> futures=new HashMap<Integer,CompletableFuture>();
  Map<Integer,List> mappedKeys=MapReduceUtil.mapKeys(ps,keys);
  for (  Map.Entry<Integer,List> entry : mappedKeys.entrySet()) {
    Operation op=factory.createOperation(entry.getKey(),entry.getValue());
    InvocationBuilder builder=buildInvocationBuilder(getServiceName(),op,entry.getKey());
    futures.put(entry.getKey(),builder.invoke());
  }
  Map<Integer,Object> results=new HashMap<Integer,Object>();
  for (  Map.Entry<Integer,CompletableFuture> entry : futures.entrySet()) {
    try {
      results.put(entry.getKey(),toObject(ss,entry.getValue().get()));
    }
 catch (    Throwable t) {
      results.put(entry.getKey(),t);
    }
  }
  List<Integer> failedPartitions=new LinkedList<Integer>();
  for (  Map.Entry<Integer,Object> entry : results.entrySet()) {
    if (entry.getValue() instanceof Throwable) {
      failedPartitions.add(entry.getKey());
    }
  }
  for (  Integer partitionId : failedPartitions) {
    List keys=mappedKeys.get(partitionId);
    Operation operation=factory.createOperation(partitionId,keys);
    InvocationBuilder builder=buildInvocationBuilder(getServiceName(),operation,partitionId);
    results.put(partitionId,builder.invoke());
  }
  for (  Integer failedPartition : failedPartitions) {
    try {
      Future<?> future=(Future<?>)results.get(failedPartition);
      Object result=future.get();
      results.put(failedPartition,result);
    }
 catch (    Throwable t) {
      results.put(failedPartition,t);
    }
  }
  engine.sendResponse(endpoint,results);
}",0.9614984391259104
48643,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessing();
    }
  }
;
  constructors[PARTITION_STATE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new JobPartitionStateImpl();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[PARTITION_STATE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new JobPartitionStateImpl();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9454874462791224
48644,"public <R>R processRequest(Address address,RequestPartitionProcessing requestPartitionProcessing) throws ExecutionException, InterruptedException {
  Future<R> future=nodeEngine.getOperationService().invokeOnTarget(MapReduceService.SERVICE_NAME,requestPartitionProcessing,address);
  return future.get();
}","public <R>R processRequest(Address address,ProcessingOperation processingOperation) throws ExecutionException, InterruptedException {
  Future<R> future=nodeEngine.getOperationService().invokeOnTarget(MapReduceService.SERVICE_NAME,processingOperation,address);
  return future.get();
}",0.7715736040609137
48645,"@Override public void readData(ObjectDataInput in) throws IOException {
  super.readData(in);
  int size=in.readInt();
  chunk=new HashMap<KeyOut,Value>();
  for (int i=0; i < size; i++) {
    KeyOut key=in.readObject();
    Value value=in.readObject();
    chunk.put(key,value);
  }
}","@Override public void readData(ObjectDataInput in) throws IOException {
  super.readData(in);
  int size=in.readInt();
  chunk=new HashMap<KeyOut,Value>();
  for (int i=0; i < size; i++) {
    KeyOut key=in.readObject();
    Value value=in.readObject();
    chunk.put(key,value);
  }
  partitionId=in.readInt();
}",0.9531772575250836
48646,"public LastChunkNotification(Address address,String name,String jobId,Map<KeyOut,Value> chunk){
  super(address,name,jobId);
  this.chunk=chunk;
}","public LastChunkNotification(Address address,String name,String jobId,int partitionId,Map<KeyOut,Value> chunk){
  super(address,name,jobId);
  this.partitionId=partitionId;
  this.chunk=chunk;
}",0.8588235294117647
48647,"@Override public void writeData(ObjectDataOutput out) throws IOException {
  super.writeData(out);
  out.writeInt(chunk.size());
  for (  Map.Entry<KeyOut,Value> entry : chunk.entrySet()) {
    out.writeObject(entry.getKey());
    out.writeObject(entry.getValue());
  }
}","@Override public void writeData(ObjectDataOutput out) throws IOException {
  super.writeData(out);
  out.writeInt(chunk.size());
  for (  Map.Entry<KeyOut,Value> entry : chunk.entrySet()) {
    out.writeObject(entry.getKey());
    out.writeObject(entry.getValue());
  }
  out.writeInt(partitionId);
}",0.9492119089316988
48648,"public RequestPartitionProcessing(String name,String jobId,int partitionId){
  this.name=name;
  this.jobId=jobId;
  this.partitionId=partitionId;
}","public RequestPartitionProcessing(String name,String jobId,int partitionId){
  super(name,jobId);
  this.partitionId=partitionId;
}",0.8888888888888888
48649,"@Override public void run() throws Exception {
  MapReduceService mapReduceService=getService();
  JobSupervisor supervisor=mapReduceService.getJobSupervisor(name,jobId);
  if (supervisor == null) {
    return;
  }
  JobProcessInformationImpl processInformation=supervisor.getJobProcessInformation();
  JobPartitionState newPartitonState=new JobPartitionStateImpl(getCallerAddress(),JobPartitionState.State.PROCESSING);
  if (checkState(processInformation)) {
    for (; ; ) {
      JobPartitionState[] oldPartitionStates=processInformation.getPartitionStates();
      JobPartitionState[] newPartitonStates=Arrays.copyOf(oldPartitionStates,oldPartitionStates.length);
      newPartitonStates[partitionId]=newPartitonState;
      if (!processInformation.updatePartitionState(oldPartitionStates,newPartitonStates)) {
        if (checkState(processInformation)) {
          continue;
        }
      }
 else {
        JobPartitionState[] partitionStates=processInformation.getPartitionStates();
        JobPartitionState partitionState=partitionStates[partitionId];
        if (partitionState.getState() == JobPartitionState.State.PROCESSING && partitionState.getOwner().equals(getCallerAddress())) {
          this.partitionStates=partitionStates;
          return;
        }
        this.partitionStates=partitionStates;
        return;
      }
    }
  }
}","@Override public void run() throws Exception {
  MapReduceService mapReduceService=getService();
  JobSupervisor supervisor=mapReduceService.getJobSupervisor(getName(),getJobId());
  if (supervisor == null) {
    return;
  }
  JobProcessInformationImpl processInformation=supervisor.getJobProcessInformation();
  JobPartitionState newPartitonState=new JobPartitionStateImpl(getCallerAddress(),JobPartitionState.State.PROCESSING);
  if (checkState(processInformation)) {
    for (; ; ) {
      JobPartitionState[] oldPartitionStates=processInformation.getPartitionStates();
      JobPartitionState[] newPartitonStates=Arrays.copyOf(oldPartitionStates,oldPartitionStates.length);
      newPartitonStates[partitionId]=newPartitonState;
      if (!processInformation.updatePartitionState(oldPartitionStates,newPartitonStates)) {
        if (checkState(processInformation)) {
          continue;
        }
      }
 else {
        JobPartitionState[] partitionStates=processInformation.getPartitionStates();
        JobPartitionState partitionState=partitionStates[partitionId];
        if (partitionState.getState() == JobPartitionState.State.PROCESSING && partitionState.getOwner().equals(getCallerAddress())) {
          this.partitionStates=partitionStates;
          return;
        }
        this.partitionStates=partitionStates;
        return;
      }
    }
  }
}",0.9948529411764706
48650,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  partitionId=in.readInt();
  name=in.readUTF();
  jobId=in.readUTF();
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  partitionId=in.readInt();
}",0.8617363344051447
48651,"@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeInt(partitionId);
  out.writeUTF(name);
  out.writeUTF(jobId);
}","@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeInt(partitionId);
}",0.8615384615384616
48652,"public void startTasks(MappingPhase mappingPhase){
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  jobTracker.registerReducerTask(new ReducerTask(name,jobId,this,new ConcurrentLinkedQueue()));
  jobTracker.registerMapCombineTask(new MapCombineTask(configuration,this,mappingPhase));
}","public void startTasks(MappingPhase mappingPhase){
  String name=configuration.getName();
  String jobId=configuration.getJobId();
  jobTracker.registerReducerTask(new ReducerTask(name,jobId,this));
  jobTracker.registerMapCombineTask(new MapCombineTask(configuration,this,mappingPhase));
}",0.8125
48653,"public void onNotification(MapReduceNotification notification){
  if (notification instanceof IntermediateChunkNotification) {
    IntermediateChunkNotification icn=(IntermediateChunkNotification)notification;
    ReducerTask reducerTask=jobTracker.getReducerTask(icn.getJobId());
    reducerTask.processChunk(icn.getChunk());
  }
 else   if (notification instanceof LastChunkNotification) {
    LastChunkNotification lcn=(LastChunkNotification)notification;
    ReducerTask reducerTask=jobTracker.getReducerTask(lcn.getJobId());
    reducerTask.processChunk(lcn.getChunk());
  }
}","public void onNotification(MapReduceNotification notification){
  if (notification instanceof IntermediateChunkNotification) {
    IntermediateChunkNotification icn=(IntermediateChunkNotification)notification;
    ReducerTask reducerTask=jobTracker.getReducerTask(icn.getJobId());
    reducerTask.processChunk(icn.getChunk());
  }
 else   if (notification instanceof LastChunkNotification) {
    LastChunkNotification lcn=(LastChunkNotification)notification;
    ReducerTask reducerTask=jobTracker.getReducerTask(lcn.getJobId());
    reducerTask.processChunk(lcn.getPartitionId(),lcn.getChunk());
  }
}",0.9822485207100592
48654,"AbstractJobTracker(String name,JobTrackerConfig jobTrackerConfig,NodeEngine nodeEngine){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.jobTrackerConfig=jobTrackerConfig;
  this.executorService=nodeEngine.getExecutionService().getExecutor(name);
}","AbstractJobTracker(String name,JobTrackerConfig jobTrackerConfig,NodeEngine nodeEngine,MapReduceService mapReduceService){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.jobTrackerConfig=jobTrackerConfig;
  this.mapReduceService=mapReduceService;
  this.executorService=nodeEngine.getExecutionService().getExecutor(name);
}",0.8703071672354948
48655,"@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessing();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[REDUCER_RESULT_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducerResultNotification();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","@Override public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[LEN];
  constructors[KEY_VALUE_SOURCE_MAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MapKeyValueSource();
    }
  }
;
  constructors[KEY_VALUE_SOURCE_MULTIMAP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new MultiMapKeyValueSource();
    }
  }
;
  constructors[REDUCER_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new IntermediateChunkNotification();
    }
  }
;
  constructors[REDUCER_LAST_CHUNK_MESSAGE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new LastChunkNotification();
    }
  }
;
  constructors[TRACKED_JOB_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeyValueJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSING]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionMapping();
    }
  }
;
  constructors[REQUEST_PARTITION_PROCESSED]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionProcessed();
    }
  }
;
  constructors[REDUCER_RESULT_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ReducerResultOperation();
    }
  }
;
  constructors[START_PROCESSING_OPERATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new StartProcessingJobOperation();
    }
  }
;
  constructors[REQUEST_PARTITION_RESULT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new RequestPartitionResult();
    }
  }
;
  constructors[CLIENT_MAP_REDUCE_REQUEST]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    @Override public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClientMapReduceRequest();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.900523560209424
48656,"public JobSupervisor createJobSupervisor(JobTaskConfiguration configuration){
  JobSupervisorKey key=new JobSupervisorKey(configuration.getName(),configuration.getJobId());
  JobTracker jobTracker=(JobTracker)createDistributedObject(configuration.getName());
  JobSupervisor jobSupervisor=new JobSupervisor(configuration,(AbstractJobTracker)jobTracker,this);
  JobSupervisor oldSupervisor=jobSupervisors.putIfAbsent(key,jobSupervisor);
  return oldSupervisor != null ? oldSupervisor : jobSupervisor;
}","public JobSupervisor createJobSupervisor(JobTaskConfiguration configuration){
  JobSupervisorKey key=new JobSupervisorKey(configuration.getName(),configuration.getJobId());
  AbstractJobTracker jobTracker=(AbstractJobTracker)createDistributedObject(configuration.getName());
  boolean ownerNode=nodeEngine.getThisAddress().equals(configuration.getJobOwner());
  JobSupervisor jobSupervisor=new JobSupervisor(configuration,jobTracker,ownerNode,this);
  JobSupervisor oldSupervisor=jobSupervisors.putIfAbsent(key,jobSupervisor);
  return oldSupervisor != null ? oldSupervisor : jobSupervisor;
}",0.8270814272644099
48657,"@Override public JobTracker createNew(String arg){
  JobTrackerConfig jobTrackerConfig=config.findJobTrackerConfig(arg);
  return new NodeJobTracker(arg,jobTrackerConfig.getAsReadOnly(),nodeEngine);
}","@Override public JobTracker createNew(String arg){
  JobTrackerConfig jobTrackerConfig=config.findJobTrackerConfig(arg);
  return new NodeJobTracker(arg,jobTrackerConfig.getAsReadOnly(),nodeEngine,MapReduceService.this);
}",0.9478672985781992
48658,"public MapReduceService(NodeEngine nodeEngine){
  this.config=nodeEngine.getConfig();
  this.nodeEngine=nodeEngine;
  this.eventService=nodeEngine.getEventService();
  this.hazelcastInstance=nodeEngine.getHazelcastInstance();
  this.partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
  this.partitions=partitionService.getPartitions();
  this.eventService.registerListener(SERVICE_NAME,EVENT_TOPIC_NAME,new MapReduceNotificationListener());
}","public MapReduceService(NodeEngine nodeEngine){
  this.config=nodeEngine.getConfig();
  this.nodeEngine=nodeEngine;
  this.eventService=nodeEngine.getEventService();
  this.hazelcastInstance=nodeEngine.getHazelcastInstance();
  this.partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
  this.partitions=partitionService.getPartitions();
  this.eventService.registerListener(SERVICE_NAME,EVENT_TOPIC_NAME,this);
}",0.9565217391304348
48659,"public FastStringCreator(Constructor<String> constructor){
  this.constructor=constructor;
}","public FastStringCreator(Constructor<String> constructor){
  this.constructor=constructor;
  this.useOldStringConstructor=constructor.getTypeParameters().length == 3;
}",0.7076923076923077
48660,"@Override public void onReplicationEvent(WanReplicationEvent replicationEvent){
  Object eventObject=replicationEvent.getEventObject();
  if (eventObject instanceof MapReplicationUpdate) {
    MapReplicationUpdate replicationUpdate=(MapReplicationUpdate)eventObject;
    EntryView entryView=replicationUpdate.getEntryView();
    MapMergePolicy mergePolicy=replicationUpdate.getMergePolicy();
    String mapName=replicationUpdate.getMapName();
    MapContainer mapContainer=getMapContainer(mapName);
    MergeOperation operation=new MergeOperation(mapName,toData(entryView.getKey(),mapContainer.getPartitioningStrategy()),entryView,mergePolicy);
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(entryView.getKey());
      Future f=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
 else   if (eventObject instanceof MapReplicationRemove) {
    MapReplicationRemove replicationRemove=(MapReplicationRemove)eventObject;
    DeleteOperation operation=new DeleteOperation(replicationRemove.getMapName(),replicationRemove.getKey());
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(replicationRemove.getKey());
      Future f=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}","@Override public void onReplicationEvent(WanReplicationEvent replicationEvent){
  Object eventObject=replicationEvent.getEventObject();
  if (eventObject instanceof MapReplicationUpdate) {
    MapReplicationUpdate replicationUpdate=(MapReplicationUpdate)eventObject;
    EntryView entryView=replicationUpdate.getEntryView();
    MapMergePolicy mergePolicy=replicationUpdate.getMergePolicy();
    String mapName=replicationUpdate.getMapName();
    MapContainer mapContainer=getMapContainer(mapName);
    MergeOperation operation=new MergeOperation(mapName,toData(entryView.getKey(),mapContainer.getPartitioningStrategy()),entryView,mergePolicy);
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(entryView.getKey());
      Future f=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
 else   if (eventObject instanceof MapReplicationRemove) {
    MapReplicationRemove replicationRemove=(MapReplicationRemove)eventObject;
    WanOriginatedDeleteOperation operation=new WanOriginatedDeleteOperation(replicationRemove.getMapName(),replicationRemove.getKey());
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(replicationRemove.getKey());
      Future f=nodeEngine.getOperationService().invokeOnPartition(SERVICE_NAME,operation,partitionId);
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}",0.9914134742404228
48661,"public void setAttribute(String key,Object value){
  if (!localMember)   throw new UnsupportedOperationException(""String_Node_Str"");
  if (value != null) {
    attributes.put(key,value);
  }
 else {
    attributes.remove(key);
  }
  if (instance != null) {
    NodeEngineImpl nodeEngine=instance.node.nodeEngine;
    OperationService os=nodeEngine.getOperationService();
    MemberAttributeChangedOperation operation;
    if (value != null) {
      operation=new MemberAttributeChangedOperation(MapOperationType.PUT,key,value);
    }
 else {
      operation=new MemberAttributeChangedOperation(MapOperationType.REMOVE,key,null);
    }
    String uuid=nodeEngine.getLocalMember().getUuid();
    operation.setCallerUuid(uuid).setNodeEngine(nodeEngine);
    try {
      for (      Member m : nodeEngine.getClusterService().getMembers()) {
        MemberImpl member=(MemberImpl)m;
        InvocationBuilder inv=os.createInvocationBuilder(ClusterServiceImpl.SERVICE_NAME,operation,member.getAddress());
        inv.invoke();
      }
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}","public void setAttribute(String key,Object value){
  if (!localMember)   throw new UnsupportedOperationException(""String_Node_Str"");
  if (value == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (value != null) {
    Object oldValue=attributes.put(key,value);
    if (value.equals(oldValue)) {
      return;
    }
  }
 else {
    attributes.remove(key);
  }
  if (instance != null) {
    NodeEngineImpl nodeEngine=instance.node.nodeEngine;
    OperationService os=nodeEngine.getOperationService();
    MemberAttributeChangedOperation operation;
    if (value != null) {
      operation=new MemberAttributeChangedOperation(MapOperationType.PUT,key,value);
    }
 else {
      operation=new MemberAttributeChangedOperation(MapOperationType.REMOVE,key,null);
    }
    String uuid=nodeEngine.getLocalMember().getUuid();
    operation.setCallerUuid(uuid).setNodeEngine(nodeEngine);
    try {
      for (      MemberImpl member : nodeEngine.getClusterService().getMemberList()) {
        os.send(operation,member.getAddress());
      }
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}",0.8333333333333334
48662,"private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null)   return getter;
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (!(getter instanceof ThisGetter)) {
      getterCache.putIfAbsent(cacheKey,getter);
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}","private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null)   return getter;
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      getterCache.putIfAbsent(cacheKey,getter);
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}",0.9907354887502364
48663,"private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null)   return getter;
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (!(getter instanceof ThisGetter)) {
      getterCache.putIfAbsent(cacheKey,getter);
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}","private static Getter createGetter(QueryableEntry entry,String attribute){
  Object obj;
  if (attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    obj=entry.getKey();
    if (attribute.length() > KEY_ATTRIBUTE_NAME.length()) {
      attribute=attribute.substring(KEY_ATTRIBUTE_NAME.length() + 1);
    }
  }
 else {
    obj=entry.getValue();
  }
  Class clazz=obj.getClass();
  final String cacheKey=clazz.getName() + ""String_Node_Str"" + attribute;
  Getter getter=getterCache.get(cacheKey);
  if (getter != null)   return getter;
  try {
    Getter parent=null;
    List<String> possibleMethodNames=new ArrayList<String>(3);
    for (    final String name : attribute.split(""String_Node_Str"")) {
      Getter localGetter=null;
      possibleMethodNames.clear();
      possibleMethodNames.add(name);
      final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      possibleMethodNames.add(""String_Node_Str"" + camelName);
      if (name.equals(THIS_ATTRIBUTE_NAME)) {
        localGetter=new ThisGetter(parent,obj);
      }
 else {
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
      }
      if (localGetter == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str""+ clazz+ ""String_Node_Str"");
      }
      parent=localGetter;
    }
    getter=parent;
    if (getter.isCacheable()) {
      getterCache.putIfAbsent(cacheKey,getter);
    }
    return getter;
  }
 catch (  Throwable e) {
    throw new QueryException(e);
  }
}",0.9907354887502364
48664,"@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  Object output=f.apply(input);
  shouldBackup=!equals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
  response=output;
}","@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  Object output=f.apply(input);
  shouldBackup=!isEquals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
  response=output;
}",0.9952153110047848
48665,"@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  Object output=f.apply(input);
  shouldBackup=!equals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
}","@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  Object output=f.apply(input);
  shouldBackup=!isEquals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
}",0.9949874686716792
48666,"@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  response=input;
  Object output=f.apply(input);
  shouldBackup=!equals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
}","@Override public void run() throws Exception {
  NodeEngine nodeEngine=getNodeEngine();
  Function f=nodeEngine.toObject(function);
  AtomicReferenceWrapper reference=getReference();
  Object input=nodeEngine.toObject(reference.get());
  response=input;
  Object output=f.apply(input);
  shouldBackup=!isEquals(input,output);
  if (shouldBackup) {
    backup=nodeEngine.toData(output);
    reference.set(backup);
  }
}",0.9952038369304556
48667,"private void startJoin(){
  logger.finest(""String_Node_Str"");
  lock.lock();
  try {
    joinInProgress=true;
    node.getPartitionService().pauseMigration();
    final Collection<MemberImpl> members=getMemberList();
    final Collection<MemberInfo> memberInfos=createMemberInfos(members);
    for (    MemberInfo memberJoining : setJoins) {
      memberInfos.add(memberJoining);
    }
    final long time=getClusterTime();
    final Operation[] postJoinOps=nodeEngine.getPostJoinOperations();
    final PostJoinOperation postJoinOp=postJoinOps != null && postJoinOps.length > 0 ? new PostJoinOperation(postJoinOps) : null;
    final int count=members.size() - 1 + setJoins.size();
    final List<Future> calls=new ArrayList<Future>(count);
    for (    MemberInfo member : setJoins) {
      calls.add(invokeClusterOperation(new FinalizeJoinOperation(memberInfos,postJoinOp,time),member.getAddress()));
    }
    for (    MemberImpl member : members) {
      if (!member.getAddress().equals(thisAddress)) {
        calls.add(invokeClusterOperation(new MemberInfoUpdateOperation(memberInfos,time,true),member.getAddress()));
      }
    }
    updateMembers(memberInfos);
    for (    Future future : calls) {
      try {
        future.get(10,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + future);
        }
      }
catch (      Exception e) {
        logger.warning(""String_Node_Str"",e);
      }
    }
  }
  finally {
    node.getPartitionService().resumeMigration();
    lock.unlock();
  }
}","private void startJoin(){
  logger.finest(""String_Node_Str"");
  lock.lock();
  try {
    try {
      joinInProgress=true;
      node.getPartitionService().pauseMigration();
      final Collection<MemberImpl> members=getMemberList();
      final Collection<MemberInfo> memberInfos=createMemberInfos(members);
      for (      MemberInfo memberJoining : setJoins) {
        memberInfos.add(memberJoining);
      }
      final long time=getClusterTime();
      final Operation[] postJoinOps=nodeEngine.getPostJoinOperations();
      final PostJoinOperation postJoinOp=postJoinOps != null && postJoinOps.length > 0 ? new PostJoinOperation(postJoinOps) : null;
      final int count=members.size() - 1 + setJoins.size();
      final List<Future> calls=new ArrayList<Future>(count);
      for (      MemberInfo member : setJoins) {
        calls.add(invokeClusterOperation(new FinalizeJoinOperation(memberInfos,postJoinOp,time),member.getAddress()));
      }
      for (      MemberImpl member : members) {
        if (!member.getAddress().equals(thisAddress)) {
          calls.add(invokeClusterOperation(new MemberInfoUpdateOperation(memberInfos,time,true),member.getAddress()));
        }
      }
      updateMembers(memberInfos);
      for (      Future future : calls) {
        try {
          future.get(10,TimeUnit.SECONDS);
        }
 catch (        TimeoutException ignored) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + future);
          }
        }
catch (        Exception e) {
          logger.warning(""String_Node_Str"",e);
        }
      }
    }
  finally {
      node.getPartitionService().resumeMigration();
    }
  }
  finally {
    lock.unlock();
  }
}",0.9540785498489426
48668,"public static AddressMatcher getAddressMatcher(String address){
  final AddressMatcher matcher;
  final int indexColon=address.indexOf(':');
  final int lastIndexColon=address.lastIndexOf(':');
  final int indexDot=address.indexOf('.');
  final int lastIndexDot=address.lastIndexOf('.');
  if (indexColon > -1 && lastIndexColon > indexColon) {
    if (indexDot == -1) {
      matcher=new Ip6AddressMatcher();
      parseIpv6(matcher,address);
    }
 else {
      if (indexDot >= lastIndexDot) {
        throw new InvalidAddressException(address);
      }
      final int lastIndexColon2=address.lastIndexOf(':');
      final String host2=address.substring(lastIndexColon2 + 1);
      matcher=new Ip4AddressMatcher();
      parseIpv4(matcher,host2);
    }
  }
 else   if (indexDot > -1 && lastIndexDot > indexDot && indexColon == -1) {
    matcher=new Ip4AddressMatcher();
    parseIpv4(matcher,address);
  }
 else {
    throw new InvalidAddressException(address);
  }
  return matcher;
}","/** 
 * Gets an AddressMatcher for a given addresses.
 * @param address the address
 * @return the returned AddressMatcher. The returned value will never be null.
 * @throws com.hazelcast.util.AddressUtil.InvalidAddressException if the address is not valid.
 */
public static AddressMatcher getAddressMatcher(String address){
  final AddressMatcher matcher;
  final int indexColon=address.indexOf(':');
  final int lastIndexColon=address.lastIndexOf(':');
  final int indexDot=address.indexOf('.');
  final int lastIndexDot=address.lastIndexOf('.');
  if (indexColon > -1 && lastIndexColon > indexColon) {
    if (indexDot == -1) {
      matcher=new Ip6AddressMatcher();
      parseIpv6(matcher,address);
    }
 else {
      if (indexDot >= lastIndexDot) {
        throw new InvalidAddressException(address);
      }
      final int lastIndexColon2=address.lastIndexOf(':');
      final String host2=address.substring(lastIndexColon2 + 1);
      matcher=new Ip4AddressMatcher();
      parseIpv4(matcher,host2);
    }
  }
 else   if (indexDot > -1 && lastIndexDot > indexDot && indexColon == -1) {
    matcher=new Ip4AddressMatcher();
    parseIpv4(matcher,address);
  }
 else {
    throw new InvalidAddressException(address);
  }
  return matcher;
}",0.8828264758497316
48669,"public static boolean isIpAddress(String address){
  try {
    return getAddressMatcher(address) != null;
  }
 catch (  InvalidAddressException e) {
    return false;
  }
}","public static boolean isIpAddress(String address){
  try {
    getAddressMatcher(address);
    return true;
  }
 catch (  InvalidAddressException e) {
    return false;
  }
}",0.930635838150289
48670,"public boolean equals(Object o){
  if (o != null && o instanceof SystemLogRecord) {
    return this.compareTo((SystemLogRecord)o) == 0;
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o != null && o instanceof SystemLogRecord) {
    return this.compareTo((SystemLogRecord)o) == 0;
  }
  return false;
}",0.9691358024691358
48671,"public boolean equals(Object o){
  if (o != null && o instanceof MonitoredThread) {
    return this.compareTo((MonitoredThread)o) == 0;
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o != null && o instanceof MonitoredThread) {
    return this.compareTo((MonitoredThread)o) == 0;
  }
  return false;
}",0.9691358024691358
48672,"public boolean equals(Object o){
  return this.compareTo(o) == 0;
}","@Override public boolean equals(Object o){
  return this.compareTo(o) == 0;
}",0.9305555555555556
48673,"private ClientConnection getOrConnect(Address address,Authenticator authenticator) throws IOException {
  ClientConnection clientConnection=connections.get(address);
  if (clientConnection == null) {
synchronized (this) {
      clientConnection=connections.get(address);
      if (clientConnection == null) {
        clientConnection=connect(address);
        connections.put(address,clientConnection);
      }
    }
  }
  authenticator.auth(clientConnection);
  return clientConnection;
}","private ClientConnection getOrConnect(Address address,Authenticator authenticator) throws IOException {
  ClientConnection clientConnection=connections.get(address);
  if (clientConnection == null) {
synchronized (this) {
      clientConnection=connections.get(address);
      if (clientConnection == null) {
        clientConnection=connect(address);
        authenticator.auth(clientConnection);
        connections.put(clientConnection.getRemoteEndpoint(),clientConnection);
      }
    }
  }
  return clientConnection;
}",0.8272458045409674
48674,"private V resolveResponse(){
  return (V)response;
}","private V resolveResponse(){
  return (V)ErrorHandler.returnResultOrThrowException(response);
}",0.7074829931972789
48675,"public static boolean stopListening(ClientContext context,ClientRequest request,String registrationId){
  final Future<Boolean> future;
  try {
    future=context.getInvocationService().invokeOnRandomTarget(request);
    Boolean result=future.get();
    context.getClusterService().deRegisterListener(registrationId);
    return result;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","public static boolean stopListening(ClientContext context,ClientRequest request,String registrationId){
  final Future<Boolean> future;
  try {
    future=context.getInvocationService().invokeOnRandomTarget(request);
    Boolean result=context.getSerializationService().toObject(future.get());
    context.getClusterService().deRegisterListener(registrationId);
    return result;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9487179487179488
48676,"public static String listen(HazelcastClient client,ClientRequest request,Object key,EventHandler handler){
  final Future<String> future;
  try {
    if (key == null) {
      future=client.getInvocationService().invokeOnRandomTarget(request,handler);
    }
 else {
      future=client.getInvocationService().invokeOnKeyOwner(request,key,handler);
    }
    String registrationId=future.get();
    client.getClientClusterService().registerListener(registrationId,request.getCallId());
    return registrationId;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","public static String listen(HazelcastClient client,ClientRequest request,Object key,EventHandler handler){
  final Future future;
  try {
    if (key == null) {
      future=client.getInvocationService().invokeOnRandomTarget(request,handler);
    }
 else {
      future=client.getInvocationService().invokeOnKeyOwner(request,key,handler);
    }
    String registrationId=client.getSerializationService().toObject(future.get());
    client.getClientClusterService().registerListener(registrationId,request.getCallId());
    return registrationId;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.9573934837092732
48677,"@Override public Object call(){
  final ClientEndpoint endpoint=getEndpoint();
  final ClientEngine clientEngine=getClientEngine();
  final MapService mapService=getService();
  EntryListener<Object,Object> listener=new EntryListener<Object,Object>(){
    private void handleEvent(    EntryEvent<Object,Object> event){
      if (endpoint.live()) {
        Data key=clientEngine.toData(event.getKey());
        Data value=clientEngine.toData(event.getValue());
        Data oldValue=clientEngine.toData(event.getOldValue());
        PortableEntryEvent portableEntryEvent=new PortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
    public void entryAdded(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryRemoved(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryUpdated(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryEvicted(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
  }
;
  EventFilter eventFilter;
  if (getPredicate() == null) {
    eventFilter=new EntryEventFilter(includeValue,key);
  }
 else {
    eventFilter=new QueryEventFilter(includeValue,key,getPredicate());
  }
  String registrationId=mapService.addEventListener(listener,eventFilter,name);
  endpoint.setListenerRegistration(MapService.SERVICE_NAME,name,registrationId);
  return true;
}","@Override public Object call(){
  final ClientEndpoint endpoint=getEndpoint();
  final ClientEngine clientEngine=getClientEngine();
  final MapService mapService=getService();
  EntryListener<Object,Object> listener=new EntryListener<Object,Object>(){
    private void handleEvent(    EntryEvent<Object,Object> event){
      if (endpoint.live()) {
        Data key=clientEngine.toData(event.getKey());
        Data value=clientEngine.toData(event.getValue());
        Data oldValue=clientEngine.toData(event.getOldValue());
        PortableEntryEvent portableEntryEvent=new PortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
    public void entryAdded(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryRemoved(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryUpdated(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryEvicted(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
  }
;
  EventFilter eventFilter;
  if (getPredicate() == null) {
    eventFilter=new EntryEventFilter(includeValue,key);
  }
 else {
    eventFilter=new QueryEventFilter(includeValue,key,getPredicate());
  }
  String registrationId=mapService.addEventListener(listener,eventFilter,name);
  endpoint.setListenerRegistration(MapService.SERVICE_NAME,name,registrationId);
  return registrationId;
}",0.9940828402366864
48678,"public void read(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  super.readPortable(reader);
}","public void read(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  super.read(reader);
}",0.9692307692307692
48679,"public Object call() throws Exception {
  final ClientEndpoint endpoint=getEndpoint();
  final ClientEngine clientEngine=getClientEngine();
  final MultiMapService service=getService();
  EntryListener listener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      send(event);
    }
    public void entryRemoved(    EntryEvent event){
      send(event);
    }
    public void entryUpdated(    EntryEvent event){
      send(event);
    }
    public void entryEvicted(    EntryEvent event){
      send(event);
    }
    private void send(    EntryEvent event){
      if (endpoint.live()) {
        Data key=clientEngine.toData(event.getKey());
        Data value=clientEngine.toData(event.getValue());
        Data oldValue=clientEngine.toData(event.getOldValue());
        PortableEntryEvent portableEntryEvent=new PortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
  }
;
  String registrationId=service.addListener(name,listener,key,includeValue,false);
  endpoint.setListenerRegistration(MultiMapService.SERVICE_NAME,name,registrationId);
  return null;
}","public Object call() throws Exception {
  final ClientEndpoint endpoint=getEndpoint();
  final ClientEngine clientEngine=getClientEngine();
  final MultiMapService service=getService();
  EntryListener listener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      send(event);
    }
    public void entryRemoved(    EntryEvent event){
      send(event);
    }
    public void entryUpdated(    EntryEvent event){
      send(event);
    }
    public void entryEvicted(    EntryEvent event){
      send(event);
    }
    private void send(    EntryEvent event){
      if (endpoint.live()) {
        Data key=clientEngine.toData(event.getKey());
        Data value=clientEngine.toData(event.getValue());
        Data oldValue=clientEngine.toData(event.getOldValue());
        PortableEntryEvent portableEntryEvent=new PortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
  }
;
  String registrationId=service.addListener(name,listener,key,includeValue,false);
  endpoint.setListenerRegistration(MultiMapService.SERVICE_NAME,name,registrationId);
  return registrationId;
}",0.9924812030075189
48680,"@Override public void read(PortableReader reader) throws IOException {
  super.readPortable(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  key=new Data();
  key.readData(in);
}","@Override public void read(PortableReader reader) throws IOException {
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  key=new Data();
  key.readData(in);
}",0.9788359788359788
48681,"public void write(PortableWriter writer) throws IOException {
  super.writePortable(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  key.writeData(out);
}","public void write(PortableWriter writer) throws IOException {
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  key.writeData(out);
}",0.9761904761904762
48682,"public void read(PortableReader reader) throws IOException {
  index=reader.readInt(""String_Node_Str"");
  threadId=reader.readInt(""String_Node_Str"");
  super.readPortable(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  value=new Data();
  value.readData(in);
}","public void read(PortableReader reader) throws IOException {
  index=reader.readInt(""String_Node_Str"");
  threadId=reader.readInt(""String_Node_Str"");
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  value=new Data();
  value.readData(in);
}",0.9852941176470588
48683,"public void write(PortableWriter writer) throws IOException {
  writer.writeInt(""String_Node_Str"",index);
  writer.writeInt(""String_Node_Str"",threadId);
  super.writePortable(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  value.writeData(out);
}","public void write(PortableWriter writer) throws IOException {
  writer.writeInt(""String_Node_Str"",index);
  writer.writeInt(""String_Node_Str"",threadId);
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  value.writeData(out);
}",0.9846743295019156
48684,"public void read(PortableReader reader) throws IOException {
  threadId=reader.readInt(""String_Node_Str"");
  super.readPortable(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  value=new Data();
  value.readData(in);
}","public void read(PortableReader reader) throws IOException {
  threadId=reader.readInt(""String_Node_Str"");
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  value=new Data();
  value.readData(in);
}",0.982532751091703
48685,"public void write(PortableWriter writer) throws IOException {
  writer.writeInt(""String_Node_Str"",threadId);
  super.writePortable(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  value.writeData(out);
}","public void write(PortableWriter writer) throws IOException {
  writer.writeInt(""String_Node_Str"",threadId);
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  value.writeData(out);
}",0.9815668202764976
48686,"public void read(PortableReader reader) throws IOException {
  super.readPortable(reader);
  int size=reader.readInt(""String_Node_Str"");
  final ObjectDataInput in=reader.getRawDataInput();
  dataList=new ArrayList<Data>(size);
  for (int i=0; i < size; i++) {
    Data data=new Data();
    data.readData(in);
    dataList.add(data);
  }
}","public void read(PortableReader reader) throws IOException {
  super.read(reader);
  int size=reader.readInt(""String_Node_Str"");
  final ObjectDataInput in=reader.getRawDataInput();
  dataList=new ArrayList<Data>(size);
  for (int i=0; i < size; i++) {
    Data data=new Data();
    data.readData(in);
    dataList.add(data);
  }
}",0.9880597014925372
48687,"public void write(PortableWriter writer) throws IOException {
  super.writePortable(writer);
  writer.writeInt(""String_Node_Str"",dataList.size());
  final ObjectDataOutput out=writer.getRawDataOutput();
  for (  Data data : dataList) {
    data.writeData(out);
  }
}","public void write(PortableWriter writer) throws IOException {
  super.write(writer);
  writer.writeInt(""String_Node_Str"",dataList.size());
  final ObjectDataOutput out=writer.getRawDataOutput();
  for (  Data data : dataList) {
    data.writeData(out);
  }
}",0.9847328244274808
48688,"public void read(PortableReader reader) throws IOException {
  super.readPortable(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  data=new Data();
  data.readData(in);
}","public void read(PortableReader reader) throws IOException {
  super.read(reader);
  final ObjectDataInput in=reader.getRawDataInput();
  data=new Data();
  data.readData(in);
}",0.9779005524861878
48689,"public void write(PortableWriter writer) throws IOException {
  super.writePortable(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  data.writeData(out);
}","public void write(PortableWriter writer) throws IOException {
  super.write(writer);
  final ObjectDataOutput out=writer.getRawDataOutput();
  data.writeData(out);
}",0.9763313609467456
48690,"@Override public Object call() throws Exception {
  final ClientEndpoint endpoint=getEndpoint();
  final ReplicatedRecordStore replicatedRecordStore=getReplicatedRecordStore();
  EntryListener<Object,Object> listener=new EntryListener<Object,Object>(){
    private void handleEvent(    EntryEvent<Object,Object> event){
      if (endpoint.live()) {
        Object key=event.getKey();
        Object value=event.getValue();
        Object oldValue=event.getOldValue();
        ReplicatedMapPortableEntryEvent portableEntryEvent=new ReplicatedMapPortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
    public void entryAdded(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryRemoved(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryUpdated(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryEvicted(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
  }
;
  String registrationId;
  if (predicate == null) {
    registrationId=replicatedRecordStore.addEntryListener(listener,key);
  }
 else {
    registrationId=replicatedRecordStore.addEntryListener(listener,predicate,key);
  }
  endpoint.setListenerRegistration(ReplicatedMapService.SERVICE_NAME,getMapName(),registrationId);
  return true;
}","@Override public Object call() throws Exception {
  final ClientEndpoint endpoint=getEndpoint();
  final ReplicatedRecordStore replicatedRecordStore=getReplicatedRecordStore();
  EntryListener<Object,Object> listener=new EntryListener<Object,Object>(){
    private void handleEvent(    EntryEvent<Object,Object> event){
      if (endpoint.live()) {
        Object key=event.getKey();
        Object value=event.getValue();
        Object oldValue=event.getOldValue();
        ReplicatedMapPortableEntryEvent portableEntryEvent=new ReplicatedMapPortableEntryEvent(key,value,oldValue,event.getEventType(),event.getMember().getUuid());
        endpoint.sendEvent(portableEntryEvent,getCallId());
      }
    }
    public void entryAdded(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryRemoved(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryUpdated(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
    public void entryEvicted(    EntryEvent<Object,Object> event){
      handleEvent(event);
    }
  }
;
  String registrationId;
  if (predicate == null) {
    registrationId=replicatedRecordStore.addEntryListener(listener,key);
  }
 else {
    registrationId=replicatedRecordStore.addEntryListener(listener,predicate,key);
  }
  endpoint.setListenerRegistration(ReplicatedMapService.SERVICE_NAME,getMapName(),registrationId);
  return registrationId;
}",0.9937973811164714
48691,"public Object call() throws Exception {
  final ReplicatedRecordStore replicatedRecordStore=getReplicatedRecordStore();
  replicatedRecordStore.removeEntryListenerInternal(registrationId);
  return null;
}","public Object call() throws Exception {
  final ReplicatedRecordStore replicatedRecordStore=getReplicatedRecordStore();
  return replicatedRecordStore.removeEntryListenerInternal(registrationId);
}",0.945273631840796
48692,"public Object call() throws Exception {
  final TopicService service=getService();
  final ClientEngine clientEngine=getClientEngine();
  final ClientEndpoint endpoint=getEndpoint();
  MessageListener listener=new MessageListener(){
    public void onMessage(    Message message){
      if (endpoint.live()) {
        Data messageData=clientEngine.toData(message.getMessageObject());
        PortableMessage portableMessage=new PortableMessage(messageData,message.getPublishTime(),message.getPublishingMember().getUuid());
        endpoint.sendEvent(portableMessage,getCallId());
      }
    }
  }
;
  String registrationId=service.addMessageListener(name,listener);
  endpoint.setListenerRegistration(TopicService.SERVICE_NAME,name,registrationId);
  return null;
}","public Object call() throws Exception {
  final TopicService service=getService();
  final ClientEngine clientEngine=getClientEngine();
  final ClientEndpoint endpoint=getEndpoint();
  MessageListener listener=new MessageListener(){
    public void onMessage(    Message message){
      if (endpoint.live()) {
        Data messageData=clientEngine.toData(message.getMessageObject());
        PortableMessage portableMessage=new PortableMessage(messageData,message.getPublishTime(),message.getPublishingMember().getUuid());
        endpoint.sendEvent(portableMessage,getCallId());
      }
    }
  }
;
  String registrationId=service.addMessageListener(name,listener);
  endpoint.setListenerRegistration(TopicService.SERVICE_NAME,name,registrationId);
  return registrationId;
}",0.9883268482490272
48693,"@AfterClass public static void destroy(){
  HazelcastClient.shutdownAll();
  Hazelcast.shutdownAll();
}","@After public static void destroy(){
  HazelcastClient.shutdownAll();
  Hazelcast.shutdownAll();
}",0.9751243781094528
48694,"@Override public void run() throws Exception {
  final PartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Record record=(Record)mapEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    backupProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,entry.getValue()));
  }
}","@Override public void run() throws Exception {
  final PartitionService partitionService=getNodeEngine().getPartitionService();
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  MapEntrySimple entry;
  for (  Data key : keys) {
    if (partitionService.getPartitionId(key) != getPartitionId())     continue;
    Object objectKey=mapService.toObject(key);
    final Map.Entry<Data,Object> mapEntry=recordStore.getMapEntry(key);
    final Object valueBeforeProcess=mapService.toObject(mapEntry.getValue());
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    backupProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(key,entry.getValue()));
  }
}",0.9052906596995428
48695,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  backupProcessor=in.readObject();
  int size=in.readInt();
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  backupProcessor=in.readObject();
  int size=in.readInt();
  keys=new HashSet<Data>(size);
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
}",0.9438596491228072
48696,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  entryProcessor=in.readObject();
  int size=in.readInt();
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  entryProcessor=in.readObject();
  int size=in.readInt();
  keys=new HashSet<Data>(size);
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
}",0.943661971830986
48697,"@Override public void readData(ObjectDataInput in) throws IOException {
  this.name=in.readUTF();
  int size=in.readInt();
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
  this.entryProcessor=in.readObject();
}","@Override public void readData(ObjectDataInput in) throws IOException {
  this.name=in.readUTF();
  int size=in.readInt();
  this.keys=new HashSet<Data>(size);
  for (int i=0; i < size; i++) {
    Data key=new Data();
    key.readData(in);
    keys.add(key);
  }
  this.entryProcessor=in.readObject();
}",0.9349736379613356
48698,"@Test public void testExecuteOnKeys() throws InterruptedException, ExecutionException {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance();
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance();
  IMap<Integer,Integer> map=instance1.getMap(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    map.put(i,0);
  }
  Set keys=new HashSet();
  keys.add(1);
  keys.add(4);
  keys.add(7);
  keys.add(9);
  final Map<Integer,Object> resultMap=map.executeOnKeys(keys,new IncrementorEntryProcessor());
  assertEquals(1,resultMap.get(1));
  assertEquals(1,resultMap.get(4));
  assertEquals(1,resultMap.get(7));
  assertEquals(1,resultMap.get(9));
  assertEquals(1,(int)map.get(1));
  assertEquals(0,(int)map.get(2));
  assertEquals(0,(int)map.get(3));
  assertEquals(1,(int)map.get(4));
  assertEquals(0,(int)map.get(5));
  assertEquals(0,(int)map.get(6));
  assertEquals(1,(int)map.get(7));
  assertEquals(0,(int)map.get(8));
  assertEquals(1,(int)map.get(9));
}","@Test public void testExecuteOnKeys() throws InterruptedException, ExecutionException {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance();
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance();
  IMap<Integer,Integer> map=instance1.getMap(""String_Node_Str"");
  IMap<Integer,Integer> map2=instance2.getMap(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    map.put(i,0);
  }
  Set keys=new HashSet();
  keys.add(1);
  keys.add(4);
  keys.add(7);
  keys.add(9);
  final Map<Integer,Object> resultMap=map2.executeOnKeys(keys,new IncrementorEntryProcessor());
  assertEquals(1,resultMap.get(1));
  assertEquals(1,resultMap.get(4));
  assertEquals(1,resultMap.get(7));
  assertEquals(1,resultMap.get(9));
  assertEquals(1,(int)map.get(1));
  assertEquals(0,(int)map.get(2));
  assertEquals(0,(int)map.get(3));
  assertEquals(1,(int)map.get(4));
  assertEquals(0,(int)map.get(5));
  assertEquals(0,(int)map.get(6));
  assertEquals(1,(int)map.get(7));
  assertEquals(0,(int)map.get(8));
  assertEquals(1,(int)map.get(9));
}",0.9692801467216872
48699,"private static DateFormat getTimestampFormat(){
  return new SimpleDateFormat(timestampFormat);
}","private static DateFormat getTimestampFormat(){
  return new SimpleDateFormat(timestampFormat,Locale.US);
}",0.9509803921568628
48700,"private static <T>T throwRuntimeParseException(String value,Exception e){
  throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ dateFormat+ ""String_Node_Str""+ timestampFormat+ ""String_Node_Str""+ sqlDateFormat+ ""String_Node_Str"",e);
}","private static <T>T throwRuntimeParseException(String value,Exception e,String... legalFormats){
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < legalFormats.length; i++) {
    sb.append(""String_Node_Str"").append(legalFormats[i]).append(""String_Node_Str"");
    if (i < legalFormats.length - 2)     sb.append(""String_Node_Str"");
  }
  throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ sb.toString()+ ""String_Node_Str"",e);
}",0.4908835904628331
48701,"static java.sql.Time parseSqlTime(final String value){
  try {
    return new Time(getSqlTimeFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e);
  }
}","static java.sql.Time parseSqlTime(final String value){
  try {
    return new Time(getSqlTimeFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e,sqlTimeFormat);
  }
}",0.9683257918552036
48702,"private static DateFormat getUtilDateFormat(){
  return new SimpleDateFormat(dateFormat);
}","private static DateFormat getUtilDateFormat(){
  return new SimpleDateFormat(dateFormat,Locale.US);
}",0.9479166666666666
48703,"static Date parseDate(final String value){
  try {
    return getUtilDateFormat().parse(value);
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e);
  }
}","static Date parseDate(final String value){
  try {
    return getUtilDateFormat().parse(value);
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e,dateFormat);
  }
}",0.9708222811671088
48704,"static Timestamp parseTimeStamp(final String value){
  try {
    return new Timestamp(getTimestampFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e);
  }
}","static Timestamp parseTimeStamp(final String value){
  try {
    return new Timestamp(getTimestampFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e,timestampFormat);
  }
}",0.9647577092511012
48705,"static Date tryParse(final String value){
  try {
    return getUtilDateFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  try {
    return getTimestampFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  try {
    return getSqlDateFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  return throwRuntimeParseException(value,null);
}","static Date tryParse(final String value){
  try {
    return getUtilDateFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  try {
    return getTimestampFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  try {
    return getSqlDateFormat().parse(value);
  }
 catch (  Exception ignored) {
  }
  return throwRuntimeParseException(value,null,sqlDateFormat);
}",0.9813333333333332
48706,"private static DateFormat getSqlTimeFormat(){
  return new SimpleDateFormat(sqlTimeFormat);
}","private static DateFormat getSqlTimeFormat(){
  return new SimpleDateFormat(sqlTimeFormat,Locale.US);
}",0.9489795918367347
48707,"static java.sql.Date parseSqlDate(final String value){
  try {
    return new java.sql.Date(getSqlDateFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e);
  }
}","static java.sql.Date parseSqlDate(final String value){
  try {
    return new java.sql.Date(getSqlDateFormat().parse(value).getTime());
  }
 catch (  ParseException e) {
    return throwRuntimeParseException(value,e,sqlDateFormat);
  }
}",0.9695652173913044
48708,"private static DateFormat getSqlDateFormat(){
  return new SimpleDateFormat(sqlDateFormat);
}","private static DateFormat getSqlDateFormat(){
  return new SimpleDateFormat(sqlDateFormat,Locale.US);
}",0.9489795918367347
48709,"@Test public void testEqual(){
  Employee value=new Employee(""String_Node_Str"",34,true,10D);
  value.setState(State.STATE2);
  Employee nullNameValue=new Employee(null,34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + State.STATE2).apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new SimpleDateFormat(dateFormat).format(new Date(0)) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new java.sql.Date(0) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new Timestamp(0) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 40+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 34+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",-33,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(Predicates.equal(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.equal(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.equal(null,TRUE).apply(new DummyEntry(true)));
  assertTrue(Predicates.equal(null,true).apply(new DummyEntry(TRUE)));
  assertFalse(Predicates.equal(null,true).apply(new DummyEntry(FALSE)));
  assertTrue(Predicates.greaterThan(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertFalse(Predicates.equal(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertTrue(Predicates.equal(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertFalse(Predicates.equal(null,15.22).apply(new DummyEntry(15.23)));
  assertTrue(Predicates.equal(null,15.22).apply(new DummyEntry(15.22)));
  assertFalse(Predicates.equal(null,16).apply(new DummyEntry(15)));
  assertTrue(Predicates.greaterThan(null,5).apply(new DummyEntry(6)));
  assertFalse(Predicates.greaterThan(null,5).apply(new DummyEntry(4)));
  assertFalse(Predicates.greaterThan(null,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.greaterThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.greaterThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.greaterEqual(null,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.lessThan(null,7).apply(new DummyEntry(6)));
  assertFalse(Predicates.lessThan(null,3).apply(new DummyEntry(4)));
  assertFalse(Predicates.lessThan(null,4).apply(new DummyEntry(4)));
  assertTrue(Predicates.lessThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.lessThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.lessEqual(null,4).apply(new DummyEntry(4)));
  assertTrue(Predicates.between(null,4,6).apply(new DummyEntry(5)));
  assertTrue(Predicates.between(null,5,6).apply(new DummyEntry(5)));
  assertTrue(Predicates.between(null,""String_Node_Str"",""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.between(null,""String_Node_Str"",""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.between(null,6,7).apply(new DummyEntry(5)));
  assertTrue(Predicates.in(null,4,7,8,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.in(null,5,7,8).apply(new DummyEntry(5)));
  assertFalse(Predicates.in(null,6,7,8).apply(new DummyEntry(5)));
  assertFalse(Predicates.in(null,6,7,8).apply(new DummyEntry(9)));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
}","@Test public void testEqual(){
  Employee value=new Employee(""String_Node_Str"",34,true,10D);
  value.setState(State.STATE2);
  Employee nullNameValue=new Employee(null,34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + State.STATE2).apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new SimpleDateFormat(DateHelperTest.DATE_FORMAT,Locale.US).format(new Date(0)) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new java.sql.Date(0) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new Timestamp(0) + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"" + new BigDecimal(""String_Node_Str"") + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",nullNameValue)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 40+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 34+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",-33,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(Predicates.equal(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.equal(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.equal(null,TRUE).apply(new DummyEntry(true)));
  assertTrue(Predicates.equal(null,true).apply(new DummyEntry(TRUE)));
  assertFalse(Predicates.equal(null,true).apply(new DummyEntry(FALSE)));
  assertTrue(Predicates.greaterThan(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertFalse(Predicates.equal(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertTrue(Predicates.equal(null,new BigDecimal(""String_Node_Str"")).apply(new DummyEntry(new BigDecimal(""String_Node_Str""))));
  assertFalse(Predicates.equal(null,15.22).apply(new DummyEntry(15.23)));
  assertTrue(Predicates.equal(null,15.22).apply(new DummyEntry(15.22)));
  assertFalse(Predicates.equal(null,16).apply(new DummyEntry(15)));
  assertTrue(Predicates.greaterThan(null,5).apply(new DummyEntry(6)));
  assertFalse(Predicates.greaterThan(null,5).apply(new DummyEntry(4)));
  assertFalse(Predicates.greaterThan(null,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.greaterThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.greaterThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.greaterEqual(null,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.lessThan(null,7).apply(new DummyEntry(6)));
  assertFalse(Predicates.lessThan(null,3).apply(new DummyEntry(4)));
  assertFalse(Predicates.lessThan(null,4).apply(new DummyEntry(4)));
  assertTrue(Predicates.lessThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.lessThan(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.lessEqual(null,4).apply(new DummyEntry(4)));
  assertTrue(Predicates.between(null,4,6).apply(new DummyEntry(5)));
  assertTrue(Predicates.between(null,5,6).apply(new DummyEntry(5)));
  assertTrue(Predicates.between(null,""String_Node_Str"",""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.between(null,""String_Node_Str"",""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.between(null,6,7).apply(new DummyEntry(5)));
  assertTrue(Predicates.in(null,4,7,8,5).apply(new DummyEntry(5)));
  assertTrue(Predicates.in(null,5,7,8).apply(new DummyEntry(5)));
  assertFalse(Predicates.in(null,6,7,8).apply(new DummyEntry(5)));
  assertFalse(Predicates.in(null,6,7,8).apply(new DummyEntry(9)));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertTrue(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
  assertFalse(Predicates.like(null,""String_Node_Str"").apply(new DummyEntry(""String_Node_Str"")));
}",0.9976707252514558
48710,"@Test public void testUtilDate(){
  final long now=System.currentTimeMillis();
  final Date date1=new Date(now);
  final Date date2=DateHelper.parseDate(date1.toString());
  Calendar cal1=Calendar.getInstance(Locale.US);
  cal1.setTimeInMillis(date1.getTime());
  Calendar cal2=Calendar.getInstance(Locale.US);
  cal2.setTimeInMillis(date2.getTime());
  Assert.assertEquals(cal1.get(Calendar.YEAR),cal2.get(Calendar.YEAR));
  Assert.assertEquals(cal1.get(Calendar.MONTH),cal2.get(Calendar.MONTH));
  Assert.assertEquals(cal1.get(Calendar.DAY_OF_MONTH),cal2.get(Calendar.DAY_OF_MONTH));
  Assert.assertEquals(cal1.get(Calendar.HOUR_OF_DAY),cal2.get(Calendar.HOUR_OF_DAY));
  Assert.assertEquals(cal1.get(Calendar.MINUTE),cal2.get(Calendar.MINUTE));
  Assert.assertEquals(cal1.get(Calendar.SECOND),cal2.get(Calendar.SECOND));
}","@Test public void testUtilDate(){
  final long now=System.currentTimeMillis();
  final Date date1=new Date(now);
  final Date date2=DateHelper.parseDate(new SimpleDateFormat(DateHelperTest.DATE_FORMAT,Locale.US).format(date1));
  Calendar cal1=Calendar.getInstance(Locale.US);
  cal1.setTimeInMillis(date1.getTime());
  Calendar cal2=Calendar.getInstance(Locale.US);
  cal2.setTimeInMillis(date2.getTime());
  Assert.assertEquals(cal1.get(Calendar.YEAR),cal2.get(Calendar.YEAR));
  Assert.assertEquals(cal1.get(Calendar.MONTH),cal2.get(Calendar.MONTH));
  Assert.assertEquals(cal1.get(Calendar.DAY_OF_MONTH),cal2.get(Calendar.DAY_OF_MONTH));
  Assert.assertEquals(cal1.get(Calendar.HOUR_OF_DAY),cal2.get(Calendar.HOUR_OF_DAY));
  Assert.assertEquals(cal1.get(Calendar.MINUTE),cal2.get(Calendar.MINUTE));
  Assert.assertEquals(cal1.get(Calendar.SECOND),cal2.get(Calendar.SECOND));
}",0.9519343493552168
48711,"@Override public void run() throws Exception {
  Member localMember=getNodeEngine().getLocalMember();
  ReplicatedMapService replicatedMapService=getService();
  for (  MemberMapPair replicatedMap : replicatedMaps) {
    String mapName=replicatedMap.getName();
    if (localMember.equals(replicatedMap.getMember())) {
      AbstractReplicatedRecordStore recordStorage=(AbstractReplicatedRecordStore)replicatedMapService.getReplicatedRecordStore(mapName,false);
      if (recordStorage != null && recordStorage.isLoaded()) {
        recordStorage.queueInitialFillup(getCallerAddress(),chunkSize);
      }
 else {
        OperationService operationService=getNodeEngine().getOperationService();
        Operation operation=new ReplicatedMapInitChunkOperation(mapName,localMember,true);
        operationService.send(operation,getCallerAddress());
      }
    }
  }
}","@Override public void run() throws Exception {
  Member localMember=getNodeEngine().getLocalMember();
  ReplicatedMapService replicatedMapService=getService();
  for (  MemberMapPair replicatedMap : replicatedMaps) {
    String mapName=replicatedMap.getName();
    if (localMember.equals(replicatedMap.getMember())) {
      AbstractReplicatedRecordStore recordStorage=(AbstractReplicatedRecordStore)replicatedMapService.getReplicatedRecordStore(mapName,false);
      if (recordStorage != null && recordStorage.isLoaded()) {
        recordStorage.queueInitialFillup(getCallerAddress(),chunkSize);
      }
 else {
        OperationService operationService=getNodeEngine().getOperationService();
        Operation operation=new ReplicatedMapInitChunkOperation(mapName,localMember);
        operationService.send(operation,getCallerAddress());
      }
    }
  }
}",0.9274521183981428
48712,"@Override public boolean containsKey(Object key){
  return invoke(new ClientReplicatedMapContainsKeyRequest(getName(),key));
}","@Override public boolean containsKey(Object key){
  return (Boolean)invoke(new ClientReplicatedMapContainsKeyRequest(getName(),key));
}",0.9655172413793104
48713,"@Override public boolean isEmpty(){
  return invoke(new ClientReplicatedMapIsEmptyRequest(getName()));
}","@Override public boolean isEmpty(){
  return (Boolean)invoke(new ClientReplicatedMapIsEmptyRequest(getName()));
}",0.9585253456221198
48714,"@Override public boolean containsValue(Object value){
  return invoke(new ClientReplicatedMapContainsValueRequest(getName(),value));
}","@Override public boolean containsValue(Object value){
  return (Boolean)invoke(new ClientReplicatedMapContainsValueRequest(getName(),value));
}",0.967509025270758
48715,"@Override public int size(){
  return invoke(new ClientReplicatedMapSizeRequest(getName()));
}","@Override public int size(){
  return (Integer)invoke(new ClientReplicatedMapSizeRequest(getName()));
}",0.9543147208121828
48716,"@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit){
  return scheduleWithFixedDelay(command,initialDelay,delay,unit);
}","@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit){
  return executorService.scheduleWithFixedDelay(command,initialDelay,delay,unit);
}",0.9591836734693876
48717,"@Override public void setReplicatorExecutorService(ExecutorService replicatorExecutorService){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void setReplicatorExecutorService(ScheduledExecutorService replicatorExecutorService){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9723076923076924
48718,"private void initNearCache(){
  if (nearCacheInitialized.compareAndSet(false,true)) {
    final NearCacheConfig nearCacheConfig=getContext().getClientConfig().getNearCacheConfig(name);
    if (nearCacheConfig == null) {
      return;
    }
    ClientNearCache<Data> _nearCache=new ClientNearCache<Data>(name,getContext(),nearCacheConfig);
    nearCache=_nearCache;
  }
}","private void initNearCache(){
  if (nearCacheInitialized.compareAndSet(false,true)) {
    final NearCacheConfig nearCacheConfig=getContext().getClientConfig().getNearCacheConfig(name);
    if (nearCacheConfig == null) {
      return;
    }
    ClientNearCache<Data> _nearCache=new ClientNearCache<Data>(name,ClientNearCacheType.Map,getContext(),nearCacheConfig);
    nearCache=_nearCache;
  }
}",0.9685863874345548
48719,"private void initNearCache(){
  if (nearCacheInitialized.compareAndSet(false,true)) {
    final NearCacheConfig nearCacheConfig=getContext().getClientConfig().getNearCacheConfig(getName());
    if (nearCacheConfig == null) {
      return;
    }
    ClientNearCache<Object> _nearCache=new ClientNearCache<Object>(getName(),getContext(),nearCacheConfig);
    nearCache=_nearCache;
  }
}","private void initNearCache(){
  if (nearCacheInitialized.compareAndSet(false,true)) {
    final NearCacheConfig nearCacheConfig=getContext().getClientConfig().getNearCacheConfig(getName());
    if (nearCacheConfig == null) {
      return;
    }
    ClientNearCache<Object> _nearCache=new ClientNearCache<Object>(getName(),ClientNearCacheType.ReplicatedMap,getContext(),nearCacheConfig);
    nearCache=_nearCache;
  }
}",0.9576059850374063
48720,"@Override public Set<Entry<K,V>> entrySet(){
  return invoke(new ClientReplicatedMapEntrySetRequest(getName()));
}","@Override public Set<Entry<K,V>> entrySet(){
  return ((ReplicatedMapEntrySet)invoke(new ClientReplicatedMapEntrySetRequest(getName()))).getEntrySet();
}",0.8539325842696629
48721,"@Override public Collection<V> values(){
  return invoke(new ClientReplicatedMapValuesRequest(getName()));
}","@Override public Collection<V> values(){
  return ((ReplicatedMapValueCollection)invoke(new ClientReplicatedMapValuesRequest(getName()))).getValues();
}",0.8307692307692308
48722,"@Override public Set<K> keySet(){
  return invoke(new ClientReplicatedMapKeySetRequest(getName()));
}","@Override public Set<K> keySet(){
  return ((ReplicatedMapKeySet)invoke(new ClientReplicatedMapKeySetRequest(getName()))).getKeySet();
}",0.8523206751054853
48723,"@Override public void onMessage(Message<ReplicationMessage> message){
  ReplicationMessage replicationMessage=message.getMessageObject();
  ReplicatedRecordStore replicatedRecordStorage=replicatedStorages.get(replicationMessage.getName());
  if (replicatedRecordStorage instanceof AbstractReplicatedRecordStorage) {
    ((AbstractReplicatedRecordStorage)replicatedRecordStorage).queueUpdateMessage(replicationMessage);
  }
}","public void onMessage(ReplicationMessage replicationMessage){
  ReplicatedRecordStore replicatedRecordStorage=replicatedStorages.get(replicationMessage.getName());
  if (replicatedRecordStorage instanceof AbstractReplicatedRecordStorage) {
    ((AbstractReplicatedRecordStorage)replicatedRecordStorage).queueUpdateMessage(replicationMessage);
  }
}",0.8212435233160622
48724,"@Override public void shutdown(boolean terminate){
  eventService.deregisterListener(SERVICE_NAME,EVENT_TOPIC_NAME,eventRegistration.getId());
  for (  ReplicatedRecordStore replicatedRecordStore : replicatedStorages.values()) {
    replicatedRecordStore.destroy();
  }
  replicatedStorages.clear();
}","@Override public void shutdown(boolean terminate){
  for (  ReplicatedRecordStore replicatedRecordStore : replicatedStorages.values()) {
    replicatedRecordStore.destroy();
  }
  replicatedStorages.clear();
}",0.8196078431372549
48725,"public AbstractReplicatedRecordStorage(String name,NodeEngine nodeEngine,CleanerRegistrator cleanerRegistrator,ReplicatedMapService replicatedMapService){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.localMember=nodeEngine.getLocalMember();
  this.localMemberHash=localMember.getUuid().hashCode();
  this.eventService=nodeEngine.getEventService();
  this.replicatedMapService=replicatedMapService;
  this.replicatedMapConfig=replicatedMapService.getReplicatedMapConfig(name);
  this.replicationTopicName=ReplicatedMapService.SERVICE_NAME + ""String_Node_Str"";
  this.executorService=getExecutorService(replicatedMapConfig);
  this.mutexes=new Object[replicatedMapConfig.getConcurrencyLevel()];
  for (int i=0; i < mutexes.length; i++) {
    mutexes[i]=new Object();
  }
  this.cleanerFuture=cleanerRegistrator.registerCleaner(this);
}","public AbstractReplicatedRecordStorage(String name,NodeEngine nodeEngine,CleanerRegistrator cleanerRegistrator,ReplicatedMapService replicatedMapService){
  this.name=name;
  this.nodeEngine=nodeEngine;
  this.localMember=nodeEngine.getLocalMember();
  this.localMemberHash=localMember.getUuid().hashCode();
  this.eventService=nodeEngine.getEventService();
  this.replicatedMapService=replicatedMapService;
  this.replicatedMapConfig=replicatedMapService.getReplicatedMapConfig(name);
  this.executorService=getExecutorService(replicatedMapConfig);
  this.mutexes=new Object[replicatedMapConfig.getConcurrencyLevel()];
  for (int i=0; i < mutexes.length; i++) {
    mutexes[i]=new Object();
  }
  this.cleanerFuture=cleanerRegistrator.registerCleaner(this);
}",0.9482220835932628
48726,"@Override public Object put(Object key,Object value){
  V oldValue=null;
  Object marshalledKey=marshallKey(key);
  Object marshalledValue=marshallValue(value);
synchronized (getMutex(marshalledKey)) {
    final ReplicatedRecord old=storage.get(marshalledKey);
    final Vector vector;
    if (old == null) {
      vector=new Vector();
      ReplicatedRecord<K,V> record=new ReplicatedRecord(marshalledKey,marshalledValue,vector,localMemberHash);
      storage.put((K)key,record);
    }
 else {
      oldValue=(V)old.getValue();
      vector=old.getVector();
      storage.get(key).setValue((V)marshalledValue,localMemberHash);
    }
    incrementClock(vector);
    publishReplicatedMessage(new ReplicationMessage(name,key,value,vector,localMember,localMemberHash));
  }
  return unmarshallValue(oldValue);
}","@Override public Object put(Object key,Object value){
  V oldValue=null;
  K marshalledKey=(K)marshallKey(key);
  V marshalledValue=(V)marshallValue(value);
synchronized (getMutex(marshalledKey)) {
    final ReplicatedRecord old=storage.get(marshalledKey);
    final Vector vector;
    if (old == null) {
      vector=new Vector();
      ReplicatedRecord<K,V> record=new ReplicatedRecord(marshalledKey,marshalledValue,vector,localMemberHash);
      storage.put(marshalledKey,record);
    }
 else {
      oldValue=(V)old.getValue();
      vector=old.getVector();
      storage.get(marshalledKey).setValue(marshalledValue,localMemberHash);
    }
    incrementClock(vector);
    publishReplicatedMessage(new ReplicationMessage(name,key,value,vector,localMember,localMemberHash));
  }
  return unmarshallValue(oldValue);
}",0.5264452644526445
48727,"protected void publishReplicatedMessage(IdentifiedDataSerializable message){
  Collection<EventRegistration> registrations=eventService.getRegistrations(ReplicatedMapService.SERVICE_NAME,replicationTopicName);
  eventService.publishEvent(ReplicatedMapService.SERVICE_NAME,registrations,message,name.hashCode());
}","protected void publishReplicatedMessage(IdentifiedDataSerializable message){
  Collection<EventRegistration> registrations=eventService.getRegistrations(ReplicatedMapService.SERVICE_NAME,ReplicatedMapService.EVENT_TOPIC_NAME);
  eventService.publishEvent(ReplicatedMapService.SERVICE_NAME,registrations,message,name.hashCode());
}",0.917573872472784
48728,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Map<String,String> properties=new LinkedHashMap<String,String>();
  Runtime runtime=Runtime.getRuntime();
  RuntimeMXBean runtimeMxBean=ManagementFactory.getRuntimeMXBean();
  final PartitionServiceImpl partitionService=mcs.getHazelcastInstance().node.getPartitionService();
  properties.put(""String_Node_Str"",mcs.getHazelcastInstance().node.initializer.getVersion());
  properties.put(""String_Node_Str"",Long.toString(runtimeMxBean.getStartTime()));
  properties.put(""String_Node_Str"",Long.toString(runtimeMxBean.getUptime()));
  properties.put(""String_Node_Str"",Long.toString(runtime.freeMemory()));
  properties.put(""String_Node_Str"",Long.toString(runtime.totalMemory()));
  properties.put(""String_Node_Str"",Long.toString(runtime.maxMemory()));
  properties.put(""String_Node_Str"",Boolean.toString(partitionService.hasOnGoingMigration()));
  properties.put(""String_Node_Str"",Long.toString(partitionService.getMigrationQueueSize()));
  dos.writeInt(properties.size());
  for (  Object property : properties.keySet()) {
    dos.writeUTF((String)property + ""String_Node_Str"" + (String)properties.get(property));
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Map<String,String> properties=new LinkedHashMap<String,String>();
  Runtime runtime=Runtime.getRuntime();
  RuntimeMXBean runtimeMxBean=ManagementFactory.getRuntimeMXBean();
  final PartitionServiceImpl partitionService=mcs.getHazelcastInstance().node.getPartitionService();
  properties.put(""String_Node_Str"",mcs.getHazelcastInstance().node.initializer.getVersion());
  properties.put(""String_Node_Str"",Long.toString(runtimeMxBean.getStartTime()));
  properties.put(""String_Node_Str"",Long.toString(runtimeMxBean.getUptime()));
  properties.put(""String_Node_Str"",Long.toString(runtime.freeMemory()));
  properties.put(""String_Node_Str"",Long.toString(runtime.totalMemory()));
  properties.put(""String_Node_Str"",Long.toString(runtime.maxMemory()));
  properties.put(""String_Node_Str"",Boolean.toString(partitionService.hasOnGoingMigration()));
  properties.put(""String_Node_Str"",Long.toString(partitionService.getMigrationQueueSize()));
  dos.writeInt(properties.size());
  for (  Map.Entry<String,String> entry : properties.entrySet()) {
    dos.writeUTF(entry.getKey() + ""String_Node_Str"" + entry.getValue());
  }
}",0.9500619067271976
48729,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  IMap map=mcs.getHazelcastInstance().getMap(mapName);
  EntryView entry=null;
  if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(key);
  }
 else   if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(Long.valueOf(key));
  }
 else   if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(Integer.valueOf(key));
  }
  TreeMap result=new TreeMap();
  if (entry == null) {
    result.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Object value=entry.getValue();
    result.put(""String_Node_Str"",value != null ? value.toString() : ""String_Node_Str"");
    result.put(""String_Node_Str"",value != null ? value.getClass().getName() : ""String_Node_Str"");
    result.put(""String_Node_Str"",Long.toString(entry.getCost()));
    result.put(""String_Node_Str"",Long.toString(entry.getCreationTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getExpirationTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getHits()));
    result.put(""String_Node_Str"",Long.toString(entry.getLastAccessTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getLastUpdateTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getVersion()));
  }
  dos.writeInt(result.size());
  for (  Object property : result.keySet()) {
    dos.writeUTF(property + ""String_Node_Str"" + result.get(property));
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  IMap map=mcs.getHazelcastInstance().getMap(mapName);
  EntryView entry=null;
  if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(key);
  }
 else   if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(Long.valueOf(key));
  }
 else   if (type.equals(""String_Node_Str"")) {
    entry=map.getEntryView(Integer.valueOf(key));
  }
  TreeMap<String,String> result=new TreeMap<String,String>();
  if (entry == null) {
    result.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Object value=entry.getValue();
    result.put(""String_Node_Str"",value != null ? value.toString() : ""String_Node_Str"");
    result.put(""String_Node_Str"",value != null ? value.getClass().getName() : ""String_Node_Str"");
    result.put(""String_Node_Str"",Long.toString(entry.getCost()));
    result.put(""String_Node_Str"",Long.toString(entry.getCreationTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getExpirationTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getHits()));
    result.put(""String_Node_Str"",Long.toString(entry.getLastAccessTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getLastUpdateTime()));
    result.put(""String_Node_Str"",Long.toString(entry.getVersion()));
  }
  dos.writeInt(result.size());
  for (  Map.Entry<String,String> propertyEntry : result.entrySet()) {
    dos.writeUTF(propertyEntry.getKey() + ""String_Node_Str"" + propertyEntry.getValue());
  }
}",0.9518680578929654
48730,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Properties properties=System.getProperties();
  dos.writeInt(properties.size());
  for (  Object property : properties.keySet()) {
    dos.writeUTF((String)property + ""String_Node_Str"" + (String)properties.get(property));
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Properties properties=System.getProperties();
  dos.writeInt(properties.size());
  for (  Map.Entry entry : properties.entrySet()) {
    dos.writeUTF(entry.getKey() + ""String_Node_Str"" + entry.getValue());
  }
}",0.8259493670886076
48731,"private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    TestUtil.terminateInstance(instances[ix]);
    instances[ix]=null;
    checkMapSizes(mapSize,backupCount,instances);
  }
}","private void testBackupMigrationAndRecovery(int nodeCount,int backupCount,int mapSize) throws Exception {
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(nodeCount);
  final String name=MAP_NAME;
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,""String_Node_Str"");
  config.getMapConfig(name).setBackupCount(backupCount).setStatisticsEnabled(true);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  instances[0]=hz;
  IMap map1=hz.getMap(name);
  for (int i=0; i < mapSize; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  checkMapSizes(mapSize,backupCount,instances);
  for (int i=1; i < nodeCount; i++) {
    instances[i]=nodeFactory.newHazelcastInstance(config);
    checkMapSizes(mapSize,backupCount,instances);
  }
  final Random rand=new Random();
  for (int i=1; i < nodeCount; i++) {
    int ix;
    do {
      ix=rand.nextInt(nodeCount);
    }
 while (instances[ix] == null);
    final CountDownLatch latch=new CountDownLatch(1);
    instances[ix].getLifecycleService().addLifecycleListener(new LifecycleListener(){
      @Override public void stateChanged(      LifecycleEvent event){
        if (event.getState().equals(LifecycleEvent.LifecycleState.SHUTDOWN)) {
          latch.countDown();
        }
      }
    }
);
    instances[ix].getLifecycleService().shutdown();
    instances[ix]=null;
    Thread.sleep(3000);
    checkMapSizes(mapSize,backupCount,instances);
  }
}",0.8390889052167524
48732,"private static void checkMapSizes(final int expectedSize,int backupCount,HazelcastInstance... instances) throws InterruptedException {
  int nodeCount=0;
  final IMap[] maps=new IMap[instances.length];
  for (int i=0; i < 20; i++) {
    for (int j=0; j < instances.length; j++) {
      final HazelcastInstance hz=instances[j];
      if (hz != null) {
        if (i == 0) {
          maps[j]=hz.getMap(MAP_NAME);
          nodeCount++;
        }
        assertEquals(expectedSize,maps[j].size());
      }
    }
    Thread.sleep(10);
  }
  final int expectedBackupSize=Math.min(nodeCount - 1,backupCount) * expectedSize;
  for (int i=0; i < 100; i++) {
    long ownedSize=getTotalOwnedEntryCount(maps);
    long backupSize=getTotalBackupEntryCount(maps);
    if (ownedSize == expectedSize && backupSize == expectedBackupSize) {
      int votes=0;
      for (      HazelcastInstance hz : instances) {
        if (hz != null) {
          votes+=TestUtil.getNode(hz).getPartitionService().hasOnGoingMigration() ? 0 : 1;
        }
      }
      if (votes == nodeCount) {
        break;
      }
    }
    Thread.sleep(250);
  }
  long backupSize=getTotalBackupEntryCount(maps);
  assertEquals(""String_Node_Str"" + nodeCount,expectedBackupSize,backupSize);
}","private static void checkMapSizes(final int expectedSize,int backupCount,HazelcastInstance... instances) throws InterruptedException {
  int nodeCount=0;
  final IMap[] maps=new IMap[instances.length];
  for (int i=0; i < 20; i++) {
    for (int j=0; j < instances.length; j++) {
      final HazelcastInstance hz=instances[j];
      if (hz != null) {
        if (i == 0) {
          maps[j]=hz.getMap(MAP_NAME);
          nodeCount++;
        }
        assertEquals(expectedSize,maps[j].size());
      }
    }
    Thread.sleep(10);
  }
  final int expectedBackupSize=Math.min(nodeCount - 1,backupCount) * expectedSize;
  for (int i=0; i < 1200; i++) {
    long ownedSize=getTotalOwnedEntryCount(maps);
    long backupSize=getTotalBackupEntryCount(maps);
    if (ownedSize == expectedSize && backupSize == expectedBackupSize) {
      int votes=0;
      for (      HazelcastInstance hz : instances) {
        if (hz != null) {
          votes+=TestUtil.getNode(hz).getPartitionService().hasOnGoingMigration() ? 0 : 1;
        }
      }
      if (votes == nodeCount) {
        break;
      }
    }
    Thread.sleep(500);
  }
  long backupSize=getTotalBackupEntryCount(maps);
  assertEquals(""String_Node_Str"" + nodeCount,expectedBackupSize,backupSize);
}",0.9987995198079233
48733,"public GroupProperties(Config config){
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  SERIALIZATION_GZIP_ENABLED=new GroupProperty(config,PROP_SERIALIZATION_GZIP_ENABLED,""String_Node_Str"");
  SERIALIZATION_READ_SHARED_ENABLED=new GroupProperty(config,PROP_SERIALIZATION_READ_SHARED_ENABLED,""String_Node_Str"");
  SERIALIZATION_BUFFER_SIZE=new GroupProperty(config,PROP_SERIALIZATION_BUFFER_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}","public GroupProperties(Config config){
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}",0.9736590038314176
48734,"public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setInitialOutputBufferSize(groupProperties.SERIALIZATION_BUFFER_SIZE.getInteger()).setEnableCompression(groupProperties.SERIALIZATION_GZIP_ENABLED.getBoolean()).setEnableSharedObject(groupProperties.SERIALIZATION_READ_SHARED_ENABLED.getBoolean()).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address));
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new PartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}","public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address));
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new PartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}",0.9641199773627618
48735,"public GroupProperties(Config config){
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  SERIALIZATION_GZIP_ENABLED=new GroupProperty(config,PROP_SERIALIZATION_GZIP_ENABLED,""String_Node_Str"");
  SERIALIZATION_READ_SHARED_ENABLED=new GroupProperty(config,PROP_SERIALIZATION_READ_SHARED_ENABLED,""String_Node_Str"");
  SERIALIZATION_BUFFER_SIZE=new GroupProperty(config,PROP_SERIALIZATION_BUFFER_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}","public GroupProperties(Config config){
  HEALTH_MONITORING_LEVEL=new GroupProperty(config,PROP_HEALTH_MONITORING_LEVEL,HealthMonitorLevel.SILENT.toString());
  HEALTH_MONITORING_DELAY_SECONDS=new GroupProperty(config,PROP_HEALTH_MONITORING_DELAY_SECONDS,""String_Node_Str"");
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  PREFER_IPv4_STACK=new GroupProperty(config,PROP_PREFER_IPv4_STACK,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  OPERATION_THREAD_COUNT=new GroupProperty(config,PROP_OPERATION_THREAD_COUNT,""String_Node_Str"");
  EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EVENT_THREAD_COUNT,""String_Node_Str"");
  EVENT_QUEUE_CAPACITY=new GroupProperty(config,PROP_EVENT_QUEUE_CAPACITY,""String_Node_Str"");
  EVENT_QUEUE_TIMEOUT_MILLIS=new GroupProperty(config,PROP_EVENT_QUEUE_TIMEOUT_MILLIS,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  OPERATION_CALL_TIMEOUT_MILLIS=new GroupProperty(config,PROP_OPERATION_CALL_TIMEOUT_MILLIS,""String_Node_Str"");
  final GroupProperty SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_SERVER_BIND_ANY=new GroupProperty(config,PROP_SOCKET_SERVER_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND_ANY=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND_ANY,SOCKET_BIND_ANY);
  SOCKET_CLIENT_BIND=new GroupProperty(config,PROP_SOCKET_CLIENT_BIND,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_JOIN_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_SECONDS,""String_Node_Str"");
  MAX_JOIN_MERGE_TARGET_SECONDS=new GroupProperty(config,PROP_MAX_JOIN_MERGE_TARGET_SECONDS,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  MASTER_CONFIRMATION_INTERVAL_SECONDS=new GroupProperty(config,PROP_MASTER_CONFIRMATION_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_MASTER_CONFIRMATION_SECONDS=new GroupProperty(config,PROP_MAX_NO_MASTER_CONFIRMATION_SECONDS,""String_Node_Str"");
  MEMBER_LIST_PUBLISH_INTERVAL_SECONDS=new GroupProperty(config,PROP_MEMBER_LIST_PUBLISH_INTERVAL_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  ICMP_TIMEOUT=new GroupProperty(config,PROP_ICMP_TIMEOUT,""String_Node_Str"");
  ICMP_TTL=new GroupProperty(config,PROP_ICMP_TTL,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  PARTITION_COUNT=new GroupProperty(config,PROP_PARTITION_COUNT,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  MC_URL_CHANGE_ENABLED=new GroupProperty(config,PROP_MC_URL_CHANGE_ENABLED,""String_Node_Str"");
  CONNECTION_MONITOR_INTERVAL=new GroupProperty(config,PROP_CONNECTION_MONITOR_INTERVAL,""String_Node_Str"");
  CONNECTION_MONITOR_MAX_FAULTS=new GroupProperty(config,PROP_CONNECTION_MONITOR_MAX_FAULTS,""String_Node_Str"");
  PARTITION_MIGRATION_INTERVAL=new GroupProperty(config,PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  PARTITION_MIGRATION_TIMEOUT=new GroupProperty(config,PROP_PARTITION_MIGRATION_TIMEOUT,""String_Node_Str"");
  PARTITION_MIGRATION_ZIP_ENABLED=new GroupProperty(config,PROP_PARTITION_MIGRATION_ZIP_ENABLED,""String_Node_Str"");
  PARTITION_TABLE_SEND_INTERVAL=new GroupProperty(config,PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  PARTITIONING_STRATEGY_CLASS=new GroupProperty(config,PROP_PARTITIONING_STRATEGY_CLASS,""String_Node_Str"");
  GRACEFUL_SHUTDOWN_MAX_WAIT=new GroupProperty(config,PROP_GRACEFUL_SHUTDOWN_MAX_WAIT,""String_Node_Str"");
  SYSTEM_LOG_ENABLED=new GroupProperty(config,PROP_SYSTEM_LOG_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_SHARED_STORAGE=new GroupProperty(config,PROP_ELASTIC_MEMORY_SHARED_STORAGE,""String_Node_Str"");
  ELASTIC_MEMORY_UNSAFE_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_UNSAFE_ENABLED,""String_Node_Str"");
  ENTERPRISE_LICENSE_KEY=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_KEY);
}",0.9736590038314176
48736,"public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setInitialOutputBufferSize(groupProperties.SERIALIZATION_BUFFER_SIZE.getInteger()).setEnableCompression(groupProperties.SERIALIZATION_GZIP_ENABLED.getBoolean()).setEnableSharedObject(groupProperties.SERIALIZATION_READ_SHARED_ENABLED.getBoolean()).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address));
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new PartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}","public Node(HazelcastInstanceImpl hazelcastInstance,Config config,NodeContext nodeContext){
  this.hazelcastInstance=hazelcastInstance;
  this.threadGroup=hazelcastInstance.threadGroup;
  this.config=config;
  configClassLoader=config.getClassLoader();
  this.groupProperties=new GroupProperties(config);
  SerializationService ss;
  try {
    String partitioningStrategyClassName=groupProperties.PARTITIONING_STRATEGY_CLASS.getString();
    final PartitioningStrategy partitioningStrategy;
    if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
      partitioningStrategy=ClassLoaderUtil.newInstance(configClassLoader,partitioningStrategyClassName);
    }
 else {
      partitioningStrategy=new DefaultPartitioningStrategy();
    }
    ss=new SerializationServiceBuilder().setClassLoader(configClassLoader).setConfig(config.getSerializationConfig() != null ? config.getSerializationConfig() : new SerializationConfig()).setManagedContext(hazelcastInstance.managedContext).setPartitioningStrategy(partitioningStrategy).setHazelcastInstance(hazelcastInstance).build();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
  serializationService=(SerializationServiceImpl)ss;
  systemLogService=new SystemLogService(groupProperties.SYSTEM_LOG_ENABLED.getBoolean());
  final AddressPicker addressPicker=nodeContext.createAddressPicker(this);
  try {
    addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
  final ServerSocketChannel serverSocketChannel=addressPicker.getServerSocketChannel();
  address=addressPicker.getPublicAddress();
  localMember=new MemberImpl(address,true,UuidUtil.createMemberUuid(address));
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  logger=loggingService.getLogger(Node.class.getName());
  initializer=NodeInitializerFactory.create(configClassLoader);
  try {
    initializer.beforeInitialize(this);
  }
 catch (  Throwable e) {
    try {
      serverSocketChannel.close();
    }
 catch (    Throwable ignored) {
    }
    throw ExceptionUtil.rethrow(e);
  }
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  nodeEngine=new NodeEngineImpl(this);
  clientEngine=new ClientEngineImpl(this);
  connectionManager=nodeContext.createConnectionManager(this,serverSocketChannel);
  partitionService=new PartitionServiceImpl(this);
  clusterService=new ClusterServiceImpl(this);
  textCommandService=new TextCommandServiceImpl(this);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  JoinConfig join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        final Address bindAddress=addressPicker.getBindAddress();
        if (!bindAddress.getInetAddress().isLoopbackAddress()) {
          multicastSocket.setInterface(bindAddress.getInetAddress());
        }
      }
 catch (      Exception e) {
        logger.warning(e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.severe(e);
  }
  this.multicastService=mcService;
  initializeListeners(config);
  joiner=nodeContext.createJoiner(this);
}",0.9641199773627618
48737,"@Test public void testAsyncRemove() throws Exception {
  fillMap();
  Future f=map.removeAsync(""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(9,map.size());
}","@Test public void testAsyncRemove() throws Exception {
  fillMap();
  Future f=map.removeAsync(""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(9,map.size());
}",0.7822736030828517
48738,"@Test public void testAsyncGet() throws Exception {
  fillMap();
  Future f=map.getAsync(""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
}","@Test public void testAsyncGet() throws Exception {
  fillMap();
  Future f=map.getAsync(""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
}",0.7472035794183445
48739,"@Test public void testAsyncPut() throws Exception {
  fillMap();
  Future f=map.putAsync(""String_Node_Str"",""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testAsyncPut() throws Exception {
  fillMap();
  Future f=map.putAsync(""String_Node_Str"",""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}",0.8138385502471169
48740,"@Test public void testAsyncRemove() throws Exception {
  fillMap();
  Future f=map.removeAsync(""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(9,map.size());
}","@Test public void testAsyncRemove() throws Exception {
  fillMap();
  Future f=map.removeAsync(""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(9,map.size());
}",0.7822736030828517
48741,"@Test public void testAsyncPut() throws Exception {
  fillMap();
  Future f=map.putAsync(""String_Node_Str"",""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testAsyncPut() throws Exception {
  fillMap();
  Future f=map.putAsync(""String_Node_Str"",""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}",0.8138385502471169
48742,"@Test public void testAsyncGet() throws Exception {
  fillMap();
  Future f=map.getAsync(""String_Node_Str"");
  Object o=null;
  try {
    o=f.get(0,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
  }
  assertNull(o);
  o=f.get();
  assertEquals(""String_Node_Str"",o);
}","@Test public void testAsyncGet() throws Exception {
  fillMap();
  Future f=map.getAsync(""String_Node_Str"");
  Object o=f.get();
  assertEquals(""String_Node_Str"",o);
}",0.7472035794183445
48743,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapEntry.getValue());
    entryProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
  }
}","public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
  }
}",0.9566265060240964
48744,"public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  final Object valueBeforeProcess=mapService.toObject(dataOldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (dataOldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (dataOldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}","public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9069767441860463
48745,"public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}","public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.974493132766514
48746,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9461312438785504
48747,"@Test @Category(SerialTest.class) public void testOneMemberWriteBehindWithEvictions() throws Exception {
  TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  Config config=newConfig(testMapStore,2);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  IMap map=h1.getMap(""String_Node_Str"");
  assertEquals(TestEventBasedMapStore.STORE_EVENTS.LOAD_ALL_KEYS,testMapStore.waitForEvent(30));
  for (int i=0; i < 100; i++) {
    map.put(i,""String_Node_Str"" + i);
    assertEquals(TestEventBasedMapStore.STORE_EVENTS.LOAD,testMapStore.waitForEvent(30));
  }
  assertEquals(TestEventBasedMapStore.STORE_EVENTS.STORE_ALL,testMapStore.waitForEvent(30));
  assertEquals(100,testMapStore.getStore().size());
  for (int i=0; i < 100; i++) {
    map.evict(i);
  }
  assertEquals(null,testMapStore.waitForEvent(30));
  assertEquals(100,testMapStore.getStore().size());
  for (int i=0; i < 100; i++) {
    map.put(i,""String_Node_Str"" + i);
    assertEquals(TestEventBasedMapStore.STORE_EVENTS.LOAD,testMapStore.waitForEvent(30));
  }
  for (int i=0; i < 100; i++) {
    map.evict(i);
    assertEquals(TestEventBasedMapStore.STORE_EVENTS.STORE,testMapStore.waitForEvent(30));
  }
  assertEquals(null,testMapStore.waitForEvent(2));
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(0,map.size());
  for (int i=0; i < 100; i++) {
    map.put(i,""String_Node_Str"" + i);
    assertEquals(TestEventBasedMapStore.STORE_EVENTS.LOAD,testMapStore.waitForEvent(30));
  }
  for (int i=0; i < 100; i++) {
    map.remove(i);
  }
  assertEquals(TestEventBasedMapStore.STORE_EVENTS.STORE_ALL,testMapStore.waitForEvent(30));
  assertEquals(TestEventBasedMapStore.STORE_EVENTS.DELETE_ALL,testMapStore.waitForEvent(30));
  assertEquals(0,testMapStore.getStore().size());
  assertEquals(0,map.size());
  assertEquals(null,testMapStore.waitForEvent(30));
}","@Test @Category(SerialTest.class) public void testOneMemberWriteBehindWithEvictions() throws Exception {
  final String mapName=""String_Node_Str"";
  final TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  testMapStore.loadAllLatch=new CountDownLatch(1);
  final Config config=newConfig(testMapStore,2);
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance node1=nodeFactory.newHazelcastInstance(config);
  final IMap map=node1.getMap(mapName);
  assertTrue(""String_Node_Str"",testMapStore.loadAllLatch.await(10,TimeUnit.SECONDS));
  final int populationCount=100;
  testMapStore.storeLatch=new CountDownLatch(populationCount);
  for (int i=0; i < populationCount; i++) {
    map.put(i,""String_Node_Str"" + i);
  }
  assertTrue(testMapStore.storeLatch.await(10,TimeUnit.SECONDS));
  testMapStore.storeLatch=new CountDownLatch(populationCount);
  for (int i=0; i < populationCount; i++) {
    map.evict(i);
  }
  assertEquals(populationCount,testMapStore.storeLatch.getCount());
  assertEquals(populationCount,testMapStore.getStore().size());
  assertEquals(0,map.size());
  for (int i=0; i < populationCount; i++) {
    map.put(i,""String_Node_Str"" + i);
  }
  for (int i=0; i < populationCount; i++) {
    map.evict(i);
  }
  testMapStore.storeLatch.await(10,TimeUnit.SECONDS);
  assertEquals(populationCount,testMapStore.getStore().size());
  assertEquals(0,map.size());
  for (int i=0; i < populationCount; i++) {
    map.put(i,""String_Node_Str"" + i);
  }
  testMapStore.deleteLatch=new CountDownLatch(populationCount);
  for (int i=0; i < populationCount; i++) {
    map.remove(i);
  }
  testMapStore.deleteLatch.await(10,TimeUnit.SECONDS);
  assertEquals(0,map.size());
}",0.2605633802816901
48748,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapEntry.getValue());
    entryProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
  }
}","public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryForBackup(dataKey);
  if (mapEntry.getValue() != null) {
    Map.Entry<Object,Object> entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
    entryProcessor.processBackup(entry);
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
  }
}",0.9566265060240964
48749,"public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  final Object valueBeforeProcess=mapService.toObject(dataOldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (dataOldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (dataOldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}","public void run(){
  oldValue=recordStore.getMapEntry(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9069767441860463
48750,"public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}","public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.974493132766514
48751,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9409448818897638
48752,"@Override public boolean contains(E expected){
  return invoke(new ContainsRequest(name,toData(expected)));
}","@Override public boolean contains(E expected){
  return (Boolean)invoke(new ContainsRequest(name,toData(expected)));
}",0.960352422907489
48753,"@Override public boolean compareAndSet(E expect,E update){
  return invoke(new CompareAndSetRequest(name,toData(expect),toData(update)));
}","@Override public boolean compareAndSet(E expect,E update){
  return (Boolean)invoke(new CompareAndSetRequest(name,toData(expect),toData(update)));
}",0.9686411149825784
48754,"@Override public boolean isNull(){
  return invoke(new IsNullRequest(name));
}","@Override public boolean isNull(){
  return (Boolean)invoke(new IsNullRequest(name));
}",0.9454545454545454
48755,"public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  Map<String,Data> data=new HashMap<String,Data>();
  final int partitionId=event.getPartitionId();
  for (  String name : references.keySet()) {
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name))) {
    }
  }
  return data.isEmpty() ? null : new AtomicReferenceReplicationOperation(data);
}","public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  Map<String,Data> data=new HashMap<String,Data>();
  final int partitionId=event.getPartitionId();
  for (  String name : references.keySet()) {
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name))) {
      data.put(name,references.get(name).get());
    }
  }
  return data.isEmpty() ? null : new AtomicReferenceReplicationOperation(data);
}",0.95311004784689
48756,"@Override public boolean contains(E expected){
  NodeEngine nodeEngine=getNodeEngine();
  Operation operation=new ContainsOperation(name,nodeEngine.toData(expected));
  return invoke(operation,nodeEngine);
}","@Override public boolean contains(E expected){
  NodeEngine nodeEngine=getNodeEngine();
  Operation operation=new ContainsOperation(name,nodeEngine.toData(expected));
  return (Boolean)invoke(operation,nodeEngine);
}",0.9787234042553192
48757,"@Override public boolean compareAndSet(E expect,E update){
  NodeEngine nodeEngine=getNodeEngine();
  Operation operation=new CompareAndSetOperation(name,nodeEngine.toData(expect),nodeEngine.toData(update));
  return invoke(operation,nodeEngine);
}","@Override public boolean compareAndSet(E expect,E update){
  NodeEngine nodeEngine=getNodeEngine();
  Operation operation=new CompareAndSetOperation(name,nodeEngine.toData(expect),nodeEngine.toData(update));
  return (Boolean)invoke(operation,nodeEngine);
}",0.9821782178217822
48758,"@Override public boolean isNull(){
  Operation operation=new IsNullOperation(name);
  return invoke(operation,getNodeEngine());
}","@Override public boolean isNull(){
  Operation operation=new IsNullOperation(name);
  return (Boolean)invoke(operation,getNodeEngine());
}",0.9662921348314608
48759,"@Test public void testGetAllKeys() throws Exception {
  TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  Map store=testMapStore.getStore();
  Set keys=new HashSet();
  int size=1000;
  for (int i=0; i < size; i++) {
    store.put(i,""String_Node_Str"" + i);
    keys.add(i);
  }
  Config config=newConfig(testMapStore,2);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  Thread.sleep(10000);
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(""String_Node_Str"",map3.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
  assertEquals(1000,map3.size());
  h3.getLifecycleService().shutdown();
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
}","@Test public void testGetAllKeys() throws Exception {
  TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  Map store=testMapStore.getStore();
  Set keys=new HashSet();
  int size=1000;
  for (int i=0; i < size; i++) {
    store.put(i,""String_Node_Str"" + i);
    keys.add(i);
  }
  Config config=newConfig(testMapStore,2);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);
  HazelcastInstance h1=nodeFactory.newHazelcastInstance(config);
  HazelcastInstance h2=nodeFactory.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  checkIfMapLoaded(""String_Node_Str"",h1);
  checkIfMapLoaded(""String_Node_Str"",h2);
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
  HazelcastInstance h3=nodeFactory.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  checkIfMapLoaded(""String_Node_Str"",h3);
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(""String_Node_Str"",map3.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
  assertEquals(1000,map3.size());
  h3.getLifecycleService().shutdown();
  assertEquals(""String_Node_Str"",map1.get(1));
  assertEquals(""String_Node_Str"",map2.get(1));
  assertEquals(1000,map1.size());
  assertEquals(1000,map2.size());
}",0.9510390982740402
48760,"public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  final Object valueBeforeProcess=mapService.toObject(dataOldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (dataOldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (dataOldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}","public void run(){
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  oldValue=isInMemoryObjectFormat ? recordStore.getMapEntryObject(dataKey).getValue() : recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.6338998621956822
48761,"public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}","public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.974493132766514
48762,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.9461312438785504
48763,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.8962418300653595
48764,"public void clearNearCache(String mapName){
  NearCache nearCache=getNearCache(mapName);
  nearCache.clear();
}","public void clearNearCache(String mapName){
  final NearCache nearCache=nearCacheMap.get(mapName);
  if (nearCache != null) {
    nearCache.clear();
  }
}",0.8075471698113208
48765,"private NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}","NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}",0.9694656488549618
48766,"public void invalidateAllNearCaches(String mapName,Set<Data> keys){
  if (keys == null || keys.isEmpty())   return;
  sendNearCacheOperation(new NearCacheKeySetInvalidationOperation(mapName,keys));
  for (  final Data key : keys) {
    invalidateNearCache(mapName,key);
  }
}","public void invalidateAllNearCaches(String mapName,Set<Data> keys){
  if (keys == null || keys.isEmpty())   return;
  Operation operation=new NearCacheKeySetInvalidationOperation(mapName,keys).setServiceName(SERVICE_NAME);
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : members) {
    try {
      if (member.localMember())       continue;
      nodeEngine.getOperationService().send(operation,member.getAddress());
    }
 catch (    Throwable throwable) {
      logger.warning(throwable);
    }
  }
  for (  final Data key : keys) {
    invalidateNearCache(mapName,key);
  }
}",0.5711159737417943
48767,"void clear(){
  cache.clear();
  resetSizeEstimator();
}","public void clear(){
  cache.clear();
  resetSizeEstimator();
}",0.9411764705882352
48768,"public NearCache(String mapName,MapService mapService){
  this.mapName=mapName;
  this.mapService=mapService;
  this.nodeEngine=mapService.getNodeEngine();
  this.mapContainer=mapService.getMapContainer(mapName);
  Config config=nodeEngine.getConfig();
  NearCacheConfig nearCacheConfig=config.findMapConfig(mapName).getNearCacheConfig();
  maxSize=nearCacheConfig.getMaxSize() <= 0 ? Integer.MAX_VALUE : nearCacheConfig.getMaxSize();
  maxIdleMillis=nearCacheConfig.getMaxIdleSeconds() * 1000;
  inMemoryFormat=nearCacheConfig.getInMemoryFormat();
  timeToLiveMillis=nearCacheConfig.getTimeToLiveSeconds() * 1000;
  invalidateOnChange=nearCacheConfig.isInvalidateOnChange();
  evictionPolicy=EvictionPolicy.valueOf(nearCacheConfig.getEvictionPolicy());
  cache=new ConcurrentHashMap<Data,CacheRecord>();
  canCleanUp=new AtomicBoolean(true);
  canEvict=new AtomicBoolean(true);
  lastCleanup=Clock.currentTimeMillis();
}","public NearCache(String mapName,MapService mapService){
  this.mapService=mapService;
  this.nodeEngine=mapService.getNodeEngine();
  this.mapContainer=mapService.getMapContainer(mapName);
  Config config=nodeEngine.getConfig();
  NearCacheConfig nearCacheConfig=config.findMapConfig(mapName).getNearCacheConfig();
  maxSize=nearCacheConfig.getMaxSize() <= 0 ? Integer.MAX_VALUE : nearCacheConfig.getMaxSize();
  maxIdleMillis=nearCacheConfig.getMaxIdleSeconds() * 1000;
  inMemoryFormat=nearCacheConfig.getInMemoryFormat();
  timeToLiveMillis=nearCacheConfig.getTimeToLiveSeconds() * 1000;
  evictionPolicy=EvictionPolicy.valueOf(nearCacheConfig.getEvictionPolicy());
  cache=new ConcurrentHashMap<Data,CacheRecord>();
  canCleanUp=new AtomicBoolean(true);
  canEvict=new AtomicBoolean(true);
  lastCleanup=Clock.currentTimeMillis();
}",0.9516220830961868
48769,"public void run(){
  final RecordStore recordStore=mapService.getExistingRecordStore(getPartitionId(),name);
  if (recordStore == null) {
    shouldBackup=false;
    return;
  }
  recordStore.clear();
}","public void run(){
  mapService.clearNearCache(name);
  final RecordStore recordStore=mapService.getExistingRecordStore(getPartitionId(),name);
  if (recordStore == null) {
    shouldBackup=false;
    return;
  }
  recordStore.clear();
}",0.9202733485193622
48770,"public void run(){
  mapService=getService();
  if (mapService.getMapContainer(mapName).isNearCacheEnabled()) {
    mapService.invalidateNearCache(mapName,key);
  }
 else {
    getLogger().warning(""String_Node_Str"" + mapName + ""String_Node_Str"");
  }
}","public void run(){
  MapService mapService=getService();
  if (mapService.getMapContainer(mapName).isNearCacheEnabled()) {
    mapService.invalidateNearCache(mapName,key);
  }
 else {
    getLogger().warning(""String_Node_Str"" + mapName + ""String_Node_Str"");
  }
}",0.9786407766990292
48771,"public void clearInternal(){
  final String mapName=name;
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    ClearOperation clearOperation=new ClearOperation(mapName);
    clearOperation.setServiceName(SERVICE_NAME);
    nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new BinaryOperationFactory(clearOperation,nodeEngine));
    if (getService().isNearCacheAndInvalidationEnabled(mapName)) {
      getService().invalidateAllNearCaches(mapName);
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public void clearInternal(){
  final String mapName=name;
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    ClearOperation clearOperation=new ClearOperation(mapName);
    clearOperation.setServiceName(SERVICE_NAME);
    nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,new BinaryOperationFactory(clearOperation,nodeEngine));
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.8703703703703703
48772,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,true);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Object> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,true);
  }
 else {
    accessRecord(record);
  }
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  final Object data=record != null ? (isInMemoryObjectFormat ? record.getValue() : mapService.toData(record.getValue())) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,data);
}",0.71259418729817
48773,"Map.Entry<Data,Data> getMapEntryData(Data dataKey);","Map.Entry<Data,Object> getMapEntryData(Data dataKey);",0.9230769230769232
48774,"public void run(){
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  oldValue=isInMemoryObjectFormat ? recordStore.getMapEntryObject(dataKey).getValue() : recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}","public void run(){
  oldValue=recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9021589343132752
48775,"public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  final Object valueBeforeProcess=mapService.toObject(dataOldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (dataOldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (dataOldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}","public void run(){
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  oldValue=isInMemoryObjectFormat ? recordStore.getMapEntryObject(dataKey).getValue() : recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.6338998621956822
48776,"public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}","public void afterRun() throws Exception {
  super.afterRun();
  if (eventType == __NO_NEED_TO_FIRE_EVENT) {
    return;
  }
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(oldValue),dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      Record record=recordStore.getRecord(dataKey);
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),record.getStatistics(),record.getVersion());
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.974493132766514
48777,"public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    entry=new MapEntrySimple(mapService.toObject(record.getKey()),valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType=null;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}","public void run(){
  response=new MapEntrySet();
  MapEntrySimple entry;
  final RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  final Map<Data,Record> records=recordStore.getReadonlyRecordMap();
  for (  final Map.Entry<Data,Record> recordEntry : records.entrySet()) {
    final Data dataKey=recordEntry.getKey();
    final Record record=recordEntry.getValue();
    final Object valueBeforeProcess=mapService.toObject(record.getValue());
    Object objectKey=mapService.toObject(record.getKey());
    if (getPredicate() != null) {
      QueryEntry queryEntry=new QueryEntry(getNodeEngine().getSerializationService(),dataKey,objectKey,valueBeforeProcess);
      if (!getPredicate().apply(queryEntry)) {
        continue;
      }
    }
    entry=new MapEntrySimple(objectKey,valueBeforeProcess);
    final Object result=entryProcessor.process(entry);
    final Object valueAfterProcess=entry.getValue();
    Data dataValue=null;
    if (result != null) {
      dataValue=mapService.toData(result);
      response.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,dataValue));
    }
    EntryEventType eventType;
    if (valueAfterProcess == null) {
      recordStore.remove(dataKey);
      eventType=EntryEventType.REMOVED;
    }
 else {
      if (valueBeforeProcess == null) {
        eventType=EntryEventType.ADDED;
      }
 else       if (!entry.isModified()) {
        eventType=__NO_NEED_TO_FIRE_EVENT;
      }
 else {
        eventType=EntryEventType.UPDATED;
      }
      if (eventType != __NO_NEED_TO_FIRE_EVENT) {
        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,valueAfterProcess));
      }
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,mapService.toData(record.getValue()),dataValue);
      if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
        mapService.invalidateAllNearCaches(name,dataKey);
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        if (EntryEventType.REMOVED.equals(eventType)) {
          mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
        }
 else {
          Record r=recordStore.getRecord(dataKey);
          SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),r.getStatistics(),r.getVersion());
          mapService.publishWanReplicationUpdate(name,entryView);
        }
      }
    }
  }
}",0.8391232423490488
48778,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Object> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,true);
  }
 else {
    accessRecord(record);
  }
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  final Object data=record != null ? (isInMemoryObjectFormat ? record.getValue() : mapService.toData(record.getValue())) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,data);
}",0.7056277056277056
48779,"private Record getRecordInternal(Data dataKey){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}","private Record getRecordInternal(Data dataKey,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}",0.939091915836102
48780,"public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}","public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,false);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}",0.9922879177377892
48781,"Map.Entry<Data,Data> getMapEntryData(Data dataKey);","Map.Entry<Data,Object> getMapEntryData(Data dataKey);",0.9230769230769232
48782,"public void run(){
  final boolean isInMemoryObjectFormat=InMemoryFormat.OBJECT.equals(mapContainer.getMapConfig().getInMemoryFormat());
  oldValue=isInMemoryObjectFormat ? recordStore.getMapEntryObject(dataKey).getValue() : recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}","public void run(){
  oldValue=recordStore.getMapEntryData(dataKey).getValue();
  final Object valueBeforeProcess=mapService.toObject(oldValue);
  final MapEntrySimple entry=new MapEntrySimple(mapService.toObject(dataKey),valueBeforeProcess);
  response=mapService.toData(entryProcessor.process(entry));
  final Object valueAfterProcess=entry.getValue();
  if (oldValue == null && valueAfterProcess == null) {
    eventType=__NO_NEED_TO_FIRE_EVENT;
  }
 else   if (valueAfterProcess == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (oldValue == null) {
      eventType=EntryEventType.ADDED;
    }
 else     if (!entry.isModified()) {
      eventType=__NO_NEED_TO_FIRE_EVENT;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    if (eventType != __NO_NEED_TO_FIRE_EVENT) {
      dataValue=mapService.toData(entry.getValue());
      recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
    }
  }
}",0.9021589343132752
48783,"private NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}","NearCache getNearCache(String mapName){
  return ConcurrencyUtil.getOrPutIfAbsent(nearCacheMap,mapName,nearCacheConstructor);
}",0.9694656488549618
48784,"public void invalidateAllNearCaches(String mapName,Data key){
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : members) {
    try {
      if (member.localMember())       continue;
      InvalidateNearCacheOperation operation=new InvalidateNearCacheOperation(mapName,key);
      nodeEngine.getOperationService().send(operation,member.getAddress());
    }
 catch (    Throwable throwable) {
      throw new HazelcastException(throwable);
    }
  }
  invalidateNearCache(mapName,key);
}","public void invalidateAllNearCaches(String mapName,Data key){
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  for (  MemberImpl member : members) {
    try {
      if (member.localMember())       continue;
      Operation operation=new InvalidateNearCacheOperation(mapName,key).setServiceName(SERVICE_NAME);
      nodeEngine.getOperationService().send(operation,member.getAddress());
    }
 catch (    Throwable throwable) {
      throw new HazelcastException(throwable);
    }
  }
  invalidateNearCache(mapName,key);
}",0.9562841530054644
48785,"public NearCache(String mapName,MapService mapService){
  this.mapName=mapName;
  this.mapService=mapService;
  this.nodeEngine=mapService.getNodeEngine();
  this.mapContainer=mapService.getMapContainer(mapName);
  Config config=nodeEngine.getConfig();
  NearCacheConfig nearCacheConfig=config.findMapConfig(mapName).getNearCacheConfig();
  maxSize=nearCacheConfig.getMaxSize() <= 0 ? Integer.MAX_VALUE : nearCacheConfig.getMaxSize();
  maxIdleMillis=nearCacheConfig.getMaxIdleSeconds() * 1000;
  inMemoryFormat=nearCacheConfig.getInMemoryFormat();
  timeToLiveMillis=nearCacheConfig.getTimeToLiveSeconds() * 1000;
  invalidateOnChange=nearCacheConfig.isInvalidateOnChange();
  evictionPolicy=EvictionPolicy.valueOf(nearCacheConfig.getEvictionPolicy());
  cache=new ConcurrentHashMap<Data,CacheRecord>();
  canCleanUp=new AtomicBoolean(true);
  canEvict=new AtomicBoolean(true);
  lastCleanup=Clock.currentTimeMillis();
}","public NearCache(String mapName,MapService mapService){
  this.mapService=mapService;
  this.nodeEngine=mapService.getNodeEngine();
  this.mapContainer=mapService.getMapContainer(mapName);
  Config config=nodeEngine.getConfig();
  NearCacheConfig nearCacheConfig=config.findMapConfig(mapName).getNearCacheConfig();
  maxSize=nearCacheConfig.getMaxSize() <= 0 ? Integer.MAX_VALUE : nearCacheConfig.getMaxSize();
  maxIdleMillis=nearCacheConfig.getMaxIdleSeconds() * 1000;
  inMemoryFormat=nearCacheConfig.getInMemoryFormat();
  timeToLiveMillis=nearCacheConfig.getTimeToLiveSeconds() * 1000;
  evictionPolicy=EvictionPolicy.valueOf(nearCacheConfig.getEvictionPolicy());
  cache=new ConcurrentHashMap<Data,CacheRecord>();
  canCleanUp=new AtomicBoolean(true);
  canEvict=new AtomicBoolean(true);
  lastCleanup=Clock.currentTimeMillis();
}",0.9516220830961868
48786,"public void run(){
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  if (keys == null) {
    recordStore.removeAll();
    return;
  }
  if (keys.isEmpty()) {
    shouldBackup=false;
  }
  for (  Data key : keys) {
    if (!recordStore.isLocked(key)) {
      recordStore.evict(key);
    }
  }
}","public void run(){
  mapService.clearNearCache(name);
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  if (keys == null) {
    recordStore.removeAll();
    return;
  }
  if (keys.isEmpty()) {
    shouldBackup=false;
  }
  for (  Data key : keys) {
    if (!recordStore.isLocked(key)) {
      recordStore.evict(key);
    }
  }
}",0.948301329394387
48787,"public void run(){
  mapService=(MapService)getService();
  if (mapService.getMapContainer(mapName).isNearCacheEnabled()) {
    mapService.invalidateNearCache(mapName,key);
  }
 else {
    getLogger().warning(""String_Node_Str"" + mapName + ""String_Node_Str"");
  }
}","public void run(){
  MapService mapService=getService();
  if (mapService.getMapContainer(mapName).isNearCacheEnabled()) {
    mapService.invalidateNearCache(mapName,key);
  }
 else {
    getLogger().warning(""String_Node_Str"" + mapName + ""String_Node_Str"");
  }
}",0.9563567362428842
48788,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
  }
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}",0.5490566037735849
48789,"public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}","public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}",0.8320726172465961
48790,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,true);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}",0.9933598937583
48791,"private Record getRecordInternal(Data dataKey){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      saveIndex(record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}","private Record getRecordInternal(Data dataKey,boolean enableIndex){
  Record record=null;
  if (mapContainer.getStore() != null) {
    final Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
    if (value != null) {
      record=mapService.createRecord(name,dataKey,value,-1);
      records.put(dataKey,record);
      if (enableIndex) {
        saveIndex(record);
      }
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  return record;
}",0.939091915836102
48792,"public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}","public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey,false);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}",0.9922879177377892
48793,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
  }
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}",0.5490566037735849
48794,"public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}","public Map.Entry<Data,Object> getMapEntryObject(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    record=getRecordInternal(dataKey);
  }
 else {
    accessRecord(record);
  }
  final Object value=record != null ? mapService.toObject(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,value);
}",0.8320726172465961
48795,"/** 
 * Iterates through all bundles to get the available @link ScriptEngineFactory classes
 * @return the names of the available ScriptEngineFactory classes
 * @throws IOException
 */
private List<String> findFactoryCandidates(BundleContext context) throws IOException {
  Bundle[] bundles=context.getBundles();
  List<String> factoryCandidates=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    System.out.println(bundle.getSymbolicName());
    if (bundle.getSymbolicName().equals(""String_Node_Str""))     continue;
    Enumeration urls=bundle.findEntries(""String_Node_Str"",""String_Node_Str"",false);
    if (urls == null)     continue;
    while (urls.hasMoreElements()) {
      URL u=(URL)urls.nextElement();
      BufferedReader reader=new BufferedReader(new InputStreamReader(u.openStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        factoryCandidates.add(line.trim());
      }
    }
  }
  factoryCandidates.add(""String_Node_Str"");
  return factoryCandidates;
}","/** 
 * Iterates through all bundles to get the available @link ScriptEngineFactory classes
 * @return the names of the available ScriptEngineFactory classes
 * @throws IOException
 */
private List<String> findFactoryCandidates(BundleContext context) throws IOException {
  Bundle[] bundles=context.getBundles();
  List<String> factoryCandidates=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    if (bundle.getSymbolicName().equals(""String_Node_Str""))     continue;
    Enumeration urls=bundle.findEntries(""String_Node_Str"",""String_Node_Str"",false);
    if (urls == null)     continue;
    while (urls.hasMoreElements()) {
      URL u=(URL)urls.nextElement();
      BufferedReader reader=new BufferedReader(new InputStreamReader(u.openStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        factoryCandidates.add(line.trim());
      }
    }
  }
  factoryCandidates.add(""String_Node_Str"");
  return factoryCandidates;
}",0.9717171717171718
48796,"private Map<ScriptEngineManager,ClassLoader> findManagers(BundleContext context){
  Map<ScriptEngineManager,ClassLoader> managers=new HashMap<ScriptEngineManager,ClassLoader>();
  try {
    for (    String factoryName : findFactoryCandidates(context)) {
      ClassLoader factoryLoader=Class.forName(factoryName).getClassLoader();
      ScriptEngineManager manager=new ScriptEngineManager(factoryLoader);
      manager.setBindings(bindings);
      managers.put(manager,factoryLoader);
    }
    return managers;
  }
 catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(cnfe);
  }
}","private Map<ScriptEngineManager,ClassLoader> findManagers(BundleContext context){
  Map<ScriptEngineManager,ClassLoader> managers=new HashMap<ScriptEngineManager,ClassLoader>();
  try {
    for (    String factoryName : findFactoryCandidates(context)) {
      ClassLoader factoryLoader;
      try {
        factoryLoader=Class.forName(factoryName).getClassLoader();
      }
 catch (      ClassNotFoundException cnfe) {
        logger.warning(""String_Node_Str"" + factoryName + ""String_Node_Str""+ cnfe);
        if (logger.isFinestEnabled()) {
          logger.finest(cnfe);
        }
        continue;
      }
      ScriptEngineManager manager=new ScriptEngineManager(factoryLoader);
      manager.setBindings(bindings);
      managers.put(manager,factoryLoader);
    }
    return managers;
  }
 catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
}",0.7653194263363755
48797,"public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  Map values=mapContainer.getStore().loadAll(keys.values());
  MapEntrySet entrySet=new MapEntrySet();
  for (  Data dataKey : keys.keySet()) {
    Object key=keys.get(dataKey);
    Object value=values.get(key);
    if (value != null) {
      Data dataValue=mapService.toData(value);
      entrySet.add(dataKey,dataValue);
    }
  }
  PutAllOperation operation=new PutAllOperation(name,entrySet,true);
  operation.setNodeEngine(nodeEngine);
  operation.setResponseHandler(new ResponseHandler(){
    @Override public void sendResponse(    Object obj){
      if (!(obj instanceof Exception)) {
        loaded.set(true);
      }
 else {
        Exception e=(Exception)obj;
        nodeEngine.getLogger(RecordStore.class).finest(e.getMessage());
      }
    }
    public boolean isLocal(){
      return true;
    }
  }
);
  operation.setPartitionId(partitionId);
  OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
  operation.setServiceName(MapService.SERVICE_NAME);
  nodeEngine.getOperationService().executeOperation(operation);
}","public void run(){
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  Map values=mapContainer.getStore().loadAll(keys.values());
  if (values == null || values.isEmpty()) {
    loaded.set(true);
    return;
  }
  MapEntrySet entrySet=new MapEntrySet();
  for (  Data dataKey : keys.keySet()) {
    Object key=keys.get(dataKey);
    Object value=values.get(key);
    if (value != null) {
      Data dataValue=mapService.toData(value);
      entrySet.add(dataKey,dataValue);
    }
  }
  PutAllOperation operation=new PutAllOperation(name,entrySet,true);
  operation.setNodeEngine(nodeEngine);
  operation.setResponseHandler(new ResponseHandler(){
    @Override public void sendResponse(    Object obj){
      if (!(obj instanceof Exception)) {
        loaded.set(true);
      }
 else {
        Exception e=(Exception)obj;
        nodeEngine.getLogger(RecordStore.class).finest(e.getMessage());
      }
    }
    public boolean isLocal(){
      return true;
    }
  }
);
  operation.setPartitionId(partitionId);
  OperationAccessor.setCallerAddress(operation,nodeEngine.getThisAddress());
  operation.setServiceName(MapService.SERVICE_NAME);
  nodeEngine.getOperationService().executeOperation(operation);
}",0.9650170648464164
48798,"@Test public void testIssue1019(){
  Config config=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setImplementation(new MapStoreAdapter<String,String>());
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance instance2=Hazelcast.newHazelcastInstance(config);
  final IMap map=instance.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    map.put(i,i);
  }
  for (int i=10000; i < 10100; i++) {
    map.get(i);
  }
  assertEquals(1000,map.values().size());
}","@Test public void testIssue1019(){
  Config config=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setImplementation(new MapStoreAdapter<String,String>());
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);
  final IMap map=instance.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    map.put(i,i);
  }
  for (int i=10000; i < 10100; i++) {
    map.get(i);
  }
  assertEquals(1000,map.values().size());
}",0.9088145896656536
48799,"/** 
 * Iterates through all bundles to get the available @link ScriptEngineFactory classes
 * @return the names of the available ScriptEngineFactory classes
 * @throws IOException
 */
private List<String> findFactoryCandidates(BundleContext context) throws IOException {
  Bundle[] bundles=context.getBundles();
  List<String> factoryCandidates=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    System.out.println(bundle.getSymbolicName());
    if (bundle.getSymbolicName().equals(""String_Node_Str""))     continue;
    Enumeration urls=bundle.findEntries(""String_Node_Str"",""String_Node_Str"",false);
    if (urls == null)     continue;
    while (urls.hasMoreElements()) {
      URL u=(URL)urls.nextElement();
      BufferedReader reader=new BufferedReader(new InputStreamReader(u.openStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        factoryCandidates.add(line.trim());
      }
    }
  }
  factoryCandidates.add(""String_Node_Str"");
  return factoryCandidates;
}","/** 
 * Iterates through all bundles to get the available @link ScriptEngineFactory classes
 * @return the names of the available ScriptEngineFactory classes
 * @throws IOException
 */
private List<String> findFactoryCandidates(BundleContext context) throws IOException {
  Bundle[] bundles=context.getBundles();
  List<String> factoryCandidates=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    if (bundle.getSymbolicName().equals(""String_Node_Str""))     continue;
    Enumeration urls=bundle.findEntries(""String_Node_Str"",""String_Node_Str"",false);
    if (urls == null)     continue;
    while (urls.hasMoreElements()) {
      URL u=(URL)urls.nextElement();
      BufferedReader reader=new BufferedReader(new InputStreamReader(u.openStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        factoryCandidates.add(line.trim());
      }
    }
  }
  factoryCandidates.add(""String_Node_Str"");
  return factoryCandidates;
}",0.9717171717171718
48800,"private Map<ScriptEngineManager,ClassLoader> findManagers(BundleContext context){
  Map<ScriptEngineManager,ClassLoader> managers=new HashMap<ScriptEngineManager,ClassLoader>();
  try {
    for (    String factoryName : findFactoryCandidates(context)) {
      ClassLoader factoryLoader=Class.forName(factoryName).getClassLoader();
      ScriptEngineManager manager=new ScriptEngineManager(factoryLoader);
      manager.setBindings(bindings);
      managers.put(manager,factoryLoader);
    }
    return managers;
  }
 catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(cnfe);
  }
}","private Map<ScriptEngineManager,ClassLoader> findManagers(BundleContext context){
  Map<ScriptEngineManager,ClassLoader> managers=new HashMap<ScriptEngineManager,ClassLoader>();
  try {
    for (    String factoryName : findFactoryCandidates(context)) {
      ClassLoader factoryLoader;
      try {
        factoryLoader=Class.forName(factoryName).getClassLoader();
      }
 catch (      ClassNotFoundException cnfe) {
        logger.warning(""String_Node_Str"" + factoryName + ""String_Node_Str""+ cnfe);
        if (logger.isFinestEnabled()) {
          logger.finest(cnfe);
        }
        continue;
      }
      ScriptEngineManager manager=new ScriptEngineManager(factoryLoader);
      manager.setBindings(bindings);
      managers.put(manager,factoryLoader);
    }
    return managers;
  }
 catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
}",0.7653194263363755
48801,"public void init(boolean fromBackup){
  if (!fromBackup && store.isEnabled()) {
    Set<Long> keys=store.loadAllKeys();
    if (keys != null) {
      for (      Long key : keys) {
        QueueItem item=new QueueItem(this,key,null);
        getItemQueue().offer(item);
        nextId();
      }
    }
  }
}","public void init(boolean fromBackup){
  if (!fromBackup && store.isEnabled()) {
    Set<Long> keys=store.loadAllKeys();
    if (keys != null) {
      long maxId=-1;
      for (      Long key : keys) {
        QueueItem item=new QueueItem(this,key,null);
        getItemQueue().offer(item);
        maxId=Math.max(maxId,key);
      }
      idGenerator=maxId;
    }
  }
}",0.8859259259259259
48802,"public void init(boolean fromBackup){
  if (!fromBackup && store.isEnabled()) {
    Set<Long> keys=store.loadAllKeys();
    if (keys != null) {
      for (      Long key : keys) {
        QueueItem item=new QueueItem(this,key,null);
        getItemQueue().offer(item);
        nextId();
      }
    }
  }
}","public void init(boolean fromBackup){
  if (!fromBackup && store.isEnabled()) {
    Set<Long> keys=store.loadAllKeys();
    if (keys != null) {
      long maxId=-1;
      for (      Long key : keys) {
        QueueItem item=new QueueItem(this,key,null);
        getItemQueue().offer(item);
        maxId=Math.max(maxId,key);
      }
      idGenerator=maxId;
    }
  }
}",0.8859259259259259
48803,"public Set<MonitoredThread> getStats(){
  try {
    Set<MonitoredThread> monitoredThreads=new TreeSet<MonitoredThread>();
    int count=threadGroup.activeCount();
    Thread[] threads=new Thread[count];
    threadGroup.enumerate(threads);
    long now=System.nanoTime();
    for (    Thread thread : threads) {
      ThreadCpuInfo t=knownThreads.get(thread.getId());
      if (t == null) {
        t=new ThreadCpuInfo(thread);
        knownThreads.putIfAbsent(thread.getId(),t);
      }
      int percentage=(int)((t.setNewValue(threadMXBean.getThreadCpuTime(thread.getId()),now)) * 100);
      monitoredThreads.add(new MonitoredThread(thread.getName(),thread.getId(),percentage));
    }
    return monitoredThreads;
  }
 catch (  Exception e) {
    return null;
  }
}","public Set<MonitoredThread> getStats(){
  try {
    Set<MonitoredThread> monitoredThreads=new TreeSet<MonitoredThread>();
    int count=threadGroup.activeCount();
    Thread[] threads=new Thread[count];
    threadGroup.enumerate(threads);
    long now=System.nanoTime();
    for (    Thread thread : threads) {
      final ThreadCpuInfo t=ConcurrencyUtil.getOrPutIfAbsent(knownThreads,thread.getId(),new ThreadCpuInfoConstructor(thread));
      int percentage=(int)((t.setNewValue(threadMXBean.getThreadCpuTime(thread.getId()),now)) * 100);
      monitoredThreads.add(new MonitoredThread(thread.getName(),thread.getId(),percentage));
    }
    return monitoredThreads;
  }
 catch (  Exception e) {
    return null;
  }
}",0.8629032258064516
48804,"public DefaultRecordStore(String name,MapService mapService,int partitionId){
  this.name=name;
  this.partitionId=partitionId;
  this.mapService=mapService;
  this.mapContainer=mapService.getMapContainer(name);
  recordFactory=mapContainer.getRecordFactory();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  this.lockStore=lockService == null ? null : lockService.createLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  this.sizeEstimator=SizeEstimators.createMapSizeEstimator();
  final int mapLoadChunkSize=nodeEngine.getGroupProperties().MAP_LOAD_CHUNK_SIZE.getInteger();
  final Queue<Map> chunks=new LinkedList<Map>();
  if (nodeEngine.getThisAddress().equals(nodeEngine.getPartitionService().getPartitionOwner(partitionId))) {
    if (mapContainer.getStore() != null && !loaded.get()) {
      Map<Data,Object> loadedKeys=mapContainer.getInitialKeys();
      if (loadedKeys != null && !loadedKeys.isEmpty()) {
        Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
        Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
        while (iterator.hasNext()) {
          final Map.Entry<Data,Object> entry=iterator.next();
          final Data data=entry.getKey();
          if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
            partitionKeys.put(data,entry.getValue());
            if (partitionKeys.size() >= mapLoadChunkSize) {
              chunks.add(partitionKeys);
              partitionKeys=new HashMap<Data,Object>();
            }
            iterator.remove();
          }
        }
        if (!partitionKeys.isEmpty()) {
          chunks.add(partitionKeys);
        }
        try {
          Map<Data,Object> chunkedKeys;
          final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
          while ((chunkedKeys=chunks.poll()) != null) {
            nodeEngine.getExecutionService().submit(""String_Node_Str"",new MapLoadAllTask(chunkedKeys,checkIfMapLoaded));
          }
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
 else {
        loaded.set(true);
      }
    }
  }
 else {
    loaded.set(true);
  }
}","public DefaultRecordStore(String name,MapService mapService,int partitionId){
  this.name=name;
  this.partitionId=partitionId;
  this.mapService=mapService;
  this.mapContainer=mapService.getMapContainer(name);
  recordFactory=mapContainer.getRecordFactory();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  this.lockStore=lockService == null ? null : lockService.createLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  this.sizeEstimator=SizeEstimators.createMapSizeEstimator();
  final int mapLoadChunkSize=nodeEngine.getGroupProperties().MAP_LOAD_CHUNK_SIZE.getInteger();
  final Queue<Map> chunks=new LinkedList<Map>();
  if (nodeEngine.getThisAddress().equals(nodeEngine.getPartitionService().getPartitionOwner(partitionId))) {
    if (mapContainer.getStore() != null && !loaded.get()) {
      Map<Data,Object> loadedKeys=mapContainer.getInitialKeys();
      if (loadedKeys != null && !loadedKeys.isEmpty()) {
        Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
        Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
        while (iterator.hasNext()) {
          final Map.Entry<Data,Object> entry=iterator.next();
          final Data data=entry.getKey();
          if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
            partitionKeys.put(data,entry.getValue());
            if (partitionKeys.size() >= mapLoadChunkSize) {
              chunks.add(partitionKeys);
              partitionKeys=new HashMap<Data,Object>();
            }
            iterator.remove();
          }
        }
        if (!partitionKeys.isEmpty()) {
          chunks.add(partitionKeys);
        }
        if (!chunks.isEmpty()) {
          try {
            Map<Data,Object> chunkedKeys;
            final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
            while ((chunkedKeys=chunks.poll()) != null) {
              nodeEngine.getExecutionService().submit(""String_Node_Str"",new MapLoadAllTask(chunkedKeys,checkIfMapLoaded));
            }
          }
 catch (          Throwable t) {
            throw ExceptionUtil.rethrow(t);
          }
        }
 else {
          loaded.set(true);
        }
      }
 else {
        loaded.set(true);
      }
    }
  }
 else {
    loaded.set(true);
  }
}",0.967892834361046
48805,"@Test public void testIssue1019(){
}","@Test public void testIssue1019() throws InterruptedException {
}",0.7128712871287128
48806,"@Test public void testMapGetAll(){
  final Map<String,String> _map=new HashMap<String,String>();
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  final AtomicBoolean loadAllCalled=new AtomicBoolean(false);
  final AtomicBoolean loadCalled=new AtomicBoolean(false);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new MapLoader<String,String>(){
    public String load(    String key){
      loadCalled.set(true);
      System.err.println(""String_Node_Str"" + key);
      return _map.get(key);
    }
    public Map<String,String> loadAll(    Collection<String> keys){
      loadAllCalled.set(true);
      final HashMap<String,String> temp=new HashMap<String,String>();
      for (      String key : keys) {
        temp.put(key,_map.get(key));
      }
      return temp;
    }
    public Set<String> loadAllKeys(){
      return _map.keySet();
    }
  }
);
  cfg.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(""String_Node_Str"");
  final HashSet<String> keys=new HashSet<String>();
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  final Map subMap=map.getAll(keys);
  assertEquals(2,subMap.size());
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertTrue(loadAllCalled.get());
  assertFalse(loadCalled.get());
}","@Test public void testMapGetAll() throws InterruptedException {
  final Map<String,String> _map=new HashMap<String,String>();
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  final AtomicBoolean loadAllCalled=new AtomicBoolean(false);
  final AtomicBoolean loadCalled=new AtomicBoolean(false);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new MapLoader<String,String>(){
    public String load(    String key){
      loadCalled.set(true);
      System.err.println(""String_Node_Str"" + key);
      return _map.get(key);
    }
    public Map<String,String> loadAll(    Collection<String> keys){
      loadAllCalled.set(true);
      final HashMap<String,String> temp=new HashMap<String,String>();
      for (      String key : keys) {
        temp.put(key,_map.get(key));
      }
      return temp;
    }
    public Set<String> loadAllKeys(){
      return _map.keySet();
    }
  }
);
  cfg.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(""String_Node_Str"");
  final HashSet<String> keys=new HashSet<String>();
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  final Map subMap=map.getAll(keys);
  assertEquals(2,subMap.size());
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertTrue(loadAllCalled.get());
  assertFalse(loadCalled.get());
}",0.9920438957475994
48807,"@Test public void testIssue1110() throws InterruptedException {
  final int mapSize=10000;
  final String mapName=""String_Node_Str"";
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  cfg.setProperty(GroupProperties.PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new SimpleMapLoader(mapSize));
  cfg.getMapConfig(mapName).setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(mapSize);
  map.addEntryListener(new EntryListener(){
    @Override public void entryAdded(    EntryEvent event){
      latch.countDown();
    }
    @Override public void entryRemoved(    EntryEvent event){
    }
    @Override public void entryUpdated(    EntryEvent event){
    }
    @Override public void entryEvicted(    EntryEvent event){
    }
  }
,true);
  map.size();
  latch.await();
  assertEquals(mapSize,map.size());
}","@Test public void testIssue1110() throws InterruptedException {
  final int mapSize=10;
  final String mapName=""String_Node_Str"";
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  cfg.setProperty(GroupProperties.PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new SimpleMapLoader(mapSize));
  cfg.getMapConfig(mapName).setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(mapSize);
  map.addEntryListener(new EntryListener(){
    @Override public void entryAdded(    EntryEvent event){
      latch.countDown();
    }
    @Override public void entryRemoved(    EntryEvent event){
    }
    @Override public void entryUpdated(    EntryEvent event){
    }
    @Override public void entryEvicted(    EntryEvent event){
    }
  }
,true);
  map.size();
  latch.await();
  assertEquals(mapSize,map.size());
}",0.9987357774968394
48808,"public DefaultRecordStore(String name,MapService mapService,int partitionId){
  this.name=name;
  this.partitionId=partitionId;
  this.mapService=mapService;
  this.mapContainer=mapService.getMapContainer(name);
  recordFactory=mapContainer.getRecordFactory();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  this.lockStore=lockService == null ? null : lockService.createLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  this.sizeEstimator=SizeEstimators.createMapSizeEstimator();
  final int mapLoadChunkSize=nodeEngine.getGroupProperties().MAP_LOAD_CHUNK_SIZE.getInteger();
  final Queue<Map> chunks=new LinkedList<Map>();
  if (nodeEngine.getThisAddress().equals(nodeEngine.getPartitionService().getPartitionOwner(partitionId))) {
    if (mapContainer.getStore() != null && !loaded.get()) {
      Map<Data,Object> loadedKeys=mapContainer.getInitialKeys();
      if (loadedKeys != null && !loadedKeys.isEmpty()) {
        Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
        Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
        while (iterator.hasNext()) {
          final Map.Entry<Data,Object> entry=iterator.next();
          final Data data=entry.getKey();
          if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
            partitionKeys.put(data,entry.getValue());
            if (partitionKeys.size() >= mapLoadChunkSize) {
              chunks.add(partitionKeys);
              partitionKeys=new HashMap<Data,Object>();
            }
            iterator.remove();
          }
        }
        if (!partitionKeys.isEmpty()) {
          chunks.add(partitionKeys);
        }
        try {
          Map<Data,Object> chunkedKeys;
          final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
          while ((chunkedKeys=chunks.poll()) != null) {
            nodeEngine.getExecutionService().submit(""String_Node_Str"",new MapLoadAllTask(chunkedKeys,checkIfMapLoaded));
          }
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
 else {
        loaded.set(true);
      }
    }
  }
 else {
    loaded.set(true);
  }
}","public DefaultRecordStore(String name,MapService mapService,int partitionId){
  this.name=name;
  this.partitionId=partitionId;
  this.mapService=mapService;
  this.mapContainer=mapService.getMapContainer(name);
  recordFactory=mapContainer.getRecordFactory();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  final LockService lockService=nodeEngine.getSharedService(LockService.SERVICE_NAME);
  this.lockStore=lockService == null ? null : lockService.createLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  this.sizeEstimator=SizeEstimators.createMapSizeEstimator();
  final int mapLoadChunkSize=nodeEngine.getGroupProperties().MAP_LOAD_CHUNK_SIZE.getInteger();
  final Queue<Map> chunks=new LinkedList<Map>();
  if (nodeEngine.getThisAddress().equals(nodeEngine.getPartitionService().getPartitionOwner(partitionId))) {
    if (mapContainer.getStore() != null && !loaded.get()) {
      Map<Data,Object> loadedKeys=mapContainer.getInitialKeys();
      if (loadedKeys != null && !loadedKeys.isEmpty()) {
        Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
        Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
        while (iterator.hasNext()) {
          final Map.Entry<Data,Object> entry=iterator.next();
          final Data data=entry.getKey();
          if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
            partitionKeys.put(data,entry.getValue());
            if (partitionKeys.size() >= mapLoadChunkSize) {
              chunks.add(partitionKeys);
              partitionKeys=new HashMap<Data,Object>();
            }
            iterator.remove();
          }
        }
        if (!partitionKeys.isEmpty()) {
          chunks.add(partitionKeys);
        }
        if (!chunks.isEmpty()) {
          try {
            Map<Data,Object> chunkedKeys;
            final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
            while ((chunkedKeys=chunks.poll()) != null) {
              nodeEngine.getExecutionService().submit(""String_Node_Str"",new MapLoadAllTask(chunkedKeys,checkIfMapLoaded));
            }
          }
 catch (          Throwable t) {
            throw ExceptionUtil.rethrow(t);
          }
        }
 else {
          loaded.set(true);
        }
      }
 else {
        loaded.set(true);
      }
    }
  }
 else {
    loaded.set(true);
  }
}",0.967892834361046
48809,"@Test public void testIssue1019(){
}","@Test public void testIssue1019() throws InterruptedException {
}",0.7128712871287128
48810,"@Test public void testMapGetAll(){
  final Map<String,String> _map=new HashMap<String,String>();
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  final AtomicBoolean loadAllCalled=new AtomicBoolean(false);
  final AtomicBoolean loadCalled=new AtomicBoolean(false);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new MapLoader<String,String>(){
    public String load(    String key){
      loadCalled.set(true);
      System.err.println(""String_Node_Str"" + key);
      return _map.get(key);
    }
    public Map<String,String> loadAll(    Collection<String> keys){
      loadAllCalled.set(true);
      final HashMap<String,String> temp=new HashMap<String,String>();
      for (      String key : keys) {
        temp.put(key,_map.get(key));
      }
      return temp;
    }
    public Set<String> loadAllKeys(){
      return _map.keySet();
    }
  }
);
  cfg.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(""String_Node_Str"");
  final HashSet<String> keys=new HashSet<String>();
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  final Map subMap=map.getAll(keys);
  assertEquals(2,subMap.size());
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertTrue(loadAllCalled.get());
  assertFalse(loadCalled.get());
}","@Test public void testMapGetAll() throws InterruptedException {
  final Map<String,String> _map=new HashMap<String,String>();
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  _map.put(""String_Node_Str"",""String_Node_Str"");
  final AtomicBoolean loadAllCalled=new AtomicBoolean(false);
  final AtomicBoolean loadCalled=new AtomicBoolean(false);
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new MapLoader<String,String>(){
    public String load(    String key){
      loadCalled.set(true);
      System.err.println(""String_Node_Str"" + key);
      return _map.get(key);
    }
    public Map<String,String> loadAll(    Collection<String> keys){
      loadAllCalled.set(true);
      final HashMap<String,String> temp=new HashMap<String,String>();
      for (      String key : keys) {
        temp.put(key,_map.get(key));
      }
      return temp;
    }
    public Set<String> loadAllKeys(){
      return _map.keySet();
    }
  }
);
  cfg.getMapConfig(""String_Node_Str"").setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(""String_Node_Str"");
  final HashSet<String> keys=new HashSet<String>();
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  keys.add(""String_Node_Str"");
  final Map subMap=map.getAll(keys);
  assertEquals(2,subMap.size());
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",subMap.get(""String_Node_Str""));
  assertTrue(loadAllCalled.get());
  assertFalse(loadCalled.get());
}",0.9920438957475994
48811,"@Test public void testIssue1110() throws InterruptedException {
  final int mapSize=10000;
  final String mapName=""String_Node_Str"";
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  cfg.setProperty(GroupProperties.PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new SimpleMapLoader(mapSize));
  cfg.getMapConfig(mapName).setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(mapSize);
  map.addEntryListener(new EntryListener(){
    @Override public void entryAdded(    EntryEvent event){
      latch.countDown();
    }
    @Override public void entryRemoved(    EntryEvent event){
    }
    @Override public void entryUpdated(    EntryEvent event){
    }
    @Override public void entryEvicted(    EntryEvent event){
    }
  }
,true);
  map.size();
  latch.await();
  assertEquals(mapSize,map.size());
}","@Test public void testIssue1110() throws InterruptedException {
  final int mapSize=10;
  final String mapName=""String_Node_Str"";
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(2);
  Config cfg=new Config();
  cfg.setProperty(GroupProperties.PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  MapStoreConfig mapStoreConfig=new MapStoreConfig();
  mapStoreConfig.setEnabled(true);
  mapStoreConfig.setImplementation(new SimpleMapLoader(mapSize));
  cfg.getMapConfig(mapName).setMapStoreConfig(mapStoreConfig);
  HazelcastInstance instance1=nodeFactory.newHazelcastInstance(cfg);
  HazelcastInstance instance2=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance1.getMap(mapName);
  final CountDownLatch latch=new CountDownLatch(mapSize);
  map.addEntryListener(new EntryListener(){
    @Override public void entryAdded(    EntryEvent event){
      latch.countDown();
    }
    @Override public void entryRemoved(    EntryEvent event){
    }
    @Override public void entryUpdated(    EntryEvent event){
    }
    @Override public void entryEvicted(    EntryEvent event){
    }
  }
,true);
  map.size();
  latch.await();
  assertEquals(mapSize,map.size());
}",0.9987357774968394
48812,"public Object getKey(){
  return key;
}","public Data getKey(){
  return key;
}",0.8947368421052632
48813,"public boolean eval(Object arg){
  return (key == null || key.equals(arg)) && predicate.apply((Map.Entry)arg);
}","public boolean eval(Object arg){
  final QueryEntry entry=(QueryEntry)arg;
  final Data keyData=entry.getKeyData();
  return (key == null || key.equals(keyData)) && predicate.apply((Map.Entry)arg);
}",0.707395498392283
48814,"public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    final ObjectDataInput in=reader.getRawDataInput();
    predicate=in.readObject();
    if (hasKey) {
      key=in.readObject();
    }
  }
 else   if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=in.readObject();
  }
}","public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    final ObjectDataInput in=reader.getRawDataInput();
    predicate=in.readObject();
    if (hasKey) {
      key=new Data();
      key.readData(in);
    }
  }
 else   if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=new Data();
    key.readData(in);
  }
}",0.9138576779026216
48815,"public Object getKey(){
  return key;
}","public Data getKey(){
  return key;
}",0.8947368421052632
48816,"public boolean eval(Object arg){
  return (key == null || key.equals(arg)) && predicate.apply((Map.Entry)arg);
}","public boolean eval(Object arg){
  final QueryEntry entry=(QueryEntry)arg;
  final Data keyData=entry.getKeyData();
  return (key == null || key.equals(keyData)) && predicate.apply((Map.Entry)arg);
}",0.707395498392283
48817,"private void cancelAssociatedSchedulers(Data key){
  mapContainer.getIdleEvictionScheduler().cancel(key);
  mapContainer.getTtlEvictionScheduler().cancel(key);
}","private void cancelAssociatedSchedulers(Set<Data> keySet){
  if (keySet == null || keySet.isEmpty())   return;
  for (  Data key : keySet) {
    cancelAssociatedSchedulers(key);
  }
}",0.4534883720930232
48818,"public void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  cancelAssociatedSchedulers(records.keySet());
}",0.9570661896243292
48819,"public Object evict(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record != null) {
    flush(dataKey);
    mapService.interceptRemove(name,record.getValue());
    oldValue=record.getValue();
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removeIndex(dataKey);
  }
  return oldValue;
}","public Object evict(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record != null) {
    flush(dataKey);
    mapService.interceptRemove(name,record.getValue());
    oldValue=record.getValue();
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removeIndex(dataKey);
    cancelAssociatedSchedulers(dataKey);
  }
  return oldValue;
}",0.9488139825218476
48820,"public void reset(){
  checkIfLoaded();
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void reset(){
  checkIfLoaded();
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  cancelAllSchedulers();
}",0.906367041198502
48821,"public boolean remove(Data dataKey,Object testValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  boolean removed=false;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    if (oldValue == null)     return false;
  }
 else {
    oldValue=record.getValue();
  }
  if (mapService.compare(name,testValue,oldValue)) {
    mapService.interceptRemove(name,oldValue);
    removeIndex(dataKey);
    mapStoreDelete(record,dataKey);
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removed=true;
  }
  return removed;
}","public boolean remove(Data dataKey,Object testValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  boolean removed=false;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    if (oldValue == null)     return false;
  }
 else {
    oldValue=record.getValue();
  }
  if (mapService.compare(name,testValue,oldValue)) {
    mapService.interceptRemove(name,oldValue);
    removeIndex(dataKey);
    mapStoreDelete(record,dataKey);
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    cancelAssociatedSchedulers(dataKey);
    removed=true;
  }
  return removed;
}",0.970942593905032
48822,"public void clear(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
}","public void clear(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
  cancelAllSchedulers();
}",0.9863760217983653
48823,"public void clearPartition(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void clearPartition(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionId,new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    for (    Data key : records.keySet()) {
      indexService.removeEntryIndex(key);
    }
  }
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  cancelAssociatedSchedulers(records.keySet());
}",0.9577464788732394
48824,"private void cancelAssociatedSchedulers(Data key){
  mapContainer.getIdleEvictionScheduler().cancel(key);
  mapContainer.getTtlEvictionScheduler().cancel(key);
}","private void cancelAssociatedSchedulers(Set<Data> keySet){
  if (keySet == null || keySet.isEmpty())   return;
  for (  Data key : keySet) {
    cancelAssociatedSchedulers(key);
  }
}",0.4534883720930232
48825,"public Object evict(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record != null) {
    flush(dataKey);
    mapService.interceptRemove(name,record.getValue());
    oldValue=record.getValue();
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removeIndex(dataKey);
  }
  return oldValue;
}","public Object evict(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record != null) {
    flush(dataKey);
    mapService.interceptRemove(name,record.getValue());
    oldValue=record.getValue();
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removeIndex(dataKey);
    cancelAssociatedSchedulers(dataKey);
  }
  return oldValue;
}",0.9488139825218476
48826,"public void removeAll(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
}","public void removeAll(){
  checkIfLoaded();
  resetSizeEstimator();
  final Collection<Data> lockedKeys=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockedRecords=new HashMap<Data,Record>(lockedKeys.size());
  for (  Data key : lockedKeys) {
    Record record=records.get(key);
    if (record != null) {
      lockedRecords.put(key,record);
      updateSizeEstimator(calculateRecordSize(record));
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockedRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.removeAll(keysToDelete);
  }
  clearRecordsMap(lockedRecords);
  cancelAllSchedulers();
}",0.9864351600651112
48827,"public void reset(){
  checkIfLoaded();
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
}","public void reset(){
  checkIfLoaded();
  clearRecordsMap(Collections.<Data,Record>emptyMap());
  resetSizeEstimator();
  cancelAllSchedulers();
}",0.906367041198502
48828,"public boolean remove(Data dataKey,Object testValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  boolean removed=false;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    if (oldValue == null)     return false;
  }
 else {
    oldValue=record.getValue();
  }
  if (mapService.compare(name,testValue,oldValue)) {
    mapService.interceptRemove(name,oldValue);
    removeIndex(dataKey);
    mapStoreDelete(record,dataKey);
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    removed=true;
  }
  return removed;
}","public boolean remove(Data dataKey,Object testValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  boolean removed=false;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    if (oldValue == null)     return false;
  }
 else {
    oldValue=record.getValue();
  }
  if (mapService.compare(name,testValue,oldValue)) {
    mapService.interceptRemove(name,oldValue);
    removeIndex(dataKey);
    mapStoreDelete(record,dataKey);
    deleteRecord(dataKey);
    updateSizeEstimator(-calculateRecordSize(record));
    cancelAssociatedSchedulers(dataKey);
    removed=true;
  }
  return removed;
}",0.970942593905032
48829,"protected void handleCommand(String command){
  if (command.contains(""String_Node_Str"")) {
    namespace=command.split(""String_Node_Str"")[0];
    command=command.substring(command.indexOf(""String_Node_Str"") + 2);
  }
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=Clock.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (Clock.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.getLifecycleService().shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    final Collection<Member> members=hazelcast.getCluster().getMembers();
    sb.append(members != null ? members.size() : 0);
    sb.append(""String_Node_Str"");
    if (members != null) {
      for (      Member member : members) {
        sb.append(""String_Node_Str"").append(member);
      }
    }
    sb.append(""String_Node_Str"");
    println(sb.toString());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberGet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberInc(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberDec(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}","protected void handleCommand(String command){
  if (command.contains(""String_Node_Str"")) {
    namespace=command.split(""String_Node_Str"")[0];
    command=command.substring(command.indexOf(""String_Node_Str"") + 2);
  }
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=Clock.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (Clock.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.getLifecycleService().shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    final Collection<Member> members=hazelcast.getCluster().getMembers();
    sb.append(members != null ? members.size() : 0);
    sb.append(""String_Node_Str"");
    if (members != null) {
      for (      Member member : members) {
        sb.append(""String_Node_Str"").append(member);
      }
    }
    sb.append(""String_Node_Str"");
    println(sb.toString());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberGet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberInc(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberDec(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}",0.9834165834165834
48830,"public boolean init(int permitCount){
  if (available != 0) {
    return false;
  }
  available=permitCount;
  return true;
}","public boolean init(int permitCount){
  if (initialized || available != 0) {
    return false;
  }
  available=permitCount;
  initialized=true;
  return true;
}",0.8771929824561403
48831,"public void readData(ObjectDataInput in) throws IOException {
  available=in.readInt();
  partitionId=in.readInt();
  backupCount=in.readInt();
  asyncBackupCount=in.readInt();
  int size=in.readInt();
  attachMap=new HashMap<String,Integer>(size);
  for (int i=0; i < size; i++) {
    String caller=in.readUTF();
    Integer val=in.readInt();
    attachMap.put(caller,val);
  }
}","public void readData(ObjectDataInput in) throws IOException {
  initialized=in.readBoolean();
  available=in.readInt();
  partitionId=in.readInt();
  backupCount=in.readInt();
  asyncBackupCount=in.readInt();
  int size=in.readInt();
  attachMap=new HashMap<String,Integer>(size);
  for (int i=0; i < size; i++) {
    String caller=in.readUTF();
    Integer val=in.readInt();
    attachMap.put(caller,val);
  }
}",0.9595959595959596
48832,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(available);
  out.writeInt(partitionId);
  out.writeInt(backupCount);
  out.writeInt(asyncBackupCount);
  out.writeInt(attachMap.size());
  for (  Map.Entry<String,Integer> entry : attachMap.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue());
  }
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeBoolean(initialized);
  out.writeInt(available);
  out.writeInt(partitionId);
  out.writeInt(backupCount);
  out.writeInt(asyncBackupCount);
  out.writeInt(attachMap.size());
  for (  Map.Entry<String,Integer> entry : attachMap.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue());
  }
}",0.9561752988047808
48833,"@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  Assert.assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    Assert.assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}","@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}",0.9941569282136896
48834,"@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  Assert.assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}","@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}",0.9951590594744122
48835,"@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}","@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}",0.9945269741985928
48836,"@Override public boolean shouldBackup(){
  return successful;
}","@Override public boolean shouldBackup(){
  return true;
}",0.9166666666666666
48837,"@Override public boolean shouldBackup(){
  return successful;
}","@Override public boolean shouldBackup(){
  return true;
}",0.9166666666666666
48838,"public boolean init(int permitCount){
  if (available != 0) {
    return false;
  }
  available=permitCount;
  return true;
}","public boolean init(int permitCount){
  if (initialized || available != 0) {
    return false;
  }
  available=permitCount;
  initialized=true;
  return true;
}",0.8771929824561403
48839,"public void readData(ObjectDataInput in) throws IOException {
  available=in.readInt();
  partitionId=in.readInt();
  backupCount=in.readInt();
  asyncBackupCount=in.readInt();
  int size=in.readInt();
  attachMap=new HashMap<String,Integer>(size);
  for (int i=0; i < size; i++) {
    String caller=in.readUTF();
    Integer val=in.readInt();
    attachMap.put(caller,val);
  }
}","public void readData(ObjectDataInput in) throws IOException {
  initialized=in.readBoolean();
  available=in.readInt();
  partitionId=in.readInt();
  backupCount=in.readInt();
  asyncBackupCount=in.readInt();
  int size=in.readInt();
  attachMap=new HashMap<String,Integer>(size);
  for (int i=0; i < size; i++) {
    String caller=in.readUTF();
    Integer val=in.readInt();
    attachMap.put(caller,val);
  }
}",0.9595959595959596
48840,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(available);
  out.writeInt(partitionId);
  out.writeInt(backupCount);
  out.writeInt(asyncBackupCount);
  out.writeInt(attachMap.size());
  for (  Map.Entry<String,Integer> entry : attachMap.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue());
  }
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeBoolean(initialized);
  out.writeInt(available);
  out.writeInt(partitionId);
  out.writeInt(backupCount);
  out.writeInt(asyncBackupCount);
  out.writeInt(attachMap.size());
  for (  Map.Entry<String,Integer> entry : attachMap.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue());
  }
}",0.9561752988047808
48841,"@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  Assert.assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    Assert.assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}","@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}",0.9941569282136896
48842,"@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  Assert.assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}","@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}",0.9951590594744122
48843,"@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}","@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}",0.9945269741985928
48844,"public boolean init(int permitCount){
  if (available != 0) {
    return false;
  }
  available=permitCount;
  return true;
}","public boolean init(int permitCount){
  if (initialized || available != 0) {
    return false;
  }
  available=permitCount;
  initialized=true;
  return true;
}",0.8771929824561403
48845,"@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  Assert.assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    Assert.assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}","@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}",0.9941569282136896
48846,"@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  Assert.assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}","@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}",0.9951590594744122
48847,"@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}","@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}",0.9945269741985928
48848,"@Override public void run(){
  recordStore.unlock(dataKey,getCallerUuid(),getThreadId());
  Record record=recordStore.getRecord(dataKey);
  if (record == null || version == record.getVersion()) {
    shouldBackup=recordStore.remove(dataKey) != null;
  }
}","@Override public void run(){
  recordStore.unlock(dataKey,getCallerUuid(),getThreadId());
  Record record=recordStore.getRecord(dataKey);
  if (record == null || version == record.getVersion()) {
    dataOldValue=getNodeEngine().toData(recordStore.remove(dataKey));
    successful=dataOldValue != null;
  }
}",0.8596802841918295
48849,"@Override public boolean shouldBackup(){
  return shouldBackup;
}","@Override public boolean shouldBackup(){
  return successful;
}",0.875
48850,"public boolean init(int permitCount){
  if (available != 0) {
    return false;
  }
  available=permitCount;
  return true;
}","public boolean init(int permitCount){
  if (initialized || available != 0) {
    return false;
  }
  available=permitCount;
  initialized=true;
  return true;
}",0.8771929824561403
48851,"@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  Assert.assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    Assert.assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}","@Test public void testSemaphoreWithFailuresAndJoin(){
  final Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance instance1=factory.newHazelcastInstance(config);
  final HazelcastInstance instance2=factory.newHazelcastInstance(config);
  final ISemaphore semaphore=instance1.getSemaphore(""String_Node_Str"");
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  assertTrue(semaphore.init(0));
  final Thread thread=new Thread(){
    public void run(){
      for (int i=0; i < 2; i++) {
        try {
          semaphore.acquire();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDownLatch.countDown();
    }
  }
;
  thread.start();
  instance2.getLifecycleService().shutdown();
  semaphore.release();
  HazelcastInstance instance3=factory.newHazelcastInstance(config);
  ISemaphore semaphore1=instance3.getSemaphore(""String_Node_Str"");
  semaphore1.release();
  try {
    assertTrue(countDownLatch.await(15,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    thread.interrupt();
  }
}",0.9941569282136896
48852,"@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  Assert.assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}","@Test public void testMutex(){
  final int k=5;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  final CountDownLatch latch=new CountDownLatch(k);
  final int loopCount=1000;
class Counter {
    int count=0;
    void inc(){
      count++;
    }
    int get(){
      return count;
    }
  }
  final Counter counter=new Counter();
  assertTrue(instances[0].getSemaphore(""String_Node_Str"").init(1));
  for (int i=0; i < k; i++) {
    final ISemaphore semaphore=instances[i].getSemaphore(""String_Node_Str"");
    new Thread(){
      public void run(){
        for (int j=0; j < loopCount; j++) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            System.err.println(""String_Node_Str"" + e.getMessage());
            return;
          }
          try {
            sleep((int)(Math.random() * 3));
            counter.inc();
          }
 catch (          InterruptedException e) {
            return;
          }
 finally {
            semaphore.release();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    Assert.assertEquals(loopCount * k,counter.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}",0.9951590594744122
48853,"@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}","@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(k);
  final HazelcastInstance[] instances=factory.newInstances(config);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}",0.9945269741985928
48854,"@Override public void run(){
  recordStore.unlock(dataKey,getCallerUuid(),getThreadId());
  Record record=recordStore.getRecord(dataKey);
  if (record == null || version == record.getVersion()) {
    shouldBackup=recordStore.remove(dataKey) != null;
  }
}","@Override public void run(){
  recordStore.unlock(dataKey,getCallerUuid(),getThreadId());
  Record record=recordStore.getRecord(dataKey);
  if (record == null || version == record.getVersion()) {
    dataOldValue=getNodeEngine().toData(recordStore.remove(dataKey));
    successful=dataOldValue != null;
  }
}",0.8596802841918295
48855,"@Override public boolean shouldBackup(){
  return shouldBackup;
}","@Override public boolean shouldBackup(){
  return successful;
}",0.875
48856,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
  }
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}",0.5542676501580611
48857,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(index);
  sb.append(""String_Node_Str"").append(fieldName).append('\'');
  sb.append(""String_Node_Str"").append(type);
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(factoryId).append('\'');
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(index);
  sb.append(""String_Node_Str"").append(fieldName).append('\'');
  sb.append(""String_Node_Str"").append(type);
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(factoryId);
  sb.append('}');
  return sb.toString();
}",0.9837702871410736
48858,"public Portable read(ObjectDataInput in) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(in instanceof PortableContextAwareInputStream)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
  final int factoryId=ctxIn.getFactoryId();
  final int dataClassId=ctxIn.getClassId();
  final int dataVersion=ctxIn.getVersion();
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(dataClassId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + dataClassId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  if (context.getVersion() == dataVersion) {
    cd=context.lookup(factoryId,dataClassId);
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    cd=context.lookup(factoryId,dataClassId,dataVersion);
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}","public Portable read(ObjectDataInput in) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(in instanceof PortableContextAwareInputStream)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
  final int factoryId=ctxIn.getFactoryId();
  final int dataClassId=ctxIn.getClassId();
  final int dataVersion=ctxIn.getVersion();
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(dataClassId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + dataClassId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  if (context.getVersion() == dataVersion) {
    cd=context.lookup(factoryId,dataClassId);
    if (cd == null) {
      throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ dataClassId+ ""String_Node_Str""+ dataVersion);
    }
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    cd=context.lookup(factoryId,dataClassId,dataVersion);
    if (cd == null) {
      throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ dataClassId+ ""String_Node_Str""+ dataVersion);
    }
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}",0.863075924724205
48859,"ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  if (cdImpl.getBinary() == null) {
    final BufferObjectDataOutput out=serializationService.pop();
    try {
      cdImpl.writeData(out);
      final byte[] binary=out.toByteArray();
      out.clear();
      compress(binary,out);
      cdImpl.setBinary(out.toByteArray());
    }
 catch (    IOException e) {
      throw new HazelcastSerializationException(e);
    }
 finally {
      serializationService.push(out);
    }
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  final ClassDefinitionImpl currentClassDef=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  if (currentClassDef == null) {
    registerNestedDefinitions(cdImpl);
    return cd;
  }
  return currentClassDef;
}","ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  if (cdImpl.getBinary() == null) {
    final BufferObjectDataOutput out=serializationService.pop();
    try {
      cdImpl.writeData(out);
      final byte[] binary=out.toByteArray();
      out.clear();
      compress(binary,out);
      cdImpl.setBinary(out.toByteArray());
    }
 catch (    IOException e) {
      throw new HazelcastSerializationException(e);
    }
 finally {
      serializationService.push(out);
    }
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  registerNestedDefinitions(cdImpl);
  final ClassDefinitionImpl currentCd=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  return currentCd == null ? cdImpl : currentCd;
}",0.8728046833422033
48860,"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  if (currentCD == null) {
    registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}","ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  registerNestedDefinitions(cd);
  final ClassDefinitionImpl currentCd=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  return currentCd == null ? cd : currentCd;
}",0.8891703609879671
48861,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(index);
  sb.append(""String_Node_Str"").append(fieldName).append('\'');
  sb.append(""String_Node_Str"").append(type);
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(factoryId).append('\'');
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(index);
  sb.append(""String_Node_Str"").append(fieldName).append('\'');
  sb.append(""String_Node_Str"").append(type);
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(factoryId);
  sb.append('}');
  return sb.toString();
}",0.9837702871410736
48862,"public Portable read(ObjectDataInput in) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(in instanceof PortableContextAwareInputStream)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
  final int factoryId=ctxIn.getFactoryId();
  final int dataClassId=ctxIn.getClassId();
  final int dataVersion=ctxIn.getVersion();
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(dataClassId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + dataClassId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  if (context.getVersion() == dataVersion) {
    cd=context.lookup(factoryId,dataClassId);
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    cd=context.lookup(factoryId,dataClassId,dataVersion);
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}","public Portable read(ObjectDataInput in) throws IOException {
  if (!(in instanceof BufferObjectDataInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(in instanceof PortableContextAwareInputStream)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
  final int factoryId=ctxIn.getFactoryId();
  final int dataClassId=ctxIn.getClassId();
  final int dataVersion=ctxIn.getVersion();
  final PortableFactory portableFactory=factories.get(factoryId);
  if (portableFactory == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + factoryId);
  }
  final Portable portable=portableFactory.create(dataClassId);
  if (portable == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + dataClassId);
  }
  final DefaultPortableReader reader;
  final ClassDefinition cd;
  final BufferObjectDataInput bufferedIn=(BufferObjectDataInput)in;
  if (context.getVersion() == dataVersion) {
    cd=context.lookup(factoryId,dataClassId);
    if (cd == null) {
      throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ dataClassId+ ""String_Node_Str""+ dataVersion);
    }
    reader=new DefaultPortableReader(this,bufferedIn,cd);
  }
 else {
    cd=context.lookup(factoryId,dataClassId,dataVersion);
    if (cd == null) {
      throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"" + factoryId + ""String_Node_Str""+ dataClassId+ ""String_Node_Str""+ dataVersion);
    }
    reader=new MorphingPortableReader(this,bufferedIn,cd);
  }
  portable.readPortable(reader);
  reader.end();
  return portable;
}",0.863075924724205
48863,"ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  if (cdImpl.getBinary() == null) {
    final BufferObjectDataOutput out=serializationService.pop();
    try {
      cdImpl.writeData(out);
      final byte[] binary=out.toByteArray();
      out.clear();
      compress(binary,out);
      cdImpl.setBinary(out.toByteArray());
    }
 catch (    IOException e) {
      throw new HazelcastSerializationException(e);
    }
 finally {
      serializationService.push(out);
    }
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  final ClassDefinitionImpl currentClassDef=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  if (currentClassDef == null) {
    registerNestedDefinitions(cdImpl);
    return cd;
  }
  return currentClassDef;
}","ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  if (cdImpl.getBinary() == null) {
    final BufferObjectDataOutput out=serializationService.pop();
    try {
      cdImpl.writeData(out);
      final byte[] binary=out.toByteArray();
      out.clear();
      compress(binary,out);
      cdImpl.setBinary(out.toByteArray());
    }
 catch (    IOException e) {
      throw new HazelcastSerializationException(e);
    }
 finally {
      serializationService.push(out);
    }
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  registerNestedDefinitions(cdImpl);
  final ClassDefinitionImpl currentCd=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  return currentCd == null ? cdImpl : currentCd;
}",0.8728046833422033
48864,"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  if (currentCD == null) {
    registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}","ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  registerNestedDefinitions(cd);
  final ClassDefinitionImpl currentCd=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  return currentCd == null ? cd : currentCd;
}",0.8891703609879671
48865,"public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}","public Map.Entry<Data,Data> getMapEntryData(Data dataKey){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object value;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
        saveIndex(record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
  }
  Data data=record != null ? mapService.toData(record.getValue()) : null;
  return new AbstractMap.SimpleImmutableEntry<Data,Data>(dataKey,data);
}",0.5542676501580611
48866,"public EntryObject key(){
  if (qb.attribute == null) {
    qb.attribute=KEY_ATTRIBUTE_NAME;
  }
 else   if (!qb.attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    qb.attribute=KEY_ATTRIBUTE_NAME + ""String_Node_Str"" + qb.attribute;
  }
  return this;
}","public EntryObject key(){
  qb.attribute=KEY_ATTRIBUTE_NAME;
  return this;
}",0.4723926380368098
48867,"public EntryObject key(){
  if (qb.attribute == null) {
    qb.attribute=KEY_ATTRIBUTE_NAME;
  }
 else   if (!qb.attribute.startsWith(KEY_ATTRIBUTE_NAME)) {
    qb.attribute=KEY_ATTRIBUTE_NAME + ""String_Node_Str"" + qb.attribute;
  }
  return this;
}","public EntryObject key(){
  qb.attribute=KEY_ATTRIBUTE_NAME;
  return this;
}",0.4723926380368098
48868,"public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    boolean response=(Boolean)op.getResponse();
  }
}","public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}",0.7624113475177305
48869,"public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,opList,getCallerUuid(),threadId);
}","public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,backupOpList,getCallerUuid(),threadId);
}",0.96875
48870,"public void run() throws Exception {
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() != version) {
    notify=false;
    return;
  }
  wrapper.incrementAndGetVersion();
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}","public void run() throws Exception {
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() != version) {
    notify=false;
    return;
  }
  wrapper.incrementAndGetVersion();
  backupOpList=new ArrayList<Operation>();
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    if (Boolean.TRUE.equals(op.getResponse())) {
      backupOpList.add(op);
    }
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}",0.8841911764705882
48871,"public void entryAdded(EntryEvent event){
  latch2Add.countDown();
}","@Override public void entryAdded(EntryEvent<Integer,Deal> arg0){
  _gateAdd.countDown();
}",0.759493670886076
48872,"public void entryRemoved(EntryEvent event){
  latch2Remove.countDown();
}","@Override public void entryRemoved(EntryEvent<Integer,Deal> arg0){
  _gateRemove.countDown();
}",0.7738095238095238
48873,"public void entryUpdated(EntryEvent event){
}","@Override public void entryUpdated(EntryEvent<Integer,Deal> arg0){
  _gateUpdate.countDown();
}",0.5857142857142857
48874,"public void entryEvicted(EntryEvent<String,String> event){
  latch.countDown();
}","@Override public void entryEvicted(EntryEvent<Integer,Deal> arg0){
  _gateEvict.countDown();
}",0.7314285714285714
48875,"public void writePortable(PortableWriter writer) throws IOException {
  writer.writeUTF(""String_Node_Str"",name);
  writer.writeBoolean(""String_Node_Str"",includeValue);
  final boolean hasKey=key != null;
  writer.writeBoolean(""String_Node_Str"",hasKey);
  if (predicate == null) {
    writer.writeBoolean(""String_Node_Str"",false);
  }
 else {
    writer.writeBoolean(""String_Node_Str"",true);
    writer.writePortable(""String_Node_Str"",(Portable)predicate);
  }
  if (hasKey) {
    final ObjectDataOutput out=writer.getRawDataOutput();
    key.writeData(out);
  }
}","public void writePortable(PortableWriter writer) throws IOException {
  writer.writeUTF(""String_Node_Str"",name);
  writer.writeBoolean(""String_Node_Str"",includeValue);
  final boolean hasKey=key != null;
  writer.writeBoolean(""String_Node_Str"",hasKey);
  if (predicate == null) {
    writer.writeBoolean(""String_Node_Str"",false);
    if (hasKey) {
      final ObjectDataOutput out=writer.getRawDataOutput();
      key.writeData(out);
    }
  }
 else {
    writer.writeBoolean(""String_Node_Str"",true);
    final ObjectDataOutput out=writer.getRawDataOutput();
    out.writeObject(predicate);
    if (hasKey) {
      key.writeData(out);
    }
  }
}",0.7196029776674938
48876,"public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    predicate=(Predicate)reader.readPortable(""String_Node_Str"");
  }
  if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=new Data();
    key.readData(in);
  }
}","public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    final ObjectDataInput in=reader.getRawDataInput();
    predicate=in.readObject();
    if (hasKey) {
      key=in.readObject();
    }
  }
 else   if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=in.readObject();
  }
}",0.741503604531411
48877,"public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    boolean response=(Boolean)op.getResponse();
  }
}","public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}",0.7624113475177305
48878,"public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,opList,getCallerUuid(),threadId);
}","public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,backupOpList,getCallerUuid(),threadId);
}",0.96875
48879,"public void run() throws Exception {
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() != version) {
    notify=false;
    return;
  }
  wrapper.incrementAndGetVersion();
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}","public void run() throws Exception {
  MultiMapWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() != version) {
    notify=false;
    return;
  }
  wrapper.incrementAndGetVersion();
  backupOpList=new ArrayList<Operation>();
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    if (Boolean.TRUE.equals(op.getResponse())) {
      backupOpList.add(op);
    }
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}",0.8841911764705882
48880,"public void entryAdded(EntryEvent event){
  latch2Add.countDown();
}","@Override public void entryAdded(EntryEvent<Integer,Deal> arg0){
  _gateAdd.countDown();
}",0.759493670886076
48881,"public void entryRemoved(EntryEvent event){
  latch2Remove.countDown();
}","@Override public void entryRemoved(EntryEvent<Integer,Deal> arg0){
  _gateRemove.countDown();
}",0.7738095238095238
48882,"public void entryUpdated(EntryEvent event){
}","@Override public void entryUpdated(EntryEvent<Integer,Deal> arg0){
  _gateUpdate.countDown();
}",0.5857142857142857
48883,"public void entryEvicted(EntryEvent<String,String> event){
  latch.countDown();
}","@Override public void entryEvicted(EntryEvent<Integer,Deal> arg0){
  _gateEvict.countDown();
}",0.7314285714285714
48884,"public void writePortable(PortableWriter writer) throws IOException {
  writer.writeUTF(""String_Node_Str"",name);
  writer.writeBoolean(""String_Node_Str"",includeValue);
  final boolean hasKey=key != null;
  writer.writeBoolean(""String_Node_Str"",hasKey);
  if (predicate == null) {
    writer.writeBoolean(""String_Node_Str"",false);
  }
 else {
    writer.writeBoolean(""String_Node_Str"",true);
    writer.writePortable(""String_Node_Str"",(Portable)predicate);
  }
  if (hasKey) {
    final ObjectDataOutput out=writer.getRawDataOutput();
    key.writeData(out);
  }
}","public void writePortable(PortableWriter writer) throws IOException {
  writer.writeUTF(""String_Node_Str"",name);
  writer.writeBoolean(""String_Node_Str"",includeValue);
  final boolean hasKey=key != null;
  writer.writeBoolean(""String_Node_Str"",hasKey);
  if (predicate == null) {
    writer.writeBoolean(""String_Node_Str"",false);
    if (hasKey) {
      final ObjectDataOutput out=writer.getRawDataOutput();
      key.writeData(out);
    }
  }
 else {
    writer.writeBoolean(""String_Node_Str"",true);
    final ObjectDataOutput out=writer.getRawDataOutput();
    out.writeObject(predicate);
    if (hasKey) {
      key.writeData(out);
    }
  }
}",0.7196029776674938
48885,"public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    predicate=(Predicate)reader.readPortable(""String_Node_Str"");
  }
  if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=new Data();
    key.readData(in);
  }
}","public void readPortable(PortableReader reader) throws IOException {
  name=reader.readUTF(""String_Node_Str"");
  includeValue=reader.readBoolean(""String_Node_Str"");
  boolean hasKey=reader.readBoolean(""String_Node_Str"");
  if (reader.readBoolean(""String_Node_Str"")) {
    final ObjectDataInput in=reader.getRawDataInput();
    predicate=in.readObject();
    if (hasKey) {
      key=in.readObject();
    }
  }
 else   if (hasKey) {
    final ObjectDataInput in=reader.getRawDataInput();
    key=in.readObject();
  }
}",0.741503604531411
48886,"public boolean replace(Data dataKey,Object testValue,Object newValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null)   return false;
  if (mapService.compare(name,record.getValue(),testValue)) {
    newValue=mapService.interceptPut(name,record.getValue(),newValue);
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    return false;
  }
  saveIndex(record);
  return true;
}","public boolean replace(Data dataKey,Object testValue,Object newValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null)   return false;
  if (mapService.compare(name,record.getValue(),testValue)) {
    newValue=mapService.interceptPut(name,record.getValue(),newValue);
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    return false;
  }
  saveIndex(record);
  return true;
}",0.8233246301131418
48887,"public void putTransient(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}","public void putTransient(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}",0.5639396346306592
48888,"public Object put(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    if (mapService.compare(name,oldValue,value)) {
      accessRecord(record);
      updateTtl(record,ttl);
    }
 else {
      mapStoreWrite(record,dataKey,value);
      updateSizeEstimator(-calculateRecordSize(record));
      setRecordValue(record,value);
      updateSizeEstimator(calculateRecordSize(record));
      updateTtl(record,ttl);
      saveIndex(record);
    }
  }
  return oldValue;
}","public Object put(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null || record.getValue() == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    if (mapService.compare(name,oldValue,value)) {
      accessRecord(record);
      updateTtl(record,ttl);
    }
 else {
      mapStoreWrite(record,dataKey,value);
      updateSizeEstimator(-calculateRecordSize(record));
      setRecordValue(record,value);
      updateSizeEstimator(calculateRecordSize(record));
      updateTtl(record,ttl);
      saveIndex(record);
    }
  }
  return oldValue;
}",0.9863142991977348
48889,"public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}","public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null || record.getValue() == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}",0.9884600079586152
48890,"public void putFromLoad(Data dataKey,Object value,long ttl){
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}","public void putFromLoad(Data dataKey,Object value,long ttl){
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}",0.549630844954881
48891,"public boolean tryPut(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return true;
}","public boolean tryPut(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return true;
}",0.9799585348997928
48892,"public boolean set(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  boolean newRecord=false;
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return newRecord;
}","public boolean set(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  boolean newRecord=false;
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return newRecord;
}",0.565695792880259
48893,"public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}","public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null || record.getValue() == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}",0.9841961852861036
48894,"public Record createRecord(String name,Data dataKey,Object value,long ttl,boolean shouldSchedule){
  MapContainer mapContainer=getMapContainer(name);
  Record record=mapContainer.getRecordFactory().newRecord(dataKey,value);
  if (shouldSchedule) {
    if (ttl < 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
      scheduleTtlEviction(name,record,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    }
    if (ttl > 0) {
      scheduleTtlEviction(name,record,ttl);
    }
    if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
      scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    }
  }
  return record;
}","public Record createRecord(String name,Data dataKey,Object value,long ttl,boolean shouldSchedule){
  MapContainer mapContainer=getMapContainer(name);
  Record record=mapContainer.getRecordFactory().newRecord(dataKey,value);
  if (shouldSchedule) {
    if (ttl < 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
      scheduleTtlEviction(name,record,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    }
 else     if (ttl > 0) {
      scheduleTtlEviction(name,record,ttl);
    }
 else     if (mapContainer.getStore() != null) {
      mapContainer.getTtlEvictionScheduler().cancel(record.getKey());
    }
    if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
      scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    }
  }
  return record;
}",0.9128409846972722
48895,"public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    boolean response=(Boolean)op.getResponse();
  }
}","public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,caller,threadId);
}",0.8153310104529616
48896,"public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,opList,getCallerUuid(),threadId);
}","public Operation getBackupOperation(){
  List<Operation> backupOpList=new ArrayList<Operation>();
  for (  Operation operation : opList) {
    if (operation instanceof BackupAwareOperation) {
      backupOpList.add(operation);
    }
  }
  return new TxnCommitBackupOperation(name,dataKey,backupOpList,getCallerUuid(),threadId);
}",0.5462555066079295
48897,"public boolean replace(Data dataKey,Object testValue,Object newValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null)   return false;
  if (mapService.compare(name,record.getValue(),testValue)) {
    newValue=mapService.interceptPut(name,record.getValue(),newValue);
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    return false;
  }
  saveIndex(record);
  return true;
}","public boolean replace(Data dataKey,Object testValue,Object newValue){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null)   return false;
  if (mapService.compare(name,record.getValue(),testValue)) {
    newValue=mapService.interceptPut(name,record.getValue(),newValue);
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    return false;
  }
  saveIndex(record);
  return true;
}",0.8233246301131418
48898,"public void putTransient(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}","public void putTransient(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}",0.5639396346306592
48899,"public Object put(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    if (mapService.compare(name,oldValue,value)) {
      accessRecord(record);
      updateTtl(record,ttl);
    }
 else {
      mapStoreWrite(record,dataKey,value);
      updateSizeEstimator(-calculateRecordSize(record));
      setRecordValue(record,value);
      updateSizeEstimator(calculateRecordSize(record));
      updateTtl(record,ttl);
      saveIndex(record);
    }
  }
  return oldValue;
}","public Object put(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null || record.getValue() == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
    }
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    saveIndex(record);
  }
 else {
    oldValue=record.getValue();
    value=mapService.interceptPut(name,oldValue,value);
    if (mapService.compare(name,oldValue,value)) {
      accessRecord(record);
      updateTtl(record,ttl);
    }
 else {
      mapStoreWrite(record,dataKey,value);
      updateSizeEstimator(-calculateRecordSize(record));
      setRecordValue(record,value);
      updateSizeEstimator(calculateRecordSize(record));
      updateTtl(record,ttl);
      saveIndex(record);
    }
  }
  return oldValue;
}",0.9863142991977348
48900,"public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}","public boolean merge(Data dataKey,EntryView mergingEntry,MapMergePolicy mergePolicy){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object newValue=null;
  if (record == null || record.getValue() == null) {
    newValue=mergingEntry.getValue();
    record=mapService.createRecord(name,dataKey,newValue,-1);
    mapStoreWrite(record,dataKey,newValue);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    Object oldValue=record.getValue();
    EntryView existingEntry=new SimpleEntryView(mapService.toObject(record.getKey()),mapService.toObject(record.getValue()),record.getStatistics(),record.getVersion());
    newValue=mergePolicy.merge(name,mergingEntry,existingEntry);
    if (newValue == null) {
      deleteRecord(dataKey);
      removeIndex(dataKey);
      mapStoreDelete(record,dataKey);
      updateSizeEstimator(-calculateRecordSize(record));
      return true;
    }
    if (mapService.compare(name,newValue,oldValue)) {
      return true;
    }
    mapStoreWrite(record,dataKey,newValue);
    updateSizeEstimator(-calculateRecordSize(record));
    recordFactory.setValue(record,newValue);
    updateSizeEstimator(calculateRecordSize(record));
  }
  saveIndex(record);
  return newValue != null;
}",0.9884600079586152
48901,"public void putFromLoad(Data dataKey,Object value,long ttl){
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}","public void putFromLoad(Data dataKey,Object value,long ttl){
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
}",0.549630844954881
48902,"public boolean tryPut(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return true;
}","public boolean tryPut(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return true;
}",0.9799585348997928
48903,"public boolean set(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  boolean newRecord=false;
  if (record == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return newRecord;
}","public boolean set(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  boolean newRecord=false;
  if (record == null || record.getValue() == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    newRecord=true;
  }
 else {
    value=mapService.interceptPut(name,record.getValue(),value);
    mapStoreWrite(record,dataKey,value);
    updateSizeEstimator(-calculateRecordSize(record));
    setRecordValue(record,value);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return newRecord;
}",0.565695792880259
48904,"public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}","public Object putIfAbsent(Data dataKey,Object value,long ttl){
  checkIfLoaded();
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record == null || record.getValue() == null) {
    if (mapContainer.getStore() != null) {
      oldValue=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (oldValue != null) {
        record=mapService.createRecord(name,dataKey,oldValue,-1);
        records.put(dataKey,record);
        updateSizeEstimator(calculateRecordSize(record));
      }
    }
  }
 else {
    accessRecord(record);
    oldValue=record.getValue();
  }
  if (oldValue == null) {
    value=mapService.interceptPut(name,null,value);
    record=mapService.createRecord(name,dataKey,value,ttl);
    mapStoreWrite(record,dataKey,value);
    records.put(dataKey,record);
    updateSizeEstimator(calculateRecordSize(record));
    updateTtl(record,ttl);
  }
  saveIndex(record);
  return oldValue;
}",0.9841961852861036
48905,"public Record createRecord(String name,Data dataKey,Object value,long ttl,boolean shouldSchedule){
  MapContainer mapContainer=getMapContainer(name);
  Record record=mapContainer.getRecordFactory().newRecord(dataKey,value);
  if (shouldSchedule) {
    if (ttl < 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
      scheduleTtlEviction(name,record,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    }
    if (ttl > 0) {
      scheduleTtlEviction(name,record,ttl);
    }
    if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
      scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    }
  }
  return record;
}","public Record createRecord(String name,Data dataKey,Object value,long ttl,boolean shouldSchedule){
  MapContainer mapContainer=getMapContainer(name);
  Record record=mapContainer.getRecordFactory().newRecord(dataKey,value);
  if (shouldSchedule) {
    if (ttl < 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
      scheduleTtlEviction(name,record,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    }
 else     if (ttl > 0) {
      scheduleTtlEviction(name,record,ttl);
    }
 else     if (mapContainer.getStore() != null) {
      mapContainer.getTtlEvictionScheduler().cancel(record.getKey());
    }
    if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
      scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    }
  }
  return record;
}",0.9128409846972722
48906,"public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[39];
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsEntryOperation();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CountOperation();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new EntrySetOperation();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetAllOperation();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeySetOperation();
    }
  }
;
  constructors[PUT_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PutBackupOperation();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PutOperation();
    }
  }
;
  constructors[REMOVE_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveAllBackupOperation();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveAllOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ValuesOperation();
    }
  }
;
  constructors[TXN_COMMIT_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnCommitBackupOperation();
    }
  }
;
  constructors[TXN_COMMIT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnCommitOperation();
    }
  }
;
  constructors[TXN_GENERATE_RECORD_ID]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnGenerateRecordIdOperation();
    }
  }
;
  constructors[TXN_LOCK_AND_GET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnLockAndGetOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_PUT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPutOperation();
    }
  }
;
  constructors[TXN_REMOVE_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveAllOperation();
    }
  }
;
  constructors[TXN_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[TXN_ROLLBACK_BACKUP + 1];
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[CONTAINS_ENTRY]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsEntryOperation();
    }
  }
;
  constructors[COUNT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CountOperation();
    }
  }
;
  constructors[ENTRY_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new EntrySetOperation();
    }
  }
;
  constructors[GET_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new GetAllOperation();
    }
  }
;
  constructors[KEY_SET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new KeySetOperation();
    }
  }
;
  constructors[PUT_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PutBackupOperation();
    }
  }
;
  constructors[PUT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PutOperation();
    }
  }
;
  constructors[REMOVE_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveAllBackupOperation();
    }
  }
;
  constructors[REMOVE_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveAllOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[VALUES]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ValuesOperation();
    }
  }
;
  constructors[TXN_COMMIT_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnCommitBackupOperation();
    }
  }
;
  constructors[TXN_COMMIT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnCommitOperation();
    }
  }
;
  constructors[TXN_GENERATE_RECORD_ID]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnGenerateRecordIdOperation();
    }
  }
;
  constructors[TXN_LOCK_AND_GET]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnLockAndGetOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_PUT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPutOperation();
    }
  }
;
  constructors[TXN_PUT_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPutBackupOperation();
    }
  }
;
  constructors[TXN_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveOperation();
    }
  }
;
  constructors[TXN_REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveBackupOperation();
    }
  }
;
  constructors[TXN_REMOVE_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveAllOperation();
    }
  }
;
  constructors[TXN_REMOVE_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRemoveAllBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9403097530347426
48907,"public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
    boolean response=(Boolean)op.getResponse();
  }
}","public void run() throws Exception {
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,caller,threadId);
}",0.8153310104529616
48908,"public Operation getBackupOperation(){
  return new TxnCommitBackupOperation(name,dataKey,opList,getCallerUuid(),threadId);
}","public Operation getBackupOperation(){
  List<Operation> backupOpList=new ArrayList<Operation>();
  for (  Operation operation : opList) {
    if (operation instanceof BackupAwareOperation) {
      BackupAwareOperation backupAwareOperation=(BackupAwareOperation)operation;
      if (backupAwareOperation.shouldBackup()) {
        backupOpList.add(backupAwareOperation.getBackupOperation());
      }
    }
  }
  return new TxnCommitBackupOperation(name,dataKey,backupOpList,getCallerUuid(),threadId);
}",0.3961661341853035
48909,"protected Comparable convert(Map.Entry mapEntry,Comparable entryValue,Comparable attributeValue){
  if (attributeValue == null) {
    return null;
  }
  AttributeType type=attributeType;
  if (type == null) {
    QueryableEntry queryableEntry=(QueryableEntry)mapEntry;
    type=queryableEntry.getAttributeType(attribute);
    attributeType=type;
  }
  if (type == AttributeType.ENUM) {
    return type.getConverter().convert(attributeValue);
  }
 else {
    if (entryValue != null && entryValue.getClass().isAssignableFrom(attributeValue.getClass())) {
      return attributeValue;
    }
 else     if (type != null) {
      return type.getConverter().convert(attributeValue);
    }
 else {
      throw new QueryException(""String_Node_Str"" + attributeValue.getClass());
    }
  }
}","protected Comparable convert(Map.Entry mapEntry,Comparable entryValue,Comparable attributeValue){
  if (attributeValue == null) {
    return null;
  }
  if (attributeValue instanceof IndexImpl.NullObject) {
    return IndexImpl.NULL;
  }
  AttributeType type=attributeType;
  if (type == null) {
    QueryableEntry queryableEntry=(QueryableEntry)mapEntry;
    type=queryableEntry.getAttributeType(attribute);
    attributeType=type;
  }
  if (type == AttributeType.ENUM) {
    return type.getConverter().convert(attributeValue);
  }
 else {
    if (entryValue != null && entryValue.getClass().isAssignableFrom(attributeValue.getClass())) {
      return attributeValue;
    }
 else     if (type != null) {
      return type.getConverter().convert(attributeValue);
    }
 else {
      throw new QueryException(""String_Node_Str"" + attributeValue.getClass());
    }
  }
}",0.9471766848816028
48910,"public void newIndex(Comparable newValue,QueryableEntry record){
  ConcurrentMap<Data,QueryableEntry> records=mapRecords.get(newValue);
  if (records == null) {
    records=new ConcurrentHashMap<Data,QueryableEntry>(1,0.75f,1);
    mapRecords.put(newValue,records);
    sortedSet.add(newValue);
  }
  records.put(record.getIndexKey(),record);
}","public void newIndex(Comparable newValue,QueryableEntry record){
  ConcurrentMap<Data,QueryableEntry> records=mapRecords.get(newValue);
  if (records == null) {
    records=new ConcurrentHashMap<Data,QueryableEntry>(1,0.75f,1);
    mapRecords.put(newValue,records);
    if (!(newValue instanceof IndexImpl.NullObject)) {
      sortedSet.add(newValue);
    }
  }
  records.put(record.getIndexKey(),record);
}",0.9161118508655126
48911,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  Map.Entry entry=new AbstractMap.SimpleEntry(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
  response=mapService.toData(entryProcessor.process(entry));
  recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
}","public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  Map.Entry entry=new AbstractMap.SimpleEntry(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
  response=mapService.toData(entryProcessor.process(entry));
  if (entry.getValue() == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (mapEntry.getValue() == null) {
      eventType=EntryEventType.ADDED;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}",0.0986964618249534
48912,"public void afterRun() throws Exception {
  super.afterRun();
  invalidateNearCaches();
}","public void afterRun() throws Exception {
  super.afterRun();
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),recordStore.getRecords().get(dataKey));
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.2448418156808803
48913,"public void processBackup(Map.Entry entry){
  entry.setValue((Integer)entry.getValue() + 1);
}","public void processBackup(Map.Entry entry){
  entry.setValue(value);
}",0.8414634146341463
48914,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  Map.Entry entry=new AbstractMap.SimpleEntry(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
  response=mapService.toData(entryProcessor.process(entry));
  if (entry.getValue() == null) {
    recordStore.remove(dataKey);
  }
 else {
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
  }
}","public void run(){
  Map.Entry<Data,Data> mapEntry=recordStore.getMapEntryData(dataKey);
  dataOldValue=mapEntry.getValue();
  Map.Entry entry=new AbstractMap.SimpleEntry(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
  response=mapService.toData(entryProcessor.process(entry));
  if (entry.getValue() == null) {
    recordStore.remove(dataKey);
    eventType=EntryEventType.REMOVED;
  }
 else {
    if (mapEntry.getValue() == null) {
      eventType=EntryEventType.ADDED;
    }
 else {
      eventType=EntryEventType.UPDATED;
    }
    dataValue=mapService.toData(entry.getValue());
    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,dataValue));
  }
}",0.1035375323554788
48915,"public void afterRun() throws Exception {
  super.afterRun();
  invalidateNearCaches();
}","public void afterRun() throws Exception {
  super.afterRun();
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
    if (EntryEventType.REMOVED.equals(eventType)) {
      mapService.publishWanReplicationRemove(name,dataKey,Clock.currentTimeMillis());
    }
 else {
      SimpleEntryView entryView=new SimpleEntryView(dataKey,mapService.toData(dataValue),recordStore.getRecords().get(dataKey));
      mapService.publishWanReplicationUpdate(name,entryView);
    }
  }
}",0.2448418156808803
48916,"public void processBackup(Map.Entry entry){
  entry.setValue((Integer)entry.getValue() + 1);
}","public void processBackup(Map.Entry entry){
  entry.setValue(value);
}",0.8414634146341463
48917,"public void memberAdded(MembershipEvent membershipEvent){
  try {
    Member member=membershipEvent.getMember();
    if (member != null && instance.node.isMaster() && urlChanged) {
      ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(webServerUrl);
      call(((MemberImpl)member).getAddress(),operation);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}","public void memberAdded(MembershipEvent membershipEvent){
  try {
    Member member=membershipEvent.getMember();
    if (member != null && instance.node.isMaster() && urlChanged) {
      ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(webServerUrl);
      callOnMember(member,operation);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}",0.9400244798041616
48918,"public byte[] changeWebServerUrlOverCluster(String groupName,String groupPass,String newUrl){
  try {
    GroupConfig groupConfig=instance.getConfig().getGroupConfig();
    if (!(groupConfig.getName().equals(groupName) && groupConfig.getPassword().equals(groupPass)))     return HttpCommand.RES_403;
    ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(newUrl);
    sendToAllMembers(operation);
  }
 catch (  Throwable throwable) {
    logger.warning(""String_Node_Str"",throwable);
    return HttpCommand.RES_500;
  }
  return HttpCommand.RES_204;
}","public byte[] changeWebServerUrlOverCluster(String groupName,String groupPass,String newUrl){
  try {
    GroupConfig groupConfig=instance.getConfig().getGroupConfig();
    if (!(groupConfig.getName().equals(groupName) && groupConfig.getPassword().equals(groupPass)))     return HttpCommand.RES_403;
    final Collection<MemberImpl> memberList=instance.node.clusterService.getMemberList();
    for (    MemberImpl member : memberList) {
      send(member.getAddress(),new ManagementCenterConfigOperation(newUrl));
    }
  }
 catch (  Throwable throwable) {
    logger.warning(""String_Node_Str"",throwable);
    return HttpCommand.RES_500;
  }
  return HttpCommand.RES_204;
}",0.8048
48919,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Object result=null;
  ScriptExecutorOperation operation=new ScriptExecutorOperation(engine,script,bindings);
  if (targetAllMembers) {
    result=mcs.callOnAllMembers(operation);
  }
 else   if (targets.isEmpty()) {
    result=NULL;
  }
 else   if (targets.size() == 1) {
    result=mcs.call(targets.iterator().next(),operation);
  }
 else {
    result=mcs.callOnAddresses(targets,operation);
  }
  if (result != null) {
    if (result instanceof Map) {
      dos.writeByte(MAP);
      writeMap(dos,(Map)result);
    }
 else     if (result instanceof Collection) {
      dos.writeByte(COLLECTION);
      writeCollection(dos,(Collection)result);
    }
 else {
      dos.writeByte(OTHER);
      dos.writeObject(result);
    }
  }
 else {
    dos.writeByte(NULL);
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Object result=null;
  if (targetAllMembers) {
    final Set<Member> members=mcs.getHazelcastInstance().getCluster().getMembers();
    final ArrayList list=new ArrayList(members.size());
    for (    Member member : members) {
      list.add(mcs.callOnMember(member,new ScriptExecutorOperation(engine,script,bindings)));
    }
    result=list;
  }
 else {
    final ArrayList list=new ArrayList(targets.size());
    for (    Address address : targets) {
      list.add(mcs.callOnAddress(address,new ScriptExecutorOperation(engine,script,bindings)));
    }
    result=list;
  }
  if (result != null) {
    if (result instanceof Map) {
      dos.writeByte(MAP);
      writeMap(dos,(Map)result);
    }
 else     if (result instanceof Collection) {
      dos.writeByte(COLLECTION);
      writeCollection(dos,(Collection)result);
    }
 else {
      dos.writeByte(OTHER);
      dos.writeObject(result);
    }
  }
 else {
    dos.writeByte(NULL);
  }
}",0.6099737532808399
48920,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  dos.writeBoolean(update);
  if (update) {
    mcs.callOnAllMembers(new UpdateMapConfigOperation(map,config));
    dos.writeUTF(""String_Node_Str"");
  }
 else {
    MapConfig cfg=(MapConfig)mcs.call(target,new GetMapConfigOperation(map));
    if (cfg != null) {
      dos.writeBoolean(true);
      new MapConfigAdapter(cfg).writeData(dos);
    }
 else {
      dos.writeBoolean(false);
    }
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  dos.writeBoolean(update);
  if (update) {
    final Set<Member> members=mcs.getHazelcastInstance().getCluster().getMembers();
    for (    Member member : members) {
      mcs.callOnMember(member,new UpdateMapConfigOperation(map,config));
    }
    dos.writeUTF(""String_Node_Str"");
  }
 else {
    MapConfig cfg=(MapConfig)mcs.callOnAddress(target,new GetMapConfigOperation(map));
    if (cfg != null) {
      dos.writeBoolean(true);
      new MapConfigAdapter(cfg).writeData(dos);
    }
 else {
      dos.writeBoolean(false);
    }
  }
}",0.8525754884547069
48921,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  String threadDump=(String)mcs.call(target,new ThreadDumpOperation(isDeadlock));
  if (threadDump != null) {
    dos.writeBoolean(true);
    writeLongString(dos,threadDump);
  }
 else {
    dos.writeBoolean(false);
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  String threadDump=(String)mcs.callOnAddress(target,new ThreadDumpOperation(isDeadlock));
  if (threadDump != null) {
    dos.writeBoolean(true);
    writeLongString(dos,threadDump);
  }
 else {
    dos.writeBoolean(false);
  }
}",0.9859594383775352
48922,"protected Set<Data> localKeySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnTargetPartitions(SERVICE_NAME,new BinaryOperationFactory(new MapKeySetOperation(name),nodeEngine),nodeEngine.getThisAddress());
    Set<Data> keySet=new HashSet<Data>();
    for (    Object result : results.values()) {
      Set keys=((MapKeySet)getService().toObject(result)).getKeySet();
      keySet.addAll(keys);
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected Set<Data> localKeySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Set<Data> keySet=new HashSet<Data>();
  try {
    List<Integer> memberPartitions=nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress());
    for (    Integer memberPartition : memberPartitions) {
      RecordStore recordStore=mapService.getRecordStore(memberPartition,name);
      keySet.addAll(recordStore.getRecords().keySet());
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.4982935153583617
48923,"protected Set<Data> localKeySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnTargetPartitions(SERVICE_NAME,new BinaryOperationFactory(new MapKeySetOperation(name),nodeEngine),nodeEngine.getThisAddress());
    Set<Data> keySet=new HashSet<Data>();
    for (    Object result : results.values()) {
      Set keys=((MapKeySet)getService().toObject(result)).getKeySet();
      keySet.addAll(keys);
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected Set<Data> localKeySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  final MapService mapService=getService();
  Set<Data> keySet=new HashSet<Data>();
  try {
    List<Integer> memberPartitions=nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress());
    for (    Integer memberPartition : memberPartitions) {
      RecordStore recordStore=mapService.getRecordStore(memberPartition,name);
      keySet.addAll(recordStore.getRecords().keySet());
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.4982935153583617
48924,"public void memberAdded(MembershipEvent membershipEvent){
  try {
    Member member=membershipEvent.getMember();
    if (member != null && instance.node.isMaster() && urlChanged) {
      ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(webServerUrl);
      call(((MemberImpl)member).getAddress(),operation);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}","public void memberAdded(MembershipEvent membershipEvent){
  try {
    Member member=membershipEvent.getMember();
    if (member != null && instance.node.isMaster() && urlChanged) {
      ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(webServerUrl);
      callOnMember(member,operation);
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}",0.9400244798041616
48925,"public byte[] changeWebServerUrlOverCluster(String groupName,String groupPass,String newUrl){
  try {
    GroupConfig groupConfig=instance.getConfig().getGroupConfig();
    if (!(groupConfig.getName().equals(groupName) && groupConfig.getPassword().equals(groupPass)))     return HttpCommand.RES_403;
    ManagementCenterConfigOperation operation=new ManagementCenterConfigOperation(newUrl);
    sendToAllMembers(operation);
  }
 catch (  Throwable throwable) {
    logger.warning(""String_Node_Str"",throwable);
    return HttpCommand.RES_500;
  }
  return HttpCommand.RES_204;
}","public byte[] changeWebServerUrlOverCluster(String groupName,String groupPass,String newUrl){
  try {
    GroupConfig groupConfig=instance.getConfig().getGroupConfig();
    if (!(groupConfig.getName().equals(groupName) && groupConfig.getPassword().equals(groupPass)))     return HttpCommand.RES_403;
    final Collection<MemberImpl> memberList=instance.node.clusterService.getMemberList();
    for (    MemberImpl member : memberList) {
      send(member.getAddress(),new ManagementCenterConfigOperation(newUrl));
    }
  }
 catch (  Throwable throwable) {
    logger.warning(""String_Node_Str"",throwable);
    return HttpCommand.RES_500;
  }
  return HttpCommand.RES_204;
}",0.8048
48926,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Object result=null;
  ScriptExecutorOperation operation=new ScriptExecutorOperation(engine,script,bindings);
  if (targetAllMembers) {
    result=mcs.callOnAllMembers(operation);
  }
 else   if (targets.isEmpty()) {
    result=NULL;
  }
 else   if (targets.size() == 1) {
    result=mcs.call(targets.iterator().next(),operation);
  }
 else {
    result=mcs.callOnAddresses(targets,operation);
  }
  if (result != null) {
    if (result instanceof Map) {
      dos.writeByte(MAP);
      writeMap(dos,(Map)result);
    }
 else     if (result instanceof Collection) {
      dos.writeByte(COLLECTION);
      writeCollection(dos,(Collection)result);
    }
 else {
      dos.writeByte(OTHER);
      dos.writeObject(result);
    }
  }
 else {
    dos.writeByte(NULL);
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  Object result=null;
  if (targetAllMembers) {
    final Set<Member> members=mcs.getHazelcastInstance().getCluster().getMembers();
    final ArrayList list=new ArrayList(members.size());
    for (    Member member : members) {
      list.add(mcs.callOnMember(member,new ScriptExecutorOperation(engine,script,bindings)));
    }
    result=list;
  }
 else {
    final ArrayList list=new ArrayList(targets.size());
    for (    Address address : targets) {
      list.add(mcs.callOnAddress(address,new ScriptExecutorOperation(engine,script,bindings)));
    }
    result=list;
  }
  if (result != null) {
    if (result instanceof Map) {
      dos.writeByte(MAP);
      writeMap(dos,(Map)result);
    }
 else     if (result instanceof Collection) {
      dos.writeByte(COLLECTION);
      writeCollection(dos,(Collection)result);
    }
 else {
      dos.writeByte(OTHER);
      dos.writeObject(result);
    }
  }
 else {
    dos.writeByte(NULL);
  }
}",0.6099737532808399
48927,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  dos.writeBoolean(update);
  if (update) {
    mcs.callOnAllMembers(new UpdateMapConfigOperation(map,config));
    dos.writeUTF(""String_Node_Str"");
  }
 else {
    MapConfig cfg=(MapConfig)mcs.call(target,new GetMapConfigOperation(map));
    if (cfg != null) {
      dos.writeBoolean(true);
      new MapConfigAdapter(cfg).writeData(dos);
    }
 else {
      dos.writeBoolean(false);
    }
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  dos.writeBoolean(update);
  if (update) {
    final Set<Member> members=mcs.getHazelcastInstance().getCluster().getMembers();
    for (    Member member : members) {
      mcs.callOnMember(member,new UpdateMapConfigOperation(map,config));
    }
    dos.writeUTF(""String_Node_Str"");
  }
 else {
    MapConfig cfg=(MapConfig)mcs.callOnAddress(target,new GetMapConfigOperation(map));
    if (cfg != null) {
      dos.writeBoolean(true);
      new MapConfigAdapter(cfg).writeData(dos);
    }
 else {
      dos.writeBoolean(false);
    }
  }
}",0.8525754884547069
48928,"public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  String threadDump=(String)mcs.call(target,new ThreadDumpOperation(isDeadlock));
  if (threadDump != null) {
    dos.writeBoolean(true);
    writeLongString(dos,threadDump);
  }
 else {
    dos.writeBoolean(false);
  }
}","public void writeResponse(ManagementCenterService mcs,ObjectDataOutput dos) throws Exception {
  String threadDump=(String)mcs.callOnAddress(target,new ThreadDumpOperation(isDeadlock));
  if (threadDump != null) {
    dos.writeBoolean(true);
    writeLongString(dos,threadDump);
  }
 else {
    dos.writeBoolean(false);
  }
}",0.9859594383775352
48929,"public Operation getBackupOperation(){
  return new CompareAndRemoveBackupOperation(proxyId,dataKey,idSet);
}","public Operation getBackupOperation(){
  return new CompareAndRemoveBackupOperation(proxyId,dataKey,idMap.keySet());
}",0.960352422907489
48930,"public void run() throws Exception {
  CollectionWrapper wrapper=getCollectionWrapper();
  if (wrapper == null) {
    response=false;
    return;
  }
  idSet=new HashSet<Long>();
  List objList=dataList;
  if (!isBinary()) {
    objList=new ArrayList(dataList.size());
    for (    Data data : dataList) {
      objList.add(toObject(data));
    }
  }
  Iterator<CollectionRecord> iter=wrapper.getCollection().iterator();
  while (iter.hasNext()) {
    CollectionRecord record=iter.next();
    boolean contains=objList.contains(record.getObject());
    if ((contains && !retain) || (!contains && retain)) {
      idSet.add(record.getRecordId());
      iter.remove();
    }
  }
  response=!idSet.isEmpty();
  if (wrapper.getCollection().isEmpty()) {
    removeCollection();
  }
}","public void run() throws Exception {
  CollectionWrapper wrapper=getCollectionWrapper();
  if (wrapper == null) {
    response=false;
    return;
  }
  idMap=new HashMap<Long,CollectionRecord>();
  List objList=dataList;
  if (!isBinary()) {
    objList=new ArrayList(dataList.size());
    for (    Data data : dataList) {
      objList.add(toObject(data));
    }
  }
  Iterator<CollectionRecord> iter=wrapper.getCollection().iterator();
  while (iter.hasNext()) {
    CollectionRecord record=iter.next();
    boolean contains=objList.contains(record.getObject());
    if ((contains && !retain) || (!contains && retain)) {
      idMap.put(record.getRecordId(),record);
      iter.remove();
    }
  }
  response=!idMap.isEmpty();
  if (wrapper.getCollection().isEmpty()) {
    removeCollection();
  }
}",0.964512040557668
48931,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=connectionAttempts * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.8167420814479638
48932,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=connectionAttempts * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=((long)connectionAttempts) * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9960629921259844
48933,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=connectionAttempts * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.8167420814479638
48934,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=connectionAttempts * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    int connectionAttemptPeriodMs=client.getClientConfig().getConnectionAttemptPeriod();
    int connectionAttempts=client.getClientConfig().getConnectionAttemptLimit();
    long timeoutMs=((long)connectionAttempts) * connectionAttemptPeriodMs + 1000;
    final Connection connection=f.get(timeoutMs,TimeUnit.MILLISECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9960629921259844
48935,"private Object waitForResponse(long time,TimeUnit unit){
  long timeout=unit.toMillis(time);
  if (timeout < 0)   timeout=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeout > maxCallTimeout;
  int pollCount=0;
  InterruptedException interrupted=null;
  while (timeout >= 0) {
    final long pollTimeout=Math.min(maxCallTimeout,timeout);
    final long start=Clock.currentTimeMillis();
    final Object response;
    final long lastPollTime;
    try {
      response=responseQ.poll(pollTimeout,TimeUnit.MILLISECONDS);
      lastPollTime=Clock.currentTimeMillis() - start;
      timeout=decrementTimeout(timeout,lastPollTime);
    }
 catch (    InterruptedException e) {
      logger.finest(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ op);
      interrupted=e;
      if (!nodeEngine.isActive()) {
        return e;
      }
      continue;
    }
    pollCount++;
    if (response == RETRY_RESPONSE) {
      if (interrupted != null) {
        return interrupted;
      }
      if (timeout > 0) {
        if (invokeCount > 5) {
          final long sleepTime=tryPauseMillis;
          try {
            Thread.sleep(sleepTime);
            timeout=decrementTimeout(timeout,sleepTime);
          }
 catch (          InterruptedException e) {
            return e;
          }
        }
        doInvoke();
      }
 else {
        return TIMEOUT_RESPONSE;
      }
    }
 else     if (response == WAIT_RESPONSE) {
      continue;
    }
 else     if (response != null) {
      return response;
    }
 else     if (longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.warning(""String_Node_Str"" + lastPollTime + ""String_Node_Str""+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object obj=responseQ.peek();
        if (obj != null) {
          continue;
        }
        return new OperationTimeoutException(""String_Node_Str"" + (pollTimeout * pollCount) + ""String_Node_Str""+ toString());
      }
    }
  }
  return TIMEOUT_RESPONSE;
}","private Object waitForResponse(long time,TimeUnit unit){
  long timeout=unit.toMillis(time);
  if (timeout < 0)   timeout=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeout > maxCallTimeout;
  int pollCount=0;
  InterruptedException interrupted=null;
  while (timeout >= 0) {
    final long pollTimeout=Math.min(maxCallTimeout,timeout);
    final long start=Clock.currentTimeMillis();
    final Object response;
    final long lastPollTime;
    try {
      response=responseQ.poll(pollTimeout,TimeUnit.MILLISECONDS);
      lastPollTime=Clock.currentTimeMillis() - start;
      timeout=decrementTimeout(timeout,lastPollTime);
    }
 catch (    InterruptedException e) {
      logger.finest(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ op);
      interrupted=e;
      if (!nodeEngine.isActive()) {
        return e;
      }
      continue;
    }
    pollCount++;
    if (response == RETRY_RESPONSE) {
      if (interrupted != null) {
        return interrupted;
      }
      if (timeout > 0) {
        if (invokeCount > 5) {
          final long sleepTime=tryPauseMillis;
          try {
            Thread.sleep(sleepTime);
            timeout=decrementTimeout(timeout,sleepTime);
          }
 catch (          InterruptedException e) {
            return e;
          }
        }
        doInvoke();
      }
 else {
        return TIMEOUT_RESPONSE;
      }
    }
 else     if (response == WAIT_RESPONSE) {
      continue;
    }
 else     if (response != null) {
      if (interrupted != null) {
        Thread.currentThread().interrupt();
      }
      return response;
    }
 else     if (longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.warning(""String_Node_Str"" + lastPollTime + ""String_Node_Str""+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object obj=responseQ.peek();
        if (obj != null) {
          continue;
        }
        return new OperationTimeoutException(""String_Node_Str"" + (pollTimeout * pollCount) + ""String_Node_Str""+ toString());
      }
    }
  }
  return TIMEOUT_RESPONSE;
}",0.9808342728297632
48936,"private Object waitForResponse(long time,TimeUnit unit){
  long timeout=unit.toMillis(time);
  if (timeout < 0)   timeout=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeout > maxCallTimeout;
  int pollCount=0;
  InterruptedException interrupted=null;
  while (timeout >= 0) {
    final long pollTimeout=Math.min(maxCallTimeout,timeout);
    final long start=Clock.currentTimeMillis();
    final Object response;
    final long lastPollTime;
    try {
      response=responseQ.poll(pollTimeout,TimeUnit.MILLISECONDS);
      lastPollTime=Clock.currentTimeMillis() - start;
      timeout=decrementTimeout(timeout,lastPollTime);
    }
 catch (    InterruptedException e) {
      logger.finest(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ op);
      interrupted=e;
      if (!nodeEngine.isActive()) {
        return e;
      }
      continue;
    }
    pollCount++;
    if (response == RETRY_RESPONSE) {
      if (interrupted != null) {
        return interrupted;
      }
      if (timeout > 0) {
        if (invokeCount > 5) {
          final long sleepTime=tryPauseMillis;
          try {
            Thread.sleep(sleepTime);
            timeout=decrementTimeout(timeout,sleepTime);
          }
 catch (          InterruptedException e) {
            return e;
          }
        }
        doInvoke();
      }
 else {
        return TIMEOUT_RESPONSE;
      }
    }
 else     if (response == WAIT_RESPONSE) {
      continue;
    }
 else     if (response != null) {
      return response;
    }
 else     if (longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.warning(""String_Node_Str"" + lastPollTime + ""String_Node_Str""+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object obj=responseQ.peek();
        if (obj != null) {
          continue;
        }
        return new OperationTimeoutException(""String_Node_Str"" + (pollTimeout * pollCount) + ""String_Node_Str""+ toString());
      }
    }
  }
  return TIMEOUT_RESPONSE;
}","private Object waitForResponse(long time,TimeUnit unit){
  long timeout=unit.toMillis(time);
  if (timeout < 0)   timeout=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeout > maxCallTimeout;
  int pollCount=0;
  InterruptedException interrupted=null;
  while (timeout >= 0) {
    final long pollTimeout=Math.min(maxCallTimeout,timeout);
    final long start=Clock.currentTimeMillis();
    final Object response;
    final long lastPollTime;
    try {
      response=responseQ.poll(pollTimeout,TimeUnit.MILLISECONDS);
      lastPollTime=Clock.currentTimeMillis() - start;
      timeout=decrementTimeout(timeout,lastPollTime);
    }
 catch (    InterruptedException e) {
      logger.finest(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ op);
      interrupted=e;
      if (!nodeEngine.isActive()) {
        return e;
      }
      continue;
    }
    pollCount++;
    if (response == RETRY_RESPONSE) {
      if (interrupted != null) {
        return interrupted;
      }
      if (timeout > 0) {
        if (invokeCount > 5) {
          final long sleepTime=tryPauseMillis;
          try {
            Thread.sleep(sleepTime);
            timeout=decrementTimeout(timeout,sleepTime);
          }
 catch (          InterruptedException e) {
            return e;
          }
        }
        doInvoke();
      }
 else {
        return TIMEOUT_RESPONSE;
      }
    }
 else     if (response == WAIT_RESPONSE) {
      continue;
    }
 else     if (response != null) {
      if (interrupted != null) {
        Thread.currentThread().interrupt();
      }
      return response;
    }
 else     if (longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.warning(""String_Node_Str"" + lastPollTime + ""String_Node_Str""+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object obj=responseQ.peek();
        if (obj != null) {
          continue;
        }
        return new OperationTimeoutException(""String_Node_Str"" + (pollTimeout * pollCount) + ""String_Node_Str""+ toString());
      }
    }
  }
  return TIMEOUT_RESPONSE;
}",0.9808342728297632
48937,"@Override public boolean contains(Object o){
  for (  Set<QueryableEntry> otherIndexedResult : lsIndexedResults) {
    if (otherIndexedResult.contains(o))     return true;
  }
  return false;
}","@Override public boolean contains(Object o){
  for (  Set<QueryableEntry> otherIndexedResult : indexedResults) {
    if (otherIndexedResult.contains(o))     return true;
  }
  return false;
}",0.9895833333333334
48938,"@Override public Iterator<QueryableEntry> iterator(){
  if (entries != null) {
    return entries.iterator();
  }
  entries=new HashSet<QueryableEntry>(lsIndexedResults.get(0));
  for (int i=1; i < lsIndexedResults.size(); i++) {
    entries.addAll(lsIndexedResults.get(i));
  }
  return entries.iterator();
}","@Override public Iterator<QueryableEntry> iterator(){
  if (entries == null) {
    if (!indexedResults.isEmpty()) {
      if (indexedResults.size() == 1) {
        entries=new HashSet<QueryableEntry>(indexedResults.get(0));
      }
 else {
        entries=new HashSet<QueryableEntry>();
        for (        Set<QueryableEntry> result : indexedResults) {
          entries.addAll(result);
        }
      }
    }
 else {
      entries=Collections.emptySet();
    }
  }
  return entries.iterator();
}",0.3564356435643564
48939,"@Override public int size(){
  return lsIndexedResults.get(0).size();
}","@Override public int size(){
  return indexedResults.isEmpty() ? 0 : indexedResults.get(0).size();
}",0.8187134502923976
48940,"public OrResultSet(List<Set<QueryableEntry>> lsIndexedResults){
  this.lsIndexedResults=lsIndexedResults;
}","public OrResultSet(List<Set<QueryableEntry>> indexedResults){
  this.indexedResults=indexedResults;
}",0.9423076923076924
48941,"public void run(){
  Record record=recordStore.getRecords().get(dataKey);
  if (record == null) {
    record=mapService.createRecord(name,dataKey,dataValue,ttl,false);
    updateSizeEstimator(calculateRecordSize(record));
    recordStore.getRecords().put(dataKey,record);
  }
 else {
    updateSizeEstimator(-calculateRecordSize(record));
    if (record instanceof DataRecord)     ((DataRecord)record).setValue(dataValue);
 else     if (record instanceof ObjectRecord)     ((ObjectRecord)record).setValue(mapService.toObject(dataValue));
    updateSizeEstimator(calculateRecordSize(record));
  }
  if (unlockKey)   recordStore.forceUnlock(dataKey);
}","public void run(){
  Record record=recordStore.getRecords().get(dataKey);
  if (record == null) {
    record=mapService.createRecord(name,dataKey,dataValue,ttl,false);
    updateSizeEstimator(calculateRecordSize(record));
    recordStore.getRecords().put(dataKey,record);
  }
 else {
    updateSizeEstimator(-calculateRecordSize(record));
    if (record instanceof DataRecord) {
      ((DataRecord)record).setValue(dataValue);
    }
 else     if (record instanceof ObjectRecord) {
      ((ObjectRecord)record).setValue(mapService.toObject(dataValue));
    }
    updateSizeEstimator(calculateRecordSize(record));
  }
  if (unlockKey)   recordStore.forceUnlock(dataKey);
}",0.9848484848484848
48942,"/** 
 * Cost of map & near cache todo in object mode object size is zero.
 */
public long getHeapCost();","/** 
 * Cost of map & near cache todo in object mode object size is zero.
 * @return heap cost
 */
public long getHeapCost();",0.9082969432314412
48943,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (100d * used / total);
    }
  }
  return false;
}",0.9978428351309708
48944,"public CallTimeoutException(String message){
  super(message);
}","public CallTimeoutException(String opName,long invocationTime,long timeout){
  super(""String_Node_Str"" + opName + ""String_Node_Str""+ invocationTime+ ""String_Node_Str""+ timeout);
}",0.4938271604938271
48945,"public void notify(Object obj){
  final Object response;
  if (obj == null) {
    response=NULL_RESPONSE;
  }
 else   if (obj instanceof Throwable) {
    final Throwable error=(Throwable)obj;
    final ExceptionAction action=onException(error);
    final int localInvokeCount=invokeCount;
    if (action == ExceptionAction.RETRY_INVOCATION && localInvokeCount < tryCount) {
      response=RETRY_RESPONSE;
      if (localInvokeCount > 99 && localInvokeCount % 10 == 0) {
        logger.warning(""String_Node_Str"" + toString() + ""String_Node_Str""+ error);
      }
    }
 else     if (action == ExceptionAction.CONTINUE_WAIT) {
      response=WAIT_RESPONSE;
    }
 else {
      response=obj;
    }
  }
 else {
    response=obj;
  }
  responseProcessor.process(response);
}","public void notify(Object obj){
  final Object response;
  if (obj == null) {
    response=NULL_RESPONSE;
  }
 else   if (obj instanceof CallTimeoutException) {
    response=RETRY_RESPONSE;
    if (logger.isFinestEnabled()) {
      logger.finest(""String_Node_Str"" + toString());
    }
    invokeCount--;
  }
 else   if (obj instanceof Throwable) {
    final Throwable error=(Throwable)obj;
    final ExceptionAction action=onException(error);
    final int localInvokeCount=invokeCount;
    if (action == ExceptionAction.RETRY_INVOCATION && localInvokeCount < tryCount) {
      response=RETRY_RESPONSE;
      if (localInvokeCount > 99 && localInvokeCount % 10 == 0) {
        logger.warning(""String_Node_Str"" + toString() + ""String_Node_Str""+ error);
      }
    }
 else     if (action == ExceptionAction.CONTINUE_WAIT) {
      response=WAIT_RESPONSE;
    }
 else {
      response=obj;
    }
  }
 else {
    response=obj;
  }
  responseProcessor.process(response);
}",0.8858131487889274
48946,"/** 
 * Runs operation in calling thread.
 */
private void doRunOperation(final Operation op){
  RemoteCallKey callKey=null;
  try {
    if (isCallTimedOut(op)) {
      Object response=new CallTimeoutException(""String_Node_Str"" + op.getClass().getName() + ""String_Node_Str""+ op.getInvocationTime()+ ""String_Node_Str""+ op.getCallTimeout());
      op.getResponseHandler().sendResponse(response);
      return;
    }
    callKey=beforeCallExecution(op);
    final int partitionId=op.getPartitionId();
    if (op instanceof PartitionAwareOperation) {
      if (partitionId < 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + partitionId);
      }
      final PartitionView partitionView=nodeEngine.getPartitionService().getPartition(partitionId);
      if (partitionView == null) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      if (retryDuringMigration(op) && node.partitionService.isPartitionMigrating(partitionId)) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      final Address owner=partitionView.getReplicaAddress(op.getReplicaIndex());
      if (op.validatesTarget() && !node.getThisAddress().equals(owner)) {
        throw new WrongTargetException(node.getThisAddress(),owner,partitionId,op.getReplicaIndex(),op.getClass().getName(),op.getServiceName());
      }
    }
    OperationAccessor.setStartTime(op,Clock.currentTimeMillis());
    op.beforeRun();
    if (op instanceof WaitSupport) {
      WaitSupport waitSupport=(WaitSupport)op;
      if (waitSupport.shouldWait()) {
        nodeEngine.waitNotifyService.await(waitSupport);
        return;
      }
    }
    op.run();
    final boolean returnsResponse=op.returnsResponse();
    Object response=null;
    if (op instanceof BackupAwareOperation) {
      final BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
      int syncBackupCount=0;
      if (backupAwareOp.shouldBackup()) {
        syncBackupCount=sendBackups(backupAwareOp);
      }
      if (returnsResponse) {
        response=new Response(op.getResponse(),op.getCallId(),syncBackupCount);
      }
    }
    if (returnsResponse) {
      if (response == null) {
        response=op.getResponse();
      }
      final ResponseHandler responseHandler=op.getResponseHandler();
      if (responseHandler == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      responseHandler.sendResponse(response);
    }
    op.afterRun();
    if (op instanceof Notifier) {
      final Notifier notifier=(Notifier)op;
      if (notifier.shouldNotify()) {
        nodeEngine.waitNotifyService.notify(notifier);
      }
    }
  }
 catch (  Throwable e) {
    handleOperationError(op,e);
  }
 finally {
    afterCallExecution(op,callKey);
  }
}","/** 
 * Runs operation in calling thread.
 */
private void doRunOperation(final Operation op){
  RemoteCallKey callKey=null;
  try {
    if (isCallTimedOut(op)) {
      Object response=new CallTimeoutException(op.getClass().getName(),op.getInvocationTime(),op.getCallTimeout());
      op.getResponseHandler().sendResponse(response);
      return;
    }
    callKey=beforeCallExecution(op);
    final int partitionId=op.getPartitionId();
    if (op instanceof PartitionAwareOperation) {
      if (partitionId < 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + partitionId);
      }
      final PartitionView partitionView=nodeEngine.getPartitionService().getPartition(partitionId);
      if (partitionView == null) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      if (retryDuringMigration(op) && node.partitionService.isPartitionMigrating(partitionId)) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      final Address owner=partitionView.getReplicaAddress(op.getReplicaIndex());
      if (op.validatesTarget() && !node.getThisAddress().equals(owner)) {
        throw new WrongTargetException(node.getThisAddress(),owner,partitionId,op.getReplicaIndex(),op.getClass().getName(),op.getServiceName());
      }
    }
    OperationAccessor.setStartTime(op,Clock.currentTimeMillis());
    op.beforeRun();
    if (op instanceof WaitSupport) {
      WaitSupport waitSupport=(WaitSupport)op;
      if (waitSupport.shouldWait()) {
        nodeEngine.waitNotifyService.await(waitSupport);
        return;
      }
    }
    op.run();
    final boolean returnsResponse=op.returnsResponse();
    Object response=null;
    if (op instanceof BackupAwareOperation) {
      final BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
      int syncBackupCount=0;
      if (backupAwareOp.shouldBackup()) {
        syncBackupCount=sendBackups(backupAwareOp);
      }
      if (returnsResponse) {
        response=new Response(op.getResponse(),op.getCallId(),syncBackupCount);
      }
    }
    if (returnsResponse) {
      if (response == null) {
        response=op.getResponse();
      }
      final ResponseHandler responseHandler=op.getResponseHandler();
      if (responseHandler == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      responseHandler.sendResponse(response);
    }
    op.afterRun();
    if (op instanceof Notifier) {
      final Notifier notifier=(Notifier)op;
      if (notifier.shouldNotify()) {
        nodeEngine.waitNotifyService.notify(notifier);
      }
    }
  }
 catch (  Throwable e) {
    handleOperationError(op,e);
  }
 finally {
    afterCallExecution(op,callKey);
  }
}",0.9826650323936263
48947,"public boolean isCallTimedOut(){
  final NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  if (nodeEngine.operationService.isCallTimedOut(op)) {
    cancel(new CallTimeoutException(""String_Node_Str"" + op.getClass().getName()));
    return true;
  }
  return false;
}","public boolean isCallTimedOut(){
  final NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  if (nodeEngine.operationService.isCallTimedOut(op)) {
    cancel(new CallTimeoutException(op.getClass().getName(),op.getInvocationTime(),op.getCallTimeout()));
    return true;
  }
  return false;
}",0.8214904679376083
48948,"@Override public boolean contains(Object o){
  for (  Set<QueryableEntry> otherIndexedResult : lsIndexedResults) {
    if (otherIndexedResult.contains(o))     return true;
  }
  return false;
}","@Override public boolean contains(Object o){
  for (  Set<QueryableEntry> otherIndexedResult : indexedResults) {
    if (otherIndexedResult.contains(o))     return true;
  }
  return false;
}",0.9895833333333334
48949,"@Override public Iterator<QueryableEntry> iterator(){
  if (entries != null) {
    return entries.iterator();
  }
  entries=new HashSet<QueryableEntry>(lsIndexedResults.get(0));
  for (int i=1; i < lsIndexedResults.size(); i++) {
    entries.addAll(lsIndexedResults.get(i));
  }
  return entries.iterator();
}","@Override public Iterator<QueryableEntry> iterator(){
  if (entries == null) {
    if (!indexedResults.isEmpty()) {
      if (indexedResults.size() == 1) {
        entries=new HashSet<QueryableEntry>(indexedResults.get(0));
      }
 else {
        entries=new HashSet<QueryableEntry>();
        for (        Set<QueryableEntry> result : indexedResults) {
          entries.addAll(result);
        }
      }
    }
 else {
      entries=Collections.emptySet();
    }
  }
  return entries.iterator();
}",0.3564356435643564
48950,"@Override public int size(){
  return lsIndexedResults.get(0).size();
}","@Override public int size(){
  return indexedResults.isEmpty() ? 0 : indexedResults.get(0).size();
}",0.8187134502923976
48951,"public OrResultSet(List<Set<QueryableEntry>> lsIndexedResults){
  this.lsIndexedResults=lsIndexedResults;
}","public OrResultSet(List<Set<QueryableEntry>> indexedResults){
  this.indexedResults=indexedResults;
}",0.9423076923076924
48952,"public CallTimeoutException(String message){
  super(message);
}","public CallTimeoutException(String opName,long invocationTime,long timeout){
  super(""String_Node_Str"" + opName + ""String_Node_Str""+ invocationTime+ ""String_Node_Str""+ timeout);
}",0.4938271604938271
48953,"public void notify(Object obj){
  final Object response;
  if (obj == null) {
    response=NULL_RESPONSE;
  }
 else   if (obj instanceof Throwable) {
    final Throwable error=(Throwable)obj;
    final ExceptionAction action=onException(error);
    final int localInvokeCount=invokeCount;
    if (action == ExceptionAction.RETRY_INVOCATION && localInvokeCount < tryCount) {
      response=RETRY_RESPONSE;
      if (localInvokeCount > 99 && localInvokeCount % 10 == 0) {
        logger.warning(""String_Node_Str"" + toString() + ""String_Node_Str""+ error);
      }
    }
 else     if (action == ExceptionAction.CONTINUE_WAIT) {
      response=WAIT_RESPONSE;
    }
 else {
      response=obj;
    }
  }
 else {
    response=obj;
  }
  responseProcessor.process(response);
}","public void notify(Object obj){
  final Object response;
  if (obj == null) {
    response=NULL_RESPONSE;
  }
 else   if (obj instanceof CallTimeoutException) {
    response=RETRY_RESPONSE;
    if (logger.isFinestEnabled()) {
      logger.finest(""String_Node_Str"" + toString());
    }
    invokeCount--;
  }
 else   if (obj instanceof Throwable) {
    final Throwable error=(Throwable)obj;
    final ExceptionAction action=onException(error);
    final int localInvokeCount=invokeCount;
    if (action == ExceptionAction.RETRY_INVOCATION && localInvokeCount < tryCount) {
      response=RETRY_RESPONSE;
      if (localInvokeCount > 99 && localInvokeCount % 10 == 0) {
        logger.warning(""String_Node_Str"" + toString() + ""String_Node_Str""+ error);
      }
    }
 else     if (action == ExceptionAction.CONTINUE_WAIT) {
      response=WAIT_RESPONSE;
    }
 else {
      response=obj;
    }
  }
 else {
    response=obj;
  }
  responseProcessor.process(response);
}",0.8858131487889274
48954,"/** 
 * Runs operation in calling thread.
 */
private void doRunOperation(final Operation op){
  executedOperationsCount.incrementAndGet();
  RemoteCallKey callKey=null;
  try {
    if (isCallTimedOut(op)) {
      Object response=new CallTimeoutException(""String_Node_Str"" + op.getClass().getName() + ""String_Node_Str""+ op.getInvocationTime()+ ""String_Node_Str""+ op.getCallTimeout());
      op.getResponseHandler().sendResponse(response);
      return;
    }
    callKey=beforeCallExecution(op);
    final int partitionId=op.getPartitionId();
    if (op instanceof PartitionAwareOperation) {
      if (partitionId < 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + partitionId);
      }
      final PartitionView partitionView=nodeEngine.getPartitionService().getPartition(partitionId);
      if (partitionView == null) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      if (retryDuringMigration(op) && node.partitionService.isPartitionMigrating(partitionId)) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      final Address owner=partitionView.getReplicaAddress(op.getReplicaIndex());
      if (op.validatesTarget() && !node.getThisAddress().equals(owner)) {
        throw new WrongTargetException(node.getThisAddress(),owner,partitionId,op.getReplicaIndex(),op.getClass().getName(),op.getServiceName());
      }
    }
    OperationAccessor.setStartTime(op,Clock.currentTimeMillis());
    op.beforeRun();
    if (op instanceof WaitSupport) {
      WaitSupport waitSupport=(WaitSupport)op;
      if (waitSupport.shouldWait()) {
        nodeEngine.waitNotifyService.await(waitSupport);
        return;
      }
    }
    op.run();
    final boolean returnsResponse=op.returnsResponse();
    Object response=null;
    if (op instanceof BackupAwareOperation) {
      final BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
      int syncBackupCount=0;
      if (backupAwareOp.shouldBackup()) {
        syncBackupCount=sendBackups(backupAwareOp);
      }
      if (returnsResponse) {
        response=new Response(op.getResponse(),op.getCallId(),syncBackupCount);
      }
    }
    if (returnsResponse) {
      if (response == null) {
        response=op.getResponse();
      }
      final ResponseHandler responseHandler=op.getResponseHandler();
      if (responseHandler == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      responseHandler.sendResponse(response);
    }
    op.afterRun();
    if (op instanceof Notifier) {
      final Notifier notifier=(Notifier)op;
      if (notifier.shouldNotify()) {
        nodeEngine.waitNotifyService.notify(notifier);
      }
    }
  }
 catch (  Throwable e) {
    handleOperationError(op,e);
  }
 finally {
    afterCallExecution(op,callKey);
  }
}","/** 
 * Runs operation in calling thread.
 */
private void doRunOperation(final Operation op){
  executedOperationsCount.incrementAndGet();
  RemoteCallKey callKey=null;
  try {
    if (isCallTimedOut(op)) {
      Object response=new CallTimeoutException(op.getClass().getName(),op.getInvocationTime(),op.getCallTimeout());
      op.getResponseHandler().sendResponse(response);
      return;
    }
    callKey=beforeCallExecution(op);
    final int partitionId=op.getPartitionId();
    if (op instanceof PartitionAwareOperation) {
      if (partitionId < 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + partitionId);
      }
      final PartitionView partitionView=nodeEngine.getPartitionService().getPartition(partitionId);
      if (partitionView == null) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      if (retryDuringMigration(op) && node.partitionService.isPartitionMigrating(partitionId)) {
        throw new PartitionMigratingException(node.getThisAddress(),partitionId,op.getClass().getName(),op.getServiceName());
      }
      final Address owner=partitionView.getReplicaAddress(op.getReplicaIndex());
      if (op.validatesTarget() && !node.getThisAddress().equals(owner)) {
        throw new WrongTargetException(node.getThisAddress(),owner,partitionId,op.getReplicaIndex(),op.getClass().getName(),op.getServiceName());
      }
    }
    OperationAccessor.setStartTime(op,Clock.currentTimeMillis());
    op.beforeRun();
    if (op instanceof WaitSupport) {
      WaitSupport waitSupport=(WaitSupport)op;
      if (waitSupport.shouldWait()) {
        nodeEngine.waitNotifyService.await(waitSupport);
        return;
      }
    }
    op.run();
    final boolean returnsResponse=op.returnsResponse();
    Object response=null;
    if (op instanceof BackupAwareOperation) {
      final BackupAwareOperation backupAwareOp=(BackupAwareOperation)op;
      int syncBackupCount=0;
      if (backupAwareOp.shouldBackup()) {
        syncBackupCount=sendBackups(backupAwareOp);
      }
      if (returnsResponse) {
        response=new Response(op.getResponse(),op.getCallId(),syncBackupCount);
      }
    }
    if (returnsResponse) {
      if (response == null) {
        response=op.getResponse();
      }
      final ResponseHandler responseHandler=op.getResponseHandler();
      if (responseHandler == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      responseHandler.sendResponse(response);
    }
    op.afterRun();
    if (op instanceof Notifier) {
      final Notifier notifier=(Notifier)op;
      if (notifier.shouldNotify()) {
        nodeEngine.waitNotifyService.notify(notifier);
      }
    }
  }
 catch (  Throwable e) {
    handleOperationError(op,e);
  }
 finally {
    afterCallExecution(op,callKey);
  }
}",0.9829339769005344
48955,"public boolean isCallTimedOut(){
  final NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  if (nodeEngine.operationService.isCallTimedOut(op)) {
    cancel(new CallTimeoutException(""String_Node_Str"" + op.getClass().getName()));
    return true;
  }
  return false;
}","public boolean isCallTimedOut(){
  final NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  if (nodeEngine.operationService.isCallTimedOut(op)) {
    cancel(new CallTimeoutException(op.getClass().getName(),op.getInvocationTime(),op.getCallTimeout()));
    return true;
  }
  return false;
}",0.8214904679376083
48956,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    final long total=Runtime.getRuntime().totalMemory();
    final long used=mapContainer.getSizeEstimator().getSize();
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    final long total=Runtime.getRuntime().totalMemory();
    final long used=mapContainer.getSizeEstimator().getSize();
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (100d * used / total);
    }
  }
  return false;
}",0.997856049004594
48957,"public void txnOfferBackupReserve(long itemId){
  QueueItem item=new QueueItem(this,itemId,null);
  Object o=txMap.put(itemId,item);
  if (o != null) {
    logger.severe(""String_Node_Str"" + itemId);
  }
}","public void txnOfferBackupReserve(long itemId,String transactionId){
  QueueItem item=new QueueItem(this,itemId,null);
  Object o=txMap.put(itemId,new TxQueueItem(item).setPollOperation(false).setTransactionId(transactionId));
  if (o != null) {
    logger.severe(""String_Node_Str"" + itemId);
  }
}",0.796812749003984
48958,"public void rollbackTransaction(String transactionId){
  final Iterator<QueueItem> iterator=txMap.values().iterator();
  while (iterator.hasNext()) {
    final TxQueueItem item=(TxQueueItem)iterator.next();
    if (transactionId.equals(item.getTransactionId())) {
      iterator.remove();
      if (item.isPollOperation()) {
        getItemQueue().offerFirst(item);
      }
    }
  }
}","public void rollbackTransaction(String transactionId){
  final Iterator<TxQueueItem> iterator=txMap.values().iterator();
  while (iterator.hasNext()) {
    final TxQueueItem item=iterator.next();
    if (transactionId.equals(item.getTransactionId())) {
      iterator.remove();
      if (item.isPollOperation()) {
        getItemQueue().offerFirst(item);
      }
    }
  }
}",0.9802371541501976
48959,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(getItemQueue().size());
  for (  QueueItem item : getItemQueue()) {
    item.writeData(out);
  }
  out.writeInt(txMap.size());
  for (  QueueItem item : txMap.values()) {
    item.writeData(out);
  }
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(getItemQueue().size());
  for (  QueueItem item : getItemQueue()) {
    item.writeData(out);
  }
  out.writeInt(txMap.size());
  for (  TxQueueItem item : txMap.values()) {
    item.writeData(out);
  }
}",0.99645390070922
48960,"public void readData(ObjectDataInput in) throws IOException {
  int size=in.readInt();
  for (int j=0; j < size; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    getItemQueue().offer(item);
    setId(item.getItemId());
  }
  int txSize=in.readInt();
  for (int j=0; j < txSize; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    txMap.put(item.getItemId(),item);
    setId(item.getItemId());
  }
}","public void readData(ObjectDataInput in) throws IOException {
  int size=in.readInt();
  for (int j=0; j < size; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    getItemQueue().offer(item);
    setId(item.getItemId());
  }
  int txSize=in.readInt();
  for (int j=0; j < txSize; j++) {
    TxQueueItem item=new TxQueueItem(this,-1,null);
    item.readData(in);
    txMap.put(item.getItemId(),item);
    setId(item.getItemId());
  }
}",0.9956803455723542
48961,"public boolean txnPollBackupReserve(long itemId){
  QueueItem item=getBackupMap().remove(itemId);
  if (item == null) {
    throw new TransactionException(""String_Node_Str"" + itemId);
  }
  txMap.put(itemId,item);
  return true;
}","public boolean txnPollBackupReserve(long itemId,String transactionId){
  QueueItem item=getBackupMap().remove(itemId);
  if (item == null) {
    throw new TransactionException(""String_Node_Str"" + itemId);
  }
  txMap.put(itemId,new TxQueueItem(item).setPollOperation(true).setTransactionId(transactionId));
  return true;
}",0.8173598553345389
48962,"public QueueItem txnPollReserve(long reservedOfferId,String transactionId){
  QueueItem item=getItemQueue().poll();
  if (item == null) {
    item=txMap.remove(reservedOfferId);
    return item;
  }
  if (store.isEnabled() && item.getData() == null) {
    try {
      load(item);
    }
 catch (    Exception e) {
      throw new HazelcastException(e);
    }
  }
  txMap.put(item.getItemId(),new TxQueueItem(item).setPollOperation(true).setTransactionId(transactionId));
  return item;
}","public QueueItem txnPollReserve(long reservedOfferId,String transactionId){
  QueueItem item=getItemQueue().poll();
  if (item == null) {
    TxQueueItem txItem=txMap.remove(reservedOfferId);
    if (txItem == null) {
      return null;
    }
    item=new QueueItem(this,txItem.getItemId(),txItem.getData());
    return item;
  }
  if (store.isEnabled() && item.getData() == null) {
    try {
      load(item);
    }
 catch (    Exception e) {
      throw new HazelcastException(e);
    }
  }
  txMap.put(item.getItemId(),new TxQueueItem(item).setPollOperation(true).setTransactionId(transactionId));
  return item;
}",0.8794197642792384
48963,"public Data txnCommitPollBackup(long itemId){
  QueueItem item=txMap.remove(itemId);
  if (item == null) {
    logger.warning(""String_Node_Str"" + itemId);
    return null;
  }
  if (store.isEnabled()) {
    try {
      store.delete(item.getItemId());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return item.getData();
}","public Data txnCommitPollBackup(long itemId){
  TxQueueItem item=txMap.remove(itemId);
  if (item == null) {
    logger.warning(""String_Node_Str"" + itemId);
    return null;
  }
  if (store.isEnabled()) {
    try {
      store.delete(item.getItemId());
    }
 catch (    Exception ignored) {
      logger.severe(""String_Node_Str"" + item.getItemId(),ignored);
    }
  }
  return item.getData();
}",0.862533692722372
48964,"public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[TRANSACTION_ROLLBACK + 1];
  constructors[OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferOperation();
    }
  }
;
  constructors[OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferBackupOperation();
    }
  }
;
  constructors[POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollOperation();
    }
  }
;
  constructors[POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollBackupOperation();
    }
  }
;
  constructors[PEEK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PeekOperation();
    }
  }
;
  constructors[ADD_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllBackupOperation();
    }
  }
;
  constructors[ADD_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllOperation();
    }
  }
;
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveBackupOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveOperation();
    }
  }
;
  constructors[CONTAINS]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsOperation();
    }
  }
;
  constructors[DRAIN_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainBackupOperation();
    }
  }
;
  constructors[DRAIN]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainOperation();
    }
  }
;
  constructors[ITERATOR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new IteratorOperation();
    }
  }
;
  constructors[QUEUE_EVENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEvent();
    }
  }
;
  constructors[QUEUE_EVENT_FILTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEventFilter();
    }
  }
;
  constructors[QUEUE_ITEM]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueItem();
    }
  }
;
  constructors[QUEUE_REPLICATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueReplicationOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[TXN_OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferBackupOperation();
    }
  }
;
  constructors[TXN_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferOperation();
    }
  }
;
  constructors[TXN_POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollBackupOperation();
    }
  }
;
  constructors[TXN_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_RESERVE_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReserveOfferOperation();
    }
  }
;
  constructors[TXN_RESERVE_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReservePollOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  constructors[CHECK_EVICT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CheckAndEvictOperation();
    }
  }
;
  constructors[TRANSACTION_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueTransactionRollbackOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[TX_QUEUE_ITEM + 1];
  constructors[OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferOperation();
    }
  }
;
  constructors[OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferBackupOperation();
    }
  }
;
  constructors[POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollOperation();
    }
  }
;
  constructors[POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollBackupOperation();
    }
  }
;
  constructors[PEEK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PeekOperation();
    }
  }
;
  constructors[ADD_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllBackupOperation();
    }
  }
;
  constructors[ADD_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllOperation();
    }
  }
;
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveBackupOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveOperation();
    }
  }
;
  constructors[CONTAINS]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsOperation();
    }
  }
;
  constructors[DRAIN_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainBackupOperation();
    }
  }
;
  constructors[DRAIN]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainOperation();
    }
  }
;
  constructors[ITERATOR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new IteratorOperation();
    }
  }
;
  constructors[QUEUE_EVENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEvent();
    }
  }
;
  constructors[QUEUE_EVENT_FILTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEventFilter();
    }
  }
;
  constructors[QUEUE_ITEM]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueItem();
    }
  }
;
  constructors[QUEUE_REPLICATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueReplicationOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[TXN_OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferBackupOperation();
    }
  }
;
  constructors[TXN_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferOperation();
    }
  }
;
  constructors[TXN_POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollBackupOperation();
    }
  }
;
  constructors[TXN_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_RESERVE_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReserveOfferOperation();
    }
  }
;
  constructors[TXN_RESERVE_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReservePollOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  constructors[CHECK_EVICT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CheckAndEvictOperation();
    }
  }
;
  constructors[TRANSACTION_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueTransactionRollbackOperation();
    }
  }
;
  constructors[TX_QUEUE_ITEM]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxQueueItem();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9844649792419982
48965,"public IdentifiedDataSerializable createNew(Integer arg){
  return new QueueTransactionRollbackOperation();
}","public IdentifiedDataSerializable createNew(Integer arg){
  return new TxQueueItem();
}",0.8469387755102041
48966,"public QueueTransactionLog(long itemId,String name,int partitionId,Operation op){
  this.itemId=itemId;
  this.name=name;
  this.partitionId=partitionId;
  this.op=op;
}","public QueueTransactionLog(String transactionId,long itemId,String name,int partitionId,Operation op){
  this.transactionId=transactionId;
  this.itemId=itemId;
  this.name=name;
  this.partitionId=partitionId;
  this.op=op;
}",0.8556962025316456
48967,"public Future prepare(NodeEngine nodeEngine){
  boolean pollOperation=op instanceof TxnPollOperation;
  TxnPrepareOperation operation=new TxnPrepareOperation(name,itemId,pollOperation);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    return invocation.invoke();
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public Future prepare(NodeEngine nodeEngine){
  boolean pollOperation=op instanceof TxnPollOperation;
  TxnPrepareOperation operation=new TxnPrepareOperation(name,itemId,pollOperation,transactionId);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    return invocation.invoke();
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9842342342342344
48968,"public void readData(ObjectDataInput in) throws IOException {
  itemId=in.readLong();
  name=in.readUTF();
  partitionId=in.readInt();
  op=in.readObject();
}","public void readData(ObjectDataInput in) throws IOException {
  transactionId=in.readUTF();
  itemId=in.readLong();
  name=in.readUTF();
  partitionId=in.readInt();
  op=in.readObject();
}",0.9132947976878611
48969,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeLong(itemId);
  out.writeUTF(name);
  out.writeInt(partitionId);
  out.writeObject(op);
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeUTF(transactionId);
  out.writeLong(itemId);
  out.writeUTF(name);
  out.writeInt(partitionId);
  out.writeObject(op);
}",0.9141274238227148
48970,"public Data pollInternal(long timeout){
  QueueItem reservedOffer=offeredQueue.peek();
  TxnReservePollOperation operation=new TxnReservePollOperation(name,timeout,reservedOffer == null ? -1 : reservedOffer.getItemId(),tx.getTxnId());
  try {
    Invocation invocation=getNodeEngine().getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    Future<QueueItem> f=invocation.invoke();
    QueueItem item=f.get();
    if (item != null) {
      if (reservedOffer != null && item.getItemId() == reservedOffer.getItemId()) {
        offeredQueue.poll();
        tx.removeTransactionLog(new TransactionLogKey(reservedOffer.getItemId(),name));
        return reservedOffer.getData();
      }
      if (!itemIdSet.add(item.getItemId())) {
        throw new TransactionException(""String_Node_Str"" + item.getItemId());
      }
      tx.addTransactionLog(new QueueTransactionLog(item.getItemId(),name,partitionId,new TxnPollOperation(name,item.getItemId())));
      return item.getData();
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return null;
}","public Data pollInternal(long timeout){
  QueueItem reservedOffer=offeredQueue.peek();
  TxnReservePollOperation operation=new TxnReservePollOperation(name,timeout,reservedOffer == null ? -1 : reservedOffer.getItemId(),tx.getTxnId());
  try {
    Invocation invocation=getNodeEngine().getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    Future<QueueItem> f=invocation.invoke();
    QueueItem item=f.get();
    if (item != null) {
      if (reservedOffer != null && item.getItemId() == reservedOffer.getItemId()) {
        offeredQueue.poll();
        tx.removeTransactionLog(new TransactionLogKey(reservedOffer.getItemId(),name));
        return reservedOffer.getData();
      }
      if (!itemIdSet.add(item.getItemId())) {
        throw new TransactionException(""String_Node_Str"" + item.getItemId());
      }
      tx.addTransactionLog(new QueueTransactionLog(tx.getTxnId(),item.getItemId(),name,partitionId,new TxnPollOperation(name,item.getItemId())));
      return item.getData();
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return null;
}",0.9600355239786856
48971,"public boolean offerInternal(Data data,long timeout){
  throwExceptionIfNull(data);
  TxnReserveOfferOperation operation=new TxnReserveOfferOperation(name,timeout,offeredQueue.size(),tx.getTxnId());
  try {
    Invocation invocation=getNodeEngine().getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    Future<Long> f=invocation.invoke();
    Long itemId=f.get();
    if (itemId != null) {
      if (!itemIdSet.add(itemId)) {
        throw new TransactionException(""String_Node_Str"" + itemId);
      }
      offeredQueue.offer(new QueueItem(null,itemId,data));
      tx.addTransactionLog(new QueueTransactionLog(itemId,name,partitionId,new TxnOfferOperation(name,itemId,data)));
      return true;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return false;
}","public boolean offerInternal(Data data,long timeout){
  throwExceptionIfNull(data);
  TxnReserveOfferOperation operation=new TxnReserveOfferOperation(name,timeout,offeredQueue.size(),tx.getTxnId());
  try {
    Invocation invocation=getNodeEngine().getOperationService().createInvocationBuilder(QueueService.SERVICE_NAME,operation,partitionId).build();
    Future<Long> f=invocation.invoke();
    Long itemId=f.get();
    if (itemId != null) {
      if (!itemIdSet.add(itemId)) {
        throw new TransactionException(""String_Node_Str"" + itemId);
      }
      offeredQueue.offer(new QueueItem(null,itemId,data));
      tx.addTransactionLog(new QueueTransactionLog(tx.getTxnId(),itemId,name,partitionId,new TxnOfferOperation(name,itemId,data)));
      return true;
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return false;
}",0.9917743830787308
48972,"public TxnPrepareBackupOperation(String name,long itemId,boolean pollOperation){
  super(name);
  this.itemId=itemId;
  this.pollOperation=pollOperation;
}","public TxnPrepareBackupOperation(String name,long itemId,boolean pollOperation,String transactionId){
  super(name);
  this.itemId=itemId;
  this.pollOperation=pollOperation;
  this.transactionId=transactionId;
}",0.8446866485013624
48973,"public void run() throws Exception {
  if (pollOperation) {
    response=getOrCreateContainer().txnPollBackupReserve(itemId);
  }
 else {
    getOrCreateContainer().txnOfferBackupReserve(itemId);
    response=true;
  }
}","public void run() throws Exception {
  if (pollOperation) {
    response=getOrCreateContainer().txnPollBackupReserve(itemId,transactionId);
  }
 else {
    getOrCreateContainer().txnOfferBackupReserve(itemId,transactionId);
    response=true;
  }
}",0.9401709401709402
48974,"protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  itemId=in.readLong();
  pollOperation=in.readBoolean();
}","protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  itemId=in.readLong();
  pollOperation=in.readBoolean();
  transactionId=in.readUTF();
}",0.9112426035502958
48975,"protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeLong(itemId);
  out.writeBoolean(pollOperation);
}","protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeLong(itemId);
  out.writeBoolean(pollOperation);
  out.writeUTF(transactionId);
}",0.9121813031161472
48976,"public Operation getBackupOperation(){
  return new TxnPrepareBackupOperation(name,itemId,pollOperation);
}","public Operation getBackupOperation(){
  return new TxnPrepareBackupOperation(name,itemId,pollOperation,transactionId);
}",0.9385964912280702
48977,"public TxnPrepareOperation(String name,long itemId,boolean pollOperation){
  super(name);
  this.itemId=itemId;
  this.pollOperation=pollOperation;
}","public TxnPrepareOperation(String name,long itemId,boolean pollOperation,String transactionId){
  super(name);
  this.itemId=itemId;
  this.pollOperation=pollOperation;
  this.transactionId=transactionId;
}",0.8394366197183099
48978,"protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  itemId=in.readLong();
  pollOperation=in.readBoolean();
}","protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  itemId=in.readLong();
  pollOperation=in.readBoolean();
  transactionId=in.readUTF();
}",0.9112426035502958
48979,"protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeLong(itemId);
  out.writeBoolean(pollOperation);
}","protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeLong(itemId);
  out.writeBoolean(pollOperation);
  out.writeUTF(transactionId);
}",0.9121813031161472
48980,"@Override public void onReplicationEvent(WanReplicationEvent replicationEvent){
  Object eventObject=replicationEvent.getEventObject();
  if (eventObject instanceof MapReplicationUpdate) {
    MapReplicationUpdate replicationUpdate=(MapReplicationUpdate)eventObject;
    EntryView entryView=replicationUpdate.getEntryView();
    MapMergePolicy mergePolicy=replicationUpdate.getMergePolicy();
    String mapName=replicationUpdate.getMapName();
    MapContainer mapContainer=getMapContainer(mapName);
    MergeOperation operation=new MergeOperation(mapName,toData(entryView.getKey(),mapContainer.getPartitionStrategy()),entryView,mergePolicy);
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(entryView.getKey());
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      invocation.invoke().get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
 else   if (eventObject instanceof MapReplicationRemove) {
    MapReplicationRemove replicationRemove=(MapReplicationRemove)eventObject;
    String mapName=replicationRemove.getMapName();
    DeleteOperation operation=new DeleteOperation(replicationRemove.getMapName(),replicationRemove.getKey());
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(replicationRemove.getKey());
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      invocation.invoke().get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}","@Override public void onReplicationEvent(WanReplicationEvent replicationEvent){
  Object eventObject=replicationEvent.getEventObject();
  if (eventObject instanceof MapReplicationUpdate) {
    MapReplicationUpdate replicationUpdate=(MapReplicationUpdate)eventObject;
    EntryView entryView=replicationUpdate.getEntryView();
    MapMergePolicy mergePolicy=replicationUpdate.getMergePolicy();
    String mapName=replicationUpdate.getMapName();
    MapContainer mapContainer=getMapContainer(mapName);
    MergeOperation operation=new MergeOperation(mapName,toData(entryView.getKey(),mapContainer.getPartitionStrategy()),entryView,mergePolicy);
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(entryView.getKey());
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      invocation.invoke().get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
 else   if (eventObject instanceof MapReplicationRemove) {
    MapReplicationRemove replicationRemove=(MapReplicationRemove)eventObject;
    DeleteOperation operation=new DeleteOperation(replicationRemove.getMapName(),replicationRemove.getKey());
    try {
      int partitionId=nodeEngine.getPartitionService().getPartitionId(replicationRemove.getKey());
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      invocation.invoke().get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}",0.9841958475364116
48981,"@Override public final void run() throws Exception {
  TransactionManagerServiceImpl txManagerService=getService();
  txManagerService.putTxBackupLog(txLogs,callerUuid,txnId,timeoutMillis,startTime);
}","@Override public final void run() throws Exception {
  TransactionManagerServiceImpl txManagerService=getService();
  txManagerService.prepareTxBackupLog(txLogs,callerUuid,txnId,timeoutMillis,startTime);
}",0.9802955665024632
48982,"public void begin() throws IllegalStateException {
  if (state == ACTIVE) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  checkThread();
  if (threadFlag.get() != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setThreadFlag(Boolean.TRUE);
  startTime=Clock.currentTimeMillis();
  backupAddresses=transactionManagerService.pickBackupAddresses(durability);
  state=ACTIVE;
}","public void begin() throws IllegalStateException {
  if (state == ACTIVE) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  checkThread();
  if (threadFlag.get() != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setThreadFlag(Boolean.TRUE);
  startTime=Clock.currentTimeMillis();
  backupAddresses=transactionManagerService.pickBackupAddresses(durability);
  if (durability > 0 && backupAddresses != null && transactionType == TransactionType.TWO_PHASE) {
    final OperationService operationService=nodeEngine.getOperationService();
    List<Future> futures=new ArrayList<Future>(backupAddresses.length);
    for (    Address backupAddress : backupAddresses) {
      if (nodeEngine.getClusterService().getMember(backupAddress) != null) {
        final Invocation inv=operationService.createInvocationBuilder(TransactionManagerServiceImpl.SERVICE_NAME,new BeginTxBackupOperation(txOwnerUuid,txnId),backupAddress).build();
        futures.add(inv.invoke());
      }
    }
    for (    Future future : futures) {
      try {
        future.get(timeoutMillis,TimeUnit.MILLISECONDS);
      }
 catch (      MemberLeftException e) {
        nodeEngine.getLogger(Transaction.class).finest(""String_Node_Str"",e);
      }
catch (      Exception e) {
        throw ExceptionUtil.rethrow(e,IllegalStateException.class);
      }
    }
  }
  state=ACTIVE;
}",0.4589614740368509
48983,"private void finalizeTransactionsOf(String uuid){
  if (!txBackupLogs.isEmpty()) {
    for (    TxBackupLog log : txBackupLogs.values()) {
      if (uuid.equals(log.callerUuid)) {
        TransactionImpl tx=new TransactionImpl(this,nodeEngine,log.txnId,log.txLogs,log.timeoutMillis,log.startTime,log.callerUuid);
        if (log.state == State.COMMITTING) {
          try {
            tx.commit();
          }
 catch (          Throwable e) {
            logger.warning(""String_Node_Str"",e);
          }
        }
 else {
          try {
            tx.rollback();
          }
 catch (          Throwable e) {
            logger.warning(""String_Node_Str"",e);
          }
        }
      }
    }
  }
}","private void finalizeTransactionsOf(String uuid){
  if (!txBackupLogs.isEmpty()) {
    for (    Map.Entry<String,TxBackupLog> entry : txBackupLogs.entrySet()) {
      TxBackupLog log=entry.getValue();
      if (uuid.equals(log.callerUuid)) {
        String txnId=entry.getKey();
        if (log.state == State.ACTIVE) {
          Collection<MemberImpl> memberList=nodeEngine.getClusterService().getMemberList();
          Collection<Future> futures=new ArrayList<Future>(memberList.size());
          for (          MemberImpl member : memberList) {
            Operation op=new BroadcastTxRollbackOperation(txnId);
            Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,op,member.getAddress()).build();
            futures.add(inv.invoke());
          }
          for (          Future future : futures) {
            try {
              future.get(TransactionOptions.getDefault().getTimeoutMillis(),TimeUnit.MILLISECONDS);
            }
 catch (            Exception e) {
              logger.warning(""String_Node_Str"");
            }
          }
        }
 else {
          TransactionImpl tx=new TransactionImpl(this,nodeEngine,txnId,log.txLogs,log.timeoutMillis,log.startTime,log.callerUuid);
          if (log.state == State.COMMITTING) {
            try {
              tx.commit();
            }
 catch (            Throwable e) {
              logger.warning(""String_Node_Str"",e);
            }
          }
 else {
            try {
              tx.rollback();
            }
 catch (            Throwable e) {
              logger.warning(""String_Node_Str"",e);
            }
          }
        }
      }
    }
  }
}",0.554664415365133
48984,"private TxBackupLog(List<TransactionLog> txLogs,String callerUuid,String txnId,long timeoutMillis,long startTime){
  this.txLogs=txLogs;
  this.callerUuid=callerUuid;
  this.txnId=txnId;
  this.timeoutMillis=timeoutMillis;
  this.startTime=startTime;
}","private TxBackupLog(List<TransactionLog> txLogs,String callerUuid,State state,long timeoutMillis,long startTime){
  this.txLogs=txLogs;
  this.callerUuid=callerUuid;
  this.state=state;
  this.timeoutMillis=timeoutMillis;
  this.startTime=startTime;
}",0.9184890656063618
48985,"protected final int getPartition(){
  return clientEngine.getPartitionService().getPartitionId(getKey());
}","protected final int getPartition(){
  final Object key=getKey();
  if (key instanceof String) {
    return clientEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey((String)key));
  }
  return clientEngine.getPartitionService().getPartitionId(key);
}",0.5306122448979592
48986,"public void removeNumber(int partitionId){
  final Iterator<String> iterator=numbers.keySet().iterator();
  while (iterator.hasNext()) {
    String name=iterator.next();
    if (nodeEngine.getPartitionService().getPartitionId(name) == partitionId) {
      iterator.remove();
    }
  }
}","public void removeNumber(int partitionId){
  final Iterator<String> iterator=numbers.keySet().iterator();
  while (iterator.hasNext()) {
    String name=iterator.next();
    if (nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name)) == partitionId) {
      iterator.remove();
    }
  }
}",0.9155844155844156
48987,"public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  Map<String,Long> data=new HashMap<String,Long>();
  final int partitionId=event.getPartitionId();
  for (  String name : numbers.keySet()) {
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(name)) {
      data.put(name,numbers.get(name).get());
    }
  }
  return data.isEmpty() ? null : new AtomicLongReplicationOperation(data);
}","public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  Map<String,Long> data=new HashMap<String,Long>();
  final int partitionId=event.getPartitionId();
  for (  String name : numbers.keySet()) {
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name))) {
      data.put(name,numbers.get(name).get());
    }
  }
  return data.isEmpty() ? null : new AtomicLongReplicationOperation(data);
}",0.9494163424124512
48988,"public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  final Collection<CountDownLatchInfo> data=new LinkedList<CountDownLatchInfo>();
  for (  Map.Entry<String,CountDownLatchInfo> latchEntry : latches.entrySet()) {
    if (nodeEngine.getPartitionService().getPartitionId(latchEntry.getKey()) == event.getPartitionId()) {
      data.add(latchEntry.getValue());
    }
  }
  return data.isEmpty() ? null : new CountDownLatchReplicationOperation(data);
}","public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  if (event.getReplicaIndex() > 1) {
    return null;
  }
  final Collection<CountDownLatchInfo> data=new LinkedList<CountDownLatchInfo>();
  for (  Map.Entry<String,CountDownLatchInfo> latchEntry : latches.entrySet()) {
    final String name=latchEntry.getKey();
    if (nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name)) == event.getPartitionId()) {
      data.add(latchEntry.getValue());
    }
  }
  return data.isEmpty() ? null : new CountDownLatchReplicationOperation(data);
}",0.8984238178633975
48989,"private void clearPartition(int partitionId){
  final Iterator<String> iter=latches.keySet().iterator();
  while (iter.hasNext()) {
    if (nodeEngine.getPartitionService().getPartitionId(iter.next()) == partitionId) {
      iter.remove();
    }
  }
}","private void clearPartition(int partitionId){
  final Iterator<String> iter=latches.keySet().iterator();
  while (iter.hasNext()) {
    final String name=iter.next();
    if (nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name)) == partitionId) {
      iter.remove();
    }
  }
}",0.8362369337979094
48990,"public Permit createNew(String name){
  SemaphoreConfig config=nodeEngine.getConfig().getSemaphoreConfig(name);
  int partitionId=nodeEngine.getPartitionService().getPartitionId(name);
  return new Permit(partitionId,new SemaphoreConfig(config));
}","public Permit createNew(String name){
  SemaphoreConfig config=nodeEngine.getConfig().getSemaphoreConfig(name);
  int partitionId=nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
  return new Permit(partitionId,new SemaphoreConfig(config));
}",0.9037037037037036
48991,"private void onOwnerDisconnected(final String caller){
  for (  String name : permitMap.keySet()) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(name);
    PartitionView info=nodeEngine.getPartitionService().getPartition(partitionId);
    if (nodeEngine.getThisAddress().equals(info.getOwner())) {
      Operation op=new SemaphoreDeadMemberOperation(name,caller).setPartitionId(partitionId).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler()).setService(this).setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME);
      nodeEngine.getOperationService().executeOperation(op);
    }
  }
}","private void onOwnerDisconnected(final String caller){
  for (  String name : permitMap.keySet()) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
    PartitionView info=nodeEngine.getPartitionService().getPartition(partitionId);
    if (nodeEngine.getThisAddress().equals(info.getOwner())) {
      Operation op=new SemaphoreDeadMemberOperation(name,caller).setPartitionId(partitionId).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler()).setService(this).setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME);
      nodeEngine.getOperationService().executeOperation(op);
    }
  }
}",0.9601837672281776
48992,"public QueueContainer(String name,int partitionId,QueueConfig config,NodeEngine nodeEngine,QueueService service) throws Exception {
  this(name);
  this.partitionId=partitionId;
  setConfig(config,nodeEngine,service);
}","public QueueContainer(String name,QueueConfig config,NodeEngine nodeEngine,QueueService service) throws Exception {
  this(name);
  setConfig(config,nodeEngine,service);
}",0.8769230769230769
48993,"public long txnOfferReserve(){
  QueueItem item=new QueueItem(this,nextId(),null);
  txMap.put(item.getItemId(),item);
  return item.getItemId();
}","public long txnOfferReserve(String transactionId){
  TxQueueItem item=new TxQueueItem(this,nextId(),null).setTransactionId(transactionId).setPollOperation(false);
  txMap.put(item.getItemId(),item);
  return item.getItemId();
}",0.786096256684492
48994,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(partitionId);
  out.writeInt(getItemQueue().size());
  for (  QueueItem item : getItemQueue()) {
    item.writeData(out);
  }
  out.writeInt(txMap.size());
  for (  QueueItem item : txMap.values()) {
    item.writeData(out);
  }
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(getItemQueue().size());
  for (  QueueItem item : getItemQueue()) {
    item.writeData(out);
  }
  out.writeInt(txMap.size());
  for (  QueueItem item : txMap.values()) {
    item.writeData(out);
  }
}",0.9509306260575296
48995,"public void readData(ObjectDataInput in) throws IOException {
  partitionId=in.readInt();
  int size=in.readInt();
  for (int j=0; j < size; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    getItemQueue().offer(item);
    setId(item.getItemId());
  }
  int txSize=in.readInt();
  for (int j=0; j < txSize; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    txMap.put(item.getItemId(),item);
    setId(item.getItemId());
  }
}","public void readData(ObjectDataInput in) throws IOException {
  int size=in.readInt();
  for (int j=0; j < size; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    getItemQueue().offer(item);
    setId(item.getItemId());
  }
  int txSize=in.readInt();
  for (int j=0; j < txSize; j++) {
    QueueItem item=new QueueItem(this,-1,null);
    item.readData(in);
    txMap.put(item.getItemId(),item);
    setId(item.getItemId());
  }
}",0.9705263157894736
48996,"public QueueItem txnPollReserve(long reservedOfferId){
  QueueItem item=getItemQueue().poll();
  if (item == null) {
    item=txMap.remove(reservedOfferId);
    return item;
  }
  if (store.isEnabled() && item.getData() == null) {
    try {
      load(item);
    }
 catch (    Exception e) {
      throw new HazelcastException(e);
    }
  }
  txMap.put(item.getItemId(),item);
  return new QueueItem(null,item.getItemId(),item.getData());
}","public QueueItem txnPollReserve(long reservedOfferId,String transactionId){
  QueueItem item=getItemQueue().poll();
  if (item == null) {
    item=txMap.remove(reservedOfferId);
    return item;
  }
  if (store.isEnabled() && item.getData() == null) {
    try {
      load(item);
    }
 catch (    Exception e) {
      throw new HazelcastException(e);
    }
  }
  txMap.put(item.getItemId(),new TxQueueItem(item).setPollOperation(true).setTransactionId(transactionId));
  return item;
}",0.8358531317494601
48997,"public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[CHECK_EVICT + 1];
  constructors[OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferOperation();
    }
  }
;
  constructors[OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferBackupOperation();
    }
  }
;
  constructors[POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollOperation();
    }
  }
;
  constructors[POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollBackupOperation();
    }
  }
;
  constructors[PEEK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PeekOperation();
    }
  }
;
  constructors[ADD_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllBackupOperation();
    }
  }
;
  constructors[ADD_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllOperation();
    }
  }
;
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveBackupOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveOperation();
    }
  }
;
  constructors[CONTAINS]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsOperation();
    }
  }
;
  constructors[DRAIN_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainBackupOperation();
    }
  }
;
  constructors[DRAIN]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainOperation();
    }
  }
;
  constructors[ITERATOR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new IteratorOperation();
    }
  }
;
  constructors[QUEUE_EVENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEvent();
    }
  }
;
  constructors[QUEUE_EVENT_FILTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEventFilter();
    }
  }
;
  constructors[QUEUE_ITEM]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueItem();
    }
  }
;
  constructors[QUEUE_REPLICATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueReplicationOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[TXN_OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferBackupOperation();
    }
  }
;
  constructors[TXN_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferOperation();
    }
  }
;
  constructors[TXN_POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollBackupOperation();
    }
  }
;
  constructors[TXN_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_RESERVE_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReserveOfferOperation();
    }
  }
;
  constructors[TXN_RESERVE_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReservePollOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  constructors[CHECK_EVICT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CheckAndEvictOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}","public DataSerializableFactory createFactory(){
  ConstructorFunction<Integer,IdentifiedDataSerializable> constructors[]=new ConstructorFunction[TRANSACTION_ROLLBACK + 1];
  constructors[OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferOperation();
    }
  }
;
  constructors[OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new OfferBackupOperation();
    }
  }
;
  constructors[POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollOperation();
    }
  }
;
  constructors[POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PollBackupOperation();
    }
  }
;
  constructors[PEEK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new PeekOperation();
    }
  }
;
  constructors[ADD_ALL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllBackupOperation();
    }
  }
;
  constructors[ADD_ALL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new AddAllOperation();
    }
  }
;
  constructors[CLEAR_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearBackupOperation();
    }
  }
;
  constructors[CLEAR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ClearOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveBackupOperation();
    }
  }
;
  constructors[COMPARE_AND_REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CompareAndRemoveOperation();
    }
  }
;
  constructors[CONTAINS]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new ContainsOperation();
    }
  }
;
  constructors[DRAIN_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainBackupOperation();
    }
  }
;
  constructors[DRAIN]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new DrainOperation();
    }
  }
;
  constructors[ITERATOR]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new IteratorOperation();
    }
  }
;
  constructors[QUEUE_EVENT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEvent();
    }
  }
;
  constructors[QUEUE_EVENT_FILTER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueEventFilter();
    }
  }
;
  constructors[QUEUE_ITEM]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueItem();
    }
  }
;
  constructors[QUEUE_REPLICATION]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueReplicationOperation();
    }
  }
;
  constructors[REMOVE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveBackupOperation();
    }
  }
;
  constructors[REMOVE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new RemoveOperation();
    }
  }
;
  constructors[SIZE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new SizeOperation();
    }
  }
;
  constructors[TXN_OFFER_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferBackupOperation();
    }
  }
;
  constructors[TXN_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnOfferOperation();
    }
  }
;
  constructors[TXN_POLL_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollBackupOperation();
    }
  }
;
  constructors[TXN_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPollOperation();
    }
  }
;
  constructors[TXN_PREPARE_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareBackupOperation();
    }
  }
;
  constructors[TXN_PREPARE]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnPrepareOperation();
    }
  }
;
  constructors[TXN_RESERVE_OFFER]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReserveOfferOperation();
    }
  }
;
  constructors[TXN_RESERVE_POLL]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnReservePollOperation();
    }
  }
;
  constructors[TXN_ROLLBACK_BACKUP]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackBackupOperation();
    }
  }
;
  constructors[TXN_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new TxnRollbackOperation();
    }
  }
;
  constructors[CHECK_EVICT]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new CheckAndEvictOperation();
    }
  }
;
  constructors[TRANSACTION_ROLLBACK]=new ConstructorFunction<Integer,IdentifiedDataSerializable>(){
    public IdentifiedDataSerializable createNew(    Integer arg){
      return new QueueTransactionRollbackOperation();
    }
  }
;
  return new ArrayDataSerializableFactory(constructors);
}",0.9807546388908048
48998,"public IdentifiedDataSerializable createNew(Integer arg){
  return new CheckAndEvictOperation();
}","public IdentifiedDataSerializable createNew(Integer arg){
  return new QueueTransactionRollbackOperation();
}",0.8502415458937198
48999,"public final boolean returnsResponse(){
  return true;
}","public boolean returnsResponse(){
  return true;
}",0.9433962264150944
49000,"@Override public void rollbackTransaction(String transactionId){
}","public void rollbackTransaction(String transactionId){
  final Set<String> queueNames=containerMap.keySet();
  for (  String name : queueNames) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
    Operation operation=new QueueTransactionRollbackOperation(name,transactionId).setPartitionId(partitionId).setService(this).setNodeEngine(nodeEngine);
    nodeEngine.getOperationService().executeOperation(operation);
  }
}",0.2014388489208633
