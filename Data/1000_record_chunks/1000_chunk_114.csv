record_number,buggy_code,fixed_code,code_similarity
113001,"@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.INPUT_STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
}","@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.INPUT_STORE)).getDataStoreOptions();
  GeoWaveOutputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveOutputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
}",0.9889867841409692
113002,"private void runScan(final DistributableQuery query) throws Exception {
  final DBScanIterationsJobRunner jobRunner=new DBScanIterationsJobRunner();
  Configuration conf=MapReduceTestUtils.getConfiguration();
  GeoWaveOutputFormat.setDataStoreName(conf,dataStorePluginOptions.getFactoryFamily().getDataStoreFactory().getName());
  GeoWaveOutputFormat.setStoreConfigOptions(conf,ConfigUtils.populateListFromOptions(dataStorePluginOptions.getFactoryOptions()));
  final int res=jobRunner.run(conf,new PropertyManagement(new ParameterEnum[]{ExtractParameters.Extract.QUERY,ExtractParameters.Extract.QUERY_OPTIONS,ExtractParameters.Extract.MIN_INPUT_SPLIT,ExtractParameters.Extract.MAX_INPUT_SPLIT,PartitionParameters.Partition.MAX_DISTANCE,PartitionParameters.Partition.PARTITIONER_CLASS,ClusteringParameters.Clustering.MINIMUM_SIZE,StoreParam.INPUT_STORE,MapReduceParameters.MRConfig.HDFS_BASE_DIR,OutputParameters.Output.REDUCER_COUNT,InputParameters.Input.INPUT_FORMAT,GlobalParameters.Global.BATCH_ID,PartitionParameters.Partition.PARTITION_DECREASE_RATE,PartitionParameters.Partition.PARTITION_PRECISION},new Object[]{query,new QueryOptions(),Integer.toString(MapReduceTestUtils.MIN_INPUT_SPLITS),Integer.toString(MapReduceTestUtils.MAX_INPUT_SPLITS),10000.0,OrthodromicDistancePartitioner.class,10,new PersistableStore(dataStorePluginOptions),TestUtils.TEMP_DIR + File.separator + MapReduceTestEnvironment.HDFS_BASE_DIRECTORY+ ""String_Node_Str"",2,GeoWaveInputFormatConfiguration.class,""String_Node_Str"",0.15,0.95}));
  Assert.assertEquals(0,res);
  Assert.assertTrue(readHulls() > 2);
  System.gc();
}","private void runScan(final DistributableQuery query) throws Exception {
  final DBScanIterationsJobRunner jobRunner=new DBScanIterationsJobRunner();
  Configuration conf=MapReduceTestUtils.getConfiguration();
  final int res=jobRunner.run(conf,new PropertyManagement(new ParameterEnum[]{ExtractParameters.Extract.QUERY,ExtractParameters.Extract.QUERY_OPTIONS,ExtractParameters.Extract.MIN_INPUT_SPLIT,ExtractParameters.Extract.MAX_INPUT_SPLIT,PartitionParameters.Partition.MAX_DISTANCE,PartitionParameters.Partition.PARTITIONER_CLASS,ClusteringParameters.Clustering.MINIMUM_SIZE,StoreParam.INPUT_STORE,MapReduceParameters.MRConfig.HDFS_BASE_DIR,OutputParameters.Output.REDUCER_COUNT,InputParameters.Input.INPUT_FORMAT,GlobalParameters.Global.BATCH_ID,PartitionParameters.Partition.PARTITION_DECREASE_RATE,PartitionParameters.Partition.PARTITION_PRECISION},new Object[]{query,new QueryOptions(),Integer.toString(MapReduceTestUtils.MIN_INPUT_SPLITS),Integer.toString(MapReduceTestUtils.MAX_INPUT_SPLITS),10000.0,OrthodromicDistancePartitioner.class,10,new PersistableStore(dataStorePluginOptions),TestUtils.TEMP_DIR + File.separator + MapReduceTestEnvironment.HDFS_BASE_DIRECTORY+ ""String_Node_Str"",2,GeoWaveInputFormatConfiguration.class,""String_Node_Str"",0.15,0.95}));
  Assert.assertEquals(0,res);
  Assert.assertTrue(readHulls() > 2);
  System.gc();
}",0.91511667230301
113003,"/** 
 * This will create the facade objects needed in order to parse the fields represented in the translation map.
 * @param map
 * @return
 */
public void createFacadeObjects(){
  if (translatedObjects != null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  translatedObjects=new ArrayList<>();
  Map<Class<?>,CtClass> createdClasses=new HashMap<Class<?>,CtClass>();
  try {
    ClassPool classPool=ClassPool.getDefault();
    for (    Map.Entry<String,TranslationEntry> mapEntry : translations.entrySet()) {
      String newFieldName=mapEntry.getKey();
      TranslationEntry entry=mapEntry.getValue();
      Class<?> objectClass=entry.getObject().getClass();
      CtClass oldClass=classPool.get(objectClass.getName());
      CtClass newClass=createdClasses.get(objectClass);
      if (newClass == null) {
        newClass=JavassistUtils.generateEmptyClass();
        JavassistUtils.copyClassAnnotations(oldClass,newClass);
        createdClasses.put(objectClass,newClass);
      }
      CtField newField=null;
      if (!entry.isMethod()) {
        newField=new CtField(oldClass.getField(entry.getParam().getName()),newClass);
      }
 else {
        CtClass fieldType=classPool.get(entry.getParam().getType().getName());
        newField=new CtField(fieldType,entry.getParam().getName(),newClass);
        CtMethod method=JavassistUtils.findMethod(oldClass,(Method)entry.getMember());
        JavassistUtils.copyMethodAnnotationsToField(method,newField);
      }
      if (entry.getPrefix().length() > 0) {
        overrideParameterPrefixes(newField,entry.getPrefixedNames());
      }
      if (entry.isRequired() && entry.hasValue()) {
        disableBooleanMember(REQUIRED_MEMBER,newField);
      }
      if (entry.isPassword() && entry.hasValue()) {
        disableBooleanMember(PASSWORD_MEMBER,newField);
      }
      newField.setName(newFieldName);
      newField.getFieldInfo().setAccessFlags(AccessFlag.PUBLIC);
      newClass.addField(newField);
    }
    for (    CtClass clz : createdClasses.values()) {
      Class<?> toClass=clz.toClass();
      Object instance=toClass.newInstance();
      translatedObjects.add(instance);
    }
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * This will create the facade objects needed in order to parse the fields represented in the translation map.
 * @param map
 * @return
 */
public void createFacadeObjects(){
  if (translatedObjects != null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  translatedObjects=new ArrayList<>();
  Map<Class<?>,CtClass> createdClasses=new HashMap<Class<?>,CtClass>();
  try {
    ClassPool classPool=ClassPool.getDefault();
    ClassClassPath path=new ClassClassPath(JCommanderPrefixTranslator.class);
    classPool.insertClassPath(path);
    for (    Map.Entry<String,TranslationEntry> mapEntry : translations.entrySet()) {
      String newFieldName=mapEntry.getKey();
      TranslationEntry entry=mapEntry.getValue();
      Class<?> objectClass=entry.getObject().getClass();
      CtClass oldClass=classPool.get(objectClass.getName());
      CtClass newClass=createdClasses.get(objectClass);
      if (newClass == null) {
        newClass=JavassistUtils.generateEmptyClass();
        JavassistUtils.copyClassAnnotations(oldClass,newClass);
        createdClasses.put(objectClass,newClass);
      }
      CtField newField=null;
      if (!entry.isMethod()) {
        newField=new CtField(oldClass.getField(entry.getParam().getName()),newClass);
      }
 else {
        CtClass fieldType=classPool.get(entry.getParam().getType().getName());
        newField=new CtField(fieldType,entry.getParam().getName(),newClass);
        CtMethod method=JavassistUtils.findMethod(oldClass,(Method)entry.getMember());
        JavassistUtils.copyMethodAnnotationsToField(method,newField);
      }
      if (entry.getPrefix().length() > 0) {
        overrideParameterPrefixes(newField,entry.getPrefixedNames());
      }
      if (entry.isRequired() && entry.hasValue()) {
        disableBooleanMember(REQUIRED_MEMBER,newField);
      }
      if (entry.isPassword() && entry.hasValue()) {
        disableBooleanMember(PASSWORD_MEMBER,newField);
      }
      newField.setName(newFieldName);
      newField.getFieldInfo().setAccessFlags(AccessFlag.PUBLIC);
      newClass.addField(newField);
    }
    for (    CtClass clz : createdClasses.values()) {
      Class<?> toClass=clz.toClass();
      Object instance=toClass.newInstance();
      translatedObjects.add(instance);
    }
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9755890469114836
113004,"@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(GEOWAVE_BASE_URL);
  infoServiceClient=new InfoServiceClient(GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  final String expectedIndex=new SpatialDimensionalityTypeProvider().getDimensionalityTypeName();
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(expectedIndex)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + expectedIndex + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getFactoryOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getFactoryOptionsAsMap();
    for (    final Entry<String,String> entry : options.entrySet()) {
      assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(TEST_WORKSPACE));
}","@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  infoServiceClient=new InfoServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  final String expectedIndex=new SpatialDimensionalityTypeProvider().getDimensionalityTypeName();
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(expectedIndex)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + expectedIndex + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getFactoryOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(ServicesTestEnvironment.TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getFactoryOptionsAsMap();
    List<ConfigOption> configOptions=Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(dataStoreOptions));
    Collection<String> nonPasswordRequiredFields=Collections2.transform(Collections2.filter(configOptions,new Predicate<ConfigOption>(){
      @Override public boolean apply(      ConfigOption input){
        return !input.isPassword() && !input.isOptional();
      }
    }
),new Function<ConfigOption,String>(){
      @Override public String apply(      ConfigOption input){
        return input.getName();
      }
    }
);
    for (    final Entry<String,String> entry : options.entrySet()) {
      if (nonPasswordRequiredFields.contains(entry.getKey())) {
        assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
      }
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
}",0.9136960600375236
113005,"public synchronized void initProperties(){
  if (kafkaProperties == null) {
    final Properties properties=new Properties();
    if (kafkaPropertyFile != null) {
      if (!readAndVerifyProperties(kafkaPropertyFile,properties)) {
        throw new ParameterException(""String_Node_Str"");
      }
      applyOverrides(properties);
    }
    kafkaProperties=properties;
  }
}","public synchronized void initProperties(){
  if (kafkaProperties == null) {
    final Properties properties=new Properties();
    if (kafkaPropertyFile != null) {
      if (!readAndVerifyProperties(kafkaPropertyFile,properties)) {
        throw new ParameterException(""String_Node_Str"");
      }
    }
    applyOverrides(properties);
    kafkaProperties=properties;
  }
}",0.9059139784946236
113006,"public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=registeredStoreFactoryFamilies.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  int matchingFactoryOptionCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameOptionCount=false;
  for (  final Entry<String,StoreFactoryFamilySpi> entry : registeredStoreFactoryFamilies.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (factoryOptions.length >= matchingFactoryOptionCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameOptionCount=(factoryOptions.length == matchingFactoryOptionCount);
      matchingFactoryOptionCount=factoryOptions.length;
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameOptionCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getName() + ""String_Node_Str"");
  }
  return matchingFactory;
}","public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  Map<String,StoreFactoryFamilySpi> factories=getRegisteredStoreFactoryFamilies();
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=factories.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  int matchingFactoryOptionCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameOptionCount=false;
  for (  final Entry<String,StoreFactoryFamilySpi> entry : factories.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (factoryOptions.length >= matchingFactoryOptionCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameOptionCount=(factoryOptions.length == matchingFactoryOptionCount);
      matchingFactoryOptionCount=factoryOptions.length;
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameOptionCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getName() + ""String_Node_Str"");
  }
  return matchingFactory;
}",0.9597406106457714
113007,"public static void main(final String[] args){
  if ((args == null) || (args.length == 0)) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  final SimpleIngestIndexWriter si=new SimpleIngestIndexWriter();
  DataStore geowaveDataStore=null;
  String namespace=null;
  String instance=null;
  if (args.length != 5) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  namespace=args[5];
  instance=args[2];
  try {
    final BasicAccumuloOperations bao=si.getAccumuloOperationsInstance(args[1],args[2],args[3],args[4],args[5]);
    geowaveDataStore=si.getAccumuloGeowaveDataStore(bao);
  }
 catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
    System.exit(1);
  }
  if (geowaveDataStore != null) {
    si.generateGrid(geowaveDataStore);
  }
 else {
    log.error(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + namespace + ""String_Node_Str""+ instance);
}","public static void main(final String[] args){
  if ((args == null) || (args.length == 0)) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  final SimpleIngestIndexWriter si=new SimpleIngestIndexWriter();
  DataStore geowaveDataStore=null;
  String namespace=null;
  String instance=null;
  if (args.length != 5) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  namespace=args[5];
  instance=args[2];
  try {
    final BasicAccumuloOperations bao=si.getAccumuloOperationsInstance(args[1],args[2],args[3],args[4],args[5]);
    geowaveDataStore=si.getAccumuloGeowaveDataStore(bao);
  }
 catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
    System.exit(1);
  }
  si.generateGrid(geowaveDataStore);
  System.out.println(""String_Node_Str"" + namespace + ""String_Node_Str""+ instance);
}",0.8342989571263036
113008,"private void init(final JobContext context,final Class<?> scope,final Logger logger) throws IOException {
  final ScopedJobConfiguration scopedJob=new ScopedJobConfiguration(context.getConfiguration(),scope,logger);
  try {
    centroidFactory=(AnalyticItemWrapperFactory<T>)CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS.getHelper().getValue(context,scope,CentroidItemWrapperFactory.class);
    centroidFactory.initialize(context,scope,logger);
  }
 catch (  final Exception e1) {
    LOGGER.error(""String_Node_Str"" + GeoWaveConfiguratorBase.enumToConfKey(this.getClass(),CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS));
    throw new IOException(e1);
  }
  this.level=scopedJob.getInt(CentroidParameters.Centroid.ZOOM_LEVEL,1);
  centroidDataTypeId=scopedJob.getString(CentroidParameters.Centroid.DATA_TYPE_ID,""String_Node_Str"");
  batchId=scopedJob.getString(GlobalParameters.Global.BATCH_ID,Long.toString(Calendar.getInstance().getTime().getTime()));
  final String indexId=scopedJob.getString(CentroidParameters.Centroid.INDEX_ID,new SpatialDimensionalityTypeProvider().createPrimaryIndex().getId().getString());
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(context,scope,null);
  dataStore=store.getDataStoreOptions().createDataStore();
  indexStore=store.getDataStoreOptions().createIndexStore();
  index=(PrimaryIndex)indexStore.getIndex(new ByteArrayId(StringUtils.stringToBinary(indexId)));
  adapterStore=store.getDataStoreOptions().createAdapterStore();
  adapter=(GeotoolsFeatureDataAdapter)adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(centroidDataTypeId)));
}","private void init(final JobContext context,final Class<?> scope,final Logger logger) throws IOException {
  final ScopedJobConfiguration scopedJob=new ScopedJobConfiguration(context.getConfiguration(),scope,logger);
  try {
    centroidFactory=(AnalyticItemWrapperFactory<T>)CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS.getHelper().getValue(context,scope,CentroidItemWrapperFactory.class);
    centroidFactory.initialize(context,scope,logger);
  }
 catch (  final Exception e1) {
    LOGGER.error(""String_Node_Str"" + GeoWaveConfiguratorBase.enumToConfKey(this.getClass(),CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS));
    throw new IOException(e1);
  }
  this.level=scopedJob.getInt(CentroidParameters.Centroid.ZOOM_LEVEL,1);
  centroidDataTypeId=scopedJob.getString(CentroidParameters.Centroid.DATA_TYPE_ID,""String_Node_Str"");
  batchId=scopedJob.getString(GlobalParameters.Global.BATCH_ID,Long.toString(Calendar.getInstance().getTime().getTime()));
  final String indexId=scopedJob.getString(CentroidParameters.Centroid.INDEX_ID,new SpatialDimensionalityTypeProvider().createPrimaryIndex().getId().getString());
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(context,scope,null);
  dataStore=store.getDataStoreOptions().createDataStore();
  indexStore=store.getDataStoreOptions().createIndexStore();
  index=(PrimaryIndex)indexStore.getIndex(new ByteArrayId(StringUtils.stringToBinary(indexId)));
  adapterStore=store.getDataStoreOptions().createAdapterStore();
  adapter=(GeotoolsFeatureDataAdapter)adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(centroidDataTypeId)));
}",0.9981894990947496
113009,"public static DataAdapter<?> createAdapter(final PropertyManagement propertyManagement) throws Exception {
  final Class<DimensionExtractor> dimensionExtractorClass=propertyManagement.getPropertyAsClass(CommonParameters.Common.DIMENSION_EXTRACT_CLASS,DimensionExtractor.class);
  return ClusteringUtils.createAdapter(propertyManagement.getPropertyAsString(CentroidParameters.Centroid.DATA_TYPE_ID),propertyManagement.getPropertyAsString(CentroidParameters.Centroid.DATA_NAMESPACE_URI,BasicFeatureTypes.DEFAULT_NAMESPACE),((PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(propertyManagement)).getDataStoreOptions().createAdapterStore(),dimensionExtractorClass.newInstance().getDimensionNames());
}","public static DataAdapter<?> createAdapter(final PropertyManagement propertyManagement) throws Exception {
  final Class<DimensionExtractor> dimensionExtractorClass=propertyManagement.getPropertyAsClass(CommonParameters.Common.DIMENSION_EXTRACT_CLASS,DimensionExtractor.class);
  return ClusteringUtils.createAdapter(propertyManagement.getPropertyAsString(CentroidParameters.Centroid.DATA_TYPE_ID),propertyManagement.getPropertyAsString(CentroidParameters.Centroid.DATA_NAMESPACE_URI,BasicFeatureTypes.DEFAULT_NAMESPACE),((PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(propertyManagement)).getDataStoreOptions().createAdapterStore(),dimensionExtractorClass.newInstance().getDimensionNames());
}",0.9958448753462604
113010,"public static PrimaryIndex[] getIndices(final PropertyManagement propertyManagement){
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(propertyManagement);
  final IndexStore indexStore=store.getDataStoreOptions().createIndexStore();
  final mil.nga.giat.geowave.core.store.CloseableIterator<Index<?,?>> it=indexStore.getIndices();
  final List<PrimaryIndex> indices=new LinkedList<PrimaryIndex>();
  while (it.hasNext()) {
    indices.add((PrimaryIndex)it.next());
  }
  try {
    it.close();
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + e);
  }
  final PrimaryIndex[] result=new PrimaryIndex[indices.size()];
  indices.toArray(result);
  return result;
}","public static PrimaryIndex[] getIndices(final PropertyManagement propertyManagement){
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(propertyManagement);
  final IndexStore indexStore=store.getDataStoreOptions().createIndexStore();
  final mil.nga.giat.geowave.core.store.CloseableIterator<Index<?,?>> it=indexStore.getIndices();
  final List<PrimaryIndex> indices=new LinkedList<PrimaryIndex>();
  while (it.hasNext()) {
    indices.add((PrimaryIndex)it.next());
  }
  try {
    it.close();
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + e);
  }
  final PrimaryIndex[] result=new PrimaryIndex[indices.size()];
  indices.toArray(result);
  return result;
}",0.9959183673469388
113011,"public static DataAdapter[] getAdapters(final PropertyManagement propertyManagement) throws IOException {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(propertyManagement);
  final AdapterStore adapterStore=store.getDataStoreOptions().createAdapterStore();
  final mil.nga.giat.geowave.core.store.CloseableIterator<DataAdapter<?>> it=adapterStore.getAdapters();
  final List<DataAdapter> adapters=new LinkedList<DataAdapter>();
  while (it.hasNext()) {
    adapters.add(it.next());
  }
  it.close();
  final DataAdapter[] result=new DataAdapter[adapters.size()];
  adapters.toArray(result);
  return result;
}","public static DataAdapter[] getAdapters(final PropertyManagement propertyManagement) throws IOException {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(propertyManagement);
  final AdapterStore adapterStore=store.getDataStoreOptions().createAdapterStore();
  final mil.nga.giat.geowave.core.store.CloseableIterator<DataAdapter<?>> it=adapterStore.getAdapters();
  final List<DataAdapter> adapters=new LinkedList<DataAdapter>();
  while (it.hasNext()) {
    adapters.add(it.next());
  }
  it.close();
  final DataAdapter[] result=new DataAdapter[adapters.size()];
  adapters.toArray(result);
  return result;
}",0.995475113122172
113012,"public static PrimaryIndex createIndex(final PropertyManagement propertyManagement) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(propertyManagement);
  final IndexStore indexStore=store.getDataStoreOptions().createIndexStore();
  return (PrimaryIndex)indexStore.getIndex(new ByteArrayId(propertyManagement.getPropertyAsString(CentroidParameters.Centroid.INDEX_ID)));
}","public static PrimaryIndex createIndex(final PropertyManagement propertyManagement) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(propertyManagement);
  final IndexStore indexStore=store.getDataStoreOptions().createIndexStore();
  return (PrimaryIndex)indexStore.getIndex(new ByteArrayId(propertyManagement.getPropertyAsString(CentroidParameters.Centroid.INDEX_ID)));
}",0.993212669683258
113013,"@Override public void setup(final PropertyManagement runTimeProperties,final Class<?> scope,final Configuration configuration){
  super.setup(runTimeProperties,scope,configuration);
  final ParameterEnum[] params=new ParameterEnum[]{StoreParameters.StoreParam.STORE};
  runTimeProperties.setConfig(params,configuration,scope);
}","@Override public void setup(final PropertyManagement runTimeProperties,final Class<?> scope,final Configuration configuration){
  super.setup(runTimeProperties,scope,configuration);
  final ParameterEnum[] params=new ParameterEnum[]{StoreParameters.StoreParam.INPUT_STORE};
  runTimeProperties.setConfig(params,configuration,scope);
}",0.9909365558912386
113014,"@Override public void initialize(final JobContext context,final Class<?> scope) throws IOException {
  super.initialize(context,scope);
  adapterStore=new SerializableAdapterStore(((PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(context,scope,null)).getDataStoreOptions().createAdapterStore());
  init();
}","@Override public void initialize(final JobContext context,final Class<?> scope) throws IOException {
  super.initialize(context,scope);
  adapterStore=new SerializableAdapterStore(((PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(context,scope,null)).getDataStoreOptions().createAdapterStore());
  init();
}",0.990990990990991
113015,"@Test public void testPartition() throws IOException, ParseException {
  final SimpleFeatureType ftype=AnalyticFeature.createGeometryFeatureAdapter(""String_Node_Str"",new String[]{""String_Node_Str""},BasicFeatureTypes.DEFAULT_NAMESPACE,ClusteringUtils.CLUSTERING_CRS).getType();
  final GeometryFactory factory=new GeometryFactory();
  SimpleFeature feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(0,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  final PropertyManagement propertyManagement=new PropertyManagement();
  final AdapterBasedPartitioner partitioner=new AdapterBasedPartitioner();
  propertyManagement.store(ClusteringParameters.Clustering.DISTANCE_THRESHOLDS,""String_Node_Str"");
  propertyManagement.store(CommonParameters.Common.INDEX_MODEL_BUILDER_CLASS,SpatialIndexModelBuilder.class);
  final Configuration configuration=new Configuration();
  final Class<?> scope=OrthodromicDistancePartitionerTest.class;
  propertyManagement.setJobConfiguration(configuration,scope);
  final DataStorePluginOptions pluginOptions=new DataStorePluginOptions();
  GeoWaveStoreFinder.getRegisteredStoreFactoryFamilies().put(""String_Node_Str"",new MemoryStoreFactoryFamily());
  pluginOptions.selectPlugin(""String_Node_Str"");
  final PersistableStore store=new PersistableStore(pluginOptions);
  store.getDataStoreOptions().createAdapterStore().addAdapter(new FeatureDataAdapter(ftype));
  ((ParameterEnum<PersistableStore>)StoreParam.STORE).getHelper().setValue(configuration,scope,store);
  partitioner.initialize(Job.getInstance(configuration),scope);
  List<PartitionData> partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  for (  final PartitionData partition : partitions) {
    final MultiDimensionalNumericData ranges=partitioner.getRangesForPartition(partition);
    assertTrue(ranges.getDataPerDimension()[0].getMin() < 0.0000000001);
    assertTrue(ranges.getDataPerDimension()[0].getMax() > -0.0000000001);
    assertTrue(ranges.getDataPerDimension()[1].getMin() < 0.00000000001);
    assertTrue(ranges.getDataPerDimension()[1].getMax() > -0.0000000001);
  }
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(-179.99999996,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(179.99999996,91)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(2,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(88,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  double maxX=0;
  double minX=0;
  double maxY=0;
  double minY=0;
  for (  final PartitionData partition : partitions) {
    final MultiDimensionalNumericData ranges=partitioner.getRangesForPartition(partition);
    maxX=Math.max(maxX,ranges.getMaxValuesPerDimension()[1]);
    maxY=Math.max(maxY,ranges.getMaxValuesPerDimension()[0]);
    minX=Math.min(minX,ranges.getMinValuesPerDimension()[1]);
    minY=Math.min(minY,ranges.getMinValuesPerDimension()[0]);
  }
  assertTrue(maxY > 88.0);
  assertTrue(minY < 88.0);
  assertTrue(maxX > 0);
  assertTrue(minX < 0);
}","@Test public void testPartition() throws IOException, ParseException {
  final SimpleFeatureType ftype=AnalyticFeature.createGeometryFeatureAdapter(""String_Node_Str"",new String[]{""String_Node_Str""},BasicFeatureTypes.DEFAULT_NAMESPACE,ClusteringUtils.CLUSTERING_CRS).getType();
  final GeometryFactory factory=new GeometryFactory();
  SimpleFeature feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(0,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  final PropertyManagement propertyManagement=new PropertyManagement();
  final AdapterBasedPartitioner partitioner=new AdapterBasedPartitioner();
  propertyManagement.store(ClusteringParameters.Clustering.DISTANCE_THRESHOLDS,""String_Node_Str"");
  propertyManagement.store(CommonParameters.Common.INDEX_MODEL_BUILDER_CLASS,SpatialIndexModelBuilder.class);
  final Configuration configuration=new Configuration();
  final Class<?> scope=OrthodromicDistancePartitionerTest.class;
  propertyManagement.setJobConfiguration(configuration,scope);
  final DataStorePluginOptions pluginOptions=new DataStorePluginOptions();
  GeoWaveStoreFinder.getRegisteredStoreFactoryFamilies().put(""String_Node_Str"",new MemoryStoreFactoryFamily());
  pluginOptions.selectPlugin(""String_Node_Str"");
  final PersistableStore store=new PersistableStore(pluginOptions);
  store.getDataStoreOptions().createAdapterStore().addAdapter(new FeatureDataAdapter(ftype));
  ((ParameterEnum<PersistableStore>)StoreParam.INPUT_STORE).getHelper().setValue(configuration,scope,store);
  partitioner.initialize(Job.getInstance(configuration),scope);
  List<PartitionData> partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  for (  final PartitionData partition : partitions) {
    final MultiDimensionalNumericData ranges=partitioner.getRangesForPartition(partition);
    assertTrue(ranges.getDataPerDimension()[0].getMin() < 0.0000000001);
    assertTrue(ranges.getDataPerDimension()[0].getMax() > -0.0000000001);
    assertTrue(ranges.getDataPerDimension()[1].getMin() < 0.00000000001);
    assertTrue(ranges.getDataPerDimension()[1].getMax() > -0.0000000001);
  }
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(-179.99999996,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(179.99999996,91)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(2,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  feature=AnalyticFeature.createGeometryFeature(ftype,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",20.30203,factory.createPoint(new Coordinate(88,0)),new String[]{""String_Node_Str""},new double[]{0.022},1,1,0);
  partitions=partitioner.getCubeIdentifiers(new AdapterDataEntry(new ByteArrayId(ftype.getName().getLocalPart()),feature));
  assertEquals(4,partitions.size());
  assertTrue(hasOnePrimary(partitions));
  double maxX=0;
  double minX=0;
  double maxY=0;
  double minY=0;
  for (  final PartitionData partition : partitions) {
    final MultiDimensionalNumericData ranges=partitioner.getRangesForPartition(partition);
    maxX=Math.max(maxX,ranges.getMaxValuesPerDimension()[1]);
    maxY=Math.max(maxY,ranges.getMaxValuesPerDimension()[0]);
    minX=Math.min(minX,ranges.getMinValuesPerDimension()[1]);
    minY=Math.min(minY,ranges.getMinValuesPerDimension()[0]);
  }
  assertTrue(maxY > 88.0);
  assertTrue(minY < 88.0);
  assertTrue(maxX > 0);
  assertTrue(minX < 0);
}",0.99929676511955
113016,"public AdapterStore getAdapterStore(final PropertyManagement runTimeProperties) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(runTimeProperties);
  return store.getDataStoreOptions().createAdapterStore();
}","public AdapterStore getAdapterStore(final PropertyManagement runTimeProperties) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(runTimeProperties);
  return store.getDataStoreOptions().createAdapterStore();
}",0.989247311827957
113017,"public IndexStore getIndexStore(final PropertyManagement runTimeProperties) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.STORE.getHelper().getValue(runTimeProperties);
  return store.getDataStoreOptions().createIndexStore();
}","public IndexStore getIndexStore(final PropertyManagement runTimeProperties) throws Exception {
  PersistableStore store=(PersistableStore)StoreParameters.StoreParam.INPUT_STORE.getHelper().getValue(runTimeProperties);
  return store.getDataStoreOptions().createIndexStore();
}",0.989010989010989
113018,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final List<ParameterEnum<?>> params=new ArrayList<ParameterEnum<?>>();
  if (inputFormat != null) {
    params.addAll(inputFormat.getParameters());
  }
  if (outputFormat != null) {
    params.addAll(inputFormat.getParameters());
  }
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParam.STORE,Output.REDUCER_COUNT,Output.OUTPUT_FORMAT}));
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final List<ParameterEnum<?>> params=new ArrayList<ParameterEnum<?>>();
  if (inputFormat != null) {
    params.addAll(inputFormat.getParameters());
  }
  if (outputFormat != null) {
    params.addAll(inputFormat.getParameters());
  }
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParam.INPUT_STORE,Output.REDUCER_COUNT,Output.OUTPUT_FORMAT}));
  return params;
}",0.993119266055046
113019,"@Override public List<ParameterEnum<?>> getParameters(){
  return Arrays.asList(new ParameterEnum<?>[]{ExtractParameters.Extract.INDEX_ID,ExtractParameters.Extract.ADAPTER_ID,ExtractParameters.Extract.QUERY,ExtractParameters.Extract.MAX_INPUT_SPLIT,ExtractParameters.Extract.MIN_INPUT_SPLIT,StoreParam.STORE});
}","@Override public List<ParameterEnum<?>> getParameters(){
  return Arrays.asList(new ParameterEnum<?>[]{ExtractParameters.Extract.INDEX_ID,ExtractParameters.Extract.ADAPTER_ID,ExtractParameters.Extract.QUERY,ExtractParameters.Extract.MAX_INPUT_SPLIT,ExtractParameters.Extract.MIN_INPUT_SPLIT,StoreParam.INPUT_STORE});
}",0.9904761904761904
113020,"@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
  final String indexId=runTimeProperties.getPropertyAsString(ExtractParameters.Extract.INDEX_ID);
  final String adapterId=runTimeProperties.getPropertyAsString(ExtractParameters.Extract.ADAPTER_ID);
  if (indexId != null) {
    final PrimaryIndex[] indices=ClusteringUtils.getIndices(runTimeProperties);
    final ByteArrayId byteId=new ByteArrayId(StringUtils.stringToBinary(indexId));
    for (    final PrimaryIndex index : indices) {
      if (byteId.equals(index.getId())) {
        GeoWaveInputFormat.setIndex(configuration,index);
      }
    }
  }
  for (  final PrimaryIndex index : indices) {
    GeoWaveInputFormat.setIndex(configuration,index);
  }
  if (adapterId != null) {
    final DataAdapter<?>[] adapters=ClusteringUtils.getAdapters(runTimeProperties);
    final ByteArrayId byteId=new ByteArrayId(StringUtils.stringToBinary(adapterId));
    for (    final DataAdapter<?> adapter : adapters) {
      if (byteId.equals(adapter.getAdapterId())) {
        GeoWaveInputFormat.addDataAdapter(configuration,adapter);
      }
    }
  }
  for (  final DataAdapter<?> adapter : adapters) {
    GeoWaveInputFormat.addDataAdapter(configuration,adapter);
  }
  final DistributableQuery query=runTimeProperties.getPropertyAsQuery(ExtractParameters.Extract.QUERY);
  if (query != null) {
    GeoWaveInputFormat.setQuery(configuration,query);
  }
  final QueryOptions queryoptions=runTimeProperties.getPropertyAsQueryOptions(ExtractParameters.Extract.QUERY_OPTIONS);
  if (queryoptions != null) {
    GeoWaveInputFormat.setQueryOptions(configuration,queryoptions);
  }
  final int minInputSplits=runTimeProperties.getPropertyAsInt(ExtractParameters.Extract.MIN_INPUT_SPLIT,-1);
  if (minInputSplits > 0) {
    GeoWaveInputFormat.setMinimumSplitCount(configuration,minInputSplits);
  }
  final int maxInputSplits=runTimeProperties.getPropertyAsInt(ExtractParameters.Extract.MAX_INPUT_SPLIT,-1);
  if (maxInputSplits > 0) {
    GeoWaveInputFormat.setMaximumSplitCount(configuration,maxInputSplits);
  }
  GeoWaveInputFormat.setIsOutputWritable(configuration,isDataWritable);
}","@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.INPUT_STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
  final String indexId=runTimeProperties.getPropertyAsString(ExtractParameters.Extract.INDEX_ID);
  final String adapterId=runTimeProperties.getPropertyAsString(ExtractParameters.Extract.ADAPTER_ID);
  if (indexId != null) {
    final PrimaryIndex[] indices=ClusteringUtils.getIndices(runTimeProperties);
    final ByteArrayId byteId=new ByteArrayId(StringUtils.stringToBinary(indexId));
    for (    final PrimaryIndex index : indices) {
      if (byteId.equals(index.getId())) {
        GeoWaveInputFormat.setIndex(configuration,index);
      }
    }
  }
  for (  final PrimaryIndex index : indices) {
    GeoWaveInputFormat.setIndex(configuration,index);
  }
  if (adapterId != null) {
    final DataAdapter<?>[] adapters=ClusteringUtils.getAdapters(runTimeProperties);
    final ByteArrayId byteId=new ByteArrayId(StringUtils.stringToBinary(adapterId));
    for (    final DataAdapter<?> adapter : adapters) {
      if (byteId.equals(adapter.getAdapterId())) {
        GeoWaveInputFormat.addDataAdapter(configuration,adapter);
      }
    }
  }
  for (  final DataAdapter<?> adapter : adapters) {
    GeoWaveInputFormat.addDataAdapter(configuration,adapter);
  }
  final DistributableQuery query=runTimeProperties.getPropertyAsQuery(ExtractParameters.Extract.QUERY);
  if (query != null) {
    GeoWaveInputFormat.setQuery(configuration,query);
  }
  final QueryOptions queryoptions=runTimeProperties.getPropertyAsQueryOptions(ExtractParameters.Extract.QUERY_OPTIONS);
  if (queryoptions != null) {
    GeoWaveInputFormat.setQueryOptions(configuration,queryoptions);
  }
  final int minInputSplits=runTimeProperties.getPropertyAsInt(ExtractParameters.Extract.MIN_INPUT_SPLIT,-1);
  if (minInputSplits > 0) {
    GeoWaveInputFormat.setMinimumSplitCount(configuration,minInputSplits);
  }
  final int maxInputSplits=runTimeProperties.getPropertyAsInt(ExtractParameters.Extract.MAX_INPUT_SPLIT,-1);
  if (maxInputSplits > 0) {
    GeoWaveInputFormat.setMaximumSplitCount(configuration,maxInputSplits);
  }
  GeoWaveInputFormat.setIsOutputWritable(configuration,isDataWritable);
}",0.9988132911392406
113021,"@Override public Collection<ParameterEnum<?>> getParameters(){
  return Arrays.asList(new ParameterEnum<?>[]{StoreParam.STORE});
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  return Arrays.asList(new ParameterEnum<?>[]{StoreParam.INPUT_STORE});
}",0.9774436090225564
113022,"@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
}","@Override public void setup(final PropertyManagement runTimeProperties,final Configuration configuration) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.INPUT_STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(configuration,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(configuration,dataStoreOptions.getFactoryOptionsAsMap());
}",0.9933333333333332
113023,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(super.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParameters.StoreParam.STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{HullParameters.Hull.WRAPPER_FACTORY_CLASS,HullParameters.Hull.PROJECTION_CLASS,HullParameters.Hull.REDUCER_COUNT,HullParameters.Hull.DATA_TYPE_ID,HullParameters.Hull.DATA_NAMESPACE_URI,HullParameters.Hull.INDEX_ID}));
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(super.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParameters.StoreParam.INPUT_STORE,StoreParameters.StoreParam.OUTPUT_STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{HullParameters.Hull.WRAPPER_FACTORY_CLASS,HullParameters.Hull.PROJECTION_CLASS,HullParameters.Hull.REDUCER_COUNT,HullParameters.Hull.DATA_TYPE_ID,HullParameters.Hull.DATA_NAMESPACE_URI,HullParameters.Hull.INDEX_ID}));
  return params;
}",0.96831955922865
113024,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{ExtractParameters.Extract.REDUCER_COUNT,ExtractParameters.Extract.OUTPUT_DATA_TYPE_ID,ExtractParameters.Extract.DATA_NAMESPACE_URI,ExtractParameters.Extract.DIMENSION_EXTRACT_CLASS,ExtractParameters.Extract.INDEX_ID,ExtractParameters.Extract.ADAPTER_ID,ExtractParameters.Extract.MIN_INPUT_SPLIT,ExtractParameters.Extract.MAX_INPUT_SPLIT,ExtractParameters.Extract.QUERY,StoreParam.STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{ExtractParameters.Extract.REDUCER_COUNT,ExtractParameters.Extract.OUTPUT_DATA_TYPE_ID,ExtractParameters.Extract.DATA_NAMESPACE_URI,ExtractParameters.Extract.DIMENSION_EXTRACT_CLASS,ExtractParameters.Extract.INDEX_ID,ExtractParameters.Extract.ADAPTER_ID,ExtractParameters.Extract.MIN_INPUT_SPLIT,ExtractParameters.Extract.MAX_INPUT_SPLIT,ExtractParameters.Extract.QUERY,StoreParam.INPUT_STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  return params;
}",0.9956140350877192
113025,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(super.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParameters.StoreParam.STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(CentroidManagerGeoWave.getParameters());
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(super.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{StoreParameters.StoreParam.INPUT_STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(CentroidManagerGeoWave.getParameters());
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  return params;
}",0.9939024390243902
113026,"@Override public int run(final Configuration config,final PropertyManagement runTimeProperties) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(config,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(config,dataStoreOptions.getFactoryOptionsAsMap());
  runTimeProperties.setConfig(new ParameterEnum[]{CentroidParameters.Centroid.EXTRACTOR_CLASS,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS},config,GroupAssignmentMapReduce.class);
  NestedGroupCentroidAssignment.setParameters(config,getScope(),runTimeProperties);
  CentroidManagerGeoWave.setParameters(config,getScope(),runTimeProperties);
  NestedGroupCentroidAssignment.setZoomLevel(config,getScope(),zoomLevel);
  return super.run(config,runTimeProperties);
}","@Override public int run(final Configuration config,final PropertyManagement runTimeProperties) throws Exception {
  final DataStorePluginOptions dataStoreOptions=((PersistableStore)runTimeProperties.getProperty(StoreParam.INPUT_STORE)).getDataStoreOptions();
  GeoWaveInputFormat.setDataStoreName(config,dataStoreOptions.getType());
  GeoWaveInputFormat.setStoreConfigOptions(config,dataStoreOptions.getFactoryOptionsAsMap());
  runTimeProperties.setConfig(new ParameterEnum[]{CentroidParameters.Centroid.EXTRACTOR_CLASS,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS},config,GroupAssignmentMapReduce.class);
  NestedGroupCentroidAssignment.setParameters(config,getScope(),runTimeProperties);
  CentroidManagerGeoWave.setParameters(config,getScope(),runTimeProperties);
  NestedGroupCentroidAssignment.setZoomLevel(config,getScope(),zoomLevel);
  return super.run(config,runTimeProperties);
}",0.9966405375139976
113027,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(kmeansRunner.singleSamplekmeansJobRunner.getParameters());
  params.addAll(kmeansRunner.parallelJobRunner.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{JumpParameters.Jump.RANGE_OF_CENTROIDS,JumpParameters.Jump.KPLUSPLUS_MIN,ClusteringParameters.Clustering.MAX_REDUCER_COUNT,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.remove(CentroidParameters.Centroid.ZOOM_LEVEL);
  params.remove(SampleParameters.Sample.DATA_TYPE_ID);
  params.remove(SampleParameters.Sample.INDEX_ID);
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(kmeansRunner.singleSamplekmeansJobRunner.getParameters());
  params.addAll(kmeansRunner.parallelJobRunner.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{JumpParameters.Jump.RANGE_OF_CENTROIDS,JumpParameters.Jump.KPLUSPLUS_MIN,ClusteringParameters.Clustering.MAX_REDUCER_COUNT,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.INPUT_STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.remove(CentroidParameters.Centroid.ZOOM_LEVEL);
  params.remove(SampleParameters.Sample.DATA_TYPE_ID);
  params.remove(SampleParameters.Sample.INDEX_ID);
  return params;
}",0.9972014925373134
113028,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(kmeansJobRunner.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{ClusteringParameters.Clustering.MAX_REDUCER_COUNT,SampleParameters.Sample.SAMPLE_SIZE,SampleParameters.Sample.SAMPLE_RANK_FUNCTION,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.STORE,GlobalParameters.Global.BATCH_ID,ClusteringParameters.Clustering.MAX_REDUCER_COUNT}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.remove(CentroidParameters.Centroid.ZOOM_LEVEL);
  params.remove(SampleParameters.Sample.DATA_TYPE_ID);
  params.remove(SampleParameters.Sample.INDEX_ID);
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(kmeansJobRunner.getParameters());
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{ClusteringParameters.Clustering.MAX_REDUCER_COUNT,SampleParameters.Sample.SAMPLE_SIZE,SampleParameters.Sample.SAMPLE_RANK_FUNCTION,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.INPUT_STORE,GlobalParameters.Global.BATCH_ID,ClusteringParameters.Clustering.MAX_REDUCER_COUNT}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.remove(CentroidParameters.Centroid.ZOOM_LEVEL);
  params.remove(SampleParameters.Sample.DATA_TYPE_ID);
  params.remove(SampleParameters.Sample.INDEX_ID);
  return params;
}",0.9972826086956522
113029,"@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{SampleParameters.Sample.MAX_SAMPLE_SIZE,SampleParameters.Sample.SAMPLE_ITERATIONS,SampleParameters.Sample.MIN_SAMPLE_SIZE,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.addAll(CentroidManagerGeoWave.getParameters());
  params.addAll(initialSampleRunner.getParameters());
  return params;
}","@Override public Collection<ParameterEnum<?>> getParameters(){
  final Set<ParameterEnum<?>> params=new HashSet<ParameterEnum<?>>();
  params.addAll(Arrays.asList(new ParameterEnum<?>[]{SampleParameters.Sample.MAX_SAMPLE_SIZE,SampleParameters.Sample.SAMPLE_ITERATIONS,SampleParameters.Sample.MIN_SAMPLE_SIZE,CentroidParameters.Centroid.WRAPPER_FACTORY_CLASS,CentroidParameters.Centroid.INDEX_ID,CentroidParameters.Centroid.DATA_TYPE_ID,CentroidParameters.Centroid.DATA_NAMESPACE_URI,CentroidParameters.Centroid.EXTRACTOR_CLASS,CommonParameters.Common.DISTANCE_FUNCTION_CLASS,CommonParameters.Common.DIMENSION_EXTRACT_CLASS,StoreParameters.StoreParam.INPUT_STORE,GlobalParameters.Global.BATCH_ID}));
  params.addAll(MapReduceParameters.getParameters());
  params.addAll(NestedGroupCentroidAssignment.getParameters());
  params.addAll(CentroidManagerGeoWave.getParameters());
  params.addAll(initialSampleRunner.getParameters());
  return params;
}",0.9968186638388123
113030,"@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(dbScanOptions);
  DBScanIterationsJobRunner runner=new DBScanIterationsJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}","@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.INPUT_STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(dbScanOptions);
  DBScanIterationsJobRunner runner=new DBScanIterationsJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}",0.9974640743871512
113031,"@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(kmeansCommonOptions);
  converter.readProperties(kmeansJumpOptions);
  MultiLevelJumpKMeansClusteringJobRunner runner=new MultiLevelJumpKMeansClusteringJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}","@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.INPUT_STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(kmeansCommonOptions);
  converter.readProperties(kmeansJumpOptions);
  MultiLevelJumpKMeansClusteringJobRunner runner=new MultiLevelJumpKMeansClusteringJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}",0.997626582278481
113032,"@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(kmeansCommonOptions);
  MultiLevelKMeansClusteringJobRunner runner=new MultiLevelKMeansClusteringJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}","@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.INPUT_STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(kmeansCommonOptions);
  MultiLevelKMeansClusteringJobRunner runner=new MultiLevelKMeansClusteringJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}",0.9975186104218362
113033,"@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(nnOptions);
  GeoWaveExtractNNJobRunner runner=new GeoWaveExtractNNJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}","@Override public void execute(OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  String inputStoreName=parameters.get(0);
  File configFile=(File)params.getContext().get(ConfigOptions.PROPERTIES_FILE_CONTEXT);
  if (inputStoreOptions == null) {
    StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputStoreOptions=inputStoreLoader.getDataStorePlugin();
  }
  PersistableStore persistedStore=new PersistableStore(inputStoreOptions);
  final PropertyManagement properties=new PropertyManagement();
  properties.store(StoreParameters.StoreParam.INPUT_STORE,persistedStore);
  PropertyManagementConverter converter=new PropertyManagementConverter(properties);
  converter.readProperties(commonOptions);
  converter.readProperties(nnOptions);
  GeoWaveExtractNNJobRunner runner=new GeoWaveExtractNNJobRunner();
  int status=runner.run(properties);
  if (status != 0) {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}",0.9974554707379136
113034,"@Override protected void runChild(Runner runner,RunNotifier notifier){
  if (runner instanceof GeoWaveIT) {
    itRunner=(GeoWaveIT)runner;
  }
  super.runChild(runner,notifier);
}","@Override protected void runChild(Runner runner,RunNotifier notifier){
  if (runner instanceof GeoWaveITRunner) {
    itRunner=(GeoWaveITRunner)runner;
  }
  super.runChild(runner,notifier);
}",0.967741935483871
113035,"@Override public void setup() throws Exception {
synchronized (GeoWaveIT.MUTEX) {
    if (jettyServer == null) {
      try {
        jettyServer=new Server();
        final SocketConnector conn=new SocketConnector();
        conn.setPort(JETTY_PORT);
        conn.setAcceptQueueSize(ACCEPT_QUEUE_SIZE);
        conn.setMaxIdleTime(MAX_IDLE_TIME);
        conn.setSoLingerTime(SO_LINGER_TIME);
        jettyServer.setConnectors(new Connector[]{conn});
        final WebAppContext gsWebapp=new WebAppContext();
        gsWebapp.setContextPath(GEOSERVER_CONTEXT_PATH);
        gsWebapp.setWar(GEOSERVER_WAR_DIR);
        final WebAppClassLoader classLoader=AccessController.doPrivileged(new PrivilegedAction<WebAppClassLoader>(){
          @Override public WebAppClassLoader run(){
            try {
              return new WebAppClassLoader(gsWebapp);
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              return null;
            }
          }
        }
);
        if (classLoader == null) {
          throw new IOException(""String_Node_Str"");
        }
        classLoader.addClassPath(System.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        gsWebapp.setClassLoader(classLoader);
        gsWebapp.setParentLoaderPriority(true);
        final File warDir=new File(GEOWAVE_WAR_DIR);
        ServicesTestUtils.writeConfigFile(new File(warDir,""String_Node_Str""));
        final WebAppContext gwWebapp=new WebAppContext();
        gwWebapp.setContextPath(GEOWAVE_CONTEXT_PATH);
        gwWebapp.setWar(warDir.getAbsolutePath());
        jettyServer.setHandlers(new WebAppContext[]{gsWebapp,gwWebapp});
        gsWebapp.setTempDirectory(TestUtils.TEMP_DIR);
        gsWebapp.getServletContext().getContextHandler().setMaxFormContentSize(MAX_FORM_CONTENT_SIZE);
        final String jettyConfigFile=System.getProperty(""String_Node_Str"");
        if (jettyConfigFile != null) {
          LOGGER.info(""String_Node_Str"" + jettyConfigFile);
          (new XmlConfiguration(new FileInputStream(jettyConfigFile))).configure(jettyServer);
        }
        jettyServer.start();
        while (!jettyServer.isRunning() && !jettyServer.isStarted()) {
          Thread.sleep(1000);
        }
      }
 catch (      final RuntimeException e) {
        throw e;
      }
catch (      final Exception e) {
        LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
        if (jettyServer != null) {
          try {
            jettyServer.stop();
          }
 catch (          final Exception e1) {
            LOGGER.error(""String_Node_Str"",e1);
          }
        }
      }
    }
  }
}","@Override public void setup() throws Exception {
synchronized (GeoWaveITRunner.MUTEX) {
    if (jettyServer == null) {
      try {
        jettyServer=new Server();
        final SocketConnector conn=new SocketConnector();
        conn.setPort(JETTY_PORT);
        conn.setAcceptQueueSize(ACCEPT_QUEUE_SIZE);
        conn.setMaxIdleTime(MAX_IDLE_TIME);
        conn.setSoLingerTime(SO_LINGER_TIME);
        jettyServer.setConnectors(new Connector[]{conn});
        final WebAppContext gsWebapp=new WebAppContext();
        gsWebapp.setContextPath(GEOSERVER_CONTEXT_PATH);
        gsWebapp.setWar(GEOSERVER_WAR_DIR);
        final WebAppClassLoader classLoader=AccessController.doPrivileged(new PrivilegedAction<WebAppClassLoader>(){
          @Override public WebAppClassLoader run(){
            try {
              return new WebAppClassLoader(gsWebapp);
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              return null;
            }
          }
        }
);
        if (classLoader == null) {
          throw new IOException(""String_Node_Str"");
        }
        classLoader.addClassPath(System.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        gsWebapp.setClassLoader(classLoader);
        gsWebapp.setParentLoaderPriority(true);
        final File warDir=new File(GEOWAVE_WAR_DIR);
        ServicesTestUtils.writeConfigFile(new File(warDir,""String_Node_Str""));
        final WebAppContext gwWebapp=new WebAppContext();
        gwWebapp.setContextPath(GEOWAVE_CONTEXT_PATH);
        gwWebapp.setWar(warDir.getAbsolutePath());
        jettyServer.setHandlers(new WebAppContext[]{gsWebapp,gwWebapp});
        gsWebapp.setTempDirectory(TestUtils.TEMP_DIR);
        gsWebapp.getServletContext().getContextHandler().setMaxFormContentSize(MAX_FORM_CONTENT_SIZE);
        final String jettyConfigFile=System.getProperty(""String_Node_Str"");
        if (jettyConfigFile != null) {
          LOGGER.info(""String_Node_Str"" + jettyConfigFile);
          (new XmlConfiguration(new FileInputStream(jettyConfigFile))).configure(jettyServer);
        }
        jettyServer.start();
        while (!jettyServer.isRunning() && !jettyServer.isStarted()) {
          Thread.sleep(1000);
        }
      }
 catch (      final RuntimeException e) {
        throw e;
      }
catch (      final Exception e) {
        LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
        if (jettyServer != null) {
          try {
            jettyServer.stop();
          }
 catch (          final Exception e1) {
            LOGGER.error(""String_Node_Str"",e1);
          }
        }
      }
    }
  }
}",0.9988785046728972
113036,"@Override public void tearDown() throws Exception {
synchronized (GeoWaveIT.MUTEX) {
    if (!GeoWaveIT.DEFER_CLEANUP.get()) {
      if (jettyServer != null) {
        try {
          jettyServer.stop();
          jettyServer=null;
        }
 catch (        final Exception e) {
          LOGGER.error(""String_Node_Str"",e);
        }
      }
    }
  }
}","@Override public void tearDown() throws Exception {
synchronized (GeoWaveITRunner.MUTEX) {
    if (!GeoWaveITRunner.DEFER_CLEANUP.get()) {
      if (jettyServer != null) {
        try {
          jettyServer.stop();
          jettyServer=null;
        }
 catch (        final Exception e) {
          LOGGER.error(""String_Node_Str"",e);
        }
      }
    }
  }
}",0.9832869080779943
113037,"/** 
 * Take the options and translate them from a map.
 * @param properties
 */
public void transformFromMap(Map<String,String> properties){
  Properties props=new Properties();
  for (  Entry<String,String> prop : properties.entrySet()) {
    props.setProperty(prop.getKey(),prop.getValue());
  }
  transformFromProperties(props);
}","/** 
 * Take the options and translate them from a map.
 * @param properties
 */
public void transformFromMap(Map<String,String> properties){
  Properties props=new Properties();
  for (  Entry<String,String> prop : properties.entrySet()) {
    if (prop.getValue() != null) {
      props.setProperty(prop.getKey(),prop.getValue());
    }
  }
  transformFromProperties(props);
}",0.939521800281294
113038,"public ConfigOption(final String name,final String description,final boolean optional){
  this.name=name;
  this.description=description;
  this.optional=optional;
}","public ConfigOption(final String name,final String description,final boolean optional,final Class type){
  this.name=name;
  this.description=description;
  this.optional=optional;
  this.type=type;
}",0.9041095890410958
113039,"/** 
 * This method will use the parameter descriptions from JCommander to create/populate an AbstractConfigOptions map.
 */
public static ConfigOption[] createConfigOptionsFromJCommander(Object createOptionsInstance){
  ConfigOption[] opts=null;
  if (createOptionsInstance != null) {
    JCommanderPrefixTranslator translator=new JCommanderPrefixTranslator();
    translator.addObject(createOptionsInstance);
    JCommanderTranslationMap map=translator.translate();
    Collection<TranslationEntry> entries=map.getEntries().values();
    opts=new ConfigOption[entries.size()];
    int optCounter=0;
    for (    TranslationEntry entry : entries) {
      ConfigOption opt=new ConfigOption(entry.getAsPropertyName(),entry.getDescription(),!entry.isRequired());
      opt.setPassword(entry.isPassword());
      opts[optCounter++]=opt;
    }
  }
 else {
    opts=new ConfigOption[0];
  }
  return opts;
}","/** 
 * This method will use the parameter descriptions from JCommander to create/populate an AbstractConfigOptions map.
 */
public static ConfigOption[] createConfigOptionsFromJCommander(Object createOptionsInstance){
  ConfigOption[] opts=null;
  if (createOptionsInstance != null) {
    JCommanderPrefixTranslator translator=new JCommanderPrefixTranslator();
    translator.addObject(createOptionsInstance);
    JCommanderTranslationMap map=translator.translate();
    Collection<TranslationEntry> entries=map.getEntries().values();
    final List<ConfigOption> options=new ArrayList<ConfigOption>();
    for (    TranslationEntry entry : entries) {
      if (!entry.isHidden()) {
        ConfigOption opt=new ConfigOption(entry.getAsPropertyName(),entry.getDescription(),!entry.isRequired(),entry.getParam().getType());
        opt.setPassword(entry.isPassword());
        options.add(opt);
      }
    }
    opts=options.toArray(new ConfigOption[options.size()]);
  }
 else {
    opts=new ConfigOption[0];
  }
  return opts;
}",0.8391101914123125
113040,"@Override public Param apply(final ConfigOption input){
  if (input.isPassword()) {
    return new Param(input.getName(),String.class,input.getDescription(),!input.isOptional(),""String_Node_Str"",Collections.singletonMap(Parameter.IS_PASSWORD,Boolean.TRUE));
  }
  return new Param(input.getName(),GenericTypeResolver.resolveTypeArgument(input.getClass(),ConfigOption.class),input.getDescription(),!input.isOptional());
}","@Override public Param apply(final ConfigOption input){
  if (input.isPassword()) {
    return new Param(input.getName(),String.class,input.getDescription(),!input.isOptional(),""String_Node_Str"",Collections.singletonMap(Parameter.IS_PASSWORD,Boolean.TRUE));
  }
  if (input.getType().isPrimitive() && input.getType() == boolean.class) {
    return new Param(input.getName(),input.getType(),input.getDescription(),true,""String_Node_Str"",Collections.singletonMap(Parameter.OPTIONS,BooleanOptions));
  }
  return new Param(input.getName(),input.getType(),input.getDescription(),!input.isOptional());
}",0.6345776031434185
113041,"@Test public void testInferredRange() throws SchemaException {
  final SimpleFeatureType schema=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"");
  final List<AttributeDescriptor> descriptors=schema.getAttributeDescriptors();
  final Object[] defaults=new Object[descriptors.size()];
  int p=0;
  for (  final AttributeDescriptor descriptor : descriptors) {
    defaults[p++]=descriptor.getDefaultValue();
  }
  final SimpleFeature newFeature=SimpleFeatureBuilder.build(schema,defaults,UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(100));
  newFeature.setAttribute(""String_Node_Str"",UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",time1);
  newFeature.setAttribute(""String_Node_Str"",time2);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(27.25,41.25)));
  final FeatureDataAdapter dataAdapter=new FeatureDataAdapter(schema,new GlobalVisibilityHandler<SimpleFeature,Object>(""String_Node_Str""));
  final byte[] binary=dataAdapter.toBinary();
  final FeatureDataAdapter dataAdapterCopy=new FeatureDataAdapter();
  dataAdapterCopy.fromBinary(binary);
  assertEquals(dataAdapterCopy.getAdapterId(),dataAdapter.getAdapterId());
  assertEquals(dataAdapterCopy.getType(),dataAdapter.getType());
  assertEquals(Boolean.TRUE,dataAdapterCopy.getType().getDescriptor(""String_Node_Str"").getUserData().get(""String_Node_Str""));
  assertEquals(Boolean.TRUE,dataAdapterCopy.getType().getDescriptor(""String_Node_Str"").getUserData().get(""String_Node_Str""));
  final List<IndexFieldHandler<SimpleFeature,? extends CommonIndexValue,Object>> handlers=dataAdapterCopy.getDefaultTypeMatchingHandlers(schema);
  boolean found=false;
  for (  final IndexFieldHandler<SimpleFeature,? extends CommonIndexValue,Object> handler : handlers) {
    found|=((handler instanceof FeatureTimeRangeHandler) && ((((FeatureTimeRangeHandler)handler).toIndexValue(newFeature).toNumericData().getMin() - time1.getTime()) < 0.001) && ((((FeatureTimeRangeHandler)handler).toIndexValue(newFeature).toNumericData().getMax() - time2.getTime()) < 0.001));
  }
  assertTrue(found);
}","@Test public void testInferredRange() throws SchemaException {
  final SimpleFeatureType schema=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<AttributeDescriptor> descriptors=schema.getAttributeDescriptors();
  final Object[] defaults=new Object[descriptors.size()];
  int p=0;
  for (  final AttributeDescriptor descriptor : descriptors) {
    defaults[p++]=descriptor.getDefaultValue();
  }
  final SimpleFeature newFeature=SimpleFeatureBuilder.build(schema,defaults,UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(100));
  newFeature.setAttribute(""String_Node_Str"",UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",time1);
  newFeature.setAttribute(""String_Node_Str"",time2);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(27.25,41.25)));
  final FeatureDataAdapter dataAdapter=new FeatureDataAdapter(schema,new GlobalVisibilityHandler<SimpleFeature,Object>(""String_Node_Str""));
  final byte[] binary=dataAdapter.toBinary();
  final FeatureDataAdapter dataAdapterCopy=new FeatureDataAdapter();
  dataAdapterCopy.fromBinary(binary);
  assertEquals(""String_Node_Str"",dataAdapterCopy.getType().getName().getNamespaceURI());
  assertEquals(dataAdapterCopy.getAdapterId(),dataAdapter.getAdapterId());
  assertEquals(dataAdapterCopy.getType(),dataAdapter.getType());
  assertEquals(Boolean.TRUE,dataAdapterCopy.getType().getDescriptor(""String_Node_Str"").getUserData().get(""String_Node_Str""));
  assertEquals(Boolean.TRUE,dataAdapterCopy.getType().getDescriptor(""String_Node_Str"").getUserData().get(""String_Node_Str""));
  final List<IndexFieldHandler<SimpleFeature,? extends CommonIndexValue,Object>> handlers=dataAdapterCopy.getDefaultTypeMatchingHandlers(schema);
  boolean found=false;
  for (  final IndexFieldHandler<SimpleFeature,? extends CommonIndexValue,Object> handler : handlers) {
    found|=((handler instanceof FeatureTimeRangeHandler) && ((((FeatureTimeRangeHandler)handler).toIndexValue(newFeature).toNumericData().getMin() - time1.getTime()) < 0.001) && ((((FeatureTimeRangeHandler)handler).toIndexValue(newFeature).toNumericData().getMax() - time2.getTime()) < 0.001));
  }
  assertTrue(found);
}",0.9756873437855031
113042,"public static SimpleFeatureType createTrackDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(TRACK);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(LineString.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}","public static SimpleFeatureType createTrackDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(TRACK);
  simpleFeatureTypeBuilder.setNamespaceURI(NAMESPACE);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(LineString.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}",0.9925905967937492
113043,"public static SimpleFeatureType createMissionSummaryDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MISSION_SUMMARY);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Polygon.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}","public static SimpleFeatureType createMissionSummaryDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MISSION_SUMMARY);
  simpleFeatureTypeBuilder.setNamespaceURI(NAMESPACE);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Polygon.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}",0.9817093448619888
113044,"public static SimpleFeatureType createMissionFrameDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MISSION_FRAME);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Polygon.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setTimeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}","public static SimpleFeatureType createMissionFrameDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MISSION_FRAME);
  simpleFeatureTypeBuilder.setNamespaceURI(NAMESPACE);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Polygon.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setTimeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}",0.972568578553616
113045,"public static SimpleFeatureType createPointDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(TRACK_POINT);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Point.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setTimeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}","public static SimpleFeatureType createPointDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(TRACK_POINT);
  simpleFeatureTypeBuilder.setNamespaceURI(NAMESPACE);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Point.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setTimeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}",0.988174586110514
113046,"public static SimpleFeatureType createMotionDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MOTION_POINT);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Point.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}","public static SimpleFeatureType createMotionDataType(){
  final SimpleFeatureTypeBuilder simpleFeatureTypeBuilder=new SimpleFeatureTypeBuilder();
  simpleFeatureTypeBuilder.setName(MOTION_POINT);
  simpleFeatureTypeBuilder.setNamespaceURI(NAMESPACE);
  final AttributeTypeBuilder attributeTypeBuilder=new AttributeTypeBuilder();
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Point.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Date.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(String.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Double.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  simpleFeatureTypeBuilder.add(attributeTypeBuilder.binding(Integer.class).buildDescriptor(""String_Node_Str""));
  final TimeDescriptorConfiguration timeConfig=new TimeDescriptorConfiguration();
  timeConfig.setStartRangeName(""String_Node_Str"");
  timeConfig.setEndRangeName(""String_Node_Str"");
  final SimpleFeatureType type=simpleFeatureTypeBuilder.buildFeatureType();
  timeConfig.updateType(type);
  return type;
}",0.9878827935668648
113047,"/** 
 * This function will append a UUID to the record that's inserted into the database.
 * @param object
 * @return
 */
@Override protected ByteArrayId getRowId(DataStatistics<?> object){
  byte[] parentRecord=super.getRowId(object).getBytes();
  ByteBuffer parentBuffer=ByteBuffer.allocate(parentRecord.length + 16);
  parentBuffer.put(parentRecord);
  UUID uuid=UUID.randomUUID();
  parentBuffer.putLong(uuid.getMostSignificantBits());
  parentBuffer.putLong(uuid.getLeastSignificantBits());
  return new ByteArrayId(parentBuffer.array());
}","/** 
 * This function will append a UUID to the record that's inserted into the database.
 * @param object
 * @return
 */
@Override protected ByteArrayId getRowId(DataStatistics<?> object){
  byte[] parentRecord=super.getRowId(object).getBytes();
  ByteBuffer parentBuffer=ByteBuffer.allocate(parentRecord.length + 1 + 16);
  parentBuffer.put(parentRecord);
  UUID uuid=UUID.randomUUID();
  parentBuffer.put(new byte[]{0});
  parentBuffer.putLong(uuid.getMostSignificantBits());
  parentBuffer.putLong(uuid.getLeastSignificantBits());
  return new ByteArrayId(parentBuffer.array());
}",0.9654561558901684
113048,"/** 
 * This function is used to change the scan object created in the superclass to enable  prefixing.
 */
@Override protected Scan applyScannerSettings(Scan scanner,ByteArrayId primaryId,ByteArrayId secondaryId){
  Scan scan=super.applyScannerSettings(scanner,primaryId,secondaryId);
  if (primaryId != null) {
    scan.setStopRow(HBaseUtils.getNextPrefix(scan.getStopRow()));
  }
  return scan;
}","/** 
 * This function is used to change the scan object created in the superclass to enable  prefixing.
 */
@Override protected Scan applyScannerSettings(Scan scanner,ByteArrayId primaryId,ByteArrayId secondaryId){
  Scan scan=super.applyScannerSettings(scanner,primaryId,secondaryId);
  if (primaryId != null) {
    ByteBuffer buf=ByteBuffer.allocate(primaryId.getBytes().length + 1);
    buf.put(primaryId.getBytes());
    buf.put(new byte[]{0});
    scan.setStopRow(HBaseUtils.getNextPrefix(buf.array()));
  }
  return scan;
}",0.8275862068965517
113049,"@Test public void testInsert() throws IOException {
  DataStatisticsStore store=dataStore.createDataStatisticsStore();
  DataStatistics<?> stat=new CountDataStatistics<String>(new ByteArrayId(""String_Node_Str""));
  stat.entryIngested(null,null);
  stat.entryIngested(null,null);
  stat.entryIngested(null,null);
  store.incorporateStatistics(stat);
  HBaseRequiredOptions opts=(HBaseRequiredOptions)dataStore.getFactoryOptions();
  BasicHBaseOperations ops=BasicHBaseOperations.createOperations(opts);
  Scan scan=new Scan();
  scan.setStartRow(stat.getStatisticsId().getBytes());
  scan.setStopRow(HBaseUtils.getNextPrefix(stat.getStatisticsId().getBytes()));
  scan.addFamily(new ByteArrayId(""String_Node_Str"").getBytes());
  ResultScanner rs=ops.getScannedResults(scan,""String_Node_Str"");
  Iterator<Result> res=rs.iterator();
  byte[] row=res.next().getRow();
  Assert.assertEquals(stat.getStatisticsId().getBytes().length + 16,row.length);
  byte[] bytes=new byte[stat.getStatisticsId().getBytes().length];
  ByteBuffer bb=ByteBuffer.wrap(row);
  bb.get(bytes);
  ByteArrayId bad=new ByteArrayId(bytes);
  Assert.assertEquals(stat.getStatisticsId().getString(),bad.getString());
  Assert.assertEquals(stat,store.getDataStatistics(stat.getDataAdapterId(),stat.getStatisticsId()));
}","@Test public void testInsert() throws IOException {
  DataStatisticsStore store=dataStore.createDataStatisticsStore();
  DataStatistics<?> stat=new CountDataStatistics<String>(new ByteArrayId(""String_Node_Str""));
  stat.entryIngested(null,null);
  stat.entryIngested(null,null);
  stat.entryIngested(null,null);
  store.incorporateStatistics(stat);
  HBaseRequiredOptions opts=(HBaseRequiredOptions)dataStore.getFactoryOptions();
  BasicHBaseOperations ops=BasicHBaseOperations.createOperations(opts);
  Scan scan=new Scan();
  scan.setStartRow(stat.getStatisticsId().getBytes());
  scan.setStopRow(HBaseUtils.getNextPrefix(stat.getStatisticsId().getBytes()));
  scan.addFamily(new ByteArrayId(""String_Node_Str"").getBytes());
  ResultScanner rs=ops.getScannedResults(scan,""String_Node_Str"");
  Iterator<Result> res=rs.iterator();
  byte[] row=res.next().getRow();
  Assert.assertEquals(stat.getStatisticsId().getBytes().length + 16 + 1,row.length);
  byte[] bytes=new byte[stat.getStatisticsId().getBytes().length];
  ByteBuffer bb=ByteBuffer.wrap(row);
  bb.get(bytes);
  ByteArrayId bad=new ByteArrayId(bytes);
  Assert.assertEquals(stat.getStatisticsId().getString(),bad.getString());
  Assert.assertEquals(stat,store.getDataStatistics(stat.getDataAdapterId(),stat.getStatisticsId()));
}",0.998447204968944
113050,"@SuppressWarnings(""String_Node_Str"") public CloseableIterator<Object> query(final BasicHBaseOperations operations,final AdapterStore adapterStore,final Integer limit){
  try {
    if (!validateAdapters(operations)) {
      LOGGER.warn(""String_Node_Str"");
      return new CloseableIterator.Empty();
    }
    if (!operations.tableExists(StringUtils.stringFromBinary(index.getId().getBytes()))) {
      LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()));
      return new CloseableIterator.Empty();
    }
  }
 catch (  final IOException ex) {
    LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()) + ""String_Node_Str"");
    return new CloseableIterator.Empty();
  }
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  final List<Filter> distributableFilters=getDistributableFilter();
  CloseableIterator<DataAdapter<?>> adapters=null;
  if ((fieldIds != null) && !fieldIds.isEmpty()) {
    adapters=adapterStore.getAdapters();
  }
  final List<Scan> scanners=getScanners(limit,distributableFilters,adapters);
  final List<Iterator<Result>> resultsIterators=new ArrayList<Iterator<Result>>();
  final List<ResultScanner> results=new ArrayList<ResultScanner>();
  for (  final Scan scanner : scanners) {
    try {
      final ResultScanner rs=operations.getScannedResults(scanner,tableName);
      if (rs != null) {
        results.add(rs);
        final Iterator<Result> it=rs.iterator();
        if (it.hasNext()) {
          resultsIterators.add(it);
        }
      }
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"" + e);
    }
  }
  if (results.iterator().hasNext()) {
    Iterator it=initIterator(adapterStore,Iterators.concat(resultsIterators.iterator()));
    if ((limit != null) && (limit > 0)) {
      it=Iterators.limit(it,limit);
    }
    if (it.hasNext()) {
      return new HBaseCloseableIteratorWrapper(new MultiScannerClosableWrapper(results),it);
    }
  }
  LOGGER.error(""String_Node_Str"");
  return new CloseableIterator.Empty();
}","@SuppressWarnings(""String_Node_Str"") public CloseableIterator<Object> query(final BasicHBaseOperations operations,final AdapterStore adapterStore,final Integer limit){
  try {
    if (!validateAdapters(operations)) {
      LOGGER.warn(""String_Node_Str"");
      return new CloseableIterator.Empty();
    }
    if (!operations.tableExists(StringUtils.stringFromBinary(index.getId().getBytes()))) {
      LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()));
      return new CloseableIterator.Empty();
    }
  }
 catch (  final IOException ex) {
    LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()) + ""String_Node_Str"");
    return new CloseableIterator.Empty();
  }
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  final List<Filter> distributableFilters=getDistributableFilter();
  CloseableIterator<DataAdapter<?>> adapters=null;
  if ((fieldIds != null) && !fieldIds.isEmpty()) {
    adapters=adapterStore.getAdapters();
  }
  final List<Scan> scanners=getScanners(limit,distributableFilters,adapters);
  final List<Iterator<Result>> resultsIterators=new ArrayList<Iterator<Result>>();
  final List<ResultScanner> results=new ArrayList<ResultScanner>();
  for (  final Scan scanner : scanners) {
    try {
      final ResultScanner rs=operations.getScannedResults(scanner,tableName);
      if (rs != null) {
        results.add(rs);
        final Iterator<Result> it=rs.iterator();
        if (it.hasNext()) {
          resultsIterators.add(it);
        }
      }
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"" + e);
    }
  }
  if (results.iterator().hasNext()) {
    Iterator it=initIterator(adapterStore,Iterators.concat(resultsIterators.iterator()));
    if ((limit != null) && (limit > 0)) {
      it=Iterators.limit(it,limit);
    }
    return new HBaseCloseableIteratorWrapper(new MultiScannerClosableWrapper(results),it);
  }
  LOGGER.error(""String_Node_Str"");
  return new CloseableIterator.Empty();
}",0.9922518159806296
113051,"protected List<Scan> getScanners(final Integer limit,final List<Filter> distributableFilters,final CloseableIterator<DataAdapter<?>> adapters){
  FilterList filterList=null;
  if ((distributableFilters != null) && (distributableFilters.size() > 0)) {
    filterList=new FilterList();
    for (    final Filter filter : distributableFilters) {
      filterList.addFilter(filter);
    }
  }
  List<ByteArrayRange> ranges=getRanges();
  if ((ranges == null) || ranges.isEmpty()) {
    ranges=Collections.singletonList(new ByteArrayRange(null,null));
  }
  final List<Scan> scanners=new ArrayList<Scan>();
  if ((ranges != null) && (ranges.size() > 0)) {
    for (    final ByteArrayRange range : ranges) {
      final Scan scanner=new Scan();
      if ((adapterIds != null) && !adapterIds.isEmpty()) {
        for (        final ByteArrayId adapterId : adapterIds) {
          scanner.addFamily(adapterId.getBytes());
        }
      }
      if (range.getStart() != null) {
        scanner.setStartRow(range.getStart().getBytes());
        if (!range.isSingleValue()) {
          scanner.setStopRow(HBaseUtils.getNextPrefix(range.getEnd().getBytes()));
        }
      }
      scanner.setFilter(filterList);
      if ((fieldIds != null) && !fieldIds.isEmpty()) {
        handleSubsetOfFieldIds(scanner,adapters);
      }
      if ((limit != null) && (limit > 0) && (limit < scanner.getBatch())) {
        scanner.setBatch(limit);
      }
      scanners.add(scanner);
    }
  }
  return scanners;
}","protected List<Scan> getScanners(final Integer limit,final List<Filter> distributableFilters,final CloseableIterator<DataAdapter<?>> adapters){
  FilterList filterList=null;
  if ((distributableFilters != null) && (distributableFilters.size() > 0)) {
    filterList=new FilterList();
    for (    final Filter filter : distributableFilters) {
      filterList.addFilter(filter);
    }
  }
  List<ByteArrayRange> ranges=getRanges();
  if ((ranges == null) || ranges.isEmpty()) {
    ranges=Collections.singletonList(new ByteArrayRange(null,null));
  }
  final List<Scan> scanners=new ArrayList<Scan>();
  if ((ranges != null) && (ranges.size() > 0)) {
    for (    final ByteArrayRange range : ranges) {
      final Scan scanner=new Scan();
      if ((adapterIds != null) && !adapterIds.isEmpty()) {
        for (        final ByteArrayId adapterId : adapterIds) {
          scanner.addFamily(adapterId.getBytes());
        }
      }
      if (range.getStart() != null) {
        scanner.setStartRow(range.getStart().getBytes());
        if (!range.isSingleValue()) {
          scanner.setStopRow(HBaseUtils.getNextPrefix(range.getEnd().getBytes()));
        }
 else {
          scanner.setStopRow(HBaseUtils.getNextPrefix(range.getStart().getBytes()));
        }
      }
      scanner.setFilter(filterList);
      if ((fieldIds != null) && !fieldIds.isEmpty()) {
        handleSubsetOfFieldIds(scanner,adapters);
      }
      if ((limit != null) && (limit > 0) && (limit < scanner.getBatch())) {
        scanner.setBatch(limit);
      }
      scanners.add(scanner);
    }
  }
  return scanners;
}",0.9666774506632158
113052,"public static byte[] getNextPrefix(final byte[] prefix){
  return new Scan(prefix).getStopRow();
}","public static byte[] getNextPrefix(final byte[] prefix){
  return new Scan().setRowPrefixFilter(prefix).getStopRow();
}",0.9032258064516128
113053,"@Override public <T>CloseableIterator<T> query(final QueryOptions queryOptions,final Query query){
  final List<CloseableIterator<Object>> results=new ArrayList<CloseableIterator<Object>>();
  final QueryOptions sanitizedQueryOptions=(queryOptions == null) ? new QueryOptions() : queryOptions;
  final Query sanitizedQuery=(query == null) ? new EverythingQuery() : query;
  final DedupeFilter filter=new DedupeFilter();
  MemoryAdapterStore tempAdapterStore;
  try {
    tempAdapterStore=new MemoryAdapterStore(sanitizedQueryOptions.getAdaptersArray(adapterStore));
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : sanitizedQueryOptions.getAdaptersWithMinimalSetOfIndices(tempAdapterStore,indexMappingStore,indexStore)) {
      final List<ByteArrayId> adapterIdsToQuery=new ArrayList<ByteArrayId>();
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        if (sanitizedQuery instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,indexAdapterPair.getLeft(),((RowIdQuery)sanitizedQuery).getRowIds(),(ScanCallback<Object>)sanitizedQueryOptions.getScanCallback(),filter,sanitizedQueryOptions.getAuthorizations());
          results.add(q.query(operations,tempAdapterStore,-1));
          continue;
        }
 else         if (sanitizedQuery instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)sanitizedQuery;
          if (idQuery.getAdapterId().equals(adapter.getAdapterId())) {
            results.add(getEntries(indexAdapterPair.getLeft(),idQuery.getDataIds(),(DataAdapter<Object>)adapterStore.getAdapter(idQuery.getAdapterId()),filter,(ScanCallback<Object>)sanitizedQueryOptions.getScanCallback(),sanitizedQueryOptions.getAuthorizations(),sanitizedQueryOptions.getMaxResolutionSubsamplingPerDimension(),true));
          }
          continue;
        }
 else         if (sanitizedQuery instanceof PrefixIdQuery) {
          continue;
        }
        adapterIdsToQuery.add(adapter.getAdapterId());
      }
      if (adapterIdsToQuery.size() > 0) {
        HBaseConstraintsQuery accumuloQuery;
        accumuloQuery=new HBaseConstraintsQuery(adapterIdsToQuery,indexAdapterPair.getLeft(),sanitizedQuery,filter,sanitizedQueryOptions.getScanCallback(),queryOptions.getAggregation(),sanitizedQueryOptions.getAuthorizations());
        results.add(accumuloQuery.query(operations,tempAdapterStore,sanitizedQueryOptions.getLimit()));
      }
    }
  }
 catch (  final IOException e1) {
    LOGGER.error(""String_Node_Str"",e1);
  }
  return new CloseableIteratorWrapper<T>(new Closeable(){
    @Override public void close() throws IOException {
      for (      final CloseableIterator<Object> result : results) {
        result.close();
      }
    }
  }
,Iterators.concat(new CastIterator<T>(results.iterator())));
}","@Override public <T>CloseableIterator<T> query(final QueryOptions queryOptions,final Query query){
  final List<CloseableIterator<Object>> results=new ArrayList<CloseableIterator<Object>>();
  final QueryOptions sanitizedQueryOptions=(queryOptions == null) ? new QueryOptions() : queryOptions;
  final Query sanitizedQuery=(query == null) ? new EverythingQuery() : query;
  final DedupeFilter filter=new DedupeFilter();
  MemoryAdapterStore tempAdapterStore;
  try {
    tempAdapterStore=new MemoryAdapterStore(sanitizedQueryOptions.getAdaptersArray(adapterStore));
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : sanitizedQueryOptions.getAdaptersWithMinimalSetOfIndices(tempAdapterStore,indexMappingStore,indexStore)) {
      final List<ByteArrayId> adapterIdsToQuery=new ArrayList<ByteArrayId>();
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        if (sanitizedQuery instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,indexAdapterPair.getLeft(),((RowIdQuery)sanitizedQuery).getRowIds(),(ScanCallback<Object>)sanitizedQueryOptions.getScanCallback(),filter,sanitizedQueryOptions.getAuthorizations());
          results.add(q.query(operations,tempAdapterStore,-1));
          continue;
        }
 else         if (sanitizedQuery instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)sanitizedQuery;
          if (idQuery.getAdapterId().equals(adapter.getAdapterId())) {
            results.add(getEntries(indexAdapterPair.getLeft(),idQuery.getDataIds(),(DataAdapter<Object>)adapterStore.getAdapter(idQuery.getAdapterId()),filter,(ScanCallback<Object>)sanitizedQueryOptions.getScanCallback(),sanitizedQueryOptions.getAuthorizations(),sanitizedQueryOptions.getMaxResolutionSubsamplingPerDimension(),true));
          }
          continue;
        }
 else         if (sanitizedQuery instanceof PrefixIdQuery) {
          continue;
        }
        adapterIdsToQuery.add(adapter.getAdapterId());
      }
      if (adapterIdsToQuery.size() > 0) {
        HBaseConstraintsQuery hbaseQuery;
        hbaseQuery=new HBaseConstraintsQuery(adapterIdsToQuery,indexAdapterPair.getLeft(),sanitizedQuery,filter,sanitizedQueryOptions.getScanCallback(),queryOptions.getAggregation(),sanitizedQueryOptions.getAuthorizations());
        results.add(hbaseQuery.query(operations,tempAdapterStore,sanitizedQueryOptions.getLimit()));
      }
    }
  }
 catch (  final IOException e1) {
    LOGGER.error(""String_Node_Str"",e1);
  }
  return new CloseableIteratorWrapper<T>(new Closeable(){
    @Override public void close() throws IOException {
      for (      final CloseableIterator<Object> result : results) {
        result.close();
      }
    }
  }
,Iterators.concat(new CastIterator<T>(results.iterator())));
}",0.9931542917324908
113054,"public AltIndexCallback(final String indexName,final WritableDataAdapter<T> adapter,final HBaseOptions accumuloOptions) throws IOException {
  this.adapter=adapter;
  altIdxTableName=indexName + HBaseUtils.ALT_INDEX_TABLE;
  if (operations.tableExists(indexName)) {
    if (!operations.tableExists(altIdxTableName)) {
      throw new TableNotFoundException(altIdxTableName);
    }
  }
 else {
    if (operations.tableExists(altIdxTableName)) {
      operations.deleteTable(altIdxTableName);
      LOGGER.warn(""String_Node_Str"" + altIdxTableName + ""String_Node_Str"");
    }
  }
  altIdxWriter=operations.createWriter(altIdxTableName,adapter.getAdapterId().getString(),accumuloOptions.isCreateTable());
}","public AltIndexCallback(final String indexName,final WritableDataAdapter<T> adapter,final HBaseOptions hbaseOptions) throws IOException {
  this.adapter=adapter;
  altIdxTableName=indexName + HBaseUtils.ALT_INDEX_TABLE;
  if (operations.tableExists(indexName)) {
    if (!operations.tableExists(altIdxTableName)) {
      throw new TableNotFoundException(altIdxTableName);
    }
  }
 else {
    if (operations.tableExists(altIdxTableName)) {
      operations.deleteTable(altIdxTableName);
      LOGGER.warn(""String_Node_Str"" + altIdxTableName + ""String_Node_Str"");
    }
  }
  altIdxWriter=operations.createWriter(altIdxTableName,adapter.getAdapterId().getString(),hbaseOptions.isCreateTable());
}",0.9814020028612304
113055,"@Override public boolean delete(final QueryOptions queryOptions,final Query query){
  if (((query == null) || (query instanceof EverythingQuery)) && queryOptions.isAllAdapters()) {
    try {
      operations.deleteAll();
      return true;
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return false;
    }
  }
  final AtomicBoolean aOk=new AtomicBoolean(true);
  final Set<ByteArrayId> queriedAdapters=new HashSet<ByteArrayId>();
  try {
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : queryOptions.getIndicesForAdapters(adapterStore,indexMappingStore,indexStore)) {
      final PrimaryIndex index=indexAdapterPair.getLeft();
      final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
      final String altIdxTableName=tableName + HBaseUtils.ALT_INDEX_TABLE;
      final boolean useAltIndex=options.isUseAltIndex() && operations.tableExists(altIdxTableName);
      final HBaseWriter idxDeleter=operations.createWriter(tableName,""String_Node_Str"",false);
      final HBaseWriter altIdxDelete=useAltIndex ? operations.createWriter(altIdxTableName,""String_Node_Str"",false) : null;
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        final DataStoreCallbackManager callbackCache=new DataStoreCallbackManager(statisticsStore,secondaryIndexDataStore,queriedAdapters.add(adapter.getAdapterId()));
        callbackCache.setPersistStats(options.persistDataStatistics);
        if (query instanceof EverythingQuery) {
          deleteEntries(adapter,index,queryOptions.getAuthorizations());
          continue;
        }
        final ScanCallback<Object> callback=new ScanCallback<Object>(){
          @Override public void entryScanned(          final DataStoreEntryInfo entryInfo,          final Object entry){
            callbackCache.getDeleteCallback((WritableDataAdapter<Object>)adapter,index).entryDeleted(entryInfo,entry);
            try {
              addToBatch(idxDeleter,entryInfo.getRowIds());
              if (altIdxDelete != null) {
                addToBatch(altIdxDelete,Collections.singletonList(adapter.getDataId(entry)));
              }
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              aOk.set(false);
            }
          }
        }
;
        CloseableIterator<?> dataIt=null;
        if (query instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,index,((RowIdQuery)query).getRowIds(),callback,null,queryOptions.getAuthorizations());
          dataIt=q.query(operations,adapterStore,-1);
        }
 else         if (query instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)query;
          dataIt=getEntries(index,idQuery.getDataIds(),adapter,null,callback,queryOptions.getAuthorizations(),null,false);
        }
 else         if (query instanceof PrefixIdQuery) {
        }
 else {
          dataIt=new HBaseConstraintsQuery(Collections.singletonList(adapter.getAdapterId()),index,query,null,callback,null,queryOptions.getAuthorizations()).query(operations,adapterStore,null);
        }
        while (dataIt.hasNext()) {
          dataIt.next();
        }
        try {
          dataIt.close();
        }
 catch (        final Exception ex) {
          LOGGER.warn(""String_Node_Str"",ex);
        }
        callbackCache.close();
      }
      if (altIdxDelete != null) {
        altIdxDelete.close();
      }
      idxDeleter.close();
    }
    return aOk.get();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + query.toString(),e);
    return false;
  }
}","@Override public boolean delete(final QueryOptions queryOptions,final Query query){
  if (((query == null) || (query instanceof EverythingQuery)) && queryOptions.isAllAdapters()) {
    try {
      operations.deleteAll();
      return true;
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return false;
    }
  }
  final AtomicBoolean aOk=new AtomicBoolean(true);
  final Set<ByteArrayId> queriedAdapters=new HashSet<ByteArrayId>();
  try {
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : queryOptions.getIndicesForAdapters(adapterStore,indexMappingStore,indexStore)) {
      final PrimaryIndex index=indexAdapterPair.getLeft();
      final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
      final String altIdxTableName=tableName + HBaseUtils.ALT_INDEX_TABLE;
      final boolean useAltIndex=options.isUseAltIndex() && operations.tableExists(altIdxTableName);
      final HBaseWriter idxDeleter=operations.createWriter(tableName,""String_Node_Str"",false);
      final HBaseWriter altIdxDelete=useAltIndex ? operations.createWriter(altIdxTableName,""String_Node_Str"",false) : null;
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        final DataStoreCallbackManager callbackCache=new DataStoreCallbackManager(statisticsStore,secondaryIndexDataStore,queriedAdapters.add(adapter.getAdapterId()));
        callbackCache.setPersistStats(options.persistDataStatistics);
        if (query instanceof EverythingQuery) {
          deleteEntries(adapter,index,queryOptions.getAuthorizations());
          continue;
        }
        final ScanCallback<Object> callback=new ScanCallback<Object>(){
          @Override public void entryScanned(          final DataStoreEntryInfo entryInfo,          final Object entry){
            callbackCache.getDeleteCallback((WritableDataAdapter<Object>)adapter,index).entryDeleted(entryInfo,entry);
            try {
              addToBatch(idxDeleter,entryInfo.getRowIds());
              if (altIdxDelete != null) {
                addToBatch(altIdxDelete,Collections.singletonList(adapter.getDataId(entry)));
              }
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              aOk.set(false);
            }
          }
        }
;
        CloseableIterator<?> dataIt=null;
        if (query instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,index,((RowIdQuery)query).getRowIds(),callback,null,queryOptions.getAuthorizations());
          dataIt=q.query(operations,adapterStore,-1);
        }
 else         if (query instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)query;
          dataIt=getEntries(index,idQuery.getDataIds(),adapter,null,callback,queryOptions.getAuthorizations(),null,false);
        }
 else         if (query instanceof PrefixIdQuery) {
        }
 else {
          dataIt=new HBaseConstraintsQuery(Collections.singletonList(adapter.getAdapterId()),index,query,null,callback,null,queryOptions.getAuthorizations()).query(operations,adapterStore,null);
        }
        if (dataIt != null) {
          while (dataIt.hasNext()) {
            dataIt.next();
          }
          try {
            dataIt.close();
          }
 catch (          final Exception ex) {
            LOGGER.warn(""String_Node_Str"",ex);
          }
        }
        callbackCache.close();
      }
      if (altIdxDelete != null) {
        altIdxDelete.close();
      }
      idxDeleter.close();
    }
    return aOk.get();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + query.toString(),e);
    return false;
  }
}",0.9922168545356952
113056,"private void addColumnFamilyToTable(TableName name,String columnFamilyName) throws IOException {
  HColumnDescriptor cfDesciptor=new HColumnDescriptor(columnFamilyName);
  if (admin.tableExists(name)) {
    if (!admin.isTableEnabled(name)) {
      admin.enableTable(name);
    }
    HTableDescriptor descriptor=admin.getTableDescriptor(name);
    boolean found=false;
    for (    HColumnDescriptor hColumnDescriptor : descriptor.getColumnFamilies()) {
      if (hColumnDescriptor.getNameAsString().equalsIgnoreCase(columnFamilyName))       found=true;
    }
    if (!found) {
      if (admin.isTableEnabled(name)) {
        admin.disableTable(name);
      }
      admin.addColumn(name,cfDesciptor);
      admin.enableTable(name);
    }
  }
 else {
    LOGGER.warn(""String_Node_Str"" + name.getNameAsString() + ""String_Node_Str""+ columnFamilyName+ ""String_Node_Str"");
  }
}","private void addColumnFamilyToTable(final TableName name,final String columnFamilyName) throws IOException {
  final HColumnDescriptor cfDesciptor=new HColumnDescriptor(columnFamilyName);
  if (admin.tableExists(name)) {
    if (!admin.isTableEnabled(name)) {
      admin.enableTable(name);
    }
    final HTableDescriptor descriptor=admin.getTableDescriptor(name);
    boolean found=false;
    for (    final HColumnDescriptor hColumnDescriptor : descriptor.getColumnFamilies()) {
      if (hColumnDescriptor.getNameAsString().equalsIgnoreCase(columnFamilyName)) {
        found=true;
      }
    }
    if (!found) {
      if (admin.isTableEnabled(name)) {
        admin.disableTable(name);
      }
      admin.addColumn(name,cfDesciptor);
      admin.enableTable(name);
    }
  }
 else {
    LOGGER.warn(""String_Node_Str"" + name.getNameAsString() + ""String_Node_Str""+ columnFamilyName+ ""String_Node_Str"");
  }
}",0.9764837625979844
113057,"public HBaseWriter(Admin admin,Table table){
  this.admin=admin;
  this.table=table;
}","public HBaseWriter(final Admin admin,final Table table){
  this.admin=admin;
  this.table=table;
}",0.9347826086956522
113058,"public void write(RowMutations mutation,String columnFamily){
  try {
    addColumnFamilyToTable(table.getName(),columnFamily);
    write(mutation);
  }
 catch (  IOException e) {
    LOGGER.warn(""String_Node_Str"" + columnFamily,e);
  }
}","public void write(final RowMutations mutation,final String columnFamily){
  try {
    addColumnFamilyToTable(table.getName(),columnFamily);
    write(mutation);
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + columnFamily,e);
  }
}",0.9635627530364372
113059,"public void delete(List<Delete> deletes) throws IOException {
  table.delete(deletes);
}","public void delete(final List<Delete> deletes) throws IOException {
  table.delete(deletes);
}",0.967032967032967
113060,"@SuppressWarnings(""String_Node_Str"") public CloseableIterator<Object> query(final BasicHBaseOperations operations,final AdapterStore adapterStore,final Integer limit){
  try {
    if (!operations.tableExists(StringUtils.stringFromBinary(index.getId().getBytes()))) {
      LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()));
      return new CloseableIterator.Empty();
    }
  }
 catch (  final IOException ex) {
    LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()) + ""String_Node_Str"");
    return new CloseableIterator.Empty();
  }
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  final List<Filter> distributableFilters=getDistributableFilter();
  CloseableIterator<DataAdapter<?>> adapters=null;
  if ((fieldIds != null) && !fieldIds.isEmpty()) {
    adapters=adapterStore.getAdapters();
  }
  final List<Scan> scanners=getScanners(limit,distributableFilters,adapters);
  final List<Iterator<Result>> resultsIterators=new ArrayList<Iterator<Result>>();
  final List<ResultScanner> results=new ArrayList<ResultScanner>();
  try {
    for (    final Scan scanner : scanners) {
      final ResultScanner rs=operations.getScannedResults(scanner,tableName);
      final Iterator<Result> it=rs.iterator();
      if ((rs != null) && it.hasNext()) {
        resultsIterators.add(it);
        results.add(rs);
      }
    }
    if (results.iterator().hasNext()) {
      Iterator it=initIterator(adapterStore,Iterators.concat(resultsIterators.iterator()));
      if ((limit != null) && (limit > 0)) {
        it=Iterators.limit(it,limit);
      }
      return new HBaseCloseableIteratorWrapper(new MultiScannerClosableWrapper(results),it);
    }
 else {
      LOGGER.error(""String_Node_Str"");
      return null;
    }
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
}","@SuppressWarnings(""String_Node_Str"") public CloseableIterator<Object> query(final BasicHBaseOperations operations,final AdapterStore adapterStore,final Integer limit){
  try {
    if (!operations.tableExists(StringUtils.stringFromBinary(index.getId().getBytes()))) {
      LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()));
      return new CloseableIterator.Empty();
    }
  }
 catch (  final IOException ex) {
    LOGGER.warn(""String_Node_Str"" + StringUtils.stringFromBinary(index.getId().getBytes()) + ""String_Node_Str"");
    return new CloseableIterator.Empty();
  }
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  final List<Filter> distributableFilters=getDistributableFilter();
  CloseableIterator<DataAdapter<?>> adapters=null;
  if ((fieldIds != null) && !fieldIds.isEmpty()) {
    adapters=adapterStore.getAdapters();
  }
  final List<Scan> scanners=getScanners(limit,distributableFilters,adapters);
  final List<Iterator<Result>> resultsIterators=new ArrayList<Iterator<Result>>();
  final List<ResultScanner> results=new ArrayList<ResultScanner>();
  try {
    for (    final Scan scanner : scanners) {
      final ResultScanner rs=operations.getScannedResults(scanner,tableName);
      if (rs != null) {
        final Iterator<Result> it=rs.iterator();
        if (it.hasNext()) {
          resultsIterators.add(it);
          results.add(rs);
        }
      }
    }
    if (results.iterator().hasNext()) {
      Iterator it=initIterator(adapterStore,Iterators.concat(resultsIterators.iterator()));
      if ((limit != null) && (limit > 0)) {
        it=Iterators.limit(it,limit);
      }
      return new HBaseCloseableIteratorWrapper(new MultiScannerClosableWrapper(results),it);
    }
 else {
      LOGGER.error(""String_Node_Str"");
      return null;
    }
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
}",0.9569948186528496
113061,"protected BasicHBaseOperations getHbaseOperationsInstance(String zookeeperInstances,String geowaveNamespace) throws IOException {
  return new BasicHBaseOperations(zookeeperInstances,geowaveNamespace);
}","protected BasicHBaseOperations getHbaseOperationsInstance(final String zookeeperInstances,final String geowaveNamespace) throws IOException {
  return new BasicHBaseOperations(zookeeperInstances,geowaveNamespace);
}",0.971291866028708
113062,"protected BasicHBaseOperations createOperations(final Map<String,Object> configOptions,final String namespace){
  try {
    return BasicHBaseOperations.createOperations(configOptions,namespace);
  }
 catch (  final Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}","protected BasicHBaseOperations createOperations(final HBaseRequiredOptions options){
  try {
    return BasicHBaseOperations.createOperations(options);
  }
 catch (  final Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}",0.7903525046382189
113063,"@Override public boolean delete(final QueryOptions queryOptions,final Query query){
  if (((query == null) || (query instanceof EverythingQuery)) && queryOptions.isAllAdapters()) {
    try {
      operations.deleteAll();
      return true;
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return false;
    }
  }
  final AtomicBoolean aOk=new AtomicBoolean(true);
  final Set<ByteArrayId> queriedAdapters=new HashSet<ByteArrayId>();
  try {
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : queryOptions.getIndicesForAdapters(adapterStore,indexMappingStore,indexStore)) {
      final PrimaryIndex index=indexAdapterPair.getLeft();
      final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
      final String altIdxTableName=tableName + HBaseUtils.ALT_INDEX_TABLE;
      final boolean useAltIndex=options.isUseAltIndex() && operations.tableExists(altIdxTableName);
      final HBaseWriter idxDeleter=operations.createWriter(tableName,""String_Node_Str"",false);
      final HBaseWriter altIdxDelete=useAltIndex ? operations.createWriter(altIdxTableName,""String_Node_Str"",false) : null;
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        final DataStoreCallbackManager callbackCache=new DataStoreCallbackManager(statisticsStore,secondaryIndexDataStore,queriedAdapters.add(adapter.getAdapterId()));
        callbackCache.setPersistStats(options.persistDataStatistics);
        if (query instanceof EverythingQuery) {
          deleteEntries(adapter,index,queryOptions.getAuthorizations());
          continue;
        }
        final ScanCallback<Object> callback=new ScanCallback<Object>(){
          @Override public void entryScanned(          final DataStoreEntryInfo entryInfo,          final Object entry){
            callbackCache.getDeleteCallback((WritableDataAdapter<Object>)adapter,index).entryDeleted(entryInfo,entry);
            try {
              addToBatch(idxDeleter,entryInfo.getRowIds());
              if (altIdxDelete != null) {
                addToBatch(altIdxDelete,Collections.singletonList(adapter.getDataId(entry)));
              }
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              aOk.set(false);
            }
          }
        }
;
        CloseableIterator<?> dataIt=null;
        if (query instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,index,((RowIdQuery)query).getRowIds(),callback,null,queryOptions.getAuthorizations());
          dataIt=q.query(operations,adapterStore,-1);
        }
 else         if (query instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)query;
          dataIt=getEntries(index,idQuery.getDataIds(),adapter,null,callback,queryOptions.getAuthorizations(),null,false);
        }
 else         if (query instanceof PrefixIdQuery) {
        }
 else {
          dataIt=new HBaseConstraintsQuery(Collections.singletonList(adapter.getAdapterId()),index,query,null,callback,null,queryOptions.getAuthorizations()).query(operations,adapterStore,null);
        }
        if (dataIt != null) {
          while (dataIt.hasNext()) {
            dataIt.next();
          }
          try {
            dataIt.close();
          }
 catch (          final Exception ex) {
            LOGGER.warn(""String_Node_Str"",ex);
          }
        }
        callbackCache.close();
      }
      if (altIdxDelete != null) {
        altIdxDelete.close();
      }
      idxDeleter.close();
    }
    return aOk.get();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + query.toString(),e);
    return false;
  }
}","@Override public boolean delete(final QueryOptions queryOptions,final Query query){
  if (((query == null) || (query instanceof EverythingQuery)) && queryOptions.isAllAdapters()) {
    try {
      operations.deleteAll();
      return true;
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return false;
    }
  }
  final AtomicBoolean aOk=new AtomicBoolean(true);
  final Set<ByteArrayId> queriedAdapters=new HashSet<ByteArrayId>();
  try {
    for (    final Pair<PrimaryIndex,List<DataAdapter<Object>>> indexAdapterPair : queryOptions.getIndicesForAdapters(adapterStore,indexMappingStore,indexStore)) {
      final PrimaryIndex index=indexAdapterPair.getLeft();
      final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
      final String altIdxTableName=tableName + HBaseUtils.ALT_INDEX_TABLE;
      final boolean useAltIndex=options.isUseAltIndex() && operations.tableExists(altIdxTableName);
      final HBaseWriter idxDeleter=operations.createWriter(tableName,""String_Node_Str"",false);
      final HBaseWriter altIdxDelete=useAltIndex ? operations.createWriter(altIdxTableName,""String_Node_Str"",false) : null;
      for (      final DataAdapter<Object> adapter : indexAdapterPair.getRight()) {
        final DataStoreCallbackManager callbackCache=new DataStoreCallbackManager(statisticsStore,secondaryIndexDataStore,queriedAdapters.add(adapter.getAdapterId()));
        callbackCache.setPersistStats(options.isPersistDataStatistics());
        if (query instanceof EverythingQuery) {
          deleteEntries(adapter,index,queryOptions.getAuthorizations());
          continue;
        }
        final ScanCallback<Object> callback=new ScanCallback<Object>(){
          @Override public void entryScanned(          final DataStoreEntryInfo entryInfo,          final Object entry){
            callbackCache.getDeleteCallback((WritableDataAdapter<Object>)adapter,index).entryDeleted(entryInfo,entry);
            try {
              addToBatch(idxDeleter,entryInfo.getRowIds());
              if (altIdxDelete != null) {
                addToBatch(altIdxDelete,Collections.singletonList(adapter.getDataId(entry)));
              }
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              aOk.set(false);
            }
          }
        }
;
        CloseableIterator<?> dataIt=null;
        if (query instanceof RowIdQuery) {
          final HBaseRowIdsQuery<Object> q=new HBaseRowIdsQuery<Object>(adapter,index,((RowIdQuery)query).getRowIds(),callback,null,queryOptions.getAuthorizations());
          dataIt=q.query(operations,adapterStore,-1);
        }
 else         if (query instanceof DataIdQuery) {
          final DataIdQuery idQuery=(DataIdQuery)query;
          dataIt=getEntries(index,idQuery.getDataIds(),adapter,null,callback,queryOptions.getAuthorizations(),null,false);
        }
 else         if (query instanceof PrefixIdQuery) {
        }
 else {
          dataIt=new HBaseConstraintsQuery(Collections.singletonList(adapter.getAdapterId()),index,query,null,callback,null,queryOptions.getAuthorizations()).query(operations,adapterStore,null);
        }
        if (dataIt != null) {
          while (dataIt.hasNext()) {
            dataIt.next();
          }
          try {
            dataIt.close();
          }
 catch (          final Exception ex) {
            LOGGER.warn(""String_Node_Str"",ex);
          }
        }
        callbackCache.close();
      }
      if (altIdxDelete != null) {
        altIdxDelete.close();
      }
      idxDeleter.close();
    }
    return aOk.get();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + query.toString(),e);
    return false;
  }
}",0.9992014905509716
113064,"@Override public DataStore createStore(final Map<String,Object> configOptions,final String namespace){
  return new HBaseDataStore(GeoWaveStoreFinder.createIndexStore(configOptions,namespace),GeoWaveStoreFinder.createAdapterStore(configOptions,namespace),GeoWaveStoreFinder.createDataStatisticsStore(configOptions,namespace),GeoWaveStoreFinder.createAdapterIndexMappingStore(configOptions,namespace),GeoWaveStoreFinder.createSecondaryIndexDataStore(configOptions,namespace),createOperations(configOptions,namespace));
}","@Override public DataStore createStore(final StoreFactoryOptions options){
  if (!(options instanceof HBaseRequiredOptions)) {
    throw new AssertionError(""String_Node_Str"" + HBaseRequiredOptions.class.getSimpleName());
  }
  final HBaseRequiredOptions opts=(HBaseRequiredOptions)options;
  if (opts.getAdditionalOptions() == null) {
    opts.setAdditionalOptions(new HBaseOptions());
  }
  final BasicHBaseOperations hbaseOperations=createOperations(opts);
  return new HBaseDataStore(new HBaseIndexStore(hbaseOperations),new HBaseAdapterStore(hbaseOperations),new HBaseDataStatisticsStore(hbaseOperations),new HBaseAdapterIndexMappingStore(hbaseOperations),new HBaseSecondaryIndexDataStore(hbaseOperations,opts.getAdditionalOptions()),hbaseOperations,opts.getAdditionalOptions());
}",0.2039877300613496
113065,"private synchronized void ensureOpen(){
  if (writer == null) {
    try {
      writer=operations.createWriter(StringUtils.stringFromBinary(index.getId().getBytes()),adapter.getAdapterId().getString(),options.createTable);
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}","private synchronized void ensureOpen(){
  if (writer == null) {
    try {
      writer=operations.createWriter(StringUtils.stringFromBinary(index.getId().getBytes()),adapter.getAdapterId().getString(),options.isCreateTable());
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}",0.9905660377358492
113066,"@Override public SecondaryIndexDataStore createStore(final Map<String,Object> configOptions,final String namespace){
  return new HBaseSecondaryIndexDataStore(createOperations(configOptions,namespace),new HBaseOptions());
}","@Override public SecondaryIndexDataStore createStore(final StoreFactoryOptions options){
  if (!(options instanceof HBaseRequiredOptions)) {
    throw new AssertionError(""String_Node_Str"" + HBaseRequiredOptions.class.getSimpleName());
  }
  final HBaseRequiredOptions opts=(HBaseRequiredOptions)options;
  if (opts.getAdditionalOptions() == null) {
    opts.setAdditionalOptions(new HBaseOptions());
  }
  return new HBaseSecondaryIndexDataStore(createOperations(opts),opts.getAdditionalOptions());
}",0.3374827109266943
113067,"@Override public AdapterIndexMappingStore createStore(final Map<String,Object> configOptions,final String namespace){
  return new HBaseAdapterIndexMappingStore(createOperations(configOptions,namespace));
}","@Override public AdapterIndexMappingStore createStore(final StoreFactoryOptions options){
  if (!(options instanceof HBaseRequiredOptions)) {
    throw new AssertionError(""String_Node_Str"" + HBaseRequiredOptions.class.getSimpleName());
  }
  final HBaseRequiredOptions opts=(HBaseRequiredOptions)options;
  if (opts.getAdditionalOptions() == null) {
    opts.setAdditionalOptions(new HBaseOptions());
  }
  return new HBaseAdapterIndexMappingStore(createOperations(opts));
}",0.4
113068,"@Override public AdapterStore createStore(final Map<String,Object> configOptions,final String namespace){
  return new HBaseAdapterStore(createOperations(configOptions,namespace));
}","@Override public AdapterStore createStore(final StoreFactoryOptions options){
  if (!(options instanceof HBaseRequiredOptions)) {
    throw new AssertionError(""String_Node_Str"" + HBaseRequiredOptions.class.getSimpleName());
  }
  final HBaseRequiredOptions opts=(HBaseRequiredOptions)options;
  return new HBaseAdapterStore(createOperations(opts));
}",0.4135338345864661
113069,"@Override public DataStatisticsStore createStore(final Map<String,Object> configOptions,final String namespace){
  return new HBaseDataStatisticsStore(createOperations(configOptions,namespace));
}","@Override public DataStatisticsStore createStore(final StoreFactoryOptions options){
  if (!(options instanceof HBaseRequiredOptions)) {
    throw new AssertionError(""String_Node_Str"" + HBaseRequiredOptions.class.getSimpleName());
  }
  final HBaseRequiredOptions opts=(HBaseRequiredOptions)options;
  return new HBaseDataStatisticsStore(createOperations(opts));
}",0.4428571428571428
113070,"public static void printVersionInfo(){
  final File buildPropertiesFile=getBuildPropertiesFile();
  if (buildPropertiesFile != null) {
    try (Scanner scanner=new Scanner(buildPropertiesFile,ConfigOptions.CHARSET)){
      while (scanner.hasNextLine()) {
        final String line=scanner.nextLine();
        JCommander.getConsole().println(line);
      }
      scanner.close();
    }
 catch (    final IOException e) {
      JCommander.getConsole().print(""String_Node_Str"" + e.getMessage());
    }
  }
 else {
    JCommander.getConsole().print(""String_Node_Str"");
  }
}","public static void printVersionInfo(){
  final List<String> buildAndPropertyList=Arrays.asList(getBuildProperties().toString().split(""String_Node_Str""));
  if (buildAndPropertyList != null) {
    Collections.sort(buildAndPropertyList.subList(1,buildAndPropertyList.size()));
    for (    String str : buildAndPropertyList) {
      JCommander.getConsole().println(str);
    }
  }
 else {
    JCommander.getConsole().println(""String_Node_Str"");
  }
}",0.4223968565815324
113071,"protected ScannerBase getScanner(final AccumuloOperations accumuloOperations,final double[] maxResolutionSubsamplingPerDimension,final Integer limit){
  final List<ByteArrayRange> ranges=getRanges();
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  ScannerBase scanner;
  try {
    if ((ranges != null) && (ranges.size() == 1)) {
      scanner=accumuloOperations.createScanner(tableName,getAdditionalAuthorizations());
      final ByteArrayRange r=ranges.get(0);
      if (r.isSingleValue()) {
        ((Scanner)scanner).setRange(Range.exact(new Text(r.getStart().getBytes())));
      }
 else {
        ((Scanner)scanner).setRange(AccumuloUtils.byteArrayRangeToAccumuloRange(r));
      }
      if ((limit != null) && (limit > 0) && (limit < ((Scanner)scanner).getBatchSize())) {
        ((Scanner)scanner).setBatchSize(Math.min(1024,limit));
      }
      if (maxResolutionSubsamplingPerDimension != null) {
        if (maxResolutionSubsamplingPerDimension.length != index.getIndexStrategy().getOrderedDimensionDefinitions().length) {
          LOGGER.warn(""String_Node_Str"" + tableName + ""String_Node_Str""+ maxResolutionSubsamplingPerDimension.length+ ""String_Node_Str""+ index.getIndexStrategy().getOrderedDimensionDefinitions().length);
        }
 else {
          final int cardinalityToSubsample=(int)Math.round(IndexUtils.getDimensionalBitsUsed(index.getIndexStrategy(),maxResolutionSubsamplingPerDimension) + (8 * index.getIndexStrategy().getByteOffsetFromDimensionalIndex()));
          final IteratorSetting iteratorSettings=new IteratorSetting(FixedCardinalitySkippingIterator.CARDINALITY_SKIPPING_ITERATOR_PRIORITY,FixedCardinalitySkippingIterator.CARDINALITY_SKIPPING_ITERATOR_NAME,FixedCardinalitySkippingIterator.class);
          iteratorSettings.addOption(FixedCardinalitySkippingIterator.CARDINALITY_SKIP_INTERVAL,Integer.toString(cardinalityToSubsample));
          scanner.addScanIterator(iteratorSettings);
        }
      }
    }
 else {
      scanner=accumuloOperations.createBatchScanner(tableName,getAdditionalAuthorizations());
      ((BatchScanner)scanner).setRanges(AccumuloUtils.byteArrayRangesToAccumuloRanges(ranges));
    }
  }
 catch (  final TableNotFoundException e) {
    LOGGER.warn(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
    return null;
  }
  if ((adapterIds != null) && !adapterIds.isEmpty()) {
    for (    final ByteArrayId adapterId : adapterIds) {
      scanner.fetchColumnFamily(new Text(adapterId.getBytes()));
    }
  }
  return scanner;
}","protected ScannerBase getScanner(final AccumuloOperations accumuloOperations,final double[] maxResolutionSubsamplingPerDimension,final Integer limit){
  final List<ByteArrayRange> ranges=getRanges();
  final String tableName=StringUtils.stringFromBinary(index.getId().getBytes());
  ScannerBase scanner;
  try {
    if ((ranges != null) && (ranges.size() == 1)) {
      scanner=accumuloOperations.createScanner(tableName,getAdditionalAuthorizations());
      final ByteArrayRange r=ranges.get(0);
      if (r.isSingleValue()) {
        ((Scanner)scanner).setRange(Range.exact(new Text(r.getStart().getBytes())));
      }
 else {
        ((Scanner)scanner).setRange(AccumuloUtils.byteArrayRangeToAccumuloRange(r));
      }
      if ((limit != null) && (limit > 0) && (limit < ((Scanner)scanner).getBatchSize())) {
        ((Scanner)scanner).setBatchSize(Math.min(1024,limit));
      }
    }
 else {
      scanner=accumuloOperations.createBatchScanner(tableName,getAdditionalAuthorizations());
      ((BatchScanner)scanner).setRanges(AccumuloUtils.byteArrayRangesToAccumuloRanges(ranges));
    }
    if (maxResolutionSubsamplingPerDimension != null) {
      if (maxResolutionSubsamplingPerDimension.length != index.getIndexStrategy().getOrderedDimensionDefinitions().length) {
        LOGGER.warn(""String_Node_Str"" + tableName + ""String_Node_Str""+ maxResolutionSubsamplingPerDimension.length+ ""String_Node_Str""+ index.getIndexStrategy().getOrderedDimensionDefinitions().length);
      }
 else {
        final int cardinalityToSubsample=(int)Math.round(IndexUtils.getDimensionalBitsUsed(index.getIndexStrategy(),maxResolutionSubsamplingPerDimension) + (8 * index.getIndexStrategy().getByteOffsetFromDimensionalIndex()));
        final IteratorSetting iteratorSettings=new IteratorSetting(FixedCardinalitySkippingIterator.CARDINALITY_SKIPPING_ITERATOR_PRIORITY,FixedCardinalitySkippingIterator.CARDINALITY_SKIPPING_ITERATOR_NAME,FixedCardinalitySkippingIterator.class);
        iteratorSettings.addOption(FixedCardinalitySkippingIterator.CARDINALITY_SKIP_INTERVAL,Integer.toString(cardinalityToSubsample));
        scanner.addScanIterator(iteratorSettings);
      }
    }
  }
 catch (  final TableNotFoundException e) {
    LOGGER.warn(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
    return null;
  }
  if ((adapterIds != null) && !adapterIds.isEmpty()) {
    for (    final ByteArrayId adapterId : adapterIds) {
      scanner.fetchColumnFamily(new Text(adapterId.getBytes()));
    }
  }
  return scanner;
}",0.9135949266745936
113072,"@Test public void testExamplesIngest() throws IOException, SchemaException, URISyntaxException {
  BasicAccumuloOperations bao=null;
  try {
    bao=new BasicAccumuloOperations(zookeeper,accumuloInstance,accumuloUser,accumuloPassword,TEST_NAMESPACE);
  }
 catch (  final AccumuloException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
catch (  final AccumuloSecurityException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
  final AccumuloDataStore ds=new AccumuloDataStore(bao);
  final SimpleFeatureType sft=SimpleIngest.createPointFeatureType();
  final PrimaryIndex idx=SimpleIngest.createSpatialIndex();
  final FeatureDataAdapter fda=SimpleIngest.createDataAdapter(sft);
  final List<SimpleFeature> features=SimpleIngest.getGriddedFeatures(new SimpleFeatureBuilder(sft),8675309);
  LOGGER.info(String.format(""String_Node_Str"",features.size()));
  int ingestedFeatures=0;
  final int featuresPer5Percent=features.size() / 20;
  try (IndexWriter writer=ds.createIndexWriter(idx,DataStoreUtils.DEFAULT_VISIBILITY)){
    for (    final SimpleFeature feat : features) {
      writer.write(fda,feat);
      ingestedFeatures++;
      if ((ingestedFeatures % featuresPer5Percent) == 0) {
        LOGGER.info(String.format(""String_Node_Str"",(ingestedFeatures / featuresPer5Percent) * 5));
      }
    }
  }
   Assert.assertTrue(geoserverServiceClient.createWorkspace(WORKSPACE));
  Assert.assertTrue(geoserverServiceClient.publishDatastore(new AccumuloStoreFactoryFamily().getName(),getAccumuloConfig(),TEST_NAMESPACE,null,null,null,null,WORKSPACE));
  Assert.assertTrue(geoserverServiceClient.publishLayer(TEST_NAMESPACE,""String_Node_Str"",SimpleIngest.FEATURE_NAME,WORKSPACE));
  final BufferedImage bi=getWMSSingleTile(-180,180,-90,90,""String_Node_Str"",""String_Node_Str"",920,360,null);
  BufferedImage ref=null;
  final String geoserverVersion=(System.getProperty(""String_Node_Str"") != null) ? System.getProperty(""String_Node_Str"") : ""String_Node_Str"";
  Assert.assertNotNull(geoserverVersion);
  if (geoserverVersion.startsWith(""String_Node_Str"") || geoserverVersion.equals(""String_Node_Str"") || geoserverVersion.equals(""String_Node_Str"")) {
    ref=ImageIO.read(new File(REFERENCE_25_WMS_IMAGE_PATH));
  }
 else {
    ref=ImageIO.read(new File(REFERENCE_26_WMS_IMAGE_PATH));
  }
  Assert.assertNotNull(ref);
  Assert.assertEquals(ref.getWidth(),bi.getWidth());
  Assert.assertEquals(ref.getHeight(),bi.getHeight());
  for (int x=0; x < ref.getWidth(); x++) {
    for (int y=0; y < ref.getHeight(); y++) {
      if (!(bi.getRGB(x,y) == ref.getRGB(x,y))) {
        Assert.fail(String.format(""String_Node_Str"",x,y,ref.getRGB(x,y),bi.getRGB(x,y)));
      }
    }
  }
}","@Test public void testExamplesIngest() throws IOException, SchemaException, URISyntaxException {
  BasicAccumuloOperations bao=null;
  try {
    bao=new BasicAccumuloOperations(zookeeper,accumuloInstance,accumuloUser,accumuloPassword,TEST_NAMESPACE);
  }
 catch (  final AccumuloException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
catch (  final AccumuloSecurityException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
  final AccumuloDataStore ds=new AccumuloDataStore(bao);
  final SimpleFeatureType sft=SimpleIngest.createPointFeatureType();
  final PrimaryIndex idx=SimpleIngest.createSpatialIndex();
  final FeatureDataAdapter fda=SimpleIngest.createDataAdapter(sft);
  final List<SimpleFeature> features=SimpleIngest.getGriddedFeatures(new SimpleFeatureBuilder(sft),8675309);
  LOGGER.info(String.format(""String_Node_Str"",features.size()));
  int ingestedFeatures=0;
  final int featuresPer5Percent=features.size() / 20;
  try (IndexWriter writer=ds.createIndexWriter(idx,DataStoreUtils.DEFAULT_VISIBILITY)){
    for (    final SimpleFeature feat : features) {
      writer.write(fda,feat);
      ingestedFeatures++;
      if ((ingestedFeatures % featuresPer5Percent) == 0) {
        LOGGER.info(String.format(""String_Node_Str"",(ingestedFeatures / featuresPer5Percent) * 5));
      }
    }
  }
   Assert.assertTrue(""String_Node_Str"",geoserverServiceClient.createWorkspace(WORKSPACE));
  Assert.assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(new AccumuloStoreFactoryFamily().getName(),getAccumuloConfig(),TEST_NAMESPACE,null,null,null,null,WORKSPACE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + TEST_SLD_MINOR_SUBSAMPLE_FILE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  assertTrue(""String_Node_Str"" + TEST_SLD_MAJOR_SUBSAMPLE_FILE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(TEST_SLD_MAJOR_SUBSAMPLE_FILE)}));
  Assert.assertTrue(""String_Node_Str"" + SimpleIngest.FEATURE_NAME + ""String_Node_Str"",geoserverServiceClient.publishLayer(TEST_NAMESPACE,""String_Node_Str"",SimpleIngest.FEATURE_NAME,WORKSPACE));
  final BufferedImage biDirectRender=getWMSSingleTile(-180,180,-90,90,SimpleIngest.FEATURE_NAME,""String_Node_Str"",920,360,null);
  BufferedImage ref=null;
  final String geoserverVersion=(System.getProperty(""String_Node_Str"") != null) ? System.getProperty(""String_Node_Str"") : ""String_Node_Str"";
  Assert.assertNotNull(geoserverVersion);
  if (geoserverVersion.startsWith(""String_Node_Str"") || geoserverVersion.equals(""String_Node_Str"") || geoserverVersion.equals(""String_Node_Str"")) {
    ref=ImageIO.read(new File(REFERENCE_25_WMS_IMAGE_PATH));
  }
 else {
    ref=ImageIO.read(new File(REFERENCE_26_WMS_IMAGE_PATH));
  }
  testTileAgainstReference(biDirectRender,ref,0,0);
  final BufferedImage biSubsamplingWithoutError=getWMSSingleTile(-180,180,-90,90,SimpleIngest.FEATURE_NAME,TEST_STYLE_NAME_NO_DIFFERENCE,920,360,null);
  Assert.assertNotNull(ref);
  testTileAgainstReference(biSubsamplingWithoutError,ref,0,0);
  final BufferedImage biSubsamplingWithExpectedError=getWMSSingleTile(-180,180,-90,90,SimpleIngest.FEATURE_NAME,TEST_STYLE_NAME_MINOR_SUBSAMPLE,920,360,null);
  testTileAgainstReference(biSubsamplingWithExpectedError,ref,0.05,0.1);
  final BufferedImage biSubsamplingWithLotsOfError=getWMSSingleTile(-180,180,-90,90,SimpleIngest.FEATURE_NAME,TEST_STYLE_NAME_MAJOR_SUBSAMPLE,920,360,null);
  testTileAgainstReference(biSubsamplingWithLotsOfError,ref,0.3,0.35);
  assertTrue(""String_Node_Str"" + SimpleIngest.FEATURE_NAME + ""String_Node_Str"",geoserverServiceClient.deleteLayer(SimpleIngest.FEATURE_NAME));
  assertTrue(""String_Node_Str"" + TEST_NAMESPACE + ""String_Node_Str"",geoserverServiceClient.deleteDatastore(TEST_NAMESPACE,WORKSPACE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"" + TEST_STYLE_NAME_MAJOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(TEST_STYLE_NAME_MAJOR_SUBSAMPLE));
}",0.6542916957431961
113073,"public IngestTask(LocalIngestRunData runData,Map<ByteArrayId,PrimaryIndex> specifiedPrimaryIndexes,Map<ByteArrayId,PrimaryIndex> requiredIndexMap,BlockingQueue<GeoWaveData<?>> queue){
  this.runData=runData;
  this.specifiedPrimaryIndexes=specifiedPrimaryIndexes;
  this.requiredIndexMap=requiredIndexMap;
  this.readQueue=queue;
}","public IngestTask(String id,LocalIngestRunData runData,Map<ByteArrayId,PrimaryIndex> specifiedPrimaryIndexes,Map<ByteArrayId,PrimaryIndex> requiredIndexMap,BlockingQueue<GeoWaveData<?>> queue){
  this.id=id;
  this.runData=runData;
  this.specifiedPrimaryIndexes=specifiedPrimaryIndexes;
  this.requiredIndexMap=requiredIndexMap;
  this.readQueue=queue;
}",0.9650145772594751
113074,"/** 
 * This function will continue to read from the BlockingQueue until isTerminated is true and the queue is empty.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void run(){
  Map<PrimaryIndex,IndexWriter> indexWriters=new HashMap<PrimaryIndex,IndexWriter>();
  try {
    LOGGER.debug(""String_Node_Str"");
    while (true) {
      GeoWaveData<?> geowaveData=readQueue.poll(100,TimeUnit.MILLISECONDS);
      if (geowaveData == null) {
        if (isTerminated && readQueue.size() == 0) {
          break;
        }
        continue;
      }
      final WritableDataAdapter adapter=runData.getDataAdapter(geowaveData);
      if (adapter == null) {
        LOGGER.warn(""String_Node_Str"" + geowaveData.getValue());
        continue;
      }
      for (      final ByteArrayId indexId : geowaveData.getIndexIds()) {
        PrimaryIndex index=specifiedPrimaryIndexes.get(indexId);
        if (index == null) {
          index=requiredIndexMap.get(indexId);
          if (index == null) {
            LOGGER.warn(""String_Node_Str"" + indexId.getString() + ""String_Node_Str""+ geowaveData.getValue());
            continue;
          }
        }
        if (!indexWriters.containsKey(index)) {
          indexWriters.put(index,runData.getIndexWriter(index));
        }
        IndexWriter writer=indexWriters.get(index);
        writer.write(adapter,geowaveData.getValue());
      }
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
 finally {
    for (    Entry<PrimaryIndex,IndexWriter> writerEntry : indexWriters.entrySet()) {
      try {
        runData.releaseIndexWriter(writerEntry.getKey(),writerEntry.getValue());
      }
 catch (      Exception e) {
        LOGGER.warn(String.format(""String_Node_Str"",writerEntry.getKey()),e);
      }
    }
    LOGGER.debug(""String_Node_Str"");
  }
}","/** 
 * This function will continue to read from the BlockingQueue until isTerminated is true and the queue is empty.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void run(){
  Map<PrimaryIndex,IndexWriter> indexWriters=new HashMap<PrimaryIndex,IndexWriter>();
  int count=0;
  try {
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(String.format(""String_Node_Str"",this.getId()));
    }
    while (true) {
      GeoWaveData<?> geowaveData=readQueue.poll(100,TimeUnit.MILLISECONDS);
      if (geowaveData == null) {
        if (isTerminated && readQueue.size() == 0) {
          break;
        }
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug(String.format(""String_Node_Str"",this.getId()));
        }
        continue;
      }
      final WritableDataAdapter adapter=runData.getDataAdapter(geowaveData);
      if (adapter == null) {
        LOGGER.warn(String.format(""String_Node_Str"",geowaveData.getValue(),this.getId()));
        continue;
      }
      for (      final ByteArrayId indexId : geowaveData.getIndexIds()) {
        PrimaryIndex index=specifiedPrimaryIndexes.get(indexId);
        if (index == null) {
          index=requiredIndexMap.get(indexId);
          if (index == null) {
            LOGGER.warn(String.format(""String_Node_Str"",indexId.getString(),geowaveData.getValue(),this.getId()));
            continue;
          }
        }
        if (!indexWriters.containsKey(index)) {
          indexWriters.put(index,runData.getIndexWriter(index));
        }
        IndexWriter writer=indexWriters.get(index);
        writer.write(adapter,geowaveData.getValue());
        count++;
      }
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
 finally {
    for (    Entry<PrimaryIndex,IndexWriter> writerEntry : indexWriters.entrySet()) {
      try {
        runData.releaseIndexWriter(writerEntry.getKey(),writerEntry.getValue());
      }
 catch (      Exception e) {
        LOGGER.warn(String.format(""String_Node_Str"",writerEntry.getKey()),e);
      }
    }
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(String.format(""String_Node_Str"",this.getId(),count));
    }
    isFinished=true;
  }
}",0.2713253012048193
113075,"@Override protected void processFile(final File file,final String typeName,final LocalFileIngestPlugin<?> plugin,final LocalIngestRunData ingestRunData) throws IOException {
  LOGGER.info(String.format(""String_Node_Str"",file.getName()));
  final String[] dimensionTypes=ingestOptions.getDimensionalityTypes();
  final Map<ByteArrayId,PrimaryIndex> specifiedPrimaryIndexes=new HashMap<ByteArrayId,PrimaryIndex>();
  for (  final String dimensionType : dimensionTypes) {
    final PrimaryIndex primaryIndex=IngestUtils.getIndex(plugin,ingestRunData.getArgs(),dimensionType);
    if (primaryIndex == null) {
      LOGGER.error(""String_Node_Str"");
      throw new IOException(""String_Node_Str"");
    }
    specifiedPrimaryIndexes.put(primaryIndex.getId(),primaryIndex);
  }
  final Map<ByteArrayId,PrimaryIndex> requiredIndexMap=new HashMap<ByteArrayId,PrimaryIndex>();
  final PrimaryIndex[] requiredIndices=plugin.getRequiredIndices();
  if ((requiredIndices != null) && (requiredIndices.length > 0)) {
    for (    final PrimaryIndex requiredIndex : requiredIndices) {
      requiredIndexMap.put(requiredIndex.getId(),requiredIndex);
    }
  }
  BlockingQueue<GeoWaveData<?>> queue=LocalIngestRunData.createBlockingQueue(INGEST_BATCH_SIZE);
  LOGGER.debug(String.format(""String_Node_Str"",localInput.getThreads(),file.getName()));
  List<IngestTask> ingestTasks=new ArrayList<IngestTask>();
  try {
    for (int i=0; i < localInput.getThreads(); i++) {
      IngestTask task=new IngestTask(ingestRunData,specifiedPrimaryIndexes,requiredIndexMap,queue);
      ingestTasks.add(task);
      ingestExecutor.submit(task);
    }
    try (CloseableIterator<?> geowaveDataIt=plugin.toGeoWaveData(file,specifiedPrimaryIndexes.keySet(),ingestOptions.getVisibility())){
      while (geowaveDataIt.hasNext()) {
        final GeoWaveData<?> geowaveData=(GeoWaveData<?>)geowaveDataIt.next();
        try {
          queue.put(geowaveData);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(""String_Node_Str"");
        }
      }
    }
   }
  finally {
    for (    IngestTask task : ingestTasks) {
      task.terminate();
    }
  }
  LOGGER.info(String.format(""String_Node_Str"",file.getName()));
}","@Override protected void processFile(final File file,final String typeName,final LocalFileIngestPlugin<?> plugin,final LocalIngestRunData ingestRunData) throws IOException {
  LOGGER.info(String.format(""String_Node_Str"",file.getName()));
  final String[] dimensionTypes=ingestOptions.getDimensionalityTypes();
  final Map<ByteArrayId,PrimaryIndex> specifiedPrimaryIndexes=new HashMap<ByteArrayId,PrimaryIndex>();
  for (  final String dimensionType : dimensionTypes) {
    final PrimaryIndex primaryIndex=IngestUtils.getIndex(plugin,ingestRunData.getArgs(),dimensionType);
    if (primaryIndex == null) {
      LOGGER.error(""String_Node_Str"");
      throw new IOException(""String_Node_Str"");
    }
    specifiedPrimaryIndexes.put(primaryIndex.getId(),primaryIndex);
  }
  final Map<ByteArrayId,PrimaryIndex> requiredIndexMap=new HashMap<ByteArrayId,PrimaryIndex>();
  final PrimaryIndex[] requiredIndices=plugin.getRequiredIndices();
  if ((requiredIndices != null) && (requiredIndices.length > 0)) {
    for (    final PrimaryIndex requiredIndex : requiredIndices) {
      requiredIndexMap.put(requiredIndex.getId(),requiredIndex);
    }
  }
  BlockingQueue<GeoWaveData<?>> queue=LocalIngestRunData.createBlockingQueue(INGEST_BATCH_SIZE);
  LOGGER.debug(String.format(""String_Node_Str"",localInput.getThreads(),file.getName()));
  List<IngestTask> ingestTasks=new ArrayList<IngestTask>();
  try {
    for (int i=0; i < localInput.getThreads(); i++) {
      String id=String.format(""String_Node_Str"",file.getName(),i);
      IngestTask task=new IngestTask(id,ingestRunData,specifiedPrimaryIndexes,requiredIndexMap,queue);
      ingestTasks.add(task);
      ingestExecutor.submit(task);
    }
    try (CloseableIterator<?> geowaveDataIt=plugin.toGeoWaveData(file,specifiedPrimaryIndexes.keySet(),ingestOptions.getVisibility())){
      while (geowaveDataIt.hasNext()) {
        final GeoWaveData<?> geowaveData=(GeoWaveData<?>)geowaveDataIt.next();
        try {
          while (!queue.offer(geowaveData,1,TimeUnit.SECONDS)) {
            boolean workerAlive=false;
            for (            IngestTask task : ingestTasks) {
              if (!task.isFinished()) {
                workerAlive=true;
                break;
              }
            }
            if (workerAlive) {
              LOGGER.debug(""String_Node_Str"");
            }
 else {
              String message=""String_Node_Str"";
              LOGGER.error(message);
              throw new RuntimeException(message);
            }
          }
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(""String_Node_Str"");
        }
      }
    }
   }
  finally {
    for (    IngestTask task : ingestTasks) {
      task.terminate();
    }
  }
  LOGGER.info(String.format(""String_Node_Str"",file.getName()));
}",0.7918075164048518
113076,"@BeforeClass public static void setup() throws IOException {
synchronized (MUTEX) {
    TimeZone.setDefault(TimeZone.getTimeZone(""String_Node_Str""));
    if (accumuloOperations == null) {
      zookeeper=System.getProperty(""String_Node_Str"");
      accumuloInstance=System.getProperty(""String_Node_Str"");
      accumuloUser=System.getProperty(""String_Node_Str"");
      accumuloPassword=System.getProperty(""String_Node_Str"");
      if (!isSet(zookeeper) || !isSet(accumuloInstance) || !isSet(accumuloUser)|| !isSet(accumuloPassword)) {
        try {
          if (!TEMP_DIR.exists()) {
            if (!TEMP_DIR.mkdirs()) {
              throw new IOException(""String_Node_Str"");
            }
          }
          TEMP_DIR.deleteOnExit();
          final MiniAccumuloConfigImpl config=new MiniAccumuloConfigImpl(TEMP_DIR,DEFAULT_MINI_ACCUMULO_PASSWORD);
          config.setNumTservers(2);
          miniAccumulo=MiniAccumuloClusterFactory.newAccumuloCluster(config,GeoWaveTestEnvironment.class);
          if (SystemUtils.IS_OS_WINDOWS && isYarn()) {
            LOGGER.info(""String_Node_Str"");
            LOGGER.info(""String_Node_Str"");
            final Map<String,String> env=System.getenv();
            String hadoopHome=System.getProperty(""String_Node_Str"");
            if (hadoopHome == null) {
              hadoopHome=env.get(""String_Node_Str"");
            }
            boolean success=false;
            if (hadoopHome != null) {
              final File hadoopDir=new File(hadoopHome);
              if (hadoopDir.exists()) {
                final File binDir=new File(TEMP_DIR,""String_Node_Str"");
                if (binDir.mkdir()) {
                  FileUtils.copyFile(new File(hadoopDir + File.separator + ""String_Node_Str"",HADOOP_WINDOWS_UTIL),new File(binDir,HADOOP_WINDOWS_UTIL));
                  success=true;
                }
 else {
                  final String[] r=binDir.list(new FilenameFilter(){
                    @Override public boolean accept(                    File arg0,                    String arg1){
                      return arg1.equals(HADOOP_WINDOWS_UTIL);
                    }
                  }
);
                  success=r != null && r.length > 0;
                }
              }
            }
            if (!success) {
              LOGGER.error(""String_Node_Str"");
              return;
            }
          }
          miniAccumulo.start();
          zookeeper=miniAccumulo.getZooKeepers();
          accumuloInstance=miniAccumulo.getInstanceName();
          accumuloUser=""String_Node_Str"";
          accumuloPassword=DEFAULT_MINI_ACCUMULO_PASSWORD;
        }
 catch (        IOException|InterruptedException e) {
          LOGGER.warn(""String_Node_Str"",e);
          LOGGER.info(""String_Node_Str"" + TEMP_DIR.getAbsolutePath() + File.separator+ ""String_Node_Str"");
          if (SystemUtils.IS_OS_WINDOWS) {
            LOGGER.warn(""String_Node_Str"");
          }
          Assert.fail(""String_Node_Str"" + e.getLocalizedMessage() + ""String_Node_Str"");
        }
      }
      try {
        accumuloOperations=new BasicAccumuloOperations(zookeeper,accumuloInstance,accumuloUser,accumuloPassword,TEST_NAMESPACE);
      }
 catch (      AccumuloException|AccumuloSecurityException e) {
        LOGGER.warn(""String_Node_Str"",e);
        Assert.fail(""String_Node_Str"" + e.getLocalizedMessage() + ""String_Node_Str"");
      }
    }
  }
}","@BeforeClass public static void setup() throws IOException {
synchronized (MUTEX) {
    TimeZone.setDefault(TimeZone.getTimeZone(""String_Node_Str""));
    if (accumuloOperations == null) {
      zookeeper=System.getProperty(""String_Node_Str"");
      accumuloInstance=System.getProperty(""String_Node_Str"");
      accumuloUser=System.getProperty(""String_Node_Str"");
      accumuloPassword=System.getProperty(""String_Node_Str"");
      if (!isSet(zookeeper) || !isSet(accumuloInstance) || !isSet(accumuloUser)|| !isSet(accumuloPassword)) {
        try {
          if (!TEMP_DIR.exists()) {
            if (!TEMP_DIR.mkdirs()) {
              throw new IOException(""String_Node_Str"");
            }
          }
          TEMP_DIR.deleteOnExit();
          final MiniAccumuloConfigImpl config=new MiniAccumuloConfigImpl(TEMP_DIR,DEFAULT_MINI_ACCUMULO_PASSWORD);
          config.setNumTservers(2);
          miniAccumulo=MiniAccumuloClusterFactory.newAccumuloCluster(config,GeoWaveTestEnvironment.class);
          miniAccumulo.start();
          zookeeper=miniAccumulo.getZooKeepers();
          accumuloInstance=miniAccumulo.getInstanceName();
          accumuloUser=""String_Node_Str"";
          accumuloPassword=DEFAULT_MINI_ACCUMULO_PASSWORD;
        }
 catch (        IOException|InterruptedException e) {
          LOGGER.warn(""String_Node_Str"",e);
          LOGGER.info(""String_Node_Str"" + TEMP_DIR.getAbsolutePath() + File.separator+ ""String_Node_Str"");
          if (SystemUtils.IS_OS_WINDOWS) {
            LOGGER.warn(""String_Node_Str"");
          }
          Assert.fail(""String_Node_Str"" + e.getLocalizedMessage() + ""String_Node_Str"");
        }
      }
      try {
        accumuloOperations=new BasicAccumuloOperations(zookeeper,accumuloInstance,accumuloUser,accumuloPassword,TEST_NAMESPACE);
      }
 catch (      AccumuloException|AccumuloSecurityException e) {
        LOGGER.warn(""String_Node_Str"",e);
        Assert.fail(""String_Node_Str"" + e.getLocalizedMessage() + ""String_Node_Str"");
      }
    }
  }
}",0.7448810182623132
113077,"@Override public PrimaryIndex wrapIndexWithOptions(final PrimaryIndex index){
  PrimaryIndex retVal=index;
  if ((options.numPartitions > 1) && !options.partitionStrategy.equals(PartitionStrategy.HASH)) {
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new HashKeyIndexStrategy(index.getIndexStrategy().getOrderedDimensionDefinitions(),options.numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + options.partitionStrategy.name()+ ""String_Node_Str""+ options.numPartitions));
  }
 else   if ((options.numPartitions > 1) && !options.partitionStrategy.equals(PartitionStrategy.ROUND_ROBIN)) {
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new RoundRobinKeyIndexStrategy(options.numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + options.partitionStrategy.name()+ ""String_Node_Str""+ options.numPartitions));
  }
  if ((options.nameOverride != null) && (options.nameOverride.length() > 0)) {
    retVal=new CustomIdIndex(retVal.getIndexStrategy(),retVal.getIndexModel(),new ByteArrayId(options.nameOverride));
  }
  return retVal;
}","@Override public PrimaryIndex wrapIndexWithOptions(final PrimaryIndex index){
  PrimaryIndex retVal=index;
  if ((options.numPartitions > 1) && options.partitionStrategy.equals(PartitionStrategy.HASH)) {
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new HashKeyIndexStrategy(index.getIndexStrategy().getOrderedDimensionDefinitions(),options.numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.HASH.name()+ ""String_Node_Str""+ options.numPartitions));
  }
 else   if (options.numPartitions > 1) {
    if (options.partitionStrategy.equals(PartitionStrategy.NONE)) {
      LOGGER.warn(""String_Node_Str"");
    }
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new RoundRobinKeyIndexStrategy(options.numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.ROUND_ROBIN.name()+ ""String_Node_Str""+ options.numPartitions));
  }
  if ((options.nameOverride != null) && (options.nameOverride.length() > 0)) {
    retVal=new CustomIdIndex(retVal.getIndexStrategy(),retVal.getIndexModel(),new ByteArrayId(options.nameOverride));
  }
  return retVal;
}",0.7446457990115322
113078,"public static final double getDimensionalBitsUsed(final NumericIndexStrategy indexStrategy,final double[] dataRangePerDimension){
  double result=Long.MAX_VALUE;
  if (dataRangePerDimension.length == 0) {
    return 0;
  }
  final double cellRangePerDimension[]=indexStrategy.getHighestPrecisionIdRangePerDimension();
  final double bitsPerDimension[]=getBitsPerDimension(indexStrategy,cellRangePerDimension);
  for (int d=0; d < dataRangePerDimension.length; d++) {
    final double bitsUsed=bitsPerDimension[d] - log2(Math.ceil(dataRangePerDimension[d] / cellRangePerDimension[d]));
    result=Math.min(bitsUsed,result);
  }
  return result * cellRangePerDimension.length;
}","public static final double getDimensionalBitsUsed(final NumericIndexStrategy indexStrategy,final double[] dataRangePerDimension){
  double result=Long.MAX_VALUE;
  if (dataRangePerDimension.length == 0) {
    return 0;
  }
  final double cellRangePerDimension[]=indexStrategy.getHighestPrecisionIdRangePerDimension();
  final double bitsPerDimension[]=getBitsPerDimension(indexStrategy,cellRangePerDimension);
  for (int d=0; d < dataRangePerDimension.length; d++) {
    final double bitsUsed=bitsPerDimension[d] - log2(Math.ceil(dataRangePerDimension[d] / cellRangePerDimension[d]));
    if (bitsUsed <= 0) {
      return 0;
    }
    result=Math.min(bitsUsed,result);
  }
  return result * cellRangePerDimension.length;
}",0.9664045746962115
113079,"public void addRangeVariables(String start,String end){
  validParamRanges.add(new String[]{start,end});
}","public void addRangeVariables(final String start,final String end){
  validParamRanges.add(new String[]{start,end});
}",0.9464285714285714
113080,"/** 
 * Produce an ReferencedEnvelope from the provided data parameter.
 * @param data
 * @return ReferencedEnvelope
 */
private TemporalConstraints btime(final Object data){
  if (data == null) {
    return null;
  }
  if (data instanceof Date) {
    return toSet(new TemporalRange((Date)data,(Date)data));
  }
 else   if (data instanceof Timestamp) {
    return toSet(new TemporalRange((Timestamp)data,(Timestamp)data));
  }
 else   if (data instanceof Number) {
    final long val=((Number)data).longValue();
    return toSet(new TemporalRange(new Date(val),new Date(val)));
  }
 else   if (data instanceof TemporalRange) {
    return toSet((TemporalRange)data);
  }
 else   if (data instanceof TemporalConstraints) {
    return (TemporalConstraints)data;
  }
 else   if (data instanceof Period) {
    final Position beginPosition=((Period)data).getBeginning().getPosition();
    final Position endPosition=((Period)data).getEnding().getPosition();
    Date s=TemporalRange.START_TIME, e=TemporalRange.START_TIME;
    if (beginPosition.getDate() != null) {
      s=beginPosition.getDate();
    }
 else     if (beginPosition.getTime() != null) {
      s=beginPosition.getTime();
    }
    if (endPosition.getDate() != null) {
      e=endPosition.getDate();
    }
 else     if (endPosition.getTime() != null) {
      e=endPosition.getTime();
    }
    return toSet(new TemporalRange(s,e));
  }
 else   if (data instanceof Instant) {
    final Position beginPosition=((Instant)data).getPosition();
    Date s=TemporalRange.START_TIME;
    if (beginPosition.getDate() != null) {
      s=beginPosition.getDate();
    }
 else     if (beginPosition.getTime() != null) {
      s=beginPosition.getTime();
    }
    return toSet(new TemporalRange(s,s));
  }
  return new TemporalConstraints();
}","/** 
 * Produce an ReferencedEnvelope from the provided data parameter.
 * @param data
 * @return ReferencedEnvelope
 */
private TemporalConstraints btime(final Object data){
  if (data == null) {
    return null;
  }
  if (data instanceof Date) {
    return toSet(new TemporalRange((Date)data,(Date)data));
  }
 else   if (data instanceof Timestamp) {
    return toSet(new TemporalRange((Timestamp)data,(Timestamp)data));
  }
 else   if (data instanceof Number) {
    final long val=((Number)data).longValue();
    return toSet(new TemporalRange(new Date(val),new Date(val)));
  }
 else   if (data instanceof TemporalRange) {
    return toSet((TemporalRange)data);
  }
 else   if (data instanceof TemporalConstraints) {
    return (TemporalConstraints)data;
  }
 else   if (data instanceof Period) {
    final Position beginPosition=((Period)data).getBeginning().getPosition();
    final Position endPosition=((Period)data).getEnding().getPosition();
    Date s=TemporalRange.START_TIME, e=TemporalRange.START_TIME;
    if (beginPosition.getDate() != null) {
      s=beginPosition.getDate();
    }
 else     if (beginPosition.getTime() != null) {
      s=beginPosition.getTime();
    }
    if (endPosition.getDate() != null) {
      e=endPosition.getDate();
    }
 else     if (endPosition.getTime() != null) {
      e=endPosition.getTime();
    }
    return toSet(new TemporalRange(s,e));
  }
 else   if (data instanceof Instant) {
    final Position beginPosition=((Instant)data).getPosition();
    Date s=TemporalRange.START_TIME;
    if (beginPosition.getDate() != null) {
      s=beginPosition.getDate();
    }
 else     if (beginPosition.getTime() != null) {
      s=beginPosition.getTime();
    }
    return toSet(new TemporalRange(s,s));
  }
  final Date convertedDate=Converters.convert(data,Date.class);
  if (convertedDate != null) {
    return btime(convertedDate);
  }
  return new TemporalConstraints();
}",0.964401294498382
113081,"@Override protected CloseableIterator<GeoWaveData<SimpleFeature>> toGeoWaveDataInternal(final WholeFile hfile,final Collection<ByteArrayId> primaryIndexIds,final String globalVisibility){
  final List<GeoWaveData<SimpleFeature>> featureData=new ArrayList<GeoWaveData<SimpleFeature>>();
  final InputStream in=new ByteArrayInputStream(hfile.getOriginalFile().array());
  final ZipInputStream zip=new ZipInputStream(in);
  try {
    zip.getNextEntry();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
  final InputStreamReader isr=new InputStreamReader(zip,StringUtils.UTF8_CHAR_SET);
  final BufferedReader br=new BufferedReader(isr);
  final GeometryFactory geometryFactory=new GeometryFactory();
  Date timeStamp=null;
  String timestring=""String_Node_Str"";
  String eventId=""String_Node_Str"";
  int actionGeoType;
  final double lat=0;
  final double lon=0;
  String actor1Name=""String_Node_Str"";
  String actor2Name=""String_Node_Str"";
  String countryCode=""String_Node_Str"";
  String sourceUrl=""String_Node_Str"";
  String actor1CC=""String_Node_Str"";
  String actor2CC=""String_Node_Str"";
  String numMentions=""String_Node_Str"";
  String numSources=""String_Node_Str"";
  String numArticles=""String_Node_Str"";
  String avgTone=""String_Node_Str"";
  String line;
  int lineNumber=0;
  try {
    while ((line=br.readLine()) != null) {
      lineNumber++;
      final String[] vals=line.split(""String_Node_Str"");
      if ((vals.length < GDELTUtils.GDELT_MIN_COLUMNS) || (vals.length > GDELTUtils.GDELT_MAX_COLUMNS)) {
        LOGGER.warn(""String_Node_Str"" + vals.length + ""String_Node_Str""+ lineNumber+ ""String_Node_Str""+ hfile.getOriginalFilePath());
        continue;
      }
      actionGeoType=Integer.parseInt(vals[GDELTUtils.GDELT_ACTION_GEO_TYPE_COLUMN_ID]);
      if (actionGeoType == 0) {
        continue;
      }
      eventId=vals[GDELTUtils.GDELT_EVENT_ID_COLUMN_ID];
      try {
        GDELTUtils.parseLatLon(vals,crs);
      }
 catch (      final Exception e) {
        LOGGER.warn(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ hfile.getOriginalFilePath());
        continue;
      }
      final Coordinate cord=new Coordinate(lat,lon);
      gdeltEventBuilder.set(GDELTUtils.GDELT_GEOMETRY_ATTRIBUTE,geometryFactory.createPoint(cord));
      gdeltEventBuilder.set(GDELTUtils.GDELT_EVENT_ID_ATTRIBUTE,eventId);
      timestring=vals[GDELTUtils.GDELT_TIMESTAMP_COLUMN_ID];
      timeStamp=GDELTUtils.parseDate(timestring);
      gdeltEventBuilder.set(GDELTUtils.GDELT_TIMESTAMP_ATTRIBUTE,timeStamp);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LATITUDE_ATTRIBUTE,lat);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LONGITUDE_ATTRIBUTE,lon);
      actor1Name=vals[GDELTUtils.ACTOR_1_NAME_COLUMN_ID];
      if ((actor1Name != null) && !actor1Name.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTOR_1_NAME_ATTRIBUTE,actor1Name);
      }
      actor2Name=vals[GDELTUtils.ACTOR_2_NAME_COLUMN_ID];
      if ((actor2Name != null) && !actor2Name.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTOR_2_NAME_ATTRIBUTE,actor2Name);
      }
      countryCode=vals[GDELTUtils.ACTION_COUNTRY_CODE_COLUMN_ID];
      if ((countryCode != null) && !countryCode.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTION_COUNTRY_CODE_ATTRIBUTE,countryCode);
      }
      sourceUrl=vals[GDELTUtils.SOURCE_URL_COLUMN_ID];
      if ((sourceUrl != null) && !sourceUrl.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.SOURCE_URL_ATTRIBUTE,sourceUrl);
      }
      if (includeSupplementalFields) {
        actor1CC=vals[GDELTUtils.ACTOR_1_COUNTRY_CODE_COLUMN_ID];
        if ((actor1CC != null) && !actor1CC.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.ACTOR_1_COUNTRY_CODE_ATTRIBUTE,actor1CC);
        }
        actor2CC=vals[GDELTUtils.ACTOR_2_COUNTRY_CODE_COLUMN_ID];
        if ((actor2CC != null) && !actor2CC.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.ACTOR_2_COUNTRY_CODE_ATTRIBUTE,actor2CC);
        }
        numMentions=vals[GDELTUtils.NUM_MENTIONS_COLUMN_ID];
        if ((numMentions != null) && !numMentions.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_MENTIONS_ATTRIBUTE,Integer.parseInt(numMentions));
        }
        numSources=vals[GDELTUtils.NUM_SOURCES_COLUMN_ID];
        if ((numSources != null) && !numSources.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_SOURCES_ATTRIBUTE,Integer.parseInt(numSources));
        }
        numArticles=vals[GDELTUtils.NUM_ARTICLES_COLUMN_ID];
        if ((numArticles != null) && !numArticles.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_ARTICLES_ATTRIBUTE,Integer.parseInt(numArticles));
        }
        avgTone=vals[GDELTUtils.AVG_TONE_COLUMN_ID];
        if ((avgTone != null) && !avgTone.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.AVG_TONE_ATTRIBUTE,Double.parseDouble(avgTone));
        }
      }
      featureData.add(new GeoWaveData<SimpleFeature>(eventKey,primaryIndexIds,gdeltEventBuilder.buildFeature(eventId)));
    }
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
catch (  final ParseException e) {
    LOGGER.error(""String_Node_Str"" + timestring,e);
  }
 finally {
    IOUtils.closeQuietly(br);
    IOUtils.closeQuietly(isr);
    IOUtils.closeQuietly(in);
  }
  return new CloseableIterator.Wrapper<GeoWaveData<SimpleFeature>>(featureData.iterator());
}","@Override protected CloseableIterator<GeoWaveData<SimpleFeature>> toGeoWaveDataInternal(final WholeFile hfile,final Collection<ByteArrayId> primaryIndexIds,final String globalVisibility){
  final List<GeoWaveData<SimpleFeature>> featureData=new ArrayList<GeoWaveData<SimpleFeature>>();
  final InputStream in=new ByteArrayInputStream(hfile.getOriginalFile().array());
  final ZipInputStream zip=new ZipInputStream(in);
  try {
    zip.getNextEntry();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
  final InputStreamReader isr=new InputStreamReader(zip,StringUtils.UTF8_CHAR_SET);
  final BufferedReader br=new BufferedReader(isr);
  final GeometryFactory geometryFactory=new GeometryFactory();
  Date timeStamp=null;
  String timestring=""String_Node_Str"";
  String eventId=""String_Node_Str"";
  int actionGeoType;
  double lat=0;
  double lon=0;
  String actor1Name=""String_Node_Str"";
  String actor2Name=""String_Node_Str"";
  String countryCode=""String_Node_Str"";
  String sourceUrl=""String_Node_Str"";
  String actor1CC=""String_Node_Str"";
  String actor2CC=""String_Node_Str"";
  String numMentions=""String_Node_Str"";
  String numSources=""String_Node_Str"";
  String numArticles=""String_Node_Str"";
  String avgTone=""String_Node_Str"";
  String line;
  int lineNumber=0;
  try {
    while ((line=br.readLine()) != null) {
      lineNumber++;
      final String[] vals=line.split(""String_Node_Str"");
      if ((vals.length < GDELTUtils.GDELT_MIN_COLUMNS) || (vals.length > GDELTUtils.GDELT_MAX_COLUMNS)) {
        LOGGER.warn(""String_Node_Str"" + vals.length + ""String_Node_Str""+ lineNumber+ ""String_Node_Str""+ hfile.getOriginalFilePath());
        continue;
      }
      actionGeoType=Integer.parseInt(vals[GDELTUtils.GDELT_ACTION_GEO_TYPE_COLUMN_ID]);
      if (actionGeoType == 0) {
        continue;
      }
      eventId=vals[GDELTUtils.GDELT_EVENT_ID_COLUMN_ID];
      try {
        final Pair<Double,Double> latLon=GDELTUtils.parseLatLon(vals);
        if (latLon == null) {
          LOGGER.warn(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ hfile.getOriginalFilePath());
          continue;
        }
        lat=latLon.getLeft();
        lon=latLon.getRight();
      }
 catch (      final Exception e) {
        LOGGER.warn(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ hfile.getOriginalFilePath(),e);
        continue;
      }
      final Coordinate cord=new Coordinate(lon,lat);
      gdeltEventBuilder.set(GDELTUtils.GDELT_GEOMETRY_ATTRIBUTE,geometryFactory.createPoint(cord));
      gdeltEventBuilder.set(GDELTUtils.GDELT_EVENT_ID_ATTRIBUTE,eventId);
      timestring=vals[GDELTUtils.GDELT_TIMESTAMP_COLUMN_ID];
      timeStamp=GDELTUtils.parseDate(timestring);
      gdeltEventBuilder.set(GDELTUtils.GDELT_TIMESTAMP_ATTRIBUTE,timeStamp);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LATITUDE_ATTRIBUTE,lat);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LONGITUDE_ATTRIBUTE,lon);
      actor1Name=vals[GDELTUtils.ACTOR_1_NAME_COLUMN_ID];
      if ((actor1Name != null) && !actor1Name.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTOR_1_NAME_ATTRIBUTE,actor1Name);
      }
      actor2Name=vals[GDELTUtils.ACTOR_2_NAME_COLUMN_ID];
      if ((actor2Name != null) && !actor2Name.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTOR_2_NAME_ATTRIBUTE,actor2Name);
      }
      countryCode=vals[GDELTUtils.ACTION_COUNTRY_CODE_COLUMN_ID];
      if ((countryCode != null) && !countryCode.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.ACTION_COUNTRY_CODE_ATTRIBUTE,countryCode);
      }
      if (vals.length > GDELTUtils.SOURCE_URL_COLUMN_ID) {
        sourceUrl=vals[GDELTUtils.SOURCE_URL_COLUMN_ID];
      }
      if ((sourceUrl != null) && !sourceUrl.isEmpty()) {
        gdeltEventBuilder.set(GDELTUtils.SOURCE_URL_ATTRIBUTE,sourceUrl);
      }
      if (includeSupplementalFields) {
        actor1CC=vals[GDELTUtils.ACTOR_1_COUNTRY_CODE_COLUMN_ID];
        if ((actor1CC != null) && !actor1CC.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.ACTOR_1_COUNTRY_CODE_ATTRIBUTE,actor1CC);
        }
        actor2CC=vals[GDELTUtils.ACTOR_2_COUNTRY_CODE_COLUMN_ID];
        if ((actor2CC != null) && !actor2CC.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.ACTOR_2_COUNTRY_CODE_ATTRIBUTE,actor2CC);
        }
        numMentions=vals[GDELTUtils.NUM_MENTIONS_COLUMN_ID];
        if ((numMentions != null) && !numMentions.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_MENTIONS_ATTRIBUTE,Integer.parseInt(numMentions));
        }
        numSources=vals[GDELTUtils.NUM_SOURCES_COLUMN_ID];
        if ((numSources != null) && !numSources.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_SOURCES_ATTRIBUTE,Integer.parseInt(numSources));
        }
        numArticles=vals[GDELTUtils.NUM_ARTICLES_COLUMN_ID];
        if ((numArticles != null) && !numArticles.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.NUM_ARTICLES_ATTRIBUTE,Integer.parseInt(numArticles));
        }
        avgTone=vals[GDELTUtils.AVG_TONE_COLUMN_ID];
        if ((avgTone != null) && !avgTone.isEmpty()) {
          gdeltEventBuilder.set(GDELTUtils.AVG_TONE_ATTRIBUTE,Double.parseDouble(avgTone));
        }
      }
      featureData.add(new GeoWaveData<SimpleFeature>(eventKey,primaryIndexIds,gdeltEventBuilder.buildFeature(eventId)));
    }
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
catch (  final ParseException e) {
    LOGGER.error(""String_Node_Str"" + timestring,e);
  }
 finally {
    IOUtils.closeQuietly(br);
    IOUtils.closeQuietly(isr);
    IOUtils.closeQuietly(in);
  }
  return new CloseableIterator.Wrapper<GeoWaveData<SimpleFeature>>(featureData.iterator());
}",0.9529758186847506
113082,"public GDELTIngestPlugin(){
  setIncludeSupplementalFields(false);
  eventKey=new ByteArrayId(StringUtils.stringToBinary(GDELTUtils.GDELT_EVENT_FEATURE));
  try {
    crs=CRS.decode(CRS_AUTHORITY);
  }
 catch (  final FactoryException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","public GDELTIngestPlugin(){
  setIncludeSupplementalFields(false);
  eventKey=new ByteArrayId(StringUtils.stringToBinary(GDELTUtils.GDELT_EVENT_FEATURE));
}",0.7090909090909091
113083,"public static Pair<Double,Double> parseLatLon(final String[] vals,final CoordinateReferenceSystem crs){
  String latString=vals[GDELTUtils.GDELT_ACTION_LATITUDE_COLUMN_ID];
  String lonString=vals[GDELTUtils.GDELT_ACTION_LONGITUDE_COLUMN_ID];
  if ((latString == null) || (lonString == null) || (latString.length() < 1)|| (lonString.length() < 1)) {
    latString=vals[GDELTUtils.GDELT_ACTOR1_LATITUDE_COLUMN_ID];
    lonString=vals[GDELTUtils.GDELT_ACTOR1_LONGITUDE_COLUMN_ID];
  }
  if ((latString == null) || (lonString == null) || (latString.length() < 1)|| (lonString.length() < 1)) {
    latString=vals[GDELTUtils.GDELT_ACTOR2_LATITUDE_COLUMN_ID];
    lonString=vals[GDELTUtils.GDELT_ACTOR2_LONGITUDE_COLUMN_ID];
  }
  final Double lat=GeometryUtils.adjustCoordinateDimensionToRange(Double.parseDouble(latString),crs,1);
  final Double lon=GeometryUtils.adjustCoordinateDimensionToRange(Double.parseDouble(lonString),crs,0);
  return Pair.of(lat,lon);
}","public static Pair<Double,Double> parseLatLon(final String[] vals){
  String latString=vals[GDELTUtils.GDELT_ACTION_LATITUDE_COLUMN_ID];
  String lonString=vals[GDELTUtils.GDELT_ACTION_LONGITUDE_COLUMN_ID];
  if ((latString == null) || (lonString == null) || latString.trim().isEmpty()|| lonString.trim().isEmpty()) {
    latString=vals[GDELTUtils.GDELT_ACTOR1_LATITUDE_COLUMN_ID];
    lonString=vals[GDELTUtils.GDELT_ACTOR1_LONGITUDE_COLUMN_ID];
  }
  if ((latString == null) || (lonString == null) || latString.trim().isEmpty()|| lonString.trim().isEmpty()) {
    latString=vals[GDELTUtils.GDELT_ACTOR2_LATITUDE_COLUMN_ID];
    lonString=vals[GDELTUtils.GDELT_ACTOR2_LONGITUDE_COLUMN_ID];
  }
  if ((latString == null) || (lonString == null) || latString.trim().isEmpty()|| lonString.trim().isEmpty()) {
    return null;
  }
  final Double lat=Double.parseDouble(latString);
  final Double lon=Double.parseDouble(lonString);
  return Pair.of(lat,lon);
}",0.6687565308254964
113084,"@Override public IngestFormatOptionProvider getIngestFormatOptionProvider(){
  return new MultiOptionProvider((IngestFormatOptionProvider[])getIngestFormatOptionProviders().toArray());
}","@Override public IngestFormatOptionProvider getIngestFormatOptionProvider(){
  return new MultiOptionProvider(getIngestFormatOptionProviders().toArray(new IngestFormatOptionProvider[]{}));
}",0.8297872340425532
113085,"/** 
 * Main method to execute the MapReduce analytic.
 */
@SuppressWarnings(""String_Node_Str"") public int runJob() throws Exception {
  final Configuration conf=super.getConf();
  GeoWaveConfiguratorBase.setRemoteInvocationParams(kdeCommandLineOptions.getHdfsHostPort(),kdeCommandLineOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.setInt(MAX_LEVEL_KEY,kdeCommandLineOptions.getMaxLevel());
  conf.setInt(MIN_LEVEL_KEY,kdeCommandLineOptions.getMinLevel());
  conf.set(COVERAGE_NAME_KEY,kdeCommandLineOptions.getCoverageName());
  conf.setInt(TILE_SIZE_KEY,kdeCommandLineOptions.getTileSize());
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    conf.set(GaussianCellMapper.CQL_FILTER_KEY,kdeCommandLineOptions.getCqlFilter());
  }
  preJob1Setup(conf);
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  addJobClasspathDependencies(job,conf);
  job.setJobName(getJob1Name());
  job.setMapperClass(getJob1Mapper());
  job.setCombinerClass(CellSummationCombiner.class);
  job.setReducerClass(getJob1Reducer());
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setOutputKeyClass(DoubleWritable.class);
  job.setOutputValueClass(LongWritable.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(SequenceFileOutputFormat.class);
  job.setNumReduceTasks(8);
  job.setSpeculativeExecution(false);
  final AdapterStore adapterStore=inputAdapterStoreOptions.createStore();
  GeoWaveInputFormat.addDataAdapter(job.getConfiguration(),adapterStore.getAdapter(new ByteArrayId(kdeCommandLineOptions.getFeatureType())));
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMaxSplits());
  GeoWaveInputFormat.setDataStoreName(job.getConfiguration(),inputDataStoreOptions.getFactory().getName());
  GeoWaveInputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(inputDataStoreOptions.getConfigOptions(),inputDataStoreOptions.getFactory().getOptions()));
  GeoWaveInputFormat.setGeoWaveNamespace(job.getConfiguration(),inputDataStoreOptions.getNamespace());
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    final Filter filter=ECQL.toFilter(kdeCommandLineOptions.getCqlFilter());
    final Geometry bbox=(Geometry)filter.accept(ExtractGeometryFilterVisitor.GEOMETRY_VISITOR,null);
    if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
      GeoWaveInputFormat.setQuery(job.getConfiguration(),new SpatialQuery(bbox));
    }
  }
  final FileSystem fs=FileSystem.get(conf);
  fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
  FileOutputFormat.setOutputPath(job,new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
  final boolean job1Success=job.waitForCompletion(true);
  boolean job2Success=false;
  boolean postJob2Success=false;
  if (job1Success) {
    setupEntriesPerLevel(job,conf);
    final Job statsReducer=new Job(conf);
    statsReducer.setJarByClass(this.getClass());
    addJobClasspathDependencies(statsReducer,conf);
    statsReducer.setJobName(getJob2Name());
    statsReducer.setMapperClass(IdentityMapper.class);
    statsReducer.setPartitionerClass(getJob2Partitioner());
    statsReducer.setReducerClass(getJob2Reducer());
    statsReducer.setNumReduceTasks(getJob2NumReducers((kdeCommandLineOptions.getMaxLevel() - kdeCommandLineOptions.getMinLevel()) + 1));
    statsReducer.setMapOutputKeyClass(DoubleWritable.class);
    statsReducer.setMapOutputValueClass(LongWritable.class);
    statsReducer.setOutputKeyClass(getJob2OutputKeyClass());
    statsReducer.setOutputValueClass(getJob2OutputValueClass());
    statsReducer.setInputFormatClass(SequenceFileInputFormat.class);
    statsReducer.setOutputFormatClass(getJob2OutputFormatClass());
    FileInputFormat.setInputPaths(statsReducer,new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
    setupJob2Output(conf,statsReducer,outputDataStoreOptions.getNamespace());
    job2Success=statsReducer.waitForCompletion(true);
    if (job2Success) {
      postJob2Success=postJob2Actions(conf,outputDataStoreOptions.getNamespace());
    }
  }
 else {
    job2Success=false;
  }
  fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
  return (job1Success && job2Success && postJob2Success) ? 0 : 1;
}","/** 
 * Main method to execute the MapReduce analytic.
 */
@SuppressWarnings(""String_Node_Str"") public int runJob() throws Exception {
  Configuration conf=super.getConf();
  if (conf == null) {
    conf=new Configuration();
    setConf(conf);
  }
  GeoWaveConfiguratorBase.setRemoteInvocationParams(kdeCommandLineOptions.getHdfsHostPort(),kdeCommandLineOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.setInt(MAX_LEVEL_KEY,kdeCommandLineOptions.getMaxLevel());
  conf.setInt(MIN_LEVEL_KEY,kdeCommandLineOptions.getMinLevel());
  conf.set(COVERAGE_NAME_KEY,kdeCommandLineOptions.getCoverageName());
  conf.setInt(TILE_SIZE_KEY,kdeCommandLineOptions.getTileSize());
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    conf.set(GaussianCellMapper.CQL_FILTER_KEY,kdeCommandLineOptions.getCqlFilter());
  }
  preJob1Setup(conf);
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  addJobClasspathDependencies(job,conf);
  job.setJobName(getJob1Name());
  job.setMapperClass(getJob1Mapper());
  job.setCombinerClass(CellSummationCombiner.class);
  job.setReducerClass(getJob1Reducer());
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setOutputKeyClass(DoubleWritable.class);
  job.setOutputValueClass(LongWritable.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(SequenceFileOutputFormat.class);
  job.setNumReduceTasks(8);
  job.setSpeculativeExecution(false);
  final AdapterStore adapterStore=inputAdapterStoreOptions.createStore();
  GeoWaveInputFormat.addDataAdapter(job.getConfiguration(),adapterStore.getAdapter(new ByteArrayId(kdeCommandLineOptions.getFeatureType())));
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMaxSplits());
  GeoWaveInputFormat.setDataStoreName(job.getConfiguration(),inputDataStoreOptions.getFactory().getName());
  GeoWaveInputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(inputDataStoreOptions.getConfigOptions(),inputDataStoreOptions.getFactory().getOptions()));
  GeoWaveInputFormat.setGeoWaveNamespace(job.getConfiguration(),inputDataStoreOptions.getNamespace());
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    final Filter filter=ECQL.toFilter(kdeCommandLineOptions.getCqlFilter());
    final Geometry bbox=(Geometry)filter.accept(ExtractGeometryFilterVisitor.GEOMETRY_VISITOR,null);
    if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
      GeoWaveInputFormat.setQuery(job.getConfiguration(),new SpatialQuery(bbox));
    }
  }
  final FileSystem fs=FileSystem.get(conf);
  fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
  FileOutputFormat.setOutputPath(job,new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
  final boolean job1Success=job.waitForCompletion(true);
  boolean job2Success=false;
  boolean postJob2Success=false;
  if (job1Success) {
    setupEntriesPerLevel(job,conf);
    final Job statsReducer=new Job(conf);
    statsReducer.setJarByClass(this.getClass());
    addJobClasspathDependencies(statsReducer,conf);
    statsReducer.setJobName(getJob2Name());
    statsReducer.setMapperClass(IdentityMapper.class);
    statsReducer.setPartitionerClass(getJob2Partitioner());
    statsReducer.setReducerClass(getJob2Reducer());
    statsReducer.setNumReduceTasks(getJob2NumReducers((kdeCommandLineOptions.getMaxLevel() - kdeCommandLineOptions.getMinLevel()) + 1));
    statsReducer.setMapOutputKeyClass(DoubleWritable.class);
    statsReducer.setMapOutputValueClass(LongWritable.class);
    statsReducer.setOutputKeyClass(getJob2OutputKeyClass());
    statsReducer.setOutputValueClass(getJob2OutputValueClass());
    statsReducer.setInputFormatClass(SequenceFileInputFormat.class);
    statsReducer.setOutputFormatClass(getJob2OutputFormatClass());
    FileInputFormat.setInputPaths(statsReducer,new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
    setupJob2Output(conf,statsReducer,outputDataStoreOptions.getNamespace());
    job2Success=statsReducer.waitForCompletion(true);
    if (job2Success) {
      postJob2Success=postJob2Actions(conf,outputDataStoreOptions.getNamespace());
    }
  }
 else {
    job2Success=false;
  }
  fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
  return (job1Success && job2Success && postJob2Success) ? 0 : 1;
}",0.9922673031026252
113086,"/** 
 * Main method to execute the MapReduce analytic.
 */
public int runJob() throws Exception {
  final Configuration conf=super.getConf();
  GeoWaveConfiguratorBase.setRemoteInvocationParams(rasterResizeOptions.getHdfsHostPort(),rasterResizeOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.set(OLD_ADAPTER_ID_KEY,rasterResizeOptions.getInputCoverageName());
  conf.set(NEW_ADAPTER_ID_KEY,rasterResizeOptions.getOutputCoverageName());
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  job.setJobName(""String_Node_Str"" + rasterResizeOptions.getInputCoverageName() + ""String_Node_Str""+ rasterResizeOptions.getOutputTileSize());
  job.setMapperClass(RasterTileResizeMapper.class);
  job.setCombinerClass(RasterTileResizeCombiner.class);
  job.setReducerClass(RasterTileResizeReducer.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(GeoWaveOutputFormat.class);
  job.setMapOutputKeyClass(GeoWaveInputKey.class);
  job.setMapOutputValueClass(ObjectWritable.class);
  job.setOutputKeyClass(GeoWaveOutputKey.class);
  job.setOutputValueClass(GridCoverage.class);
  job.setNumReduceTasks(8);
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),rasterResizeOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),rasterResizeOptions.getMaxSplits());
  GeoWaveInputFormat.setDataStoreName(job.getConfiguration(),inputDataStoreOptions.getFactory().getName());
  GeoWaveInputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(inputDataStoreOptions.getConfigOptions(),inputDataStoreOptions.getFactory().getOptions()));
  GeoWaveInputFormat.setGeoWaveNamespace(job.getConfiguration(),inputDataStoreOptions.getNamespace());
  final DataAdapter adapter=inputAdapterStoreOptions.createStore().getAdapter(new ByteArrayId(rasterResizeOptions.getInputCoverageName()));
  if (adapter == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + rasterResizeOptions.getInputCoverageName() + ""String_Node_Str""+ inputAdapterStoreOptions.getNamespace()+ ""String_Node_Str"");
  }
  final RasterDataAdapter newAdapter=new RasterDataAdapter((RasterDataAdapter)adapter,rasterResizeOptions.getOutputCoverageName(),rasterResizeOptions.getOutputTileSize(),new NoDataMergeStrategy());
  JobContextAdapterStore.addDataAdapter(job.getConfiguration(),adapter);
  JobContextAdapterStore.addDataAdapter(job.getConfiguration(),newAdapter);
  PrimaryIndex index=null;
  final IndexStore indexStore=inputIndexStoreOptions.createStore();
  if (rasterResizeOptions.getIndexId() != null) {
    index=(PrimaryIndex)indexStore.getIndex(new ByteArrayId(rasterResizeOptions.getIndexId()));
  }
  if (index == null) {
    try (CloseableIterator<Index<?,?>> indices=indexStore.getIndices()){
      index=(PrimaryIndex)indices.next();
    }
     if (index == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + inputIndexStoreOptions.getNamespace() + ""String_Node_Str"");
    }
  }
  GeoWaveOutputFormat.setDataStoreName(job.getConfiguration(),outputDataStoreOptions.getFactory().getName());
  GeoWaveOutputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(outputDataStoreOptions.getConfigOptions(),outputDataStoreOptions.getFactory().getOptions()));
  GeoWaveOutputFormat.setGeoWaveNamespace(job.getConfiguration(),outputDataStoreOptions.getNamespace());
  JobContextIndexStore.addIndex(job.getConfiguration(),index);
  final DataStore store=outputDataStoreOptions.createStore();
  final IndexWriter writer=store.createIndexWriter(index,DataStoreUtils.DEFAULT_VISIBILITY);
  writer.setupAdapter(newAdapter);
  boolean retVal=false;
  try {
    retVal=job.waitForCompletion(true);
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
 finally {
    writer.close();
  }
  return retVal ? 0 : 1;
}","/** 
 * Main method to execute the MapReduce analytic.
 */
public int runJob() throws Exception {
  Configuration conf=super.getConf();
  if (conf == null) {
    conf=new Configuration();
    setConf(conf);
  }
  GeoWaveConfiguratorBase.setRemoteInvocationParams(rasterResizeOptions.getHdfsHostPort(),rasterResizeOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.set(OLD_ADAPTER_ID_KEY,rasterResizeOptions.getInputCoverageName());
  conf.set(NEW_ADAPTER_ID_KEY,rasterResizeOptions.getOutputCoverageName());
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  job.setJobName(""String_Node_Str"" + rasterResizeOptions.getInputCoverageName() + ""String_Node_Str""+ rasterResizeOptions.getOutputTileSize());
  job.setMapperClass(RasterTileResizeMapper.class);
  job.setCombinerClass(RasterTileResizeCombiner.class);
  job.setReducerClass(RasterTileResizeReducer.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(GeoWaveOutputFormat.class);
  job.setMapOutputKeyClass(GeoWaveInputKey.class);
  job.setMapOutputValueClass(ObjectWritable.class);
  job.setOutputKeyClass(GeoWaveOutputKey.class);
  job.setOutputValueClass(GridCoverage.class);
  job.setNumReduceTasks(8);
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),rasterResizeOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),rasterResizeOptions.getMaxSplits());
  GeoWaveInputFormat.setDataStoreName(job.getConfiguration(),inputDataStoreOptions.getFactory().getName());
  GeoWaveInputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(inputDataStoreOptions.getConfigOptions(),inputDataStoreOptions.getFactory().getOptions()));
  GeoWaveInputFormat.setGeoWaveNamespace(job.getConfiguration(),inputDataStoreOptions.getNamespace());
  final DataAdapter adapter=inputAdapterStoreOptions.createStore().getAdapter(new ByteArrayId(rasterResizeOptions.getInputCoverageName()));
  if (adapter == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + rasterResizeOptions.getInputCoverageName() + ""String_Node_Str""+ inputAdapterStoreOptions.getNamespace()+ ""String_Node_Str"");
  }
  final RasterDataAdapter newAdapter=new RasterDataAdapter((RasterDataAdapter)adapter,rasterResizeOptions.getOutputCoverageName(),rasterResizeOptions.getOutputTileSize(),new NoDataMergeStrategy());
  JobContextAdapterStore.addDataAdapter(job.getConfiguration(),adapter);
  JobContextAdapterStore.addDataAdapter(job.getConfiguration(),newAdapter);
  PrimaryIndex index=null;
  final IndexStore indexStore=inputIndexStoreOptions.createStore();
  if (rasterResizeOptions.getIndexId() != null) {
    index=(PrimaryIndex)indexStore.getIndex(new ByteArrayId(rasterResizeOptions.getIndexId()));
  }
  if (index == null) {
    try (CloseableIterator<Index<?,?>> indices=indexStore.getIndices()){
      index=(PrimaryIndex)indices.next();
    }
     if (index == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + inputIndexStoreOptions.getNamespace() + ""String_Node_Str"");
    }
  }
  GeoWaveOutputFormat.setDataStoreName(job.getConfiguration(),outputDataStoreOptions.getFactory().getName());
  GeoWaveOutputFormat.setStoreConfigOptions(job.getConfiguration(),ConfigUtils.valuesToStrings(outputDataStoreOptions.getConfigOptions(),outputDataStoreOptions.getFactory().getOptions()));
  GeoWaveOutputFormat.setGeoWaveNamespace(job.getConfiguration(),outputDataStoreOptions.getNamespace());
  JobContextIndexStore.addIndex(job.getConfiguration(),index);
  final DataStore store=outputDataStoreOptions.createStore();
  final IndexWriter writer=store.createIndexWriter(index,DataStoreUtils.DEFAULT_VISIBILITY);
  writer.setupAdapter(newAdapter);
  boolean retVal=false;
  try {
    retVal=job.waitForCompletion(true);
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
 finally {
    writer.close();
  }
  return retVal ? 0 : 1;
}",0.989640619004988
113087,"public static IngestCommandLineOptions parseOptions(final CommandLine commandLine) throws ParseException {
  final boolean success=true;
  boolean clearNamespace=false;
  final int randomPartitions=-1;
  if (commandLine.hasOption(""String_Node_Str"")) {
    clearNamespace=true;
  }
  String visibility=null;
  if (commandLine.hasOption(""String_Node_Str"")) {
    visibility=commandLine.getOptionValue(""String_Node_Str"");
  }
  final String dimensionalityType=commandLine.getOptionValue(""String_Node_Str"",IngestUtils.getDefaultDimensionalityType());
  if (!success) {
    throw new ParseException(""String_Node_Str"");
  }
  return new IngestCommandLineOptions(visibility,clearNamespace,dimensionalityType);
}","public static IngestCommandLineOptions parseOptions(final CommandLine commandLine) throws ParseException {
  final boolean success=true;
  boolean clearNamespace=false;
  if (commandLine.hasOption(""String_Node_Str"")) {
    clearNamespace=true;
  }
  String visibility=null;
  if (commandLine.hasOption(""String_Node_Str"")) {
    visibility=commandLine.getOptionValue(""String_Node_Str"");
  }
  final String dimensionalityType=commandLine.getOptionValue(""String_Node_Str"",IngestUtils.getDefaultDimensionalityType());
  if (!success) {
    throw new ParseException(""String_Node_Str"");
  }
  return new IngestCommandLineOptions(visibility,clearNamespace,dimensionalityType);
}",0.976
113088,"public void setTrackPointData(final byte[] geometry,final byte[] image,final String missionUUID,final String trackNumber,final String trackUUID,final String trackStatus,final String trackClassification,final String trackItemUUID,final String trackPointSource,final long timeStamp,final long endTimeStamp,final double speed,final double course,final String trackItemClassification,final double latitude,final double longitude,final double elevation,final int pixelRow,final int pixelColumn,final int frameNumber){
  EventType=new IntWritable(0);
  Geometry=new BytesWritable(geometry);
  Image=new BytesWritable(image);
  MissionUUID=new Text(missionUUID);
  TrackNumber=new Text(trackNumber);
  TrackUUID=new Text(trackUUID);
  TrackStatus=new Text(trackStatus);
  TrackClassification=new Text(trackClassification);
  TrackItemUUID=new Text(trackItemUUID);
  TrackPointSource=new Text(trackPointSource);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(endTimeStamp);
  Speed=new DoubleWritable(speed);
  Course=new DoubleWritable(course);
  TrackItemClassification=new Text(trackItemClassification);
  Latitude=new DoubleWritable(latitude);
  Longitude=new DoubleWritable(longitude);
  Elevation=new DoubleWritable(elevation);
  PixelRow=new IntWritable(pixelRow);
  PixelColumn=new IntWritable(pixelColumn);
  FrameNumber=new IntWritable(frameNumber);
}","public void setTrackPointData(final byte[] geometry,final byte[] image,final String missionUUID,final String trackNumber,final String trackUUID,final String trackStatus,final String trackClassification,final String trackItemUUID,final String trackPointSource,final long timeStamp,final long endTimeStamp,final double speed,final double course,final String trackItemClassification,final double latitude,final double longitude,final double elevation,final int pixelRow,final int pixelColumn,final int frameNumber){
  EventType=new IntWritable(0);
  Geometry=new BytesWritable(geometry);
  if (image != null) {
    Image=new BytesWritable(image);
  }
  MissionUUID=new Text(missionUUID);
  TrackNumber=new Text(trackNumber);
  TrackUUID=new Text(trackUUID);
  TrackStatus=new Text(trackStatus);
  TrackClassification=new Text(trackClassification);
  TrackItemUUID=new Text(trackItemUUID);
  TrackPointSource=new Text(trackPointSource);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(endTimeStamp);
  Speed=new DoubleWritable(speed);
  Course=new DoubleWritable(course);
  TrackItemClassification=new Text(trackItemClassification);
  Latitude=new DoubleWritable(latitude);
  Longitude=new DoubleWritable(longitude);
  Elevation=new DoubleWritable(elevation);
  PixelRow=new IntWritable(pixelRow);
  PixelColumn=new IntWritable(pixelColumn);
  FrameNumber=new IntWritable(frameNumber);
}",0.989594546106925
113089,"public void setMotionPointData(final byte[] geometry,final byte[] image,final String missionUUID,final String trackNumber,final String trackUUID,final String trackStatus,final String trackClassification,final String trackItemUUID,final String trackPointSource,final long timeStamp,final long endTimeStamp,final double speed,final double course,final String trackItemClassification,final double latitude,final double longitude,final double elevation,final int pixelRow,final int pixelColumn,final int frameNumber,final String motionEvent){
  EventType=new IntWritable(1);
  Geometry=new BytesWritable(geometry);
  Image=new BytesWritable(image);
  MissionUUID=new Text(missionUUID);
  TrackNumber=new Text(trackNumber);
  TrackUUID=new Text(trackUUID);
  TrackStatus=new Text(trackStatus);
  TrackClassification=new Text(trackClassification);
  TrackItemUUID=new Text(trackItemUUID);
  TrackPointSource=new Text(trackPointSource);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(endTimeStamp);
  Speed=new DoubleWritable(speed);
  Course=new DoubleWritable(course);
  TrackItemClassification=new Text(trackItemClassification);
  Latitude=new DoubleWritable(latitude);
  Longitude=new DoubleWritable(longitude);
  Elevation=new DoubleWritable(elevation);
  PixelRow=new IntWritable(pixelRow);
  PixelColumn=new IntWritable(pixelColumn);
  FrameNumber=new IntWritable(frameNumber);
  MotionEvent=new Text(motionEvent);
}","public void setMotionPointData(final byte[] geometry,final byte[] image,final String missionUUID,final String trackNumber,final String trackUUID,final String trackStatus,final String trackClassification,final String trackItemUUID,final String trackPointSource,final long timeStamp,final long endTimeStamp,final double speed,final double course,final String trackItemClassification,final double latitude,final double longitude,final double elevation,final int pixelRow,final int pixelColumn,final int frameNumber,final String motionEvent){
  EventType=new IntWritable(1);
  Geometry=new BytesWritable(geometry);
  if (image != null) {
    Image=new BytesWritable(image);
  }
  MissionUUID=new Text(missionUUID);
  TrackNumber=new Text(trackNumber);
  TrackUUID=new Text(trackUUID);
  TrackStatus=new Text(trackStatus);
  TrackClassification=new Text(trackClassification);
  TrackItemUUID=new Text(trackItemUUID);
  TrackPointSource=new Text(trackPointSource);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(endTimeStamp);
  Speed=new DoubleWritable(speed);
  Course=new DoubleWritable(course);
  TrackItemClassification=new Text(trackItemClassification);
  Latitude=new DoubleWritable(latitude);
  Longitude=new DoubleWritable(longitude);
  Elevation=new DoubleWritable(elevation);
  PixelRow=new IntWritable(pixelRow);
  PixelColumn=new IntWritable(pixelColumn);
  FrameNumber=new IntWritable(frameNumber);
  MotionEvent=new Text(motionEvent);
}",0.9900446275317542
113090,"public void setMissionSummaryData(final byte[] geometry,final String missionUUID,final String missionName,final int missionNumFrames,final long timeStamp,final long endTimeStamp,final String classification,final String objectClass){
  EventType=new IntWritable(4);
  Geometry=new BytesWritable(geometry);
  MissionUUID=new Text(missionUUID);
  MissionName=new Text(missionName);
  MissionNumFrames=new IntWritable(missionNumFrames);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(timeStamp);
  TrackClassification=new Text(classification);
  ObjectClass=new Text(objectClass);
}","public void setMissionSummaryData(final byte[] geometry,final String missionUUID,final String missionName,final int missionNumFrames,final long timeStamp,final long endTimeStamp,final String classification,final String objectClass){
  EventType=new IntWritable(4);
  Geometry=new BytesWritable(geometry);
  MissionUUID=new Text(missionUUID);
  MissionName=new Text(missionName);
  MissionNumFrames=new IntWritable(missionNumFrames);
  TimeStamp=new LongWritable(timeStamp);
  EndTimeStamp=new LongWritable(endTimeStamp);
  TrackClassification=new Text(classification);
  ObjectClass=new Text(objectClass);
}",0.9958711808422792
113091,"@Override protected CloseableIterator<GeoWaveData<SimpleFeature>> toGeoWaveDataInternal(final WholeFile hfile,final ByteArrayId primaryIndexId,final String globalVisibility){
  final List<GeoWaveData<SimpleFeature>> featureData=new ArrayList<GeoWaveData<SimpleFeature>>();
  final InputStream in=new ZipInputStream(new ByteArrayInputStream(hfile.getOriginalFile().array()));
  final InputStreamReader isr=new InputStreamReader(in,StringUtils.UTF8_CHAR_SET);
  final BufferedReader br=new BufferedReader(isr);
  final GeometryFactory geometryFactory=new GeometryFactory();
  Date timeStamp=null;
  String timestring=""String_Node_Str"";
  String eventId=""String_Node_Str"";
  double lat;
  double lon;
  String line;
  try {
    while ((line=br.readLine()) != null) {
      final String[] vals=line.split(""String_Node_Str"");
      if ((vals.length < GDELTUtils.GDELT_MIN_COLUMNS) || (vals.length > GDELTUtils.GDELT_MAX_COLUMNS)) {
        LOGGER.warn(""String_Node_Str"" + vals.length + ""String_Node_Str"");
        continue;
      }
      eventId=vals[GDELTUtils.GDELT_EVENT_ID_COLUMN_ID];
      lat=GeometryUtils.adjustCoordinateDimensionToRange(Double.parseDouble(vals[GDELTUtils.GDELT_LATITUDE_COLUMN_ID]),crs,1);
      lon=GeometryUtils.adjustCoordinateDimensionToRange(Double.parseDouble(vals[GDELTUtils.GDELT_LONGITUDE_COLUMN_ID]),crs,0);
      final Coordinate cord=new Coordinate(lat,lon);
      gdeltEventBuilder.set(GDELTUtils.GDELT_GEOMETRY_ATTRIBUTE,geometryFactory.createPoint(cord));
      gdeltEventBuilder.set(GDELTUtils.GDELT_EVENT_ID_ATTRIBUTE,eventId);
      timestring=vals[GDELTUtils.GDELT_TIMESTAMP_COLUMN_ID];
      timeStamp=GDELTUtils.parseDate(timestring);
      gdeltEventBuilder.set(GDELTUtils.GDELT_TIMESTAMP_ATTRIBUTE,timeStamp);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LATITUDE_ATTRIBUTE,lat);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LONGITUDE_ATTRIBUTE,lon);
      featureData.add(new GeoWaveData<SimpleFeature>(eventKey,primaryIndexId,gdeltEventBuilder.buildFeature(eventId)));
    }
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
catch (  final ParseException e) {
    LOGGER.error(""String_Node_Str"" + timestring,e);
  }
 finally {
    IOUtils.closeQuietly(br);
    IOUtils.closeQuietly(isr);
    IOUtils.closeQuietly(in);
  }
  return new CloseableIterator.Wrapper<GeoWaveData<SimpleFeature>>(featureData.iterator());
}","@Override protected CloseableIterator<GeoWaveData<SimpleFeature>> toGeoWaveDataInternal(final WholeFile hfile,final ByteArrayId primaryIndexId,final String globalVisibility){
  final List<GeoWaveData<SimpleFeature>> featureData=new ArrayList<GeoWaveData<SimpleFeature>>();
  final InputStream in=new ByteArrayInputStream(hfile.getOriginalFile().array());
  final ZipInputStream zip=new ZipInputStream(in);
  try {
    zip.getNextEntry();
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
  final InputStreamReader isr=new InputStreamReader(zip,StringUtils.UTF8_CHAR_SET);
  final BufferedReader br=new BufferedReader(isr);
  final GeometryFactory geometryFactory=new GeometryFactory();
  Date timeStamp=null;
  String timestring=""String_Node_Str"";
  String eventId=""String_Node_Str"";
  int actionGeoType;
  final double lat=0;
  final double lon=0;
  String line;
  int lineNumber=0;
  try {
    while ((line=br.readLine()) != null) {
      lineNumber++;
      final String[] vals=line.split(""String_Node_Str"");
      if ((vals.length < GDELTUtils.GDELT_MIN_COLUMNS) || (vals.length > GDELTUtils.GDELT_MAX_COLUMNS)) {
        LOGGER.warn(""String_Node_Str"" + vals.length + ""String_Node_Str""+ lineNumber+ ""String_Node_Str""+ hfile.getOriginalFilePath());
        continue;
      }
      actionGeoType=Integer.parseInt(vals[GDELTUtils.GDELT_ACTION_GEO_TYPE_COLUMN_ID]);
      if (actionGeoType == 0) {
        continue;
      }
      eventId=vals[GDELTUtils.GDELT_EVENT_ID_COLUMN_ID];
      try {
        GDELTUtils.parseLatLon(vals,crs);
      }
 catch (      final Exception e) {
        LOGGER.warn(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ hfile.getOriginalFilePath());
        continue;
      }
      final Coordinate cord=new Coordinate(lat,lon);
      gdeltEventBuilder.set(GDELTUtils.GDELT_GEOMETRY_ATTRIBUTE,geometryFactory.createPoint(cord));
      gdeltEventBuilder.set(GDELTUtils.GDELT_EVENT_ID_ATTRIBUTE,eventId);
      timestring=vals[GDELTUtils.GDELT_TIMESTAMP_COLUMN_ID];
      timeStamp=GDELTUtils.parseDate(timestring);
      gdeltEventBuilder.set(GDELTUtils.GDELT_TIMESTAMP_ATTRIBUTE,timeStamp);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LATITUDE_ATTRIBUTE,lat);
      gdeltEventBuilder.set(GDELTUtils.GDELT_LONGITUDE_ATTRIBUTE,lon);
      featureData.add(new GeoWaveData<SimpleFeature>(eventKey,primaryIndexId,gdeltEventBuilder.buildFeature(eventId)));
    }
  }
 catch (  final IOException e) {
    LOGGER.warn(""String_Node_Str"" + hfile.getOriginalFilePath(),e);
  }
catch (  final ParseException e) {
    LOGGER.error(""String_Node_Str"" + timestring,e);
  }
 finally {
    IOUtils.closeQuietly(br);
    IOUtils.closeQuietly(isr);
    IOUtils.closeQuietly(in);
  }
  return new CloseableIterator.Wrapper<GeoWaveData<SimpleFeature>>(featureData.iterator());
}",0.6812227074235808
113092,"public static void printHelp(){
  final HelpFormatter helpFormatter=new HelpFormatter();
  final PrintWriter pw=new PrintWriter(System.out);
  final int width=HelpFormatter.DEFAULT_WIDTH;
  helpFormatter.printUsage(pw,width,""String_Node_Str"");
  helpFormatter.printWrapped(pw,width,""String_Node_Str"");
  final int leftPad=HelpFormatter.DEFAULT_LEFT_PAD;
  final int descPad=HelpFormatter.DEFAULT_DESC_PAD;
  final Map<CategoryKey,CLIOperation[]> internalOperationsRegistry=getRegisteredOperations();
  for (  final Entry<CategoryKey,CLIOperation[]> entry : internalOperationsRegistry.entrySet()) {
    final CLIOperation[] operations=entry.getValue();
    final Options options=new Options();
    final OptionGroup operationChoice=new OptionGroup();
    operationChoice.setRequired(true);
    for (int i=0; i < operations.length; i++) {
      operationChoice.addOption(new Option(operations[i].getCommandlineOptionValue(),operations[i].getDescription()));
    }
    options.addOptionGroup(operationChoice);
    final CLIOperationCategory category=entry.getKey().category;
    final StringBuffer buf=new StringBuffer(""String_Node_Str"" + category.getName());
    final String description=category.getDescription();
    if ((description != null) && (description.trim().length() > 0)) {
      buf.append(""String_Node_Str"").append(description);
    }
    helpFormatter.printWrapped(pw,width,buf.toString());
    helpFormatter.printOptions(pw,width,options,leftPad,descPad);
  }
  helpFormatter.printWrapped(pw,width,""String_Node_Str"");
  pw.flush();
  System.exit(-1);
}","public static void printHelp(){
  final HelpFormatter helpFormatter=new HelpFormatter();
  final PrintWriter pw=new PrintWriter(new OutputStreamWriter(System.out,StringUtils.UTF8_CHAR_SET));
  final int width=HelpFormatter.DEFAULT_WIDTH;
  helpFormatter.printUsage(pw,width,""String_Node_Str"");
  helpFormatter.printWrapped(pw,width,""String_Node_Str"");
  final int leftPad=HelpFormatter.DEFAULT_LEFT_PAD;
  final int descPad=HelpFormatter.DEFAULT_DESC_PAD;
  final Map<CategoryKey,CLIOperation[]> internalOperationsRegistry=getRegisteredOperations();
  for (  final Entry<CategoryKey,CLIOperation[]> entry : internalOperationsRegistry.entrySet()) {
    final CLIOperation[] operations=entry.getValue();
    final Options options=new Options();
    final OptionGroup operationChoice=new OptionGroup();
    operationChoice.setRequired(true);
    for (int i=0; i < operations.length; i++) {
      operationChoice.addOption(new Option(operations[i].getCommandlineOptionValue(),operations[i].getDescription()));
    }
    options.addOptionGroup(operationChoice);
    final CLIOperationCategory category=entry.getKey().category;
    final StringBuffer buf=new StringBuffer(""String_Node_Str"" + category.getName());
    final String description=category.getDescription();
    if ((description != null) && (description.trim().length() > 0)) {
      buf.append(""String_Node_Str"").append(description);
    }
    helpFormatter.printWrapped(pw,width,buf.toString());
    helpFormatter.printOptions(pw,width,options,leftPad,descPad);
  }
  helpFormatter.printWrapped(pw,width,""String_Node_Str"");
  pw.flush();
  System.exit(-1);
}",0.9779874213836478
113093,"@Override protected void transformRange(final SortedKeyValueIterator<Key,Value> input,final KVBuffer output) throws IOException {
  if (model != null) {
    long longDataId=0;
    while (input.hasTop()) {
      final Value val=input.getTopValue();
      final Key currentKey=input.getTopKey();
      final ArrayReader<byte[]> reader=new ArrayReader<byte[]>(new PrimitiveByteArrayReader());
      final ByteArrayId fieldId=new ByteArrayId(currentKey.getColumnQualifierData().getBackingArray());
      final boolean addEncoding=(model.getReader(fieldId) == null);
      final ByteSequence rowData=currentKey.getRowData();
      AccumuloRowId rowId=new AccumuloRowId(rowData.getBackingArray());
      final byte[][] entryBytes=reader.readField(val.get());
      for (int i=0; i < entryBytes.length; i++) {
        final byte[] dataId=new byte[4];
        ByteBuffer buf=ByteBuffer.allocate(8);
        buf.putLong(longDataId++);
        buf.position(4);
        buf.get(dataId,0,4);
        rowId=new AccumuloRowId(rowId.getInsertionId(),dataId,rowId.getAdapterId(),rowId.getNumberOfDuplicates());
        final Key outKey=IteratorUtils.replaceRow(currentKey,rowId.getRowId());
        byte[] value;
        if (addEncoding) {
          if (entryBytes[i] != null) {
            value=new byte[1 + entryBytes[i].length];
            value=ArrayUtils.add(entryBytes[i],0,val.get()[0]);
          }
 else {
            value=new byte[]{val.get()[0]};
          }
        }
 else {
          value=entryBytes[i];
        }
        output.append(outKey,new Value(value));
      }
      input.next();
    }
  }
}","@Override protected void transformRange(final SortedKeyValueIterator<Key,Value> input,final KVBuffer output) throws IOException {
  if (model != null) {
    while (input.hasTop()) {
      long longDataId=0;
      final Value val=input.getTopValue();
      final Key currentKey=input.getTopKey();
      final ArrayReader<byte[]> reader=new ArrayReader<byte[]>(new PrimitiveByteArrayReader());
      final ByteArrayId fieldId=new ByteArrayId(currentKey.getColumnQualifierData().getBackingArray());
      final boolean addEncoding=(model.getReader(fieldId) == null);
      final ByteSequence rowData=currentKey.getRowData();
      AccumuloRowId rowId=new AccumuloRowId(rowData.getBackingArray());
      final byte[][] entryBytes=reader.readField(val.get());
      for (int i=0; i < entryBytes.length; i++) {
        final byte[] dataId=new byte[4];
        ByteBuffer buf=ByteBuffer.allocate(8);
        buf.putLong(longDataId++);
        buf.position(4);
        buf.get(dataId,0,4);
        rowId=new AccumuloRowId(rowId.getInsertionId(),dataId,rowId.getAdapterId(),rowId.getNumberOfDuplicates());
        final Key outKey=IteratorUtils.replaceRow(currentKey,rowId.getRowId());
        byte[] value;
        if (addEncoding) {
          if (entryBytes[i] != null) {
            value=new byte[1 + entryBytes[i].length];
            value=ArrayUtils.add(entryBytes[i],0,val.get()[0]);
          }
 else {
            value=new byte[]{val.get()[0]};
          }
        }
 else {
          value=entryBytes[i];
        }
        output.append(outKey,new Value(value));
      }
      input.next();
    }
  }
}",0.9850374064837906
113094,"/** 
 * Convenience constructor used to construct a simple latitude dimension object which sits on a Cartesian plane.
 */
public LatitudeDefinition(){
  super(-90,90);
}","/** 
 * Convenience constructor used to construct a simple latitude dimension object which sits on a Cartesian plane. You can pass in a flag to use half the range if you want square SFC IDs in decimal degree latitudes and longitudes
 */
public LatitudeDefinition(final boolean useHalfRange){
  super(useHalfRange ? -180 : -90,useHalfRange ? 180 : 90);
}",0.6475095785440613
113095,"@Override public byte[] toBinary(){
  return new byte[]{};
}","@Override public byte[] toBinary(){
  return new byte[]{(byte)(((min > -180) && (max < 180)) ? 0 : 1)};
}",0.7272727272727273
113096,"@Override public void fromBinary(byte[] bytes){
}","@Override public void fromBinary(final byte[] bytes){
  if ((bytes != null) && (bytes.length > 0)) {
    if (bytes[0] == (byte)1) {
      min=-180;
      max=180;
    }
  }
}",0.4394618834080717
113097,"@Override public Mutation next(){
  boolean ignoreLastEntry=false;
  if (!pendingOutput.isEmpty()) {
    return pendingOutput.removeFirst();
  }
 else   if (rawIt.hasNext()) {
    while (rawIt.hasNext()) {
      Entry<Key,Value> entry=rawIt.next();
      addEntry(lastEntries,entry);
      byte[] currentRowID=entry.getKey().getRow().getBytes();
      if (rowID == null || Arrays.equals(rowID,currentRowID)) {
        rowID=currentRowID;
        continue;
      }
 else {
        rowID=currentRowID;
        ignoreLastEntry=true;
        break;
      }
    }
  }
  int countDown=lastEntries.size();
  Iterator<Entry<Key,Value>> it=lastEntries.iterator();
  while (it.hasNext()) {
    Entry<Key,Value> lastEntry=it.next();
    countDown--;
    if (ignoreLastEntry && countDown == 0)     break;
    Mutation mutation=new Mutation(lastEntry.getKey().getRow());
    if (lastEntry.getKey().isDeleted()) {
      mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
    }
 else {
      mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
    }
    pendingOutput.addLast(mutation);
    it.remove();
  }
  return pendingOutput.removeFirst();
}","@Override public Mutation next(){
  boolean ignoreLastEntry=false;
  if (!pendingOutput.isEmpty()) {
    return pendingOutput.removeFirst();
  }
 else   if (rawIt.hasNext()) {
    while (rawIt.hasNext()) {
      Entry<Key,Value> entry=rawIt.next();
      addEntry(lastEntries,entry);
      byte[] currentRowID=entry.getKey().getRow().getBytes();
      if (rowID == null || Arrays.equals(rowID,currentRowID)) {
        rowID=currentRowID;
      }
 else {
        rowID=currentRowID;
        ignoreLastEntry=true;
        break;
      }
    }
  }
  int countDown=lastEntries.size();
  Iterator<Entry<Key,Value>> it=lastEntries.iterator();
  while (it.hasNext()) {
    Entry<Key,Value> lastEntry=it.next();
    countDown--;
    if (ignoreLastEntry && countDown == 0)     break;
    Mutation mutation=new Mutation(lastEntry.getKey().getRow());
    if (lastEntry.getKey().isDeleted()) {
      mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
    }
 else {
      mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
    }
    pendingOutput.addLast(mutation);
    it.remove();
  }
  return pendingOutput.removeFirst();
}",0.9933774834437086
113098,"public void transform(){
  try {
    final Iterator<Entry<Key,Value>> rawIt=scanner.iterator();
    Writer writer=accumuloOperations.createWriter(tableName);
    writer.write(new Iterable<Mutation>(){
      @Override public Iterator<Mutation> iterator(){
        return new Iterator<Mutation>(){
          List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
          LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
          byte[] rowID=null;
          @Override public boolean hasNext(){
            return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
          }
          @Override public Mutation next(){
            boolean ignoreLastEntry=false;
            if (!pendingOutput.isEmpty()) {
              return pendingOutput.removeFirst();
            }
 else             if (rawIt.hasNext()) {
              while (rawIt.hasNext()) {
                Entry<Key,Value> entry=rawIt.next();
                addEntry(lastEntries,entry);
                byte[] currentRowID=entry.getKey().getRow().getBytes();
                if (rowID == null || Arrays.equals(rowID,currentRowID)) {
                  rowID=currentRowID;
                  continue;
                }
 else {
                  rowID=currentRowID;
                  ignoreLastEntry=true;
                  break;
                }
              }
            }
            int countDown=lastEntries.size();
            Iterator<Entry<Key,Value>> it=lastEntries.iterator();
            while (it.hasNext()) {
              Entry<Key,Value> lastEntry=it.next();
              countDown--;
              if (ignoreLastEntry && countDown == 0)               break;
              Mutation mutation=new Mutation(lastEntry.getKey().getRow());
              if (lastEntry.getKey().isDeleted()) {
                mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
              }
 else {
                mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
              }
              pendingOutput.addLast(mutation);
              it.remove();
            }
            return pendingOutput.removeFirst();
          }
          @Override public void remove(){
          }
        }
;
      }
    }
);
    writer.close();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
}","public void transform(){
  try {
    final Iterator<Entry<Key,Value>> rawIt=scanner.iterator();
    Writer writer=accumuloOperations.createWriter(tableName);
    writer.write(new Iterable<Mutation>(){
      @Override public Iterator<Mutation> iterator(){
        return new Iterator<Mutation>(){
          List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
          LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
          byte[] rowID=null;
          @Override public boolean hasNext(){
            return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
          }
          @Override public Mutation next(){
            boolean ignoreLastEntry=false;
            if (!pendingOutput.isEmpty()) {
              return pendingOutput.removeFirst();
            }
 else             if (rawIt.hasNext()) {
              while (rawIt.hasNext()) {
                Entry<Key,Value> entry=rawIt.next();
                addEntry(lastEntries,entry);
                byte[] currentRowID=entry.getKey().getRow().getBytes();
                if (rowID == null || Arrays.equals(rowID,currentRowID)) {
                  rowID=currentRowID;
                }
 else {
                  rowID=currentRowID;
                  ignoreLastEntry=true;
                  break;
                }
              }
            }
            int countDown=lastEntries.size();
            Iterator<Entry<Key,Value>> it=lastEntries.iterator();
            while (it.hasNext()) {
              Entry<Key,Value> lastEntry=it.next();
              countDown--;
              if (ignoreLastEntry && countDown == 0)               break;
              Mutation mutation=new Mutation(lastEntry.getKey().getRow());
              if (lastEntry.getKey().isDeleted()) {
                mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
              }
 else {
                mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
              }
              pendingOutput.addLast(mutation);
              it.remove();
            }
            return pendingOutput.removeFirst();
          }
          @Override public void remove(){
          }
        }
;
      }
    }
);
    writer.close();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
}",0.994486018117369
113099,"@Override public Iterator<Mutation> iterator(){
  return new Iterator<Mutation>(){
    List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
    LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
    byte[] rowID=null;
    @Override public boolean hasNext(){
      return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
    }
    @Override public Mutation next(){
      boolean ignoreLastEntry=false;
      if (!pendingOutput.isEmpty()) {
        return pendingOutput.removeFirst();
      }
 else       if (rawIt.hasNext()) {
        while (rawIt.hasNext()) {
          Entry<Key,Value> entry=rawIt.next();
          addEntry(lastEntries,entry);
          byte[] currentRowID=entry.getKey().getRow().getBytes();
          if (rowID == null || Arrays.equals(rowID,currentRowID)) {
            rowID=currentRowID;
            continue;
          }
 else {
            rowID=currentRowID;
            ignoreLastEntry=true;
            break;
          }
        }
      }
      int countDown=lastEntries.size();
      Iterator<Entry<Key,Value>> it=lastEntries.iterator();
      while (it.hasNext()) {
        Entry<Key,Value> lastEntry=it.next();
        countDown--;
        if (ignoreLastEntry && countDown == 0)         break;
        Mutation mutation=new Mutation(lastEntry.getKey().getRow());
        if (lastEntry.getKey().isDeleted()) {
          mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
        }
 else {
          mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
        }
        pendingOutput.addLast(mutation);
        it.remove();
      }
      return pendingOutput.removeFirst();
    }
    @Override public void remove(){
    }
  }
;
}","@Override public Iterator<Mutation> iterator(){
  return new Iterator<Mutation>(){
    List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
    LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
    byte[] rowID=null;
    @Override public boolean hasNext(){
      return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
    }
    @Override public Mutation next(){
      boolean ignoreLastEntry=false;
      if (!pendingOutput.isEmpty()) {
        return pendingOutput.removeFirst();
      }
 else       if (rawIt.hasNext()) {
        while (rawIt.hasNext()) {
          Entry<Key,Value> entry=rawIt.next();
          addEntry(lastEntries,entry);
          byte[] currentRowID=entry.getKey().getRow().getBytes();
          if (rowID == null || Arrays.equals(rowID,currentRowID)) {
            rowID=currentRowID;
          }
 else {
            rowID=currentRowID;
            ignoreLastEntry=true;
            break;
          }
        }
      }
      int countDown=lastEntries.size();
      Iterator<Entry<Key,Value>> it=lastEntries.iterator();
      while (it.hasNext()) {
        Entry<Key,Value> lastEntry=it.next();
        countDown--;
        if (ignoreLastEntry && countDown == 0)         break;
        Mutation mutation=new Mutation(lastEntry.getKey().getRow());
        if (lastEntry.getKey().isDeleted()) {
          mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
        }
 else {
          mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
        }
        pendingOutput.addLast(mutation);
        it.remove();
      }
      return pendingOutput.removeFirst();
    }
    @Override public void remove(){
    }
  }
;
}",0.9943181818181818
113100,"private static DataAdapter<?>[] getDataAdaptersInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.DATA_ADAPTER) + ""String_Node_Str"");
  if (input != null) {
    final List<DataAdapter<?>> adapters=new ArrayList<DataAdapter<?>>(input.size());
    for (    final String dataAdapterStr : input.values()) {
      final byte[] dataAdapterBytes=ByteArrayUtils.byteArrayFromString(dataAdapterStr);
      adapters.add(PersistenceUtils.fromBinary(dataAdapterBytes,DataAdapter.class));
    }
    return adapters.toArray(new DataAdapter[]{});
  }
  return new DataAdapter[]{};
}","private static DataAdapter<?>[] getDataAdaptersInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.DATA_ADAPTER) + ""String_Node_Str"");
  if (input != null) {
    final List<DataAdapter<?>> adapters=new ArrayList<DataAdapter<?>>(input.size());
    for (    final String dataAdapterStr : input.values()) {
      final byte[] dataAdapterBytes=ByteArrayUtils.byteArrayFromString(dataAdapterStr);
      adapters.add(PersistenceUtils.fromBinary(dataAdapterBytes,DataAdapter.class));
    }
    return adapters.toArray(new DataAdapter[adapters.size()]);
  }
  return new DataAdapter[]{};
}",0.988036593947924
113101,"private static Index[] getIndicesInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.INDEX) + ""String_Node_Str"");
  if (input != null) {
    final List<Index> indices=new ArrayList<Index>(input.size());
    for (    final String indexStr : input.values()) {
      final byte[] indexBytes=ByteArrayUtils.byteArrayFromString(indexStr);
      indices.add(PersistenceUtils.fromBinary(indexBytes,Index.class));
    }
    return indices.toArray(new Index[]{});
  }
  return new Index[]{};
}","private static Index[] getIndicesInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.INDEX) + ""String_Node_Str"");
  if (input != null) {
    final List<Index> indices=new ArrayList<Index>(input.size());
    for (    final String indexStr : input.values()) {
      final byte[] indexBytes=ByteArrayUtils.byteArrayFromString(indexStr);
      indices.add(PersistenceUtils.fromBinary(indexBytes,Index.class));
    }
    return indices.toArray(new Index[indices.size()]);
  }
  return new Index[]{};
}",0.987220447284345
113102,"private GeoWaveInputSplit toFinalSplit(){
  final Map<Index,List<Range>> rangesPerIndex=new HashMap<Index,List<Range>>();
  final Set<String> locations=new HashSet<String>();
  for (  final Entry<Index,List<RangeLocationPair>> entry : splitInfo.entrySet()) {
    final List<Range> ranges=new ArrayList<Range>(entry.getValue().size());
    for (    final RangeLocationPair pair : entry.getValue()) {
      locations.add(pair.location);
      ranges.add(pair.range);
    }
    rangesPerIndex.put(entry.getKey(),ranges);
  }
  return new GeoWaveInputSplit(rangesPerIndex,locations.toArray(new String[]{}));
}","private GeoWaveInputSplit toFinalSplit(){
  final Map<Index,List<Range>> rangesPerIndex=new HashMap<Index,List<Range>>();
  final Set<String> locations=new HashSet<String>();
  for (  final Entry<Index,List<RangeLocationPair>> entry : splitInfo.entrySet()) {
    final List<Range> ranges=new ArrayList<Range>(entry.getValue().size());
    for (    final RangeLocationPair pair : entry.getValue()) {
      locations.add(pair.location);
      ranges.add(pair.range);
    }
    rangesPerIndex.put(entry.getKey(),ranges);
  }
  return new GeoWaveInputSplit(rangesPerIndex,locations.toArray(new String[locations.size()]));
}",0.9787581699346404
113103,"/** 
 * Creates a new expanding filter. 
 * @param expandMinX the distance to expand the box X dimension leftwards
 * @param expandMaxX the distance to expand the box X dimension rightwards
 * @param expandMinY the distance to expand the box Y dimension downwards
 * @param expandMaxY the distance to expand the box Y dimension upwards
 */
public BBOXExpandingFilterVisitor(double expandMinX,double expandMaxX,double expandMinY,double expandMaxY){
  this.expandMinX=expandMinX;
  this.expandMaxX=expandMaxX;
  this.expandMinY=expandMinY;
  this.expandMaxY=expandMaxX;
}","/** 
 * Creates a new expanding filter. 
 * @param expandMinX the distance to expand the box X dimension leftwards
 * @param expandMaxX the distance to expand the box X dimension rightwards
 * @param expandMinY the distance to expand the box Y dimension downwards
 * @param expandMaxY the distance to expand the box Y dimension upwards
 */
public BBOXExpandingFilterVisitor(double expandMinX,double expandMaxX,double expandMinY,double expandMaxY){
  this.expandMinX=expandMinX;
  this.expandMaxX=expandMaxX;
  this.expandMinY=expandMinY;
  this.expandMaxY=expandMaxY;
}",0.9982425307557118
113104,"private float[][] extractGrid(float[][] grid,int xBase,int yBase,int xSize,int ySize){
  float[][] gridExtract=new float[xSize][ySize];
  for (int i=0; i < xSize; i++) {
    for (int j=0; j < ySize; j++) {
      gridExtract[i][j]=grid[xBase + i][yBase + j];
    }
  }
  return gridExtract;
}","private float[][] extractGrid(float[][] grid,int xBase,int yBase,int xSize,int ySize){
  float[][] gridExtract=new float[xSize][ySize];
  for (int i=0; i < xSize; i++) {
    System.arraycopy(grid[xBase + i],yBase,gridExtract[i],0,ySize);
  }
  return gridExtract;
}",0.6834532374100719
113105,"@Override public void map(final GeoWaveInputKey key,final SimpleFeatureImpl value,final Context context) throws IOException, InterruptedException {
  final Integer pointId=Integer.parseInt(value.getAttribute(""String_Node_Str"").toString());
  final Geometry geometry=(Geometry)value.getDefaultGeometry();
  final Coordinate coord=geometry.getCentroid().getCoordinate();
  final DataPoint dp=new DataPoint(pointId,coord.x,coord.y,-1,false);
  final String outputRowId=context.getConfiguration().get(""String_Node_Str"");
  DataPoint assignedCentroid=null;
  double leastDist=Double.MAX_VALUE;
  for (  final DataPoint centroid : centroids) {
    final double dist=centroid.calculateDistance(dp);
    if (dist < leastDist) {
      assignedCentroid=centroid;
      leastDist=dist;
    }
  }
  final Mutation m=new Mutation(outputRowId);
  m.put(new Text(new Integer(assignedCentroid.id).toString()),new Text(pointId.toString()),new Value(coord.toString().getBytes()));
  context.write(outKey,m);
}","@Override public void map(final GeoWaveInputKey key,final SimpleFeatureImpl value,final Context context) throws IOException, InterruptedException {
  final Integer pointId=Integer.parseInt(value.getAttribute(""String_Node_Str"").toString());
  final Geometry geometry=(Geometry)value.getDefaultGeometry();
  final Coordinate coord=geometry.getCentroid().getCoordinate();
  final DataPoint dp=new DataPoint(pointId,coord.x,coord.y,-1,false);
  final String outputRowId=context.getConfiguration().get(""String_Node_Str"");
  DataPoint assignedCentroid=null;
  double leastDist=Double.MAX_VALUE;
  for (  final DataPoint centroid : centroids) {
    final double dist=centroid.calculateDistance(dp);
    if (dist < leastDist) {
      assignedCentroid=centroid;
      leastDist=dist;
    }
  }
  final Mutation m=new Mutation(outputRowId);
  m.put(new Text(assignedCentroid.id.toString()),new Text(pointId.toString()),new Value(coord.toString().getBytes()));
  context.write(outKey,m);
}",0.9933976637887252
113106,"@Override protected void reduce(final DoubleWritable key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  if (key.get() < 0) {
    final double prevMax=-key.get();
    if (prevMax > max) {
      max=prevMax;
    }
  }
 else {
    final double normalized=key.get() / max;
    for (    final LongWritable v : values) {
      final long cellIndex=v.get() / numLevels;
      final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
      builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
      builder.add(key.get());
      builder.add(normalized);
      inc+=(1.0 / totalKeys);
      builder.add(inc);
      final SimpleFeature feature=builder.buildFeature(new Long(cellIndex).toString());
      dataStore.ingest(adapter,index,feature);
    }
  }
}","@Override protected void reduce(final DoubleWritable key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  if (key.get() < 0) {
    final double prevMax=-key.get();
    if (prevMax > max) {
      max=prevMax;
    }
  }
 else {
    final double normalized=key.get() / max;
    for (    final LongWritable v : values) {
      final long cellIndex=v.get() / numLevels;
      final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
      builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
      builder.add(key.get());
      builder.add(normalized);
      inc+=(1.0 / totalKeys);
      builder.add(inc);
      final SimpleFeature feature=builder.buildFeature(Long.toString(cellIndex));
      dataStore.ingest(adapter,index,feature);
    }
  }
}",0.9706227967097532
113107,"protected void collectStats(final LongWritable key,final double sum,final Context context){
  final long level=(key.get() % numLevels) + minLevel;
  Double max=maxPerLevel.get(level);
  if ((max == null) || (sum > max)) {
    max=sum;
    maxPerLevel.put(level,max);
  }
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","protected void collectStats(final LongWritable key,final double sum,final Context context){
  final long level=(key.get() % numLevels) + minLevel;
  Double max=maxPerLevel.get(level);
  if ((max == null) || (sum > max)) {
    max=sum;
    maxPerLevel.put(level,max);
  }
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9405405405405406
113108,"@Override protected void reduce(final ComparisonCellData key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  for (  final LongWritable v : values) {
    final long cellIndex=v.get() / numLevels;
    final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
    builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
    builder.add(key.getSummerPercentile());
    builder.add(key.getWinterPercentile());
    builder.add(key.getCombinedPercentile());
    inc+=(1.0 / totalKeys);
    builder.add(inc);
    final SimpleFeature feature=builder.buildFeature(new Long(cellIndex).toString());
    dataStore.ingest(adapter,index,feature);
  }
}","@Override protected void reduce(final ComparisonCellData key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  for (  final LongWritable v : values) {
    final long cellIndex=v.get() / numLevels;
    final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
    builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
    builder.add(key.getSummerPercentile());
    builder.add(key.getWinterPercentile());
    builder.add(key.getCombinedPercentile());
    inc+=(1.0 / totalKeys);
    builder.add(inc);
    final SimpleFeature feature=builder.buildFeature(Long.toString(cellIndex));
    dataStore.ingest(adapter,index,feature);
  }
}",0.9687924016282226
113109,"@Override protected void collectStats(final LongWritable key,final double sum,final org.apache.hadoop.mapreduce.Reducer.Context context){
  long positiveKey=key.get();
  boolean isWinter=false;
  if (positiveKey < 0) {
    positiveKey=-positiveKey - 1;
    isWinter=true;
  }
  final long level=(positiveKey % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"" + (isWinter ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","@Override protected void collectStats(final LongWritable key,final double sum,final org.apache.hadoop.mapreduce.Reducer.Context context){
  long positiveKey=key.get();
  boolean isWinter=false;
  if (positiveKey < 0) {
    positiveKey=-positiveKey - 1;
    isWinter=true;
  }
  final long level=(positiveKey % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"" + (isWinter ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9643564356435644
113110,"protected void collectStats(final long key,final Context context){
  final long level=(key % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","protected void collectStats(final long key,final Context context){
  final long level=(key % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9627906976744186
113111,"private static Object convertTrueFalseStringToBoolean(Object obj){
  if (!(obj instanceof Number) && !(obj instanceof Boolean)) {
    if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=new Boolean(true);
    }
 else     if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=new Boolean(false);
    }
  }
  return obj;
}","private static Object convertTrueFalseStringToBoolean(Object obj){
  if (!(obj instanceof Number) && !(obj instanceof Boolean)) {
    if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=Boolean.TRUE;
    }
 else     if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=Boolean.FALSE;
    }
  }
  return obj;
}",0.9564032697547684
113112,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final ByteArrayId other=(ByteArrayId)obj;
  if (!Arrays.equals(id,other.id)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final ByteArrayId other=(ByteArrayId)obj;
  return Arrays.equals(id,other.id);
}",0.9038785834738616
113113,"@Override public BinRange[] getNormalizedRanges(final NumericData range){
  final Calendar startEpoch=Calendar.getInstance(TimeZone.getTimeZone(timezone));
  final long binSizeMillis=getBinSizeMillis();
  startEpoch.setTimeInMillis((long)range.getMin());
  setToEpoch(startEpoch);
  final long startEpochMillis=startEpoch.getTimeInMillis();
  long epochIterator=startEpochMillis;
  final List<BinRange> bins=new ArrayList<BinRange>();
  boolean firstBin=((long)range.getMin() != startEpochMillis);
  boolean lastBin=false;
  do {
    final Calendar nextEpochCal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    nextEpochCal.setTimeInMillis(epochIterator + (long)(binSizeMillis * 1.5));
    setToEpoch(nextEpochCal);
    final long nextEpoch=nextEpochCal.getTimeInMillis();
    final long maxOfBin=nextEpoch - 1;
    final Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    cal.setTimeInMillis(epochIterator);
    long startMillis, endMillis;
    boolean fullExtent;
    if ((long)range.getMax() <= maxOfBin) {
      lastBin=true;
      endMillis=(long)range.getMax();
      fullExtent=range.getMax() == maxOfBin;
    }
 else {
      endMillis=maxOfBin;
      fullExtent=!firstBin;
    }
    if (firstBin) {
      startMillis=(long)range.getMin();
      firstBin=false;
    }
 else {
      startMillis=epochIterator;
    }
    bins.add(new BinRange(getBinId(cal),startMillis - epochIterator,endMillis - epochIterator,fullExtent));
    epochIterator=nextEpoch;
  }
 while (!lastBin);
  return bins.toArray(new BinRange[]{});
}","@Override public BinRange[] getNormalizedRanges(final NumericData range){
  final Calendar startEpoch=Calendar.getInstance(TimeZone.getTimeZone(timezone));
  final long binSizeMillis=getBinSizeMillis();
  startEpoch.setTimeInMillis((long)range.getMin());
  setToEpoch(startEpoch);
  final long startEpochMillis=startEpoch.getTimeInMillis();
  long epochIterator=startEpochMillis;
  final List<BinRange> bins=new ArrayList<BinRange>();
  boolean firstBin=((long)range.getMin() != startEpochMillis);
  boolean lastBin=false;
  do {
    final Calendar nextEpochCal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    nextEpochCal.setTimeInMillis(epochIterator + (long)(binSizeMillis * 1.5));
    setToEpoch(nextEpochCal);
    final long nextEpoch=nextEpochCal.getTimeInMillis();
    final long maxOfBin=nextEpoch - 1;
    final Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    cal.setTimeInMillis(epochIterator);
    long startMillis, endMillis;
    boolean fullExtent;
    if ((long)range.getMax() <= maxOfBin) {
      lastBin=true;
      endMillis=(long)range.getMax();
      fullExtent=range.getMax() == maxOfBin;
    }
 else {
      endMillis=maxOfBin;
      fullExtent=!firstBin;
    }
    if (firstBin) {
      startMillis=(long)range.getMin();
      firstBin=false;
    }
 else {
      startMillis=epochIterator;
    }
    bins.add(new BinRange(getBinId(cal),startMillis - epochIterator,endMillis - epochIterator,fullExtent));
    epochIterator=nextEpoch;
  }
 while (!lastBin);
  return bins.toArray(new BinRange[bins.size()]);
}",0.993900481540931
113114,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final TieredSFCIndexStrategy other=(TieredSFCIndexStrategy)obj;
  if (!Arrays.equals(baseDefinitions,other.baseDefinitions)) {
    return false;
  }
  if (!Arrays.equals(orderedSfcs,other.orderedSfcs)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final TieredSFCIndexStrategy other=(TieredSFCIndexStrategy)obj;
  if (!Arrays.equals(baseDefinitions,other.baseDefinitions)) {
    return false;
  }
  return Arrays.equals(orderedSfcs,other.orderedSfcs);
}",0.9347568208778172
113115,"@Test public void testTimeDefinitionMinBinByMonth(){
  final double expectedMin=0.0;
  final double expectedMax=2678399999.0;
  final Calendar calendar=Calendar.getInstance();
  calendar.set(Calendar.MONTH,6);
  calendar.set(Calendar.DATE,1);
  calendar.set(Calendar.HOUR_OF_DAY,00);
  calendar.set(Calendar.MINUTE,00);
  calendar.set(Calendar.SECOND,0);
  calendar.set(Calendar.MILLISECOND,000);
  BinningStrategy bin=getStrategyByUnit(Unit.MONTH);
  Assert.assertEquals(expectedMin,bin.getBinMin(),DELTA);
  Assert.assertEquals(expectedMax,bin.getBinMax(),DELTA);
  Assert.assertEquals(bin.getBinMin(),bin.getBinnedValue(calendar.getTimeInMillis()).getNormalizedValue(),DELTA);
}","@Test public void testTimeDefinitionMinBinByMonth(){
  final double expectedMin=0.0;
  final double expectedMax=2678399999.0;
  final Calendar calendar=Calendar.getInstance();
  calendar.set(Calendar.MONTH,6);
  calendar.set(Calendar.DATE,1);
  calendar.set(Calendar.HOUR_OF_DAY,0);
  calendar.set(Calendar.MINUTE,0);
  calendar.set(Calendar.SECOND,0);
  calendar.set(Calendar.MILLISECOND,0);
  BinningStrategy bin=getStrategyByUnit(Unit.MONTH);
  Assert.assertEquals(expectedMin,bin.getBinMin(),DELTA);
  Assert.assertEquals(expectedMax,bin.getBinMax(),DELTA);
  Assert.assertEquals(bin.getBinMin(),bin.getBinnedValue(calendar.getTimeInMillis()).getNormalizedValue(),DELTA);
}",0.9970544918998528
113116,"@Override public Mutation next(){
  boolean ignoreLastEntry=false;
  if (!pendingOutput.isEmpty()) {
    return pendingOutput.removeFirst();
  }
 else   if (rawIt.hasNext()) {
    while (rawIt.hasNext()) {
      Entry<Key,Value> entry=rawIt.next();
      addEntry(lastEntries,entry);
      byte[] currentRowID=entry.getKey().getRow().getBytes();
      if (rowID == null || Arrays.equals(rowID,currentRowID)) {
        rowID=currentRowID;
        continue;
      }
 else {
        rowID=currentRowID;
        ignoreLastEntry=true;
        break;
      }
    }
  }
  int countDown=lastEntries.size();
  Iterator<Entry<Key,Value>> it=lastEntries.iterator();
  while (it.hasNext()) {
    Entry<Key,Value> lastEntry=it.next();
    countDown--;
    if (ignoreLastEntry && countDown == 0)     break;
    Mutation mutation=new Mutation(lastEntry.getKey().getRow());
    if (lastEntry.getKey().isDeleted()) {
      mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
    }
 else {
      mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
    }
    pendingOutput.addLast(mutation);
    it.remove();
  }
  return pendingOutput.removeFirst();
}","@Override public Mutation next(){
  boolean ignoreLastEntry=false;
  if (!pendingOutput.isEmpty()) {
    return pendingOutput.removeFirst();
  }
 else   if (rawIt.hasNext()) {
    while (rawIt.hasNext()) {
      Entry<Key,Value> entry=rawIt.next();
      addEntry(lastEntries,entry);
      byte[] currentRowID=entry.getKey().getRow().getBytes();
      if (rowID == null || Arrays.equals(rowID,currentRowID)) {
        rowID=currentRowID;
      }
 else {
        rowID=currentRowID;
        ignoreLastEntry=true;
        break;
      }
    }
  }
  int countDown=lastEntries.size();
  Iterator<Entry<Key,Value>> it=lastEntries.iterator();
  while (it.hasNext()) {
    Entry<Key,Value> lastEntry=it.next();
    countDown--;
    if (ignoreLastEntry && countDown == 0)     break;
    Mutation mutation=new Mutation(lastEntry.getKey().getRow());
    if (lastEntry.getKey().isDeleted()) {
      mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
    }
 else {
      mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
    }
    pendingOutput.addLast(mutation);
    it.remove();
  }
  return pendingOutput.removeFirst();
}",0.9933774834437086
113117,"public void transform(){
  try {
    final Iterator<Entry<Key,Value>> rawIt=scanner.iterator();
    Writer writer=accumuloOperations.createWriter(tableName);
    writer.write(new Iterable<Mutation>(){
      @Override public Iterator<Mutation> iterator(){
        return new Iterator<Mutation>(){
          List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
          LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
          byte[] rowID=null;
          @Override public boolean hasNext(){
            return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
          }
          @Override public Mutation next(){
            boolean ignoreLastEntry=false;
            if (!pendingOutput.isEmpty()) {
              return pendingOutput.removeFirst();
            }
 else             if (rawIt.hasNext()) {
              while (rawIt.hasNext()) {
                Entry<Key,Value> entry=rawIt.next();
                addEntry(lastEntries,entry);
                byte[] currentRowID=entry.getKey().getRow().getBytes();
                if (rowID == null || Arrays.equals(rowID,currentRowID)) {
                  rowID=currentRowID;
                  continue;
                }
 else {
                  rowID=currentRowID;
                  ignoreLastEntry=true;
                  break;
                }
              }
            }
            int countDown=lastEntries.size();
            Iterator<Entry<Key,Value>> it=lastEntries.iterator();
            while (it.hasNext()) {
              Entry<Key,Value> lastEntry=it.next();
              countDown--;
              if (ignoreLastEntry && countDown == 0)               break;
              Mutation mutation=new Mutation(lastEntry.getKey().getRow());
              if (lastEntry.getKey().isDeleted()) {
                mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
              }
 else {
                mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
              }
              pendingOutput.addLast(mutation);
              it.remove();
            }
            return pendingOutput.removeFirst();
          }
          @Override public void remove(){
          }
        }
;
      }
    }
);
    writer.close();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
}","public void transform(){
  try {
    final Iterator<Entry<Key,Value>> rawIt=scanner.iterator();
    Writer writer=accumuloOperations.createWriter(tableName);
    writer.write(new Iterable<Mutation>(){
      @Override public Iterator<Mutation> iterator(){
        return new Iterator<Mutation>(){
          List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
          LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
          byte[] rowID=null;
          @Override public boolean hasNext(){
            return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
          }
          @Override public Mutation next(){
            boolean ignoreLastEntry=false;
            if (!pendingOutput.isEmpty()) {
              return pendingOutput.removeFirst();
            }
 else             if (rawIt.hasNext()) {
              while (rawIt.hasNext()) {
                Entry<Key,Value> entry=rawIt.next();
                addEntry(lastEntries,entry);
                byte[] currentRowID=entry.getKey().getRow().getBytes();
                if (rowID == null || Arrays.equals(rowID,currentRowID)) {
                  rowID=currentRowID;
                }
 else {
                  rowID=currentRowID;
                  ignoreLastEntry=true;
                  break;
                }
              }
            }
            int countDown=lastEntries.size();
            Iterator<Entry<Key,Value>> it=lastEntries.iterator();
            while (it.hasNext()) {
              Entry<Key,Value> lastEntry=it.next();
              countDown--;
              if (ignoreLastEntry && countDown == 0)               break;
              Mutation mutation=new Mutation(lastEntry.getKey().getRow());
              if (lastEntry.getKey().isDeleted()) {
                mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
              }
 else {
                mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
              }
              pendingOutput.addLast(mutation);
              it.remove();
            }
            return pendingOutput.removeFirst();
          }
          @Override public void remove(){
          }
        }
;
      }
    }
);
    writer.close();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
}",0.994486018117369
113118,"@Override public Iterator<Mutation> iterator(){
  return new Iterator<Mutation>(){
    List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
    LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
    byte[] rowID=null;
    @Override public boolean hasNext(){
      return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
    }
    @Override public Mutation next(){
      boolean ignoreLastEntry=false;
      if (!pendingOutput.isEmpty()) {
        return pendingOutput.removeFirst();
      }
 else       if (rawIt.hasNext()) {
        while (rawIt.hasNext()) {
          Entry<Key,Value> entry=rawIt.next();
          addEntry(lastEntries,entry);
          byte[] currentRowID=entry.getKey().getRow().getBytes();
          if (rowID == null || Arrays.equals(rowID,currentRowID)) {
            rowID=currentRowID;
            continue;
          }
 else {
            rowID=currentRowID;
            ignoreLastEntry=true;
            break;
          }
        }
      }
      int countDown=lastEntries.size();
      Iterator<Entry<Key,Value>> it=lastEntries.iterator();
      while (it.hasNext()) {
        Entry<Key,Value> lastEntry=it.next();
        countDown--;
        if (ignoreLastEntry && countDown == 0)         break;
        Mutation mutation=new Mutation(lastEntry.getKey().getRow());
        if (lastEntry.getKey().isDeleted()) {
          mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
        }
 else {
          mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
        }
        pendingOutput.addLast(mutation);
        it.remove();
      }
      return pendingOutput.removeFirst();
    }
    @Override public void remove(){
    }
  }
;
}","@Override public Iterator<Mutation> iterator(){
  return new Iterator<Mutation>(){
    List<Entry<Key,Value>> lastEntries=new ArrayList<Entry<Key,Value>>();
    LinkedList<Mutation> pendingOutput=new LinkedList<Mutation>();
    byte[] rowID=null;
    @Override public boolean hasNext(){
      return !pendingOutput.isEmpty() || rawIt.hasNext() || !lastEntries.isEmpty();
    }
    @Override public Mutation next(){
      boolean ignoreLastEntry=false;
      if (!pendingOutput.isEmpty()) {
        return pendingOutput.removeFirst();
      }
 else       if (rawIt.hasNext()) {
        while (rawIt.hasNext()) {
          Entry<Key,Value> entry=rawIt.next();
          addEntry(lastEntries,entry);
          byte[] currentRowID=entry.getKey().getRow().getBytes();
          if (rowID == null || Arrays.equals(rowID,currentRowID)) {
            rowID=currentRowID;
          }
 else {
            rowID=currentRowID;
            ignoreLastEntry=true;
            break;
          }
        }
      }
      int countDown=lastEntries.size();
      Iterator<Entry<Key,Value>> it=lastEntries.iterator();
      while (it.hasNext()) {
        Entry<Key,Value> lastEntry=it.next();
        countDown--;
        if (ignoreLastEntry && countDown == 0)         break;
        Mutation mutation=new Mutation(lastEntry.getKey().getRow());
        if (lastEntry.getKey().isDeleted()) {
          mutation.putDelete(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getKey().getTimestamp());
        }
 else {
          mutation.put(lastEntry.getKey().getColumnFamily(),lastEntry.getKey().getColumnQualifier(),lastEntry.getKey().getColumnVisibilityParsed(),lastEntry.getValue());
        }
        pendingOutput.addLast(mutation);
        it.remove();
      }
      return pendingOutput.removeFirst();
    }
    @Override public void remove(){
    }
  }
;
}",0.9943181818181818
113119,"private static DataAdapter<?>[] getDataAdaptersInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.DATA_ADAPTER) + ""String_Node_Str"");
  if (input != null) {
    final List<DataAdapter<?>> adapters=new ArrayList<DataAdapter<?>>(input.size());
    for (    final String dataAdapterStr : input.values()) {
      final byte[] dataAdapterBytes=ByteArrayUtils.byteArrayFromString(dataAdapterStr);
      adapters.add(PersistenceUtils.fromBinary(dataAdapterBytes,DataAdapter.class));
    }
    return adapters.toArray(new DataAdapter[]{});
  }
  return new DataAdapter[]{};
}","private static DataAdapter<?>[] getDataAdaptersInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.DATA_ADAPTER) + ""String_Node_Str"");
  if (input != null) {
    final List<DataAdapter<?>> adapters=new ArrayList<DataAdapter<?>>(input.size());
    for (    final String dataAdapterStr : input.values()) {
      final byte[] dataAdapterBytes=ByteArrayUtils.byteArrayFromString(dataAdapterStr);
      adapters.add(PersistenceUtils.fromBinary(dataAdapterBytes,DataAdapter.class));
    }
    return adapters.toArray(new DataAdapter[adapters.size()]);
  }
  return new DataAdapter[]{};
}",0.988036593947924
113120,"private static Index[] getIndicesInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.INDEX) + ""String_Node_Str"");
  if (input != null) {
    final List<Index> indices=new ArrayList<Index>(input.size());
    for (    final String indexStr : input.values()) {
      final byte[] indexBytes=ByteArrayUtils.byteArrayFromString(indexStr);
      indices.add(PersistenceUtils.fromBinary(indexBytes,Index.class));
    }
    return indices.toArray(new Index[]{});
  }
  return new Index[]{};
}","private static Index[] getIndicesInternal(final Class<?> implementingClass,final Configuration configuration){
  final Map<String,String> input=configuration.getValByRegex(enumToConfKey(implementingClass,GeoWaveMetaStore.INDEX) + ""String_Node_Str"");
  if (input != null) {
    final List<Index> indices=new ArrayList<Index>(input.size());
    for (    final String indexStr : input.values()) {
      final byte[] indexBytes=ByteArrayUtils.byteArrayFromString(indexStr);
      indices.add(PersistenceUtils.fromBinary(indexBytes,Index.class));
    }
    return indices.toArray(new Index[indices.size()]);
  }
  return new Index[]{};
}",0.987220447284345
113121,"private GeoWaveInputSplit toFinalSplit(){
  final Map<Index,List<Range>> rangesPerIndex=new HashMap<Index,List<Range>>();
  final Set<String> locations=new HashSet<String>();
  for (  final Entry<Index,List<RangeLocationPair>> entry : splitInfo.entrySet()) {
    final List<Range> ranges=new ArrayList<Range>(entry.getValue().size());
    for (    final RangeLocationPair pair : entry.getValue()) {
      locations.add(pair.location);
      ranges.add(pair.range);
    }
    rangesPerIndex.put(entry.getKey(),ranges);
  }
  return new GeoWaveInputSplit(rangesPerIndex,locations.toArray(new String[]{}));
}","private GeoWaveInputSplit toFinalSplit(){
  final Map<Index,List<Range>> rangesPerIndex=new HashMap<Index,List<Range>>();
  final Set<String> locations=new HashSet<String>();
  for (  final Entry<Index,List<RangeLocationPair>> entry : splitInfo.entrySet()) {
    final List<Range> ranges=new ArrayList<Range>(entry.getValue().size());
    for (    final RangeLocationPair pair : entry.getValue()) {
      locations.add(pair.location);
      ranges.add(pair.range);
    }
    rangesPerIndex.put(entry.getKey(),ranges);
  }
  return new GeoWaveInputSplit(rangesPerIndex,locations.toArray(new String[locations.size()]));
}",0.9787581699346404
113122,"/** 
 * Creates a new expanding filter. 
 * @param expandMinX the distance to expand the box X dimension leftwards
 * @param expandMaxX the distance to expand the box X dimension rightwards
 * @param expandMinY the distance to expand the box Y dimension downwards
 * @param expandMaxY the distance to expand the box Y dimension upwards
 */
public BBOXExpandingFilterVisitor(double expandMinX,double expandMaxX,double expandMinY,double expandMaxY){
  this.expandMinX=expandMinX;
  this.expandMaxX=expandMaxX;
  this.expandMinY=expandMinY;
  this.expandMaxY=expandMaxX;
}","/** 
 * Creates a new expanding filter. 
 * @param expandMinX the distance to expand the box X dimension leftwards
 * @param expandMaxX the distance to expand the box X dimension rightwards
 * @param expandMinY the distance to expand the box Y dimension downwards
 * @param expandMaxY the distance to expand the box Y dimension upwards
 */
public BBOXExpandingFilterVisitor(double expandMinX,double expandMaxX,double expandMinY,double expandMaxY){
  this.expandMinX=expandMinX;
  this.expandMaxX=expandMaxX;
  this.expandMinY=expandMinY;
  this.expandMaxY=expandMaxY;
}",0.9982425307557118
113123,"private float[][] extractGrid(float[][] grid,int xBase,int yBase,int xSize,int ySize){
  float[][] gridExtract=new float[xSize][ySize];
  for (int i=0; i < xSize; i++) {
    for (int j=0; j < ySize; j++) {
      gridExtract[i][j]=grid[xBase + i][yBase + j];
    }
  }
  return gridExtract;
}","private float[][] extractGrid(float[][] grid,int xBase,int yBase,int xSize,int ySize){
  float[][] gridExtract=new float[xSize][ySize];
  for (int i=0; i < xSize; i++) {
    System.arraycopy(grid[xBase + i],yBase,gridExtract[i],0,ySize);
  }
  return gridExtract;
}",0.6834532374100719
113124,"@Override public void map(final GeoWaveInputKey key,final SimpleFeatureImpl value,final Context context) throws IOException, InterruptedException {
  final Integer pointId=Integer.parseInt(value.getAttribute(""String_Node_Str"").toString());
  final Geometry geometry=(Geometry)value.getDefaultGeometry();
  final Coordinate coord=geometry.getCentroid().getCoordinate();
  final DataPoint dp=new DataPoint(pointId,coord.x,coord.y,-1,false);
  final String outputRowId=context.getConfiguration().get(""String_Node_Str"");
  DataPoint assignedCentroid=null;
  double leastDist=Double.MAX_VALUE;
  for (  final DataPoint centroid : centroids) {
    final double dist=centroid.calculateDistance(dp);
    if (dist < leastDist) {
      assignedCentroid=centroid;
      leastDist=dist;
    }
  }
  final Mutation m=new Mutation(outputRowId);
  m.put(new Text(new Integer(assignedCentroid.id).toString()),new Text(pointId.toString()),new Value(coord.toString().getBytes()));
  context.write(outKey,m);
}","@Override public void map(final GeoWaveInputKey key,final SimpleFeatureImpl value,final Context context) throws IOException, InterruptedException {
  final Integer pointId=Integer.parseInt(value.getAttribute(""String_Node_Str"").toString());
  final Geometry geometry=(Geometry)value.getDefaultGeometry();
  final Coordinate coord=geometry.getCentroid().getCoordinate();
  final DataPoint dp=new DataPoint(pointId,coord.x,coord.y,-1,false);
  final String outputRowId=context.getConfiguration().get(""String_Node_Str"");
  DataPoint assignedCentroid=null;
  double leastDist=Double.MAX_VALUE;
  for (  final DataPoint centroid : centroids) {
    final double dist=centroid.calculateDistance(dp);
    if (dist < leastDist) {
      assignedCentroid=centroid;
      leastDist=dist;
    }
  }
  final Mutation m=new Mutation(outputRowId);
  m.put(new Text(assignedCentroid.id.toString()),new Text(pointId.toString()),new Value(coord.toString().getBytes()));
  context.write(outKey,m);
}",0.9933976637887252
113125,"@Override protected void reduce(final DoubleWritable key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  if (key.get() < 0) {
    final double prevMax=-key.get();
    if (prevMax > max) {
      max=prevMax;
    }
  }
 else {
    final double normalized=key.get() / max;
    for (    final LongWritable v : values) {
      final long cellIndex=v.get() / numLevels;
      final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
      builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
      builder.add(key.get());
      builder.add(normalized);
      inc+=(1.0 / totalKeys);
      builder.add(inc);
      final SimpleFeature feature=builder.buildFeature(new Long(cellIndex).toString());
      dataStore.ingest(adapter,index,feature);
    }
  }
}","@Override protected void reduce(final DoubleWritable key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  if (key.get() < 0) {
    final double prevMax=-key.get();
    if (prevMax > max) {
      max=prevMax;
    }
  }
 else {
    final double normalized=key.get() / max;
    for (    final LongWritable v : values) {
      final long cellIndex=v.get() / numLevels;
      final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
      builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
      builder.add(key.get());
      builder.add(normalized);
      inc+=(1.0 / totalKeys);
      builder.add(inc);
      final SimpleFeature feature=builder.buildFeature(Long.toString(cellIndex));
      dataStore.ingest(adapter,index,feature);
    }
  }
}",0.9706227967097532
113126,"protected void collectStats(final LongWritable key,final double sum,final Context context){
  final long level=(key.get() % numLevels) + minLevel;
  Double max=maxPerLevel.get(level);
  if ((max == null) || (sum > max)) {
    max=sum;
    maxPerLevel.put(level,max);
  }
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","protected void collectStats(final LongWritable key,final double sum,final Context context){
  final long level=(key.get() % numLevels) + minLevel;
  Double max=maxPerLevel.get(level);
  if ((max == null) || (sum > max)) {
    max=sum;
    maxPerLevel.put(level,max);
  }
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9405405405405406
113127,"@Override protected void reduce(final ComparisonCellData key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  for (  final LongWritable v : values) {
    final long cellIndex=v.get() / numLevels;
    final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
    builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
    builder.add(key.getSummerPercentile());
    builder.add(key.getWinterPercentile());
    builder.add(key.getCombinedPercentile());
    inc+=(1.0 / totalKeys);
    builder.add(inc);
    final SimpleFeature feature=builder.buildFeature(new Long(cellIndex).toString());
    dataStore.ingest(adapter,index,feature);
  }
}","@Override protected void reduce(final ComparisonCellData key,final Iterable<LongWritable> values,final Context context) throws IOException, InterruptedException {
  for (  final LongWritable v : values) {
    final long cellIndex=v.get() / numLevels;
    final Point2d[] bbox=fromIndexToLL_UR(cellIndex);
    builder.add(GeometryUtils.GEOMETRY_FACTORY.toGeometry(new Envelope(bbox[0].x,bbox[1].x,bbox[0].y,bbox[1].y)));
    builder.add(key.getSummerPercentile());
    builder.add(key.getWinterPercentile());
    builder.add(key.getCombinedPercentile());
    inc+=(1.0 / totalKeys);
    builder.add(inc);
    final SimpleFeature feature=builder.buildFeature(Long.toString(cellIndex));
    dataStore.ingest(adapter,index,feature);
  }
}",0.9687924016282226
113128,"@Override protected void collectStats(final LongWritable key,final double sum,final org.apache.hadoop.mapreduce.Reducer.Context context){
  long positiveKey=key.get();
  boolean isWinter=false;
  if (positiveKey < 0) {
    positiveKey=-positiveKey - 1;
    isWinter=true;
  }
  final long level=(positiveKey % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"" + (isWinter ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","@Override protected void collectStats(final LongWritable key,final double sum,final org.apache.hadoop.mapreduce.Reducer.Context context){
  long positiveKey=key.get();
  boolean isWinter=false;
  if (positiveKey < 0) {
    positiveKey=-positiveKey - 1;
    isWinter=true;
  }
  final long level=(positiveKey % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"" + (isWinter ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9643564356435644
113129,"protected void collectStats(final long key,final Context context){
  final long level=(key % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + new Long(level).toString()).increment(1);
}","protected void collectStats(final long key,final Context context){
  final long level=(key % numLevels) + minLevel;
  context.getCounter(""String_Node_Str"",""String_Node_Str"" + Long.toString(level)).increment(1);
}",0.9627906976744186
113130,"private static Object convertTrueFalseStringToBoolean(Object obj){
  if (!(obj instanceof Number) && !(obj instanceof Boolean)) {
    if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=new Boolean(true);
    }
 else     if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=new Boolean(false);
    }
  }
  return obj;
}","private static Object convertTrueFalseStringToBoolean(Object obj){
  if (!(obj instanceof Number) && !(obj instanceof Boolean)) {
    if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=Boolean.TRUE;
    }
 else     if (obj.toString().trim().toLowerCase().equals(""String_Node_Str"")) {
      obj=Boolean.FALSE;
    }
  }
  return obj;
}",0.9564032697547684
113131,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final ByteArrayId other=(ByteArrayId)obj;
  if (!Arrays.equals(id,other.id)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final ByteArrayId other=(ByteArrayId)obj;
  return Arrays.equals(id,other.id);
}",0.9038785834738616
113132,"@Override public BinRange[] getNormalizedRanges(final NumericData range){
  final Calendar startEpoch=Calendar.getInstance(TimeZone.getTimeZone(timezone));
  final long binSizeMillis=getBinSizeMillis();
  startEpoch.setTimeInMillis((long)range.getMin());
  setToEpoch(startEpoch);
  final long startEpochMillis=startEpoch.getTimeInMillis();
  long epochIterator=startEpochMillis;
  final List<BinRange> bins=new ArrayList<BinRange>();
  boolean firstBin=((long)range.getMin() != startEpochMillis);
  boolean lastBin=false;
  do {
    final Calendar nextEpochCal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    nextEpochCal.setTimeInMillis(epochIterator + (long)(binSizeMillis * 1.5));
    setToEpoch(nextEpochCal);
    final long nextEpoch=nextEpochCal.getTimeInMillis();
    final long maxOfBin=nextEpoch - 1;
    final Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    cal.setTimeInMillis(epochIterator);
    long startMillis, endMillis;
    boolean fullExtent;
    if ((long)range.getMax() <= maxOfBin) {
      lastBin=true;
      endMillis=(long)range.getMax();
      fullExtent=range.getMax() == maxOfBin;
    }
 else {
      endMillis=maxOfBin;
      fullExtent=!firstBin;
    }
    if (firstBin) {
      startMillis=(long)range.getMin();
      firstBin=false;
    }
 else {
      startMillis=epochIterator;
    }
    bins.add(new BinRange(getBinId(cal),startMillis - epochIterator,endMillis - epochIterator,fullExtent));
    epochIterator=nextEpoch;
  }
 while (!lastBin);
  return bins.toArray(new BinRange[]{});
}","@Override public BinRange[] getNormalizedRanges(final NumericData range){
  final Calendar startEpoch=Calendar.getInstance(TimeZone.getTimeZone(timezone));
  final long binSizeMillis=getBinSizeMillis();
  startEpoch.setTimeInMillis((long)range.getMin());
  setToEpoch(startEpoch);
  final long startEpochMillis=startEpoch.getTimeInMillis();
  long epochIterator=startEpochMillis;
  final List<BinRange> bins=new ArrayList<BinRange>();
  boolean firstBin=((long)range.getMin() != startEpochMillis);
  boolean lastBin=false;
  do {
    final Calendar nextEpochCal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    nextEpochCal.setTimeInMillis(epochIterator + (long)(binSizeMillis * 1.5));
    setToEpoch(nextEpochCal);
    final long nextEpoch=nextEpochCal.getTimeInMillis();
    final long maxOfBin=nextEpoch - 1;
    final Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(timezone));
    cal.setTimeInMillis(epochIterator);
    long startMillis, endMillis;
    boolean fullExtent;
    if ((long)range.getMax() <= maxOfBin) {
      lastBin=true;
      endMillis=(long)range.getMax();
      fullExtent=range.getMax() == maxOfBin;
    }
 else {
      endMillis=maxOfBin;
      fullExtent=!firstBin;
    }
    if (firstBin) {
      startMillis=(long)range.getMin();
      firstBin=false;
    }
 else {
      startMillis=epochIterator;
    }
    bins.add(new BinRange(getBinId(cal),startMillis - epochIterator,endMillis - epochIterator,fullExtent));
    epochIterator=nextEpoch;
  }
 while (!lastBin);
  return bins.toArray(new BinRange[bins.size()]);
}",0.993900481540931
113133,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final TieredSFCIndexStrategy other=(TieredSFCIndexStrategy)obj;
  if (!Arrays.equals(baseDefinitions,other.baseDefinitions)) {
    return false;
  }
  if (!Arrays.equals(orderedSfcs,other.orderedSfcs)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final TieredSFCIndexStrategy other=(TieredSFCIndexStrategy)obj;
  if (!Arrays.equals(baseDefinitions,other.baseDefinitions)) {
    return false;
  }
  return Arrays.equals(orderedSfcs,other.orderedSfcs);
}",0.9347568208778172
113134,"@Test public void testTimeDefinitionMinBinByMonth(){
  final double expectedMin=0.0;
  final double expectedMax=2678399999.0;
  final Calendar calendar=Calendar.getInstance();
  calendar.set(Calendar.MONTH,6);
  calendar.set(Calendar.DATE,1);
  calendar.set(Calendar.HOUR_OF_DAY,00);
  calendar.set(Calendar.MINUTE,00);
  calendar.set(Calendar.SECOND,0);
  calendar.set(Calendar.MILLISECOND,000);
  BinningStrategy bin=getStrategyByUnit(Unit.MONTH);
  Assert.assertEquals(expectedMin,bin.getBinMin(),DELTA);
  Assert.assertEquals(expectedMax,bin.getBinMax(),DELTA);
  Assert.assertEquals(bin.getBinMin(),bin.getBinnedValue(calendar.getTimeInMillis()).getNormalizedValue(),DELTA);
}","@Test public void testTimeDefinitionMinBinByMonth(){
  final double expectedMin=0.0;
  final double expectedMax=2678399999.0;
  final Calendar calendar=Calendar.getInstance();
  calendar.set(Calendar.MONTH,6);
  calendar.set(Calendar.DATE,1);
  calendar.set(Calendar.HOUR_OF_DAY,0);
  calendar.set(Calendar.MINUTE,0);
  calendar.set(Calendar.SECOND,0);
  calendar.set(Calendar.MILLISECOND,0);
  BinningStrategy bin=getStrategyByUnit(Unit.MONTH);
  Assert.assertEquals(expectedMin,bin.getBinMin(),DELTA);
  Assert.assertEquals(expectedMax,bin.getBinMax(),DELTA);
  Assert.assertEquals(bin.getBinMin(),bin.getBinnedValue(calendar.getTimeInMillis()).getNormalizedValue(),DELTA);
}",0.9970544918998528
113135,"protected static byte[] getNoDataBinary(final double[][] noDataValuesPerBand){
  if (noDataValuesPerBand != null) {
    int totalBytes=4;
    final List<byte[]> noDataValuesBytes=new ArrayList<byte[]>(noDataValuesPerBand.length);
    for (    final double[] noDataValues : noDataValuesPerBand) {
      final int thisBytes=4 + (noDataValues.length * 8);
      totalBytes+=thisBytes;
      final ByteBuffer noDataBuf=ByteBuffer.allocate(thisBytes);
      noDataBuf.putInt(noDataValues.length);
      for (      final double noDataValue : noDataValues) {
        noDataBuf.putDouble(noDataValue);
      }
      noDataValuesBytes.add(noDataBuf.array());
    }
    final ByteBuffer noDataBuf=ByteBuffer.allocate(totalBytes);
    noDataBuf.putInt(noDataValuesPerBand.length);
    for (    final byte[] noDataValueBytes : noDataValuesBytes) {
      noDataBuf.put(noDataValueBytes);
    }
    return noDataBuf.array();
  }
 else {
    return new byte[]{};
  }
}","protected static byte[] getNoDataBinary(final double[][] noDataValuesPerBand){
  if (noDataValuesPerBand != null) {
    int totalBytes=4;
    final List<byte[]> noDataValuesBytes=new ArrayList<byte[]>(noDataValuesPerBand.length);
    for (    final double[] noDataValues : noDataValuesPerBand) {
      int length=0;
      if (noDataValues != null) {
        length=noDataValues.length;
      }
      final int thisBytes=4 + (length * 8);
      totalBytes+=thisBytes;
      final ByteBuffer noDataBuf=ByteBuffer.allocate(thisBytes);
      noDataBuf.putInt(length);
      if (noDataValues != null) {
        for (        final double noDataValue : noDataValues) {
          noDataBuf.putDouble(noDataValue);
        }
      }
      noDataValuesBytes.add(noDataBuf.array());
    }
    final ByteBuffer noDataBuf=ByteBuffer.allocate(totalBytes);
    noDataBuf.putInt(noDataValuesPerBand.length);
    for (    final byte[] noDataValueBytes : noDataValuesBytes) {
      noDataBuf.put(noDataValueBytes);
    }
    return noDataBuf.array();
  }
 else {
    return new byte[]{};
  }
}",0.9092702169625246
113136,"@Override public byte[] toBinary(){
  final byte[] coverageNameBytes=StringUtils.stringToBinary(coverageName);
  final byte[] sampleModelBinary=getSampleModelBinary(sampleModel);
  final byte[] colorModelBinary=getColorModelBinary(colorModel);
  int metadataBinaryLength=4;
  final List<byte[]> entryBinaries=new ArrayList<byte[]>();
  for (  final Entry<String,String> e : metadata.entrySet()) {
    final byte[] keyBytes=StringUtils.stringToBinary(e.getKey());
    final byte[] valueBytes=StringUtils.stringToBinary(e.getValue());
    final int entryBinaryLength=4 + valueBytes.length + keyBytes.length;
    final ByteBuffer buf=ByteBuffer.allocate(entryBinaryLength);
    buf.putInt(keyBytes.length);
    buf.put(keyBytes);
    buf.put(valueBytes);
    entryBinaries.add(buf.array());
    metadataBinaryLength+=(entryBinaryLength + 4);
  }
  byte[] histogramConfigBinary;
  if (histogramConfig != null) {
    histogramConfigBinary=PersistenceUtils.toBinary(histogramConfig);
  }
 else {
    histogramConfigBinary=new byte[]{};
  }
  final byte[] noDataBinary=getNoDataBinary(noDataValuesPerBand);
  final byte[] backgroundBinary;
  if (backgroundValuesPerBand != null) {
    final int totalBytes=(backgroundValuesPerBand.length * 8);
    final ByteBuffer backgroundBuf=ByteBuffer.allocate(totalBytes);
    for (    final double backgroundValue : backgroundValuesPerBand) {
      backgroundBuf.putDouble(backgroundValue);
    }
    backgroundBinary=backgroundBuf.array();
  }
 else {
    backgroundBinary=new byte[]{};
  }
  byte[] mergeStrategyBinary;
  if (mergeStrategy != null) {
    mergeStrategyBinary=PersistenceUtils.toBinary(mergeStrategy);
  }
 else {
    mergeStrategyBinary=new byte[]{};
  }
  final ByteBuffer buf=ByteBuffer.allocate(coverageNameBytes.length + sampleModelBinary.length + colorModelBinary.length+ metadataBinaryLength+ histogramConfigBinary.length+ noDataBinary.length+ backgroundBinary.length+ 29);
  buf.putInt(tileSize);
  buf.putInt(coverageNameBytes.length);
  buf.put(coverageNameBytes);
  buf.putInt(sampleModelBinary.length);
  buf.put(sampleModelBinary);
  buf.putInt(colorModelBinary.length);
  buf.put(colorModelBinary);
  buf.putInt(entryBinaries.size());
  for (  final byte[] entryBinary : entryBinaries) {
    buf.putInt(entryBinary.length);
    buf.put(entryBinary);
  }
  buf.putInt(histogramConfigBinary.length);
  buf.put(histogramConfigBinary);
  buf.putInt(noDataBinary.length);
  buf.put(noDataBinary);
  buf.putInt(backgroundBinary.length);
  buf.put(backgroundBinary);
  buf.putInt(mergeStrategyBinary.length);
  buf.put(mergeStrategyBinary);
  buf.put(buildPyramid ? (byte)1 : (byte)0);
  return buf.array();
}","@Override public byte[] toBinary(){
  final byte[] coverageNameBytes=StringUtils.stringToBinary(coverageName);
  final byte[] sampleModelBinary=getSampleModelBinary(sampleModel);
  final byte[] colorModelBinary=getColorModelBinary(colorModel);
  int metadataBinaryLength=4;
  final List<byte[]> entryBinaries=new ArrayList<byte[]>();
  for (  final Entry<String,String> e : metadata.entrySet()) {
    final byte[] keyBytes=StringUtils.stringToBinary(e.getKey());
    final byte[] valueBytes=StringUtils.stringToBinary(e.getValue());
    final int entryBinaryLength=4 + valueBytes.length + keyBytes.length;
    final ByteBuffer buf=ByteBuffer.allocate(entryBinaryLength);
    buf.putInt(keyBytes.length);
    buf.put(keyBytes);
    buf.put(valueBytes);
    entryBinaries.add(buf.array());
    metadataBinaryLength+=(entryBinaryLength + 4);
  }
  byte[] histogramConfigBinary;
  if (histogramConfig != null) {
    histogramConfigBinary=PersistenceUtils.toBinary(histogramConfig);
  }
 else {
    histogramConfigBinary=new byte[]{};
  }
  final byte[] noDataBinary=getNoDataBinary(noDataValuesPerBand);
  final byte[] backgroundBinary;
  if (backgroundValuesPerBand != null) {
    final int totalBytes=(backgroundValuesPerBand.length * 8);
    final ByteBuffer backgroundBuf=ByteBuffer.allocate(totalBytes);
    for (    final double backgroundValue : backgroundValuesPerBand) {
      backgroundBuf.putDouble(backgroundValue);
    }
    backgroundBinary=backgroundBuf.array();
  }
 else {
    backgroundBinary=new byte[]{};
  }
  byte[] mergeStrategyBinary;
  if (mergeStrategy != null) {
    mergeStrategyBinary=PersistenceUtils.toBinary(mergeStrategy);
  }
 else {
    mergeStrategyBinary=new byte[]{};
  }
  final ByteBuffer buf=ByteBuffer.allocate(coverageNameBytes.length + sampleModelBinary.length + colorModelBinary.length+ metadataBinaryLength+ histogramConfigBinary.length+ noDataBinary.length+ backgroundBinary.length+ mergeStrategyBinary.length+ 33);
  buf.putInt(tileSize);
  buf.putInt(coverageNameBytes.length);
  buf.put(coverageNameBytes);
  buf.putInt(sampleModelBinary.length);
  buf.put(sampleModelBinary);
  buf.putInt(colorModelBinary.length);
  buf.put(colorModelBinary);
  buf.putInt(entryBinaries.size());
  for (  final byte[] entryBinary : entryBinaries) {
    buf.putInt(entryBinary.length);
    buf.put(entryBinary);
  }
  buf.putInt(histogramConfigBinary.length);
  buf.put(histogramConfigBinary);
  buf.putInt(noDataBinary.length);
  buf.put(noDataBinary);
  buf.putInt(backgroundBinary.length);
  buf.put(backgroundBinary);
  buf.putInt(mergeStrategyBinary.length);
  buf.put(mergeStrategyBinary);
  buf.put(buildPyramid ? (byte)1 : (byte)0);
  return buf.array();
}",0.9940298507462688
113137,"@Override public byte[] toBinary(){
  final byte[] noDataBinary;
  if ((noDataPerBand != null) && (noDataPerBand.length > 0)) {
    int totalBytes=4;
    final List<byte[]> noDataValuesBytes=new ArrayList<byte[]>(noDataPerBand.length);
    for (    final double[] noDataValues : noDataPerBand) {
      final int thisBytes=4 + (noDataValues.length * 8);
      totalBytes+=thisBytes;
      final ByteBuffer noDataBuf=ByteBuffer.allocate(thisBytes);
      noDataBuf.putInt(noDataValues.length);
      for (      final double noDataValue : noDataValues) {
        noDataBuf.putDouble(noDataValue);
      }
      noDataValuesBytes.add(noDataBuf.array());
    }
    final ByteBuffer noDataBuf=ByteBuffer.allocate(totalBytes);
    noDataBuf.putInt(noDataPerBand.length);
    for (    final byte[] noDataValueBytes : noDataValuesBytes) {
      noDataBuf.put(noDataValueBytes);
    }
    noDataBinary=noDataBuf.array();
  }
 else {
    noDataBinary=new byte[]{};
  }
  final byte[] geometryBinary=GeometryUtils.geometryToBinary(shape);
  final ByteBuffer buf=ByteBuffer.allocate(geometryBinary.length + noDataPerBand.length + 4);
  buf.putInt(noDataBinary.length);
  buf.put(noDataBinary);
  buf.put(geometryBinary);
  return buf.array();
}","@Override public byte[] toBinary(){
  final byte[] noDataBinary;
  if ((noDataPerBand != null) && (noDataPerBand.length > 0)) {
    int totalBytes=4;
    final List<byte[]> noDataValuesBytes=new ArrayList<byte[]>(noDataPerBand.length);
    for (    final double[] noDataValues : noDataPerBand) {
      final int thisBytes=4 + (noDataValues.length * 8);
      totalBytes+=thisBytes;
      final ByteBuffer noDataBuf=ByteBuffer.allocate(thisBytes);
      noDataBuf.putInt(noDataValues.length);
      for (      final double noDataValue : noDataValues) {
        noDataBuf.putDouble(noDataValue);
      }
      noDataValuesBytes.add(noDataBuf.array());
    }
    final ByteBuffer noDataBuf=ByteBuffer.allocate(totalBytes);
    noDataBuf.putInt(noDataPerBand.length);
    for (    final byte[] noDataValueBytes : noDataValuesBytes) {
      noDataBuf.put(noDataValueBytes);
    }
    noDataBinary=noDataBuf.array();
  }
 else {
    noDataBinary=new byte[]{};
  }
  final byte[] geometryBinary=GeometryUtils.geometryToBinary(shape);
  final ByteBuffer buf=ByteBuffer.allocate(geometryBinary.length + noDataBinary.length + 4);
  buf.putInt(noDataBinary.length);
  buf.put(noDataBinary);
  buf.put(geometryBinary);
  return buf.array();
}",0.9947175944737912
113138,"@Override protected void transformRange(final SortedKeyValueIterator<Key,Value> input,final KVBuffer output) throws IOException {
  Mergeable currentMergeable=null;
  Key outputKey=null;
  while (input.hasTop()) {
    final Value val=input.getTopValue();
    final Key currentKey=new Key(input.getTopKey());
    if (outputKey == null) {
      outputKey=currentKey;
    }
 else     if (currentMergeable != null && !outputKey.getRowData().equals(currentKey.getRowData())) {
      output.append(outputKey,new Value(PersistenceUtils.toBinary(currentMergeable)));
      currentMergeable=null;
      outputKey=currentKey;
      continue;
    }
 else {
      final Text combinedVisibility=new Text(combineVisibilities(currentKey.getColumnVisibility().getBytes(),outputKey.getColumnVisibility().getBytes()));
      outputKey=replaceColumnVisibility(outputKey,combinedVisibility);
    }
    Mergeable mergeable=PersistenceUtils.fromBinary(val.get(),Mergeable.class);
    mergeable=transform(currentKey,mergeable);
    if (mergeable != null) {
      if (currentMergeable == null) {
        currentMergeable=mergeable;
      }
 else {
        currentMergeable.merge(mergeable);
      }
    }
    input.next();
  }
  if (currentMergeable != null) {
    output.append(outputKey,new Value(PersistenceUtils.toBinary(currentMergeable)));
  }
}","@Override protected void transformRange(final SortedKeyValueIterator<Key,Value> input,final KVBuffer output) throws IOException {
  Mergeable currentMergeable=null;
  Key outputKey=null;
  while (input.hasTop()) {
    final Value val=input.getTopValue();
    final Key currentKey=new Key(input.getTopKey());
    if (outputKey == null) {
      outputKey=currentKey;
    }
 else     if ((currentMergeable != null) && !outputKey.getRowData().equals(currentKey.getRowData())) {
      output.append(outputKey,new Value(PersistenceUtils.toBinary(currentMergeable)));
      currentMergeable=null;
      outputKey=currentKey;
      continue;
    }
 else {
      final Text combinedVisibility=new Text(combineVisibilities(currentKey.getColumnVisibility().getBytes(),outputKey.getColumnVisibility().getBytes()));
      outputKey=replaceColumnVisibility(outputKey,combinedVisibility);
    }
    final Mergeable mergeable=getMergeable(currentKey,val.get());
    if (mergeable != null) {
      if (currentMergeable == null) {
        currentMergeable=mergeable;
      }
 else {
        currentMergeable.merge(mergeable);
      }
    }
    input.next();
  }
  if (currentMergeable != null) {
    output.append(outputKey,new Value(getBinary(currentMergeable)));
  }
}",0.716556804963164
113139,"private static byte[] combineVisibilities(final byte[] vis1,final byte[] vis2){
  if (vis1 == null || vis1.length == 0) {
    return vis2;
  }
  if (vis2 == null || vis2.length == 0) {
    return vis1;
  }
  return new ColumnVisibility(ArrayUtils.addAll(ArrayUtils.addAll(ColumnVisibility.quote(vis1),AMPRISAND),ColumnVisibility.quote(vis2))).flatten();
}","private static byte[] combineVisibilities(final byte[] vis1,final byte[] vis2){
  if ((vis1 == null) || (vis1.length == 0)) {
    return vis2;
  }
  if ((vis2 == null) || (vis2.length == 0)) {
    return vis1;
  }
  return new ColumnVisibility(ArrayUtils.addAll(ArrayUtils.addAll(ColumnVisibility.quote(vis1),AMPRISAND),ColumnVisibility.quote(vis2))).flatten();
}",0.9220055710306406
113140,"@Override protected Mergeable getMergeable(final Key key,final byte[] binary){
  final RasterTile mergeable=PersistenceUtils.classFactory(RasterTile.class.getName(),RasterTile.class);
  return helper.transform(key,mergeable);
}","@Override protected Mergeable getMergeable(final Key key,final byte[] binary){
  final RasterTile mergeable=PersistenceUtils.classFactory(RasterTile.class.getName(),RasterTile.class);
  if (mergeable != null) {
    mergeable.fromBinary(binary);
  }
  return helper.transform(key,mergeable);
}",0.8631984585741811
113141,"@SuppressWarnings(""String_Node_Str"") @Override protected Object defaultTypeDataFromBinary(final byte[] bytes){
  final ByteBuffer buf=ByteBuffer.wrap(bytes);
  final byte[] typeNameBytes=new byte[buf.getInt()];
  final byte[] namespaceBytes=new byte[buf.getInt()];
  final byte[] fieldVisibilityAtributeNameBytes=new byte[buf.getInt()];
  final byte[] visibilityManagementClassNameBytes=new byte[buf.getInt()];
  final byte[] timeAndRangeBytes=new byte[buf.getInt()];
  buf.get(typeNameBytes);
  buf.get(namespaceBytes);
  buf.get(fieldVisibilityAtributeNameBytes);
  buf.get(visibilityManagementClassNameBytes);
  buf.get(timeAndRangeBytes);
  final String typeName=StringUtils.stringFromBinary(typeNameBytes);
  final String namespace=StringUtils.stringFromBinary(namespaceBytes);
  visibilityAttributeName=StringUtils.stringFromBinary(fieldVisibilityAtributeNameBytes);
  final String visibilityManagementClassName=StringUtils.stringFromBinary(visibilityManagementClassNameBytes);
  try {
    fieldVisibilityManagement=(VisibilityManagement<SimpleFeature>)Class.forName(visibilityManagementClassName).newInstance();
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"" + visibilityManagementClassName,ex);
  }
  final byte[] encodedTypeBytes=new byte[bytes.length - typeNameBytes.length - namespaceBytes.length- fieldVisibilityAtributeNameBytes.length- visibilityManagementClassNameBytes.length- timeAndRangeBytes.length- 20];
  buf.get(encodedTypeBytes);
  final String encodedType=StringUtils.stringFromBinary(encodedTypeBytes);
  try {
    setFeatureType(DataUtilities.createType(namespace,typeName,encodedType));
    final TimeDescriptors timeDescriptors=new TimeDescriptors();
    timeDescriptors.fromBinary(persistedType,timeAndRangeBytes);
    if (persistedType.getDescriptor(visibilityAttributeName) != null) {
      persistedType.getDescriptor(visibilityAttributeName).getUserData().put(""String_Node_Str"",Boolean.TRUE);
    }
    return reprojectedType;
  }
 catch (  final SchemaException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") @Override protected Object defaultTypeDataFromBinary(final byte[] bytes){
  final ByteBuffer buf=ByteBuffer.wrap(bytes);
  final byte[] typeNameBytes=new byte[buf.getInt()];
  final byte[] namespaceBytes=new byte[buf.getInt()];
  final byte[] fieldVisibilityAtributeNameBytes=new byte[buf.getInt()];
  final byte[] visibilityManagementClassNameBytes=new byte[buf.getInt()];
  final byte[] timeAndRangeBytes=new byte[buf.getInt()];
  buf.get(typeNameBytes);
  buf.get(namespaceBytes);
  buf.get(fieldVisibilityAtributeNameBytes);
  buf.get(visibilityManagementClassNameBytes);
  buf.get(timeAndRangeBytes);
  final String typeName=StringUtils.stringFromBinary(typeNameBytes);
  String namespace=StringUtils.stringFromBinary(namespaceBytes);
  if (namespace.length() == 0) {
    namespace=null;
  }
  visibilityAttributeName=StringUtils.stringFromBinary(fieldVisibilityAtributeNameBytes);
  final String visibilityManagementClassName=StringUtils.stringFromBinary(visibilityManagementClassNameBytes);
  try {
    fieldVisibilityManagement=(VisibilityManagement<SimpleFeature>)Class.forName(visibilityManagementClassName).newInstance();
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"" + visibilityManagementClassName,ex);
  }
  final byte[] encodedTypeBytes=new byte[bytes.length - typeNameBytes.length - namespaceBytes.length- fieldVisibilityAtributeNameBytes.length- visibilityManagementClassNameBytes.length- timeAndRangeBytes.length- 20];
  buf.get(encodedTypeBytes);
  final String encodedType=StringUtils.stringFromBinary(encodedTypeBytes);
  try {
    setFeatureType(DataUtilities.createType(namespace,typeName,encodedType));
    final TimeDescriptors timeDescriptors=new TimeDescriptors();
    timeDescriptors.fromBinary(persistedType,timeAndRangeBytes);
    if (persistedType.getDescriptor(visibilityAttributeName) != null) {
      persistedType.getDescriptor(visibilityAttributeName).getUserData().put(""String_Node_Str"",Boolean.TRUE);
    }
    return reprojectedType;
  }
 catch (  final SchemaException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return null;
}",0.9850675515525006
113142,"@Override protected byte[] defaultTypeDataToBinary(){
  final String encodedType=DataUtilities.encodeType(persistedType);
  final String typeName=reprojectedType.getTypeName();
  final byte[] typeNameBytes=StringUtils.stringToBinary(typeName);
  final byte[] fieldVisibilityAtributeNameBytes=StringUtils.stringToBinary(visibilityAttributeName);
  final byte[] visibilityManagementClassNameBytes=StringUtils.stringToBinary(fieldVisibilityManagement.getClass().getCanonicalName());
  final TimeDescriptors timeDescriptors=inferTimeAttributeDescriptor(persistedType);
  final byte[] timeAndRangeBytes=timeDescriptors.toBinary();
  final String namespace=this.reprojectedType.getName().getNamespaceURI();
  byte[] namespaceBytes;
  if (namespace != null) {
    namespaceBytes=StringUtils.stringToBinary(namespace);
  }
 else {
    namespaceBytes=new byte[0];
  }
  final byte[] encodedTypeBytes=StringUtils.stringToBinary(encodedType);
  final ByteBuffer buf=ByteBuffer.allocate(encodedTypeBytes.length + typeNameBytes.length + namespaceBytes.length+ fieldVisibilityAtributeNameBytes.length+ visibilityManagementClassNameBytes.length+ timeAndRangeBytes.length+ 20);
  buf.putInt(typeNameBytes.length);
  buf.putInt(namespaceBytes.length);
  buf.putInt(fieldVisibilityAtributeNameBytes.length);
  buf.putInt(visibilityManagementClassNameBytes.length);
  buf.putInt(timeAndRangeBytes.length);
  buf.put(typeNameBytes);
  buf.put(namespaceBytes);
  buf.put(fieldVisibilityAtributeNameBytes);
  buf.put(visibilityManagementClassNameBytes);
  buf.put(timeAndRangeBytes);
  buf.put(encodedTypeBytes);
  return buf.array();
}","@Override protected byte[] defaultTypeDataToBinary(){
  final String encodedType=DataUtilities.encodeType(persistedType);
  final String typeName=reprojectedType.getTypeName();
  final byte[] typeNameBytes=StringUtils.stringToBinary(typeName);
  final byte[] fieldVisibilityAtributeNameBytes=StringUtils.stringToBinary(visibilityAttributeName);
  final byte[] visibilityManagementClassNameBytes=StringUtils.stringToBinary(fieldVisibilityManagement.getClass().getCanonicalName());
  final TimeDescriptors timeDescriptors=inferTimeAttributeDescriptor(persistedType);
  final byte[] timeAndRangeBytes=timeDescriptors.toBinary();
  final String namespace=reprojectedType.getName().getNamespaceURI();
  byte[] namespaceBytes;
  if ((namespace != null) && (namespace.length() > 0)) {
    namespaceBytes=StringUtils.stringToBinary(namespace);
  }
 else {
    namespaceBytes=new byte[0];
  }
  final byte[] encodedTypeBytes=StringUtils.stringToBinary(encodedType);
  final ByteBuffer buf=ByteBuffer.allocate(encodedTypeBytes.length + typeNameBytes.length + namespaceBytes.length+ fieldVisibilityAtributeNameBytes.length+ visibilityManagementClassNameBytes.length+ timeAndRangeBytes.length+ 20);
  buf.putInt(typeNameBytes.length);
  buf.putInt(namespaceBytes.length);
  buf.putInt(fieldVisibilityAtributeNameBytes.length);
  buf.putInt(visibilityManagementClassNameBytes.length);
  buf.putInt(timeAndRangeBytes.length);
  buf.put(typeNameBytes);
  buf.put(namespaceBytes);
  buf.put(fieldVisibilityAtributeNameBytes);
  buf.put(visibilityManagementClassNameBytes);
  buf.put(timeAndRangeBytes);
  buf.put(encodedTypeBytes);
  return buf.array();
}",0.9892407008914847
113143,"public GeoWaveGTDataStore(final GeoWavePluginConfig config) throws IOException, AccumuloException, AccumuloSecurityException {
  listenerManager=new FeatureListenerManager();
  lockingManager=config.getLockingManagementFactory().createLockingManager(config);
  authorizationSPI=config.getAuthorizationFactory().create(config.getAuthorizationURL());
  init(config);
  transactionsAllocater=new ZooKeeperTransactionsAllocater(config.getZookeeperServers(),""String_Node_Str"",this);
  try {
    featureNameSpaceURI=new URI(""String_Node_Str"");
  }
 catch (  URISyntaxException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","public GeoWaveGTDataStore(final GeoWavePluginConfig config) throws IOException, AccumuloException, AccumuloSecurityException {
  listenerManager=new FeatureListenerManager();
  lockingManager=config.getLockingManagementFactory().createLockingManager(config);
  authorizationSPI=config.getAuthorizationFactory().create(config.getAuthorizationURL());
  init(config);
  transactionsAllocater=new ZooKeeperTransactionsAllocater(config.getZookeeperServers(),""String_Node_Str"",this);
  featureNameSpaceURI=config.getFeatureNamespace();
}",0.8774978279756733
113144,"Name getTypeName(String typeName){
  return new NameImpl(featureNameSpaceURI.toString(),typeName);
}","Name getTypeName(final String typeName){
  return new NameImpl(featureNameSpaceURI.toString(),typeName);
}",0.970873786407767
113145,"private Index getPreferredIndex(final FeatureDataAdapter adapter){
  Index currentSelection=preferredIndexes.get(adapter.getType().getName().toString());
  if (currentSelection != null) {
    return currentSelection;
  }
  final boolean needTime=adapter.hasTemporalConstraints();
  try (CloseableIterator<Index> indices=dataStore.getIndices()){
    boolean currentSelectionHasTime=false;
    while (indices.hasNext()) {
      final Index index=indices.next();
      @SuppressWarnings(""String_Node_Str"") final DimensionField[] dims=index.getIndexModel().getDimensions();
      boolean hasLat=false;
      boolean hasLong=false;
      boolean hasTime=false;
      for (      final DimensionField<?> dim : dims) {
        hasLat|=dim instanceof LatitudeField;
        hasLong|=dim instanceof LongitudeField;
        hasTime|=dim instanceof TimeField;
      }
      if (hasLat && hasLong) {
        if ((currentSelection == null) || (currentSelectionHasTime != hasTime)) {
          currentSelection=index;
          currentSelectionHasTime=hasTime;
        }
      }
    }
    if ((currentSelection == null) || (!currentSelectionHasTime && needTime)) {
      if (needTime) {
        currentSelection=IndexType.SPATIAL_TEMPORAL_VECTOR.createDefaultIndex();
      }
 else {
        currentSelection=IndexType.SPATIAL_VECTOR.createDefaultIndex();
      }
      LOGGER.warn(""String_Node_Str"");
    }
  }
 catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
  preferredIndexes.put(adapter.getType().getName().toString(),currentSelection);
  return currentSelection;
}","private Index getPreferredIndex(final FeatureDataAdapter adapter){
  Index currentSelection=preferredIndexes.get(adapter.getType().getName().toString());
  if (currentSelection != null) {
    return currentSelection;
  }
  final boolean needTime=adapter.hasTemporalConstraints();
  try (CloseableIterator<Index> indices=dataStore.getIndices()){
    boolean currentSelectionHasTime=false;
    while (indices.hasNext()) {
      final Index index=indices.next();
      @SuppressWarnings(""String_Node_Str"") final DimensionField[] dims=index.getIndexModel().getDimensions();
      boolean hasLat=false;
      boolean hasLong=false;
      boolean hasTime=false;
      for (      final DimensionField<?> dim : dims) {
        hasLat|=dim instanceof LatitudeField;
        hasLong|=dim instanceof LongitudeField;
        hasTime|=dim instanceof TimeField;
      }
      if (hasLat && hasLong) {
        if ((currentSelection == null) || (currentSelectionHasTime != hasTime)) {
          currentSelection=index;
          currentSelectionHasTime=hasTime;
        }
      }
    }
    if ((currentSelection == null) || (!currentSelectionHasTime && needTime)) {
      if (needTime) {
        currentSelection=IndexType.SPATIAL_TEMPORAL_VECTOR.createDefaultIndex();
      }
 else {
        currentSelection=IndexType.SPATIAL_VECTOR.createDefaultIndex();
      }
      LOGGER.warn(""String_Node_Str"");
    }
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
  preferredIndexes.put(adapter.getType().getName().toString(),currentSelection);
  return currentSelection;
}",0.9981024667931688
113146,"private FeatureDataAdapter getAdapter(final String typeName){
  final SimpleFeatureType statsFeatureType=getDefaultSchema(typeName);
  final FeatureDataAdapter featureAdapter;
  if (statsFeatureType != null) {
    featureAdapter=new FeatureDataAdapter(statsFeatureType,getVisibilityManagement());
  }
 else {
    final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(typeName)));
    if ((adapter == null) || !(adapter instanceof FeatureDataAdapter)) {
      return null;
    }
    featureAdapter=(FeatureDataAdapter)adapter;
  }
  featureAdapter.setNamespace(this.featureNameSpaceURI.toString());
  return featureAdapter;
}","private FeatureDataAdapter getAdapter(final String typeName){
  final SimpleFeatureType statsFeatureType=getDefaultSchema(typeName);
  final FeatureDataAdapter featureAdapter;
  if (statsFeatureType != null) {
    featureAdapter=new FeatureDataAdapter(statsFeatureType,getVisibilityManagement());
  }
 else {
    final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(typeName)));
    if ((adapter == null) || !(adapter instanceof FeatureDataAdapter)) {
      return null;
    }
    featureAdapter=(FeatureDataAdapter)adapter;
  }
  if (featureNameSpaceURI != null)   featureAdapter.setNamespace(featureNameSpaceURI.toString());
  return featureAdapter;
}",0.9706314243759178
113147,"@Override public void removeSchema(final String typeName) throws IOException {
  final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(typeName)));
  if (adapter != null) {
    String[] authorizations=getAuthorizationSPI().getAuthorizations();
    try (CloseableIterator<Index> indicesIt=dataStore.getIndices()){
      while (indicesIt.hasNext()) {
        dataStore.deleteEntries(adapter,indicesIt.next(),authorizations);
      }
    }
 catch (    IOException ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}","@Override public void removeSchema(final String typeName) throws IOException {
  final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(StringUtils.stringToBinary(typeName)));
  if (adapter != null) {
    final String[] authorizations=getAuthorizationSPI().getAuthorizations();
    try (CloseableIterator<Index> indicesIt=dataStore.getIndices()){
      while (indicesIt.hasNext()) {
        dataStore.deleteEntries(adapter,indicesIt.next(),authorizations);
      }
    }
 catch (    final IOException ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}",0.98943661971831
113148,"@Override public void createSchema(final SimpleFeatureType featureType){
  if (featureType.getGeometryDescriptor() == null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  final FeatureDataAdapter adapter=new FeatureDataAdapter(featureType,getVisibilityManagement());
  if (featureNameSpaceURI != null)   adapter.setNamespace(featureNameSpaceURI.toString());
  adapterStore.addAdapter(adapter);
  getPreferredIndex(adapter);
}","@Override public void createSchema(final SimpleFeatureType featureType){
  if (featureType.getGeometryDescriptor() == null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  final FeatureDataAdapter adapter=new FeatureDataAdapter(featureType,getVisibilityManagement());
  if (featureNameSpaceURI != null) {
    adapter.setNamespace(featureNameSpaceURI.toString());
  }
  adapterStore.addAdapter(adapter);
  getPreferredIndex(adapter);
}",0.9911894273127754
113149,"private SimpleFeatureType getDefaultSchema(final String typeName){
  final FeatureDataAdapter adapter=getStatsAdapter(typeName);
  if (adapter != null) {
    final SimpleFeatureType type=adapter.getType();
    String nameSpace=featureNameSpaceURI != null ? featureNameSpaceURI.toString() : type.getName().getNamespaceURI();
    return new SimpleFeatureTypeImpl(new NameImpl(nameSpace,type.getName().getSeparator(),typeName),type.getAttributeDescriptors(),type.getGeometryDescriptor(),type.isAbstract(),type.getRestrictions(),type.getSuper(),type.getDescription());
  }
  return null;
}","private SimpleFeatureType getDefaultSchema(final String typeName){
  final FeatureDataAdapter adapter=getStatsAdapter(typeName);
  if (adapter != null) {
    final SimpleFeatureType type=adapter.getType();
    final String nameSpace=featureNameSpaceURI != null ? featureNameSpaceURI.toString() : type.getName().getNamespaceURI();
    return new SimpleFeatureTypeImpl(new NameImpl(nameSpace,type.getName().getSeparator(),typeName),type.getAttributeDescriptors(),type.getGeometryDescriptor(),type.isAbstract(),type.getRestrictions(),type.getSuper(),type.getDescription());
  }
  return null;
}",0.9948979591836736
113150,"public void run(){
  while (s < 20 && !shutdown) {
    s++;
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
    try {
      String txID=allocater.getTransaction();
synchronized (activeTX) {
        assert(!activeTX.contains(txID));
        activeTX.add(txID);
        activeTX.notify();
      }
      try {
        Thread.sleep(200 + (Math.abs(random.nextInt()) % 200));
      }
 catch (      InterruptedException e) {
      }
      allocater.releaseTransaction(txID);
synchronized (activeTX) {
        activeTX.remove(txID);
      }
    }
 catch (    Throwable e) {
synchronized (failures) {
        failures.add(e);
        shutdown=true;
      }
    }
  }
}","public void run(){
  while (s < 10 && !shutdown) {
    s++;
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
    try {
      String txID=allocater.getTransaction();
synchronized (activeTX) {
        assert(!activeTX.contains(txID));
        activeTX.add(txID);
        activeTX.notify();
      }
      try {
        Thread.sleep(200 + (Math.abs(random.nextInt()) % 200));
      }
 catch (      InterruptedException e) {
      }
      allocater.releaseTransaction(txID);
synchronized (activeTX) {
        activeTX.remove(txID);
      }
    }
 catch (    Throwable e) {
synchronized (failures) {
        failures.add(e);
        shutdown=true;
      }
    }
  }
}",0.9985652797704448
113151,"protected boolean objectExists(final ByteArrayId id){
  if (cache.get(id) != null) {
    return true;
  }
  try {
    final BatchScanner scanner=getScanner(id);
    try {
      final Iterator<Entry<Key,Value>> it=scanner.iterator();
      return it.hasNext();
    }
  finally {
      scanner.close();
    }
  }
 catch (  final TableNotFoundException e) {
    LOGGER.debug(""String_Node_Str"" + StringUtils.stringFromBinary(id.getBytes()) + ""String_Node_Str"",e);
  }
  return false;
}","protected boolean objectExists(final ByteArrayId id){
  if (cache.get(id) != null) {
    return true;
  }
  try {
    final BatchScanner scanner=getScanner(id);
    try {
      final Iterator<Entry<Key,Value>> it=scanner.iterator();
      if (it.hasNext()) {
        return (entryToValue(it.next()) != null);
      }
 else {
        return false;
      }
    }
  finally {
      scanner.close();
    }
  }
 catch (  final TableNotFoundException e) {
    LOGGER.debug(""String_Node_Str"" + StringUtils.stringFromBinary(id.getBytes()) + ""String_Node_Str"",e);
  }
  return false;
}",0.8949858088930936
113152,"@Override public boolean tableExists(String tableName){
  final String qName=getQualifiedTableName(tableName);
  return connector.tableOperations().exists(qName);
}","@Override public boolean tableExists(final String tableName){
  final String qName=getQualifiedTableName(tableName);
  return connector.tableOperations().exists(qName);
}",0.9820359281437124
113153,"/** 
 * Convert from an expected input format to a data format that can be directly ingested into GeoWave
 * @param input The expected input.
 * @param primaryIndexId The index ID specified via a commandline argument (this is typically either the default spatial index or default spatial-temporal index)
 * @param globalVisibility If on the command-line the user specifies a global visibility to write to the visibility column in GeoWave, it is passed along here. It is assumed that this is the same visibility string that will be passed to DataAdapterProvider.getDataAdapters()
 * @return The objects that can be directly ingested into GeoWave
 */
public Iterable<GeoWaveData<O>> toGeoWaveData(I input,ByteArrayId primaryIndexId,String globalVisibility);","/** 
 * Convert from an expected input format to a data format that can be directly ingested into GeoWave
 * @param input The expected input.
 * @param primaryIndexId The index ID specified via a commandline argument (this is typically either the default spatial index or default spatial-temporal index)
 * @param globalVisibility If on the command-line the user specifies a global visibility to write to the visibility column in GeoWave, it is passed along here. It is assumed that this is the same visibility string that will be passed to DataAdapterProvider.getDataAdapters()
 * @return The objects that can be directly ingested into GeoWave
 */
public CloseableIterator<GeoWaveData<O>> toGeoWaveData(I input,ByteArrayId primaryIndexId,String globalVisibility);",0.9835418038183016
113154,"@Override protected void map(final AvroKey key,final NullWritable value,final org.apache.hadoop.mapreduce.Mapper.Context context) throws IOException, InterruptedException {
  final Iterable<GeoWaveData> data=ingestWithMapper.toGeoWaveData(key.datum(),primaryIndexId,globalVisibility);
  for (  final GeoWaveData d : data) {
    context.write(d.getKey(),d.getValue());
  }
}","@Override protected void map(final AvroKey key,final NullWritable value,final org.apache.hadoop.mapreduce.Mapper.Context context) throws IOException, InterruptedException {
  try (CloseableIterator<GeoWaveData> data=ingestWithMapper.toGeoWaveData(key.datum(),primaryIndexId,globalVisibility)){
    while (data.hasNext()) {
      final GeoWaveData d=data.next();
      context.write(d.getKey(),d.getValue());
    }
  }
 }",0.8247162673392182
113155,"@Override protected void reduce(final WritableComparable<?> key,final Iterable<Writable> values,final Context context) throws IOException, InterruptedException {
  final Iterable<GeoWaveData> data=ingestWithReducer.toGeoWaveData(key,primaryIndexId,globalVisibility,values);
  for (  final GeoWaveData d : data) {
    context.write(d.getKey(),d.getValue());
  }
}","@Override protected void reduce(final WritableComparable<?> key,final Iterable<Writable> values,final Context context) throws IOException, InterruptedException {
  try (CloseableIterator<GeoWaveData> data=ingestWithReducer.toGeoWaveData(key,primaryIndexId,globalVisibility,values)){
    while (data.hasNext()) {
      final GeoWaveData d=data.next();
      context.write(d.getKey(),d.getValue());
    }
  }
 }",0.8067444876783398
113156,"public Iterable<GeoWaveData<O>> toGeoWaveData(K key,ByteArrayId primaryIndexId,String globalVisibility,Iterable<V> values);","public CloseableIterator<GeoWaveData<O>> toGeoWaveData(K key,ByteArrayId primaryIndexId,String globalVisibility,Iterable<V> values);",0.9411764705882352
113157,"public Iterable<KeyValueData<K,V>> toIntermediateMapReduceData(I input);","public CloseableIterator<KeyValueData<K,V>> toIntermediateMapReduceData(I input);",0.9019607843137256
113158,"@Override protected void map(final AvroKey key,final NullWritable value,final org.apache.hadoop.mapreduce.Mapper.Context context) throws IOException, InterruptedException {
  final Iterable<KeyValueData<WritableComparable<?>,Writable>> data=ingestWithReducer.toIntermediateMapReduceData(key.datum());
  for (  final KeyValueData<WritableComparable<?>,Writable> d : data) {
    context.write(d.getKey(),d.getValue());
  }
}","@Override protected void map(final AvroKey key,final NullWritable value,final org.apache.hadoop.mapreduce.Mapper.Context context) throws IOException, InterruptedException {
  try (CloseableIterator<KeyValueData<WritableComparable<?>,Writable>> data=ingestWithReducer.toIntermediateMapReduceData(key.datum())){
    while (data.hasNext()) {
      final KeyValueData<WritableComparable<?>,Writable> d=data.next();
      context.write(d.getKey(),d.getValue());
    }
  }
 }",0.8821548821548821
113159,"abstract protected void processFile(final File file,String typeName,P plugin,R runData);","abstract protected void processFile(final File file,String typeName,P plugin,R runData) throws IOException ;",0.8979591836734694
113160,"@Override protected void processFile(final File file,final String typeName,final LocalFileIngestPlugin plugin,final IngestRunData ingestRunData){
  final Iterable<GeoWaveData<?>> geowaveDataIt=plugin.toGeoWaveData(file,accumulo.getPrimaryIndex().getId(),accumulo.getVisibility());
  for (  final GeoWaveData<?> geowaveData : geowaveDataIt) {
    final WritableDataAdapter adapter=ingestRunData.getDataAdapter(geowaveData);
    if (adapter == null) {
      LOGGER.warn(""String_Node_Str"" + geowaveData.getValue());
      continue;
    }
    indexWriter.write(adapter,geowaveData.getValue());
  }
}","@Override protected void processFile(final File file,final String typeName,final LocalFileIngestPlugin plugin,final IngestRunData ingestRunData) throws IOException {
  try (CloseableIterator<GeoWaveData<?>> geowaveDataIt=plugin.toGeoWaveData(file,accumulo.getPrimaryIndex().getId(),accumulo.getVisibility())){
    while (geowaveDataIt.hasNext()) {
      final GeoWaveData<?> geowaveData=geowaveDataIt.next();
      final WritableDataAdapter adapter=ingestRunData.getDataAdapter(geowaveData);
      if (adapter == null) {
        LOGGER.warn(""String_Node_Str"" + geowaveData.getValue());
        continue;
      }
      ingestRunData.getIndexWriter().write(adapter,geowaveData.getValue());
    }
  }
 }",0.8571428571428571
113161,"@Override protected void runInternal(final String[] args,final List<IngestTypePluginProviderSpi<?,?>> pluginProviders){
  final Map<String,LocalFileIngestPlugin<?>> localFileIngestPlugins=new HashMap<String,LocalFileIngestPlugin<?>>();
  final List<WritableDataAdapter<?>> adapters=new ArrayList<WritableDataAdapter<?>>();
  for (  final IngestTypePluginProviderSpi<?,?> pluginProvider : pluginProviders) {
    LocalFileIngestPlugin<?> localFileIngestPlugin=null;
    try {
      localFileIngestPlugin=pluginProvider.getLocalFileIngestPlugin();
      if (localFileIngestPlugin == null) {
        LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str"");
        continue;
      }
    }
 catch (    final UnsupportedOperationException e) {
      LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str"",e);
      continue;
    }
    final Index[] supportedIndices=localFileIngestPlugin.getSupportedIndices();
    final Index selectedIndex=accumulo.getPrimaryIndex();
    boolean indexSupported=false;
    for (    final Index i : supportedIndices) {
      if (i.getId().equals(selectedIndex.getId())) {
        indexSupported=true;
        break;
      }
    }
    if (!indexSupported) {
      LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str""+ StringUtils.stringFromBinary(selectedIndex.getId().getBytes())+ ""String_Node_Str"");
      continue;
    }
    localFileIngestPlugins.put(pluginProvider.getIngestTypeName(),localFileIngestPlugin);
    adapters.addAll(Arrays.asList(localFileIngestPlugin.getDataAdapters(accumulo.getVisibility())));
  }
  final AccumuloOperations operations=accumulo.getAccumuloOperations();
  if (localFileIngestPlugins.isEmpty()) {
    LOGGER.fatal(""String_Node_Str"");
    return;
  }
  final DataStore dataStore=new AccumuloDataStore(operations);
  indexWriter=null;
  try {
    indexWriter=dataStore.createIndexWriter(accumulo.getPrimaryIndex());
    processInput(localFileIngestPlugins,new IngestRunData(indexWriter,adapters));
  }
 catch (  final IOException e) {
    LOGGER.fatal(""String_Node_Str"",e);
  }
 finally {
    if (indexWriter != null) {
      indexWriter.close();
    }
  }
}","@Override protected void runInternal(final String[] args,final List<IngestTypePluginProviderSpi<?,?>> pluginProviders){
  final Map<String,LocalFileIngestPlugin<?>> localFileIngestPlugins=new HashMap<String,LocalFileIngestPlugin<?>>();
  final List<WritableDataAdapter<?>> adapters=new ArrayList<WritableDataAdapter<?>>();
  for (  final IngestTypePluginProviderSpi<?,?> pluginProvider : pluginProviders) {
    LocalFileIngestPlugin<?> localFileIngestPlugin=null;
    try {
      localFileIngestPlugin=pluginProvider.getLocalFileIngestPlugin();
      if (localFileIngestPlugin == null) {
        LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str"");
        continue;
      }
    }
 catch (    final UnsupportedOperationException e) {
      LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str"",e);
      continue;
    }
    final Index[] supportedIndices=localFileIngestPlugin.getSupportedIndices();
    final Index selectedIndex=accumulo.getPrimaryIndex();
    boolean indexSupported=false;
    for (    final Index i : supportedIndices) {
      if (i.getId().equals(selectedIndex.getId())) {
        indexSupported=true;
        break;
      }
    }
    if (!indexSupported) {
      LOGGER.warn(""String_Node_Str"" + pluginProvider.getIngestTypeName() + ""String_Node_Str""+ StringUtils.stringFromBinary(selectedIndex.getId().getBytes())+ ""String_Node_Str"");
      continue;
    }
    localFileIngestPlugins.put(pluginProvider.getIngestTypeName(),localFileIngestPlugin);
    adapters.addAll(Arrays.asList(localFileIngestPlugin.getDataAdapters(accumulo.getVisibility())));
  }
  final AccumuloOperations operations=accumulo.getAccumuloOperations();
  if (localFileIngestPlugins.isEmpty()) {
    LOGGER.fatal(""String_Node_Str"");
    return;
  }
  final DataStore dataStore=new AccumuloDataStore(operations);
  try (IndexWriter indexWriter=dataStore.createIndexWriter(accumulo.getPrimaryIndex())){
    processInput(localFileIngestPlugins,new IngestRunData(indexWriter,adapters));
  }
 catch (  final IOException e) {
    LOGGER.fatal(""String_Node_Str"",e);
  }
}",0.9753513015434232
113162,"@Override public void init(final SFCDimensionDefinition[] dimensionDefs){
  binsPerDimension=new long[dimensionDefs.length];
  for (int d=0; d < dimensionDefs.length; d++) {
    final SFCDimensionDefinition dimension=dimensionDefs[d];
    binsPerDimension[d]=(long)Math.pow(2,dimension.getBitsOfPrecision());
  }
}","@Override public void init(final SFCDimensionDefinition[] dimensionDefs){
  binsPerDimension=new long[dimensionDefs.length];
  int totalPrecision=0;
  for (int d=0; d < dimensionDefs.length; d++) {
    final SFCDimensionDefinition dimension=dimensionDefs[d];
    binsPerDimension[d]=(long)Math.pow(2,dimension.getBitsOfPrecision());
    totalPrecision+=dimension.getBitsOfPrecision();
  }
  minHilbertValue=0;
  maxHilbertValue=(long)(Math.pow(2,totalPrecision) - 1);
}",0.8020434227330779
113163,"@Override public RangeDecomposition decomposeRange(final NumericData[] rangePerDimension,final CompactHilbertCurve compactHilbertCurve,final SFCDimensionDefinition[] dimensionDefinitions,final int totalPrecision,final int maxFilteredIndexedRanges,final boolean removeVacuum){
  final List<Long> minRangeList=new ArrayList<Long>();
  final List<Long> maxRangeList=new ArrayList<Long>();
  final LongContent zero=new LongContent(0L);
  final List<LongRange> region=new ArrayList<LongRange>(dimensionDefinitions.length);
  for (int d=0; d < dimensionDefinitions.length; d++) {
    final long normalizedMin=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMin(),binsPerDimension[d]);
    final long normalizedMax=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMax(),binsPerDimension[d]);
    minRangeList.add(normalizedMin);
    maxRangeList.add(normalizedMax);
    region.add(LongRange.of(normalizedMin,normalizedMax + 1L));
  }
  final long minQuadSize=getMinimumQuadSize(minRangeList,maxRangeList);
  final RegionInspector<LongRange,LongContent> regionInspector=SimpleRegionInspector.create(ImmutableList.of(region),new LongContent(minQuadSize),Functions.<LongRange>identity(),LongRangeHome.INSTANCE,zero);
  final PlainFilterCombiner<LongRange,Long,LongContent,LongRange> intervalCombiner=new PlainFilterCombiner<LongRange,Long,LongContent,LongRange>(LongRange.of(0,1));
  final QueryBuilder<LongRange,LongRange> queryBuilder=BacktrackingQueryBuilder.create(regionInspector,intervalCombiner,maxFilteredIndexedRanges,removeVacuum,LongRangeHome.INSTANCE,zero);
  compactHilbertCurve.accept(new ZoomingSpaceVisitorAdapter(compactHilbertCurve,queryBuilder));
  final List<FilteredIndexRange<LongRange,LongRange>> hilbertRanges=queryBuilder.get().getFilteredIndexRanges();
  final ByteArrayRange[] sfcRanges=new ByteArrayRange[hilbertRanges.size()];
  final int expectedByteCount=(int)Math.ceil(totalPrecision / 8.0);
  if (expectedByteCount <= 0) {
    return new RangeDecomposition(new ByteArrayRange[]{new ByteArrayRange(new ByteArrayId(new byte[]{}),new ByteArrayId(new byte[]{}))});
  }
  for (int i=0; i < hilbertRanges.size(); i++) {
    final FilteredIndexRange<LongRange,LongRange> range=hilbertRanges.get(i);
    final byte[] start=HilbertSFC.fitExpectedByteCount(expectedByteCount,ByteBuffer.allocate(8).putLong(range.getIndexRange().getStart()).array());
    final byte[] end=HilbertSFC.fitExpectedByteCount(expectedByteCount,ByteBuffer.allocate(8).putLong(range.getIndexRange().getEnd()).array());
    sfcRanges[i]=new ByteArrayRange(new ByteArrayId(start),new ByteArrayId(end));
  }
  final RangeDecomposition rangeDecomposition=new RangeDecomposition(sfcRanges);
  return rangeDecomposition;
}","@Override public RangeDecomposition decomposeRange(final NumericData[] rangePerDimension,final CompactHilbertCurve compactHilbertCurve,final SFCDimensionDefinition[] dimensionDefinitions,final int totalPrecision,final int maxFilteredIndexedRanges,final boolean removeVacuum){
  final List<Long> minRangeList=new ArrayList<Long>();
  final List<Long> maxRangeList=new ArrayList<Long>();
  final LongContent zero=new LongContent(0L);
  final List<LongRange> region=new ArrayList<LongRange>(dimensionDefinitions.length);
  for (int d=0; d < dimensionDefinitions.length; d++) {
    final long normalizedMin=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMin(),binsPerDimension[d]);
    final long normalizedMax=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMax(),binsPerDimension[d]);
    minRangeList.add(normalizedMin);
    maxRangeList.add(normalizedMax);
    region.add(LongRange.of(normalizedMin,normalizedMax + 1L));
  }
  final long minQuadSize=getMinimumQuadSize(minRangeList,maxRangeList);
  final RegionInspector<LongRange,LongContent> regionInspector=SimpleRegionInspector.create(ImmutableList.of(region),new LongContent(minQuadSize),Functions.<LongRange>identity(),LongRangeHome.INSTANCE,zero);
  final PlainFilterCombiner<LongRange,Long,LongContent,LongRange> intervalCombiner=new PlainFilterCombiner<LongRange,Long,LongContent,LongRange>(LongRange.of(0,1));
  final QueryBuilder<LongRange,LongRange> queryBuilder=BacktrackingQueryBuilder.create(regionInspector,intervalCombiner,maxFilteredIndexedRanges,removeVacuum,LongRangeHome.INSTANCE,zero);
  compactHilbertCurve.accept(new ZoomingSpaceVisitorAdapter(compactHilbertCurve,queryBuilder));
  final List<FilteredIndexRange<LongRange,LongRange>> hilbertRanges=queryBuilder.get().getFilteredIndexRanges();
  final ByteArrayRange[] sfcRanges=new ByteArrayRange[hilbertRanges.size()];
  final int expectedByteCount=(int)Math.ceil(totalPrecision / 8.0);
  if (expectedByteCount <= 0) {
    return new RangeDecomposition(new ByteArrayRange[]{new ByteArrayRange(new ByteArrayId(new byte[]{}),new ByteArrayId(new byte[]{}))});
  }
  for (int i=0; i < hilbertRanges.size(); i++) {
    final FilteredIndexRange<LongRange,LongRange> range=hilbertRanges.get(i);
    final long startValue=clamp(minHilbertValue,maxHilbertValue,range.getIndexRange().getStart());
    final long endValue=clamp(minHilbertValue,maxHilbertValue,range.getIndexRange().getEnd());
    final byte[] start=HilbertSFC.fitExpectedByteCount(expectedByteCount,ByteBuffer.allocate(8).putLong(startValue).array());
    final byte[] end=HilbertSFC.fitExpectedByteCount(expectedByteCount,ByteBuffer.allocate(8).putLong(endValue).array());
    sfcRanges[i]=new ByteArrayRange(new ByteArrayId(start),new ByteArrayId(end));
  }
  final RangeDecomposition rangeDecomposition=new RangeDecomposition(sfcRanges);
  return rangeDecomposition;
}",0.9513494318181818
113164,"@Override public void init(final SFCDimensionDefinition[] dimensionDefs){
  binsPerDimension=new BigDecimal[dimensionDefs.length];
  for (int d=0; d < dimensionDefs.length; d++) {
    final SFCDimensionDefinition dimension=dimensionDefs[d];
    binsPerDimension[d]=TWO.pow(dimension.getBitsOfPrecision());
  }
}","@Override public void init(final SFCDimensionDefinition[] dimensionDefs){
  binsPerDimension=new BigDecimal[dimensionDefs.length];
  int totalPrecision=0;
  for (int d=0; d < dimensionDefs.length; d++) {
    final SFCDimensionDefinition dimension=dimensionDefs[d];
    binsPerDimension[d]=TWO.pow(dimension.getBitsOfPrecision());
    totalPrecision+=dimension.getBitsOfPrecision();
  }
  minHilbertValue=BigInteger.ZERO;
  maxHilbertValue=TWO.pow(totalPrecision).subtract(BigDecimal.ONE).toBigInteger();
}",0.7622549019607843
113165,"@Override public RangeDecomposition decomposeRange(final NumericData[] rangePerDimension,final CompactHilbertCurve compactHilbertCurve,final SFCDimensionDefinition[] dimensionDefinitions,final int totalPrecision,final int maxFilteredIndexedRanges,final boolean removeVacuum){
  final List<BigInteger> minRangeList=new ArrayList<BigInteger>();
  final List<BigInteger> maxRangeList=new ArrayList<BigInteger>();
  final BigIntegerContent zero=new BigIntegerContent(BigInteger.valueOf(0L));
  final List<BigIntegerRange> region=new ArrayList<BigIntegerRange>(dimensionDefinitions.length);
  for (int d=0; d < dimensionDefinitions.length; d++) {
    final BigInteger normalizedMin=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMin(),binsPerDimension[d]);
    final BigInteger normalizedMax=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMax(),binsPerDimension[d]);
    minRangeList.add(normalizedMin);
    maxRangeList.add(normalizedMax);
    region.add(BigIntegerRange.of(normalizedMin,normalizedMax.add(BigInteger.ONE)));
  }
  final BigInteger minQuadSize=getMinimumQuadSize(minRangeList,maxRangeList);
  final RegionInspector<BigIntegerRange,BigIntegerContent> regionInspector=SimpleRegionInspector.create(ImmutableList.of(region),new BigIntegerContent(minQuadSize),Functions.<BigIntegerRange>identity(),BigIntegerRangeHome.INSTANCE,zero);
  final PlainFilterCombiner<BigIntegerRange,BigInteger,BigIntegerContent,BigIntegerRange> intervalCombiner=new PlainFilterCombiner<BigIntegerRange,BigInteger,BigIntegerContent,BigIntegerRange>(BigIntegerRange.of(0,1));
  final QueryBuilder<BigIntegerRange,BigIntegerRange> queryBuilder=BacktrackingQueryBuilder.create(regionInspector,intervalCombiner,maxFilteredIndexedRanges,removeVacuum,BigIntegerRangeHome.INSTANCE,zero);
  compactHilbertCurve.accept(new ZoomingSpaceVisitorAdapter(compactHilbertCurve,queryBuilder));
  final List<FilteredIndexRange<BigIntegerRange,BigIntegerRange>> hilbertRanges=queryBuilder.get().getFilteredIndexRanges();
  final ByteArrayRange[] sfcRanges=new ByteArrayRange[hilbertRanges.size()];
  final int expectedByteCount=(int)Math.ceil(totalPrecision / 8.0);
  if (expectedByteCount <= 0) {
    return new RangeDecomposition(new ByteArrayRange[]{new ByteArrayRange(new ByteArrayId(new byte[]{}),new ByteArrayId(new byte[]{}))});
  }
  for (int i=0; i < hilbertRanges.size(); i++) {
    final FilteredIndexRange<BigIntegerRange,BigIntegerRange> range=hilbertRanges.get(i);
    final byte[] start=HilbertSFC.fitExpectedByteCount(expectedByteCount,range.getIndexRange().getStart().toByteArray());
    final byte[] end=HilbertSFC.fitExpectedByteCount(expectedByteCount,range.getIndexRange().getEnd().toByteArray());
    sfcRanges[i]=new ByteArrayRange(new ByteArrayId(start),new ByteArrayId(end));
  }
  final RangeDecomposition rangeDecomposition=new RangeDecomposition(sfcRanges);
  return rangeDecomposition;
}","@Override public RangeDecomposition decomposeRange(final NumericData[] rangePerDimension,final CompactHilbertCurve compactHilbertCurve,final SFCDimensionDefinition[] dimensionDefinitions,final int totalPrecision,final int maxFilteredIndexedRanges,final boolean removeVacuum){
  final List<BigInteger> minRangeList=new ArrayList<BigInteger>();
  final List<BigInteger> maxRangeList=new ArrayList<BigInteger>();
  final BigIntegerContent zero=new BigIntegerContent(BigInteger.valueOf(0L));
  final List<BigIntegerRange> region=new ArrayList<BigIntegerRange>(dimensionDefinitions.length);
  for (int d=0; d < dimensionDefinitions.length; d++) {
    final BigInteger normalizedMin=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMin(),binsPerDimension[d]);
    final BigInteger normalizedMax=normalizeDimension(dimensionDefinitions[d],rangePerDimension[d].getMax(),binsPerDimension[d]);
    minRangeList.add(normalizedMin);
    maxRangeList.add(normalizedMax);
    region.add(BigIntegerRange.of(normalizedMin,normalizedMax.add(BigInteger.ONE)));
  }
  final BigInteger minQuadSize=getMinimumQuadSize(minRangeList,maxRangeList);
  final RegionInspector<BigIntegerRange,BigIntegerContent> regionInspector=SimpleRegionInspector.create(ImmutableList.of(region),new BigIntegerContent(minQuadSize),Functions.<BigIntegerRange>identity(),BigIntegerRangeHome.INSTANCE,zero);
  final PlainFilterCombiner<BigIntegerRange,BigInteger,BigIntegerContent,BigIntegerRange> intervalCombiner=new PlainFilterCombiner<BigIntegerRange,BigInteger,BigIntegerContent,BigIntegerRange>(BigIntegerRange.of(0,1));
  final QueryBuilder<BigIntegerRange,BigIntegerRange> queryBuilder=BacktrackingQueryBuilder.create(regionInspector,intervalCombiner,maxFilteredIndexedRanges,removeVacuum,BigIntegerRangeHome.INSTANCE,zero);
  compactHilbertCurve.accept(new ZoomingSpaceVisitorAdapter(compactHilbertCurve,queryBuilder));
  final List<FilteredIndexRange<BigIntegerRange,BigIntegerRange>> hilbertRanges=queryBuilder.get().getFilteredIndexRanges();
  final ByteArrayRange[] sfcRanges=new ByteArrayRange[hilbertRanges.size()];
  final int expectedByteCount=(int)Math.ceil(totalPrecision / 8.0);
  if (expectedByteCount <= 0) {
    return new RangeDecomposition(new ByteArrayRange[]{new ByteArrayRange(new ByteArrayId(new byte[]{}),new ByteArrayId(new byte[]{}))});
  }
  for (int i=0; i < hilbertRanges.size(); i++) {
    final FilteredIndexRange<BigIntegerRange,BigIntegerRange> range=hilbertRanges.get(i);
    final BigInteger startValue=clamp(minHilbertValue,maxHilbertValue,range.getIndexRange().getStart());
    final BigInteger endValue=clamp(minHilbertValue,maxHilbertValue,range.getIndexRange().getEnd());
    final byte[] start=HilbertSFC.fitExpectedByteCount(expectedByteCount,startValue.toByteArray());
    final byte[] end=HilbertSFC.fitExpectedByteCount(expectedByteCount,endValue.toByteArray());
    sfcRanges[i]=new ByteArrayRange(new ByteArrayId(start),new ByteArrayId(end));
  }
  final RangeDecomposition rangeDecomposition=new RangeDecomposition(sfcRanges);
  return rangeDecomposition;
}",0.9523809523809524
113166,"protected List<ByteArrayId> decomposeRangesForEntry(final BinnedNumericDataset index,final int tier){
  final List<ByteArrayId> retVal=new ArrayList<ByteArrayId>();
  final byte[] tierAndBinId=ByteArrayUtils.combineArrays(new byte[]{(byte)tier},index.getBinId());
  final RangeDecomposition rangeDecomp=orderedSfcs[tier].decomposeQuery(index,DEFAULT_MAX_RANGES);
  for (  final ByteArrayRange range : rangeDecomp.getRanges()) {
    final byte[] currentRowId=Arrays.copyOf(range.getStart().getBytes(),range.getStart().getBytes().length);
    final int increment=(orderedSfcs[tier].getBitsOfPrecision() % 8) + 1;
    retVal.add(new ByteArrayId(ByteArrayUtils.combineArrays(tierAndBinId,currentRowId)));
    while (!Arrays.equals(currentRowId,range.getEnd().getBytes())) {
      boolean overflow=false;
      for (int i=0; i < increment; i++) {
        if (!ByteArrayUtils.increment(currentRowId)) {
          LOGGER.warn(""String_Node_Str"");
          overflow=true;
          break;
        }
        if (Arrays.equals(currentRowId,range.getEnd().getBytes())) {
          break;
        }
      }
      if (!overflow) {
        retVal.add(new ByteArrayId(ByteArrayUtils.combineArrays(tierAndBinId,currentRowId)));
      }
    }
  }
  return retVal;
}","protected List<ByteArrayId> decomposeRangesForEntry(final BinnedNumericDataset index,final int tier){
  final List<ByteArrayId> retVal=new ArrayList<ByteArrayId>();
  final byte[] tierAndBinId=ByteArrayUtils.combineArrays(new byte[]{(byte)tier},index.getBinId());
  final RangeDecomposition rangeDecomp=orderedSfcs[tier].decomposeQuery(index,DEFAULT_MAX_RANGES);
  for (  final ByteArrayRange range : rangeDecomp.getRanges()) {
    final byte[] currentRowId=Arrays.copyOf(range.getStart().getBytes(),range.getStart().getBytes().length);
    final int increment=(int)Math.pow(2,getNumPaddedBitsInByte(orderedSfcs[tier].getBitsOfPrecision()));
    retVal.add(new ByteArrayId(ByteArrayUtils.combineArrays(tierAndBinId,currentRowId)));
    while (!Arrays.equals(currentRowId,range.getEnd().getBytes())) {
      boolean overflow=false;
      for (int i=0; i < increment; i++) {
        if (!ByteArrayUtils.increment(currentRowId)) {
          LOGGER.warn(""String_Node_Str"");
          ;
          overflow=true;
          break;
        }
        if (Arrays.equals(currentRowId,range.getEnd().getBytes())) {
          break;
        }
      }
      if (!overflow) {
        retVal.add(new ByteArrayId(ByteArrayUtils.combineArrays(tierAndBinId,currentRowId)));
      }
    }
  }
  return retVal;
}",0.9759747932256794
113167,"/** 
 * You can get results calling getResults() method.
 * @param neuralNetwork type of neural net
 * @param dataSet
 */
@Override public void train(DataSet dataSet){
  generateTrainingSettings();
  List<TrainingResult> statResults=null;
  DataSet trainingSet, testSet;
  if (splitTrainTest) {
    List<DataSet> dataSplit=dataSet.split(splitPercentage,100 - splitPercentage);
    trainingSet=dataSplit.get(0);
    testSet=dataSplit.get(1);
  }
 else {
    trainingSet=dataSet;
    testSet=dataSet;
  }
  if (generateStatistics) {
    statResults=new ArrayList<>();
  }
  int trainingNo=0;
  for (  TrainingSettings trainingSetting : trainingSettingsList) {
    System.out.println(""String_Node_Str"");
    trainingNo++;
    System.out.println(""String_Node_Str"" + trainingNo);
    trainingSetting.setTrainingSet(splitPercentage);
    trainingSetting.setTestSet(100 - splitPercentage);
    for (int subtrainNo=1; subtrainNo <= repeat; subtrainNo++) {
      System.out.println(""String_Node_Str"" + subtrainNo);
      MultiLayerPerceptron neuralNet=new MultiLayerPerceptron(dataSet.getInputSize(),trainingSetting.getHiddenNeurons(),dataSet.getOutputSize());
      BackPropagation bp=neuralNet.getLearningRule();
      bp.setLearningRate(trainingSetting.getLearningRate());
      bp.setMaxError(trainingSetting.getMaxError());
      bp.setMaxIterations(trainingSetting.getMaxIterations());
      neuralNet.learn(trainingSet);
      ConfusionMatrix cm=new ConfusionMatrix(new String[]{""String_Node_Str""});
      TrainingResult result=new TrainingResult(trainingSetting,bp.getTotalNetworkError(),bp.getCurrentIteration(),cm);
      System.out.println(subtrainNo + ""String_Node_Str"" + bp.getCurrentIteration());
      if (generateStatistics) {
        statResults.add(result);
      }
 else {
        results.add(result);
      }
    }
    if (generateStatistics) {
      TrainingResult trainingStats=calculateTrainingStatistics(trainingSetting,statResults);
      results.add(trainingStats);
      statResults.clear();
    }
  }
}","/** 
 * You can get results calling getResults() method.
 * @param neuralNetwork type of neural net
 * @param dataSet
 */
public void train(DataSet dataSet){
  generateTrainingSettings();
  List<TrainingResult> statResults=null;
  DataSet trainingSet, testSet;
  if (splitTrainTest) {
    List<DataSet> dataSplit=dataSet.split(splitPercentage,100 - splitPercentage);
    trainingSet=dataSplit.get(0);
    testSet=dataSplit.get(1);
  }
 else {
    trainingSet=dataSet;
    testSet=dataSet;
  }
  if (generateStatistics) {
    statResults=new ArrayList<>();
  }
  int trainingNo=0;
  for (  TrainingSettings trainingSetting : trainingSettingsList) {
    System.out.println(""String_Node_Str"");
    trainingNo++;
    System.out.println(""String_Node_Str"" + trainingNo);
    trainingSetting.setTrainingSet(splitPercentage);
    trainingSetting.setTestSet(100 - splitPercentage);
    for (int subtrainNo=1; subtrainNo <= repeat; subtrainNo++) {
      System.out.println(""String_Node_Str"" + subtrainNo);
      MultiLayerPerceptron neuralNet=new MultiLayerPerceptron(dataSet.getInputSize(),trainingSetting.getHiddenNeurons(),dataSet.getOutputSize());
      BackPropagation bp=neuralNet.getLearningRule();
      bp.setLearningRate(trainingSetting.getLearningRate());
      bp.setMaxError(trainingSetting.getMaxError());
      bp.setMaxIterations(trainingSetting.getMaxIterations());
      neuralNet.learn(trainingSet);
      ConfusionMatrix cm=new ConfusionMatrix(new String[]{""String_Node_Str""});
      TrainingResult result=new TrainingResult(trainingSetting,bp.getTotalNetworkError(),bp.getCurrentIteration(),cm);
      System.out.println(subtrainNo + ""String_Node_Str"" + bp.getCurrentIteration());
      if (generateStatistics) {
        statResults.add(result);
      }
 else {
        results.add(result);
      }
    }
    if (generateStatistics) {
      TrainingResult trainingStats=calculateTrainingStatistics(trainingSetting,statResults);
      results.add(trainingStats);
      statResults.clear();
    }
  }
}",0.9975198412698412
113168,"/** 
 * Returns the slope parametar of this function
 * @return slope parametar of this function
 */
public double getSlope(){
  return this.slope;
}","/** 
 * Returns the slope parameter of this function
 * @return slope parameter of this function
 */
public double getSlope(){
  return slope;
}",0.969283276450512
113169,"public double getAmplitude(){
  return amplitude;
}","/** 
 * Returns the amplitude parameter of this function
 * @return amplitude parameter of this function
 */
public double getAmplitude(){
  return amplitude;
}",0.4834123222748815
113170,"@Override final public double getDerivative(double net){
  return (1d - output * output);
}","/** 
 * Returns the derivative of this function evaluated at x=input
 * @param input location to evaluate the derivative
 * @return derivative of this function evaluated at x=input
 */
@Override final public double getDerivative(double input){
  if (Math.abs(input) * slope > 100) {
    return 0.0d;
  }
  double E_x=Math.exp(2 * slope * input);
  double tanhsx=(E_x - 1d) / (E_x + 1d);
  derivativeOutput=amplitude * slope * (1.0d - tanhsx * tanhsx);
  return derivativeOutput;
}",0.2276707530647986
113171,"public void setAmplitude(double amplitude){
  this.amplitude=amplitude;
}","/** 
 * Sets the slope parameter for this function
 * @param amplitude value for the amplitude parameter
 */
public void setAmplitude(double amplitude){
  this.amplitude=amplitude;
}",0.5725490196078431
113172,"/** 
 * Sets the slope parametar for this function
 * @param slope value for the slope parametar
 */
public void setSlope(double slope){
  this.slope=slope;
}","/** 
 * Sets the slope parameter for this function
 * @param slope value for the slope parameter
 */
public void setSlope(double slope){
  this.slope=slope;
}",0.9873417721518988
113173,"@Override final public double getOutput(double input){
  if (input > 100) {
    return 1.0;
  }
 else   if (input < -100) {
    return -1.0;
  }
  double E_x=Math.exp(this.slope * input);
  this.output=amplitude * ((E_x - 1d) / (E_x + 1d));
  return this.output;
}","/** 
 * Returns the value of this function at x=input
 * @param input location to evaluate this function
 * @return value of this function at x=input
 */
@Override final public double getOutput(double input){
  if (Math.abs(input) * slope > 100) {
    return Math.signum(input) * 1.0d;
  }
  double E_x=Math.exp(2.0d * slope * input);
  output=amplitude * ((E_x - 1.0d) / (E_x + 1.0d));
  return output;
}",0.5829596412556054
113174,"@Parameters public static Collection getparameters(){
  return Arrays.asList(new Object[][]{{.1,.0249947929,.940014848},{.2,.0499583,.786447},{.3,.07485969,.596585},{.4,.09966799,.419974},{.5,.124353,.280414},{.6,.1488850,.1807066},{.7,.17323515,.113812},{.8,.1973753,.070650},{.9,.22127846,.043464}});
}","@Parameters public static Collection getparameters(){
  return Arrays.asList(new Object[][]{{.1,0.5,1.5,.0749376d,.748128d},{.2,0.5,1.5,.149502d,.74255d},{.3,0.5,1.5,.223328d,.733375d},{.4,0.5,1.5,.296063d,.720782d},{.5,0.5,1.5,.367378d,.705011d},{.6,0.5,1.5,.436969d,.686353d},{.7,0.5,1.5,.504563d,.665139d},{.8,0.5,1.5,.569923d,.641729d},{.9,0.5,1.5,.632849d,.616501d}});
}",0.3004418262150221
113175,"@Before public void setUp(){
  instance=new Tanh();
  instance.setSlope(.5);
}","@Before public void setUp(){
  instance=new Tanh();
  instance.setSlope(slope);
  instance.setAmplitude(amplitude);
}",0.7897435897435897
113176,"/** 
 * Test of getDerivative method, of class Tanh.
 */
@Test public void testGetDerivative(){
  instance.setSlope(5);
  double out=instance.getOutput(input);
  double result=instance.getDerivative(input);
  assertEquals(expected_derivative,result,0.00001);
}","/** 
 * Test of getDerivative method, of class Tanh.
 */
@Test public void testGetDerivative(){
  double out=instance.getOutput(input);
  double result=instance.getDerivative(input);
  assertEquals(expected_derivative,result,0.00001);
}",0.9516129032258064
113177,"public TanhTest(double input,double expected,double expected_derivative){
  this.input=input;
  this.expected=expected;
  this.expected_derivative=expected_derivative;
}","public TanhTest(double input,double slope,double amplitude,double expected,double expected_derivative){
  this.input=input;
  this.slope=slope;
  this.amplitude=amplitude;
  this.expected=expected;
  this.expected_derivative=expected_derivative;
}",0.8125
113178,"public MultilayerPerceptronOptimazer(){
  errorEstimationMethod=new KFoldCrossValidation(10);
}","/** 
 * If ErrorEstimationMethod is not provided use KFoldCrossValidation by default
 */
public MultilayerPerceptronOptimazer(){
  errorEstimationMethod=new KFoldCrossValidation(10);
}",0.6810035842293907
113179,"@Override protected DataSetRow getNextDataSetRow(){
  return dataDeque.pop();
}","@Override protected DataSetRow getNextDataSetRow(){
  return dataSet.getRowAt(new Random().nextInt(dataSet.size()));
}",0.7411167512690355
113180,"@Override protected void populateInternalDataStructure(DataSet dataSet){
  dataDeque.addAll(dataSet.getRows());
}","@Override protected void populateInternalDataStructure(DataSet dataSet){
  this.dataSet=dataSet;
}",0.8436018957345972
113181,"@Override protected int getSampleSize(){
  return dataDeque.size();
}","@Override protected int getSampleSize(){
  return dataSet.size();
}",0.9558823529411764
113182,"public RandomSamplingWithRepetition(final int numberOfFolds){
  super(numberOfFolds);
  dataDeque=new ArrayDeque<>();
}","public RandomSamplingWithRepetition(final int numberOfSamples){
  super(numberOfSamples);
}",0.7714285714285715
113183,"public RandomSamplingWithoutRepetition(final int numberOfSamples){
  super(numberOfSamples);
}","public RandomSamplingWithoutRepetition(final int numberOfFolds){
  super(numberOfFolds);
  dataDeque=new ArrayDeque<>();
}",0.7777777777777778
113184,"@Override protected DataSetRow getNextDataSetRow(){
  return dataSet.getRowAt(new Random().nextInt(dataSet.size()));
}","@Override protected DataSetRow getNextDataSetRow(){
  return dataDeque.pop();
}",0.7411167512690355
113185,"@Override protected void populateInternalDataStructure(DataSet dataSet){
  this.dataSet=dataSet;
}","@Override protected void populateInternalDataStructure(DataSet dataSet){
  dataDeque.addAll(dataSet.getRows());
}",0.8436018957345972
113186,"@Override protected int getSampleSize(){
  return dataSet.size() / numberOfSamples;
}","@Override protected int getSampleSize(){
  return dataDeque.size() / numberOfSamples;
}",0.9651162790697676
113187,"public static void fullConectMapLayers(FeatureMapLayer fromLayer,FeatureMapLayer toLayer){
  if (fromLayer instanceof ConvolutionLayer || fromLayer instanceof InputMapLayer) {
    for (int i=0; i < fromLayer.getNumberOfMaps(); i++) {
      for (int j=0; j < toLayer.getNumberOfMaps(); j++) {
        connect(fromLayer,toLayer,i,j);
      }
    }
  }
 else {
    for (int i=0; i < fromLayer.getNumberOfMaps(); i++) {
      connect(fromLayer,toLayer,i,i);
    }
  }
}","public static void fullConectMapLayers(FeatureMapLayer fromLayer,FeatureMapLayer toLayer){
  if (toLayer instanceof ConvolutionLayer) {
    for (int i=0; i < fromLayer.getNumberOfMaps(); i++) {
      for (int j=0; j < toLayer.getNumberOfMaps(); j++) {
        connect(fromLayer,toLayer,i,j);
      }
    }
  }
 else {
    for (int i=0; i < toLayer.getNumberOfMaps(); i++) {
      connect(fromLayer,toLayer,i,i);
    }
  }
}",0.9436936936936936
113188,"public static void main(String[] args){
  try {
    String path=""String_Node_Str"";
    DataSet trainSet=MNISTLoader.loadTrainSet(path,60000);
    DataSet testSet=MNISTLoader.loadTestSet(path,10000);
    ConvolutionNeuralNetwork cnn=new ConvolutionNeuralNetwork();
    MapDimension mapSize=new MapDimension(28,28);
    Kernel convolutionKernel=new Kernel(7,7);
    FeatureMapLayer inputLayer=CNNFactory.creteInputLayer(mapSize);
    FeatureMapLayer convolutionLayer=CNNFactory.createNextLayer(inputLayer,convolutionKernel,Layer2DType.CONVOLUTION);
    cnn.addLayer(inputLayer);
    cnn.addLayer(convolutionLayer);
    CNNFactory.addFeatureMap(inputLayer);
    CNNFactory.addFeatureMaps(convolutionLayer,6);
    CNNFactory.fullConectMapLayers(inputLayer,convolutionLayer);
    NeuronProperties neuronProperties=new NeuronProperties();
    neuronProperties.setProperty(""String_Node_Str"",true);
    neuronProperties.setProperty(""String_Node_Str"",TransferFunctionType.SIGMOID);
    neuronProperties.setProperty(""String_Node_Str"",WeightedSum.class);
    Layer outputLayer=LayerFactory.createLayer(10,neuronProperties);
    cnn.addLayer(outputLayer);
    fullConnect(convolutionLayer,outputLayer,true);
    cnn.setInputNeurons(inputLayer.getNeurons());
    cnn.setOutputNeurons(outputLayer.getNeurons());
    cnn.getLearningRule().setLearningRate(0.2);
    cnn.getLearningRule().setMaxIterations(8);
    cnn.learn(trainSet);
    ModelMetric.calculateModelMetric(cnn,testSet);
    WeightVisualiser visualiser1=new WeightVisualiser(convolutionLayer.getFeatureMap(0),convolutionKernel);
    visualiser1.displayWeights();
    WeightVisualiser visualiser2=new WeightVisualiser(convolutionLayer.getFeatureMap(1),convolutionKernel);
    visualiser2.displayWeights();
    WeightVisualiser visualiser3=new WeightVisualiser(convolutionLayer.getFeatureMap(2),convolutionKernel);
    visualiser3.displayWeights();
    WeightVisualiser visualiser4=new WeightVisualiser(convolutionLayer.getFeatureMap(3),convolutionKernel);
    visualiser4.displayWeights();
    WeightVisualiser visualiser5=new WeightVisualiser(convolutionLayer.getFeatureMap(4),convolutionKernel);
    visualiser5.displayWeights();
    WeightVisualiser visualiser6=new WeightVisualiser(convolutionLayer.getFeatureMap(5),convolutionKernel);
    visualiser6.displayWeights();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  try {
    String path=""String_Node_Str"";
    DataSet trainSet=MNISTLoader.loadTrainSet(path,200);
    DataSet testSet=MNISTLoader.loadTestSet(path,100);
    ConvolutionNeuralNetwork cnn=new ConvolutionNeuralNetwork();
    MapDimension mapSize=new MapDimension(28,28);
    Kernel convolutionKernel=new Kernel(5,5);
    Kernel poolingKernel=new Kernel(2,2);
    Kernel endConvolution=new Kernel(4,4);
    FeatureMapLayer inputLayer=CNNFactory.creteInputLayer(mapSize);
    FeatureMapLayer convolutionLayer=CNNFactory.createNextLayer(inputLayer,convolutionKernel,Layer2DType.CONVOLUTION);
    FeatureMapLayer convolutionLayer2=CNNFactory.createNextLayer(convolutionLayer,poolingKernel,Layer2DType.POOLING);
    FeatureMapLayer convolutionLayer3=CNNFactory.createNextLayer(convolutionLayer2,convolutionKernel,Layer2DType.CONVOLUTION);
    FeatureMapLayer convolutionLayer4=CNNFactory.createNextLayer(convolutionLayer3,poolingKernel,Layer2DType.POOLING);
    FeatureMapLayer convolutionLayer5=CNNFactory.createNextLayer(convolutionLayer4,endConvolution,Layer2DType.CONVOLUTION);
    cnn.addLayer(inputLayer);
    cnn.addLayer(convolutionLayer);
    cnn.addLayer(convolutionLayer2);
    cnn.addLayer(convolutionLayer3);
    cnn.addLayer(convolutionLayer4);
    cnn.addLayer(convolutionLayer5);
    CNNFactory.addFeatureMap(inputLayer);
    CNNFactory.addFeatureMaps(convolutionLayer,6);
    CNNFactory.addFeatureMaps(convolutionLayer2,6);
    CNNFactory.addFeatureMaps(convolutionLayer3,10);
    CNNFactory.addFeatureMaps(convolutionLayer4,10);
    CNNFactory.addFeatureMaps(convolutionLayer5,50);
    CNNFactory.fullConectMapLayers(inputLayer,convolutionLayer);
    CNNFactory.fullConectMapLayers(convolutionLayer,convolutionLayer2);
    CNNFactory.fullConectMapLayers(convolutionLayer2,convolutionLayer3);
    CNNFactory.fullConectMapLayers(convolutionLayer3,convolutionLayer4);
    CNNFactory.fullConectMapLayers(convolutionLayer4,convolutionLayer5);
    Layer layer=cnn.getLayerAt(1);
    NeuronProperties neuronProperties=new NeuronProperties();
    neuronProperties.setProperty(""String_Node_Str"",true);
    neuronProperties.setProperty(""String_Node_Str"",TransferFunctionType.SIGMOID);
    neuronProperties.setProperty(""String_Node_Str"",WeightedSum.class);
    Layer outputLayer=LayerFactory.createLayer(10,neuronProperties);
    cnn.addLayer(outputLayer);
    fullConnect(convolutionLayer5,outputLayer,true);
    cnn.setInputNeurons(inputLayer.getNeurons());
    cnn.setOutputNeurons(outputLayer.getNeurons());
    cnn.getLearningRule().setLearningRate(0.6);
    cnn.getLearningRule().setBatchMode(false);
    cnn.setLearningRule(new BackPropagation());
    cnn.getLearningRule().setMaxIterations(30);
    cnn.learn(trainSet);
    ModelMetric.calculateModelMetric(cnn,testSet);
    WeightVisualiser visualiser1=new WeightVisualiser(convolutionLayer.getFeatureMap(0),convolutionKernel);
    visualiser1.displayWeights();
    WeightVisualiser visualiser2=new WeightVisualiser(convolutionLayer.getFeatureMap(1),convolutionKernel);
    visualiser2.displayWeights();
    WeightVisualiser visualiser3=new WeightVisualiser(convolutionLayer.getFeatureMap(2),convolutionKernel);
    visualiser3.displayWeights();
    WeightVisualiser visualiser4=new WeightVisualiser(convolutionLayer.getFeatureMap(3),convolutionKernel);
    visualiser4.displayWeights();
    WeightVisualiser visualiser5=new WeightVisualiser(convolutionLayer.getFeatureMap(4),convolutionKernel);
    visualiser5.displayWeights();
    WeightVisualiser visualiser6=new WeightVisualiser(convolutionLayer.getFeatureMap(5),convolutionKernel);
    visualiser6.displayWeights();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.7463614063777596
113189,"@Override protected String doInBackground() throws Exception {
  publish(""String_Node_Str"");
  GooglePlayAPI service=App.createConnection(archive);
  service.setLocalization(Locale.getDefault().getCountry());
  service.checkin();
  service.login();
  service.uploadDeviceConfig();
  Archive a=new Archive(archive.getRoot());
  a.setUserId(archive.getUserId());
  a.setPassword(archive.getPassword());
  a.setAndroidId(service.getAndroidID());
  a.saveCredentials();
  return service.getAndroidID();
}","@Override protected String doInBackground() throws Exception {
  publish(""String_Node_Str"");
  GooglePlayAPI service=App.createConnection(archive);
  service.setLocalization(Locale.getDefault().getCountry());
  if (""String_Node_Str"".equals(archive.getAndroidId())) {
    service.checkin();
    service.login();
    service.uploadDeviceConfig();
  }
 else {
    service.login();
  }
  Archive a=new Archive(archive.getRoot());
  a.setUserId(archive.getUserId());
  a.setPassword(archive.getPassword());
  a.setAndroidId(service.getAndroidID());
  a.saveCredentials();
  return service.getAndroidID();
}",0.8773841961852861
113190,"protected void doSearch(){
  if (query.getText().length() == 0) {
    doMessage(""String_Node_Str"");
  }
 else {
    query.setEnabled(false);
    page.setEnabled(false);
    cardLayout.show(main,CARDPROGRESS);
    int offset=(Integer)page.getValue();
    offset=(offset - 1) * 10;
    new SearchWorker(archive,query.getText(),this).withOffset(offset).withLimit(offset + 10).execute();
  }
}","protected void doSearch(){
  if (query.getText().length() == 0) {
    doMessage(""String_Node_Str"");
  }
 else {
    query.setEnabled(false);
    page.setEnabled(false);
    cardLayout.show(main,CARDPROGRESS);
    int offset=(Integer)page.getValue();
    offset=(offset - 1) * 10;
    new SearchWorker(archive,query.getText(),this).withOffset(offset).withLimit(10).execute();
  }
}",0.988296488946684
113191,"protected void doSearch(){
  query.setEnabled(false);
  page.setEnabled(false);
  cardLayout.show(main,CARDPROGRESS);
  int offset=(Integer)page.getValue();
  offset=(offset - 1) * 10;
  new SearchWorker(archive,query.getText(),this).withOffset(offset).withLimit(offset + 10).execute();
}","protected void doSearch(){
  if (query.getText().length() == 0) {
    return;
  }
  query.setEnabled(false);
  page.setEnabled(false);
  cardLayout.show(main,CARDPROGRESS);
  int offset=(Integer)page.getValue();
  offset=(offset - 1) * 10;
  new SearchWorker(archive,query.getText(),this).withOffset(offset).withLimit(offset + 10).execute();
}",0.91283676703645
113192,"private boolean flush(){
  final int size=featureEvents.size();
  if (size == 0) {
    return true;
  }
  int adds=0, removes=0;
  for (Iterator<FeatureEvent> it=featureEvents.values().iterator(); it.hasNext(); ) {
    FeatureEvent fe=it.next();
    it.remove();
    NodeRef left=fe.left;
    NodeRef right=fe.right;
    if (left == null)     adds++;
    if (right == null)     removes++;
    if (!super.feature(left,right)) {
      return false;
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(String.format(""String_Node_Str"",size,totalFeatureEvents,adds,removes,totalMerged,maxHeldFeatures));
  }
  return true;
}","private boolean flush(){
  final int size=featureEvents.size();
  if (size == 0) {
    return true;
  }
  int adds=0, removes=0;
  for (Iterator<FeatureEvent> it=featureEvents.values().iterator(); it.hasNext(); ) {
    FeatureEvent fe=it.next();
    it.remove();
    NodeRef left=fe.left;
    NodeRef right=fe.right;
    if (left == null)     adds++;
    if (right == null)     removes++;
    if (!super.feature(left,right)) {
      return false;
    }
  }
  if (log.isInfoEnabled()) {
    log.info(String.format(""String_Node_Str"",size,totalFeatureEvents,adds,removes,totalMerged,maxHeldFeatures));
  }
  return true;
}",0.9806451612903224
113193,"public boolean merge(FeatureEvent e){
  if (Objects.equals(left,e.right) || Objects.equals(right,e.left)) {
    return false;
  }
  setLeft(e.left);
  setRight(e.right);
  return true;
}","public boolean merge(FeatureEvent e){
  if ((left != null && left.equals(e.right)) || (right != null && right.equals(e.left))) {
    return false;
  }
  setLeft(e.left);
  setRight(e.right);
  return true;
}",0.7531806615776081
113194,"@Override protected boolean canSort(){
  return true;
}","@Override protected boolean canSort(){
  return false;
}",0.9369369369369368
113195,"@Override public <T>T get(Object object,String xpath,@Nullable Class<T> target) throws IllegalArgumentException {
  Bounded b=(Bounded)object;
  Object value=null;
  if (""String_Node_Str"".equals(xpath)) {
    Optional<Envelope> envelope=b.bounds();
    if (envelope.isPresent()) {
      value=JTS.toGeometry(envelope.get(),BOUNDS_GEOM_FAC);
    }
  }
 else {
    final Node node;
    if (b instanceof NodeRef) {
      node=((NodeRef)b).getNode();
    }
 else     if (b instanceof Node) {
      node=(Node)b;
    }
 else {
      node=null;
    }
    if (node != null) {
      if (""String_Node_Str"".equals(xpath)) {
        value=node.getName();
      }
 else {
        value=IndexInfo.getMaterializedAttribute(xpath,node);
      }
    }
    if (value != null && target != null && !target.isInstance(value)) {
      value=Converters.convert(value,target);
    }
  }
  return (T)value;
}","@Override public <T>T get(Object object,String xpath,@Nullable Class<T> target) throws IllegalArgumentException {
  Bounded b=(Bounded)object;
  Object value=null;
  if (""String_Node_Str"".equals(xpath)) {
    value=b.bounds().orNull();
  }
 else {
    final Node node;
    if (b instanceof NodeRef) {
      node=((NodeRef)b).getNode();
    }
 else     if (b instanceof Node) {
      node=(Node)b;
    }
 else {
      node=null;
    }
    if (node != null) {
      if (""String_Node_Str"".equals(xpath)) {
        value=node.getName();
      }
 else {
        value=IndexInfo.getMaterializedAttribute(xpath,node);
      }
    }
    if (value != null && target != null && !target.isInstance(value)) {
      value=Converters.convert(value,target);
    }
  }
  return (T)value;
}",0.9016294508147256
113196,"public WalkInfo buildTreeWalk(){
  WalkInfo info=new WalkInfo();
  info.fullSchema=resolveFullSchema();
  info.nativeFilter=resolveNativeFilter();
  info.requiredProperties=resolveRequiredProperties(info.nativeFilter);
  final ObjectId featureTypeId=typeRef.getMetadataId();
  final ObjectId oldFeatureTypeTree;
  final ObjectId newFeatureTypeTree;
  final ObjectStore treeSource;
{
    final String nativeTypeName=nativeSchema.getTypeName();
    final @Nullable GeometryDescriptor geometryAttribute=nativeSchema.getGeometryDescriptor();
    final Optional<Index> oldHeadIndex;
    final Optional<Index> headIndex;
    final Optional<NodeRef> oldCanonicalTree=resolveCanonicalTree(oldHeadRef,nativeTypeName);
    final Optional<NodeRef> newCanonicalTree=resolveCanonicalTree(headRef,nativeTypeName);
    final ObjectId oldCanonicalTreeId=oldCanonicalTree.isPresent() ? oldCanonicalTree.get().getObjectId() : RevTree.EMPTY_TREE_ID;
    final ObjectId newCanonicalTreeId=newCanonicalTree.isPresent() ? newCanonicalTree.get().getObjectId() : RevTree.EMPTY_TREE_ID;
    Optional<Index> indexes[];
    final boolean ignoreIndex=geometryAttribute == null || this.ignoreIndex || info.nativeFilter instanceof Id;
    if (ignoreIndex) {
      indexes=NO_INDEX;
    }
 else {
      indexes=resolveIndex(oldCanonicalTreeId,newCanonicalTreeId,nativeTypeName,geometryAttribute.getLocalName());
    }
    oldHeadIndex=indexes[0];
    headIndex=indexes[1];
    checkState(!(oldHeadIndex.isPresent() || headIndex.isPresent()) || headIndex.get().info().equals(oldHeadIndex.get().info()));
    if (oldHeadIndex.isPresent()) {
      oldFeatureTypeTree=oldHeadIndex.get().indexTreeId();
      newFeatureTypeTree=headIndex.get().indexTreeId();
    }
 else {
      oldFeatureTypeTree=oldCanonicalTreeId;
      newFeatureTypeTree=newCanonicalTreeId;
    }
    info.materializedIndexProperties=resolveMaterializedProperties(headIndex);
    PrePostFilterSplitter filterSplitter;
    filterSplitter=new PrePostFilterSplitter().extraAttributes(info.materializedIndexProperties).filter(info.nativeFilter).build();
    info.preFilter=filterSplitter.getPreFilter();
    info.postFilter=filterSplitter.getPostFilter();
    info.indexContainsAllRequiredProperties=info.materializedIndexProperties.containsAll(info.requiredProperties);
    info.filterIsFullySupportedByIndex=Filter.INCLUDE.equals(info.postFilter);
    treeSource=headIndex.isPresent() ? repo.indexDatabase() : repo.objectDatabase();
  }
  info.diffOp=repo.command(DiffTree.class);
  info.diffOp.setDefaultMetadataId(featureTypeId).setPreserveIterationOrder(shallPreserveIterationOrder()).setPathFilter(createFidFilter(info.nativeFilter)).setCustomFilter(createIndexPreFilter(info.preFilter,info.filterIsFullySupportedByIndex)).setBoundsFilter(createBoundsFilter(info.fullSchema,info.nativeFilter,newFeatureTypeTree,treeSource)).setChangeTypeFilter(resolveChangeType()).setOldTree(oldFeatureTypeTree).setNewTree(newFeatureTypeTree).setLeftSource(treeSource).setRightSource(treeSource).recordStats();
  return info;
}","public WalkInfo buildTreeWalk(){
  WalkInfo info=new WalkInfo();
  info.fullSchema=resolveFullSchema();
  info.nativeFilter=resolveNativeFilter();
  info.requiredProperties=resolveRequiredProperties(info.nativeFilter);
  final ObjectId featureTypeId=typeRef.getMetadataId();
  final ObjectId oldFeatureTypeTree;
  final ObjectId newFeatureTypeTree;
  final ObjectStore treeSource;
{
    final String nativeTypeName=nativeSchema.getTypeName();
    final @Nullable GeometryDescriptor geometryAttribute=nativeSchema.getGeometryDescriptor();
    final Optional<Index> oldHeadIndex;
    final Optional<Index> headIndex;
    final Optional<NodeRef> oldCanonicalTree=resolveCanonicalTree(oldHeadRef,nativeTypeName);
    final Optional<NodeRef> newCanonicalTree=resolveCanonicalTree(headRef,nativeTypeName);
    final ObjectId oldCanonicalTreeId=oldCanonicalTree.isPresent() ? oldCanonicalTree.get().getObjectId() : RevTree.EMPTY_TREE_ID;
    final ObjectId newCanonicalTreeId=newCanonicalTree.isPresent() ? newCanonicalTree.get().getObjectId() : RevTree.EMPTY_TREE_ID;
    Optional<Index> indexes[];
    final boolean ignoreIndex=geometryAttribute == null || this.ignoreIndex || info.nativeFilter instanceof Id;
    if (ignoreIndex) {
      indexes=NO_INDEX;
    }
 else {
      indexes=resolveIndex(oldCanonicalTreeId,newCanonicalTreeId,nativeTypeName,geometryAttribute.getLocalName());
    }
    oldHeadIndex=indexes[0];
    headIndex=indexes[1];
    checkState(!(oldHeadIndex.isPresent() || headIndex.isPresent()) || headIndex.get().info().equals(oldHeadIndex.get().info()));
    if (oldHeadIndex.isPresent()) {
      oldFeatureTypeTree=oldHeadIndex.get().indexTreeId();
      newFeatureTypeTree=headIndex.get().indexTreeId();
    }
 else {
      oldFeatureTypeTree=oldCanonicalTreeId;
      newFeatureTypeTree=newCanonicalTreeId;
    }
    info.materializedIndexProperties=resolveMaterializedProperties(headIndex);
    PrePostFilterSplitter filterSplitter;
    filterSplitter=new PrePostFilterSplitter().extraAttributes(info.materializedIndexProperties).filter(info.nativeFilter).build();
    info.preFilter=filterSplitter.getPreFilter();
    info.postFilter=filterSplitter.getPostFilter();
    info.indexContainsAllRequiredProperties=info.materializedIndexProperties.containsAll(info.requiredProperties);
    info.filterIsFullySupportedByIndex=Filter.INCLUDE.equals(info.postFilter);
    treeSource=headIndex.isPresent() ? repo.indexDatabase() : repo.objectDatabase();
  }
  info.diffOp=repo.command(DiffTree.class);
  info.diffOp.setDefaultMetadataId(featureTypeId).setPreserveIterationOrder(shallPreserveIterationOrder()).setPathFilter(createFidFilter(info.nativeFilter)).setCustomFilter(createIndexPreFilter(info.preFilter,info.filterIsFullySupportedByIndex)).setChangeTypeFilter(resolveChangeType()).setOldTree(oldFeatureTypeTree).setNewTree(newFeatureTypeTree).setLeftSource(treeSource).setRightSource(treeSource).recordStats();
  return info;
}",0.9831582457895616
113197,"/** 
 * Determines if the returned iterator shall preserve iteration order among successive calls of the same query. <p> This is the case if: <ul> <li>  {@link #limit} and/or {@link #offset} have been set, since most probably the caller isdoing paging </ul>
 */
private boolean shallPreserveIterationOrder(){
  boolean preserveIterationOrder=false;
  preserveIterationOrder|=limit != null || offset != null;
  return preserveIterationOrder;
}","/** 
 * Determines if the returned iterator shall preserve iteration order among successive calls of the same query. <p> This is the case if: <ul> <li>  {@link #limit} and/or {@link #offset} have been set, since most probably the caller isdoing paging </ul>
 */
private boolean shallPreserveIterationOrder(){
  boolean preserveIterationOrder=false;
  preserveIterationOrder|=limit != null || offset != null;
  return true;
}",0.9699769053117784
113198,"@Override public boolean apply(Bounded bounded){
  if (bounded == null) {
    return false;
  }
  if (bounded instanceof Bucket && !(filter instanceof BinarySpatialOperator)) {
    return true;
  }
  if (bounded instanceof NodeRef && ((NodeRef)bounded).getType() == TYPE.TREE) {
    return true;
  }
  return filter.evaluate(bounded);
}","public @Override boolean apply(@Nullable Bounded bounded){
  if (Filter.INCLUDE == filter) {
    return true;
  }
  if (Filter.EXCLUDE == filter) {
    return false;
  }
  if (bounded == null) {
    return false;
  }
  if (bounded instanceof Bucket && !(filter instanceof BinarySpatialOperator)) {
    return true;
  }
  if (bounded instanceof NodeRef && ((NodeRef)bounded).getType() == TYPE.TREE) {
    return true;
  }
  return filter.evaluate(bounded);
}",0.8297604035308953
113199,"public static Predicate<Bounded> forFilter(Filter filter){
  if (Filter.INCLUDE.equals(filter)) {
    return Predicates.alwaysTrue();
  }
  if (Filter.EXCLUDE.equals(filter)) {
    return Predicates.alwaysFalse();
  }
  return new PreFilter(filter);
}","public static PreFilter forFilter(Filter filter){
  return Filter.INCLUDE.equals(filter) ? PreFilter.INCLUDE : Filter.EXCLUDE.equals(filter) ? PreFilter.EXCLUDE : new PreFilter(filter);
}",0.7031963470319634
113200,"private ImmutableSet<Ref> getChangedRefs(){
  ImmutableSet<Ref> changedRefs=transaction.getChangedRefs();
  return changedRefs;
}","private List<ChangedRef> getChangedRefs(){
  return transaction.changedRefs();
}",0.6220095693779905
113201,"private void updateRefs(){
  final Optional<Ref> currHead=command(RefParse.class).setName(Ref.HEAD).call();
  final String currentBranch;
  if (currHead.isPresent() && currHead.get() instanceof SymRef) {
    currentBranch=((SymRef)currHead.get()).getTarget();
  }
 else {
    currentBranch=""String_Node_Str"";
  }
  ImmutableSet<Ref> changedRefs=getChangedRefs();
  try {
    refDatabase().lock();
  }
 catch (  TimeoutException e) {
    Throwables.propagate(e);
  }
  try {
    for (    Ref ref : changedRefs) {
      if (!ref.getName().startsWith(Ref.REFS_PREFIX)) {
        continue;
      }
      Ref updatedRef=ref;
      Optional<Ref> repoRef=command(RefParse.class).setName(ref.getName()).call();
      if (repoRef.isPresent() && repositoryChanged(repoRef.get())) {
        if (rebase) {
          transaction.command(CheckoutOp.class).setSource(ref.getName()).setForce(true).call();
          try {
            transaction.command(RebaseOp.class).setUpstream(Suppliers.ofInstance(repoRef.get().getObjectId())).call();
          }
 catch (          RebaseConflictsException e) {
            Throwables.propagate(e);
          }
          updatedRef=transaction.command(RefParse.class).setName(ref.getName()).call().get();
        }
 else {
          transaction.command(CheckoutOp.class).setSource(ref.getName()).setForce(true).call();
          try {
            transaction.command(MergeOp.class).setAuthor(authorName.orNull(),authorEmail.orNull()).addCommit(repoRef.get().getObjectId()).call();
          }
 catch (          NothingToCommitException e) {
          }
          updatedRef=transaction.command(RefParse.class).setName(ref.getName()).call().get();
        }
      }
      LOGGER.debug(String.format(""String_Node_Str"",ref.getName(),ref.getObjectId(),updatedRef.getObjectId()));
      command(UpdateRef.class).setName(ref.getName()).setNewValue(updatedRef.getObjectId()).call();
      if (currentBranch.equals(ref.getName())) {
        command(UpdateSymRef.class).setName(Ref.HEAD).setNewValue(ref.getName()).call();
        command(UpdateRef.class).setName(Ref.WORK_HEAD).setNewValue(updatedRef.getObjectId()).call();
        command(UpdateRef.class).setName(Ref.STAGE_HEAD).setNewValue(updatedRef.getObjectId()).call();
      }
    }
  }
  finally {
    refDatabase().unlock();
  }
}","private void updateRefs(){
  final Optional<Ref> currHead=command(RefParse.class).setName(Ref.HEAD).call();
  final String currentBranch;
  if (currHead.isPresent() && currHead.get() instanceof SymRef) {
    currentBranch=((SymRef)currHead.get()).getTarget();
  }
 else {
    currentBranch=""String_Node_Str"";
  }
  List<ChangedRef> changedRefs=getChangedRefs();
  try {
    refDatabase().lock();
  }
 catch (  TimeoutException e) {
    Throwables.propagate(e);
  }
  try {
    for (    ChangedRef change : changedRefs) {
      final String refName=change.name;
      if (!refName.startsWith(Ref.REFS_PREFIX)) {
        continue;
      }
      final boolean isDelete=change.newValue == null;
      final boolean isNew=change.orignalValue == null;
      final ObjectId oldCommit=isNew ? null : ObjectId.valueOf(change.orignalValue);
      final ObjectId newCommit=isDelete ? null : ObjectId.valueOf(change.newValue);
      final Optional<Ref> currentRef=command(RefParse.class).setName(refName).call();
      final Ref updatedRef;
      if (currentRef.isPresent() && repositoryChanged(currentRef.get())) {
        if (rebase) {
          transaction.command(CheckoutOp.class).setSource(refName).setForce(true).call();
          try {
            transaction.command(RebaseOp.class).setUpstream(Suppliers.ofInstance(currentRef.get().getObjectId())).call();
          }
 catch (          RebaseConflictsException e) {
            Throwables.propagate(e);
          }
          updatedRef=transaction.command(RefParse.class).setName(refName).call().get();
        }
 else {
          transaction.command(CheckoutOp.class).setSource(refName).setForce(true).call();
          try {
            transaction.command(MergeOp.class).setAuthor(authorName.orNull(),authorEmail.orNull()).addCommit(currentRef.get().getObjectId()).call();
          }
 catch (          NothingToCommitException e) {
          }
          updatedRef=transaction.command(RefParse.class).setName(refName).call().get();
        }
      }
 else {
        updatedRef=isDelete ? null : new Ref(refName,newCommit);
      }
      LOGGER.debug(String.format(""String_Node_Str"",refName,oldCommit,newCommit));
      command(UpdateRef.class).setName(refName).setNewValue(updatedRef == null ? null : updatedRef.getObjectId()).setDelete(isDelete).call();
      if (currentBranch.equals(refName)) {
        command(UpdateSymRef.class).setName(Ref.HEAD).setNewValue(refName).call();
        command(UpdateRef.class).setName(Ref.WORK_HEAD).setNewValue(updatedRef.getObjectId()).call();
        command(UpdateRef.class).setName(Ref.STAGE_HEAD).setNewValue(updatedRef.getObjectId()).call();
      }
    }
  }
  finally {
    refDatabase().unlock();
  }
}",0.7962445065920895
113202,"/** 
 * The set of refs that have either changed since, or didn't exist at, the time the transaction was created.
 */
public ImmutableSet<Ref> getChangedRefs(){
  Set<String> changedRefNames=transactionRefDatabase.getChangedRefs();
  Set<Ref> changedRefs=new HashSet<Ref>();
  for (  String name : changedRefNames) {
    Ref ref=this.command(RefParse.class).setName(name).call().get();
    changedRefs.add(ref);
  }
  return ImmutableSet.copyOf(changedRefs);
}","/** 
 * The set of refs that have either changed since, or didn't exist at, the time the transaction was created.
 */
public @Deprecated ImmutableSet<Ref> getChangedRefs(){
  Set<String> changedRefNames=transactionRefDatabase.getChangedRefs();
  Set<Ref> changedRefs=new HashSet<Ref>();
  for (  String name : changedRefNames) {
    Ref ref=this.command(RefParse.class).setName(name).call().get();
    changedRefs.add(ref);
  }
  return ImmutableSet.copyOf(changedRefs);
}",0.9871244635193132
113203,"/** 
 * Constructs a new   {@code LinearHistoryIterator} with the given parameters.
 * @param tipsList the list of tips to start computing history from
 * @param repo the repository where the commits are stored.
 * @param graphDb
 */
public TopologicalHistoryIterator(final List<ObjectId> tipsList,final Repository repo,GraphDatabase graphDb){
  this.graphDb=graphDb;
  tips=new Stack<RevCommit>();
  stopPoints=Lists.newArrayList();
  for (  ObjectId tip : tipsList) {
    if (!tip.isNull()) {
      final RevCommit commit=repo.getCommit(tip);
      tips.add(commit);
      stopPoints.add(tip);
    }
  }
  this.repo=repo;
}","/** 
 * Constructs a new   {@code LinearHistoryIterator} with the given parameters.
 * @param tipsList the list of tips to start computing history from
 * @param repo the repository where the commits are stored.
 * @param graphDb
 */
public TopologicalHistoryIterator(final List<ObjectId> tipsList,final Repository repo,GraphDatabase graphDb,ObjectId oldestCommitId){
  this.graphDb=graphDb;
  tips=new Stack<RevCommit>();
  stopPoints=Lists.newArrayList();
  stopPoints.add(oldestCommitId);
  this.oldestCommitId=oldestCommitId;
  for (  ObjectId tip : tipsList) {
    if (!tip.isNull()) {
      final RevCommit commit=repo.getCommit(tip);
      tips.add(commit);
      stopPoints.add(tip);
    }
  }
  this.repo=repo;
}",0.9286775631500744
113204,"/** 
 * Executes the log operation.
 * @return the list of commits that satisfy the query criteria, most recent first.
 * @see org.locationtech.geogig.repository.AbstractGeoGigOp#call()
 */
@Override protected Iterator<RevCommit> _call(){
  ObjectId newestCommitId;
  ObjectId oldestCommitId;
{
    if (this.until == null) {
      newestCommitId=command(RevParse.class).setRefSpec(Ref.HEAD).call().get();
    }
 else {
      if (!repository().commitExists(this.until)) {
        throw new IllegalArgumentException(""String_Node_Str"" + until.toString());
      }
      newestCommitId=this.until;
    }
    if (this.since == null) {
      oldestCommitId=ObjectId.NULL;
    }
 else {
      if (!repository().commitExists(this.since)) {
        throw new IllegalArgumentException(""String_Node_Str"" + since.toString());
      }
      oldestCommitId=this.since;
    }
  }
  Iterator<RevCommit> history;
  if (firstParent) {
    history=new LinearHistoryIterator(newestCommitId,repository());
  }
 else {
    if (commits.isEmpty()) {
      commits.add(newestCommitId);
    }
    if (topo) {
      history=new TopologicalHistoryIterator(commits,repository(),graphDatabase());
    }
 else {
      history=new ChronologicalHistoryIterator(commits,repository());
    }
  }
  LogFilter filter=new LogFilter(oldestCommitId,timeRange,paths,author,commiter);
  Iterator<RevCommit> filteredCommits=Iterators.filter(history,filter);
  if (skip != null) {
    Iterators.advance(filteredCommits,skip.intValue());
  }
  if (limit != null) {
    filteredCommits=Iterators.limit(filteredCommits,limit.intValue());
  }
  return filteredCommits;
}","/** 
 * Executes the log operation.
 * @return the list of commits that satisfy the query criteria, most recent first.
 * @see org.locationtech.geogig.repository.AbstractGeoGigOp#call()
 */
@Override protected Iterator<RevCommit> _call(){
  ObjectId newestCommitId;
  ObjectId oldestCommitId;
{
    if (this.until == null) {
      newestCommitId=command(RevParse.class).setRefSpec(Ref.HEAD).call().get();
    }
 else {
      if (!repository().commitExists(this.until)) {
        throw new IllegalArgumentException(""String_Node_Str"" + until.toString());
      }
      newestCommitId=this.until;
    }
    if (this.since == null) {
      oldestCommitId=ObjectId.NULL;
    }
 else {
      if (!repository().commitExists(this.since)) {
        throw new IllegalArgumentException(""String_Node_Str"" + since.toString());
      }
      oldestCommitId=this.since;
    }
  }
  Iterator<RevCommit> history;
  if (firstParent) {
    history=new LinearHistoryIterator(newestCommitId,repository());
  }
 else {
    if (commits.isEmpty()) {
      commits.add(newestCommitId);
    }
    if (topo) {
      history=new TopologicalHistoryIterator(commits,repository(),graphDatabase(),oldestCommitId);
    }
 else {
      history=new ChronologicalHistoryIterator(commits,repository());
    }
  }
  LogFilter filter=new LogFilter(oldestCommitId,timeRange,paths,author,commiter);
  Iterator<RevCommit> filteredCommits=Iterators.filter(history,filter);
  if (skip != null) {
    Iterators.advance(filteredCommits,skip.intValue());
  }
  if (limit != null) {
    filteredCommits=Iterators.limit(filteredCommits,limit.intValue());
  }
  return filteredCommits;
}",0.995397361153728
113205,"protected final void doSetUp() throws IOException, SchemaException, ParseException, Exception {
  repositoryDirectory=repositoryTempFolder.newFolder(""String_Node_Str"" + RANDOM.nextInt());
  injector=createInjector();
  geogig=new GeoGIG(injector);
  repo=geogig.getOrCreateRepository();
  assertNotNull(repo);
  assertTrue(repo.isOpen());
  assertNotNull(repo.configDatabase());
  assertSame(injector,repo.context());
  assertNotNull(repo.objectDatabase());
  assertNotNull(repo.graphDatabase());
  assertNotNull(repo.conflictsDatabase());
  assertNotNull(repo.blobStore());
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
  pointsType=DataUtilities.createType(pointsNs,pointsName,pointsTypeSpec);
  modifiedPointsType=DataUtilities.createType(pointsNs,pointsName,modifiedPointsTypeSpec);
  points1=feature(pointsType,idP1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  points1_modified=feature(pointsType,idP1,""String_Node_Str"",new Integer(1001),""String_Node_Str"");
  points1B=feature(modifiedPointsType,idP1,""String_Node_Str"",new Integer(1000),""String_Node_Str"",""String_Node_Str"");
  points1B_modified=feature(modifiedPointsType,idP1,""String_Node_Str"",new Integer(1001),""String_Node_Str"",""String_Node_Str"");
  points2=feature(pointsType,idP2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  points3=feature(pointsType,idP3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  linesType=DataUtilities.createType(linesNs,linesName,linesTypeSpec);
  lines1=feature(linesType,idL1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  lines2=feature(linesType,idL2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  lines3=feature(linesType,idL3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  polyType=DataUtilities.createType(polyNs,polyName,polyTypeSpec);
  poly1=feature(polyType,idPG1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  poly2=feature(polyType,idPG2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  poly3=feature(polyType,idPG3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  setUpInternal();
}","protected final void doSetUp() throws IOException, SchemaException, ParseException, Exception {
  repositoryDirectory=repositoryTempFolder.newFolder(""String_Node_Str"" + RANDOM.nextInt());
  injector=createInjector();
  geogig=new GeoGIG(injector);
  repo=geogig.getOrCreateRepository();
  assertNotNull(repo);
  assertTrue(repo.isOpen());
  assertNotNull(repo.configDatabase());
  assertSame(injector,repo.context());
  assertNotNull(repo.objectDatabase());
  assertNotNull(repo.graphDatabase());
  assertNotNull(repo.conflictsDatabase());
  assertNotNull(repo.blobStore());
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
  pointsType=DataUtilities.createType(pointsNs,pointsName,pointsTypeSpec);
  modifiedPointsType=DataUtilities.createType(pointsNs,pointsName,modifiedPointsTypeSpec);
  points1=feature(pointsType,idP1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  points1_modified=feature(pointsType,idP1,""String_Node_Str"",new Integer(1001),""String_Node_Str"");
  points1B=feature(modifiedPointsType,idP1,""String_Node_Str"",new Integer(1000),""String_Node_Str"",""String_Node_Str"");
  points1B_modified=feature(modifiedPointsType,idP1,""String_Node_Str"",new Integer(1001),""String_Node_Str"",""String_Node_Str"");
  points2=feature(pointsType,idP2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  points3=feature(pointsType,idP3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  linesType=DataUtilities.createType(linesNs,linesName,linesTypeSpec);
  lines1=feature(linesType,idL1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  lines2=feature(linesType,idL2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  lines3=feature(linesType,idL3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  polyType=DataUtilities.createType(polyNs,polyName,polyTypeSpec);
  poly1=feature(polyType,idPG1,""String_Node_Str"",new Integer(1000),""String_Node_Str"");
  poly2=feature(polyType,idPG2,""String_Node_Str"",new Integer(2000),""String_Node_Str"");
  poly3=feature(polyType,idPG3,""String_Node_Str"",new Integer(3000),""String_Node_Str"");
  points2_modified=feature(pointsType,idP2,""String_Node_Str"",new Integer(2001),""String_Node_Str"");
  points3_modified=feature(pointsType,idP3,""String_Node_Str"",new Integer(3001),""String_Node_Str"");
  lines1_modified=feature(linesType,idL1,""String_Node_Str"",new Integer(1001),""String_Node_Str"");
  setUpInternal();
}",0.9395863198853164
113206,"@Test public void testGetParents() throws Exception {
  Repository repo=repoProvider.createGeogig(""String_Node_Str"",null);
  repoProvider.getTestRepository(""String_Node_Str"").initializeRpository();
  new TestData(repo).init(""String_Node_Str"",""String_Node_Str"").loadDefaultData();
  Iterator<RevCommit> call=repo.command(LogOp.class).call();
  assertTrue(call.hasNext());
  while (call.hasNext()) {
    RevCommit next=call.next();
    ImmutableList<ObjectId> parentIds=next.getParentIds();
    String oid=next.getId().toString();
    MockHttpServletRequestBuilder get=MockMvcRequestBuilders.get(""String_Node_Str"" + oid);
    String[] actualIds=perform(get).andExpect(status().isOk()).andExpect(content().contentType(MediaType.TEXT_PLAIN)).andReturn().getResponse().getContentAsString().split(""String_Node_Str"");
    if (actualIds.length == 1 && actualIds[0].isEmpty()) {
      actualIds=new String[0];
    }
    String[] expectedIds=new String[parentIds.size()];
    int i=0;
    for (    ObjectId parentId : parentIds) {
      expectedIds[i++]=parentId.toString();
    }
    assertArrayEquals(expectedIds,actualIds);
  }
  repo.close();
}","@Test public void testGetParents() throws Exception {
  Repository repo=repoProvider.createGeogig(""String_Node_Str"",null);
  repoProvider.getTestRepository(""String_Node_Str"").initializeRpository();
  new TestData(repo).init(""String_Node_Str"",""String_Node_Str"").loadDefaultData();
  Iterator<RevCommit> call=repo.command(LogOp.class).call();
  assertTrue(call.hasNext());
  while (call.hasNext()) {
    RevCommit next=call.next();
    ImmutableList<ObjectId> parentIds=next.getParentIds();
    String oid=next.getId().toString();
    MockHttpServletRequestBuilder get=MockMvcRequestBuilders.get(""String_Node_Str"" + oid);
    String response=perform(get).andExpect(status().isOk()).andExpect(content().contentType(MediaType.TEXT_PLAIN)).andReturn().getResponse().getContentAsString();
    String[] actualIds=response.split(""String_Node_Str"");
    if (actualIds.length == 1 && actualIds[0].isEmpty()) {
      actualIds=new String[0];
    }
    String[] expectedIds=new String[parentIds.size()];
    int i=0;
    for (    ObjectId parentId : parentIds) {
      expectedIds[i++]=parentId.toString();
    }
    assertArrayEquals(expectedIds,actualIds);
  }
  repo.close();
}",0.9765828274067648
113207,"protected DataStore getDataStore(String geoJSON) throws FileNotFoundException, IOException {
  try {
    File geoJsonfile=new File(geoJSON);
    checkParameter(geoJsonfile.exists(),""String_Node_Str"",geoJsonfile);
    InputStream in=new FileInputStream(geoJsonfile);
    FeatureJSON fjson=new FeatureJSON();
    @SuppressWarnings(""String_Node_Str"") FeatureCollection fc=fjson.readFeatureCollection(in);
    @SuppressWarnings(""String_Node_Str"") DataStore dataStore=new MemoryDataStore(fc);
    return dataStore;
  }
 catch (  IOException ioe) {
    throw new CommandFailedException(""String_Node_Str"" + ioe.getMessage(),ioe);
  }
}","protected DataStore getDataStore(String geoJSON) throws FileNotFoundException, IOException {
  try {
    File geoJsonfile=new File(geoJSON);
    checkParameter(geoJsonfile.exists(),""String_Node_Str"",geoJsonfile);
    InputStream in=new FileInputStream(geoJsonfile);
    FeatureJSON fjson=new FeatureJSON();
    @SuppressWarnings(""String_Node_Str"") FeatureCollection fc=fjson.readFeatureCollection(in);
    MemoryDataStore dataStore=new MemoryDataStore();
    dataStore.addFeatures((SimpleFeatureIterator)fc.features());
    return dataStore;
  }
 catch (  IOException ioe) {
    throw new CommandFailedException(""String_Node_Str"" + ioe.getMessage(),ioe);
  }
}",0.8757763975155279
113208,"@Test public void testImport() throws Exception {
  GeoJsonImport importCommand=new GeoJsonImport();
  importCommand.geoJSONList=new ArrayList<String>();
  importCommand.geoJSONList.add(GeoJsonImport.class.getResource(""String_Node_Str"").getFile());
  importCommand.run(cli);
}","@Test public void testImport() throws Exception {
  GeoJsonImport importCommand=new GeoJsonImport();
  importCommand.geoJSONList=new ArrayList<String>();
  importCommand.geoJSONList.add(GeoJsonImport.class.getResource(""String_Node_Str"").getFile());
  importCommand.destTable=""String_Node_Str"";
  importCommand.run(cli);
  List<NodeRef> nodes=Lists.newArrayList(cli.getGeogig().getRepository().command(LsTreeOp.class).setStrategy(Strategy.DEPTHFIRST).setReference(Ref.WORK_HEAD).call());
  assertEquals(3,nodes.size());
  NodeRef rootNode=nodes.get(0);
  assertEquals(""String_Node_Str"",rootNode.name());
  assertEquals(TYPE.TREE,rootNode.getType());
  NodeRef feature1=nodes.get(1);
  NodeRef feature2=nodes.get(2);
  ObjectId feature1id;
  ObjectId feature2id;
  if (feature1.name().equals(""String_Node_Str"")) {
    assertEquals(""String_Node_Str"",feature2.name());
    feature1id=feature1.getObjectId();
    feature2id=feature2.getObjectId();
  }
 else {
    assertEquals(""String_Node_Str"",feature1.name());
    assertEquals(""String_Node_Str"",feature2.name());
    feature1id=feature2.getObjectId();
    feature2id=feature1.getObjectId();
  }
  assertEquals(TYPE.FEATURE,feature1.getType());
  assertEquals(TYPE.FEATURE,feature2.getType());
  assertEquals(""String_Node_Str"",feature1.getParentPath());
  assertEquals(""String_Node_Str"",feature2.getParentPath());
  ObjectDatabase odb=cli.getGeogig().getRepository().objectDatabase();
  RevFeature feature1Obj=odb.getFeature(feature1id);
  RevFeature feature2Obj=odb.getFeature(feature2id);
  ImmutableSet<PropertyDescriptor> attributes=cli.getGeogig().command(DescribeFeatureType.class).setFeatureType(odb.getFeatureType(rootNode.getMetadataId())).call();
  assertEquals(3,attributes.size());
  int attributeIndex=0;
  for (  PropertyDescriptor attribute : attributes) {
switch (attribute.getName().toString()) {
case ""String_Node_Str"":
      assertTrue(LineString.class.isAssignableFrom(attribute.getType().getBinding()));
    assertEquals(""String_Node_Str"",feature1Obj.get(attributeIndex).get().toString());
  assertEquals(""String_Node_Str"",feature2Obj.get(attributeIndex).get().toString());
break;
case ""String_Node_Str"":
assertTrue(String.class.isAssignableFrom(attribute.getType().getBinding()));
assertEquals(""String_Node_Str"",feature1Obj.get(attributeIndex).get());
assertEquals(""String_Node_Str"",feature2Obj.get(attributeIndex).get());
break;
case ""String_Node_Str"":
assertTrue(Double.class.isAssignableFrom(attribute.getType().getBinding()));
assertEquals(0.0,feature1Obj.get(attributeIndex).get());
assertEquals(0.2,feature2Obj.get(attributeIndex).get());
break;
}
attributeIndex++;
}
}",0.1821917808219178
113209,"@Override public boolean bucket(NodeRef leftParent,NodeRef rightParent,BucketIndex bucketIndex,Bucket left,Bucket right){
  if (left == null || right == null) {
    Bucket bucket=left == null ? right : left;
    addTreeFeatures(bucket.getObjectId(),left != null,right != null);
    return false;
  }
  return true;
}","@Override public boolean bucket(NodeRef leftParent,NodeRef rightParent,BucketIndex bucketIndex,@Nullable Bucket left,@Nullable Bucket right){
  if (bucketIndex.left().isEmpty() || bucketIndex.right().isEmpty()) {
    Bucket bucket=left == null ? right : left;
    addTreeFeatures(bucket.getObjectId(),left != null,right != null);
    return false;
  }
  return true;
}",0.8508771929824561
113210,"@Override public void addConflicts(@Nullable String txId,Iterable<Conflict> conflicts){
  try (RocksDBReference dbRef=getOrCreateDb(txId)){
    ConflictSerializer serializer=new ConflictSerializer();
    try (WriteBatch batch=new WriteBatch()){
      for (      Conflict c : conflicts) {
        byte[] key=key(c.getPath());
        byte[] value=serializer.write(c);
        batch.put(key,value);
      }
      try (WriteOptions writeOptions=new WriteOptions()){
        dbRef.db().write(writeOptions,batch);
      }
     }
 catch (    Exception e) {
      propagate(e);
    }
  }
 }","@Override public void addConflicts(@Nullable String txId,Iterable<Conflict> conflicts){
  try (RocksDBReference dbRef=getOrCreateDb(txId)){
    ConflictSerializer serializer=new ConflictSerializer();
    try (WriteBatch batch=new WriteBatch()){
      for (      Conflict c : conflicts) {
        byte[] key=key(c.getPath());
        byte[] value=serializer.write(c);
        batch.put(key,value);
      }
      try (WriteOptions writeOptions=new WriteOptions()){
        writeOptions.setSync(true);
        dbRef.db().write(writeOptions,batch);
      }
     }
 catch (    Exception e) {
      propagate(e);
    }
  }
 }",0.9700499168053244
113211,"@Override public void removeConflict(@Nullable String txId,String path){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  try (RocksDBReference dbRef=dbRefOpt.get()){
    dbRef.db().remove(key(path));
  }
 catch (  RocksDBException e) {
    propagate(e);
  }
}","@Override public void removeConflict(@Nullable String txId,String path){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  try (RocksDBReference dbRef=dbRefOpt.get()){
    dbRef.db().delete(key(path));
  }
 catch (  RocksDBException e) {
    propagate(e);
  }
}",0.9839228295819936
113212,"@Override public void removeByPrefix(@Nullable String txId,@Nullable String pathPrefix){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  final @Nullable byte[] prefix=pathPrefix == null ? null : key(pathPrefix + ""String_Node_Str"");
  try (RocksDBReference dbRef=dbRefOpt.get();WriteBatch batch=new WriteBatch()){
    if (pathPrefix != null) {
      batch.remove(key(pathPrefix));
    }
    try (RocksIterator it=dbRef.db().newIterator()){
      if (prefix == null) {
        it.seekToFirst();
      }
 else {
        it.seek(prefix);
      }
      while (it.isValid()) {
        byte[] key=it.key();
        if (isPrefix(prefix,key)) {
          batch.remove(key);
        }
 else {
          break;
        }
        it.next();
      }
    }
     try (WriteOptions opts=new WriteOptions()){
      dbRef.db().write(opts,batch);
    }
   }
 catch (  RocksDBException e) {
    propagate(e);
  }
}","@Override public void removeByPrefix(@Nullable String txId,@Nullable String pathPrefix){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  final @Nullable byte[] prefix=pathPrefix == null ? null : key(pathPrefix + ""String_Node_Str"");
  try (RocksDBReference dbRef=dbRefOpt.get();WriteOptions opts=new WriteOptions();WriteBatch batch=new WriteBatch()){
    opts.setSync(true);
    if (pathPrefix != null) {
      batch.remove(key(pathPrefix));
    }
    try (RocksIterator it=dbRef.db().newIterator()){
      if (prefix == null) {
        it.seekToFirst();
      }
 else {
        it.seek(prefix);
      }
      while (it.isValid()) {
        byte[] key=it.key();
        if (isPrefix(prefix,key)) {
          batch.remove(key);
        }
 else {
          break;
        }
        it.next();
      }
    }
     dbRef.db().write(opts,batch);
  }
 catch (  RocksDBException e) {
    propagate(e);
  }
}",0.9261603375527426
113213,"@Override public void removeConflicts(@Nullable String txId,Iterable<String> paths){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  try (RocksDBReference dbRef=dbRefOpt.get();WriteOptions writeOptions=new WriteOptions()){
    writeOptions.setSync(false);
    for (    String path : paths) {
      dbRef.db().remove(writeOptions,key(path));
    }
    writeOptions.sync();
  }
 catch (  RocksDBException e) {
    propagate(e);
  }
}","@Override public void removeConflicts(@Nullable String txId,Iterable<String> paths){
  Optional<RocksDBReference> dbRefOpt=getDb(txId);
  if (!dbRefOpt.isPresent()) {
    return;
  }
  try (RocksDBReference dbRef=dbRefOpt.get();WriteOptions writeOptions=new WriteOptions();WriteBatch batch=new WriteBatch()){
    writeOptions.setSync(true);
    for (    String path : paths) {
      batch.remove(key(path));
    }
    dbRef.db().write(writeOptions,batch);
  }
 catch (  RocksDBException e) {
    propagate(e);
  }
}",0.8476953907815631
113214,"@Override public boolean put(ObjectId commitId,ImmutableList<ObjectId> parentIds){
  @Nullable NodeData node=getNodeInternal(commitId,false);
  boolean updated=false;
  try (WriteBatch batch=new WriteBatch()){
    if (node == null) {
      node=new NodeData(commitId,parentIds);
      updated=true;
    }
    for (    ObjectId parent : parentIds) {
      if (!node.outgoing.contains(parent)) {
        node.outgoing.add(parent);
        updated=true;
      }
      NodeData parentNode=getNodeInternal(parent,false);
      if (parentNode == null) {
        parentNode=new NodeData(parent);
        updated=true;
      }
      if (!parentNode.incoming.contains(commitId)) {
        parentNode.incoming.add(commitId);
        updated=true;
      }
      batch.put(parent.getRawValue(),BINDING.objectToEntry(parentNode));
    }
    batch.put(commitId.getRawValue(),BINDING.objectToEntry(node));
    try (RocksDBReference dbRef=dbhandle.getReference();WriteOptions wo=new WriteOptions()){
      dbRef.db().write(wo,batch);
    }
   }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
  return updated;
}","@Override public boolean put(ObjectId commitId,ImmutableList<ObjectId> parentIds){
  @Nullable NodeData node=getNodeInternal(commitId,false);
  boolean updated=false;
  try (WriteBatch batch=new WriteBatch()){
    if (node == null) {
      node=new NodeData(commitId,parentIds);
      updated=true;
    }
    for (    ObjectId parent : parentIds) {
      if (!node.outgoing.contains(parent)) {
        node.outgoing.add(parent);
        updated=true;
      }
      NodeData parentNode=getNodeInternal(parent,false);
      if (parentNode == null) {
        parentNode=new NodeData(parent);
        updated=true;
      }
      if (!parentNode.incoming.contains(commitId)) {
        parentNode.incoming.add(commitId);
        updated=true;
      }
      batch.put(parent.getRawValue(),BINDING.objectToEntry(parentNode));
    }
    batch.put(commitId.getRawValue(),BINDING.objectToEntry(node));
    try (RocksDBReference dbRef=dbhandle.getReference();WriteOptions wo=new WriteOptions()){
      wo.setSync(true);
      dbRef.db().write(wo,batch);
    }
   }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
  return updated;
}",0.98932384341637
113215,"@Override public void truncate(){
  try (RocksDBReference dbRef=dbhandle.getReference()){
    try (RocksIterator it=dbRef.db().newIterator()){
      it.seekToFirst();
      try (WriteOptions wo=new WriteOptions()){
        wo.setDisableWAL(true);
        wo.setSync(false);
        while (it.isValid()) {
          dbRef.db().remove(wo,it.key());
          it.next();
        }
        wo.sync();
      }
     }
 catch (    RocksDBException e) {
      throw propagate(e);
    }
  }
 }","@Override public void truncate(){
  try (RocksDBReference dbRef=dbhandle.getReference()){
    try (RocksIterator it=dbRef.db().newIterator()){
      it.seekToFirst();
      try (WriteOptions wo=new WriteOptions();WriteBatch batch=new WriteBatch()){
        wo.setSync(true);
        while (it.isValid()) {
          batch.remove(it.key());
          it.next();
        }
        dbRef.db().write(wo,batch);
      }
     }
 catch (    RocksDBException e) {
      throw propagate(e);
    }
  }
 }",0.6728016359918201
113216,"@Override public void deleteAll(Iterator<ObjectId> ids,BulkOpListener listener){
  checkNotNull(ids,""String_Node_Str"");
  checkNotNull(listener,""String_Node_Str"");
  checkWritable();
  final boolean checkExists=!BulkOpListener.NOOP_LISTENER.equals(listener);
  byte[] keybuff=new byte[ObjectId.NUM_BYTES];
  try (RocksDBReference dbRef=dbhandle.getReference();ReadOptions ro=new ReadOptions()){
    ro.setFillCache(false);
    ro.setVerifyChecksums(false);
    try (WriteOptions writeOps=new WriteOptions()){
      writeOps.setSync(false);
      while (ids.hasNext()) {
        ObjectId id=ids.next();
        id.getRawValue(keybuff);
        if (!checkExists || exists(dbRef,ro,keybuff)) {
          try {
            dbRef.db().remove(writeOps,keybuff);
          }
 catch (          RocksDBException e) {
            throw Throwables.propagate(e);
          }
          listener.deleted(id);
        }
 else {
          listener.notFound(id);
        }
      }
      writeOps.sync();
    }
   }
 }","@Override public void deleteAll(Iterator<ObjectId> ids,BulkOpListener listener){
  checkNotNull(ids,""String_Node_Str"");
  checkNotNull(listener,""String_Node_Str"");
  checkWritable();
  final boolean checkExists=!BulkOpListener.NOOP_LISTENER.equals(listener);
  byte[] keybuff=new byte[ObjectId.NUM_BYTES];
  try (RocksDBReference dbRef=dbhandle.getReference();ReadOptions ro=new ReadOptions()){
    ro.setFillCache(false);
    ro.setVerifyChecksums(false);
    try (WriteOptions writeOps=new WriteOptions();WriteBatch batch=new WriteBatch()){
      writeOps.setSync(true);
      while (ids.hasNext()) {
        ObjectId id=ids.next();
        id.getRawValue(keybuff);
        if (!checkExists || exists(dbRef,ro,keybuff)) {
          batch.remove(keybuff);
          listener.deleted(id);
        }
 else {
          listener.notFound(id);
        }
      }
      try {
        dbRef.db().write(writeOps,batch);
      }
 catch (      RocksDBException e) {
        throw Throwables.propagate(e);
      }
    }
   }
 }",0.8323412698412699
113217,"@Override public <T>T convert(Object source,Class<T> target) throws Exception {
  if (source == null) {
    return null;
  }
  Preconditions.checkArgument(source.getClass().equals(String.class));
  Preconditions.checkArgument(target.isArray());
  Preconditions.checkArgument(target.getComponentType().isPrimitive());
  final FieldType arrayType=FieldType.forBinding(target);
  Preconditions.checkState(arrayType.getBinding().isArray());
  final List<String> list=Splitter.on(';').omitEmptyStrings().trimResults().splitToList((CharSequence)source);
  final int length=list.size();
  Object array=Array.newInstance(target.getComponentType(),length);
  for (int i=0; i < length; i++) {
    String val=list.get(i);
switch (arrayType) {
case BOOLEAN_ARRAY:
      Array.setBoolean(array,i,Boolean.parseBoolean(val));
    break;
case BYTE_ARRAY:
  Array.setByte(array,i,Byte.parseByte(val));
break;
case SHORT_ARRAY:
Array.setShort(array,i,Short.parseShort(val));
break;
case INTEGER_ARRAY:
Array.setInt(array,i,Integer.parseInt(val));
break;
case LONG_ARRAY:
Array.setLong(array,i,Long.parseLong(val));
break;
case FLOAT_ARRAY:
Array.setFloat(array,i,Float.parseFloat(val));
break;
case DOUBLE_ARRAY:
Array.setDouble(array,i,Double.parseDouble(val));
break;
default :
throw new IllegalArgumentException();
}
}
return (T)array;
}","@Override public <T>T convert(Object source,Class<T> target) throws Exception {
  Preconditions.checkArgument(source == null || source.getClass().equals(String.class));
  Preconditions.checkArgument(target.isArray());
  Preconditions.checkArgument(target.getComponentType().isPrimitive());
  if (source == null || ((String)source).trim().isEmpty()) {
    return null;
  }
  final FieldType arrayType=FieldType.forBinding(target);
  Preconditions.checkState(arrayType.getBinding().isArray());
  String string=(String)source;
  if (!string.startsWith(""String_Node_Str"") && !string.endsWith(""String_Node_Str"")) {
    return null;
  }
  string=string.substring(1);
  string=string.substring(0,string.length() - 1);
  final List<String> list=Splitter.on(',').omitEmptyStrings().trimResults().splitToList(string);
  final int length=list.size();
  Object array=Array.newInstance(target.getComponentType(),length);
  for (int i=0; i < length; i++) {
    String val=list.get(i);
switch (arrayType) {
case BOOLEAN_ARRAY:
      Array.setBoolean(array,i,Boolean.parseBoolean(val));
    break;
case BYTE_ARRAY:
  Array.setByte(array,i,Byte.parseByte(val));
break;
case SHORT_ARRAY:
Array.setShort(array,i,Short.parseShort(val));
break;
case INTEGER_ARRAY:
Array.setInt(array,i,Integer.parseInt(val));
break;
case LONG_ARRAY:
Array.setLong(array,i,Long.parseLong(val));
break;
case FLOAT_ARRAY:
Array.setFloat(array,i,Float.parseFloat(val));
break;
case DOUBLE_ARRAY:
Array.setDouble(array,i,Double.parseDouble(val));
break;
default :
throw new IllegalArgumentException();
}
}
return (T)array;
}",0.7617079889807162
113218,"@Test public void roundtripTest(){
  Map<String,? extends Object> map=ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Integer.valueOf(12345),""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new Long(789)));
  assertNull(Converters.convert(map,Integer.class));
  String converted=Converters.convert(map,String.class);
  assertNotNull(converted);
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> roundTripped=Converters.convert(converted,Map.class);
  assertNotNull(roundTripped);
  assertEquals(map,roundTripped);
}","@Test public void roundtripTest(){
  Map<String,Object> map=new HashMap<>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",Integer.valueOf(12345));
  map.put(""String_Node_Str"",null);
  map.put(""String_Node_Str"",new double[]{Math.PI,Double.MIN_VALUE,Double.MAX_VALUE});
  map.put(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new Long(789)));
  assertNull(Converters.convert(map,Integer.class));
  String converted=Converters.convert(map,String.class);
  assertNotNull(converted);
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> roundTripped=Converters.convert(converted,Map.class);
  assertNotNull(roundTripped);
  assertEquals(map.size(),roundTripped.size());
  assertEquals(map.keySet(),roundTripped.keySet());
  for (  Entry<String,Object> e : map.entrySet()) {
    assertTrue(Objects.deepEquals(e.getValue(),roundTripped.get(e.getKey())));
  }
}",0.6516572858036273
113219,"private void roundtripTest(Object value){
  String converted=Converters.convert(value,String.class);
  assertNotNull(converted);
  Object roundTripped=Converters.convert(converted,value.getClass());
  assertNotNull(roundTripped);
  assertTrue(roundTripped.getClass().isArray());
  assertTrue(roundTripped.getClass().getComponentType().isPrimitive());
  assertArrayEquals(value,roundTripped);
}","private void roundtripTest(Object value){
  String converted=Converters.convert(value,String.class);
  assertNotNull(converted);
  int length=Array.getLength(value);
  if (0 == length) {
    assertEquals(""String_Node_Str"",converted);
  }
 else {
    assertTrue(converted.startsWith(""String_Node_Str""));
    assertTrue(converted.endsWith(""String_Node_Str""));
    String plain=converted.substring(1);
    plain=plain.substring(0,plain.length() - 1);
    List<String> elems=Splitter.on(',').omitEmptyStrings().trimResults().splitToList(plain);
    assertEquals(length,elems.size());
  }
  Object roundTripped=Converters.convert(converted,value.getClass());
  assertNotNull(roundTripped);
  assertTrue(roundTripped.getClass().isArray());
  assertTrue(roundTripped.getClass().getComponentType().isPrimitive());
  assertArrayEquals(value,roundTripped);
}",0.6333601933924254
113220,"@Test public void testDouble(){
  roundtripTest(new double[0]);
  roundtripTest(new double[]{Double.NaN,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,Double.MIN_VALUE,-1.1,0,1.1,2.2,3.3,Double.MAX_VALUE});
}","@Test public void testDouble(){
  roundtripTest(new double[0]);
  roundtripTest(new double[]{Double.NaN,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,Double.MIN_VALUE,-1.1,0,1.1,2.2,3.3,Double.MAX_VALUE,Math.PI,Math.E});
}",0.965675057208238
113221,"@Override public void found(ObjectId object,@Nullable Integer storageSizeBytes){
  found.add(object);
}","@Override public void found(ObjectId object,@Nullable Integer storageSizeBytes){
  found.add(object);
  assertNotNull(db.getIfPresent(object));
}",0.8306451612903226
113222,"@Override public void inserted(ObjectId object,@Nullable Integer storageSizeBytes){
  inserted.add(object);
}","@Override public void inserted(ObjectId object,@Nullable Integer storageSizeBytes){
  inserted.add(object);
  assertNotNull(db.getIfPresent(object));
}",0.8384615384615385
113223,"@Test public void testPutAllWithListener(){
  ImmutableList<RevObject> expected=ImmutableList.of(feature(0,null,""String_Node_Str""),feature(1,""String_Node_Str"",new Integer(111)),feature(2,(Object)null),RevTree.EMPTY);
  Function<RevObject,ObjectId> toId=p -> p.getId();
  final Iterable<ObjectId> ids=Iterables.transform(expected,toId);
  final List<ObjectId> found=new CopyOnWriteArrayList<>();
  final List<ObjectId> inserted=new CopyOnWriteArrayList<>();
  BulkOpListener listener=new BulkOpListener(){
    @Override public void found(    ObjectId object,    @Nullable Integer storageSizeBytes){
      found.add(object);
    }
    @Override public void inserted(    ObjectId object,    @Nullable Integer storageSizeBytes){
      inserted.add(object);
    }
  }
;
  db.putAll(expected.iterator(),listener);
  assertTrue(found.toString(),found.isEmpty());
  assertEquals(Sets.newHashSet(ids),Sets.newHashSet(inserted));
  found.clear();
  inserted.clear();
  db.putAll(expected.iterator(),listener);
  assertTrue(inserted.toString(),inserted.isEmpty());
  assertEquals(Sets.newHashSet(ids),Sets.newHashSet(found));
}","@Test public void testPutAllWithListener(){
  ImmutableList<RevObject> expected=ImmutableList.of(feature(0,null,""String_Node_Str""),feature(1,""String_Node_Str"",new Integer(111)),feature(2,(Object)null),RevTree.EMPTY);
  Function<RevObject,ObjectId> toId=p -> p.getId();
  final Iterable<ObjectId> ids=Iterables.transform(expected,toId);
  final List<ObjectId> found=new CopyOnWriteArrayList<>();
  final List<ObjectId> inserted=new CopyOnWriteArrayList<>();
  BulkOpListener listener=new BulkOpListener(){
    @Override public void found(    ObjectId object,    @Nullable Integer storageSizeBytes){
      found.add(object);
      assertNotNull(db.getIfPresent(object));
    }
    @Override public void inserted(    ObjectId object,    @Nullable Integer storageSizeBytes){
      inserted.add(object);
      assertNotNull(db.getIfPresent(object));
    }
  }
;
  db.putAll(expected.iterator(),listener);
  assertTrue(found.toString(),found.isEmpty());
  assertEquals(Sets.newHashSet(ids),Sets.newHashSet(inserted));
  found.clear();
  inserted.clear();
  db.putAll(expected.iterator(),listener);
  assertTrue(inserted.toString(),inserted.isEmpty());
  assertEquals(Sets.newHashSet(ids),Sets.newHashSet(found));
}",0.9604130808950088
113224,"static int notifyInserted(int[] inserted,List<ObjectId> objects,BulkOpListener listener){
  int newObjects=0;
  for (int i=0; i < inserted.length; i++) {
    ObjectId id=objects.get(i);
    if (inserted[i] > 0) {
      listener.inserted(id,null);
      newObjects++;
    }
 else {
      listener.found(id,null);
    }
  }
  return newObjects;
}","static int notifyInserted(Map<ObjectId,Integer> insertResults,BulkOpListener listener){
  int newObjects=0;
  for (  Entry<ObjectId,Integer> entry : insertResults.entrySet()) {
    if (entry.getValue() > 0) {
      listener.inserted(entry.getKey(),null);
      newObjects++;
    }
 else {
      listener.found(entry.getKey(),null);
    }
  }
  return newObjects;
}",0.4887005649717514
113225,"private void doInsert(Connection cx,List<EncodedObject> partition) throws Exception {
  Map<String,PreparedStatement> perTableStatements=new HashMap<>();
  ArrayListMultimap<String,ObjectId> perTableIds=ArrayListMultimap.create();
  for (Iterator<EncodedObject> it=partition.iterator(); it.hasNext() && !abortFlag.get(); ) {
    EncodedObject obj=it.next();
    final TYPE type=obj.type;
    final ObjectId id=obj.id;
    final PGId pgid=PGId.valueOf(id);
    final byte[] bytes=obj.serialized;
{
      final String tableName=objectStore.tableNameForType(type,pgid);
      perTableIds.put(tableName,id);
      PreparedStatement stmt=prepare(cx,tableName,perTableStatements);
      pgid.setArgs(stmt,1);
      stmt.setBytes(4,bytes);
      stmt.addBatch();
    }
  }
  for (  String tableName : new HashSet<String>(perTableIds.keySet())) {
    if (abortFlag.get()) {
      return;
    }
    PreparedStatement tableStatement;
    tableStatement=perTableStatements.get(tableName);
    List<ObjectId> ids=perTableIds.removeAll(tableName);
    int[] batchResults=tableStatement.executeBatch();
    tableStatement.clearParameters();
    tableStatement.clearBatch();
    notifyInserted(batchResults,ids,listener);
  }
  for (  PreparedStatement tableStatement : perTableStatements.values()) {
    tableStatement.close();
  }
}","private Map<ObjectId,Integer> doInsert(Connection cx,List<EncodedObject> partition) throws Exception {
  Map<String,PreparedStatement> perTableStatements=new HashMap<>();
  ArrayListMultimap<String,ObjectId> perTableIds=ArrayListMultimap.create();
  for (Iterator<EncodedObject> it=partition.iterator(); it.hasNext() && !abortFlag.get(); ) {
    EncodedObject obj=it.next();
    final TYPE type=obj.type;
    final ObjectId id=obj.id;
    final PGId pgid=PGId.valueOf(id);
    final byte[] bytes=obj.serialized;
{
      final String tableName=objectStore.tableNameForType(type,pgid);
      perTableIds.put(tableName,id);
      PreparedStatement stmt=prepare(cx,tableName,perTableStatements);
      pgid.setArgs(stmt,1);
      stmt.setBytes(4,bytes);
      stmt.addBatch();
    }
  }
  Map<ObjectId,Integer> insertResults=new HashMap<ObjectId,Integer>();
  for (  String tableName : new HashSet<String>(perTableIds.keySet())) {
    if (abortFlag.get()) {
      return null;
    }
    PreparedStatement tableStatement;
    tableStatement=perTableStatements.get(tableName);
    List<ObjectId> ids=perTableIds.removeAll(tableName);
    int[] batchResults=tableStatement.executeBatch();
    tableStatement.clearParameters();
    tableStatement.clearBatch();
    for (int i=0; i < batchResults.length; i++) {
      insertResults.put(ids.get(i),batchResults[i]);
    }
  }
  for (  PreparedStatement tableStatement : perTableStatements.values()) {
    tableStatement.close();
  }
  return insertResults;
}",0.7582534611288605
113226,"@Override public Void call(){
  if (abortFlag.get()) {
    return null;
  }
  try (Connection cx=PGStorage.newConnection(ds)){
    cx.setAutoCommit(false);
    try {
      doInsert(cx,batch);
      if (abortFlag.get()) {
        cx.rollback();
      }
 else {
        cx.commit();
      }
    }
 catch (    Exception executionEx) {
      rollbackAndRethrow(cx,executionEx);
    }
 finally {
      cx.setAutoCommit(true);
    }
  }
 catch (  Exception connectEx) {
    abortFlag.set(true);
  }
  return null;
}","@Override public Void call(){
  if (abortFlag.get()) {
    return null;
  }
  try (Connection cx=PGStorage.newConnection(ds)){
    cx.setAutoCommit(false);
    try {
      Map<ObjectId,Integer> insertResults=doInsert(cx,batch);
      if (abortFlag.get()) {
        cx.rollback();
      }
 else {
        cx.commit();
      }
      notifyInserted(insertResults,listener);
    }
 catch (    Exception executionEx) {
      rollbackAndRethrow(cx,executionEx);
    }
 finally {
      cx.setAutoCommit(true);
    }
  }
 catch (  Exception connectEx) {
    abortFlag.set(true);
  }
  return null;
}",0.9254545454545454
113227,"/** 
 * Makes sure the DAG has the same structure than the original tree following the path to the node (i.e.) loading only the   {@link RevTree trees} necessary to reach the node being added.
 * @param root
 * @param nodeId
 * @param nodeDepth depth, not depth index
 * @return
 * @return
 */
protected void mergeRoot(DAG root,final NodeId nodeId){
  checkNotNull(root);
  checkNotNull(nodeId);
  if (root.getState() == STATE.INITIALIZED) {
    final RevTree original=getOriginalTree(root.originalTreeId());
    root.setTotalChildCount(original.size());
    final boolean originalIsLeaf=original.buckets().isEmpty();
    if (originalIsLeaf) {
      final Map<NodeId,DAGNode> origNodes=lazyNodes(original);
      if (!origNodes.isEmpty()) {
        storageProvider.saveNodes(origNodes);
        origNodes.keySet().forEach((id) -> root.addChild(id));
      }
    }
 else {
      final int dagDepth=root.getId().depthLength();
      final TreeId nodeBucketId=computeBucketId(nodeId,dagDepth + 1);
      final ImmutableSortedMap<Integer,Bucket> buckets=original.buckets();
      if (root.getState() == STATE.INITIALIZED) {
        checkState(root.numChildren() == 0);
        preload(buckets.values());
        for (        Entry<Integer,Bucket> e : buckets.entrySet()) {
          Integer bucketIndex=e.getKey();
          TreeId dagBucketId=computeBucketId(nodeBucketId,bucketIndex);
          ObjectId bucketId=e.getValue().getObjectId();
          DAG dag=getOrCreateDAG(dagBucketId,bucketId);
          root.addBucket(dagBucketId);
        }
      }
    }
    root.setMirrored();
  }
}","/** 
 * Makes sure the DAG has the same structure than the original tree following the path to the node (i.e.) loading only the   {@link RevTree trees} necessary to reach the node being added.
 * @param root
 * @param nodeDepth depth, not depth index
 * @return
 * @return
 */
protected void mergeRoot(DAG root){
  checkNotNull(root);
  if (root.getState() == STATE.INITIALIZED) {
    final RevTree original=getOriginalTree(root.originalTreeId());
    root.setTotalChildCount(original.size() + original.numTrees());
    final boolean originalIsLeaf=original.buckets().isEmpty();
    if (originalIsLeaf) {
      final Map<NodeId,DAGNode> origNodes=lazyNodes(original);
      if (!origNodes.isEmpty()) {
        storageProvider.saveNodes(origNodes);
        origNodes.keySet().forEach((id) -> root.addChild(id));
      }
    }
 else {
      final ImmutableSortedMap<Integer,Bucket> buckets=original.buckets();
      if (root.getState() == STATE.INITIALIZED) {
        checkState(root.numChildren() == 0);
        preload(buckets.values());
        for (        Entry<Integer,Bucket> e : buckets.entrySet()) {
          Integer bucketIndex=e.getKey();
          TreeId dagBucketId=root.getId().newChild(bucketIndex.intValue());
          ObjectId bucketId=e.getValue().getObjectId();
          DAG dag=getOrCreateDAG(dagBucketId,bucketId);
          root.addBucket(dagBucketId);
        }
      }
    }
    root.setMirrored();
  }
}",0.8985411140583555
113228,"/** 
 * @param dagId
 * @param dag
 * @param nodeId
 * @param remove
 * @param dagDepth zero based depth of {@code dag} (not a depth index, which is{@code depth - 1}
 * @return
 */
private int put(final DAG dag,final NodeId nodeId,final boolean remove){
  checkNotNull(dag);
  checkNotNull(nodeId);
  final int dagDepth=dag.getId().depthLength();
  mergeRoot(dag,nodeId);
  boolean changed=false;
  final int deltaSize;
  final int normalizedSizeLimit=normalizedSizeLimit(dagDepth);
  if (dag.numBuckets() > 0) {
    final @Nullable TreeId bucketId=computeBucketId(nodeId,dagDepth + 1);
    if (bucketId != null) {
      DAG bucketDAG=getOrCreateDAG(bucketId);
      dag.addBucket(bucketId);
      deltaSize=put(bucketDAG,nodeId,remove);
      changed=bucketDAG.getState() == STATE.CHANGED;
      if (bucketDAG.getTotalChildCount() == 0) {
        dag.removeBucket(bucketId);
      }
    }
 else {
      deltaSize=0;
    }
  }
 else {
    if (remove) {
      deltaSize=dag.removeChild(nodeId) ? -1 : 0;
    }
 else {
      changed=true;
      deltaSize=dag.addChild(nodeId) ? +1 : 0;
    }
    final int size=dag.numChildren();
    if (size > normalizedSizeLimit) {
      ListMultimap<TreeId,NodeId> promotions=ArrayListMultimap.create();
      dag.forEachChild((childId) -> {
        TreeId bucketId=computeBucketId(childId,dagDepth + 1);
        checkNotNull(bucketId);
        promotions.put(bucketId,childId);
      }
);
      promotions.asMap().forEach((bucketId,childIds) -> {
        DAG bucketDAG=getOrCreateDAG(bucketId);
        dag.addBucket(bucketId);
        for (        NodeId childId : childIds) {
          put(bucketDAG,childId,remove);
        }
      }
);
      dag.clearChildren();
    }
  }
  if (deltaSize != 0) {
    changed=true;
    dag.setTotalChildCount(dag.getTotalChildCount() + deltaSize);
    shrinkIfUnderflow(dag,nodeId,dagDepth);
  }
  if (changed) {
    dag.setChanged();
  }
  return deltaSize;
}","/** 
 * @param dagId
 * @param dag
 * @param nodeId
 * @param remove
 * @param dagDepth zero based depth of {@code dag} (not a depth index, which is{@code depth - 1}
 * @return
 */
protected int put(final DAG dag,final NodeId nodeId,final boolean remove){
  checkNotNull(dag);
  checkNotNull(nodeId);
  final int dagDepth=dag.getId().depthLength();
  mergeRoot(dag);
  boolean changed=false;
  final int deltaSize;
  final int normalizedSizeLimit=normalizedSizeLimit(dagDepth);
  if (dag.numBuckets() > 0) {
    final @Nullable TreeId bucketId=computeBucketId(nodeId,dagDepth + 1);
    if (bucketId != null) {
      final DAG bucketDAG=getOrCreateDAG(bucketId);
      dag.addBucket(bucketId);
      deltaSize=put(bucketDAG,nodeId,remove);
      changed=bucketDAG.getState() == STATE.CHANGED;
      if (bucketDAG.getTotalChildCount() == 0) {
        dag.removeBucket(bucketId);
      }
    }
 else {
      deltaSize=0;
    }
  }
 else {
    if (remove) {
      final boolean removed=dag.removeChild(nodeId);
      deltaSize=removed ? -1 : 0;
    }
 else {
      changed=true;
      deltaSize=dag.addChild(nodeId) ? +1 : 0;
    }
    final int size=dag.numChildren();
    if (size > normalizedSizeLimit) {
      ListMultimap<TreeId,NodeId> promotions=ArrayListMultimap.create();
      dag.forEachChild((childId) -> {
        TreeId bucketId=computeBucketId(childId,dagDepth + 1);
        checkNotNull(bucketId);
        promotions.put(bucketId,childId);
      }
);
      promotions.asMap().forEach((bucketId,childIds) -> {
        DAG bucketDAG=getOrCreateDAG(bucketId);
        dag.addBucket(bucketId);
        for (        NodeId childId : childIds) {
          put(bucketDAG,childId,remove);
        }
      }
);
      dag.clearChildren();
    }
  }
  if (deltaSize != 0) {
    changed=true;
    dag.setTotalChildCount(dag.getTotalChildCount() + deltaSize);
    shrinkIfUnderflow(dag);
  }
  if (changed) {
    dag.setChanged();
  }
  return deltaSize;
}",0.97119341563786
113229,"private void shrinkIfUnderflow(final DAG bucketsDAG,NodeId nodeId,int depth){
  final long childCount=bucketsDAG.getTotalChildCount();
  final int normalizedSizeLimit=normalizedSizeLimit(depth);
  if (childCount <= normalizedSizeLimit && bucketsDAG.numBuckets() > 0) {
    Set<NodeId> childrenRecursive=getChildrenRecursive(bucketsDAG,nodeId,depth);
    checkState(childrenRecursive.size() == childCount,""String_Node_Str"",childCount,childrenRecursive.size(),bucketsDAG);
    bucketsDAG.clearBuckets();
    childrenRecursive.forEach((id) -> bucketsDAG.addChild(id));
  }
}","private void shrinkIfUnderflow(final DAG dag){
  if (dag.numBuckets() == 0) {
    return;
  }
  final long childCount=dag.getTotalChildCount();
  final int depth=dag.getId().depthLength();
  final int normalizedSizeLimit=normalizedSizeLimit(depth);
  if (childCount > normalizedSizeLimit) {
    return;
  }
  Set<NodeId> childrenRecursive=getChildrenRecursiveAndClearBuckets(dag);
  checkState(childrenRecursive.size() == childCount,""String_Node_Str"",childCount,childrenRecursive.size(),dag);
  dag.clearBuckets();
  childrenRecursive.forEach((id) -> dag.addChild(id));
}",0.4640980735551663
113230,"private TreeId computeBucketId(final TreeId treeId,final Integer leafOverride){
  byte[] bucketIndicesByDepth=treeId.bucketIndicesByDepth.clone();
  bucketIndicesByDepth[bucketIndicesByDepth.length - 1]=leafOverride.byteValue();
  return new TreeId(bucketIndicesByDepth);
}","TreeId computeBucketId(final NodeId nodeId,final int childDepth){
  byte[] treeId=new byte[childDepth];
  int unpromotableDepthIndex=-1;
  for (int depthIndex=0; depthIndex < childDepth; depthIndex++) {
    int bucketIndex=bucket(nodeId,depthIndex);
    if (bucketIndex == -1) {
      unpromotableDepthIndex=depthIndex;
      break;
    }
    treeId[depthIndex]=(byte)bucketIndex;
  }
  if (unpromotableDepthIndex > -1) {
    final int extraBucketIndex=unpromotableBucketIndex(unpromotableDepthIndex);
    treeId[unpromotableDepthIndex]=(byte)extraBucketIndex;
    unpromotableDepthIndex++;
    final int missingDepthCount=childDepth - unpromotableDepthIndex;
    for (int i=0; i < missingDepthCount; i++, unpromotableDepthIndex++) {
      int bucketIndex=canonicalBucket(nodeId,i);
      treeId[unpromotableDepthIndex]=(byte)bucketIndex;
    }
  }
  return new TreeId(treeId);
}",0.1371527777777778
113231,"protected ClusteringStrategy(RevTree original,DAGStorageProvider storageProvider){
  checkNotNull(original);
  checkNotNull(storageProvider);
  this.original=original;
  this.storageProvider=storageProvider;
  this.dagCache=new DAGCache(storageProvider);
  this.root=new DAG(ROOT_ID,original.getId());
  this.root.setTotalChildCount(original.size());
}","protected ClusteringStrategy(RevTree original,DAGStorageProvider storageProvider){
  checkNotNull(original);
  checkNotNull(storageProvider);
  this.original=original;
  this.storageProvider=storageProvider;
  this.dagCache=new DAGCache(storageProvider);
  this.root=new DAG(ROOT_ID,original.getId());
  mergeRoot(root);
}",0.913946587537092
113232,"@Override public String toString(){
  String revTreeId=originalTreeId.equals(RevTree.EMPTY_TREE_ID) ? ""String_Node_Str"" : originalTreeId.toString().substring(0,6);
  return String.format(""String_Node_Str"",id,revTreeId,state,childCount,children.size(),buckets.size(),children,buckets);
}","@Override public String toString(){
  String revTreeId=originalTreeId.equals(RevTree.EMPTY_TREE_ID) ? ""String_Node_Str"" : originalTreeId.toString().substring(0,8);
  return String.format(""String_Node_Str"",id,revTreeId,state,childCount,children.size(),buckets.size(),children,buckets);
}",0.9965034965034965
113233,"@Override protected void mergeRoot(final DAG root,final NodeId nodeId){
  if (!ENABLE_EXPAND_COLLAPSE) {
    super.mergeRoot(root,nodeId);
    return;
  }
  checkNotNull(root);
  checkNotNull(nodeId);
  if (root.getState() == STATE.INITIALIZED) {
    final ObjectId originalTreeId=root.originalTreeId();
    final RevTree originalTree=getOriginalTree(originalTreeId);
    final TreeId rootId=root.getId();
    final TreeId expandedTreeId=computeExpandedChildId(originalTree,rootId);
    if (rootId.equals(expandedTreeId)) {
      super.mergeRoot(root,nodeId);
    }
 else {
      expand(root,expandedTreeId,originalTree,nodeId);
    }
  }
}","@Override protected void mergeRoot(final DAG root){
  if (!ENABLE_EXPAND_COLLAPSE) {
    super.mergeRoot(root);
    return;
  }
  checkNotNull(root);
  if (root.getState() == STATE.INITIALIZED) {
    final ObjectId originalTreeId=root.originalTreeId();
    final RevTree originalTree=getOriginalTree(originalTreeId);
    final TreeId rootId=root.getId();
    final TreeId expandedTreeId=computeExpandedChildId(originalTree,rootId);
    if (rootId.equals(expandedTreeId)) {
      super.mergeRoot(root);
    }
 else {
    }
  }
}",0.9031705227077976
113234,"public Node putNode(QuadTreeClusteringStrategy quad,Quadrant... location){
  Preconditions.checkNotNull(location);
  long fnumb=quad.root == null ? 0 : quad.root.getTotalChildCount();
  String quadInfo=""String_Node_Str"";
  for (  Quadrant q : location) {
    quadInfo+=q.name() + ""String_Node_Str"";
  }
  quadInfo+=""String_Node_Str"";
  for (  Quadrant q : location) {
    quadInfo+=q.getBucketNumber() + ""String_Node_Str"";
  }
  quadInfo+=""String_Node_Str"";
  Node n=createNode(""String_Node_Str"" + fnumb + ""String_Node_Str""+ quadInfo,location);
  quad.put(n);
  return n;
}","public Node putNode(QuadTreeClusteringStrategy quad,Quadrant... location){
  Preconditions.checkNotNull(location);
  long fnumb=quad.root == null ? 0 : quad.root.getTotalChildCount();
  String quadInfo=Arrays.toString(location);
  Node n=createNode(""String_Node_Str"" + fnumb + ""String_Node_Str""+ quadInfo,location);
  quad.put(n);
  return n;
}",0.6412213740458015
113235,"public DAG buildRoot(){
  while (1 == root.numBuckets()) {
    root.forEachBucket((treeId) -> {
      DAG actual=getOrCreateDAG(treeId);
      root=actual;
      rootId=treeId;
    }
);
  }
  return root;
}","public DAG buildRoot(){
  return root;
}",0.3252032520325203
113236,"protected ClusteringStrategy(RevTree original,DAGStorageProvider storageProvider){
  checkNotNull(original);
  checkNotNull(storageProvider);
  this.storageProvider=storageProvider;
  this.root=new DAG(ROOT_ID,original.getId());
  this.root.setChildCount(original.size());
  this.dagCache=new DAGCache(storageProvider);
}","protected ClusteringStrategy(RevTree original,DAGStorageProvider storageProvider){
  checkNotNull(original);
  checkNotNull(storageProvider);
  this.storageProvider=storageProvider;
  this.dagCache=new DAGCache(storageProvider);
  init(original,ROOT_ID);
}",0.7209705372616985
113237,"public static RevTree build(final ClusteringStrategy clusteringStrategy,final ObjectStore targetStore){
  ProgressListener listener=new DefaultProgressListener();
  SharedState state=new SharedState(targetStore,clusteringStrategy,listener);
  DAG root=clusteringStrategy.buildRoot();
  TreeId rootId=clusteringStrategy.getRootId();
  final int baseDepth=rootId.depthLength();
  TreeBuildTask task=new TreeBuildTask(state,root,baseDepth);
  RevTree tree;
  try {
    ForkJoinPool forkJoinPool=FORK_JOIN_POOL;
    tree=forkJoinPool.invoke(task);
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
 finally {
    state.saveTrees();
  }
  return tree;
}","public static RevTree build(final ClusteringStrategy clusteringStrategy,final ObjectStore targetStore){
  ProgressListener listener=new DefaultProgressListener();
  SharedState state=new SharedState(targetStore,clusteringStrategy,listener);
  final DAG root=clusteringStrategy.buildRoot();
  final TreeId rootId=root.getId();
  final int baseDepth=rootId.depthLength();
  TreeBuildTask task=new TreeBuildTask(state,root,baseDepth);
  RevTree tree;
  try {
    ForkJoinPool forkJoinPool=FORK_JOIN_POOL;
    tree=forkJoinPool.invoke(task);
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
 finally {
    state.saveTrees();
  }
  return tree;
}",0.971342383107089
113238,"/** 
 * Overrides to implement a simple optimization for the case where the node bounds haven't changed and hence avoid calling remove and then put, but call put only, since the  {@code NodeId} is guaranteed to lay on the same bucket at any depth.
 */
@Override public void update(Node oldNode,Node newNode){
  if (oldNode.bounds().equals(newNode.bounds())) {
    Preconditions.checkArgument(oldNode.getName().equals(newNode.getName()));
    put(newNode);
  }
 else {
    super.update(oldNode,newNode);
  }
}","/** 
 * Overrides to implement a simple optimization for the case where the node bounds haven't changed and hence avoid calling remove and then put, but call put only, since the  {@code NodeId} is guaranteed to lay on the same bucket at any depth.
 */
@Override public void update(Node oldNode,Node newNode){
  Optional<Envelope> oldBounds=oldNode.bounds();
  Optional<Envelope> newBounds=newNode.bounds();
  if (oldBounds.equals(newBounds)) {
    Preconditions.checkArgument(oldNode.getName().equals(newNode.getName()));
    put(newNode);
  }
 else {
    super.update(oldNode,newNode);
  }
}",0.8763636363636363
113239,"public QuadTreeClusteringStrategy(RevTree original,DAGStorageProvider storageProvider,Envelope maxBounds){
  super(original,storageProvider);
  this.maxBounds=maxBounds;
}","public QuadTreeClusteringStrategy(RevTree original,DAGStorageProvider storageProvider,Envelope maxBounds){
  super(original,storageProvider);
  this.maxBounds=maxBounds;
  init(original);
}",0.95
113240,"/** 
 * @return a feature node named {@code i}, with  {@code id = ObjectId.forString(String.valueOf(i))}, null metadata id, and  {@code bounds = [i, i+1, i, i+1]}
 */
protected static Node node(int i){
  String key=""String_Node_Str"" + String.valueOf(i);
  ObjectId oid=RevObjectTestSupport.hashString(key);
  Envelope bounds=new Envelope(i,i + 1,i,i + 1);
  Node node=Node.create(key,oid,ObjectId.NULL,TYPE.FEATURE,bounds);
  return node;
}","protected static Node node(int i,Envelope bounds){
  String key=""String_Node_Str"" + String.valueOf(i);
  ObjectId oid=RevObjectTestSupport.hashString(key);
  Node node=Node.create(key,oid,ObjectId.NULL,TYPE.FEATURE,bounds);
  return node;
}",0.5705882352941176
113241,"public Optional<ObjectId> getMetadataId(final int objectIdIndex){
  Optional<ObjectId> mdId=Optional.absent();
  if (objectIdIndex > 0) {
    mdId=Optional.of(getObjectId(objectIdIndex));
  }
  return mdId;
}","public Optional<ObjectId> getMetadataId(final int objectIdIndex){
  Optional<ObjectId> mdId=Optional.absent();
  if (objectIdIndex > -1) {
    mdId=Optional.of(getObjectId(objectIdIndex));
  }
  return mdId;
}",0.9928057553956836
113242,"public static RevTree decode(ObjectId id,ByteBuffer data){
  final DataBuffer dataBuffer=DataBuffer.of(data);
  final long totalSize=dataBuffer.header().size();
  final int numTrees=dataBuffer.header().numTrees();
  if (totalSize == 0L && numTrees == 0) {
    return RevTree.EMPTY;
  }
  return new RevTreeImpl(id,dataBuffer);
}","public static RevTree decode(@Nullable ObjectId id,ByteBuffer data){
  final DataBuffer dataBuffer=DataBuffer.of(data);
  final long totalSize=dataBuffer.header().size();
  final int numTrees=dataBuffer.header().numTrees();
  if (totalSize == 0L && numTrees == 0) {
    return RevTree.EMPTY;
  }
  if (null == id) {
    List<Node> trees=RevTreeFormat.trees(dataBuffer);
    List<Node> features=RevTreeFormat.features(dataBuffer);
    SortedMap<Integer,Bucket> buckets=RevTreeFormat.buckets(dataBuffer);
    id=HashObject.hashTree(trees,features,buckets);
  }
  return new RevTreeImpl(id,dataBuffer);
}",0.7061356297093649
113243,"@Test public void severalFeatures() throws IOException {
  encodedDecode(nodes(TYPE.FEATURE,1,false,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,false,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,false),TYPE.FEATURE);
}","@Test public void severalFeatures() throws IOException {
  encodedDecode(nodes(TYPE.FEATURE,1024,false,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,false,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,false),TYPE.FEATURE);
}",0.9969481180061036
113244,"@Test public void testConsistentHashing() throws IOException {
  List<Node> tNodes=nodes(TYPE.TREE,512,true,true,true);
  List<Node> fNodes=nodes(TYPE.FEATURE,512,false,true,true);
  final RevTree orig=tree(2048,tNodes,fNodes,null);
  final byte[] encoded=RevTreeFormat.encode(orig);
  assertNotNull(encoded);
  RevTree decoded=RevTreeFormat.decode(orig.getId(),encoded);
  ObjectId expected=new HashObject().setObject(orig).call();
  ObjectId actual=new HashObject().setObject(decoded).call();
  assertEquals(expected,actual);
}","public void testConsistentHashing(boolean withMetadataId,boolean withBounds,boolean withExtraData) throws IOException {
  List<Node> tNodes=nodes(TYPE.TREE,512,withMetadataId,withBounds,withExtraData);
  List<Node> fNodes=nodes(TYPE.FEATURE,512,withMetadataId,withBounds,withExtraData);
  final RevTree orig=tree(2048,tNodes,fNodes,null);
  assertHashing(orig);
}",0.4596412556053811
113245,"/** 
 * <pre>  {@code NodeSet = <HEADER>,[DATA] HEADER = <int>, // size of this header <int>, //size, number of nodes <byte[]>, // node flags (4 bits per node) <uvarint>, //size in bytes of node data section <uvarint>, //size in bytes of objectids array <uvarint>, //size in bytes of bounds section <uvarint>; //size in bytes of extra data section DATA =  <uvarint[]>,  //node name indexes on string table <objectid[]>, //node object ids <bitset>, //metadata ids presence bitset [objectid[]], //metadata ids (only those present) (bounds and extra data TBD) NODE =   <uvarint>, //name index <uvarint>, //objectid index [uvarint], //metadataid index [uvarint], //bounds index [uvarint]; //extra data relative offset}</pre>
 */
public static void encode(DataOutput out,final List<Node> nodes,StringTable stringTable) throws IOException {
  final int size=nodes.size();
  if (size == 0) {
    out.writeInt(Integer.BYTES);
    return;
  }
  InternalDataOutput header=stream(32);
  InternalDataOutput nodeData=stream(size * 8);
  InternalDataOutput inlineExtraData=stream(size * 32);
  Index<ObjectId> uniqueIds=new Index<>();
  InternalDataOutput objectIds=stream(size * ObjectId.NUM_BYTES);
  header.writeInt(0);
  NodeFlags flags=new NodeFlags(size);
  Envelope bounds=new Envelope();
  List<Coordinate> boundsCoords=new ArrayList<>(2 * size);
  for (int nodeIndex=0; nodeIndex < size; nodeIndex++) {
    final Node node=nodes.get(nodeIndex);
    Preconditions.checkArgument(node != null);
    final int nameIndex, oidIndex, mdIdIndex, boundsIndex, extraDataRelOffset;
    nameIndex=stringTable.add(node.getName());
    checkState(nameIndex > -1);
    oidIndex=objectIdIndex(node.getObjectId(),uniqueIds,objectIds);
    Optional<ObjectId> metadataId=node.getMetadataId();
    flags.metadataPresent(nodeIndex,metadataId.isPresent());
    mdIdIndex=metadataId.isPresent() ? objectIdIndex(metadataId.get(),uniqueIds,objectIds) : -1;
    bounds.setToNull();
    node.expand(bounds);
    flags.boundsPresent(nodeIndex,!bounds.isNull());
    if (bounds.isNull()) {
      boundsIndex=-1;
    }
 else {
      boundsIndex=boundsCoords.size();
      boolean isPoint=bounds.getWidth() == 0D && bounds.getHeight() == 0D;
      flags.isPoint(nodeIndex,isPoint);
      boundsCoords.add(new Coordinate(bounds.getMinX(),bounds.getMinY()));
      if (!isPoint) {
        boundsCoords.add(new Coordinate(bounds.getMaxX(),bounds.getMaxY()));
      }
    }
    final Map<String,Object> extraData=node.getExtraData();
    if (extraData.isEmpty()) {
      flags.extraDataPresent(nodeIndex,false);
      extraDataRelOffset=-1;
    }
 else {
      flags.extraDataPresent(nodeIndex,true);
      extraDataRelOffset=inlineExtraData.size();
      ExtraData.encode(extraData,inlineExtraData,stringTable);
    }
    writeUnsignedVarInt(nameIndex,nodeData);
    writeUnsignedVarInt(oidIndex,nodeData);
    if (metadataId.isPresent()) {
      writeUnsignedVarInt(mdIdIndex,nodeData);
    }
    if (!bounds.isNull()) {
      writeUnsignedVarInt(boundsIndex,nodeData);
    }
    if (!extraData.isEmpty()) {
      writeUnsignedVarInt(extraDataRelOffset,nodeData);
    }
  }
  header.writeInt(size);
  final byte[] flagsData=flags.bitset.toByteArray();
  header.write(flagsData);
  int nodeDataSize=nodeData.size();
  writeUnsignedVarInt(nodeDataSize,header);
  int oidSectionSize=objectIds.size();
  writeUnsignedVarInt(oidSectionSize,header);
  IntCoordinateSequence boundsSeq=new IntCoordinateSequence(2,boundsCoords);
  InternalDataOutput boundsStream=stream(boundsSeq.size() * 4);
  long[] xordinates=boundsSeq.ordinates()[0];
  long[] yordinates=boundsSeq.ordinates()[1];
  Varints.writeLongArrayDeltaEncoded(xordinates,boundsStream);
  Varints.writeLongArrayDeltaEncoded(yordinates,boundsStream);
  final int coordsSectionSzie=boundsStream.size();
  writeUnsignedVarInt(coordsSectionSzie,header);
  writeUnsignedVarInt(inlineExtraData.size(),header);
  final int headerSize=header.size();
  header.reset().writeInt(headerSize);
  header.setSize(headerSize);
  header.writeTo(out);
  nodeData.writeTo(out);
  objectIds.writeTo(out);
  boundsStream.writeTo(out);
  inlineExtraData.writeTo(out);
}","/** 
 * <pre>  {@code NodeSet = <HEADER>,[DATA] HEADER = <int>, // size of this header <int>, //size, number of nodes <byte[]>, // node flags (4 bits per node) <uvarint>, //size in bytes of node data section <uvarint>, //size in bytes of objectids array <uvarint>, //size in bytes of bounds section <uvarint>; //size in bytes of extra data section DATA =  <uvarint[]>,  //node name indexes on string table <objectid[]>, //node object ids <bitset>, //metadata ids presence bitset [objectid[]], //metadata ids (only those present) (bounds and extra data TBD) NODE =   <uvarint>, //name index <uvarint>, //objectid index [uvarint], //metadataid index [uvarint], //bounds index [uvarint]; //extra data relative offset}</pre>
 */
public static void encode(DataOutput out,final List<Node> nodes,StringTable stringTable) throws IOException {
  final int size=nodes.size();
  if (size == 0) {
    out.writeInt(Integer.BYTES);
    return;
  }
  InternalDataOutput header=stream(32);
  InternalDataOutput nodeData=stream(size * 8);
  InternalDataOutput inlineExtraData=stream(size * 32);
  Index<ObjectId> uniqueIds=new Index<>();
  InternalDataOutput objectIds=stream(size * ObjectId.NUM_BYTES);
  header.writeInt(0);
  NodeFlags flags=new NodeFlags(size);
  Envelope bounds=new Envelope();
  List<Coordinate> boundsCoords=new ArrayList<>(2 * size);
  for (int nodeIndex=0; nodeIndex < size; nodeIndex++) {
    final Node node=nodes.get(nodeIndex);
    Preconditions.checkArgument(node != null);
    final int nameIndex, oidIndex, mdIdIndex, boundsIndex, extraDataRelOffset;
    nameIndex=stringTable.add(node.getName());
    checkState(nameIndex > -1);
    oidIndex=objectIdIndex(node.getObjectId(),uniqueIds,objectIds);
    Optional<ObjectId> metadataId=node.getMetadataId();
    flags.metadataPresent(nodeIndex,metadataId.isPresent());
    mdIdIndex=metadataId.isPresent() ? objectIdIndex(metadataId.get(),uniqueIds,objectIds) : -1;
    bounds.setToNull();
    node.expand(bounds);
    flags.boundsPresent(nodeIndex,!bounds.isNull());
    if (bounds.isNull()) {
      boundsIndex=-1;
    }
 else {
      boundsIndex=boundsCoords.size();
      boolean isPoint=bounds.getWidth() == 0D && bounds.getHeight() == 0D;
      flags.isPoint(nodeIndex,isPoint);
      boundsCoords.add(new Coordinate(bounds.getMinX(),bounds.getMinY()));
      if (!isPoint) {
        boundsCoords.add(new Coordinate(bounds.getMaxX(),bounds.getMaxY()));
      }
    }
    final Map<String,Object> extraData=node.getExtraData();
    if (extraData.isEmpty()) {
      flags.extraDataPresent(nodeIndex,false);
      extraDataRelOffset=-1;
    }
 else {
      flags.extraDataPresent(nodeIndex,true);
      extraDataRelOffset=inlineExtraData.size();
      ExtraData.encode(extraData,inlineExtraData,stringTable);
    }
    writeUnsignedVarInt(nameIndex,nodeData);
    writeUnsignedVarInt(oidIndex,nodeData);
    if (metadataId.isPresent()) {
      writeUnsignedVarInt(mdIdIndex,nodeData);
    }
    if (!bounds.isNull()) {
      writeUnsignedVarInt(boundsIndex,nodeData);
    }
    if (!extraData.isEmpty()) {
      writeUnsignedVarInt(extraDataRelOffset,nodeData);
    }
  }
  header.writeInt(size);
  final byte[] flagsData=flags.bitset.toByteArray();
  header.writeInt(flagsData.length);
  header.write(flagsData);
  int nodeDataSize=nodeData.size();
  writeUnsignedVarInt(nodeDataSize,header);
  int oidSectionSize=objectIds.size();
  writeUnsignedVarInt(oidSectionSize,header);
  IntCoordinateSequence boundsSeq=new IntCoordinateSequence(2,boundsCoords);
  InternalDataOutput boundsStream=stream(boundsSeq.size() * 4);
  long[] xordinates=boundsSeq.ordinates()[0];
  long[] yordinates=boundsSeq.ordinates()[1];
  Varints.writeLongArrayDeltaEncoded(xordinates,boundsStream);
  Varints.writeLongArrayDeltaEncoded(yordinates,boundsStream);
  final int coordsSectionSzie=boundsStream.size();
  writeUnsignedVarInt(coordsSectionSzie,header);
  writeUnsignedVarInt(inlineExtraData.size(),header);
  final int headerSize=header.size();
  header.reset().writeInt(headerSize);
  header.setSize(headerSize);
  header.writeTo(out);
  nodeData.writeTo(out);
  objectIds.writeTo(out);
  boundsStream.writeTo(out);
  inlineExtraData.writeTo(out);
}",0.9955746920224854
113246,"static NodeFlags parse(DataInput in,int numNodes) throws IOException {
  if (numNodes == 0) {
    return EMPTY;
  }
  final int length=(int)Math.ceil(numNodes / 2D);
  byte[] bitsetData=new byte[length];
  in.readFully(bitsetData);
  BitSet bitset=BitSet.valueOf(bitsetData);
  return new NodeFlags(bitset);
}","static NodeFlags parse(DataInput in,int numNodes) throws IOException {
  if (numNodes == 0) {
    return EMPTY;
  }
  int logicalSize=in.readInt();
  final int length=(int)Math.ceil(numNodes / 2D);
  byte[] bitsetData=new byte[length];
  in.readFully(bitsetData,0,logicalSize);
  BitSet bitset=BitSet.valueOf(bitsetData);
  return new NodeFlags(bitset);
}",0.9307228915662652
113247,"@Test public void severalFeatures() throws IOException {
  encodedDecode(featureNodes(1024),TYPE.FEATURE);
}","@Test public void severalFeatures() throws IOException {
  encodedDecode(nodes(TYPE.FEATURE,1,false,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,false,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,false,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,true),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,false,false),TYPE.FEATURE);
  encodedDecode(nodes(TYPE.FEATURE,1024,true,true,false),TYPE.FEATURE);
}",0.3177257525083612
113248,"@Override public void addIndexedTree(IndexInfo index,ObjectId originalTree,ObjectId indexedTree){
  ObjectId indexTreeLookupId=computeIndexTreeLookupId(index.getId(),originalTree);
  try (RocksDBReference dbRef=dbhandle.getReference()){
    dbRef.db().put(indexMetadataColumn,indexTreeLookupId.getRawValue(),indexedTree.getRawValue());
  }
 catch (  RocksDBException e) {
    throw Throwables.propagate(e);
  }
}","@Override public void addIndexedTree(IndexInfo index,ObjectId originalTree,ObjectId indexedTree){
  ObjectId indexTreeLookupId=computeIndexTreeLookupId(index.getId(),originalTree);
  try (RocksDBReference dbRef=dbhandle.getReference()){
    dbRef.db().put(indexMappingsColumn,indexTreeLookupId.getRawValue(),indexedTree.getRawValue());
  }
 catch (  RocksDBException e) {
    throw Throwables.propagate(e);
  }
}",0.983009708737864
113249,"@Override public Optional<ObjectId> resolveIndexedTree(IndexInfo index,ObjectId treeId){
  ObjectId indexTreeLookupId=computeIndexTreeLookupId(index.getId(),treeId);
  byte[] indexTreeBytes;
  try (RocksDBReference dbRef=dbhandle.getReference()){
    indexTreeBytes=dbRef.db().get(indexMetadataColumn,indexTreeLookupId.getRawValue());
  }
 catch (  RocksDBException e) {
    throw Throwables.propagate(e);
  }
  if (indexTreeBytes != null) {
    return Optional.of(ObjectId.createNoClone(indexTreeBytes));
  }
  return Optional.absent();
}","@Override public Optional<ObjectId> resolveIndexedTree(IndexInfo index,ObjectId treeId){
  ObjectId indexTreeLookupId=computeIndexTreeLookupId(index.getId(),treeId);
  byte[] indexTreeBytes;
  try (RocksDBReference dbRef=dbhandle.getReference()){
    indexTreeBytes=dbRef.db().get(indexMappingsColumn,indexTreeLookupId.getRawValue());
  }
 catch (  RocksDBException e) {
    throw Throwables.propagate(e);
  }
  if (indexTreeBytes != null) {
    return Optional.of(ObjectId.createNoClone(indexTreeBytes));
  }
  return Optional.absent();
}",0.987012987012987
113250,"private IndexInfo readIndex(byte[] indexBytes){
  IndexInfo index=IndexInfoSerializer.deserialize(ByteStreams.newDataInput(indexBytes));
  return index;
}","private IndexInfo readIndex(byte[] indexBytes){
  DataInput input=ByteStreams.newDataInput(indexBytes);
  IndexInfo index=IndexInfoSerializer.deserialize(input);
  return index;
}",0.7327327327327328
113251,"@Override public synchronized void open(){
  if (isOpen()) {
    return;
  }
  super.open(Collections.singleton(""String_Node_Str""));
  this.indexMetadataColumn=super.dbhandle.getColumnFamily(""String_Node_Str"");
  Preconditions.checkState(this.indexMetadataColumn != null);
}","@Override public synchronized void open(){
  if (isOpen()) {
    return;
  }
  super.open(Sets.newHashSet(""String_Node_Str"",""String_Node_Str""));
  this.indexMetadataColumn=super.dbhandle.getColumnFamily(""String_Node_Str"");
  this.indexMappingsColumn=super.dbhandle.getColumnFamily(""String_Node_Str"");
  Preconditions.checkState(this.indexMetadataColumn != null);
  Preconditions.checkState(this.indexMappingsColumn != null);
}",0.6485714285714286
113252,"@Override public ConfigDatabase getConfigDatabase(URI repoURI,Context repoContext,boolean rootUri){
  final Environment config;
  if (rootUri) {
    Properties properties=EnvironmentBuilder.getRootURIProperties(repoURI);
    EnvironmentBuilder builder=new EnvironmentBuilder(properties);
    config=builder.build();
  }
 else {
    config=parseConfig(repoURI);
  }
  PGConfigDatabase configDb=new PGConfigDatabase(config);
  if (config.getRepositoryName() != null) {
    Optional<String> refsFormat=configDb.get(""String_Node_Str"");
    if (!refsFormat.isPresent()) {
      configDb.put(PGStorageProvider.FORMAT_NAME + ""String_Node_Str"",PGStorageProvider.VERSION);
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
    }
  }
  return configDb;
}","@Override public ConfigDatabase getConfigDatabase(URI repoURI,Context repoContext,boolean rootUri){
  final Environment config;
  if (rootUri) {
    Properties properties=EnvironmentBuilder.getRootURIProperties(repoURI);
    EnvironmentBuilder builder=new EnvironmentBuilder(properties);
    config=builder.build();
  }
 else {
    config=parseConfig(repoURI);
  }
  PGConfigDatabase configDb=new PGConfigDatabase(config);
  if (config.getRepositoryName() != null) {
    Optional<String> configEntry=configDb.get(PGStorageProvider.FORMAT_NAME + ""String_Node_Str"");
    if (!configEntry.isPresent()) {
      configDb.put(PGStorageProvider.FORMAT_NAME + ""String_Node_Str"",PGStorageProvider.VERSION);
    }
    configEntry=configDb.get(""String_Node_Str"");
    if (!configEntry.isPresent()) {
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
    }
    configEntry=configDb.get(""String_Node_Str"");
    if (!configEntry.isPresent()) {
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
    }
    configEntry=configDb.get(""String_Node_Str"");
    if (!configEntry.isPresent()) {
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
    }
    configEntry=configDb.get(""String_Node_Str"");
    if (!configEntry.isPresent()) {
      configDb.put(""String_Node_Str"",PGStorageProvider.FORMAT_NAME);
    }
  }
  return configDb;
}",0.716852010265184
113253,"@Override protected void runInternal(GeogigCLI cli) throws InvalidParameterException, CommandFailedException, IOException {
  GeoGIG geogig=cli.getGeogig();
  IndexDatabase indexDatabase=geogig.getRepository().indexDatabase();
  if (indexDatabase.getIndex(tree,attribute).isPresent()) {
    throw new CommandFailedException(""String_Node_Str"");
  }
  Optional<RevFeatureType> featureTypeOpt=geogig.command(ResolveFeatureType.class).setRefSpec(""String_Node_Str"" + tree).call();
  if (!featureTypeOpt.isPresent()) {
    throw new CommandFailedException(String.format(""String_Node_Str"",tree));
  }
  RevFeatureType treeType=featureTypeOpt.get();
  boolean attributeFound=false;
  PropertyType attributeType=null;
  for (  PropertyDescriptor descriptor : treeType.descriptors()) {
    if (descriptor.getName().toString().equals(attribute)) {
      attributeFound=true;
      attributeType=descriptor.getType();
    }
  }
  if (!attributeFound) {
    throw new CommandFailedException(String.format(""String_Node_Str"",attribute));
  }
  if (!(attributeType instanceof GeometryType)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  Index index=indexDatabase.createIndex(tree,attribute,IndexType.QUADTREE,null);
  if (indexHistory) {
    ImmutableList<Ref> branches=geogig.command(BranchListOp.class).setLocal(true).setRemotes(true).call();
    for (    Ref ref : branches) {
      Iterator<RevCommit> commits=geogig.command(LogOp.class).setUntil(ref.getObjectId()).call();
      while (commits.hasNext()) {
        RevCommit next=commits.next();
        createQuadTree(cli,next.getId().toString(),index);
      }
    }
  }
 else {
    createQuadTree(cli,""String_Node_Str"",index);
  }
}","@Override protected void runInternal(GeogigCLI cli) throws InvalidParameterException, CommandFailedException, IOException {
  GeoGIG geogig=cli.getGeogig();
  IndexDatabase indexDatabase=geogig.getRepository().indexDatabase();
  if (indexDatabase.getIndex(tree,attribute).isPresent()) {
    throw new CommandFailedException(""String_Node_Str"");
  }
  Optional<RevFeatureType> featureTypeOpt=geogig.command(ResolveFeatureType.class).setRefSpec(""String_Node_Str"" + tree).call();
  if (!featureTypeOpt.isPresent()) {
    throw new CommandFailedException(String.format(""String_Node_Str"",tree));
  }
  RevFeatureType treeType=featureTypeOpt.get();
  boolean attributeFound=false;
  PropertyType attributeType=null;
  for (  PropertyDescriptor descriptor : treeType.descriptors()) {
    if (descriptor.getName().toString().equals(attribute)) {
      attributeFound=true;
      attributeType=descriptor.getType();
      break;
    }
  }
  if (!attributeFound) {
    throw new CommandFailedException(String.format(""String_Node_Str"",attribute));
  }
  if (!(attributeType instanceof GeometryType)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  Index index=indexDatabase.createIndex(tree,attribute,IndexType.QUADTREE,null);
  if (indexHistory) {
    ImmutableList<Ref> branches=geogig.command(BranchListOp.class).setLocal(true).setRemotes(true).call();
    for (    Ref ref : branches) {
      Iterator<RevCommit> commits=geogig.command(LogOp.class).setUntil(ref.getObjectId()).call();
      while (commits.hasNext()) {
        RevCommit next=commits.next();
        createQuadTree(cli,next.getId().toString(),index);
      }
    }
  }
 else {
    createQuadTree(cli,""String_Node_Str"",index);
  }
}",0.9961910342806914
113254,"private void createQuadTree(GeogigCLI cli,String commitish,Index index) throws IOException {
  GeoGIG geogig=cli.getGeogig();
  IndexDatabase indexDatabase=geogig.getRepository().indexDatabase();
  String treeSpec=commitish + ""String_Node_Str"" + tree;
  Optional<ObjectId> treeId=geogig.command(ResolveTreeish.class).setTreeish(treeSpec).call();
  if (!treeId.isPresent()) {
    cli.getConsole().println(String.format(""String_Node_Str"",treeSpec));
    return;
  }
  if (indexDatabase.resolveIndexedTree(index,treeId.get()).isPresent()) {
    cli.getConsole().println(String.format(""String_Node_Str"",treeSpec));
    return;
  }
  CreateQuadTree command=geogig.command(CreateQuadTree.class);
  command.setFeatureTree(treeId.get());
  ProgressListener listener=cli.getProgressListener();
  RevTree quadTree=command.setProgressListener(listener).call();
  geogig.getRepository().indexDatabase().addIndexedTree(index,treeId.get(),quadTree.getId());
  cli.getConsole().println(String.format(""String_Node_Str"",quadTree.getId(),quadTree.size()));
}","private void createQuadTree(GeogigCLI cli,String commitish,Index index) throws IOException {
  GeoGIG geogig=cli.getGeogig();
  IndexDatabase indexDatabase=geogig.getRepository().indexDatabase();
  String treeSpec=commitish + ""String_Node_Str"" + tree;
  Optional<ObjectId> treeId=geogig.command(ResolveTreeish.class).setTreeish(treeSpec).call();
  if (!treeId.isPresent()) {
    cli.getConsole().println(String.format(""String_Node_Str"",treeSpec));
    return;
  }
  if (indexDatabase.resolveIndexedTree(index,treeId.get()).isPresent()) {
    cli.getConsole().println(String.format(""String_Node_Str"",treeSpec));
    return;
  }
  CreateQuadTree command=geogig.command(CreateQuadTree.class);
  command.setFeatureTree(treeId.get());
  ProgressListener listener=cli.getProgressListener();
  RevTree quadTree=command.setProgressListener(listener).call();
  indexDatabase.addIndexedTree(index,treeId.get(),quadTree.getId());
  cli.getConsole().println(String.format(""String_Node_Str"",quadTree.getId(),quadTree.size()));
}",0.9878345498783456
113255,"private RevTree resolveTree(@Nullable final String treeIsh,@Nullable final ObjectId treeOid,final ObjectStore source){
  RevTree tree=null;
  ResolveTreeish command=null;
  if (treeOid != null) {
    if (ObjectId.NULL.equals(treeOid) || RevTree.EMPTY_TREE_ID.equals(treeOid)) {
      tree=RevTree.EMPTY;
    }
 else {
      command=command(ResolveTreeish.class).setTreeish(treeOid);
    }
  }
 else   if (treeIsh.equals(ObjectId.NULL.toString()) || RevTree.EMPTY_TREE_ID.toString().equals(treeIsh)) {
    tree=RevTree.EMPTY;
  }
 else {
    command=command(ResolveTreeish.class).setTreeish(treeIsh);
  }
  if (tree == null) {
    final Optional<ObjectId> treeId=command.call();
    checkArgument(treeId.isPresent(),treeIsh + ""String_Node_Str"");
    tree=source.getTree(treeId.get());
  }
  return tree;
}","private RevTree resolveTree(@Nullable final String treeIsh,@Nullable final ObjectId treeOid,final ObjectStore source){
  RevTree tree=null;
  ResolveTreeish command=null;
  if (treeOid != null) {
    if (ObjectId.NULL.equals(treeOid) || RevTree.EMPTY_TREE_ID.equals(treeOid)) {
      tree=RevTree.EMPTY;
    }
 else {
      command=command(ResolveTreeish.class).setSource(source).setTreeish(treeOid);
    }
  }
 else   if (treeIsh.equals(ObjectId.NULL.toString()) || RevTree.EMPTY_TREE_ID.toString().equals(treeIsh)) {
    tree=RevTree.EMPTY;
  }
 else {
    command=command(ResolveTreeish.class).setSource(source).setTreeish(treeIsh);
  }
  if (tree == null) {
    final Optional<ObjectId> treeId=command.call();
    checkArgument(treeId.isPresent(),treeIsh + ""String_Node_Str"");
    tree=source.getTree(treeId.get());
  }
  return tree;
}",0.978102189781022
113256,"/** 
 * Executes the command.
 * @return the type of the object specified by the object id.
 * @throws IllegalArgumentException if the object doesn't exist
 */
@Override protected TYPE _call() throws IllegalArgumentException {
  RevObject o=objectDatabase().get(oid);
  return o.getType();
}","/** 
 * Executes the command.
 * @return the type of the object specified by the object id.
 * @throws IllegalArgumentException if the object doesn't exist
 */
@Override protected TYPE _call() throws IllegalArgumentException {
  ObjectStore source=this.source == null ? objectDatabase() : this.source;
  RevObject o=source.get(oid);
  return o.getType();
}",0.8500772797527048
113257,"/** 
 * @param resolved an {@link Optional} with an ObjectId to resolve
 * @return an {@link Optional} of the {@link ObjectId} that was resolved, or{@link Optional#absent()} if it did not resolve.
 */
private Optional<ObjectId> call(Optional<ObjectId> resolved){
  if (!resolved.isPresent()) {
    return Optional.absent();
  }
  ObjectId objectId=resolved.get();
  if (objectId.isNull()) {
    return Optional.of(RevTree.EMPTY_TREE_ID);
  }
  final TYPE objectType=command(ResolveObjectType.class).setObjectId(objectId).call();
switch (objectType) {
case TREE:
    break;
case COMMIT:
{
    Optional<RevCommit> commit=command(RevObjectParse.class).setObjectId(objectId).call(RevCommit.class);
    if (commit.isPresent()) {
      objectId=commit.get().getTreeId();
    }
 else {
      objectId=null;
    }
    break;
  }
case TAG:
{
  Optional<RevTag> tag=command(RevObjectParse.class).setObjectId(objectId).call(RevTag.class);
  if (tag.isPresent()) {
    ObjectId commitId=tag.get().getCommitId();
    return call(Optional.of(commitId));
  }
}
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",treeishRefSpec,String.valueOf(objectType)));
}
return Optional.fromNullable(objectId);
}","/** 
 * @param resolved an {@link Optional} with an ObjectId to resolve
 * @return an {@link Optional} of the {@link ObjectId} that was resolved, or{@link Optional#absent()} if it did not resolve.
 */
private Optional<ObjectId> call(Optional<ObjectId> resolved){
  if (!resolved.isPresent()) {
    return Optional.absent();
  }
  ObjectId objectId=resolved.get();
  if (objectId.isNull()) {
    return Optional.of(RevTree.EMPTY_TREE_ID);
  }
  ObjectStore source=this.source == null ? objectDatabase() : this.source;
  final TYPE objectType=command(ResolveObjectType.class).setSource(source).setObjectId(objectId).call();
switch (objectType) {
case TREE:
    break;
case COMMIT:
{
    Optional<RevCommit> commit=command(RevObjectParse.class).setSource(source).setObjectId(objectId).call(RevCommit.class);
    if (commit.isPresent()) {
      objectId=commit.get().getTreeId();
    }
 else {
      objectId=null;
    }
    break;
  }
case TAG:
{
  Optional<RevTag> tag=command(RevObjectParse.class).setSource(source).setObjectId(objectId).call(RevTag.class);
  if (tag.isPresent()) {
    ObjectId commitId=tag.get().getCommitId();
    return call(Optional.of(commitId));
  }
}
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",treeishRefSpec,String.valueOf(objectType)));
}
return Optional.fromNullable(objectId);
}",0.9494315954527636
113258,"/** 
 * Executes the command.
 * @return an {@link Optional} of the {@link ObjectId} that was resolved, or{@link Optional#absent()} if it did not resolve.
 */
@Override protected Optional<ObjectId> _call(){
  checkState(treeishRefSpec != null || treeish != null,""String_Node_Str"");
  Optional<ObjectId> resolved;
  if (treeishRefSpec != null) {
    resolved=command(RevParse.class).setRefSpec(treeishRefSpec).call();
  }
 else {
    resolved=Optional.of(treeish);
  }
  return call(resolved);
}","/** 
 * Executes the command.
 * @return an {@link Optional} of the {@link ObjectId} that was resolved, or{@link Optional#absent()} if it did not resolve.
 */
@Override protected Optional<ObjectId> _call(){
  checkState(treeishRefSpec != null || treeish != null,""String_Node_Str"");
  ObjectStore source=this.source == null ? objectDatabase() : this.source;
  Optional<ObjectId> resolved;
  if (treeishRefSpec != null) {
    resolved=command(RevParse.class).setSource(source).setRefSpec(treeishRefSpec).call();
  }
 else {
    resolved=Optional.of(treeish);
  }
  return call(resolved);
}",0.913968547641073
113259,"/** 
 * @param clazz the base type of the parsed objects
 * @return the resolved object id
 * @see RevObject
 */
public <T extends RevObject>Optional<T> call(Class<T> clazz){
  final ObjectId resolvedObjectId;
  if (objectId == null) {
    Optional<ObjectId> parsed=command(RevParse.class).setRefSpec(refSpec).call();
    if (parsed.isPresent()) {
      resolvedObjectId=parsed.get();
    }
 else {
      resolvedObjectId=ObjectId.NULL;
    }
  }
 else {
    resolvedObjectId=objectId;
  }
  if (resolvedObjectId.isNull()) {
    return Optional.absent();
  }
  RevObject revObject;
  if (RevTree.EMPTY_TREE_ID.equals(resolvedObjectId)) {
    revObject=RevTree.EMPTY;
  }
 else {
    revObject=objectDatabase().get(resolvedObjectId,clazz);
  }
  Preconditions.checkArgument(clazz.isAssignableFrom(revObject.getClass()),""String_Node_Str"",clazz.getName(),revObject.getClass().getName());
  return Optional.of(clazz.cast(revObject));
}","/** 
 * @param clazz the base type of the parsed objects
 * @return the resolved object id
 * @see RevObject
 */
public <T extends RevObject>Optional<T> call(Class<T> clazz){
  this.source=this.source == null ? objectDatabase() : this.source;
  final ObjectId resolvedObjectId;
  if (objectId == null) {
    Optional<ObjectId> parsed=command(RevParse.class).setSource(source).setRefSpec(refSpec).call();
    if (parsed.isPresent()) {
      resolvedObjectId=parsed.get();
    }
 else {
      resolvedObjectId=ObjectId.NULL;
    }
  }
 else {
    resolvedObjectId=objectId;
  }
  if (resolvedObjectId.isNull()) {
    return Optional.absent();
  }
  RevObject revObject;
  if (RevTree.EMPTY_TREE_ID.equals(resolvedObjectId)) {
    revObject=RevTree.EMPTY;
  }
 else {
    revObject=source.get(resolvedObjectId,clazz);
  }
  Preconditions.checkArgument(clazz.isAssignableFrom(revObject.getClass()),""String_Node_Str"",clazz.getName(),revObject.getClass().getName());
  return Optional.of(clazz.cast(revObject));
}",0.8957688338493293
113260,"private Optional<ObjectId> resolveParent(final ObjectId objectId,final int parentN){
  checkNotNull(objectId);
  checkArgument(parentN > -1);
  if (objectId.isNull()) {
    return Optional.absent();
  }
  if (parentN == 0) {
    Optional<RevObject> object=command(RevObjectParse.class).setObjectId(objectId).call();
    checkArgument(object.isPresent() && object.get() instanceof RevCommit,""String_Node_Str"",objectId,(object.isPresent() ? object.get().getType() : ""String_Node_Str""));
    return Optional.of(objectId);
  }
  RevCommit commit=resolveCommit(objectId);
  if (parentN > commit.getParentIds().size()) {
    return Optional.absent();
  }
  return commit.parentN(parentN - 1);
}","private Optional<ObjectId> resolveParent(final ObjectId objectId,final int parentN){
  checkNotNull(objectId);
  checkArgument(parentN > -1);
  if (objectId.isNull()) {
    return Optional.absent();
  }
  if (parentN == 0) {
    Optional<RevObject> object=command(RevObjectParse.class).setSource(source).setObjectId(objectId).call();
    checkArgument(object.isPresent() && object.get() instanceof RevCommit,""String_Node_Str"",objectId,(object.isPresent() ? object.get().getType() : ""String_Node_Str""));
    return Optional.of(objectId);
  }
  RevCommit commit=resolveCommit(objectId);
  if (parentN > commit.getParentIds().size()) {
    return Optional.absent();
  }
  return commit.parentN(parentN - 1);
}",0.9870875179340028
113261,"private Optional<ObjectId> verifyId(ObjectId objectId,RevObject.TYPE type){
  final Optional<RevObject> object=command(RevObjectParse.class).setObjectId(objectId).call();
  checkArgument(object.isPresent(),""String_Node_Str"",objectId);
  final RevObject revObject=object.get();
  if (type.equals(revObject.getType())) {
    return Optional.of(revObject.getId());
  }
 else {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",objectId,type,revObject.getType()));
  }
}","private Optional<ObjectId> verifyId(ObjectId objectId,RevObject.TYPE type){
  final Optional<RevObject> object=command(RevObjectParse.class).setSource(source).setObjectId(objectId).call();
  checkArgument(object.isPresent(),""String_Node_Str"",objectId);
  final RevObject revObject=object.get();
  if (type.equals(revObject.getType())) {
    return Optional.of(revObject.getId());
  }
 else {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",objectId,type,revObject.getType()));
  }
}",0.9818548387096774
113262,"/** 
 * @param objectId
 * @return
 */
private RevCommit resolveCommit(ObjectId objectId){
  final Optional<RevObject> object=command(RevObjectParse.class).setObjectId(objectId).call();
  checkArgument(object.isPresent(),""String_Node_Str"",objectId);
  final RevObject revObject=object.get();
  RevCommit commit;
switch (revObject.getType()) {
case COMMIT:
    commit=(RevCommit)revObject;
  break;
case TAG:
ObjectId commitId=((RevTag)revObject).getCommitId();
commit=command(RevObjectParse.class).setObjectId(commitId).call(RevCommit.class).get();
break;
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",objectId,revObject.getType()));
}
return commit;
}","/** 
 * @param objectId
 * @return
 */
private RevCommit resolveCommit(ObjectId objectId){
  final Optional<RevObject> object=command(RevObjectParse.class).setSource(source).setObjectId(objectId).call();
  checkArgument(object.isPresent(),""String_Node_Str"",objectId);
  final RevObject revObject=object.get();
  RevCommit commit;
switch (revObject.getType()) {
case COMMIT:
    commit=(RevCommit)revObject;
  break;
case TAG:
ObjectId commitId=((RevTag)revObject).getCommitId();
commit=command(RevObjectParse.class).setSource(source).setObjectId(commitId).call(RevCommit.class).get();
break;
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",objectId,revObject.getType()));
}
return commit;
}",0.9743223965763196
113263,"private Optional<ObjectId> revParse(String refSpec){
  String path=null;
  if (refSpec.contains(PATH_SEPARATOR)) {
    String[] tokens=refSpec.split(PATH_SEPARATOR);
    refSpec=tokens[0];
    path=tokens[1];
  }
  final String prefix;
  int parentN=-1;
  int ancestorN=-1;
  RevObject.TYPE type=null;
  final StringBuilder remaining=new StringBuilder();
  if (refSpec.indexOf(PARENT_DELIMITER) > 0) {
    prefix=parsePrefix(refSpec,PARENT_DELIMITER);
    String suffix=parseSuffix(refSpec,PARENT_DELIMITER);
    if (suffix.indexOf('{') == 0) {
      type=parseType(suffix);
    }
 else {
      parentN=parseNumber(suffix,1,remaining);
    }
  }
 else   if (refSpec.indexOf(ANCESTOR_DELIMITER) > 0) {
    prefix=parsePrefix(refSpec,ANCESTOR_DELIMITER);
    String suffix=parseSuffix(refSpec,ANCESTOR_DELIMITER);
    ancestorN=parseNumber(suffix,1,remaining);
  }
 else {
    prefix=refSpec;
  }
  Optional<ObjectId> resolved=resolveObject(prefix);
  if (!resolved.isPresent()) {
    return resolved;
  }
  if (parentN > -1) {
    resolved=resolveParent(resolved.get(),parentN);
  }
 else   if (ancestorN > -1) {
    resolved=resolveAncestor(resolved.get(),ancestorN);
  }
 else   if (type != null) {
    resolved=verifyId(resolved.get(),type);
  }
  if (resolved.isPresent() && remaining.length() > 0) {
    String newRefSpec=resolved.get().toString() + remaining.toString();
    resolved=revParse(newRefSpec);
  }
  if (!resolved.isPresent()) {
    return resolved;
  }
  if (path != null) {
    NodeRef.checkValidPath(path);
    Optional<ObjectId> treeId=command(ResolveTreeish.class).setTreeish(resolved.get()).call();
    if (!treeId.isPresent() || treeId.get().isNull()) {
      return Optional.absent();
    }
    Optional<RevTree> revTree=command(RevObjectParse.class).setObjectId(treeId.get()).call(RevTree.class);
    Optional<NodeRef> ref=command(FindTreeChild.class).setParent(revTree.get()).setChildPath(path).call();
    if (!ref.isPresent()) {
      return Optional.absent();
    }
    resolved=Optional.of(ref.get().getObjectId());
  }
  return resolved;
}","private Optional<ObjectId> revParse(String refSpec){
  this.source=this.source == null ? objectDatabase() : this.source;
  String path=null;
  if (refSpec.contains(PATH_SEPARATOR)) {
    String[] tokens=refSpec.split(PATH_SEPARATOR);
    refSpec=tokens[0];
    path=tokens[1];
  }
  final String prefix;
  int parentN=-1;
  int ancestorN=-1;
  RevObject.TYPE type=null;
  final StringBuilder remaining=new StringBuilder();
  if (refSpec.indexOf(PARENT_DELIMITER) > 0) {
    prefix=parsePrefix(refSpec,PARENT_DELIMITER);
    String suffix=parseSuffix(refSpec,PARENT_DELIMITER);
    if (suffix.indexOf('{') == 0) {
      type=parseType(suffix);
    }
 else {
      parentN=parseNumber(suffix,1,remaining);
    }
  }
 else   if (refSpec.indexOf(ANCESTOR_DELIMITER) > 0) {
    prefix=parsePrefix(refSpec,ANCESTOR_DELIMITER);
    String suffix=parseSuffix(refSpec,ANCESTOR_DELIMITER);
    ancestorN=parseNumber(suffix,1,remaining);
  }
 else {
    prefix=refSpec;
  }
  Optional<ObjectId> resolved=resolveObject(prefix);
  if (!resolved.isPresent()) {
    return resolved;
  }
  if (parentN > -1) {
    resolved=resolveParent(resolved.get(),parentN);
  }
 else   if (ancestorN > -1) {
    resolved=resolveAncestor(resolved.get(),ancestorN);
  }
 else   if (type != null) {
    resolved=verifyId(resolved.get(),type);
  }
  if (resolved.isPresent() && remaining.length() > 0) {
    String newRefSpec=resolved.get().toString() + remaining.toString();
    resolved=revParse(newRefSpec);
  }
  if (!resolved.isPresent()) {
    return resolved;
  }
  if (path != null) {
    NodeRef.checkValidPath(path);
    Optional<ObjectId> treeId=command(ResolveTreeish.class).setSource(source).setTreeish(resolved.get()).call();
    if (!treeId.isPresent() || treeId.get().isNull()) {
      return Optional.absent();
    }
    Optional<RevTree> revTree=command(RevObjectParse.class).setSource(source).setObjectId(treeId.get()).call(RevTree.class);
    Optional<NodeRef> ref=command(FindTreeChild.class).setParent(revTree.get()).setChildPath(path).call();
    if (!ref.isPresent()) {
      return Optional.absent();
    }
    resolved=Optional.of(ref.get().getObjectId());
  }
  return resolved;
}",0.975506358926048
113264,"/** 
 * @param objectName a ref name or object id
 */
private Optional<ObjectId> resolveObject(final String refSpec){
  ObjectId resolvedTo=null;
  Optional<Ref> ref=command(RefParse.class).setName(refSpec).call();
  if (ref.isPresent()) {
    resolvedTo=ref.get().getObjectId();
  }
 else {
    boolean hexPatternMatches=HEX_PATTERN.matcher(refSpec).matches();
    if (hexPatternMatches) {
      try {
        ObjectId parsed=ObjectId.valueOf(refSpec);
        if (parsed.isNull()) {
          return Optional.of(ObjectId.NULL);
        }
        if (parsed.equals(RevTree.EMPTY_TREE_ID)) {
          return Optional.of(RevTree.EMPTY_TREE_ID);
        }
        if (objectDatabase().exists(parsed)) {
          return Optional.of(parsed);
        }
      }
 catch (      IllegalArgumentException ignore) {
      }
      List<ObjectId> hashMatches=objectDatabase().lookUp(refSpec);
      if (hashMatches.size() > 1) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",refSpec,hashMatches.toString()));
      }
      if (hashMatches.size() == 1) {
        resolvedTo=hashMatches.get(0);
      }
 else       if (ObjectId.NULL.toString().startsWith(refSpec)) {
        resolvedTo=ObjectId.NULL;
      }
 else       if (RevTree.EMPTY_TREE_ID.toString().startsWith(refSpec)) {
        resolvedTo=RevTree.EMPTY.getId();
      }
    }
  }
  return Optional.fromNullable(resolvedTo);
}","/** 
 * @param objectName a ref name or object id
 */
private Optional<ObjectId> resolveObject(final String refSpec){
  ObjectId resolvedTo=null;
  Optional<Ref> ref=command(RefParse.class).setName(refSpec).call();
  if (ref.isPresent()) {
    resolvedTo=ref.get().getObjectId();
  }
 else {
    boolean hexPatternMatches=HEX_PATTERN.matcher(refSpec).matches();
    if (hexPatternMatches) {
      try {
        ObjectId parsed=ObjectId.valueOf(refSpec);
        if (parsed.isNull()) {
          return Optional.of(ObjectId.NULL);
        }
        if (parsed.equals(RevTree.EMPTY_TREE_ID)) {
          return Optional.of(RevTree.EMPTY_TREE_ID);
        }
        if (source.exists(parsed)) {
          return Optional.of(parsed);
        }
      }
 catch (      IllegalArgumentException ignore) {
      }
      List<ObjectId> hashMatches=source.lookUp(refSpec);
      if (hashMatches.size() > 1) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",refSpec,hashMatches.toString()));
      }
      if (hashMatches.size() == 1) {
        resolvedTo=hashMatches.get(0);
      }
 else       if (ObjectId.NULL.toString().startsWith(refSpec)) {
        resolvedTo=ObjectId.NULL;
      }
 else       if (RevTree.EMPTY_TREE_ID.toString().startsWith(refSpec)) {
        resolvedTo=RevTree.EMPTY.getId();
      }
    }
  }
  return Optional.fromNullable(resolvedTo);
}",0.8706896551724138
113265,"@SuppressWarnings(""String_Node_Str"") public static Index deserialize(DataInput in) throws IOException {
  String treeName=(String)DataStreamValueSerializerV2.read(FieldType.STRING,in);
  String attributeName=(String)DataStreamValueSerializerV2.read(FieldType.STRING,in);
  IndexType indexType=IndexType.valueOf((String)DataStreamValueSerializerV2.read(FieldType.STRING,in));
  Map<String,Object> metadata=(Map<String,Object>)DataStreamValueSerializerV2.read(FieldType.MAP,in);
  return new Index(treeName,attributeName,indexType,metadata);
}","@SuppressWarnings(""String_Node_Str"") public static Index deserialize(DataInput in) throws IOException {
  String treeName=(String)DataStreamValueSerializerV2.read(FieldType.STRING,in);
  String attributeName=(String)DataStreamValueSerializerV2.read(FieldType.STRING,in);
  IndexType indexType=IndexType.valueOf((String)DataStreamValueSerializerV2.read(FieldType.STRING,in));
  Map<String,Object> metadata;
  try {
    metadata=(Map<String,Object>)DataStreamValueSerializerV2.read(FieldType.MAP,in);
  }
 catch (  EOFException e) {
    metadata=null;
  }
  return new Index(treeName,attributeName,indexType,metadata);
}",0.9335634167385676
113266,"@Override public int compare(Quadrant[] left,Quadrant[] right){
  final int minDepth=Math.min(left.length,right.length);
  int c;
  for (int d=0; d > minDepth; d++) {
    c=left[d].compareTo(right[d]);
    if (c != 0) {
      return c;
    }
  }
  c=left.length - right.length;
  return c;
}","@Override public int compare(Quadrant[] left,Quadrant[] right){
  final int minDepth=Math.min(left.length,right.length);
  int c;
  for (int d=0; d < minDepth; d++) {
    c=left[d].compareTo(right[d]);
    if (c != 0) {
      return c;
    }
  }
  c=left.length - right.length;
  return c;
}",0.9965635738831616
113267,"/** 
 * Constructs a new   {@code RevFeatureType} from the given {@link ObjectId} and{@link FeatureType}.
 * @param id the object id to use for this feature type
 * @param featureType the feature type to use
 */
public RevFeatureTypeImpl(ObjectId id,FeatureType featureType){
  super(id);
  checkNotNull(featureType);
  CoordinateReferenceSystem defaultCrs=featureType.getCoordinateReferenceSystem();
  if (WGS84.equals(defaultCrs)) {
    checkArgument(featureType instanceof SimpleFeatureType);
    try {
      final boolean longitudeFirst=true;
      CoordinateReferenceSystem epsg4326=CRS.decode(""String_Node_Str"",longitudeFirst);
      String[] includeAllAttributes=null;
      featureType=DataUtilities.createSubType((SimpleFeatureType)featureType,includeAllAttributes,epsg4326);
    }
 catch (    Exception e) {
      throw Throwables.propagate(e);
    }
  }
  this.featureType=featureType;
  sortedDescriptors=ImmutableList.copyOf(featureType.getDescriptors());
}","/** 
 * Constructs a new   {@code RevFeatureType} from the given {@link ObjectId} and{@link FeatureType}.
 * @param id the object id to use for this feature type
 * @param featureType the feature type to use
 */
public RevFeatureTypeImpl(ObjectId id,FeatureType featureType){
  super(id);
  checkNotNull(featureType);
  CoordinateReferenceSystem defaultCrs=featureType.getCoordinateReferenceSystem();
  if (WGS84.equals((org.geotools.referencing.AbstractIdentifiedObject)defaultCrs,false)) {
    checkArgument(featureType instanceof SimpleFeatureType);
    try {
      final boolean longitudeFirst=true;
      CoordinateReferenceSystem epsg4326=CRS.decode(""String_Node_Str"",longitudeFirst);
      String[] includeAllAttributes=null;
      featureType=DataUtilities.createSubType((SimpleFeatureType)featureType,includeAllAttributes,epsg4326);
    }
 catch (    Exception e) {
      throw Throwables.propagate(e);
    }
  }
  this.featureType=featureType;
  sortedDescriptors=ImmutableList.copyOf(featureType.getDescriptors());
}",0.971457185778668
113268,"@Override public FeatureIterator<F> features(){
  if (delegate.getSchema().getDescriptors().size() != featureType.getDescriptors().size()) {
    throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
  }
  GeometryDescriptor geomDescriptorOrg=delegate.getSchema().getGeometryDescriptor();
  GeometryDescriptor geomDescriptorDest=featureType.getGeometryDescriptor();
  if (!geomDescriptorOrg.getType().getBinding().equals(geomDescriptorDest.getType().getBinding()) || !geomDescriptorOrg.getType().getCoordinateReferenceSystem().equals(geomDescriptorDest.getType().getCoordinateReferenceSystem())) {
    throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
  }
  FeatureIterator<F> iterator=delegate.features();
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder((SimpleFeatureType)featureType);
  return new FeatureTypeConverterIterator<F>(iterator,(SimpleFeatureBuilder)builder);
}","@Override public FeatureIterator<F> features(){
  if (delegate.getSchema().getDescriptors().size() != featureType.getDescriptors().size()) {
    throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
  }
  GeometryDescriptor geomDescriptorOrg=delegate.getSchema().getGeometryDescriptor();
  GeometryDescriptor geomDescriptorDest=featureType.getGeometryDescriptor();
  if (!geomDescriptorOrg.getType().getBinding().equals(geomDescriptorDest.getType().getBinding())) {
    throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
  }
  AbstractReferenceSystem crsOrg=(AbstractReferenceSystem)delegate.getSchema().getCoordinateReferenceSystem();
  AbstractReferenceSystem crsDest=(AbstractReferenceSystem)featureType.getCoordinateReferenceSystem();
  if (!crsOrg.equals(crsDest,false)) {
    throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
  }
  FeatureIterator<F> iterator=delegate.features();
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder((SimpleFeatureType)featureType);
  return new FeatureTypeConverterIterator<F>(iterator,(SimpleFeatureBuilder)builder);
}",0.7677146879399342
113269,"@Override public FeatureCollection<T,F> getFeatures(Query query) throws IOException {
  final FeatureCollection<T,F> features=super.getFeatures(query);
  return new ForwardingFeatureCollection<T,F>(features){
    @Override public FeatureIterator<F> features(){
      if (delegate.getSchema().getDescriptors().size() != featureType.getDescriptors().size()) {
        throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
      }
      GeometryDescriptor geomDescriptorOrg=delegate.getSchema().getGeometryDescriptor();
      GeometryDescriptor geomDescriptorDest=featureType.getGeometryDescriptor();
      if (!geomDescriptorOrg.getType().getBinding().equals(geomDescriptorDest.getType().getBinding()) || !geomDescriptorOrg.getType().getCoordinateReferenceSystem().equals(geomDescriptorDest.getType().getCoordinateReferenceSystem())) {
        throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
      }
      FeatureIterator<F> iterator=delegate.features();
      SimpleFeatureBuilder builder=new SimpleFeatureBuilder((SimpleFeatureType)featureType);
      return new FeatureTypeConverterIterator<F>(iterator,(SimpleFeatureBuilder)builder);
    }
    @Override public T getSchema(){
      return featureType;
    }
  }
;
}","@Override public FeatureCollection<T,F> getFeatures(Query query) throws IOException {
  final FeatureCollection<T,F> features=super.getFeatures(query);
  return new ForwardingFeatureCollection<T,F>(features){
    @Override public FeatureIterator<F> features(){
      if (delegate.getSchema().getDescriptors().size() != featureType.getDescriptors().size()) {
        throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
      }
      GeometryDescriptor geomDescriptorOrg=delegate.getSchema().getGeometryDescriptor();
      GeometryDescriptor geomDescriptorDest=featureType.getGeometryDescriptor();
      if (!geomDescriptorOrg.getType().getBinding().equals(geomDescriptorDest.getType().getBinding())) {
        throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
      }
      AbstractReferenceSystem crsOrg=(AbstractReferenceSystem)delegate.getSchema().getCoordinateReferenceSystem();
      AbstractReferenceSystem crsDest=(AbstractReferenceSystem)featureType.getCoordinateReferenceSystem();
      if (!crsOrg.equals(crsDest,false)) {
        throw new GeoToolsOpException(GeoToolsOpException.StatusCode.INCOMPATIBLE_FEATURE_TYPE);
      }
      FeatureIterator<F> iterator=delegate.features();
      SimpleFeatureBuilder builder=new SimpleFeatureBuilder((SimpleFeatureType)featureType);
      return new FeatureTypeConverterIterator<F>(iterator,(SimpleFeatureBuilder)builder);
    }
    @Override public T getSchema(){
      return featureType;
    }
  }
;
}",0.8176991150442477
113270,"private static ExecutorService createExecutorService(Environment.ConnectionConfig config,int threadPoolSize){
  String poolName=String.format(""String_Node_Str"",config.getServer(),config.getPortNumber(),config.getDatabaseName()) + ""String_Node_Str"";
  return Executors.newFixedThreadPool(threadPoolSize,new ThreadFactoryBuilder().setNameFormat(poolName).setDaemon(true).build());
}","private static ExecutorService createExecutorService(ThreadFactory threadFactory,Environment.ConnectionConfig config,int threadPoolSize){
  String poolName=String.format(""String_Node_Str"",config.getServer(),config.getPortNumber(),config.getDatabaseName()) + ""String_Node_Str"";
  return Executors.newFixedThreadPool(threadPoolSize,new ThreadFactoryBuilder().setThreadFactory(threadFactory).setNameFormat(poolName).setDaemon(true).build());
}",0.926829268292683
113271,"public synchronized static void retain(ConfigDatabase configdb,Environment.ConnectionConfig config,String tableNamesPrefix){
  final Key key=new Key(config,tableNamesPrefix);
  SharedResourceReference ref=sharedResources.get(key);
  if (ref == null) {
    int threadPoolSize;
    Optional<Integer> tpoolSize=configdb.get(KEY_THREADPOOL_SIZE,Integer.class).or(configdb.getGlobal(KEY_THREADPOOL_SIZE,Integer.class));
    if (tpoolSize.isPresent()) {
      Integer poolSize=tpoolSize.get();
      Preconditions.checkState(poolSize.intValue() > 0,""String_Node_Str"",poolSize);
      threadPoolSize=poolSize;
    }
 else {
      threadPoolSize=Math.max(Runtime.getRuntime().availableProcessors(),2);
    }
    ExecutorService databaseExecutor=createExecutorService(config,threadPoolSize);
    Cache<ObjectId,byte[]> byteCache=createCache(configdb);
    ref=new SharedResourceReference(byteCache,databaseExecutor,threadPoolSize);
    sharedResources.put(key,ref);
  }
 else {
    ref.refCount++;
  }
}","public synchronized static void retain(ConfigDatabase configdb,Environment.ConnectionConfig config,String tableNamesPrefix){
  final Key key=new Key(config,tableNamesPrefix);
  SharedResourceReference ref=sharedResources.get(key);
  if (ref == null) {
    int threadPoolSize;
    Optional<Integer> tpoolSize=configdb.get(KEY_THREADPOOL_SIZE,Integer.class).or(configdb.getGlobal(KEY_THREADPOOL_SIZE,Integer.class));
    if (tpoolSize.isPresent()) {
      Integer poolSize=tpoolSize.get();
      Preconditions.checkState(poolSize.intValue() > 0,""String_Node_Str"",poolSize);
      threadPoolSize=poolSize;
    }
 else {
      threadPoolSize=Math.max(Runtime.getRuntime().availableProcessors(),2);
    }
    final String threadGroupName=String.format(""String_Node_Str"",config.getServer(),config.getPortNumber(),config.getDatabaseName());
    final ThreadGroup threadGroup=new ThreadGroup(threadGroupName);
    final ThreadFactory threadFactory=new ThreadFactory(){
      public Thread newThread(      Runnable r){
        return new Thread(threadGroup,r);
      }
    }
;
    ExecutorService databaseExecutor=createExecutorService(threadFactory,config,threadPoolSize);
    Cache<ObjectId,byte[]> byteCache=createCache(configdb);
    ref=new SharedResourceReference(byteCache,databaseExecutor,threadPoolSize,threadGroup);
    sharedResources.put(key,ref);
  }
 else {
    ref.refCount++;
  }
}",0.834592779177162
113272,"SharedResourceReference(Cache<ObjectId,byte[]> byteCache,ExecutorService executor,int threadPoolSize){
  this.executor=executor;
  this.byteCache=byteCache;
  this.threadPoolSize=threadPoolSize;
}","SharedResourceReference(Cache<ObjectId,byte[]> byteCache,ExecutorService executor,int threadPoolSize,ThreadGroup threadGroup){
  this.executor=executor;
  this.byteCache=byteCache;
  this.threadPoolSize=threadPoolSize;
  this.threadGroup=threadGroup;
}",0.875
113273,"private Future<List<RevObject>> getAll(final List<ObjectId> ids,final DataSource ds,final BulkOpListener listener,final @Nullable TYPE type){
  checkState(isOpen(),""String_Node_Str"");
  GetAllOp getAllOp=new GetAllOp(ids,listener,this,type);
  Future<List<RevObject>> future=executor.submit(getAllOp);
  return future;
}","private Future<List<RevObject>> getAll(final List<ObjectId> ids,final DataSource ds,final BulkOpListener listener,final @Nullable TYPE type){
  checkState(isOpen(),""String_Node_Str"");
  GetAllOp getAllOp=new GetAllOp(ids,listener,this,type);
  if (Thread.currentThread().getThreadGroup().equals(threadGroup)) {
    try {
      List<RevObject> objects=getAllOp.call();
      return Futures.immediateFuture(objects);
    }
 catch (    Exception e) {
      propagate(e);
    }
  }
  Future<List<RevObject>> future=executor.submit(getAllOp);
  return future;
}",0.730593607305936
113274,"@Override public void open(){
  if (dataSource != null) {
    return;
  }
  dataSource=connect();
  Optional<Integer> getAllFetchSize=configdb.get(KEY_GETALL_BATCH_SIZE,Integer.class);
  Optional<Integer> putAllBatchSize=configdb.get(KEY_PUTALL_BATCH_SIZE,Integer.class);
  if (getAllFetchSize.isPresent()) {
    Integer fetchSize=getAllFetchSize.get();
    Preconditions.checkState(fetchSize.intValue() > 0,""String_Node_Str"",fetchSize);
    this.getAllBatchSize=fetchSize;
  }
  if (putAllBatchSize.isPresent()) {
    Integer batchSize=putAllBatchSize.get();
    Preconditions.checkState(batchSize.intValue() > 0,""String_Node_Str"",batchSize);
    this.putAllBatchSize=batchSize;
  }
  final int repositoryId=config.getRepositoryId();
  final String conflictsTable=config.getTables().conflicts();
  final String blobsTable=config.getTables().blobs();
  final String prefix=config.getTables().getPrefix();
  final ConnectionConfig connectionConfig=config.connectionConfig;
  ObjectDatabaseSharedResources.retain(configdb,connectionConfig,prefix);
  executor=ObjectDatabaseSharedResources.getExecutor(connectionConfig,prefix);
  byteCache=ObjectDatabaseSharedResources.getByteCache(connectionConfig,prefix);
  threadPoolSize=ObjectDatabaseSharedResources.getThreadPoolSize(connectionConfig,prefix);
  conflicts=new PGConflictsDatabase(dataSource,conflictsTable,repositoryId);
  blobStore=new PGBlobStore(dataSource,blobsTable,repositoryId);
}","@Override public void open(){
  if (dataSource != null) {
    return;
  }
  dataSource=connect();
  Optional<Integer> getAllFetchSize=configdb.get(KEY_GETALL_BATCH_SIZE,Integer.class);
  Optional<Integer> putAllBatchSize=configdb.get(KEY_PUTALL_BATCH_SIZE,Integer.class);
  if (getAllFetchSize.isPresent()) {
    Integer fetchSize=getAllFetchSize.get();
    Preconditions.checkState(fetchSize.intValue() > 0,""String_Node_Str"",fetchSize);
    this.getAllBatchSize=fetchSize;
  }
  if (putAllBatchSize.isPresent()) {
    Integer batchSize=putAllBatchSize.get();
    Preconditions.checkState(batchSize.intValue() > 0,""String_Node_Str"",batchSize);
    this.putAllBatchSize=batchSize;
  }
  final int repositoryId=config.getRepositoryId();
  final String conflictsTable=config.getTables().conflicts();
  final String blobsTable=config.getTables().blobs();
  final String prefix=config.getTables().getPrefix();
  final ConnectionConfig connectionConfig=config.connectionConfig;
  ObjectDatabaseSharedResources.retain(configdb,connectionConfig,prefix);
  executor=ObjectDatabaseSharedResources.getExecutor(connectionConfig,prefix);
  byteCache=ObjectDatabaseSharedResources.getByteCache(connectionConfig,prefix);
  threadPoolSize=ObjectDatabaseSharedResources.getThreadPoolSize(connectionConfig,prefix);
  threadGroup=ObjectDatabaseSharedResources.getThreadGroup(connectionConfig,prefix);
  conflicts=new PGConflictsDatabase(dataSource,conflictsTable,repositoryId);
  blobStore=new PGBlobStore(dataSource,blobsTable,repositoryId);
}",0.9713322091062394
113275,"/** 
 * Transforms all features to use a feature id that is compatible with GeoPackage. Keeps track of all the mappings so they can be added to the geopackage file after the export.
 * @param featureType the feature type of the features to transform
 * @return the transforming function
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    for (    Property property : feature.getProperties()) {
      if (property instanceof GeometryAttribute) {
        builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
      }
 else {
        builder.set(property.getName().getLocalPart(),property.getValue());
      }
    }
    Map<Object,Object> userData=feature.getUserData();
    for (    Entry<Object,Object> entry : userData.entrySet()) {
      builder.featureUserData(entry.getKey(),entry.getValue());
    }
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),feature.getIdentifier().getID());
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}","/** 
 * Transforms all features to use a feature id that is compatible with GeoPackage. Keeps track of all the mappings so they can be added to the geopackage file after the export.
 * @param featureType the feature type of the features to transform
 * @return the transforming function
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    builder.init((SimpleFeature)feature);
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),feature.getIdentifier().getID());
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}",0.7758099352051836
113276,"@Override public SimpleFeature next(){
  SimpleFeature next=super.next();
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
  for (  Property property : next.getProperties()) {
    if (property instanceof GeometryAttribute) {
      builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
    }
 else {
      builder.set(property.getName().getLocalPart(),property.getValue());
    }
  }
  Map<Object,Object> userData=next.getUserData();
  for (  Entry<Object,Object> entry : userData.entrySet()) {
    builder.featureUserData(entry.getKey(),entry.getValue());
  }
  String oldFeatureId=next.getIdentifier().getID();
  String featureId;
  if (fidMappings.containsKey(oldFeatureId)) {
    featureId=fidMappings.get(oldFeatureId);
  }
 else {
    featureId=SimpleFeatureBuilder.createDefaultFeatureId();
  }
  return builder.buildFeature(featureId);
}","@Override public SimpleFeature next(){
  SimpleFeature next=super.next();
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
  builder.init(next);
  String oldFeatureId=next.getIdentifier().getID();
  String featureId;
  if (fidMappings.containsKey(oldFeatureId)) {
    featureId=fidMappings.get(oldFeatureId);
  }
 else {
    featureId=SimpleFeatureBuilder.createDefaultFeatureId();
  }
  return builder.buildFeature(featureId);
}",0.6487695749440716
113277,"/** 
 * @param featureType the feature type of the features to transform
 * @return a transform function to update and keep track of feature id mappings of exportedfeatures
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    String featureId=feature.getIdentifier().getID();
    if (!changedNodes.containsKey(featureId)) {
      return Optional.absent();
    }
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    for (    Property property : feature.getProperties()) {
      if (property instanceof GeometryAttribute) {
        builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
      }
 else {
        builder.set(property.getName().getLocalPart(),property.getValue());
      }
    }
    Map<Object,Object> userData=feature.getUserData();
    for (    Entry<Object,Object> entry : userData.entrySet()) {
      builder.featureUserData(entry.getKey(),entry.getValue());
    }
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),featureId);
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}","/** 
 * @param featureType the feature type of the features to transform
 * @return a transform function to update and keep track of feature id mappings of exportedfeatures
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    String featureId=feature.getIdentifier().getID();
    if (!changedNodes.containsKey(featureId)) {
      return Optional.absent();
    }
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    builder.init((SimpleFeature)feature);
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),featureId);
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}",0.7757210503659061
113278,"/** 
 * @param featureType the feature type of the features to transform
 * @return a transform function to update and keep track of feature id mappings of exportedfeatures
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    for (    Property property : feature.getProperties()) {
      if (property instanceof GeometryAttribute) {
        builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
      }
 else {
        builder.set(property.getName().getLocalPart(),property.getValue());
      }
    }
    Map<Object,Object> userData=feature.getUserData();
    for (    Entry<Object,Object> entry : userData.entrySet()) {
      builder.featureUserData(entry.getKey(),entry.getValue());
    }
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),feature.getIdentifier().getID());
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}","/** 
 * @param featureType the feature type of the features to transform
 * @return a transform function to update and keep track of feature id mappings of exportedfeatures
 */
@Override protected Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=(feature) -> {
    SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
    builder.init((SimpleFeature)feature);
    long fidValue=nextId.incrementAndGet();
    builder.featureUserData(Hints.PROVIDED_FID,Long.valueOf(fidValue));
    fidMappings.put(Long.toString(fidValue),feature.getIdentifier().getID());
    Feature modifiedFeature=builder.buildFeature(Long.toString(fidValue));
    return Optional.fromNullable(modifiedFeature);
  }
;
  return function;
}",0.7513176808816483
113279,"public Map<String,String> getFidMappings(String tableName) throws SQLException {
  final String sql=format(""String_Node_Str"",tableName + ""String_Node_Str"");
  Map<String,String> mappings=new HashMap<String,String>();
  try (Statement st=cx.createStatement()){
    try (ResultSet rs=st.executeQuery(sql)){
      while (rs.next()) {
        String gpkg_fid=rs.getString(1);
        String geogig_fid=rs.getString(2);
        mappings.put(gpkg_fid,geogig_fid);
      }
    }
   }
   return mappings;
}","public Map<String,String> getFidMappings(String tableName) throws SQLException {
  String fidTable=tableName + ""String_Node_Str"";
  Map<String,String> mappings=new HashMap<String,String>();
  DatabaseMetaData dbm=cx.getMetaData();
  ResultSet tables=dbm.getTables(null,null,fidTable,null);
  while (tables.next()) {
    if (tables.getString(""String_Node_Str"").equals(fidTable)) {
      final String sql=format(""String_Node_Str"",fidTable);
      try (Statement st=cx.createStatement()){
        try (ResultSet rs=st.executeQuery(sql)){
          while (rs.next()) {
            String gpkg_fid=rs.getString(1);
            String geogig_fid=rs.getString(2);
            mappings.put(gpkg_fid,geogig_fid);
          }
        }
       }
     }
  }
  return mappings;
}",0.6075949367088608
113280,"/** 
 * Executes the diff-tree command with the specified options.
 */
@Override protected void runInternal(GeogigCLI cli) throws IOException {
  if (refSpec.size() > 2) {
    throw new InvalidParameterException(""String_Node_Str"" + refSpec);
  }
  if (treeStats && describe) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  GeoGIG geogig=cli.getGeogig();
  org.locationtech.geogig.api.plumbing.DiffTree diff=geogig.command(org.locationtech.geogig.api.plumbing.DiffTree.class);
  String oldVersion=resolveOldVersion();
  String newVersion=resolveNewVersion();
  diff.setOldVersion(oldVersion).setNewVersion(newVersion);
  Iterator<DiffEntry> diffEntries;
  if (paths.isEmpty()) {
    diffEntries=diff.setProgressListener(cli.getProgressListener()).call();
  }
 else {
    diffEntries=Collections.emptyIterator();
    for (    String path : paths) {
      Iterator<DiffEntry> moreEntries=diff.setPathFilter(path).setProgressListener(cli.getProgressListener()).call();
      diffEntries=Iterators.concat(diffEntries,moreEntries);
    }
  }
  DiffEntry diffEntry;
  HashMap<String,Long[]> stats=Maps.newHashMap();
  while (diffEntries.hasNext()) {
    diffEntry=diffEntries.next();
    StringBuilder sb=new StringBuilder();
    String path=diffEntry.newPath() != null ? diffEntry.newPath() : diffEntry.oldPath();
    if (describe) {
      sb.append(diffEntry.changeType().toString().charAt(0)).append(' ').append(path).append(LINE_BREAK);
      if (diffEntry.changeType() == ChangeType.MODIFIED) {
        FeatureDiff featureDiff=geogig.command(DiffFeature.class).setNewVersion(Suppliers.ofInstance(diffEntry.getNewObject())).setOldVersion(Suppliers.ofInstance(diffEntry.getOldObject())).call();
        Map<PropertyDescriptor,AttributeDiff> diffs=featureDiff.getDiffs();
        HashSet<PropertyDescriptor> diffDescriptors=Sets.newHashSet(diffs.keySet());
        NodeRef noderef=diffEntry.changeType() != ChangeType.REMOVED ? diffEntry.getNewObject() : diffEntry.getOldObject();
        RevFeatureType featureType=geogig.command(RevObjectParse.class).setObjectId(noderef.getMetadataId()).call(RevFeatureType.class).get();
        Optional<RevObject> obj=geogig.command(RevObjectParse.class).setObjectId(noderef.getObjectId()).call();
        RevFeature feature=(RevFeature)obj.get();
        ImmutableList<Optional<Object>> values=feature.getValues();
        ImmutableList<PropertyDescriptor> descriptors=featureType.sortedDescriptors();
        int idx=0;
        for (        PropertyDescriptor descriptor : descriptors) {
          if (diffs.containsKey(descriptor)) {
            AttributeDiff ad=diffs.get(descriptor);
            sb.append(ad.getType().toString().charAt(0) + ""String_Node_Str"" + descriptor.getName().toString()+ LINE_BREAK);
            if (!ad.getType().equals(TYPE.ADDED)) {
              Object value=ad.getOldValue().orNull();
              sb.append(TextValueSerializer.asString(Optional.fromNullable(value)));
              sb.append(LINE_BREAK);
            }
            if (!ad.getType().equals(TYPE.REMOVED)) {
              Object value=ad.getNewValue().orNull();
              sb.append(TextValueSerializer.asString(Optional.fromNullable(value)));
              sb.append(LINE_BREAK);
            }
            diffDescriptors.remove(descriptor);
          }
 else {
            sb.append(""String_Node_Str"").append(descriptor.getName().toString()).append(LINE_BREAK);
            sb.append(TextValueSerializer.asString(values.get(idx))).append(LINE_BREAK);
          }
          idx++;
        }
        for (        PropertyDescriptor descriptor : diffDescriptors) {
          AttributeDiff ad=diffs.get(descriptor);
          sb.append(ad.getType().toString().charAt(0) + ""String_Node_Str"" + descriptor.getName().toString()+ LINE_BREAK);
          if (!ad.getType().equals(TYPE.ADDED)) {
            Object value=ad.getOldValue().orNull();
            sb.append(TextValueSerializer.asString(Optional.fromNullable(value)));
            sb.append(LINE_BREAK);
          }
          if (!ad.getType().equals(TYPE.REMOVED)) {
            Object value=ad.getNewValue().orNull();
            sb.append(TextValueSerializer.asString(Optional.fromNullable(value)));
            sb.append(LINE_BREAK);
          }
        }
      }
 else {
        NodeRef noderef=diffEntry.changeType() == ChangeType.ADDED ? diffEntry.getNewObject() : diffEntry.getOldObject();
        RevFeatureType featureType=geogig.command(RevObjectParse.class).setObjectId(noderef.getMetadataId()).call(RevFeatureType.class).get();
        Optional<RevObject> obj=geogig.command(RevObjectParse.class).setObjectId(noderef.getObjectId()).call();
        RevFeature feature=(RevFeature)obj.get();
        ImmutableList<Optional<Object>> values=feature.getValues();
        int i=0;
        for (        Optional<Object> value : values) {
          sb.append(diffEntry.changeType().toString().charAt(0));
          sb.append(' ');
          sb.append(featureType.sortedDescriptors().get(i).getName().toString());
          sb.append(LINE_BREAK);
          sb.append(TextValueSerializer.asString(value));
          sb.append(LINE_BREAK);
          i++;
        }
        sb.append(LINE_BREAK);
      }
      sb.append(LINE_BREAK);
      cli.getConsole().println(sb.toString());
    }
 else     if (treeStats) {
      String parent=NodeRef.parentPath(path);
      if (!stats.containsKey(parent)) {
        stats.put(parent,new Long[]{0l,0l,0l});
      }
      Long[] counts=stats.get(parent);
      if (diffEntry.changeType() == ChangeType.ADDED) {
        counts[0]++;
      }
 else       if (diffEntry.changeType() == ChangeType.REMOVED) {
        counts[1]++;
      }
 else       if (diffEntry.changeType() == ChangeType.MODIFIED) {
        counts[2]++;
      }
    }
 else {
      sb.append(path).append(' ');
      sb.append(diffEntry.oldObjectId().toString());
      sb.append(' ');
      sb.append(diffEntry.newObjectId().toString());
      cli.getConsole().println(sb.toString());
    }
  }
  if (treeStats) {
    for (    String path : stats.keySet()) {
      StringBuffer sb=new StringBuffer();
      sb.append(path);
      Long[] counts=stats.get(path);
      for (int i=0; i < counts.length; i++) {
        sb.append(""String_Node_Str"" + counts[i].toString());
      }
      cli.getConsole().println(sb.toString());
    }
  }
}","/** 
 * Executes the diff-tree command with the specified options.
 */
@Override protected void runInternal(GeogigCLI cli) throws IOException {
  if (refSpec.size() > 2) {
    throw new InvalidParameterException(""String_Node_Str"" + refSpec);
  }
  if (treeStats && describe) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  GeoGIG geogig=cli.getGeogig();
  org.locationtech.geogig.api.plumbing.DiffTree diff=geogig.command(org.locationtech.geogig.api.plumbing.DiffTree.class);
  String oldVersion=resolveOldVersion();
  String newVersion=resolveNewVersion();
  diff.setOldVersion(oldVersion).setNewVersion(newVersion);
  Iterator<DiffEntry> diffEntries;
  if (paths.isEmpty()) {
    diffEntries=diff.setProgressListener(cli.getProgressListener()).call();
  }
 else {
    diffEntries=Collections.emptyIterator();
    for (    String path : paths) {
      Iterator<DiffEntry> moreEntries=diff.setPathFilter(path).setProgressListener(cli.getProgressListener()).call();
      diffEntries=Iterators.concat(diffEntries,moreEntries);
    }
  }
  DiffEntry diffEntry;
  HashMap<String,Long[]> stats=Maps.newHashMap();
  while (diffEntries.hasNext()) {
    diffEntry=diffEntries.next();
    StringBuilder sb=new StringBuilder();
    String path=diffEntry.newPath() != null ? diffEntry.newPath() : diffEntry.oldPath();
    if (describe) {
      sb.append(diffEntry.changeType().toString().charAt(0)).append(' ').append(path).append(LINE_BREAK);
      if (diffEntry.changeType() == ChangeType.MODIFIED) {
        FeatureDiff featureDiff=geogig.command(DiffFeature.class).setNewVersion(Suppliers.ofInstance(diffEntry.getNewObject())).setOldVersion(Suppliers.ofInstance(diffEntry.getOldObject())).call();
        Map<PropertyDescriptor,AttributeDiff> diffs=featureDiff.getDiffs();
        HashSet<PropertyDescriptor> diffDescriptors=Sets.newHashSet(diffs.keySet());
        NodeRef noderef=diffEntry.changeType() != ChangeType.REMOVED ? diffEntry.getNewObject() : diffEntry.getOldObject();
        RevFeatureType featureType=geogig.command(RevObjectParse.class).setObjectId(noderef.getMetadataId()).call(RevFeatureType.class).get();
        Optional<RevObject> obj=geogig.command(RevObjectParse.class).setObjectId(noderef.getObjectId()).call();
        RevFeature feature=(RevFeature)obj.get();
        ImmutableList<Optional<Object>> values=feature.getValues();
        ImmutableList<PropertyDescriptor> descriptors=featureType.sortedDescriptors();
        int idx=0;
        for (        PropertyDescriptor descriptor : descriptors) {
          if (diffs.containsKey(descriptor)) {
            AttributeDiff ad=diffs.get(descriptor);
            sb.append(ad.getType().toString().charAt(0) + ""String_Node_Str"" + descriptor.getName().toString()+ LINE_BREAK);
            if (!ad.getType().equals(TYPE.ADDED)) {
              Object value=ad.getOldValue();
              sb.append(TextValueSerializer.asString(value));
              sb.append(LINE_BREAK);
            }
            if (!ad.getType().equals(TYPE.REMOVED)) {
              Object value=ad.getNewValue();
              sb.append(TextValueSerializer.asString(value));
              sb.append(LINE_BREAK);
            }
            diffDescriptors.remove(descriptor);
          }
 else {
            sb.append(""String_Node_Str"").append(descriptor.getName().toString()).append(LINE_BREAK);
            sb.append(TextValueSerializer.asString(values.get(idx))).append(LINE_BREAK);
          }
          idx++;
        }
        for (        PropertyDescriptor descriptor : diffDescriptors) {
          AttributeDiff ad=diffs.get(descriptor);
          sb.append(ad.getType().toString().charAt(0) + ""String_Node_Str"" + descriptor.getName().toString()+ LINE_BREAK);
          if (!ad.getType().equals(TYPE.ADDED)) {
            Object value=ad.getOldValue();
            sb.append(TextValueSerializer.asString(value));
            sb.append(LINE_BREAK);
          }
          if (!ad.getType().equals(TYPE.REMOVED)) {
            Object value=ad.getNewValue();
            sb.append(TextValueSerializer.asString(value));
            sb.append(LINE_BREAK);
          }
        }
      }
 else {
        NodeRef noderef=diffEntry.changeType() == ChangeType.ADDED ? diffEntry.getNewObject() : diffEntry.getOldObject();
        RevFeatureType featureType=geogig.command(RevObjectParse.class).setObjectId(noderef.getMetadataId()).call(RevFeatureType.class).get();
        Optional<RevObject> obj=geogig.command(RevObjectParse.class).setObjectId(noderef.getObjectId()).call();
        RevFeature feature=(RevFeature)obj.get();
        ImmutableList<Optional<Object>> values=feature.getValues();
        int i=0;
        for (        Optional<Object> value : values) {
          sb.append(diffEntry.changeType().toString().charAt(0));
          sb.append(' ');
          sb.append(featureType.sortedDescriptors().get(i).getName().toString());
          sb.append(LINE_BREAK);
          sb.append(TextValueSerializer.asString(value));
          sb.append(LINE_BREAK);
          i++;
        }
        sb.append(LINE_BREAK);
      }
      sb.append(LINE_BREAK);
      cli.getConsole().println(sb.toString());
    }
 else     if (treeStats) {
      String parent=NodeRef.parentPath(path);
      if (!stats.containsKey(parent)) {
        stats.put(parent,new Long[]{0l,0l,0l});
      }
      Long[] counts=stats.get(parent);
      if (diffEntry.changeType() == ChangeType.ADDED) {
        counts[0]++;
      }
 else       if (diffEntry.changeType() == ChangeType.REMOVED) {
        counts[1]++;
      }
 else       if (diffEntry.changeType() == ChangeType.MODIFIED) {
        counts[2]++;
      }
    }
 else {
      sb.append(path).append(' ');
      sb.append(diffEntry.oldObjectId().toString());
      sb.append(' ');
      sb.append(diffEntry.newObjectId().toString());
      cli.getConsole().println(sb.toString());
    }
  }
  if (treeStats) {
    for (    String path : stats.keySet()) {
      StringBuffer sb=new StringBuffer();
      sb.append(path);
      Long[] counts=stats.get(path);
      for (int i=0; i < counts.length; i++) {
        sb.append(""String_Node_Str"" + counts[i].toString());
      }
      cli.getConsole().println(sb.toString());
    }
  }
}",0.9898186446070634
113281,"@Given(""String_Node_Str"") public void I_have_a_patch_file() throws Throwable {
  Patch patch=new Patch();
  String path=NodeRef.appendChild(pointsName,points1.getIdentifier().getID());
  Map<PropertyDescriptor,AttributeDiff> map=Maps.newHashMap();
  Optional<?> oldValue=Optional.fromNullable(points1.getProperty(""String_Node_Str"").getValue());
  GenericAttributeDiffImpl diff=new GenericAttributeDiffImpl(oldValue,Optional.of(""String_Node_Str""));
  map.put(pointsType.getDescriptor(""String_Node_Str""),diff);
  FeatureDiff feaureDiff=new FeatureDiff(path,map,RevFeatureTypeImpl.build(pointsType),RevFeatureTypeImpl.build(pointsType));
  patch.addModifiedFeature(feaureDiff);
  File file=new File(localRepo.platform.pwd(),""String_Node_Str"");
  BufferedWriter writer=Files.newWriter(file,Charsets.UTF_8);
  PatchSerializer.write(writer,patch);
  writer.flush();
  writer.close();
}","@Given(""String_Node_Str"") public void I_have_a_patch_file() throws Throwable {
  Patch patch=new Patch();
  String path=NodeRef.appendChild(pointsName,points1.getIdentifier().getID());
  Map<PropertyDescriptor,AttributeDiff> map=Maps.newHashMap();
  Object oldValue=points1.getProperty(""String_Node_Str"").getValue();
  GenericAttributeDiffImpl diff=new GenericAttributeDiffImpl(oldValue,""String_Node_Str"");
  map.put(pointsType.getDescriptor(""String_Node_Str""),diff);
  FeatureDiff feaureDiff=new FeatureDiff(path,map,RevFeatureTypeImpl.build(pointsType),RevFeatureTypeImpl.build(pointsType));
  patch.addModifiedFeature(feaureDiff);
  File file=new File(localRepo.platform.pwd(),""String_Node_Str"");
  BufferedWriter writer=Files.newWriter(file,Charsets.UTF_8);
  PatchSerializer.write(writer,patch);
  writer.flush();
  writer.close();
}",0.9376820034944672
113282,"/** 
 * applies the difference on the passed object, if possible.
 * @param obj the object representing the original (old) state of the attribute. If the value isnull, it represents that the attribute did not exist previously
 */
public Optional<?> applyOn(Optional<?> obj);","/** 
 * applies the difference on the passed object, if possible.
 * @param value the object representing the original (old) state of the attribute. If the valueis null, it represents that the attribute did not exist previously
 */
@Nullable public Object applyOn(@Nullable Object value);",0.8683274021352313
113283,"/** 
 * Returns true if the diff can be applied on the passed value. Return false if the passed value does not represent the old state represented by this attribute difference
 * @param obj the object representing the original (old) state of the attribute. If the value isnull, it represents that the attribute did not exist previously
 * @return true if the diff can be applied to the passed object
 */
public boolean canBeAppliedOn(Optional<?> obj);","/** 
 * Returns true if the diff can be applied on the passed value. Return false if the passed value does not represent the old state represented by this attribute difference
 * @param value the object representing the original (old) state of the attribute. If the valueis null, it represents that the attribute did not exist previously
 * @return true if the diff can be applied to the passed object
 */
public boolean canBeAppliedOn(@Nullable Object value);",0.9396267837541163
113284,"/** 
 * accessor for the old value
 */
public Optional<?> getOldValue();","/** 
 * accessor for the old value
 */
@Nullable public Object getOldValue();",0.8456375838926175
113285,"/** 
 * accessor for the new value
 */
public Optional<?> getNewValue();","/** 
 * accessor for the new value
 */
@Nullable public Object getNewValue();",0.8456375838926175
113286,"public static AttributeDiff attributeDiffFromText(Class<?> clazz,String s){
  String[] tokens=s.split(""String_Node_Str"");
  AttributeDiff ad;
  if (Geometry.class.isAssignableFrom(clazz)) {
    ad=new GeometryAttributeDiff(s);
  }
 else {
    if (AttributeDiff.TYPE.REMOVED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 2,""String_Node_Str"",s);
      Object oldValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      ad=new GenericAttributeDiffImpl(Optional.fromNullable(oldValue),null);
    }
 else     if (AttributeDiff.TYPE.ADDED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 2,""String_Node_Str"",s);
      Object newValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      ad=new GenericAttributeDiffImpl(null,Optional.fromNullable(newValue));
    }
 else     if (AttributeDiff.TYPE.MODIFIED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 3,""String_Node_Str"",s);
      Object oldValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      Object newValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[2]);
      ad=new GenericAttributeDiffImpl(Optional.fromNullable(oldValue),Optional.fromNullable(newValue));
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return ad;
}","public static AttributeDiff attributeDiffFromText(Class<?> clazz,String s){
  String[] tokens=s.split(""String_Node_Str"");
  AttributeDiff ad;
  if (Geometry.class.isAssignableFrom(clazz)) {
    ad=new GeometryAttributeDiff(s);
  }
 else {
    if (AttributeDiff.TYPE.REMOVED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 2,""String_Node_Str"",s);
      Object oldValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      ad=new GenericAttributeDiffImpl(oldValue,null);
    }
 else     if (AttributeDiff.TYPE.ADDED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 2,""String_Node_Str"",s);
      Object newValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      ad=new GenericAttributeDiffImpl(null,newValue);
    }
 else     if (AttributeDiff.TYPE.MODIFIED.name().startsWith(tokens[0])) {
      Preconditions.checkArgument(tokens.length == 3,""String_Node_Str"",s);
      Object oldValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[1]);
      Object newValue=TextValueSerializer.fromString(FieldType.forBinding(clazz),tokens[2]);
      ad=new GenericAttributeDiffImpl(oldValue,newValue);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return ad;
}",0.9665454545454546
113287,"/** 
 * @param path the full path to the feature, including its name
 * @param newRevFeature the new version of the feature
 * @param oldRevFeature the old version of the feature
 * @param newRevFeatureType the new version of the feature type
 * @param oldRevFeatureType the old version of the feature type
 * @param all - true if all attributes should be added regardless of change
 */
public FeatureDiff(String path,@Nullable RevFeature newRevFeature,@Nullable RevFeature oldRevFeature,@Nullable RevFeatureType newRevFeatureType,@Nullable RevFeatureType oldRevFeatureType,boolean all){
  this.path=path;
  this.newFeatureType=newRevFeatureType;
  this.oldFeatureType=oldRevFeatureType;
  diffs=new HashMap<PropertyDescriptor,AttributeDiff>();
  if (newRevFeature == null) {
    Preconditions.checkArgument(oldRevFeature != null,""String_Node_Str"");
    Preconditions.checkArgument(oldRevFeatureType != null,""String_Node_Str"");
    ImmutableList<PropertyDescriptor> oldAttributes=oldRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> oldValues=oldRevFeature.getValues();
    for (int i=0; i < oldAttributes.size(); i++) {
      Optional<Object> oldValue=oldValues.get(i);
      PropertyDescriptor descriptor=oldAttributes.get(i);
      if (Geometry.class.isAssignableFrom(descriptor.getType().getBinding())) {
        diffs.put(descriptor,new GeometryAttributeDiff(Optional.fromNullable((Geometry)oldValue.orNull()),Optional.absent()));
      }
 else {
        diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue,null));
      }
    }
  }
 else   if (oldRevFeature == null) {
    Preconditions.checkArgument(newRevFeatureType != null,""String_Node_Str"");
    ImmutableList<PropertyDescriptor> newAttributes=newRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> newValues=newRevFeature.getValues();
    for (int i=0; i < newAttributes.size(); i++) {
      Optional<Object> newValue=newValues.get(i);
      PropertyDescriptor descriptor=newAttributes.get(i);
      if (Geometry.class.isAssignableFrom(descriptor.getType().getBinding())) {
        diffs.put(descriptor,new GeometryAttributeDiff(Optional.absent(),Optional.fromNullable((Geometry)newValue.orNull())));
      }
 else {
        diffs.put(newAttributes.get(i),new GenericAttributeDiffImpl(null,newValue));
      }
    }
  }
 else {
    ImmutableList<PropertyDescriptor> oldAttributes=oldRevFeatureType.sortedDescriptors();
    ImmutableList<PropertyDescriptor> newAttributes=newRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> oldValues=oldRevFeature.getValues();
    ImmutableList<Optional<Object>> newValues=newRevFeature.getValues();
    BitSet updatedAttributes=new BitSet(newValues.size());
    for (int i=0; i < oldAttributes.size(); i++) {
      Optional<Object> oldValue=oldValues.get(i);
      int idx=newAttributes.indexOf(oldAttributes.get(i));
      if (idx != -1) {
        Optional<Object> newValue=newValues.get(idx);
        if (!oldValue.equals(newValue) || all) {
          if (Geometry.class.isAssignableFrom(oldAttributes.get(i).getType().getBinding())) {
            diffs.put(oldAttributes.get(i),new GeometryAttributeDiff(Optional.fromNullable((Geometry)oldValue.orNull()),Optional.fromNullable((Geometry)newValue.orNull())));
          }
 else {
            diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue,newValue));
          }
        }
        updatedAttributes.set(idx);
      }
 else {
        if (Geometry.class.isAssignableFrom(oldAttributes.get(i).getType().getBinding())) {
          diffs.put(oldAttributes.get(i),new GeometryAttributeDiff(Optional.fromNullable((Geometry)oldValue.orNull()),Optional.fromNullable((Geometry)null)));
        }
 else {
          diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue,null));
        }
      }
    }
    updatedAttributes.flip(0,newValues.size());
    for (int i=updatedAttributes.nextSetBit(0); i >= 0; i=updatedAttributes.nextSetBit(i + 1)) {
      if (Geometry.class.isAssignableFrom(newAttributes.get(i).getType().getBinding())) {
        diffs.put(newAttributes.get(i),new GeometryAttributeDiff(Optional.fromNullable((Geometry)null),Optional.fromNullable((Geometry)newValues.get(i).orNull())));
      }
 else {
        diffs.put(newAttributes.get(i),new GenericAttributeDiffImpl(null,newValues.get(i)));
      }
    }
  }
}","/** 
 * @param path the full path to the feature, including its name
 * @param newRevFeature the new version of the feature
 * @param oldRevFeature the old version of the feature
 * @param newRevFeatureType the new version of the feature type
 * @param oldRevFeatureType the old version of the feature type
 * @param all - true if all attributes should be added regardless of change
 */
public FeatureDiff(String path,@Nullable RevFeature newRevFeature,@Nullable RevFeature oldRevFeature,@Nullable RevFeatureType newRevFeatureType,@Nullable RevFeatureType oldRevFeatureType,boolean all){
  this.path=path;
  this.newFeatureType=newRevFeatureType;
  this.oldFeatureType=oldRevFeatureType;
  diffs=new HashMap<PropertyDescriptor,AttributeDiff>();
  if (newRevFeature == null) {
    Preconditions.checkArgument(oldRevFeature != null,""String_Node_Str"");
    Preconditions.checkArgument(oldRevFeatureType != null,""String_Node_Str"");
    ImmutableList<PropertyDescriptor> oldAttributes=oldRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> oldValues=oldRevFeature.getValues();
    for (int i=0; i < oldAttributes.size(); i++) {
      Optional<Object> oldValue=oldValues.get(i);
      PropertyDescriptor descriptor=oldAttributes.get(i);
      if (Geometry.class.isAssignableFrom(descriptor.getType().getBinding())) {
        diffs.put(descriptor,new GeometryAttributeDiff((Geometry)oldValue.orNull(),(Geometry)null));
      }
 else {
        diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue.orNull(),null));
      }
    }
  }
 else   if (oldRevFeature == null) {
    Preconditions.checkArgument(newRevFeatureType != null,""String_Node_Str"");
    ImmutableList<PropertyDescriptor> newAttributes=newRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> newValues=newRevFeature.getValues();
    for (int i=0; i < newAttributes.size(); i++) {
      Optional<Object> newValue=newValues.get(i);
      PropertyDescriptor descriptor=newAttributes.get(i);
      if (Geometry.class.isAssignableFrom(descriptor.getType().getBinding())) {
        diffs.put(descriptor,new GeometryAttributeDiff((Geometry)null,(Geometry)newValue.orNull()));
      }
 else {
        diffs.put(newAttributes.get(i),new GenericAttributeDiffImpl(null,newValue.orNull()));
      }
    }
  }
 else {
    ImmutableList<PropertyDescriptor> oldAttributes=oldRevFeatureType.sortedDescriptors();
    ImmutableList<PropertyDescriptor> newAttributes=newRevFeatureType.sortedDescriptors();
    ImmutableList<Optional<Object>> oldValues=oldRevFeature.getValues();
    ImmutableList<Optional<Object>> newValues=newRevFeature.getValues();
    BitSet updatedAttributes=new BitSet(newValues.size());
    for (int i=0; i < oldAttributes.size(); i++) {
      Optional<Object> oldValue=oldValues.get(i);
      int idx=newAttributes.indexOf(oldAttributes.get(i));
      if (idx != -1) {
        Optional<Object> newValue=newValues.get(idx);
        if (!oldValue.equals(newValue) || all) {
          if (Geometry.class.isAssignableFrom(oldAttributes.get(i).getType().getBinding())) {
            diffs.put(oldAttributes.get(i),new GeometryAttributeDiff((Geometry)oldValue.orNull(),(Geometry)newValue.orNull()));
          }
 else {
            diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue.orNull(),newValue.orNull()));
          }
        }
        updatedAttributes.set(idx);
      }
 else {
        if (Geometry.class.isAssignableFrom(oldAttributes.get(i).getType().getBinding())) {
          diffs.put(oldAttributes.get(i),new GeometryAttributeDiff((Geometry)oldValue.orNull(),(Geometry)null));
        }
 else {
          diffs.put(oldAttributes.get(i),new GenericAttributeDiffImpl(oldValue.orNull(),null));
        }
      }
    }
    updatedAttributes.flip(0,newValues.size());
    for (int i=updatedAttributes.nextSetBit(0); i >= 0; i=updatedAttributes.nextSetBit(i + 1)) {
      PropertyDescriptor descriptor=newAttributes.get(i);
      if (Geometry.class.isAssignableFrom(descriptor.getType().getBinding())) {
        diffs.put(descriptor,new GeometryAttributeDiff((Geometry)null,(Geometry)newValues.get(i).orNull()));
      }
 else {
        diffs.put(descriptor,new GenericAttributeDiffImpl(null,newValues.get(i).orNull()));
      }
    }
  }
}",0.7831909489725236
113288,"public GenericAttributeDiffImpl(@Nullable Optional<?> oldValue,@Nullable Optional<?> newValue){
  if (oldValue == null) {
    this.oldValue=Optional.absent();
  }
 else {
    this.oldValue=oldValue;
  }
  if (newValue == null) {
    this.newValue=Optional.absent();
  }
 else {
    this.newValue=newValue;
  }
}","/** 
 * @param oldValue The new value. {@code null} if it does not exist (the attribute has beenremoved)
 * @param newValue The old value. {@code null} if it did not exist (the attribute has beenadded)
 */
public GenericAttributeDiffImpl(@Nullable Object oldValue,@Nullable Object newValue){
  checkArgument(!(oldValue instanceof Optional));
  checkArgument(!(newValue instanceof Optional));
  this.oldValue=oldValue;
  this.newValue=newValue;
}",0.2195767195767195
113289,"@Override public TYPE getType(){
  TYPE type;
  if (!oldValue.isPresent() && !newValue.isPresent()) {
    type=TYPE.NO_CHANGE;
  }
 else   if (!newValue.isPresent()) {
    type=TYPE.REMOVED;
  }
 else   if (!oldValue.isPresent()) {
    type=TYPE.ADDED;
  }
 else   if (oldValue.equals(newValue)) {
    type=TYPE.NO_CHANGE;
  }
 else {
    type=TYPE.MODIFIED;
  }
  return type;
}","@Override public TYPE getType(){
  TYPE type;
  if (java.util.Objects.equals(oldValue,newValue)) {
    type=TYPE.NO_CHANGE;
  }
 else   if (null == newValue) {
    type=TYPE.REMOVED;
  }
 else   if (null == oldValue) {
    type=TYPE.ADDED;
  }
 else {
    type=TYPE.MODIFIED;
  }
  return type;
}",0.7525925925925926
113290,"@Override public Optional<?> applyOn(Optional<?> obj){
  Preconditions.checkState(canBeAppliedOn(obj));
  return newValue;
}","@Override public Object applyOn(@Nullable Object obj){
  Preconditions.checkState(canBeAppliedOn(obj));
  return newValue;
}",0.8548387096774194
113291,"@Override public boolean canBeAppliedOn(Optional<?> obj){
  if (obj == null) {
    obj=Optional.absent();
  }
  return obj.equals(oldValue) || obj.equals(newValue);
}","@Override public boolean canBeAppliedOn(@Nullable Object obj){
  checkArgument(!(obj instanceof Optional));
  return Objects.equal(obj,oldValue) || Objects.equal(obj,newValue);
}",0.6976744186046512
113292,"@Override public Optional<?> getOldValue(){
  return oldValue;
}","@Override public Object getOldValue(){
  return oldValue;
}",0.8943089430894309
113293,"@Override public Optional<?> getNewValue(){
  return newValue;
}","@Override public Object getNewValue(){
  return newValue;
}",0.8943089430894309
113294,"private CharSequence attributeValueAsString(Optional<?> value){
  if (value.isPresent()) {
    return TextValueSerializer.asString(Optional.fromNullable((Object)value.get()));
  }
 else {
    return ""String_Node_Str"";
  }
}","private CharSequence attributeValueAsString(@Nullable Object value){
  if (null == value) {
    return ""String_Node_Str"";
  }
  return TextValueSerializer.asString(value);
}",0.601010101010101
113295,"public void printFormatted(GeogigCLI cli) throws IOException {
  Console console=cli.getConsole();
  GeoGIG geogig=cli.getGeogig();
  for (  String ref : refs) {
    Optional<RevObject> obj=geogig.command(RevObjectParse.class).setRefSpec(ref).call();
    if (!obj.isPresent()) {
      ref=getFullRef(ref);
      obj=geogig.command(RevObjectParse.class).setRefSpec(ref).call();
    }
    checkParameter(obj.isPresent(),""String_Node_Str"");
    RevObject revObject=obj.get();
    if (revObject instanceof RevFeature) {
      Optional<RevFeatureType> opt=geogig.command(ResolveFeatureType.class).setRefSpec(ref).call();
      if (opt.isPresent()) {
        RevFeatureType ft=opt.get();
        ImmutableList<PropertyDescriptor> attribs=ft.sortedDescriptors();
        RevFeature feature=(RevFeature)revObject;
        Ansi ansi=super.newAnsi(console);
        ansi.newline().fg(Color.YELLOW).a(""String_Node_Str"").reset().a(feature.getId().toString()).newline();
        ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(ft.getId().toString()).newline().newline();
        ansi.a(""String_Node_Str"").newline();
        ansi.a(""String_Node_Str"").newline();
        ImmutableList<Optional<Object>> values=feature.getValues();
        int i=0;
        for (        Optional<Object> value : values) {
          ansi.fg(Color.YELLOW).a(attribs.get(i).getName() + ""String_Node_Str"").reset();
          ansi.a(value.or(""String_Node_Str"").toString()).newline();
          i++;
        }
        console.println(ansi.toString());
      }
 else {
        CharSequence s=geogig.command(CatObject.class).setObject(Suppliers.ofInstance(revObject)).call();
        console.println(s);
      }
    }
 else     if (revObject instanceof RevTree) {
      RevTree tree=(RevTree)revObject;
      Optional<RevFeatureType> opt=geogig.command(ResolveFeatureType.class).setRefSpec(ref).call();
      checkParameter(opt.isPresent(),""String_Node_Str"");
      RevFeatureType ft=opt.get();
      Ansi ansi=super.newAnsi(console);
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(tree.getId().toString()).newline();
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(Long.toString(tree.size())).newline();
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(Integer.toString(tree.numTrees()).toString()).newline();
      printFeatureType(ansi,ft,true);
      console.println(ansi.toString());
    }
 else     if (revObject instanceof RevCommit) {
      RevCommit commit=(RevCommit)revObject;
      Ansi ansi=super.newAnsi(console);
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.YELLOW).a(commit.getId().toString()).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.GREEN).a(formatPerson(commit.getAuthor())).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.GREEN).a(formatPerson(commit.getAuthor())).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(""String_Node_Str"").fg(Color.RED).a(estimateSince(geogig.getPlatform(),commit.getAuthor().getTimestamp())).reset().a(""String_Node_Str"").a(new Date(commit.getAuthor().getTimestamp())).newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(""String_Node_Str"").fg(Color.RED).a(estimateSince(geogig.getPlatform(),commit.getCommitter().getTimestamp())).reset().a(""String_Node_Str"").a(new Date(commit.getCommitter().getTimestamp())).newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(commit.getMessage()).newline();
      console.println(ansi.toString());
    }
 else     if (revObject instanceof RevFeatureType) {
      Ansi ansi=super.newAnsi(console);
      printFeatureType(ansi,(RevFeatureType)revObject,false);
      console.println(ansi.toString());
    }
 else {
      throw new InvalidParameterException(""String_Node_Str"");
    }
    console.println();
  }
}","public void printFormatted(GeogigCLI cli) throws IOException {
  Console console=cli.getConsole();
  GeoGIG geogig=cli.getGeogig();
  for (  String ref : refs) {
    Optional<RevObject> obj=geogig.command(RevObjectParse.class).setRefSpec(ref).call();
    if (!obj.isPresent()) {
      ref=getFullRef(ref);
      obj=geogig.command(RevObjectParse.class).setRefSpec(ref).call();
    }
    checkParameter(obj.isPresent(),""String_Node_Str"");
    RevObject revObject=obj.get();
    if (revObject instanceof RevFeature) {
      Optional<RevFeatureType> opt=geogig.command(ResolveFeatureType.class).setRefSpec(ref).call();
      if (opt.isPresent()) {
        RevFeatureType ft=opt.get();
        ImmutableList<PropertyDescriptor> attribs=ft.sortedDescriptors();
        RevFeature feature=(RevFeature)revObject;
        Ansi ansi=super.newAnsi(console);
        ansi.newline().fg(Color.YELLOW).a(""String_Node_Str"").reset().a(feature.getId().toString()).newline();
        ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(ft.getId().toString()).newline().newline();
        ansi.a(""String_Node_Str"").newline();
        ansi.a(""String_Node_Str"").newline();
        ImmutableList<Optional<Object>> values=feature.getValues();
        int i=0;
        for (        Optional<Object> value : values) {
          ansi.fg(Color.YELLOW).a(attribs.get(i).getName() + ""String_Node_Str"").reset();
          ansi.a(value.or(""String_Node_Str"").toString()).newline();
          i++;
        }
        console.println(ansi.toString());
      }
 else {
        CharSequence s=geogig.command(CatObject.class).setObject(Suppliers.ofInstance(revObject)).call();
        console.println(s);
      }
    }
 else     if (revObject instanceof RevTree) {
      RevTree tree=(RevTree)revObject;
      Optional<RevFeatureType> opt=geogig.command(ResolveFeatureType.class).setRefSpec(ref).call();
      checkParameter(opt.isPresent(),""String_Node_Str"");
      RevFeatureType ft=opt.get();
      Ansi ansi=super.newAnsi(console);
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(tree.getId().toString()).newline();
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(Long.toString(tree.size())).newline();
      ansi.fg(Color.YELLOW).a(""String_Node_Str"").reset().a(Integer.toString(tree.numTrees()).toString()).newline();
      printFeatureType(ansi,ft,true);
      console.println(ansi.toString());
    }
 else     if (revObject instanceof RevCommit) {
      RevCommit commit=(RevCommit)revObject;
      Ansi ansi=super.newAnsi(console);
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.YELLOW).a(commit.getId().toString()).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.GREEN).a(formatPerson(commit.getAuthor())).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).fg(Color.GREEN).a(formatPerson(commit.getCommitter())).reset().newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(""String_Node_Str"").fg(Color.RED).a(estimateSince(geogig.getPlatform(),commit.getAuthor().getTimestamp())).reset().a(""String_Node_Str"").a(new Date(commit.getAuthor().getTimestamp())).newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(""String_Node_Str"").fg(Color.RED).a(estimateSince(geogig.getPlatform(),commit.getCommitter().getTimestamp())).reset().a(""String_Node_Str"").a(new Date(commit.getCommitter().getTimestamp())).newline();
      ansi.a(Strings.padEnd(""String_Node_Str"",15,' ')).a(commit.getMessage()).newline();
      console.println(ansi.toString());
    }
 else     if (revObject instanceof RevFeatureType) {
      Ansi ansi=super.newAnsi(console);
      printFeatureType(ansi,(RevFeatureType)revObject,false);
      console.println(ansi.toString());
    }
 else {
      throw new InvalidParameterException(""String_Node_Str"");
    }
    console.println();
  }
}",0.9983092729873846
113296,"private RevCommit commit(boolean fastForward){
  RevCommit mergeCommit;
  if (fastForward) {
    mergeCommit=repository().getCommit(commits.get(0));
  }
 else {
    String commitMessage=message;
    if (commitMessage == null) {
      commitMessage=""String_Node_Str"";
      for (      ObjectId commit : commits) {
        Optional<Ref> ref=command(ResolveBranchId.class).setObjectId(commit).call();
        if (ref.isPresent()) {
          commitMessage+=""String_Node_Str"" + ref.get().getName();
        }
 else {
          commitMessage+=""String_Node_Str"" + commit.toString() + ""String_Node_Str"";
        }
      }
    }
    if (noCommit) {
      final Optional<Ref> currHead=command(RefParse.class).setName(Ref.HEAD).call();
      SymRef headRef=(SymRef)currHead.get();
      RevCommit headCommit=repository().getCommit(headRef.getObjectId());
      command(UpdateRef.class).setName(Ref.MERGE_HEAD).setNewValue(commits.get(0)).call();
      command(UpdateRef.class).setName(Ref.ORIG_HEAD).setNewValue(headCommit.getId()).call();
      mergeCommit=headCommit;
      command(SaveMergeCommitMessageOp.class).setMessage(commitMessage).call();
    }
 else {
      mergeCommit=command(CommitOp.class).setAllowEmpty(true).setMessage(commitMessage).addParents(commits).setAuthor(authorName.orNull(),authorEmail.orNull()).call();
    }
  }
  getProgressListener().complete();
  return mergeCommit;
}","private RevCommit commit(boolean fastForward){
  RevCommit mergeCommit;
  if (fastForward) {
    mergeCommit=repository().getCommit(commits.get(0));
  }
 else {
    String commitMessage=message;
    if (commitMessage == null) {
      commitMessage=""String_Node_Str"";
      for (      ObjectId commit : commits) {
        Optional<Ref> ref=command(ResolveBranchId.class).setObjectId(commit).call();
        if (ref.isPresent()) {
          commitMessage+=""String_Node_Str"" + ref.get().getName();
        }
 else {
          commitMessage+=""String_Node_Str"" + commit.toString() + ""String_Node_Str"";
        }
      }
    }
    if (noCommit) {
      final Optional<Ref> currHead=command(RefParse.class).setName(Ref.HEAD).call();
      SymRef headRef=(SymRef)currHead.get();
      RevCommit headCommit=repository().getCommit(headRef.getObjectId());
      command(UpdateRef.class).setName(Ref.MERGE_HEAD).setNewValue(commits.get(0)).call();
      command(UpdateRef.class).setName(Ref.ORIG_HEAD).setNewValue(headCommit.getId()).call();
      mergeCommit=headCommit;
      command(SaveMergeCommitMessageOp.class).setMessage(commitMessage).call();
    }
 else {
      CommitOp commit=command(CommitOp.class).setAllowEmpty(true).setMessage(commitMessage).addParents(commits);
      if (authorName.isPresent() || authorEmail.isPresent()) {
        commit.setAuthor(authorName.orNull(),authorEmail.orNull());
      }
      mergeCommit=commit.call();
    }
  }
  getProgressListener().complete();
  return mergeCommit;
}",0.9396343566747154
113297,"@Test public void testNoFastForward() throws Exception {
  insertAndAdd(points1);
  RevCommit masterCommit=geogig.command(CommitOp.class).call();
  geogig.command(BranchCreateOp.class).setName(""String_Node_Str"").call();
  geogig.command(CheckoutOp.class).setSource(""String_Node_Str"").call();
  insertAndAdd(points2);
  RevCommit branchCommit=geogig.command(CommitOp.class).call();
  geogig.command(CheckoutOp.class).setSource(""String_Node_Str"").call();
  Ref branch=geogig.command(RefParse.class).setName(""String_Node_Str"").call().get();
  MergeOp mergeOp=geogig.command(MergeOp.class).addCommit(Suppliers.ofInstance(branch.getObjectId()));
  mergeOp.setNoFastForward(true).call();
  Iterator<RevCommit> log=geogig.command(LogOp.class).call();
  RevCommit mergeCommit=log.next();
  assertEquals(2,mergeCommit.getParentIds().size());
  assertEquals(masterCommit.getId(),mergeCommit.getParentIds().get(0));
  assertEquals(branchCommit.getId(),mergeCommit.getParentIds().get(1));
}","@Test public void testNoFastForward() throws Exception {
  insertAndAdd(points1);
  RevCommit masterCommit=geogig.command(CommitOp.class).call();
  geogig.command(BranchCreateOp.class).setName(""String_Node_Str"").call();
  geogig.command(CheckoutOp.class).setSource(""String_Node_Str"").call();
  insertAndAdd(points2);
  RevCommit branchCommit=geogig.command(CommitOp.class).call();
  geogig.command(CheckoutOp.class).setSource(""String_Node_Str"").call();
  Ref branch=geogig.command(RefParse.class).setName(""String_Node_Str"").call().get();
  MergeOp mergeOp=geogig.command(MergeOp.class).addCommit(Suppliers.ofInstance(branch.getObjectId()));
  mergeOp.setNoFastForward(true).call();
  Iterator<RevCommit> log=geogig.command(LogOp.class).call();
  RevCommit mergeCommit=log.next();
  assertEquals(2,mergeCommit.getParentIds().size());
  assertEquals(masterCommit.getId(),mergeCommit.getParentIds().get(0));
  assertEquals(branchCommit.getId(),mergeCommit.getParentIds().get(1));
  assertEquals(COMMITTER_NAME,mergeCommit.getAuthor().getName().get());
  assertEquals(COMMITTER_EMAIL,mergeCommit.getAuthor().getEmail().get());
  assertEquals(COMMITTER_NAME,mergeCommit.getCommitter().getName().get());
  assertEquals(COMMITTER_EMAIL,mergeCommit.getCommitter().getEmail().get());
}",0.867790594498669
113298,"@Override protected void setUpInternal() throws Exception {
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(""String_Node_Str"").call();
}","@Override protected void setUpInternal() throws Exception {
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(COMMITTER_NAME).call();
  repo.command(ConfigOp.class).setAction(ConfigAction.CONFIG_SET).setName(""String_Node_Str"").setValue(COMMITTER_EMAIL).call();
}",0.9004739336492891
113299,"public static void createTables(final Environment config){
  DataSource ds=PGStorage.newDataSource(config);
  try {
    new DbOp<Void>(){
      @Override protected Void doRun(      final Connection cx) throws SQLException {
        DatabaseMetaData md=cx.getMetaData();
        final TableNames tables=config.getTables();
        final String reposTable=tables.repositories();
        final String schema=PGStorage.schema(reposTable);
        final String table=PGStorage.stripSchema(reposTable);
        try (ResultSet rs=md.getTables(null,schema,table,null)){
          if (rs.next()) {
            return null;
          }
        }
         cx.setAutoCommit(false);
        try {
          String sql=String.format(""String_Node_Str"",config.getDatabaseName());
          PGStorage.run(cx,sql);
          PGStorage.run(cx,""String_Node_Str"");
          createConfigTable(cx,tables);
          cx.commit();
          cx.setAutoCommit(false);
          createRefsTable(cx,tables);
          createConflictsTable(cx,tables);
          createBlobsTable(cx,tables);
          createObjectsTables(cx,tables);
          createGraphTables(cx,tables);
          cx.commit();
        }
 catch (        SQLException|RuntimeException e) {
          cx.rollback();
          Throwables.propagateIfInstanceOf(e,SQLException.class);
          throw Throwables.propagate(e);
        }
        return null;
      }
    }
.run(ds);
  }
  finally {
    PGStorage.closeDataSource(ds);
  }
}","public static void createTables(final Environment config){
  DataSource ds=PGStorage.newDataSource(config);
  try {
    new DbOp<Void>(){
      @Override protected Void doRun(      final Connection cx) throws SQLException {
        DatabaseMetaData md=cx.getMetaData();
        final TableNames tables=config.getTables();
        final String reposTable=tables.repositories();
        final String schema=PGStorage.schema(reposTable);
        final String table=PGStorage.stripSchema(reposTable);
        try (ResultSet rs=md.getTables(null,schema,table,null)){
          if (rs.next()) {
            return null;
          }
        }
         try {
          cx.setAutoCommit(true);
          PGStorage.run(cx,""String_Node_Str"");
          String sql=String.format(""String_Node_Str"",config.getDatabaseName());
          PGStorage.run(cx,sql);
          PGStorage.run(cx,""String_Node_Str"");
          cx.setAutoCommit(false);
          PGStorage.run(cx,""String_Node_Str"");
          createConfigTable(cx,tables);
          cx.commit();
          cx.setAutoCommit(false);
          createRefsTable(cx,tables);
          createConflictsTable(cx,tables);
          createBlobsTable(cx,tables);
          createObjectsTables(cx,tables);
          createGraphTables(cx,tables);
          cx.commit();
        }
 catch (        SQLException|RuntimeException e) {
          cx.rollback();
          Throwables.propagateIfInstanceOf(e,SQLException.class);
          throw Throwables.propagate(e);
        }
        return null;
      }
    }
.run(ds);
  }
  finally {
    PGStorage.closeDataSource(ds);
  }
}",0.9205729166666666
113300,"@Override protected Void doRun(final Connection cx) throws SQLException {
  DatabaseMetaData md=cx.getMetaData();
  final TableNames tables=config.getTables();
  final String reposTable=tables.repositories();
  final String schema=PGStorage.schema(reposTable);
  final String table=PGStorage.stripSchema(reposTable);
  try (ResultSet rs=md.getTables(null,schema,table,null)){
    if (rs.next()) {
      return null;
    }
  }
   cx.setAutoCommit(false);
  try {
    String sql=String.format(""String_Node_Str"",config.getDatabaseName());
    PGStorage.run(cx,sql);
    PGStorage.run(cx,""String_Node_Str"");
    createConfigTable(cx,tables);
    cx.commit();
    cx.setAutoCommit(false);
    createRefsTable(cx,tables);
    createConflictsTable(cx,tables);
    createBlobsTable(cx,tables);
    createObjectsTables(cx,tables);
    createGraphTables(cx,tables);
    cx.commit();
  }
 catch (  SQLException|RuntimeException e) {
    cx.rollback();
    Throwables.propagateIfInstanceOf(e,SQLException.class);
    throw Throwables.propagate(e);
  }
  return null;
}","@Override protected Void doRun(final Connection cx) throws SQLException {
  DatabaseMetaData md=cx.getMetaData();
  final TableNames tables=config.getTables();
  final String reposTable=tables.repositories();
  final String schema=PGStorage.schema(reposTable);
  final String table=PGStorage.stripSchema(reposTable);
  try (ResultSet rs=md.getTables(null,schema,table,null)){
    if (rs.next()) {
      return null;
    }
  }
   try {
    cx.setAutoCommit(true);
    PGStorage.run(cx,""String_Node_Str"");
    String sql=String.format(""String_Node_Str"",config.getDatabaseName());
    PGStorage.run(cx,sql);
    PGStorage.run(cx,""String_Node_Str"");
    cx.setAutoCommit(false);
    PGStorage.run(cx,""String_Node_Str"");
    createConfigTable(cx,tables);
    cx.commit();
    cx.setAutoCommit(false);
    createRefsTable(cx,tables);
    createConflictsTable(cx,tables);
    createBlobsTable(cx,tables);
    createObjectsTables(cx,tables);
    createGraphTables(cx,tables);
    cx.commit();
  }
 catch (  SQLException|RuntimeException e) {
    cx.rollback();
    Throwables.propagateIfInstanceOf(e,SQLException.class);
    throw Throwables.propagate(e);
  }
  return null;
}",0.9091726618705036
113301,"/** 
 * Encodes a value using the variable-length encoding from <a href=""http://code.google.com/apis/protocolbuffers/docs/encoding.html""> Google Protocol Buffers</a>. Zig-zag is not used, so input must not be negative. If values can be negative, use   {@link #writeSignedVarLong(long,DataOutput)} instead. This method treats negative inputas like a large unsigned value.
 * @param value value to encode
 * @param out to write bytes to
 * @throws IOException if {@link DataOutput} throws {@link IOException}
 */
public static void writeUnsignedVarLong(long value,DataOutput out) throws IOException {
  byte[] buff=new byte[9];
  int cnt=0;
  while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {
    buff[cnt++]=(byte)(((int)value & 0x7F) | 0x80);
    value>>>=7;
  }
  buff[cnt++]=(byte)((int)value & 0x7F);
  out.write(buff,0,cnt);
}","/** 
 * Encodes a value using the variable-length encoding from <a href=""http://code.google.com/apis/protocolbuffers/docs/encoding.html""> Google Protocol Buffers</a>. Zig-zag is not used, so input must not be negative. If values can be negative, use   {@link #writeSignedVarLong(long,DataOutput)} instead. This method treats negative inputas like a large unsigned value.
 * @param value value to encode
 * @param out to write bytes to
 * @throws IOException if {@link DataOutput} throws {@link IOException}
 */
public static void writeUnsignedVarLong(long value,DataOutput out) throws IOException {
  byte[] buff=new byte[10];
  int cnt=0;
  while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {
    buff[cnt++]=(byte)(((int)value & 0x7F) | 0x80);
    value>>>=7;
  }
  buff[cnt++]=(byte)((int)value & 0x7F);
  out.write(buff,0,cnt);
}",0.998185117967332
113302,"/** 
 * Constructs the transaction with the given ID and Injector.
 * @param context the non transactional command locator
 * @param transactionId the id of the transaction
 */
public GeogigTransaction(Context context,UUID transactionId){
  Preconditions.checkArgument(!(context instanceof GeogigTransaction));
  this.context=context;
  this.transactionId=transactionId;
  transactionIndex=new TransactionStagingArea(new Index(this),transactionId);
  transactionWorkTree=new WorkingTree(this);
  transactionRefDatabase=new TransactionRefDatabase(context.refDatabase(),transactionId);
}","/** 
 * Constructs the transaction with the given ID and Injector.
 * @param context the non transactional command locator
 * @param transactionId the id of the transaction
 */
public GeogigTransaction(Context context,UUID transactionId){
  Preconditions.checkArgument(!(context instanceof GeogigTransaction));
  this.context=context;
  this.transactionId=transactionId;
  transactionIndex=new TransactionStagingArea(new Index(this),transactionId);
  transactionWorkTree=new WorkingTree(this);
  transactionRefDatabase=new TransactionRefDatabase(context.refDatabase(),transactionId);
  transactionBlobStore=new TransactionBlobStoreImpl((TransactionBlobStore)context.blobStore(),transactionId);
}",0.9140625
113303,"public void create(){
  transactionBlobStore=new TransactionBlobStoreImpl((TransactionBlobStore)context.blobStore(),transactionId);
  transactionRefDatabase.create();
}","public void create(){
  transactionRefDatabase.create();
}",0.5132743362831859
113304,"@Override @Nullable public Optional<Feature> apply(@Nullable Feature feature){
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
  for (  Property property : feature.getProperties()) {
    if (property instanceof GeometryAttribute) {
      builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
    }
 else {
      builder.set(property.getName(),property.getValue());
    }
  }
  Feature modifiedFeature=builder.buildFeature(feature.getIdentifier().getID());
  return Optional.fromNullable(modifiedFeature);
}","@Override @Nullable public Optional<Feature> apply(@Nullable Feature feature){
  SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
  for (  Property property : feature.getProperties()) {
    if (property instanceof GeometryAttribute) {
      builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
    }
 else {
      String name=property.getName().getLocalPart();
      if (name.length() > 10) {
        name=name.substring(0,10);
      }
      builder.set(name,property.getValue());
    }
  }
  Feature modifiedFeature=builder.buildFeature(feature.getIdentifier().getID());
  return Optional.fromNullable(modifiedFeature);
}",0.8870703764320785
113305,"private Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=new Function<Feature,Optional<Feature>>(){
    @Override @Nullable public Optional<Feature> apply(    @Nullable Feature feature){
      SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
      for (      Property property : feature.getProperties()) {
        if (property instanceof GeometryAttribute) {
          builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
        }
 else {
          builder.set(property.getName(),property.getValue());
        }
      }
      Feature modifiedFeature=builder.buildFeature(feature.getIdentifier().getID());
      return Optional.fromNullable(modifiedFeature);
    }
  }
;
  return function;
}","private Function<Feature,Optional<Feature>> getTransformingFunction(final SimpleFeatureType featureType){
  Function<Feature,Optional<Feature>> function=new Function<Feature,Optional<Feature>>(){
    @Override @Nullable public Optional<Feature> apply(    @Nullable Feature feature){
      SimpleFeatureBuilder builder=new SimpleFeatureBuilder(featureType);
      for (      Property property : feature.getProperties()) {
        if (property instanceof GeometryAttribute) {
          builder.set(featureType.getGeometryDescriptor().getName(),property.getValue());
        }
 else {
          String name=property.getName().getLocalPart();
          if (name.length() > 10) {
            name=name.substring(0,10);
          }
          builder.set(name,property.getValue());
        }
      }
      Feature modifiedFeature=builder.buildFeature(feature.getIdentifier().getID());
      return Optional.fromNullable(modifiedFeature);
    }
  }
;
  return function;
}",0.8964365256124721
113306,"public DiffTree setCustomFilter(Predicate<Bounded> customFilter){
  this.customFilter=customFilter;
  return this;
}","public DiffTree setCustomFilter(@Nullable Predicate<Bounded> customFilter){
  this.customFilter=customFilter;
  return this;
}",0.9586776859504132
113307,"@Override public void run(){
  Consumer consumer=diffProducer;
  if (customFilter != null) {
    consumer=new DiffTreeVisitor.FilteringConsumer(consumer,customFilter);
  }
  if (changeTypeFilter != null) {
    consumer=new ChangeTypeFilteringDiffConsumer(changeTypeFilter,consumer);
  }
  if (boundsFilter != null) {
    consumer=new BoundsFilteringDiffConsumer(boundsFilter,consumer,stagingDatabase());
  }
  if (!pathFilters.isEmpty()) {
    consumer=new PathFilteringDiffConsumer(pathFilters,consumer);
  }
  try {
    visitor.walk(consumer);
  }
 catch (  RuntimeException e) {
    LOGGER.error(""String_Node_Str"",e);
    producerErrors.add(e);
    diffProducer.finished=true;
  }
}","@Override public void run(){
  Consumer consumer=diffProducer;
  if (customFilter != null) {
    consumer=new DiffTreeVisitor.FilteringConsumer(consumer,customFilter);
  }
  if (changeTypeFilter != null) {
    consumer=new ChangeTypeFilteringDiffConsumer(changeTypeFilter,consumer);
  }
  if (boundsFilter != null) {
    consumer=new BoundsFilteringDiffConsumer(boundsFilter,consumer,stagingDatabase());
  }
  if (!pathFilters.isEmpty()) {
    consumer=new PathFilteringDiffConsumer(pathFilters,consumer);
  }
  try {
    visitor.walk(consumer);
  }
 catch (  RuntimeException e) {
    LOGGER.error(""String_Node_Str"",e);
    producerErrors.add(e);
  }
 finally {
    diffProducer.finished=true;
  }
}",0.9891696750902528
113308,"/** 
 * Finds differences between the two specified trees.
 * @return an iterator to a set of differences between the two trees
 * @see DiffEntry
 */
@Override protected Iterator<DiffEntry> _call() throws IllegalArgumentException {
  checkNotNull(oldRefSpec,""String_Node_Str"");
  checkNotNull(newRefSpec,""String_Node_Str"");
  final RevTree oldTree=resolveTree(oldRefSpec);
  final RevTree newTree=resolveTree(newRefSpec);
  if (oldTree.equals(newTree)) {
    return Iterators.emptyIterator();
  }
  ObjectDatabase leftSource=resolveSource(oldTree.getId());
  ObjectDatabase rightSource=resolveSource(newTree.getId());
  final DiffTreeVisitor visitor=new DiffTreeVisitor(oldTree,newTree,leftSource,rightSource);
  final BlockingQueue<DiffEntry> queue=new ArrayBlockingQueue<>(100);
  final DiffEntryProducer diffProducer=new DiffEntryProducer(queue);
  diffProducer.setReportTrees(this.reportTrees);
  diffProducer.setRecursive(this.recursive);
  final List<RuntimeException> producerErrors=new LinkedList<>();
  Thread producerThread=new Thread(){
    @Override public void run(){
      Consumer consumer=diffProducer;
      if (customFilter != null) {
        consumer=new DiffTreeVisitor.FilteringConsumer(consumer,customFilter);
      }
      if (changeTypeFilter != null) {
        consumer=new ChangeTypeFilteringDiffConsumer(changeTypeFilter,consumer);
      }
      if (boundsFilter != null) {
        consumer=new BoundsFilteringDiffConsumer(boundsFilter,consumer,stagingDatabase());
      }
      if (!pathFilters.isEmpty()) {
        consumer=new PathFilteringDiffConsumer(pathFilters,consumer);
      }
      try {
        visitor.walk(consumer);
      }
 catch (      RuntimeException e) {
        LOGGER.error(""String_Node_Str"",e);
        producerErrors.add(e);
        diffProducer.finished=true;
      }
    }
  }
;
  producerThread.setDaemon(true);
  producerThread.start();
  Iterator<DiffEntry> consumerIterator=new AbstractIterator<DiffEntry>(){
    @Override protected DiffEntry computeNext(){
      if (!producerErrors.isEmpty()) {
        throw new RuntimeException(""String_Node_Str"",producerErrors.get(0));
      }
      BlockingQueue<DiffEntry> entries=queue;
      boolean finished=diffProducer.isFinished();
      boolean empty=entries.isEmpty();
      while (!finished || !empty) {
        try {
          DiffEntry entry=entries.poll(10,TimeUnit.MILLISECONDS);
          if (entry != null) {
            return entry;
          }
          finished=diffProducer.isFinished();
          empty=entries.isEmpty();
        }
 catch (        InterruptedException e) {
          throw Throwables.propagate(e);
        }
      }
      return endOfData();
    }
    @Override protected void finalize(){
      diffProducer.finished=true;
    }
  }
;
  return consumerIterator;
}","/** 
 * Finds differences between the two specified trees.
 * @return an iterator to a set of differences between the two trees
 * @see DiffEntry
 */
@Override protected Iterator<DiffEntry> _call() throws IllegalArgumentException {
  checkNotNull(oldRefSpec,""String_Node_Str"");
  checkNotNull(newRefSpec,""String_Node_Str"");
  final RevTree oldTree=resolveTree(oldRefSpec);
  final RevTree newTree=resolveTree(newRefSpec);
  if (oldTree.equals(newTree)) {
    return Iterators.emptyIterator();
  }
  ObjectDatabase leftSource=resolveSource(oldTree.getId());
  ObjectDatabase rightSource=resolveSource(newTree.getId());
  final DiffTreeVisitor visitor=new DiffTreeVisitor(oldTree,newTree,leftSource,rightSource);
  final BlockingQueue<DiffEntry> queue=new ArrayBlockingQueue<>(100);
  final DiffEntryProducer diffProducer=new DiffEntryProducer(queue);
  diffProducer.setReportTrees(this.reportTrees);
  diffProducer.setRecursive(this.recursive);
  final List<RuntimeException> producerErrors=new LinkedList<>();
  Thread producerThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      Consumer consumer=diffProducer;
      if (customFilter != null) {
        consumer=new DiffTreeVisitor.FilteringConsumer(consumer,customFilter);
      }
      if (changeTypeFilter != null) {
        consumer=new ChangeTypeFilteringDiffConsumer(changeTypeFilter,consumer);
      }
      if (boundsFilter != null) {
        consumer=new BoundsFilteringDiffConsumer(boundsFilter,consumer,stagingDatabase());
      }
      if (!pathFilters.isEmpty()) {
        consumer=new PathFilteringDiffConsumer(pathFilters,consumer);
      }
      try {
        visitor.walk(consumer);
      }
 catch (      RuntimeException e) {
        LOGGER.error(""String_Node_Str"",e);
        producerErrors.add(e);
      }
 finally {
        diffProducer.finished=true;
      }
    }
  }
;
  producerThread.setDaemon(true);
  producerThread.start();
  Iterator<DiffEntry> consumerIterator=new AbstractIterator<DiffEntry>(){
    @Override protected DiffEntry computeNext(){
      if (!producerErrors.isEmpty()) {
        throw new RuntimeException(""String_Node_Str"",producerErrors.get(0));
      }
      BlockingQueue<DiffEntry> entries=queue;
      boolean finished=diffProducer.isFinished();
      boolean empty=entries.isEmpty();
      while (!finished || !empty) {
        try {
          DiffEntry entry=entries.poll(10,TimeUnit.MILLISECONDS);
          if (entry != null) {
            return entry;
          }
          finished=diffProducer.isFinished();
          empty=entries.isEmpty();
        }
 catch (        InterruptedException e) {
          throw Throwables.propagate(e);
        }
      }
      return endOfData();
    }
    @Override protected void finalize(){
      diffProducer.finished=true;
    }
  }
;
  return consumerIterator;
}",0.9936079545454546
113309,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Activity activity=getActivity();
  activity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
  mVibrator=(Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);
  if (savedInstanceState != null) {
    mCalendar.set(Calendar.YEAR,savedInstanceState.getInt(KEY_SELECTED_YEAR));
    mCalendar.set(Calendar.MONTH,savedInstanceState.getInt(KEY_SELECTED_MONTH));
    mCalendar.set(Calendar.DAY_OF_MONTH,savedInstanceState.getInt(KEY_SELECTED_DAY));
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Activity activity=getActivity();
  activity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
  if (savedInstanceState != null) {
    mCalendar.set(Calendar.YEAR,savedInstanceState.getInt(KEY_SELECTED_YEAR));
    mCalendar.set(Calendar.MONTH,savedInstanceState.getInt(KEY_SELECTED_MONTH));
    mCalendar.set(Calendar.DAY_OF_MONTH,savedInstanceState.getInt(KEY_SELECTED_DAY));
  }
}",0.9333333333333332
113310,"/** 
 * Try to vibrate. To prevent this becoming a single continuous vibration, nothing will happen if we have vibrated very recently.
 */
@Override public void tryVibrate(){
  if (mVibrator != null) {
    long now=SystemClock.uptimeMillis();
    if (now - mLastVibrate >= 125) {
      mVibrator.vibrate(5);
      mLastVibrate=now;
    }
  }
}","@Override public void tryVibrate(){
  mHapticFeedbackController.tryVibrate();
}",0.2796208530805687
113311,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.date_picker_dialog,null);
  mDayOfWeekView=(TextView)view.findViewById(R.id.date_picker_header);
  mMonthAndDayView=(LinearLayout)view.findViewById(R.id.date_picker_month_and_day);
  mMonthAndDayView.setOnClickListener(this);
  mSelectedMonthTextView=(TextView)view.findViewById(R.id.date_picker_month);
  mSelectedDayTextView=(TextView)view.findViewById(R.id.date_picker_day);
  mYearView=(TextView)view.findViewById(R.id.date_picker_year);
  mYearView.setOnClickListener(this);
  int listPosition=-1;
  int listPositionOffset=0;
  int currentView=MONTH_AND_DAY_VIEW;
  if (savedInstanceState != null) {
    mWeekStart=savedInstanceState.getInt(KEY_WEEK_START);
    mMinYear=savedInstanceState.getInt(KEY_YEAR_START);
    mMaxYear=savedInstanceState.getInt(KEY_YEAR_END);
    currentView=savedInstanceState.getInt(KEY_CURRENT_VIEW);
    listPosition=savedInstanceState.getInt(KEY_LIST_POSITION);
    listPositionOffset=savedInstanceState.getInt(KEY_LIST_POSITION_OFFSET);
  }
  final Activity activity=getActivity();
  mDayPickerView=new DayPickerView(activity,this);
  mYearPickerView=new YearPickerView(activity,this);
  Resources res=getResources();
  mDayPickerDescription=res.getString(R.string.day_picker_description);
  mSelectDay=res.getString(R.string.select_day);
  mYearPickerDescription=res.getString(R.string.year_picker_description);
  mSelectYear=res.getString(R.string.select_year);
  mAnimator=(AccessibleDateAnimator)view.findViewById(R.id.animator);
  mAnimator.addView(mDayPickerView);
  mAnimator.addView(mYearPickerView);
  mAnimator.setDateMillis(mCalendar.getTimeInMillis());
  Animation animation=new AlphaAnimation(0.0f,1.0f);
  animation.setDuration(ANIMATION_DURATION);
  mAnimator.setInAnimation(animation);
  Animation animation2=new AlphaAnimation(1.0f,0.0f);
  animation2.setDuration(ANIMATION_DURATION);
  mAnimator.setOutAnimation(animation2);
  mDoneButton=(Button)view.findViewById(R.id.done);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      tryVibrate();
      if (mCallBack != null) {
        mCallBack.onDateSet(DatePickerDialog.this,mCalendar.get(Calendar.YEAR),mCalendar.get(Calendar.MONTH),mCalendar.get(Calendar.DAY_OF_MONTH));
      }
      dismiss();
    }
  }
);
  updateDisplay(false);
  setCurrentView(currentView);
  if (listPosition != -1) {
    if (currentView == MONTH_AND_DAY_VIEW) {
      mDayPickerView.postSetSelection(listPosition);
    }
 else     if (currentView == YEAR_VIEW) {
      mYearPickerView.postSetSelectionFromTop(listPosition,listPositionOffset);
    }
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.date_picker_dialog,null);
  mDayOfWeekView=(TextView)view.findViewById(R.id.date_picker_header);
  mMonthAndDayView=(LinearLayout)view.findViewById(R.id.date_picker_month_and_day);
  mMonthAndDayView.setOnClickListener(this);
  mSelectedMonthTextView=(TextView)view.findViewById(R.id.date_picker_month);
  mSelectedDayTextView=(TextView)view.findViewById(R.id.date_picker_day);
  mYearView=(TextView)view.findViewById(R.id.date_picker_year);
  mYearView.setOnClickListener(this);
  int listPosition=-1;
  int listPositionOffset=0;
  int currentView=MONTH_AND_DAY_VIEW;
  if (savedInstanceState != null) {
    mWeekStart=savedInstanceState.getInt(KEY_WEEK_START);
    mMinYear=savedInstanceState.getInt(KEY_YEAR_START);
    mMaxYear=savedInstanceState.getInt(KEY_YEAR_END);
    currentView=savedInstanceState.getInt(KEY_CURRENT_VIEW);
    listPosition=savedInstanceState.getInt(KEY_LIST_POSITION);
    listPositionOffset=savedInstanceState.getInt(KEY_LIST_POSITION_OFFSET);
  }
  final Activity activity=getActivity();
  mDayPickerView=new DayPickerView(activity,this);
  mYearPickerView=new YearPickerView(activity,this);
  Resources res=getResources();
  mDayPickerDescription=res.getString(R.string.day_picker_description);
  mSelectDay=res.getString(R.string.select_day);
  mYearPickerDescription=res.getString(R.string.year_picker_description);
  mSelectYear=res.getString(R.string.select_year);
  mAnimator=(AccessibleDateAnimator)view.findViewById(R.id.animator);
  mAnimator.addView(mDayPickerView);
  mAnimator.addView(mYearPickerView);
  mAnimator.setDateMillis(mCalendar.getTimeInMillis());
  Animation animation=new AlphaAnimation(0.0f,1.0f);
  animation.setDuration(ANIMATION_DURATION);
  mAnimator.setInAnimation(animation);
  Animation animation2=new AlphaAnimation(1.0f,0.0f);
  animation2.setDuration(ANIMATION_DURATION);
  mAnimator.setOutAnimation(animation2);
  mDoneButton=(Button)view.findViewById(R.id.done);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      tryVibrate();
      if (mCallBack != null) {
        mCallBack.onDateSet(DatePickerDialog.this,mCalendar.get(Calendar.YEAR),mCalendar.get(Calendar.MONTH),mCalendar.get(Calendar.DAY_OF_MONTH));
      }
      dismiss();
    }
  }
);
  updateDisplay(false);
  setCurrentView(currentView);
  if (listPosition != -1) {
    if (currentView == MONTH_AND_DAY_VIEW) {
      mDayPickerView.postSetSelection(listPosition);
    }
 else     if (currentView == YEAR_VIEW) {
      mYearPickerView.postSetSelectionFromTop(listPosition,listPositionOffset);
    }
  }
  mHapticFeedbackController=new HapticFeedbackController(activity);
  return view;
}",0.9882108183079056
113312,"public RadialPickerLayout(Context context,AttributeSet attrs){
  super(context,attrs);
  setOnTouchListener(this);
  ViewConfiguration vc=ViewConfiguration.get(context);
  TOUCH_SLOP=vc.getScaledTouchSlop();
  TAP_TIMEOUT=ViewConfiguration.getTapTimeout();
  mDoingMove=false;
  mCircleView=new CircleView(context);
  addView(mCircleView);
  mAmPmCirclesView=new AmPmCirclesView(context);
  addView(mAmPmCirclesView);
  mHourRadialTextsView=new RadialTextsView(context);
  addView(mHourRadialTextsView);
  mMinuteRadialTextsView=new RadialTextsView(context);
  addView(mMinuteRadialTextsView);
  mHourRadialSelectorView=new RadialSelectorView(context);
  addView(mHourRadialSelectorView);
  mMinuteRadialSelectorView=new RadialSelectorView(context);
  addView(mMinuteRadialSelectorView);
  preparePrefer30sMap();
  mVibrator=(Vibrator)context.getSystemService(Service.VIBRATOR_SERVICE);
  mLastVibrate=0;
  mLastValueSelected=-1;
  mInputEnabled=true;
  mGrayBox=new View(context);
  mGrayBox.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  mGrayBox.setBackgroundColor(getResources().getColor(R.color.transparent_black));
  mGrayBox.setVisibility(View.INVISIBLE);
  addView(mGrayBox);
  mAccessibilityManager=(AccessibilityManager)context.getSystemService(Context.ACCESSIBILITY_SERVICE);
  mTimeInitialized=false;
}","public RadialPickerLayout(Context context,AttributeSet attrs){
  super(context,attrs);
  setOnTouchListener(this);
  ViewConfiguration vc=ViewConfiguration.get(context);
  TOUCH_SLOP=vc.getScaledTouchSlop();
  TAP_TIMEOUT=ViewConfiguration.getTapTimeout();
  mDoingMove=false;
  mCircleView=new CircleView(context);
  addView(mCircleView);
  mAmPmCirclesView=new AmPmCirclesView(context);
  addView(mAmPmCirclesView);
  mHourRadialTextsView=new RadialTextsView(context);
  addView(mHourRadialTextsView);
  mMinuteRadialTextsView=new RadialTextsView(context);
  addView(mMinuteRadialTextsView);
  mHourRadialSelectorView=new RadialSelectorView(context);
  addView(mHourRadialSelectorView);
  mMinuteRadialSelectorView=new RadialSelectorView(context);
  addView(mMinuteRadialSelectorView);
  preparePrefer30sMap();
  mLastValueSelected=-1;
  mInputEnabled=true;
  mGrayBox=new View(context);
  mGrayBox.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  mGrayBox.setBackgroundColor(getResources().getColor(R.color.transparent_black));
  mGrayBox.setVisibility(View.INVISIBLE);
  addView(mGrayBox);
  mAccessibilityManager=(AccessibilityManager)context.getSystemService(Context.ACCESSIBILITY_SERVICE);
  mTimeInitialized=false;
}",0.965697240865026
113313,"/** 
 * Initialize the Layout with starting values.
 * @param context
 * @param initialHoursOfDay
 * @param initialMinutes
 * @param is24HourMode
 */
public void initialize(Context context,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){
  if (mTimeInitialized) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  mIs24HourMode=is24HourMode;
  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;
  mCircleView.initialize(context,mHideAmPm);
  mCircleView.invalidate();
  if (!mHideAmPm) {
    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);
    mAmPmCirclesView.invalidate();
  }
  Resources res=context.getResources();
  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};
  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};
  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};
  String[] hoursTexts=new String[12];
  String[] innerHoursTexts=new String[12];
  String[] minutesTexts=new String[12];
  for (int i=0; i < 12; i++) {
    hoursTexts[i]=is24HourMode ? String.format(""String_Node_Str"",hours_24[i]) : String.format(""String_Node_Str"",hours[i]);
    innerHoursTexts[i]=String.format(""String_Node_Str"",hours[i]);
    minutesTexts[i]=String.format(""String_Node_Str"",minutes[i]);
  }
  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);
  mHourRadialTextsView.invalidate();
  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);
  mMinuteRadialTextsView.invalidate();
  setValueForItem(HOUR_INDEX,initialHoursOfDay);
  setValueForItem(MINUTE_INDEX,initialMinutes);
  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;
  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));
  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;
  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);
  mTimeInitialized=true;
}","/** 
 * Initialize the Layout with starting values.
 * @param context
 * @param initialHoursOfDay
 * @param initialMinutes
 * @param is24HourMode
 */
public void initialize(Context context,TimePickerDialog controller,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){
  if (mTimeInitialized) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  mController=controller;
  mIs24HourMode=is24HourMode;
  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;
  mCircleView.initialize(context,mHideAmPm);
  mCircleView.invalidate();
  if (!mHideAmPm) {
    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);
    mAmPmCirclesView.invalidate();
  }
  Resources res=context.getResources();
  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};
  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};
  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};
  String[] hoursTexts=new String[12];
  String[] innerHoursTexts=new String[12];
  String[] minutesTexts=new String[12];
  for (int i=0; i < 12; i++) {
    hoursTexts[i]=is24HourMode ? String.format(""String_Node_Str"",hours_24[i]) : String.format(""String_Node_Str"",hours[i]);
    innerHoursTexts[i]=String.format(""String_Node_Str"",hours[i]);
    minutesTexts[i]=String.format(""String_Node_Str"",minutes[i]);
  }
  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);
  mHourRadialTextsView.invalidate();
  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);
  mMinuteRadialTextsView.invalidate();
  setValueForItem(HOUR_INDEX,initialHoursOfDay);
  setValueForItem(MINUTE_INDEX,initialMinutes);
  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;
  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));
  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;
  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);
  mTimeInitialized=true;
}",0.986679822397632
113314,"@Override public boolean onTouch(View v,MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
  int degrees;
  int value;
  final Boolean[] isInnerCircle=new Boolean[1];
  isInnerCircle[0]=false;
  long millis=SystemClock.uptimeMillis();
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (!mInputEnabled) {
      return true;
    }
  mDownX=eventX;
mDownY=eventY;
mLastValueSelected=-1;
mDoingMove=false;
mDoingTouch=true;
if (!mHideAmPm) {
mIsTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
}
 else {
mIsTouchingAmOrPm=-1;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
tryVibrate();
mDownDegrees=-1;
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mAmPmCirclesView.setAmOrPmPressed(mIsTouchingAmOrPm);
mAmPmCirclesView.invalidate();
}
}
,TAP_TIMEOUT);
}
 else {
boolean forceLegal=mAccessibilityManager.isTouchExplorationEnabled();
mDownDegrees=getDegreesFromCoords(eventX,eventY,forceLegal,isInnerCircle);
if (mDownDegrees != -1) {
tryVibrate();
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mDoingMove=true;
int value=reselectSelector(mDownDegrees,isInnerCircle[0],false,true);
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
,TAP_TIMEOUT);
}
}
return true;
case MotionEvent.ACTION_MOVE:
if (!mInputEnabled) {
Log.e(TAG,""String_Node_Str"");
return true;
}
float dY=Math.abs(eventY - mDownY);
float dX=Math.abs(eventX - mDownX);
if (!mDoingMove && dX <= TOUCH_SLOP && dY <= TOUCH_SLOP) {
break;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mHandler.removeCallbacksAndMessages(null);
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
if (isTouchingAmOrPm != mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
mIsTouchingAmOrPm=-1;
}
break;
}
if (mDownDegrees == -1) {
break;
}
mDoingMove=true;
mHandler.removeCallbacksAndMessages(null);
degrees=getDegreesFromCoords(eventX,eventY,true,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],false,true);
if (value != mLastValueSelected) {
tryVibrate();
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mInputEnabled) {
Log.d(TAG,""String_Node_Str"");
mListener.onValueSelected(ENABLE_PICKER_INDEX,1,false);
return true;
}
mHandler.removeCallbacksAndMessages(null);
mDoingTouch=false;
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
if (isTouchingAmOrPm == mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPm(isTouchingAmOrPm);
if (getIsCurrentlyAmOrPm() != isTouchingAmOrPm) {
mListener.onValueSelected(AMPM_INDEX,mIsTouchingAmOrPm,false);
setValueForItem(AMPM_INDEX,isTouchingAmOrPm);
}
}
mIsTouchingAmOrPm=-1;
break;
}
if (mDownDegrees != -1) {
degrees=getDegreesFromCoords(eventX,eventY,mDoingMove,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],!mDoingMove,false);
if (getCurrentItemShowing() == HOUR_INDEX && !mIs24HourMode) {
int amOrPm=getIsCurrentlyAmOrPm();
if (amOrPm == AM && value == 12) {
value=0;
}
 else if (amOrPm == PM && value != 12) {
value+=12;
}
}
setValueForItem(getCurrentItemShowing(),value);
mListener.onValueSelected(getCurrentItemShowing(),value,true);
}
}
mDoingMove=false;
return true;
default :
break;
}
return false;
}","@Override public boolean onTouch(View v,MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
  int degrees;
  int value;
  final Boolean[] isInnerCircle=new Boolean[1];
  isInnerCircle[0]=false;
  long millis=SystemClock.uptimeMillis();
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (!mInputEnabled) {
      return true;
    }
  mDownX=eventX;
mDownY=eventY;
mLastValueSelected=-1;
mDoingMove=false;
mDoingTouch=true;
if (!mHideAmPm) {
mIsTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
}
 else {
mIsTouchingAmOrPm=-1;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mController.tryVibrate();
mDownDegrees=-1;
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mAmPmCirclesView.setAmOrPmPressed(mIsTouchingAmOrPm);
mAmPmCirclesView.invalidate();
}
}
,TAP_TIMEOUT);
}
 else {
boolean forceLegal=mAccessibilityManager.isTouchExplorationEnabled();
mDownDegrees=getDegreesFromCoords(eventX,eventY,forceLegal,isInnerCircle);
if (mDownDegrees != -1) {
mController.tryVibrate();
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mDoingMove=true;
int value=reselectSelector(mDownDegrees,isInnerCircle[0],false,true);
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
,TAP_TIMEOUT);
}
}
return true;
case MotionEvent.ACTION_MOVE:
if (!mInputEnabled) {
Log.e(TAG,""String_Node_Str"");
return true;
}
float dY=Math.abs(eventY - mDownY);
float dX=Math.abs(eventX - mDownX);
if (!mDoingMove && dX <= TOUCH_SLOP && dY <= TOUCH_SLOP) {
break;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mHandler.removeCallbacksAndMessages(null);
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
if (isTouchingAmOrPm != mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
mIsTouchingAmOrPm=-1;
}
break;
}
if (mDownDegrees == -1) {
break;
}
mDoingMove=true;
mHandler.removeCallbacksAndMessages(null);
degrees=getDegreesFromCoords(eventX,eventY,true,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],false,true);
if (value != mLastValueSelected) {
mController.tryVibrate();
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mInputEnabled) {
Log.d(TAG,""String_Node_Str"");
mListener.onValueSelected(ENABLE_PICKER_INDEX,1,false);
return true;
}
mHandler.removeCallbacksAndMessages(null);
mDoingTouch=false;
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
if (isTouchingAmOrPm == mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPm(isTouchingAmOrPm);
if (getIsCurrentlyAmOrPm() != isTouchingAmOrPm) {
mListener.onValueSelected(AMPM_INDEX,mIsTouchingAmOrPm,false);
setValueForItem(AMPM_INDEX,isTouchingAmOrPm);
}
}
mIsTouchingAmOrPm=-1;
break;
}
if (mDownDegrees != -1) {
degrees=getDegreesFromCoords(eventX,eventY,mDoingMove,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],!mDoingMove,false);
if (getCurrentItemShowing() == HOUR_INDEX && !mIs24HourMode) {
int amOrPm=getIsCurrentlyAmOrPm();
if (amOrPm == AM && value == 12) {
value=0;
}
 else if (amOrPm == PM && value != 12) {
value+=12;
}
}
setValueForItem(getCurrentItemShowing(),value);
mListener.onValueSelected(getCurrentItemShowing(),value,true);
}
}
mDoingMove=false;
return true;
default :
break;
}
return false;
}",0.9949593951274152
113315,"@Override public void onClick(View v){
  mTimePicker.tryVibrate();
  int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
  if (amOrPm == AM) {
    amOrPm=PM;
  }
 else   if (amOrPm == PM) {
    amOrPm=AM;
  }
  updateAmPmDisplay(amOrPm);
  mTimePicker.setAmOrPm(amOrPm);
}","@Override public void onClick(View v){
  tryVibrate();
  int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
  if (amOrPm == AM) {
    amOrPm=PM;
  }
 else   if (amOrPm == PM) {
    amOrPm=AM;
  }
  updateAmPmDisplay(amOrPm);
  mTimePicker.setAmOrPm(amOrPm);
}",0.9770114942528736
113316,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  KeyboardListener keyboardListener=new KeyboardListener();
  view.findViewById(R.id.time_picker_dialog).setOnKeyListener(keyboardListener);
  Resources res=getResources();
  mHourPickerDescription=res.getString(R.string.hour_picker_description);
  mSelectHours=res.getString(R.string.select_hours);
  mMinutePickerDescription=res.getString(R.string.minute_picker_description);
  mSelectMinutes=res.getString(R.string.select_minutes);
  mBlue=res.getColor(R.color.blue);
  mBlack=res.getColor(R.color.numbers_text_color);
  mHourView=(TextView)view.findViewById(R.id.hours);
  mHourView.setOnKeyListener(keyboardListener);
  mHourSpaceView=(TextView)view.findViewById(R.id.hour_space);
  mMinuteSpaceView=(TextView)view.findViewById(R.id.minutes_space);
  mMinuteView=(TextView)view.findViewById(R.id.minutes);
  mMinuteView.setOnKeyListener(keyboardListener);
  mAmPmTextView=(TextView)view.findViewById(R.id.ampm_label);
  mAmPmTextView.setOnKeyListener(keyboardListener);
  String[] amPmTexts=new DateFormatSymbols().getAmPmStrings();
  mAmText=amPmTexts[0];
  mPmText=amPmTexts[1];
  mTimePicker=(RadialPickerLayout)view.findViewById(R.id.time_picker);
  mTimePicker.setOnValueSelectedListener(this);
  mTimePicker.setOnKeyListener(keyboardListener);
  mTimePicker.initialize(getActivity(),mInitialHourOfDay,mInitialMinute,mIs24HourMode);
  int currentItemShowing=HOUR_INDEX;
  if (savedInstanceState != null && savedInstanceState.containsKey(KEY_CURRENT_ITEM_SHOWING)) {
    currentItemShowing=savedInstanceState.getInt(KEY_CURRENT_ITEM_SHOWING);
  }
  setCurrentItemShowing(currentItemShowing,false,true,true);
  mTimePicker.invalidate();
  mHourView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(HOUR_INDEX,true,false,true);
      mTimePicker.tryVibrate();
    }
  }
);
  mMinuteView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(MINUTE_INDEX,true,false,true);
      mTimePicker.tryVibrate();
    }
  }
);
  mDoneButton=(TextView)view.findViewById(R.id.done_button);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mInKbMode && isTypedTimeFullyLegal()) {
        finishKbMode(false);
      }
 else {
        mTimePicker.tryVibrate();
      }
      if (mCallback != null) {
        mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());
      }
      dismiss();
    }
  }
);
  mDoneButton.setOnKeyListener(keyboardListener);
  mAmPmHitspace=view.findViewById(R.id.ampm_hitspace);
  if (mIs24HourMode) {
    mAmPmTextView.setVisibility(View.GONE);
    RelativeLayout.LayoutParams paramsSeparator=new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
    paramsSeparator.addRule(RelativeLayout.CENTER_IN_PARENT);
    TextView separatorView=(TextView)view.findViewById(R.id.separator);
    separatorView.setLayoutParams(paramsSeparator);
  }
 else {
    mAmPmTextView.setVisibility(View.VISIBLE);
    updateAmPmDisplay(mInitialHourOfDay < 12 ? AM : PM);
    mAmPmHitspace.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        mTimePicker.tryVibrate();
        int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
        if (amOrPm == AM) {
          amOrPm=PM;
        }
 else         if (amOrPm == PM) {
          amOrPm=AM;
        }
        updateAmPmDisplay(amOrPm);
        mTimePicker.setAmOrPm(amOrPm);
      }
    }
);
  }
  mAllowAutoAdvance=true;
  setHour(mInitialHourOfDay,true);
  setMinute(mInitialMinute);
  mDoublePlaceholderText=res.getString(R.string.time_placeholder);
  mDeletedKeyFormat=res.getString(R.string.deleted_key);
  mPlaceholderText=mDoublePlaceholderText.charAt(0);
  mAmKeyCode=mPmKeyCode=-1;
  generateLegalTimesTree();
  if (mInKbMode) {
    mTypedTimes=savedInstanceState.getIntegerArrayList(KEY_TYPED_TIMES);
    tryStartingKbMode(-1);
    mHourView.invalidate();
  }
 else   if (mTypedTimes == null) {
    mTypedTimes=new ArrayList<Integer>();
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  KeyboardListener keyboardListener=new KeyboardListener();
  view.findViewById(R.id.time_picker_dialog).setOnKeyListener(keyboardListener);
  Resources res=getResources();
  mHourPickerDescription=res.getString(R.string.hour_picker_description);
  mSelectHours=res.getString(R.string.select_hours);
  mMinutePickerDescription=res.getString(R.string.minute_picker_description);
  mSelectMinutes=res.getString(R.string.select_minutes);
  mBlue=res.getColor(R.color.blue);
  mBlack=res.getColor(R.color.numbers_text_color);
  mHourView=(TextView)view.findViewById(R.id.hours);
  mHourView.setOnKeyListener(keyboardListener);
  mHourSpaceView=(TextView)view.findViewById(R.id.hour_space);
  mMinuteSpaceView=(TextView)view.findViewById(R.id.minutes_space);
  mMinuteView=(TextView)view.findViewById(R.id.minutes);
  mMinuteView.setOnKeyListener(keyboardListener);
  mAmPmTextView=(TextView)view.findViewById(R.id.ampm_label);
  mAmPmTextView.setOnKeyListener(keyboardListener);
  String[] amPmTexts=new DateFormatSymbols().getAmPmStrings();
  mAmText=amPmTexts[0];
  mPmText=amPmTexts[1];
  mTimePicker=(RadialPickerLayout)view.findViewById(R.id.time_picker);
  mTimePicker.setOnValueSelectedListener(this);
  mTimePicker.setOnKeyListener(keyboardListener);
  mTimePicker.initialize(getActivity(),this,mInitialHourOfDay,mInitialMinute,mIs24HourMode);
  int currentItemShowing=HOUR_INDEX;
  if (savedInstanceState != null && savedInstanceState.containsKey(KEY_CURRENT_ITEM_SHOWING)) {
    currentItemShowing=savedInstanceState.getInt(KEY_CURRENT_ITEM_SHOWING);
  }
  setCurrentItemShowing(currentItemShowing,false,true,true);
  mTimePicker.invalidate();
  mHapticFeedbackController=new HapticFeedbackController(getActivity());
  mHourView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(HOUR_INDEX,true,false,true);
      tryVibrate();
    }
  }
);
  mMinuteView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(MINUTE_INDEX,true,false,true);
      tryVibrate();
    }
  }
);
  mDoneButton=(TextView)view.findViewById(R.id.done_button);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mInKbMode && isTypedTimeFullyLegal()) {
        finishKbMode(false);
      }
 else {
        tryVibrate();
      }
      if (mCallback != null) {
        mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());
      }
      dismiss();
    }
  }
);
  mDoneButton.setOnKeyListener(keyboardListener);
  mAmPmHitspace=view.findViewById(R.id.ampm_hitspace);
  if (mIs24HourMode) {
    mAmPmTextView.setVisibility(View.GONE);
    RelativeLayout.LayoutParams paramsSeparator=new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
    paramsSeparator.addRule(RelativeLayout.CENTER_IN_PARENT);
    TextView separatorView=(TextView)view.findViewById(R.id.separator);
    separatorView.setLayoutParams(paramsSeparator);
  }
 else {
    mAmPmTextView.setVisibility(View.VISIBLE);
    updateAmPmDisplay(mInitialHourOfDay < 12 ? AM : PM);
    mAmPmHitspace.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        tryVibrate();
        int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
        if (amOrPm == AM) {
          amOrPm=PM;
        }
 else         if (amOrPm == PM) {
          amOrPm=AM;
        }
        updateAmPmDisplay(amOrPm);
        mTimePicker.setAmOrPm(amOrPm);
      }
    }
);
  }
  mAllowAutoAdvance=true;
  setHour(mInitialHourOfDay,true);
  setMinute(mInitialMinute);
  mDoublePlaceholderText=res.getString(R.string.time_placeholder);
  mDeletedKeyFormat=res.getString(R.string.deleted_key);
  mPlaceholderText=mDoublePlaceholderText.charAt(0);
  mAmKeyCode=mPmKeyCode=-1;
  generateLegalTimesTree();
  if (mInKbMode) {
    mTypedTimes=savedInstanceState.getIntegerArrayList(KEY_TYPED_TIMES);
    tryStartingKbMode(-1);
    mHourView.invalidate();
  }
 else   if (mTypedTimes == null) {
    mTypedTimes=new ArrayList<Integer>();
  }
  return view;
}",0.9855703160787906
113317,"/** 
 * Called by the picker for updating the header display.
 */
@Override public void onValueSelected(int pickerIndex,int newValue,boolean autoAdvance){
  if (pickerIndex == HOUR_INDEX) {
    setHour(newValue,false);
    String announcement=String.format(""String_Node_Str"",newValue);
    if (mAllowAutoAdvance && autoAdvance) {
      setCurrentItemShowing(MINUTE_INDEX,true,true,false);
      announcement+=""String_Node_Str"" + mSelectMinutes;
    }
    Utils.tryAccessibilityAnnounce(mTimePicker,announcement);
  }
 else   if (pickerIndex == MINUTE_INDEX) {
    setMinute(newValue);
  }
 else   if (pickerIndex == AMPM_INDEX) {
    updateAmPmDisplay(newValue);
  }
 else   if (pickerIndex == ENABLE_PICKER_INDEX) {
    if (!isTypedTimeFullyLegal()) {
      mTypedTimes.clear();
    }
    finishKbMode(true);
  }
}","/** 
 * Called by the picker for updating the header display.
 */
@Override public void onValueSelected(int pickerIndex,int newValue,boolean autoAdvance){
  if (pickerIndex == HOUR_INDEX) {
    setHour(newValue,false);
    String announcement=String.format(""String_Node_Str"",newValue);
    if (mAllowAutoAdvance && autoAdvance) {
      setCurrentItemShowing(MINUTE_INDEX,true,true,false);
      announcement+=""String_Node_Str"" + mSelectMinutes;
    }
 else {
      mTimePicker.setContentDescription(mHourPickerDescription + ""String_Node_Str"" + newValue);
    }
    Utils.tryAccessibilityAnnounce(mTimePicker,announcement);
  }
 else   if (pickerIndex == MINUTE_INDEX) {
    setMinute(newValue);
    mTimePicker.setContentDescription(mMinutePickerDescription + ""String_Node_Str"" + newValue);
  }
 else   if (pickerIndex == AMPM_INDEX) {
    updateAmPmDisplay(newValue);
  }
 else   if (pickerIndex == ENABLE_PICKER_INDEX) {
    if (!isTypedTimeFullyLegal()) {
      mTypedTimes.clear();
    }
    finishKbMode(true);
  }
}",0.8877995642701525
113318,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Activity activity=getActivity();
  activity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
  mVibrator=(Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);
  if (savedInstanceState != null) {
    mCalendar.set(Calendar.YEAR,savedInstanceState.getInt(KEY_SELECTED_YEAR));
    mCalendar.set(Calendar.MONTH,savedInstanceState.getInt(KEY_SELECTED_MONTH));
    mCalendar.set(Calendar.DAY_OF_MONTH,savedInstanceState.getInt(KEY_SELECTED_DAY));
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Activity activity=getActivity();
  activity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
  if (savedInstanceState != null) {
    mCalendar.set(Calendar.YEAR,savedInstanceState.getInt(KEY_SELECTED_YEAR));
    mCalendar.set(Calendar.MONTH,savedInstanceState.getInt(KEY_SELECTED_MONTH));
    mCalendar.set(Calendar.DAY_OF_MONTH,savedInstanceState.getInt(KEY_SELECTED_DAY));
  }
}",0.9333333333333332
113319,"/** 
 * Try to vibrate. To prevent this becoming a single continuous vibration, nothing will happen if we have vibrated very recently.
 */
@Override public void tryVibrate(){
  if (mVibrator != null) {
    long now=SystemClock.uptimeMillis();
    if (now - mLastVibrate >= 125) {
      mVibrator.vibrate(5);
      mLastVibrate=now;
    }
  }
}","@Override public void tryVibrate(){
  mHapticFeedbackController.tryVibrate();
}",0.2796208530805687
113320,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.date_picker_dialog,null);
  mDayOfWeekView=(TextView)view.findViewById(R.id.date_picker_header);
  mMonthAndDayView=(LinearLayout)view.findViewById(R.id.date_picker_month_and_day);
  mMonthAndDayView.setOnClickListener(this);
  mSelectedMonthTextView=(TextView)view.findViewById(R.id.date_picker_month);
  mSelectedDayTextView=(TextView)view.findViewById(R.id.date_picker_day);
  mYearView=(TextView)view.findViewById(R.id.date_picker_year);
  mYearView.setOnClickListener(this);
  int listPosition=-1;
  int listPositionOffset=0;
  int currentView=MONTH_AND_DAY_VIEW;
  if (savedInstanceState != null) {
    mWeekStart=savedInstanceState.getInt(KEY_WEEK_START);
    mMinYear=savedInstanceState.getInt(KEY_YEAR_START);
    mMaxYear=savedInstanceState.getInt(KEY_YEAR_END);
    currentView=savedInstanceState.getInt(KEY_CURRENT_VIEW);
    listPosition=savedInstanceState.getInt(KEY_LIST_POSITION);
    listPositionOffset=savedInstanceState.getInt(KEY_LIST_POSITION_OFFSET);
  }
  final Activity activity=getActivity();
  mDayPickerView=new DayPickerView(activity,this);
  mYearPickerView=new YearPickerView(activity,this);
  Resources res=getResources();
  mDayPickerDescription=res.getString(R.string.day_picker_description);
  mSelectDay=res.getString(R.string.select_day);
  mYearPickerDescription=res.getString(R.string.year_picker_description);
  mSelectYear=res.getString(R.string.select_year);
  mAnimator=(AccessibleDateAnimator)view.findViewById(R.id.animator);
  mAnimator.addView(mDayPickerView);
  mAnimator.addView(mYearPickerView);
  mAnimator.setDateMillis(mCalendar.getTimeInMillis());
  Animation animation=new AlphaAnimation(0.0f,1.0f);
  animation.setDuration(ANIMATION_DURATION);
  mAnimator.setInAnimation(animation);
  Animation animation2=new AlphaAnimation(1.0f,0.0f);
  animation2.setDuration(ANIMATION_DURATION);
  mAnimator.setOutAnimation(animation2);
  mDoneButton=(Button)view.findViewById(R.id.done);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      tryVibrate();
      if (mCallBack != null) {
        mCallBack.onDateSet(DatePickerDialog.this,mCalendar.get(Calendar.YEAR),mCalendar.get(Calendar.MONTH),mCalendar.get(Calendar.DAY_OF_MONTH));
      }
      dismiss();
    }
  }
);
  updateDisplay(false);
  setCurrentView(currentView);
  if (listPosition != -1) {
    if (currentView == MONTH_AND_DAY_VIEW) {
      mDayPickerView.postSetSelection(listPosition);
    }
 else     if (currentView == YEAR_VIEW) {
      mYearPickerView.postSetSelectionFromTop(listPosition,listPositionOffset);
    }
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.date_picker_dialog,null);
  mDayOfWeekView=(TextView)view.findViewById(R.id.date_picker_header);
  mMonthAndDayView=(LinearLayout)view.findViewById(R.id.date_picker_month_and_day);
  mMonthAndDayView.setOnClickListener(this);
  mSelectedMonthTextView=(TextView)view.findViewById(R.id.date_picker_month);
  mSelectedDayTextView=(TextView)view.findViewById(R.id.date_picker_day);
  mYearView=(TextView)view.findViewById(R.id.date_picker_year);
  mYearView.setOnClickListener(this);
  int listPosition=-1;
  int listPositionOffset=0;
  int currentView=MONTH_AND_DAY_VIEW;
  if (savedInstanceState != null) {
    mWeekStart=savedInstanceState.getInt(KEY_WEEK_START);
    mMinYear=savedInstanceState.getInt(KEY_YEAR_START);
    mMaxYear=savedInstanceState.getInt(KEY_YEAR_END);
    currentView=savedInstanceState.getInt(KEY_CURRENT_VIEW);
    listPosition=savedInstanceState.getInt(KEY_LIST_POSITION);
    listPositionOffset=savedInstanceState.getInt(KEY_LIST_POSITION_OFFSET);
  }
  final Activity activity=getActivity();
  mDayPickerView=new DayPickerView(activity,this);
  mYearPickerView=new YearPickerView(activity,this);
  Resources res=getResources();
  mDayPickerDescription=res.getString(R.string.day_picker_description);
  mSelectDay=res.getString(R.string.select_day);
  mYearPickerDescription=res.getString(R.string.year_picker_description);
  mSelectYear=res.getString(R.string.select_year);
  mAnimator=(AccessibleDateAnimator)view.findViewById(R.id.animator);
  mAnimator.addView(mDayPickerView);
  mAnimator.addView(mYearPickerView);
  mAnimator.setDateMillis(mCalendar.getTimeInMillis());
  Animation animation=new AlphaAnimation(0.0f,1.0f);
  animation.setDuration(ANIMATION_DURATION);
  mAnimator.setInAnimation(animation);
  Animation animation2=new AlphaAnimation(1.0f,0.0f);
  animation2.setDuration(ANIMATION_DURATION);
  mAnimator.setOutAnimation(animation2);
  mDoneButton=(Button)view.findViewById(R.id.done);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      tryVibrate();
      if (mCallBack != null) {
        mCallBack.onDateSet(DatePickerDialog.this,mCalendar.get(Calendar.YEAR),mCalendar.get(Calendar.MONTH),mCalendar.get(Calendar.DAY_OF_MONTH));
      }
      dismiss();
    }
  }
);
  updateDisplay(false);
  setCurrentView(currentView);
  if (listPosition != -1) {
    if (currentView == MONTH_AND_DAY_VIEW) {
      mDayPickerView.postSetSelection(listPosition);
    }
 else     if (currentView == YEAR_VIEW) {
      mYearPickerView.postSetSelectionFromTop(listPosition,listPositionOffset);
    }
  }
  mHapticFeedbackController=new HapticFeedbackController(activity);
  return view;
}",0.9882108183079056
113321,"public RadialPickerLayout(Context context,AttributeSet attrs){
  super(context,attrs);
  setOnTouchListener(this);
  ViewConfiguration vc=ViewConfiguration.get(context);
  TOUCH_SLOP=vc.getScaledTouchSlop();
  TAP_TIMEOUT=ViewConfiguration.getTapTimeout();
  mDoingMove=false;
  mCircleView=new CircleView(context);
  addView(mCircleView);
  mAmPmCirclesView=new AmPmCirclesView(context);
  addView(mAmPmCirclesView);
  mHourRadialTextsView=new RadialTextsView(context);
  addView(mHourRadialTextsView);
  mMinuteRadialTextsView=new RadialTextsView(context);
  addView(mMinuteRadialTextsView);
  mHourRadialSelectorView=new RadialSelectorView(context);
  addView(mHourRadialSelectorView);
  mMinuteRadialSelectorView=new RadialSelectorView(context);
  addView(mMinuteRadialSelectorView);
  preparePrefer30sMap();
  mVibrator=(Vibrator)context.getSystemService(Service.VIBRATOR_SERVICE);
  mLastVibrate=0;
  mLastValueSelected=-1;
  mInputEnabled=true;
  mGrayBox=new View(context);
  mGrayBox.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  mGrayBox.setBackgroundColor(getResources().getColor(R.color.transparent_black));
  mGrayBox.setVisibility(View.INVISIBLE);
  addView(mGrayBox);
  mAccessibilityManager=(AccessibilityManager)context.getSystemService(Context.ACCESSIBILITY_SERVICE);
  mTimeInitialized=false;
}","public RadialPickerLayout(Context context,AttributeSet attrs){
  super(context,attrs);
  setOnTouchListener(this);
  ViewConfiguration vc=ViewConfiguration.get(context);
  TOUCH_SLOP=vc.getScaledTouchSlop();
  TAP_TIMEOUT=ViewConfiguration.getTapTimeout();
  mDoingMove=false;
  mCircleView=new CircleView(context);
  addView(mCircleView);
  mAmPmCirclesView=new AmPmCirclesView(context);
  addView(mAmPmCirclesView);
  mHourRadialTextsView=new RadialTextsView(context);
  addView(mHourRadialTextsView);
  mMinuteRadialTextsView=new RadialTextsView(context);
  addView(mMinuteRadialTextsView);
  mHourRadialSelectorView=new RadialSelectorView(context);
  addView(mHourRadialSelectorView);
  mMinuteRadialSelectorView=new RadialSelectorView(context);
  addView(mMinuteRadialSelectorView);
  preparePrefer30sMap();
  mLastValueSelected=-1;
  mInputEnabled=true;
  mGrayBox=new View(context);
  mGrayBox.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  mGrayBox.setBackgroundColor(getResources().getColor(R.color.transparent_black));
  mGrayBox.setVisibility(View.INVISIBLE);
  addView(mGrayBox);
  mAccessibilityManager=(AccessibilityManager)context.getSystemService(Context.ACCESSIBILITY_SERVICE);
  mTimeInitialized=false;
}",0.965697240865026
113322,"/** 
 * Initialize the Layout with starting values.
 * @param context
 * @param initialHoursOfDay
 * @param initialMinutes
 * @param is24HourMode
 */
public void initialize(Context context,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){
  if (mTimeInitialized) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  mIs24HourMode=is24HourMode;
  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;
  mCircleView.initialize(context,mHideAmPm);
  mCircleView.invalidate();
  if (!mHideAmPm) {
    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);
    mAmPmCirclesView.invalidate();
  }
  Resources res=context.getResources();
  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};
  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};
  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};
  String[] hoursTexts=new String[12];
  String[] innerHoursTexts=new String[12];
  String[] minutesTexts=new String[12];
  for (int i=0; i < 12; i++) {
    hoursTexts[i]=is24HourMode ? String.format(""String_Node_Str"",hours_24[i]) : String.format(""String_Node_Str"",hours[i]);
    innerHoursTexts[i]=String.format(""String_Node_Str"",hours[i]);
    minutesTexts[i]=String.format(""String_Node_Str"",minutes[i]);
  }
  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);
  mHourRadialTextsView.invalidate();
  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);
  mMinuteRadialTextsView.invalidate();
  setValueForItem(HOUR_INDEX,initialHoursOfDay);
  setValueForItem(MINUTE_INDEX,initialMinutes);
  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;
  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));
  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;
  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);
  mTimeInitialized=true;
}","/** 
 * Initialize the Layout with starting values.
 * @param context
 * @param initialHoursOfDay
 * @param initialMinutes
 * @param is24HourMode
 */
public void initialize(Context context,TimePickerDialog controller,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){
  if (mTimeInitialized) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  mController=controller;
  mIs24HourMode=is24HourMode;
  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;
  mCircleView.initialize(context,mHideAmPm);
  mCircleView.invalidate();
  if (!mHideAmPm) {
    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);
    mAmPmCirclesView.invalidate();
  }
  Resources res=context.getResources();
  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};
  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};
  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};
  String[] hoursTexts=new String[12];
  String[] innerHoursTexts=new String[12];
  String[] minutesTexts=new String[12];
  for (int i=0; i < 12; i++) {
    hoursTexts[i]=is24HourMode ? String.format(""String_Node_Str"",hours_24[i]) : String.format(""String_Node_Str"",hours[i]);
    innerHoursTexts[i]=String.format(""String_Node_Str"",hours[i]);
    minutesTexts[i]=String.format(""String_Node_Str"",minutes[i]);
  }
  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);
  mHourRadialTextsView.invalidate();
  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);
  mMinuteRadialTextsView.invalidate();
  setValueForItem(HOUR_INDEX,initialHoursOfDay);
  setValueForItem(MINUTE_INDEX,initialMinutes);
  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;
  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));
  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;
  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);
  mTimeInitialized=true;
}",0.986679822397632
113323,"@Override public boolean onTouch(View v,MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
  int degrees;
  int value;
  final Boolean[] isInnerCircle=new Boolean[1];
  isInnerCircle[0]=false;
  long millis=SystemClock.uptimeMillis();
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (!mInputEnabled) {
      return true;
    }
  mDownX=eventX;
mDownY=eventY;
mLastValueSelected=-1;
mDoingMove=false;
mDoingTouch=true;
if (!mHideAmPm) {
mIsTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
}
 else {
mIsTouchingAmOrPm=-1;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
tryVibrate();
mDownDegrees=-1;
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mAmPmCirclesView.setAmOrPmPressed(mIsTouchingAmOrPm);
mAmPmCirclesView.invalidate();
}
}
,TAP_TIMEOUT);
}
 else {
boolean forceLegal=mAccessibilityManager.isTouchExplorationEnabled();
mDownDegrees=getDegreesFromCoords(eventX,eventY,forceLegal,isInnerCircle);
if (mDownDegrees != -1) {
tryVibrate();
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mDoingMove=true;
int value=reselectSelector(mDownDegrees,isInnerCircle[0],false,true);
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
,TAP_TIMEOUT);
}
}
return true;
case MotionEvent.ACTION_MOVE:
if (!mInputEnabled) {
Log.e(TAG,""String_Node_Str"");
return true;
}
float dY=Math.abs(eventY - mDownY);
float dX=Math.abs(eventX - mDownX);
if (!mDoingMove && dX <= TOUCH_SLOP && dY <= TOUCH_SLOP) {
break;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mHandler.removeCallbacksAndMessages(null);
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
if (isTouchingAmOrPm != mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
mIsTouchingAmOrPm=-1;
}
break;
}
if (mDownDegrees == -1) {
break;
}
mDoingMove=true;
mHandler.removeCallbacksAndMessages(null);
degrees=getDegreesFromCoords(eventX,eventY,true,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],false,true);
if (value != mLastValueSelected) {
tryVibrate();
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mInputEnabled) {
Log.d(TAG,""String_Node_Str"");
mListener.onValueSelected(ENABLE_PICKER_INDEX,1,false);
return true;
}
mHandler.removeCallbacksAndMessages(null);
mDoingTouch=false;
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
if (isTouchingAmOrPm == mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPm(isTouchingAmOrPm);
if (getIsCurrentlyAmOrPm() != isTouchingAmOrPm) {
mListener.onValueSelected(AMPM_INDEX,mIsTouchingAmOrPm,false);
setValueForItem(AMPM_INDEX,isTouchingAmOrPm);
}
}
mIsTouchingAmOrPm=-1;
break;
}
if (mDownDegrees != -1) {
degrees=getDegreesFromCoords(eventX,eventY,mDoingMove,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],!mDoingMove,false);
if (getCurrentItemShowing() == HOUR_INDEX && !mIs24HourMode) {
int amOrPm=getIsCurrentlyAmOrPm();
if (amOrPm == AM && value == 12) {
value=0;
}
 else if (amOrPm == PM && value != 12) {
value+=12;
}
}
setValueForItem(getCurrentItemShowing(),value);
mListener.onValueSelected(getCurrentItemShowing(),value,true);
}
}
mDoingMove=false;
return true;
default :
break;
}
return false;
}","@Override public boolean onTouch(View v,MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
  int degrees;
  int value;
  final Boolean[] isInnerCircle=new Boolean[1];
  isInnerCircle[0]=false;
  long millis=SystemClock.uptimeMillis();
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (!mInputEnabled) {
      return true;
    }
  mDownX=eventX;
mDownY=eventY;
mLastValueSelected=-1;
mDoingMove=false;
mDoingTouch=true;
if (!mHideAmPm) {
mIsTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
}
 else {
mIsTouchingAmOrPm=-1;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mController.tryVibrate();
mDownDegrees=-1;
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mAmPmCirclesView.setAmOrPmPressed(mIsTouchingAmOrPm);
mAmPmCirclesView.invalidate();
}
}
,TAP_TIMEOUT);
}
 else {
boolean forceLegal=mAccessibilityManager.isTouchExplorationEnabled();
mDownDegrees=getDegreesFromCoords(eventX,eventY,forceLegal,isInnerCircle);
if (mDownDegrees != -1) {
mController.tryVibrate();
mHandler.postDelayed(new Runnable(){
@Override public void run(){
mDoingMove=true;
int value=reselectSelector(mDownDegrees,isInnerCircle[0],false,true);
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
,TAP_TIMEOUT);
}
}
return true;
case MotionEvent.ACTION_MOVE:
if (!mInputEnabled) {
Log.e(TAG,""String_Node_Str"");
return true;
}
float dY=Math.abs(eventY - mDownY);
float dX=Math.abs(eventX - mDownX);
if (!mDoingMove && dX <= TOUCH_SLOP && dY <= TOUCH_SLOP) {
break;
}
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
mHandler.removeCallbacksAndMessages(null);
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
if (isTouchingAmOrPm != mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
mIsTouchingAmOrPm=-1;
}
break;
}
if (mDownDegrees == -1) {
break;
}
mDoingMove=true;
mHandler.removeCallbacksAndMessages(null);
degrees=getDegreesFromCoords(eventX,eventY,true,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],false,true);
if (value != mLastValueSelected) {
mController.tryVibrate();
mLastValueSelected=value;
mListener.onValueSelected(getCurrentItemShowing(),value,false);
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mInputEnabled) {
Log.d(TAG,""String_Node_Str"");
mListener.onValueSelected(ENABLE_PICKER_INDEX,1,false);
return true;
}
mHandler.removeCallbacksAndMessages(null);
mDoingTouch=false;
if (mIsTouchingAmOrPm == AM || mIsTouchingAmOrPm == PM) {
int isTouchingAmOrPm=mAmPmCirclesView.getIsTouchingAmOrPm(eventX,eventY);
mAmPmCirclesView.setAmOrPmPressed(-1);
mAmPmCirclesView.invalidate();
if (isTouchingAmOrPm == mIsTouchingAmOrPm) {
mAmPmCirclesView.setAmOrPm(isTouchingAmOrPm);
if (getIsCurrentlyAmOrPm() != isTouchingAmOrPm) {
mListener.onValueSelected(AMPM_INDEX,mIsTouchingAmOrPm,false);
setValueForItem(AMPM_INDEX,isTouchingAmOrPm);
}
}
mIsTouchingAmOrPm=-1;
break;
}
if (mDownDegrees != -1) {
degrees=getDegreesFromCoords(eventX,eventY,mDoingMove,isInnerCircle);
if (degrees != -1) {
value=reselectSelector(degrees,isInnerCircle[0],!mDoingMove,false);
if (getCurrentItemShowing() == HOUR_INDEX && !mIs24HourMode) {
int amOrPm=getIsCurrentlyAmOrPm();
if (amOrPm == AM && value == 12) {
value=0;
}
 else if (amOrPm == PM && value != 12) {
value+=12;
}
}
setValueForItem(getCurrentItemShowing(),value);
mListener.onValueSelected(getCurrentItemShowing(),value,true);
}
}
mDoingMove=false;
return true;
default :
break;
}
return false;
}",0.9949593951274152
113324,"@Override public void onClick(View v){
  mTimePicker.tryVibrate();
  int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
  if (amOrPm == AM) {
    amOrPm=PM;
  }
 else   if (amOrPm == PM) {
    amOrPm=AM;
  }
  updateAmPmDisplay(amOrPm);
  mTimePicker.setAmOrPm(amOrPm);
}","@Override public void onClick(View v){
  tryVibrate();
  int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
  if (amOrPm == AM) {
    amOrPm=PM;
  }
 else   if (amOrPm == PM) {
    amOrPm=AM;
  }
  updateAmPmDisplay(amOrPm);
  mTimePicker.setAmOrPm(amOrPm);
}",0.9770114942528736
113325,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  KeyboardListener keyboardListener=new KeyboardListener();
  view.findViewById(R.id.time_picker_dialog).setOnKeyListener(keyboardListener);
  Resources res=getResources();
  mHourPickerDescription=res.getString(R.string.hour_picker_description);
  mSelectHours=res.getString(R.string.select_hours);
  mMinutePickerDescription=res.getString(R.string.minute_picker_description);
  mSelectMinutes=res.getString(R.string.select_minutes);
  mBlue=res.getColor(R.color.blue);
  mBlack=res.getColor(R.color.numbers_text_color);
  mHourView=(TextView)view.findViewById(R.id.hours);
  mHourView.setOnKeyListener(keyboardListener);
  mHourSpaceView=(TextView)view.findViewById(R.id.hour_space);
  mMinuteSpaceView=(TextView)view.findViewById(R.id.minutes_space);
  mMinuteView=(TextView)view.findViewById(R.id.minutes);
  mMinuteView.setOnKeyListener(keyboardListener);
  mAmPmTextView=(TextView)view.findViewById(R.id.ampm_label);
  mAmPmTextView.setOnKeyListener(keyboardListener);
  String[] amPmTexts=new DateFormatSymbols().getAmPmStrings();
  mAmText=amPmTexts[0];
  mPmText=amPmTexts[1];
  mTimePicker=(RadialPickerLayout)view.findViewById(R.id.time_picker);
  mTimePicker.setOnValueSelectedListener(this);
  mTimePicker.setOnKeyListener(keyboardListener);
  mTimePicker.initialize(getActivity(),mInitialHourOfDay,mInitialMinute,mIs24HourMode);
  int currentItemShowing=HOUR_INDEX;
  if (savedInstanceState != null && savedInstanceState.containsKey(KEY_CURRENT_ITEM_SHOWING)) {
    currentItemShowing=savedInstanceState.getInt(KEY_CURRENT_ITEM_SHOWING);
  }
  setCurrentItemShowing(currentItemShowing,false,true,true);
  mTimePicker.invalidate();
  mHourView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(HOUR_INDEX,true,false,true);
      mTimePicker.tryVibrate();
    }
  }
);
  mMinuteView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(MINUTE_INDEX,true,false,true);
      mTimePicker.tryVibrate();
    }
  }
);
  mDoneButton=(TextView)view.findViewById(R.id.done_button);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mInKbMode && isTypedTimeFullyLegal()) {
        finishKbMode(false);
      }
 else {
        mTimePicker.tryVibrate();
      }
      if (mCallback != null) {
        mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());
      }
      dismiss();
    }
  }
);
  mDoneButton.setOnKeyListener(keyboardListener);
  mAmPmHitspace=view.findViewById(R.id.ampm_hitspace);
  if (mIs24HourMode) {
    mAmPmTextView.setVisibility(View.GONE);
    RelativeLayout.LayoutParams paramsSeparator=new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
    paramsSeparator.addRule(RelativeLayout.CENTER_IN_PARENT);
    TextView separatorView=(TextView)view.findViewById(R.id.separator);
    separatorView.setLayoutParams(paramsSeparator);
  }
 else {
    mAmPmTextView.setVisibility(View.VISIBLE);
    updateAmPmDisplay(mInitialHourOfDay < 12 ? AM : PM);
    mAmPmHitspace.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        mTimePicker.tryVibrate();
        int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
        if (amOrPm == AM) {
          amOrPm=PM;
        }
 else         if (amOrPm == PM) {
          amOrPm=AM;
        }
        updateAmPmDisplay(amOrPm);
        mTimePicker.setAmOrPm(amOrPm);
      }
    }
);
  }
  mAllowAutoAdvance=true;
  setHour(mInitialHourOfDay,true);
  setMinute(mInitialMinute);
  mDoublePlaceholderText=res.getString(R.string.time_placeholder);
  mDeletedKeyFormat=res.getString(R.string.deleted_key);
  mPlaceholderText=mDoublePlaceholderText.charAt(0);
  mAmKeyCode=mPmKeyCode=-1;
  generateLegalTimesTree();
  if (mInKbMode) {
    mTypedTimes=savedInstanceState.getIntegerArrayList(KEY_TYPED_TIMES);
    tryStartingKbMode(-1);
    mHourView.invalidate();
  }
 else   if (mTypedTimes == null) {
    mTypedTimes=new ArrayList<Integer>();
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().getWindow().requestFeature(Window.FEATURE_NO_TITLE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  KeyboardListener keyboardListener=new KeyboardListener();
  view.findViewById(R.id.time_picker_dialog).setOnKeyListener(keyboardListener);
  Resources res=getResources();
  mHourPickerDescription=res.getString(R.string.hour_picker_description);
  mSelectHours=res.getString(R.string.select_hours);
  mMinutePickerDescription=res.getString(R.string.minute_picker_description);
  mSelectMinutes=res.getString(R.string.select_minutes);
  mBlue=res.getColor(R.color.blue);
  mBlack=res.getColor(R.color.numbers_text_color);
  mHourView=(TextView)view.findViewById(R.id.hours);
  mHourView.setOnKeyListener(keyboardListener);
  mHourSpaceView=(TextView)view.findViewById(R.id.hour_space);
  mMinuteSpaceView=(TextView)view.findViewById(R.id.minutes_space);
  mMinuteView=(TextView)view.findViewById(R.id.minutes);
  mMinuteView.setOnKeyListener(keyboardListener);
  mAmPmTextView=(TextView)view.findViewById(R.id.ampm_label);
  mAmPmTextView.setOnKeyListener(keyboardListener);
  String[] amPmTexts=new DateFormatSymbols().getAmPmStrings();
  mAmText=amPmTexts[0];
  mPmText=amPmTexts[1];
  mTimePicker=(RadialPickerLayout)view.findViewById(R.id.time_picker);
  mTimePicker.setOnValueSelectedListener(this);
  mTimePicker.setOnKeyListener(keyboardListener);
  mTimePicker.initialize(getActivity(),this,mInitialHourOfDay,mInitialMinute,mIs24HourMode);
  int currentItemShowing=HOUR_INDEX;
  if (savedInstanceState != null && savedInstanceState.containsKey(KEY_CURRENT_ITEM_SHOWING)) {
    currentItemShowing=savedInstanceState.getInt(KEY_CURRENT_ITEM_SHOWING);
  }
  setCurrentItemShowing(currentItemShowing,false,true,true);
  mTimePicker.invalidate();
  mHapticFeedbackController=new HapticFeedbackController(getActivity());
  mHourView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(HOUR_INDEX,true,false,true);
      tryVibrate();
    }
  }
);
  mMinuteView.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      setCurrentItemShowing(MINUTE_INDEX,true,false,true);
      tryVibrate();
    }
  }
);
  mDoneButton=(TextView)view.findViewById(R.id.done_button);
  mDoneButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mInKbMode && isTypedTimeFullyLegal()) {
        finishKbMode(false);
      }
 else {
        tryVibrate();
      }
      if (mCallback != null) {
        mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());
      }
      dismiss();
    }
  }
);
  mDoneButton.setOnKeyListener(keyboardListener);
  mAmPmHitspace=view.findViewById(R.id.ampm_hitspace);
  if (mIs24HourMode) {
    mAmPmTextView.setVisibility(View.GONE);
    RelativeLayout.LayoutParams paramsSeparator=new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
    paramsSeparator.addRule(RelativeLayout.CENTER_IN_PARENT);
    TextView separatorView=(TextView)view.findViewById(R.id.separator);
    separatorView.setLayoutParams(paramsSeparator);
  }
 else {
    mAmPmTextView.setVisibility(View.VISIBLE);
    updateAmPmDisplay(mInitialHourOfDay < 12 ? AM : PM);
    mAmPmHitspace.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        tryVibrate();
        int amOrPm=mTimePicker.getIsCurrentlyAmOrPm();
        if (amOrPm == AM) {
          amOrPm=PM;
        }
 else         if (amOrPm == PM) {
          amOrPm=AM;
        }
        updateAmPmDisplay(amOrPm);
        mTimePicker.setAmOrPm(amOrPm);
      }
    }
);
  }
  mAllowAutoAdvance=true;
  setHour(mInitialHourOfDay,true);
  setMinute(mInitialMinute);
  mDoublePlaceholderText=res.getString(R.string.time_placeholder);
  mDeletedKeyFormat=res.getString(R.string.deleted_key);
  mPlaceholderText=mDoublePlaceholderText.charAt(0);
  mAmKeyCode=mPmKeyCode=-1;
  generateLegalTimesTree();
  if (mInKbMode) {
    mTypedTimes=savedInstanceState.getIntegerArrayList(KEY_TYPED_TIMES);
    tryStartingKbMode(-1);
    mHourView.invalidate();
  }
 else   if (mTypedTimes == null) {
    mTypedTimes=new ArrayList<Integer>();
  }
  return view;
}",0.9855703160787906
113326,"@Override public FileStatus[] listStatus(Path path) throws IOException {
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Volume xtreemfsVolume=getVolumeFromPath(path);
  final String pathString=preparePath(path,xtreemfsVolume);
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + pathString);
  }
  if (isXtreemFSDirectory(pathString,xtreemfsVolume) == false) {
    if (compareHadoopVersion(new int[]{2,0,0}) >= 0) {
      throw new FileNotFoundException(pathString);
    }
 else     if (compareHadoopVersion(new int[]{1,0,0}) >= 0) {
      return null;
    }
 else     if (compareHadoopVersion(new int[]{0,21,0}) >= 0) {
      throw new FileNotFoundException(pathString);
    }
 else {
      return null;
    }
  }
  DirectoryEntries dirEntries=xtreemfsVolume.readDir(userCredentials,pathString,0,0,false);
  statistics.incrementLargeReadOps(1);
  ArrayList<FileStatus> fileStatus=new ArrayList<FileStatus>(dirEntries.getEntriesCount() - 2);
  for (  DirectoryEntry entry : dirEntries.getEntriesList()) {
    if (entry.getName().equals(""String_Node_Str"") || entry.getName().equals(""String_Node_Str"")) {
      continue;
    }
    final Stat stat=entry.getStbuf();
    final boolean isDir=isXtreemFSDirectory(stat);
    if (isDir) {
      fileStatus.add(new FileStatus(0,true,0,0,(long)(stat.getMtimeNs() / 1e6),(long)(stat.getAtimeNs() / 1e6),new FsPermission((short)stat.getMode()),stat.getUserId(),stat.getGroupId(),new Path(makeAbsolute(path),entry.getName())));
    }
 else {
      Replicas replicas=xtreemfsVolume.listReplicas(userCredentials,pathString);
      fileStatus.add(new FileStatus(stat.getSize(),false,replicas.getReplicasCount(),replicas.getReplicas(0).getStripingPolicy().getStripeSize() * 1024,(long)(stat.getMtimeNs() / 1e6),(long)(stat.getAtimeNs() / 1e6),new FsPermission((short)stat.getMode()),stat.getUserId(),stat.getGroupId(),new Path(makeAbsolute(path),entry.getName())));
    }
  }
  return fileStatus.toArray(new FileStatus[fileStatus.size()]);
}","@Override public FileStatus[] listStatus(Path path) throws IOException {
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Volume xtreemfsVolume=getVolumeFromPath(path);
  final String pathString=preparePath(path,xtreemfsVolume);
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + pathString);
  }
  if (isXtreemFSDirectory(pathString,xtreemfsVolume) == false) {
    if (compareHadoopVersion(new int[]{2,0,0}) >= 0) {
      throw new FileNotFoundException(pathString);
    }
 else     if (compareHadoopVersion(new int[]{1,0,0}) >= 0) {
      return null;
    }
 else     if (compareHadoopVersion(new int[]{0,21,0}) >= 0) {
      throw new FileNotFoundException(pathString);
    }
 else {
      return null;
    }
  }
  DirectoryEntries dirEntries=xtreemfsVolume.readDir(userCredentials,pathString,0,0,false);
  statistics.incrementLargeReadOps(1);
  ArrayList<FileStatus> fileStatus=new ArrayList<FileStatus>(dirEntries.getEntriesCount() - 2);
  for (  DirectoryEntry entry : dirEntries.getEntriesList()) {
    if (entry.getName().equals(""String_Node_Str"") || entry.getName().equals(""String_Node_Str"")) {
      continue;
    }
    final Stat stat=entry.getStbuf();
    final boolean isDir=isXtreemFSDirectory(stat);
    if (isDir) {
      fileStatus.add(new FileStatus(0,true,0,0,(long)(stat.getMtimeNs() / 1e6),(long)(stat.getAtimeNs() / 1e6),new FsPermission((short)stat.getMode()),stat.getUserId(),stat.getGroupId(),new Path(makeAbsolute(path),entry.getName())));
    }
 else {
      Replicas replicas=xtreemfsVolume.listReplicas(userCredentials,pathString + ""String_Node_Str"" + entry.getName());
      fileStatus.add(new FileStatus(stat.getSize(),false,replicas.getReplicasCount(),replicas.getReplicas(0).getStripingPolicy().getStripeSize() * 1024,(long)(stat.getMtimeNs() / 1e6),(long)(stat.getAtimeNs() / 1e6),new FsPermission((short)stat.getMode()),stat.getUserId(),stat.getGroupId(),new Path(makeAbsolute(path),entry.getName())));
    }
  }
  return fileStatus.toArray(new FileStatus[fileStatus.size()]);
}",0.9908477842003852
113327,"/** 
 * saves the request and fetches the object
 */
public void fetchObject(String fileID,long objectNo,XLocations xLoc,Capability capability,CowPolicy cow,final StageRequest rq){
  ReplicatingFile file=this.filesInProgress.get(fileID);
  if (file == null) {
    file=this.lastCompletedFilesCache.get(fileID);
    if (file == null || (file != null && file.hasXLocChanged(xLoc))) {
      file=new ReplicatingFile(fileID,xLoc,capability,cow,master);
    }
    this.filesInProgress.put(fileID,file);
    ReplicatingFile.setMaxObjectsInProgressPerFile(MAX_OBJECTS_IN_PROGRESS_OVERALL / filesInProgress.size());
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileID);
  }
  file.update(capability,xLoc,cow);
  if (file.isObjectInProgress(objectNo)) {
    file.addObjectForReplication(objectNo,rq);
  }
 else {
    file.addObjectForReplication(objectNo,rq);
    try {
      file.replicate();
    }
 catch (    TransferStrategyException e) {
      if (e.getErrorCode() == TransferStrategyException.ErrorCode.NO_OSD_FOUND)       file.reportError(ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"",e.getStackTrace().toString()));
 else       if (e.getErrorCode() == TransferStrategyException.ErrorCode.NO_OSD_REACHABLE)       file.reportError(ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"",e.getStackTrace().toString()));
    }
    if (!file.isReplicating())     fileCompleted(file.fileID);
  }
}","/** 
 * saves the request and fetches the object
 */
public void fetchObject(String fileID,long objectNo,XLocations xLoc,Capability capability,CowPolicy cow,final StageRequest rq){
  ReplicatingFile file=this.filesInProgress.get(fileID);
  if (file == null) {
    file=this.lastCompletedFilesCache.get(fileID);
    if (file == null || (file != null && file.hasXLocChanged(xLoc))) {
      file=new ReplicatingFile(fileID,xLoc,capability,cow,master);
    }
    this.filesInProgress.put(fileID,file);
    ReplicatingFile.setMaxObjectsInProgressPerFile(MAX_OBJECTS_IN_PROGRESS_OVERALL / filesInProgress.size());
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileID);
  }
  file.update(capability,xLoc,cow);
  if (file.isViewOutdated()) {
    file.reportError(ErrorUtils.getErrorResponse(ErrorType.INVALID_VIEW,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
  }
  if (file.isObjectInProgress(objectNo)) {
    file.addObjectForReplication(objectNo,rq);
  }
 else {
    file.addObjectForReplication(objectNo,rq);
    try {
      file.replicate();
    }
 catch (    TransferStrategyException e) {
      if (e.getErrorCode() == TransferStrategyException.ErrorCode.NO_OSD_FOUND)       file.reportError(ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"",e));
 else       if (e.getErrorCode() == TransferStrategyException.ErrorCode.NO_OSD_REACHABLE)       file.reportError(ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"",e));
    }
    if (!file.isReplicating())     fileCompleted(file.fileID);
  }
}",0.9337957124842372
113328,"public ReplicatingFile(String fileID,XLocations xLoc,Capability cap,CowPolicy cow,OSDRequestDispatcher master){
  this.master=master;
  this.osdAvailability=master.getServiceAvailability();
  this.fileID=fileID;
  this.xLoc=xLoc;
  this.cap=cap;
  this.cow=cow;
  this.cancelled=false;
  this.objectsInProgress=new HashMap<Long,ReplicatingObject>();
  this.waitingRequests=new HashMap<Long,ReplicatingObject>();
  StripingPolicyImpl sp=xLoc.getLocalReplica().getStripingPolicy();
  assert(checkEqualStripeSizeOfReplicas(xLoc.getReplicas()));
  this.lastObject=sp.getObjectNoForOffset(xLoc.getXLocSet().getReadOnlyFileSize() - 1);
  if (ReplicationFlags.isRandomStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new RandomStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isSequentialStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new SequentialStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isSequentialPrefetchingStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new SequentialPrefetchingStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isRarestFirstStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new RarestFirstStrategy(fileID,xLoc,osdAvailability);
 else   throw new IllegalArgumentException(""String_Node_Str"" + xLoc.getLocalReplica().getTransferStrategyFlags() + ""String_Node_Str"");
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileID,strategy.getClass().getName());
  isFullReplica=!xLoc.getLocalReplica().isPartialReplica();
  if (isFullReplica) {
    int coloumn=xLoc.getLocalReplica().getOSDs().indexOf(master.getConfig().getUUID());
    Iterator<Long> objectsIt=sp.getObjectsOfOSD(coloumn,0,lastObject);
    while (objectsIt.hasNext()) {
      strategy.addObject(objectsIt.next(),false);
    }
  }
}","public ReplicatingFile(String fileID,XLocations xLoc,Capability cap,CowPolicy cow,OSDRequestDispatcher master){
  this.master=master;
  this.osdAvailability=master.getServiceAvailability();
  this.fileID=fileID;
  this.xLoc=xLoc;
  this.cap=cap;
  this.cow=cow;
  this.cancelled=false;
  this.viewOutdated=false;
  this.objectsInProgress=new HashMap<Long,ReplicatingObject>();
  this.waitingRequests=new HashMap<Long,ReplicatingObject>();
  StripingPolicyImpl sp=xLoc.getLocalReplica().getStripingPolicy();
  assert(checkEqualStripeSizeOfReplicas(xLoc.getReplicas()));
  this.lastObject=sp.getObjectNoForOffset(xLoc.getXLocSet().getReadOnlyFileSize() - 1);
  if (ReplicationFlags.isRandomStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new RandomStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isSequentialStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new SequentialStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isSequentialPrefetchingStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new SequentialPrefetchingStrategy(fileID,xLoc,osdAvailability);
 else   if (ReplicationFlags.isRarestFirstStrategy(xLoc.getLocalReplica().getTransferStrategyFlags()))   strategy=new RarestFirstStrategy(fileID,xLoc,osdAvailability);
 else   throw new IllegalArgumentException(""String_Node_Str"" + xLoc.getLocalReplica().getTransferStrategyFlags() + ""String_Node_Str"");
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileID,strategy.getClass().getName());
  isFullReplica=!xLoc.getLocalReplica().isPartialReplica();
  if (isFullReplica) {
    int coloumn=xLoc.getLocalReplica().getOSDs().indexOf(master.getConfig().getUUID());
    Iterator<Long> objectsIt=sp.getObjectsOfOSD(coloumn,0,lastObject);
    while (objectsIt.hasNext()) {
      strategy.addObject(objectsIt.next(),false);
    }
  }
}",0.9930358524632448
113329,"/** 
 * Sends a RPC for reading the object on another OSD.
 * @param attachObjectSet
 * @throws UnknownUUIDException
 */
private void sendFetchObjectRequest(final long objectNo,final ServiceUUID osd,boolean attachObjectSet) throws UnknownUUIDException, IOException {
  try {
    checkCap();
  }
 catch (  IOException e1) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + e1.getLocalizedMessage(),fileID);
  }
  assert(objectsInProgress.size() <= MAX_MAX_OBJECTS_IN_PROGRESS);
  OSDServiceClient client=master.getOSDClientForReplication();
  FileCredentials fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();
  RPCResponse<InternalReadLocalResponse> response=client.xtreemfs_internal_read_local(osd.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,fileID,objectNo,0,0,xLoc.getLocalReplica().getStripingPolicy().getStripeSizeForObject(objectNo),attachObjectSet,new ArrayList(0));
  response.registerListener(new RPCResponseAvailableListener<InternalReadLocalResponse>(){
    @Override public void responseAvailable(    RPCResponse<InternalReadLocalResponse> r){
      InternalReadLocalResponse internalReadLocalResponse=null;
      try {
        internalReadLocalResponse=r.get();
        ObjectData metadata=internalReadLocalResponse.getData();
        InternalObjectData data=new InternalObjectData(metadata,r.getData());
        ObjectList objectList=null;
        if (internalReadLocalResponse.getObjectSetCount() == 1)         objectList=internalReadLocalResponse.getObjectSet(0);
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,data,objectList,null);
      }
 catch (      PBRPCException e) {
        osdAvailability.setServiceWasNotAvailable(osd);
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,e.getErrorResponse());
      }
catch (      IOException e) {
        osdAvailability.setServiceWasNotAvailable(osd);
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,e.toString()));
      }
catch (      InterruptedException e) {
      }
 finally {
        r.freeBuffers();
      }
    }
  }
);
}","/** 
 * Sends a RPC for reading the object on another OSD.
 * @param attachObjectSet
 * @throws UnknownUUIDException
 */
private void sendFetchObjectRequest(final long objectNo,final ServiceUUID osd,boolean attachObjectSet) throws UnknownUUIDException, IOException {
  try {
    checkCap();
  }
 catch (  IOException e1) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + e1.getLocalizedMessage(),fileID);
  }
  assert(objectsInProgress.size() <= MAX_MAX_OBJECTS_IN_PROGRESS);
  OSDServiceClient client=master.getOSDClientForReplication();
  FileCredentials fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();
  RPCResponse<InternalReadLocalResponse> response=client.xtreemfs_internal_read_local(osd.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,fileID,objectNo,0,0,xLoc.getLocalReplica().getStripingPolicy().getStripeSizeForObject(objectNo),attachObjectSet,new ArrayList(0));
  response.registerListener(new RPCResponseAvailableListener<InternalReadLocalResponse>(){
    @Override public void responseAvailable(    RPCResponse<InternalReadLocalResponse> r){
      InternalReadLocalResponse internalReadLocalResponse=null;
      try {
        internalReadLocalResponse=r.get();
        ObjectData metadata=internalReadLocalResponse.getData();
        InternalObjectData data=new InternalObjectData(metadata,r.getData());
        ObjectList objectList=null;
        if (internalReadLocalResponse.getObjectSetCount() == 1)         objectList=internalReadLocalResponse.getObjectSet(0);
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,data,objectList,null);
      }
 catch (      PBRPCException e) {
        if (e.getErrorType() != ErrorType.INVALID_VIEW) {
          osdAvailability.setServiceWasNotAvailable(osd);
        }
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,e.getErrorResponse());
      }
catch (      IOException e) {
        osdAvailability.setServiceWasNotAvailable(osd);
        master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,e.toString()));
      }
catch (      InterruptedException e) {
      }
 finally {
        r.freeBuffers();
      }
    }
  }
);
}",0.9849072876239758
113330,"/** 
 * updates the capability and XLocations-list, if they are newer
 * @return true, if something has changed
 */
public boolean update(Capability cap,XLocations xLoc,CowPolicy cow){
  boolean changed=false;
  this.cow=cow;
  if (cap.getExpires() > this.cap.getExpires() || cap.getEpochNo() > this.cap.getEpochNo()) {
    this.cap=cap;
    changed=true;
  }
  if (hasXLocChanged(xLoc)) {
    this.xLoc=xLoc;
    this.strategy.updateXLoc(xLoc);
    changed=true;
  }
  return changed;
}","/** 
 * updates the capability and XLocations-list, if they are newer
 * @return true, if something has changed
 */
public boolean update(Capability cap,XLocations xLoc,CowPolicy cow){
  boolean changed=false;
  this.cow=cow;
  if (cap.getExpires() > this.cap.getExpires() || cap.getEpochNo() > this.cap.getEpochNo()) {
    this.cap=cap;
    changed=true;
  }
  if (hasXLocChanged(xLoc)) {
    this.xLoc=xLoc;
    this.strategy.updateXLoc(xLoc);
    this.viewOutdated=false;
    changed=true;
  }
  return changed;
}",0.971086739780658
113331,"@Override public void responseAvailable(RPCResponse<InternalReadLocalResponse> r){
  InternalReadLocalResponse internalReadLocalResponse=null;
  try {
    internalReadLocalResponse=r.get();
    ObjectData metadata=internalReadLocalResponse.getData();
    InternalObjectData data=new InternalObjectData(metadata,r.getData());
    ObjectList objectList=null;
    if (internalReadLocalResponse.getObjectSetCount() == 1)     objectList=internalReadLocalResponse.getObjectSet(0);
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,data,objectList,null);
  }
 catch (  PBRPCException e) {
    osdAvailability.setServiceWasNotAvailable(osd);
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,e.getErrorResponse());
  }
catch (  IOException e) {
    osdAvailability.setServiceWasNotAvailable(osd);
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,e.toString()));
  }
catch (  InterruptedException e) {
  }
 finally {
    r.freeBuffers();
  }
}","@Override public void responseAvailable(RPCResponse<InternalReadLocalResponse> r){
  InternalReadLocalResponse internalReadLocalResponse=null;
  try {
    internalReadLocalResponse=r.get();
    ObjectData metadata=internalReadLocalResponse.getData();
    InternalObjectData data=new InternalObjectData(metadata,r.getData());
    ObjectList objectList=null;
    if (internalReadLocalResponse.getObjectSetCount() == 1)     objectList=internalReadLocalResponse.getObjectSet(0);
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,data,objectList,null);
  }
 catch (  PBRPCException e) {
    if (e.getErrorType() != ErrorType.INVALID_VIEW) {
      osdAvailability.setServiceWasNotAvailable(osd);
    }
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,e.getErrorResponse());
  }
catch (  IOException e) {
    osdAvailability.setServiceWasNotAvailable(osd);
    master.getReplicationStage().internalObjectFetched(fileID,objectNo,osd,null,null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,e.toString()));
  }
catch (  InterruptedException e) {
  }
 finally {
    r.freeBuffers();
  }
}",0.9726148409893992
113332,"private void processInternalObjectFetched(StageRequest rq){
  String fileId=(String)rq.getArgs()[0];
  long objectNo=(Long)rq.getArgs()[1];
  final ServiceUUID usedOSD=(ServiceUUID)rq.getArgs()[2];
  InternalObjectData data=(InternalObjectData)rq.getArgs()[3];
  ObjectList objectList=(ObjectList)rq.getArgs()[4];
  final ErrorResponse error=(ErrorResponse)rq.getArgs()[5];
  if (error != null) {
    if (error.getErrorType() == ErrorType.INVALID_VIEW) {
      disseminationLayer.sendError(fileId,error);
    }
 else {
      disseminationLayer.objectNotFetched(fileId,usedOSD,objectNo,data);
      if (data != null && data.getData() != null)       BufferPool.free(data.getData());
    }
  }
 else {
    if (objectList != null) {
      try {
        ObjectSet objectSet=new ObjectSet(objectList.getStripeWidth(),objectList.getFirst(),objectList.getSet().toByteArray());
        disseminationLayer.objectSetFetched(fileId,usedOSD,objectSet,objectList.getSet().size());
      }
 catch (      IOException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
      }
catch (      ClassNotFoundException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
      }
    }
    if (data != null && data.getData() != null && data.getData().limit() != 0)     disseminationLayer.objectFetched(fileId,objectNo,usedOSD,data);
 else {
      disseminationLayer.objectNotFetched(fileId,usedOSD,objectNo,data);
      if (data != null)       BufferPool.free(data.getData());
    }
  }
}","private void processInternalObjectFetched(StageRequest rq){
  String fileId=(String)rq.getArgs()[0];
  long objectNo=(Long)rq.getArgs()[1];
  final ServiceUUID usedOSD=(ServiceUUID)rq.getArgs()[2];
  InternalObjectData data=(InternalObjectData)rq.getArgs()[3];
  ObjectList objectList=(ObjectList)rq.getArgs()[4];
  final ErrorResponse error=(ErrorResponse)rq.getArgs()[5];
  if (error != null) {
    if (error.getErrorType() == ErrorType.INVALID_VIEW) {
      disseminationLayer.objectNotFetchedBecauseViewError(fileId,usedOSD,objectNo,error);
    }
 else {
      disseminationLayer.objectNotFetchedBecauseError(fileId,usedOSD,objectNo,error);
    }
    if (data != null && data.getData() != null)     BufferPool.free(data.getData());
  }
 else {
    if (objectList != null) {
      try {
        ObjectSet objectSet=new ObjectSet(objectList.getStripeWidth(),objectList.getFirst(),objectList.getSet().toByteArray());
        disseminationLayer.objectSetFetched(fileId,usedOSD,objectSet,objectList.getSet().size());
      }
 catch (      IOException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
      }
catch (      ClassNotFoundException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
      }
    }
    if (data != null && data.getData() != null && data.getData().limit() != 0)     disseminationLayer.objectFetched(fileId,objectNo,usedOSD,data);
 else {
      disseminationLayer.objectNotFetched(fileId,usedOSD,objectNo,data);
      if (data != null)       BufferPool.free(data.getData());
    }
  }
}",0.9730628533422016
113333,"private void processLeaseStateChanged(StageRequest method){
  try {
    final ASCIIString cellId=(ASCIIString)method.getArgs()[0];
    final Flease lease=(Flease)method.getArgs()[1];
    final FleaseException error=(FleaseException)method.getArgs()[2];
    if (error == null) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,cellId,lease);
      }
    }
 else {
      Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",localID,cellId,error);
    }
    final String fileId=cellToFileId.get(cellId);
    if (fileId != null) {
      ReplicatedFileState state=files.get(fileId);
      assert(state != null);
      if (state.isInvalidated()) {
        doInvalidated(state);
      }
      boolean leaseOk=false;
      if (error == null) {
        boolean localIsPrimary=(lease.getLeaseHolder() != null) && (lease.getLeaseHolder().equals(localID));
        ReplicaState oldState=state.getState();
        state.setLocalIsPrimary(localIsPrimary);
        state.setLease(lease);
        if (oldState == ReplicaState.PRIMARY && lease.getLeaseHolder() == null && lease.getLeaseTimeout_ms() == 0) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",localID,cellId,lease,error);
          failed(state,ErrorUtils.getInternalServerError(new IOException(fileId + ""String_Node_Str"")),""String_Node_Str"");
        }
 else {
          if ((oldState == ReplicaState.BACKUP) || (oldState == ReplicaState.PRIMARY) || (oldState == ReplicaState.WAITING_FOR_LEASE)) {
            if (localIsPrimary) {
              if (oldState != ReplicaState.PRIMARY) {
                state.setMasterEpoch(lease.getMasterEpochNumber());
                doPrimary(state);
              }
            }
 else {
              if (oldState != ReplicaState.BACKUP) {
                state.setMasterEpoch(FleaseMessage.IGNORE_MASTER_EPOCH);
                doBackup(state);
              }
            }
          }
        }
      }
 else {
        failed(state,ErrorUtils.getInternalServerError(error),""String_Node_Str"");
      }
    }
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","private void processLeaseStateChanged(StageRequest method){
  try {
    final ASCIIString cellId=(ASCIIString)method.getArgs()[0];
    final Flease lease=(Flease)method.getArgs()[1];
    final FleaseException error=(FleaseException)method.getArgs()[2];
    if (error == null) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,cellId,lease);
      }
    }
 else {
      Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",localID,cellId,error);
    }
    final String fileId=cellToFileId.get(cellId);
    if (fileId != null) {
      ReplicatedFileState state=files.get(fileId);
      assert(state != null);
      if (state.isInvalidated()) {
        doInvalidated(state);
        return;
      }
      boolean leaseOk=false;
      if (error == null) {
        boolean localIsPrimary=(lease.getLeaseHolder() != null) && (lease.getLeaseHolder().equals(localID));
        ReplicaState oldState=state.getState();
        state.setLocalIsPrimary(localIsPrimary);
        state.setLease(lease);
        if (oldState == ReplicaState.PRIMARY && lease.getLeaseHolder() == null && lease.getLeaseTimeout_ms() == 0) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",localID,cellId,lease,error);
          failed(state,ErrorUtils.getInternalServerError(new IOException(fileId + ""String_Node_Str"")),""String_Node_Str"");
        }
 else {
          if ((oldState == ReplicaState.BACKUP) || (oldState == ReplicaState.PRIMARY) || (oldState == ReplicaState.WAITING_FOR_LEASE)) {
            if (localIsPrimary) {
              if (oldState != ReplicaState.PRIMARY) {
                state.setMasterEpoch(lease.getMasterEpochNumber());
                doPrimary(state);
              }
            }
 else {
              if (oldState != ReplicaState.BACKUP) {
                state.setMasterEpoch(FleaseMessage.IGNORE_MASTER_EPOCH);
                doBackup(state);
              }
            }
          }
        }
      }
 else {
        failed(state,ErrorUtils.getInternalServerError(error),""String_Node_Str"");
      }
    }
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9965709387055294
113334,"private void processPrepareOp(StageRequest method){
  final RWReplicationCallback callback=(RWReplicationCallback)method.getCallback();
  try {
    final FileCredentials credentials=(FileCredentials)method.getArgs()[0];
    final XLocations loc=(XLocations)method.getArgs()[1];
    final Long objVersion=(Long)method.getArgs()[3];
    final Operation op=(Operation)method.getArgs()[4];
    final String fileId=credentials.getXcap().getFileId();
    ReplicatedFileState state=getState(credentials,loc,false,false);
    if (state.isInvalidated()) {
      callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
      return;
    }
    if ((op == Operation.INTERNAL_UPDATE) || (op == Operation.INTERNAL_TRUNCATE)) {
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,state.getState());
          }
          if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
            }
            callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
            return;
          }
 else {
            state.addPendingRequest(method);
          }
          return;
        }
case OPEN:
{
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,state.getState());
        }
        if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
          }
          callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
          return;
        }
 else {
          state.addPendingRequest(method);
        }
        doWaitingForLease(state);
        return;
      }
  }
  if (!state.getPolicy().acceptRemoteUpdate(objVersion)) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",objVersion,fileId);
    callback.failed(ErrorUtils.getErrorResponse(ErrorType.IO_ERROR,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str""));
    return;
  }
  boolean needsReset=state.getPolicy().onRemoteUpdate(objVersion,state.getState());
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,needsReset);
  }
  if (needsReset) {
    state.addPendingRequest(method);
    doReset(state,objVersion);
  }
 else {
    callback.success(0);
  }
}
 else {
  state.setCredentials(credentials);
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
      if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
        }
        callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
      }
 else {
        state.addPendingRequest(method);
      }
      return;
    }
case OPEN:
{
    if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
      }
      callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
      return;
    }
 else {
      state.addPendingRequest(method);
    }
    doWaitingForLease(state);
    return;
  }
}
try {
long newVersion=state.getPolicy().onClientOperation(op,objVersion,state.getState(),state.getLease());
callback.success(newVersion);
}
 catch (RedirectToMasterException ex) {
callback.redirect(ex.getMasterUUID());
}
catch (RetryException ex) {
final ErrorResponse err=ErrorUtils.getInternalServerError(ex);
failed(state,err,""String_Node_Str"");
if (state.getState() == ReplicaState.BACKUP || state.getState() == ReplicaState.PRIMARY) {
  callback.failed(err);
}
}
}
}
 catch (Exception ex) {
ex.printStackTrace();
callback.failed(ErrorUtils.getInternalServerError(ex));
}
}","private void processPrepareOp(StageRequest method){
  final RWReplicationCallback callback=(RWReplicationCallback)method.getCallback();
  try {
    final FileCredentials credentials=(FileCredentials)method.getArgs()[0];
    final XLocations loc=(XLocations)method.getArgs()[1];
    final Long objVersion=(Long)method.getArgs()[3];
    final Operation op=(Operation)method.getArgs()[4];
    final String fileId=credentials.getXcap().getFileId();
    ReplicatedFileState state=getState(credentials,loc,false,false);
    if (state.isInvalidated()) {
      callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
      return;
    }
    if ((op == Operation.INTERNAL_UPDATE) || (op == Operation.INTERNAL_TRUNCATE)) {
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
case OPEN:
{
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,state.getState());
          }
          if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
            }
            callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
            return;
          }
 else {
            state.addPendingRequest(method);
          }
          if (state.getState() == ReplicaState.OPEN) {
            doWaitingForLease(state);
          }
          return;
        }
    }
    if (!state.getPolicy().acceptRemoteUpdate(objVersion)) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",objVersion,fileId);
      callback.failed(ErrorUtils.getErrorResponse(ErrorType.IO_ERROR,POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str""));
      return;
    }
    boolean needsReset=state.getPolicy().onRemoteUpdate(objVersion,state.getState());
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,needsReset);
    }
    if (needsReset) {
      state.addPendingRequest(method);
      doReset(state,objVersion);
    }
 else {
      callback.success(0);
    }
  }
 else {
    state.setCredentials(credentials);
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
        if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
          }
          callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
        }
 else {
          state.addPendingRequest(method);
        }
        return;
      }
case OPEN:
{
      if (state.sizeOfPendingRequests() > MAX_PENDING_PER_FILE) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",state.sizeOfPendingRequests(),MAX_PENDING_PER_FILE,fileId);
        }
        callback.failed(ErrorUtils.getErrorResponse(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str""));
        return;
      }
 else {
        state.addPendingRequest(method);
      }
      doWaitingForLease(state);
      return;
    }
}
try {
  long newVersion=state.getPolicy().onClientOperation(op,objVersion,state.getState(),state.getLease());
  callback.success(newVersion);
}
 catch (RedirectToMasterException ex) {
  callback.redirect(ex.getMasterUUID());
}
catch (RetryException ex) {
  final ErrorResponse err=ErrorUtils.getInternalServerError(ex);
  failed(state,err,""String_Node_Str"");
  if (state.getState() == ReplicaState.BACKUP || state.getState() == ReplicaState.PRIMARY) {
    callback.failed(err);
  }
}
}
}
 catch (Exception ex) {
ex.printStackTrace();
callback.failed(ErrorUtils.getInternalServerError(ex));
}
}",0.6083140877598152
113335,"private void fetchObjects(){
  while (numObjsInFlight < MAX_OBJS_IN_FLIGHT) {
    ReplicatedFileState fileInReset=filesInReset.poll();
    if (fileInReset == null)     break;
    ReplicatedFileState file=files.get(fileInReset.getFileId());
    if (file == null || file != fileInReset) {
      continue;
    }
    if (!file.getObjectsToFetch().isEmpty()) {
      ObjectVersionMapping o=file.getObjectsToFetch().remove(0);
      file.incrementNumObjectsPending();
      numObjsInFlight++;
      fetchObject(file,o);
    }
 else {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,file.getFileId());
      doResetComplete(file);
    }
    if (!file.getObjectsToFetch().isEmpty()) {
      filesInReset.add(file);
    }
  }
}","private void fetchObjects(){
  while (numObjsInFlight < MAX_OBJS_IN_FLIGHT) {
    ReplicatedFileState fileInReset=filesInReset.poll();
    if (fileInReset == null)     break;
    ReplicatedFileState file=files.get(fileInReset.getFileId());
    if (file == null || file != fileInReset) {
      continue;
    }
    if (!file.getObjectsToFetch().isEmpty()) {
      ObjectVersionMapping o=file.getObjectsToFetch().remove(0);
      file.incrementNumObjectsPending();
      numObjsInFlight++;
      fetchObject(file,o);
    }
    if (!file.getObjectsToFetch().isEmpty()) {
      filesInReset.add(file);
    }
    if (file.getObjectsToFetch().isEmpty() && file.getNumObjectsPending() == 0) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,file.getFileId());
      doResetComplete(file);
    }
  }
}",0.845771144278607
113336,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_get_file_credentialsRequest rqArgs=(xtreemfs_get_file_credentialsRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  GlobalFileIdResolver gfr=new GlobalFileIdResolver(rqArgs.getFileId());
  final String volId=gfr.getVolumeId();
  final Long localFileID=gfr.getLocalFileId();
  StorageManager sMan=vMan.getStorageManager(volId);
  VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(localFileID);
  if (file == null)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  boolean enableTracing=volume.isTracingEnabled();
  String traceTarget=volume.getTraceTarget();
  String tracingPolicy=volume.getTracingPolicy();
  Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,file),FileAccessManager.O_RDONLY,master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),file.getEpoch(),false,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),enableTracing,traceTarget,tracingPolicy,master.getConfig().getCapabilitySecret());
  XLocSet newXlocSet=null;
  if (file.isReadOnly()) {
    newXlocSet=Converter.xLocListToXLocSet(file.getXLocList()).setReadOnlyFileSize(file.getSize()).build();
  }
 else {
    newXlocSet=Converter.xLocListToXLocSet(file.getXLocList()).build();
  }
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(newXlocSet).build();
  rq.setResponse(fc);
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_get_file_credentialsRequest rqArgs=(xtreemfs_get_file_credentialsRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  GlobalFileIdResolver gfr=new GlobalFileIdResolver(rqArgs.getFileId());
  final String volId=gfr.getVolumeId();
  final Long localFileID=gfr.getLocalFileId();
  StorageManager sMan=vMan.getStorageManager(volId);
  VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(localFileID);
  if (file == null)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  boolean enableTracing=volume.isTracingEnabled();
  String traceTarget=volume.getTraceTarget();
  String tracingPolicy=volume.getTracingPolicy();
  Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,file),FileAccessManager.O_RDONLY,master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),file.getEpoch(),false,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),enableTracing,traceTarget,tracingPolicy,QuotaConstants.UNLIMITED_VOUCHER,0L,master.getConfig().getCapabilitySecret());
  XLocSet newXlocSet=null;
  if (file.isReadOnly()) {
    newXlocSet=Converter.xLocListToXLocSet(file.getXLocList()).setReadOnlyFileSize(file.getSize()).build();
  }
 else {
    newXlocSet=Converter.xLocListToXLocSet(file.getXLocList()).build();
  }
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(newXlocSet).build();
  rq.setResponse(fc);
  finishRequest(rq);
}",0.991236611489776
113337,"/** 
 * Transfers the space information (used & blocked) for a file to the new owner group
 * @param quotaFileInformation
 * @param newOwnerGroupId
 * @param filesize
 * @param blockedSpace
 * @param update
 * @throws UserException
 */
@SuppressWarnings(""String_Node_Str"") public synchronized void transferOwnerGroupSpace(QuotaFileInformation quotaFileInformation,String newOwnerGroupId,long filesize,long blockedSpace,AtomicDBUpdate update) throws UserException {
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  QuotaFileInformation newQuotaFileInformation=new QuotaFileInformation(quotaFileInformation);
  newQuotaFileInformation.setOwnerGroupId(newOwnerGroupId);
  QuotaInformation quotaInformationOldOwnerGroup=getAndApplyQuotaInformation(quotaFileInformation,true,update);
  QuotaInformation quotaInformationNewOwnerGroup=getAndApplyQuotaInformation(newQuotaFileInformation,true,update);
  if (QuotaConstants.checkQuotaOnChown && quotaInformationNewOwnerGroup.getFreeSpace() < (filesize + blockedSpace)) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + quotaInformationNewOwnerGroup.getQuotaType() + ""String_Node_Str"");
  }
  updateGroupSpaceUsage(quotaFileInformation,quotaInformationOldOwnerGroup,-1 * filesize,-1 * blockedSpace,update);
  updateGroupSpaceUsage(newQuotaFileInformation,quotaInformationNewOwnerGroup,filesize,blockedSpace,update);
}","/** 
 * Transfers the space information (used & blocked) for a file to the new owner group
 * @param quotaFileInformation
 * @param newOwnerGroupId
 * @param filesize
 * @param blockedSpace
 * @param update
 * @throws UserException
 */
public synchronized void transferOwnerGroupSpace(QuotaFileInformation quotaFileInformation,String newOwnerGroupId,long filesize,long blockedSpace,AtomicDBUpdate update) throws UserException {
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  QuotaFileInformation newQuotaFileInformation=new QuotaFileInformation(quotaFileInformation);
  newQuotaFileInformation.setOwnerGroupId(newOwnerGroupId);
  QuotaInformation quotaInformationOldOwnerGroup=getAndApplyGroupQuotaInformation(null,quotaFileInformation,true,update);
  QuotaInformation quotaInformationNewOwnerGroup=getAndApplyGroupQuotaInformation(null,newQuotaFileInformation,true,update);
  System.out.println(""String_Node_Str"" + quotaFileInformation.getOwnerId());
  System.out.println(""String_Node_Str"" + quotaFileInformation.getOwnerGroupId() + ""String_Node_Str""+ newOwnerGroupId);
  System.out.println(""String_Node_Str"" + quotaInformationNewOwnerGroup.getFreeSpace() + ""String_Node_Str""+ filesize+ ""String_Node_Str""+ blockedSpace);
  if (QuotaConstants.checkQuotaOnChown && quotaInformationNewOwnerGroup.getFreeSpace() < (filesize + blockedSpace)) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + quotaInformationNewOwnerGroup.getQuotaType() + ""String_Node_Str"");
  }
  updateGroupSpaceUsage(quotaFileInformation,quotaInformationOldOwnerGroup,-1 * filesize,-1 * blockedSpace,update);
  updateGroupSpaceUsage(newQuotaFileInformation,quotaInformationNewOwnerGroup,filesize,blockedSpace,update);
}",0.8739076154806492
113338,"/** 
 * Transfers the space information (used & blocked) for a file to the new owner
 * @param quotaFileInformation
 * @param newOwnerId
 * @param filesize
 * @param blockedSpace
 * @param update
 * @throws UserException
 */
@SuppressWarnings(""String_Node_Str"") public synchronized void transferOwnerSpace(QuotaFileInformation quotaFileInformation,String newOwnerId,long filesize,long blockedSpace,AtomicDBUpdate update) throws UserException {
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  QuotaFileInformation newQuotaFileInformation=new QuotaFileInformation(quotaFileInformation);
  newQuotaFileInformation.setOwnerId(newOwnerId);
  QuotaInformation quotaInformationOldOwner=getAndApplyQuotaInformation(quotaFileInformation,true,update);
  QuotaInformation quotaInformationNewOwner=getAndApplyQuotaInformation(newQuotaFileInformation,true,update);
  if (QuotaConstants.checkQuotaOnChown && quotaInformationNewOwner.getFreeSpace() < (filesize + blockedSpace)) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + quotaInformationNewOwner.getQuotaType() + ""String_Node_Str"");
  }
  updateUserSpaceUsage(quotaFileInformation,quotaInformationOldOwner,-1 * filesize,-1 * blockedSpace,update);
  updateUserSpaceUsage(newQuotaFileInformation,quotaInformationNewOwner,filesize,blockedSpace,update);
}","/** 
 * Transfers the space information (used & blocked) for a file to the new owner
 * @param quotaFileInformation
 * @param newOwnerId
 * @param filesize
 * @param blockedSpace
 * @param update
 * @throws UserException
 */
public synchronized void transferOwnerSpace(QuotaFileInformation quotaFileInformation,String newOwnerId,long filesize,long blockedSpace,AtomicDBUpdate update) throws UserException {
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  QuotaFileInformation newQuotaFileInformation=new QuotaFileInformation(quotaFileInformation);
  newQuotaFileInformation.setOwnerId(newOwnerId);
  QuotaInformation quotaInformationOldOwner=getAndApplyUserQuotaInformation(null,quotaFileInformation,true,update);
  QuotaInformation quotaInformationNewOwner=getAndApplyUserQuotaInformation(null,newQuotaFileInformation,true,update);
  System.out.println(""String_Node_Str"" + quotaFileInformation.getOwnerId() + ""String_Node_Str""+ newOwnerId);
  System.out.println(""String_Node_Str"" + quotaFileInformation.getOwnerGroupId());
  System.out.println(""String_Node_Str"" + quotaInformationNewOwner.getFreeSpace() + ""String_Node_Str""+ filesize+ ""String_Node_Str""+ blockedSpace);
  if (QuotaConstants.checkQuotaOnChown && quotaInformationNewOwner.getFreeSpace() < (filesize + blockedSpace)) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + quotaInformationNewOwner.getQuotaType() + ""String_Node_Str"");
  }
  updateUserSpaceUsage(quotaFileInformation,quotaInformationOldOwner,-1 * filesize,-1 * blockedSpace,update);
  updateUserSpaceUsage(newQuotaFileInformation,quotaInformationNewOwner,filesize,blockedSpace,update);
}",0.8721461187214612
113339,"/** 
 * Gets all quota information, applies the default user and group quota and saves them, if it has to.
 * @param quotaFileInformation
 * @param saveAppliedDefaultQuota
 * @param update
 * @return
 * @throws UserException
 */
private QuotaInformation getAndApplyQuotaInformation(QuotaFileInformation quotaFileInformation,boolean saveAppliedDefaultQuota,AtomicDBUpdate update) throws UserException {
  QuotaInformation quotaInformation=null;
  try {
    boolean userQuotaDefined=false, groupQuotaDefined=false;
    String ownerId=quotaFileInformation.getOwnerId();
    String ownerGroupId=quotaFileInformation.getOwnerGroupId();
    long userQuota=volStorageManager.getUserQuota(ownerId);
    long groupQuota=volStorageManager.getGroupQuota(ownerGroupId);
    quotaInformation=new QuotaInformation(volumeQuota,userQuota,groupQuota);
    long volumeUsedSpace=volStorageManager.getVolumeUsedSpace();
    quotaInformation.setVolumeUsedSpace(volumeUsedSpace);
    if (volumeQuota != QuotaConstants.unlimitedQuota) {
      long volumeBlockedSpace=volStorageManager.getVolumeBlockedSpace();
      quotaInformation.setVolumeBlockedSpace(volumeBlockedSpace);
      long volumeFreeSpace=volumeQuota - (volumeUsedSpace + volumeBlockedSpace);
      if (volumeFreeSpace < quotaInformation.getFreeSpace()) {
        quotaInformation.setFreeSpace(volumeFreeSpace);
        quotaInformation.setQuotaType(""String_Node_Str"");
      }
    }
    if (userQuota == QuotaConstants.noQuota) {
      userQuota=volumeDefaultUserQuota;
      quotaInformation.setUserQuota(userQuota);
      userQuotaDefined=true;
    }
    long userUsedSpace=volStorageManager.getUserUsedSpace(ownerId);
    quotaInformation.setUserUsedSpace(userUsedSpace);
    if (userQuota != QuotaConstants.unlimitedQuota) {
      long userBlockedSpace=volStorageManager.getUserBlockedSpace(ownerId);
      quotaInformation.setUserBlockedSpace(userBlockedSpace);
      long userFreeSpace=userQuota - (userUsedSpace + userBlockedSpace);
      if (userFreeSpace < quotaInformation.getFreeSpace()) {
        quotaInformation.setFreeSpace(userFreeSpace);
        quotaInformation.setQuotaType(""String_Node_Str"");
      }
    }
    if (groupQuota == QuotaConstants.noQuota) {
      groupQuota=volumeDefaultGroupQuota;
      quotaInformation.setGroupQuota(groupQuota);
      groupQuotaDefined=true;
    }
    long groupUsedSpace=volStorageManager.getGroupUsedSpace(ownerGroupId);
    quotaInformation.setGroupUsedSpace(groupUsedSpace);
    if (groupQuota != QuotaConstants.unlimitedQuota) {
      long groupBlockedSpace=volStorageManager.getGroupBlockedSpace(ownerGroupId);
      quotaInformation.setGroupBlockedSpace(groupBlockedSpace);
      long groupFreeSpace=groupQuota - (groupUsedSpace + groupBlockedSpace);
      if (groupFreeSpace < quotaInformation.getFreeSpace()) {
        quotaInformation.setFreeSpace(groupFreeSpace);
        quotaInformation.setQuotaType(""String_Node_Str"");
      }
    }
    if (saveAppliedDefaultQuota) {
      if (userQuota != QuotaConstants.unlimitedQuota && userQuotaDefined) {
        volStorageManager.setUserQuota(ownerId,userQuota,update);
      }
      if (groupQuota != QuotaConstants.unlimitedQuota && groupQuotaDefined) {
        volStorageManager.setGroupQuota(ownerGroupId,groupQuota,update);
      }
    }
  }
 catch (  DatabaseException e) {
    Logging.logError(Logging.LEVEL_ERROR,""String_Node_Str"",e);
    throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"");
  }
  return quotaInformation;
}","/** 
 * Gets all quota information, applies the default user and group quota and saves them, if it has to.
 * @param quotaFileInformation
 * @param saveAppliedDefaultQuota
 * @param update
 * @return
 * @throws UserException
 */
private QuotaInformation getAndApplyQuotaInformation(QuotaFileInformation quotaFileInformation,boolean saveAppliedDefaultQuota,AtomicDBUpdate update) throws UserException {
  QuotaInformation quotaInformation=new QuotaInformation(volumeQuota,0,0);
  quotaInformation=getAndApplyVolumeQuotaInformation(quotaInformation,quotaFileInformation,saveAppliedDefaultQuota,update);
  quotaInformation=getAndApplyUserQuotaInformation(quotaInformation,quotaFileInformation,saveAppliedDefaultQuota,update);
  quotaInformation=getAndApplyGroupQuotaInformation(quotaInformation,quotaFileInformation,saveAppliedDefaultQuota,update);
  return quotaInformation;
}",0.2235428571428571
113340,"@Test @Ignore(""String_Node_Str"") public void testReplicaOpenFile() throws Exception {
  final String VOLUME_NAME=VOLUMENAME + ""String_Node_Str"";
  Options options=new Options();
  Client client=ClientFactory.createClient(ClientType.NATIVE,dirAddress,userCredentials,null,options);
  client.start();
  String voucherSize=""String_Node_Str"";
  String voucherSize2X=""String_Node_Str"";
  String fileSize=""String_Node_Str"";
  String fileSize2X=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,VOLUME_NAME);
  Volume volume=client.openVolume(VOLUME_NAME,null,options);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"",voucherSize,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  boolean error, firstPass;
  String quotaWithVoucher=""String_Node_Str"";
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"",quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME,quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME,quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  FileHandle fileHandle;
{
    fileHandle=volume.openFile(userCredentials,FILEPATH,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber(),0777);
    fileHandle.write(userCredentials,getContent(fileSize).getBytes(),Integer.parseInt(fileSize),0);
    fileHandle.close();
  }
  fileHandle=volume.openFile(userCredentials,FILEPATH,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
{
    error=false;
    firstPass=false;
    try {
      addReplicas(volume,FILEPATH,1);
      assertEquals(fileSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
      assertEquals(fileSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
      assertEquals(voucherSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
      assertEquals(voucherSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
      firstPass=true;
      addReplicas(volume,FILEPATH,1);
    }
 catch (    PosixErrorException e) {
      if (e.getPosixError().equals(POSIXErrno.POSIX_ERROR_ENOSPC)) {
        error=firstPass;
      }
    }
 finally {
      assertTrue(error);
    }
    Replicas listReplicas=volume.listReplicas(userCredentials,FILEPATH);
    assertEquals(2,listReplicas.getReplicasCount());
    String osdUuid1=listReplicas.getReplicas(0).getOsdUuids(0);
    volume.removeReplica(userCredentials,FILEPATH,osdUuid1);
    assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
    assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
    assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
    assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  }
  fileHandle.close();
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  volume.unlink(userCredentials,FILEPATH);
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  client.deleteVolume(mrcAddress,auth,userCredentials,VOLUME_NAME);
  client.shutdown();
}","@Test public void testReplicaOpenFile() throws Exception {
  final String VOLUME_NAME=VOLUMENAME + ""String_Node_Str"";
  Options options=new Options();
  Client client=ClientFactory.createClient(ClientType.NATIVE,dirAddress,userCredentials,null,options);
  client.start();
  String voucherSize=""String_Node_Str"";
  String voucherSize2X=""String_Node_Str"";
  String fileSize=""String_Node_Str"";
  String fileSize2X=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,VOLUME_NAME);
  Volume volume=client.openVolume(VOLUME_NAME,null,options);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"",voucherSize,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  boolean error, firstPass;
  String quotaWithVoucher=""String_Node_Str"";
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"",quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME,quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  volume.setXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME,quotaWithVoucher,XATTR_FLAGS.XATTR_FLAGS_CREATE);
  FileHandle fileHandle;
{
    fileHandle=volume.openFile(userCredentials,FILEPATH,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber(),0777);
    fileHandle.write(userCredentials,getContent(fileSize).getBytes(),Integer.parseInt(fileSize),0);
    fileHandle.close();
  }
  fileHandle=volume.openFile(userCredentials,FILEPATH,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
{
    error=false;
    firstPass=false;
    try {
      addReplicas(volume,FILEPATH,1);
      assertEquals(fileSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
      assertEquals(fileSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
      assertEquals(voucherSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
      assertEquals(voucherSize2X,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
      firstPass=true;
      addReplicas(volume,FILEPATH,1);
    }
 catch (    PosixErrorException e) {
      if (e.getPosixError().equals(POSIXErrno.POSIX_ERROR_ENOSPC)) {
        error=firstPass;
      }
    }
 finally {
      assertTrue(error);
    }
    Replicas listReplicas=volume.listReplicas(userCredentials,FILEPATH);
    assertEquals(2,listReplicas.getReplicasCount());
    String osdUuid1=listReplicas.getReplicas(0).getOsdUuids(0);
    volume.removeReplica(userCredentials,FILEPATH,osdUuid1);
    assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
    assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
    assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
    assertEquals(voucherSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  }
  fileHandle.close();
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(fileSize,volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  volume.unlink(userCredentials,FILEPATH);
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + USERNAME));
  assertEquals(""String_Node_Str"",volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"" + GROUPNAME));
  client.deleteVolume(mrcAddress,auth,userCredentials,VOLUME_NAME);
  client.shutdown();
}",0.9969202691912856
113341,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cvRequest.toString());
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  long truncateEpoch=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    if (truncateEpoch == -1) {
      osdFinalizeVouchersResponse.getTruncateEpoch();
    }
 else     if (truncateEpoch != osdFinalizeVouchersResponse.getTruncateEpoch()) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"" + truncateEpoch);
    }
    if (osdFinalizeVouchersResponse.getSizeInBytes() > newFileSizeMax) {
      newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    }
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  GlobalFileIdResolver globalFileIdResolver=new GlobalFileIdResolver(cap.getFileId());
  StorageManager sMan=master.getVolumeManager().getStorageManager(globalFileIdResolver.getVolumeId());
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata metadata=sMan.getMetadata(globalFileIdResolver.getLocalFileId());
  QuotaFileInformation quotaFileInformation=new QuotaFileInformation(globalFileIdResolver.getVolumeId(),metadata);
  master.getMrcVoucherManager().clearVouchers(quotaFileInformation,cap.getClientIdentity(),expireTimeSet,newFileSizeMax,update);
  rq.setResponse(emptyResponse.getDefaultInstance());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cvRequest.toString());
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  long truncateEpoch=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    if (truncateEpoch == -1) {
      osdFinalizeVouchersResponse.getTruncateEpoch();
    }
 else     if (truncateEpoch != osdFinalizeVouchersResponse.getTruncateEpoch()) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"" + truncateEpoch);
    }
    if (osdFinalizeVouchersResponse.getSizeInBytes() > newFileSizeMax) {
      newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    }
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  GlobalFileIdResolver globalFileIdResolver=new GlobalFileIdResolver(cap.getFileId());
  StorageManager sMan=master.getVolumeManager().getStorageManager(globalFileIdResolver.getVolumeId());
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata metadata=sMan.getMetadata(globalFileIdResolver.getLocalFileId());
  if (metadata != null) {
    QuotaFileInformation quotaFileInformation=new QuotaFileInformation(globalFileIdResolver.getVolumeId(),metadata);
    master.getMrcVoucherManager().clearVouchers(quotaFileInformation,cap.getClientIdentity(),expireTimeSet,newFileSizeMax,update);
  }
  rq.setResponse(emptyResponse.getDefaultInstance());
  update.execute();
}",0.9943181818181818
113342,"private void processWrite(StageRequest rq){
  final WriteObjectCallback cback=(WriteObjectCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final long objNo=(Long)rq.getArgs()[1];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[2];
    int offset=(Integer)rq.getArgs()[3];
    final ReusableBuffer data=(ReusableBuffer)rq.getArgs()[4];
    final CowPolicy cow=(CowPolicy)rq.getArgs()[5];
    final XLocations xloc=(XLocations)rq.getArgs()[6];
    final boolean gMaxOff=(Boolean)rq.getArgs()[7];
    final boolean syncWrite=(Boolean)rq.getArgs()[8];
    final Long newVersionArg=(Long)rq.getArgs()[9];
    final int dataLength=data.remaining();
    final int stripeSize=sp.getStripeSizeForObject(objNo);
    final FileMetadata fi=layout.getFileMetadata(sp,fileId);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,objNo,fi.getLastObjectNumber(),dataLength,offset);
    }
    final int dataCapacity=data.capacity();
    if (offset + dataCapacity > stripeSize) {
      BufferPool.free(data);
      cback.writeComplete(null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + offset + ""String_Node_Str""+ dataCapacity+ ""String_Node_Str""+ stripeSize+ ""String_Node_Str""));
      return;
    }
    cow.initCowFlagsIfRequired(fi.getLastObjectNumber() + 1);
    long largestV=fi.getLargestObjectVersion(objNo);
    final boolean isCow=cow.isCOW((int)objNo);
    long newVersion=(isCow || checksumsEnabled) ? largestV + 1 : Math.max(1,largestV);
    if (newVersionArg != null) {
      newVersion=newVersionArg;
    }
    assert(data != null);
    if (objNo > fi.getLastObjectNumber()) {
      fi.setLastObjectNumber(objNo);
    }
    layout.writeObject(fileId,fi,data,objNo,offset,newVersion,syncWrite,isCow);
    if (cow.cowEnabled() && (isCow || largestV == 0))     layout.updateCurrentObjVersion(fileId,objNo,newVersion);
    if (isCow)     cow.objectChanged((int)objNo);
    OSDWriteResponse.Builder response=OSDWriteResponse.newBuilder();
    if (objNo >= fi.getLastObjectNumber() && !gMaxOff) {
      long newObjSize=dataLength + offset;
      long newFS=0;
      if (objNo > 0) {
        newFS=sp.getObjectEndOffset(objNo - 1) + 1 + newObjSize;
      }
 else {
        newFS=newObjSize;
      }
      if (newFS < fi.getFilesize()) {
        newFS=fi.getFilesize();
      }
      if (newFS > fi.getFilesize() && objNo >= fi.getLastObjectNumber() && objNo >= fi.getGlobalLastObjectNumber()) {
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",newFS);
        response.setSizeInBytes(newFS);
        response.setTruncateEpoch((int)fi.getTruncateEpoch());
      }
 else {
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",newFS,fi.getFilesize(),fi.getLastObjectNumber(),objNo);
      }
      fi.setFilesize(newFS);
      if (objNo > fi.getLastObjectNumber()) {
        if (objNo > fi.getGlobalLastObjectNumber()) {
          final List<ServiceUUID> osds=xloc.getLocalReplica().getOSDs();
          final ServiceUUID localUUID=master.getConfig().getUUID();
          if (osds.size() > 1) {
            RPCHeader.RequestHeader rqHdr=RPCHeader.RequestHeader.newBuilder().setAuthData(RPCAuthentication.authNone).setUserCreds(RPCAuthentication.userService).setInterfaceId(OSDServiceConstants.INTERFACE_ID).setProcId(OSDServiceConstants.PROC_ID_XTREEMFS_BROADCAST_GMAX).build();
            RPCHeader header=RPCHeader.newBuilder().setCallId(0).setMessageType(MessageType.RPC_REQUEST).setRequestHeader(rqHdr).build();
            xtreemfs_broadcast_gmaxRequest gmaxRq=xtreemfs_broadcast_gmaxRequest.newBuilder().setFileId(fileId).setTruncateEpoch(fi.getTruncateEpoch()).setLastObject(objNo).build();
            for (            ServiceUUID osd : osds) {
              if (!osd.equals(localUUID)) {
                master.sendUDPMessage(header,gmaxRq,osd.getAddress());
              }
            }
          }
        }
      }
    }
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fi.getLastObjectNumber(),fi.getGlobalLastObjectNumber());
    cback.writeComplete(response.build(),null);
  }
 catch (  IOException ex) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.storage,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
    cback.writeComplete(null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,ex.toString()));
  }
}","private void processWrite(StageRequest rq){
  final WriteObjectCallback cback=(WriteObjectCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final long objNo=(Long)rq.getArgs()[1];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[2];
    int offset=(Integer)rq.getArgs()[3];
    final ReusableBuffer data=(ReusableBuffer)rq.getArgs()[4];
    final CowPolicy cow=(CowPolicy)rq.getArgs()[5];
    final XLocations xloc=(XLocations)rq.getArgs()[6];
    final boolean gMaxOff=(Boolean)rq.getArgs()[7];
    final boolean syncWrite=(Boolean)rq.getArgs()[8];
    final Long newVersionArg=(Long)rq.getArgs()[9];
    final int dataLength=data.remaining();
    final int stripeSize=sp.getStripeSizeForObject(objNo);
    final FileMetadata fi=layout.getFileMetadata(sp,fileId);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,objNo,fi.getLastObjectNumber(),dataLength,offset);
    }
    final int dataCapacity=data.capacity();
    if (offset + dataCapacity > stripeSize) {
      BufferPool.free(data);
      cback.writeComplete(null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + offset + ""String_Node_Str""+ dataCapacity+ ""String_Node_Str""+ stripeSize+ ""String_Node_Str""));
      return;
    }
    cow.initCowFlagsIfRequired(fi.getLastObjectNumber() + 1);
    long largestV=fi.getLargestObjectVersion(objNo);
    final boolean isCow=cow.isCOW((int)objNo);
    long newVersion=(isCow || checksumsEnabled) ? largestV + 1 : Math.max(1,largestV);
    if (newVersionArg != null) {
      newVersion=newVersionArg;
    }
    assert(data != null);
    if (objNo > fi.getLastObjectNumber()) {
      fi.setLastObjectNumber(objNo);
    }
    layout.writeObject(fileId,fi,data,objNo,offset,newVersion,syncWrite,isCow);
    if (cow.cowEnabled() && (isCow || largestV == 0))     layout.updateCurrentObjVersion(fileId,objNo,newVersion);
    if (isCow)     cow.objectChanged((int)objNo);
    OSDWriteResponse.Builder response=OSDWriteResponse.newBuilder();
    if (objNo >= fi.getLastObjectNumber()) {
      long newObjSize=dataLength + offset;
      long newFS=0;
      if (objNo > 0) {
        newFS=sp.getObjectEndOffset(objNo - 1) + 1 + newObjSize;
      }
 else {
        newFS=newObjSize;
      }
      if (newFS < fi.getFilesize()) {
        newFS=fi.getFilesize();
      }
      if (newFS > fi.getFilesize() && objNo >= fi.getLastObjectNumber() && objNo >= fi.getGlobalLastObjectNumber()) {
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",newFS);
        response.setSizeInBytes(newFS);
        response.setTruncateEpoch((int)fi.getTruncateEpoch());
      }
 else {
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",newFS,fi.getFilesize(),fi.getLastObjectNumber(),objNo);
      }
      fi.setFilesize(newFS);
      if (objNo > fi.getLastObjectNumber() && !gMaxOff) {
        if (objNo > fi.getGlobalLastObjectNumber()) {
          final List<ServiceUUID> osds=xloc.getLocalReplica().getOSDs();
          final ServiceUUID localUUID=master.getConfig().getUUID();
          if (osds.size() > 1) {
            RPCHeader.RequestHeader rqHdr=RPCHeader.RequestHeader.newBuilder().setAuthData(RPCAuthentication.authNone).setUserCreds(RPCAuthentication.userService).setInterfaceId(OSDServiceConstants.INTERFACE_ID).setProcId(OSDServiceConstants.PROC_ID_XTREEMFS_BROADCAST_GMAX).build();
            RPCHeader header=RPCHeader.newBuilder().setCallId(0).setMessageType(MessageType.RPC_REQUEST).setRequestHeader(rqHdr).build();
            xtreemfs_broadcast_gmaxRequest gmaxRq=xtreemfs_broadcast_gmaxRequest.newBuilder().setFileId(fileId).setTruncateEpoch(fi.getTruncateEpoch()).setLastObject(objNo).build();
            for (            ServiceUUID osd : osds) {
              if (!osd.equals(localUUID)) {
                master.sendUDPMessage(header,gmaxRq,osd.getAddress());
              }
            }
          }
        }
      }
    }
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fi.getLastObjectNumber(),fi.getGlobalLastObjectNumber());
    cback.writeComplete(response.build(),null);
  }
 catch (  IOException ex) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.storage,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
    cback.writeComplete(null,ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EIO,ex.toString()));
  }
}",0.9974025974025974
113343,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  final Path sp=new Path(rqArgs.getVolumeName(),rqArgs.getSourcePath());
  final StorageManager sMan=vMan.getStorageManagerByName(sp.getComp(0));
  final PathResolver sRes=new PathResolver(sMan,sp);
  final VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  Path tp=new Path(rqArgs.getVolumeName(),rqArgs.getTargetPath());
  if (sp.getCompCount() == 1)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"");
  if (!sp.getComp(0).equals(tp.getComp(0)))   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"");
  sRes.checkIfFileDoesNotExist();
  faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  FileMetadata source=sRes.getFile();
  FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  PathResolver tRes=null;
  tRes=new PathResolver(sMan,tp);
  FileMetadata targetParentDir=tRes.getParentDir();
  if (targetParentDir == null || !targetParentDir.isDirectory())   throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
  FileMetadata target=tRes.getFile();
  FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
  FileCredentials.Builder creds=null;
  if (sp.equals(tp)) {
    rq.setResponse(buildResponse(0,creds));
    finishRequest(rq);
    return;
  }
  faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  int time=(int)(TimeSync.getGlobalTime() / 1000);
switch (sourceType) {
case dir:
{
      if (tp.isSubDirOf(sp))       throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
          relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case dir:
{
        faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        DatabaseResultSet<FileMetadata> children=sMan.getChildren(target.getId(),0,Integer.MAX_VALUE);
        boolean hasChildren=children.hasNext();
        children.destroy();
        if (hasChildren)         throw new UserException(POSIXErrno.POSIX_ERROR_ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else {
          FileMetadata metadata=sMan.getMetadata(tRes.getParentDirId(),tRes.getFileName());
          QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),metadata);
          master.getMrcVoucherManager().deleteFile(quotaFileInformation,update);
          sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
        }
        relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
        break;
      }
case file:
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
break;
}
case file:
{
switch (targetType) {
case nexists:
{
  relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
  break;
}
case dir:
{
throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,tRes.getFile(),tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
if (sMan.getSoftlinkTarget(target.getId()) == null && target.getLinkCount() == 1) {
Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,target),FileAccessManager.NON_POSIX_DELETE,master.getConfig().getCapabilityTimeout(),Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),target.getEpoch(),false,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),master.getConfig().getCapabilitySecret());
creds=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(Converter.xLocListToXLocSet(target.getXLocList()));
}
FileMetadata metadata=sMan.getMetadata(tRes.getParentDirId(),tRes.getFileName());
QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),metadata);
master.getMrcVoucherManager().deleteFile(quotaFileInformation,update);
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,time,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,time,update);
rq.setResponse(buildResponse(time,creds));
update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  final Path sp=new Path(rqArgs.getVolumeName(),rqArgs.getSourcePath());
  final StorageManager sMan=vMan.getStorageManagerByName(sp.getComp(0));
  final PathResolver sRes=new PathResolver(sMan,sp);
  final VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  Path tp=new Path(rqArgs.getVolumeName(),rqArgs.getTargetPath());
  if (sp.getCompCount() == 1)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"");
  if (!sp.getComp(0).equals(tp.getComp(0)))   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"");
  sRes.checkIfFileDoesNotExist();
  faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  FileMetadata source=sRes.getFile();
  FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  PathResolver tRes=null;
  tRes=new PathResolver(sMan,tp);
  FileMetadata targetParentDir=tRes.getParentDir();
  if (targetParentDir == null || !targetParentDir.isDirectory())   throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
  FileMetadata target=tRes.getFile();
  FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
  FileCredentials.Builder creds=null;
  if (sp.equals(tp)) {
    rq.setResponse(buildResponse(0,creds));
    finishRequest(rq);
    return;
  }
  faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  int time=(int)(TimeSync.getGlobalTime() / 1000);
switch (sourceType) {
case dir:
{
      if (tp.isSubDirOf(sp))       throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
          relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case dir:
{
        faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        DatabaseResultSet<FileMetadata> children=sMan.getChildren(target.getId(),0,Integer.MAX_VALUE);
        boolean hasChildren=children.hasNext();
        children.destroy();
        if (hasChildren)         throw new UserException(POSIXErrno.POSIX_ERROR_ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else {
          sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
        }
        relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
        break;
      }
case file:
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
break;
}
case file:
{
switch (targetType) {
case nexists:
{
  relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
  break;
}
case dir:
{
throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,tRes.getFile(),tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
if (sMan.getSoftlinkTarget(target.getId()) == null && target.getLinkCount() == 1) {
Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,target),FileAccessManager.NON_POSIX_DELETE,master.getConfig().getCapabilityTimeout(),Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),target.getEpoch(),false,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),master.getConfig().getCapabilitySecret());
creds=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(Converter.xLocListToXLocSet(target.getXLocList()));
}
FileMetadata metadata=sMan.getMetadata(tRes.getParentDirId(),tRes.getFileName());
QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),metadata);
master.getMrcVoucherManager().deleteFile(quotaFileInformation,update);
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
relink(sMan,sRes.getParentDirId(),sRes.getFileName(),source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,time,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,time,update);
rq.setResponse(buildResponse(time,creds));
update.execute();
}",0.9769500584599966
113344,"@Override public void setGroupBlockedSpace(String groupId,Long blockedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && groupId.isEmpty());
  setOwnerQuotaInfo(groupId,blockedSpace,OwnerType.GROUP,QuotaInfo.BLOCKED,update);
}","@Override public void setGroupBlockedSpace(String groupId,Long blockedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && !groupId.isEmpty());
  setOwnerQuotaInfo(groupId,blockedSpace,OwnerType.GROUP,QuotaInfo.BLOCKED,update);
}",0.9980732177263968
113345,"@Override public void setUserUsedSpace(String userId,Long usedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && userId.isEmpty());
  setOwnerQuotaInfo(userId,usedSpace,OwnerType.USER,QuotaInfo.USED,update);
}","@Override public void setUserUsedSpace(String userId,Long usedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && !userId.isEmpty());
  setOwnerQuotaInfo(userId,usedSpace,OwnerType.USER,QuotaInfo.USED,update);
}",0.9979296066252588
113346,"@Override public void setUserQuota(String userId,Long quota,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && userId.isEmpty());
  setOwnerQuotaInfo(userId,quota,OwnerType.USER,QuotaInfo.QUOTA,update);
}","@Override public void setUserQuota(String userId,Long quota,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && !userId.isEmpty());
  setOwnerQuotaInfo(userId,quota,OwnerType.USER,QuotaInfo.QUOTA,update);
}",0.9978308026030368
113347,"@Override public void setGroupQuota(String groupId,Long quota,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && groupId.isEmpty());
  setOwnerQuotaInfo(groupId,quota,OwnerType.GROUP,QuotaInfo.QUOTA,update);
}","@Override public void setGroupQuota(String groupId,Long quota,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && !groupId.isEmpty());
  setOwnerQuotaInfo(groupId,quota,OwnerType.GROUP,QuotaInfo.QUOTA,update);
}",0.9978858350951374
113348,"@Override public void setUserBlockedSpace(String userId,Long blockedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && userId.isEmpty());
  setOwnerQuotaInfo(userId,blockedSpace,OwnerType.USER,QuotaInfo.BLOCKED,update);
}","@Override public void setUserBlockedSpace(String userId,Long blockedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(userId != null && !userId.isEmpty());
  setOwnerQuotaInfo(userId,blockedSpace,OwnerType.USER,QuotaInfo.BLOCKED,update);
}",0.9980276134122288
113349,"@Override public void setGroupUsedSpace(String groupId,Long usedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && groupId.isEmpty());
  setOwnerQuotaInfo(groupId,usedSpace,OwnerType.GROUP,QuotaInfo.USED,update);
}","@Override public void setGroupUsedSpace(String groupId,Long usedSpace,AtomicDBUpdate update) throws DatabaseException {
  assert(groupId != null && !groupId.isEmpty());
  setOwnerQuotaInfo(groupId,usedSpace,OwnerType.GROUP,QuotaInfo.USED,update);
}",0.997979797979798
113350,"@Override public void setValue(long value){
  if (valBuf == null) {
    valLen=Long.SIZE / Byte.SIZE;
    valBuf=new byte[valLen];
  }
  ByteBuffer tmp=ByteBuffer.wrap(valBuf);
  tmp.putLong(value);
}","@Override public void setValue(long value){
  this.value=value;
  if (valBuf == null) {
    valLen=Long.SIZE / Byte.SIZE;
    valBuf=new byte[valLen];
  }
  ByteBuffer tmp=ByteBuffer.wrap(valBuf);
  tmp.putLong(value);
}",0.9523809523809524
113351,"/** 
 * Checks, whether a given extend operation (e.g. write, truncate) is executable regarding the registered vouchers. There is no need to block them, because it only checks the limit from the whole beginning. Concurrent access can't effect this.
 * @param clientId
 * @param expireTime
 * @param newFileSize
 * @return
 * @throws VoucherErrorException
 */
public boolean checkMaxVoucherSize(String clientId,long expireTime,long newFileSize) throws VoucherErrorException {
  if (!clientExpireTimeSet.contains(clientId + expireTime)) {
    if (invalidClientExpireTimeSet.contains(clientId + expireTime)) {
      throw new VoucherErrorException(String.format(""String_Node_Str"",fileId,clientId,expireTime));
    }
 else {
      Logging.logMessage(Logging.LEVEL_WARN,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime);
    }
  }
  if (clientExpireTimeSet.isEmpty() || newFileSize <= voucherSizeMax) {
    return true;
  }
 else {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"" + ""String_Node_Str"",fileId,clientId,newFileSize,voucherSizeMax);
    return false;
  }
}","/** 
 * Checks, whether a given extend operation (e.g. write, truncate) is executable regarding the registered vouchers. There is no need to block them, because it only checks the limit from the whole beginning. Concurrent access can't effect this.
 * @param clientId
 * @param expireTime
 * @param newFileSize
 * @return
 * @throws VoucherErrorException
 */
public boolean checkMaxVoucherSize(String clientId,long expireTime,long newFileSize) throws VoucherErrorException {
  if (!clientExpireTimeSet.contains(expireTime + ""String_Node_Str"" + clientId)) {
    if (invalidClientExpireTimeSet.contains(expireTime + ""String_Node_Str"" + clientId)) {
      throw new VoucherErrorException(String.format(""String_Node_Str"",fileId,clientId,expireTime));
    }
 else {
      Logging.logMessage(Logging.LEVEL_WARN,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime);
    }
  }
  if (clientExpireTimeSet.isEmpty() || newFileSize <= voucherSizeMax) {
    return true;
  }
 else {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"" + ""String_Node_Str"",fileId,clientId,newFileSize,voucherSizeMax);
    return false;
  }
}",0.95929203539823
113352,"/** 
 * @param clientId
 * @param expireTime
 * @param voucherSize
 * @throws VoucherErrorException
 */
public void addVoucher(String clientId,long expireTime,long voucherSize) throws VoucherErrorException {
  Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime,voucherSize);
  if (!invalidClientExpireTimeSet.contains(clientId + expireTime)) {
    if (!clientExpireTimeSet.contains(clientId + expireTime)) {
      clientExpireTimeSet.add(clientId + expireTime);
      voucherSizeMax=(voucherSizeMax < voucherSize) ? voucherSize : voucherSizeMax;
      latestExpireTime=(latestExpireTime < expireTime) ? expireTime : latestExpireTime;
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,latestExpireTime,voucherSizeMax);
    }
 else {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime,voucherSize);
    }
  }
 else {
    throw new VoucherErrorException(String.format(""String_Node_Str"",fileId,clientId,expireTime));
  }
}","/** 
 * @param clientId
 * @param expireTime
 * @param voucherSize
 * @throws VoucherErrorException
 */
public void addVoucher(String clientId,long expireTime,long voucherSize) throws VoucherErrorException {
  Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime,voucherSize);
  if (!invalidClientExpireTimeSet.contains(expireTime + ""String_Node_Str"" + clientId)) {
    if (!clientExpireTimeSet.contains(expireTime + ""String_Node_Str"" + clientId)) {
      clientExpireTimeSet.add(expireTime + ""String_Node_Str"" + clientId);
      voucherSizeMax=(voucherSizeMax < voucherSize) ? voucherSize : voucherSizeMax;
      latestExpireTime=(latestExpireTime < expireTime) ? expireTime : latestExpireTime;
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,latestExpireTime,voucherSizeMax);
    }
 else {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId,clientId,expireTime,voucherSize);
    }
  }
 else {
    throw new VoucherErrorException(String.format(""String_Node_Str"",fileId,clientId,expireTime));
  }
}",0.9240506329113924
113353,"/** 
 * TODO(baerhold): save invalidated Vouchers locally in case of a crash approach
 * @param clientId
 * @param expireTimeSet
 */
public void invalidateVouchers(String clientId,Set<Long> expireTimeSet){
  for (  Long expireTime : expireTimeSet) {
    clientExpireTimeSet.remove(clientId + expireTime);
    invalidClientExpireTimeSet.add(clientId + expireTime);
    latestExpireTime=(latestExpireTime < expireTime) ? expireTime : latestExpireTime;
  }
  return;
}","/** 
 * TODO(baerhold): save invalidated Vouchers locally in case of a crash approach
 * @param clientId
 * @param expireTimeSet
 */
public void invalidateVouchers(String clientId,Set<Long> expireTimeSet){
  long currentTime=TimeSync.getGlobalTime();
  Iterator<String> it=invalidClientExpireTimeSet.iterator();
  while (it.hasNext()) {
    String invalidClientEntry=it.next();
    String expireTime=invalidClientEntry.substring(0,invalidClientEntry.indexOf(""String_Node_Str""));
    if (currentTime > Long.valueOf(expireTime)) {
      it.remove();
    }
 else {
      break;
    }
  }
  for (  Long expireTime : expireTimeSet) {
    clientExpireTimeSet.remove(expireTime + ""String_Node_Str"" + clientId);
    invalidClientExpireTimeSet.add(expireTime + ""String_Node_Str"" + clientId);
    latestExpireTime=(latestExpireTime < expireTime) ? expireTime : latestExpireTime;
  }
  return;
}",0.514455151964418
113354,"/** 
 * Checks, whether all voucher information regarding this file are invalid by themselves
 * @return
 */
public boolean isObsolete(){
  return (TimeSync.getGlobalTime() / 1000) > latestExpireTime;
}","/** 
 * Checks, whether all voucher information regarding this file are invalid by themselves
 * @return
 */
public boolean isObsolete(){
  return TimeSync.getGlobalTime() > latestExpireTime;
}",0.9772151898734176
113355,"/** 
 * @param message
 * @param cause
 * @param enableSuppression
 * @param writableStackTrace
 */
public VoucherErrorException(String message,Throwable cause,boolean enableSuppression,boolean writableStackTrace){
  super(message,cause,enableSuppression,writableStackTrace);
}","/** 
 * @param message
 * @param cause
 */
public VoucherErrorException(String message,Throwable cause){
  super(message,cause);
}",0.6388206388206388
113356,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_renew_capabilityRequest renewCapabilityRequest=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
  Capability cap=new Capability(renewCapabilityRequest.getXcap(),master.getConfig().getCapabilitySecret());
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired() && !renewTimedOutCaps)   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  long newExpireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  long voucherSize=cap.getVoucherSize();
  if (renewCapabilityRequest.getIncreaseVoucher()) {
    voucherSize=master.getMrcVoucherManager().checkAndRenewVoucher(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs);
  }
  Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),cap.getClientIdentity(),cap.getEpochNo(),cap.isReplicateOnClose(),cap.getSnapConfig(),cap.getSnapTimestamp(),voucherSize,newExpireMs,master.getConfig().getCapabilitySecret());
  rq.setResponse(newCap.getXCap());
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_renew_capabilityRequest renewCapabilityRequest=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
  Capability cap=new Capability(renewCapabilityRequest.getXcap(),master.getConfig().getCapabilitySecret());
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired() && !renewTimedOutCaps)   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  long newExpireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  long voucherSize=cap.getVoucherSize();
  if (renewCapabilityRequest.getIncreaseVoucher()) {
    voucherSize=master.getMrcVoucherManager().checkAndRenewVoucher(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs);
  }
 else {
    master.getMrcVoucherManager().addRenewedTimestamp(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs);
  }
  Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),cap.getClientIdentity(),cap.getEpochNo(),cap.isReplicateOnClose(),cap.getSnapConfig(),cap.getSnapTimestamp(),voucherSize,newExpireMs,master.getConfig().getCapabilitySecret());
  rq.setResponse(newCap.getXCap());
  finishRequest(rq);
}",0.9493019838354152
113357,"public boolean hasActiveExpireTime(long expireTime){
  return xcapExpireTimeMap.containsKey(expireTime);
}","public boolean hasActiveExpireTime(long expireTime){
  return xcapExpireTimeList.contains(expireTime);
}",0.9523809523809524
113358,"public void addVoucher(long expireTime,long voucherSize){
  if (!xcapExpireTimeMap.containsKey(expireTime)) {
    xcapExpireTimeMap.put(expireTime,voucherSize);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","public void addVoucher(long expireTime){
  if (!xcapExpireTimeList.contains(expireTime)) {
    xcapExpireTimeList.add(expireTime);
  }
 else {
    System.out.println(""String_Node_Str"" + getClass() + ""String_Node_Str"");
  }
}",0.2157303370786517
113359,"public boolean isEmpty(){
  return xcapExpireTimeMap.isEmpty();
}","public boolean isEmpty(){
  return xcapExpireTimeList.isEmpty();
}",0.9465648854961832
113360,"public void clearVouchers(Set<Long> expireTimes){
  for (  Long expireTime : expireTimes) {
    if (xcapExpireTimeMap.containsKey(expireTime)) {
      xcapExpireTimeMap.remove(expireTime);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
}","public void clearVouchers(Set<Long> expireTimes){
  for (  Long expireTime : expireTimes) {
    if (xcapExpireTimeList.contains(expireTime)) {
      xcapExpireTimeList.remove(expireTime);
    }
 else {
      System.out.println(""String_Node_Str"" + getClass() + ""String_Node_Str"");
    }
  }
}",0.4545454545454545
113361,"@Override public String toString(){
  return ""String_Node_Str"" + fileID + ""String_Node_Str""+ clientID+ ""String_Node_Str""+ xcapExpireTimeMap+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + fileID + ""String_Node_Str""+ clientID+ ""String_Node_Str""+ xcapExpireTimeList+ ""String_Node_Str"";
}",0.978328173374613
113362,"public long addVoucher(String clientID,long expireTime,long voucherSize){
  ClientVoucherManager clientVoucherManager=openVoucherMap.get(clientID);
  if (clientVoucherManager == null) {
    clientVoucherManager=new ClientVoucherManager(clientID,fileID);
    openVoucherMap.put(clientID,clientVoucherManager);
  }
  blockedSpace+=voucherSize;
  clientVoucherManager.addVoucher(expireTime,fileSize + blockedSpace);
  return fileSize + blockedSpace;
}","public long addVoucher(String clientID,long expireTime,long voucherSize){
  ClientVoucherManager clientVoucherManager=openVoucherMap.get(clientID);
  if (clientVoucherManager == null) {
    clientVoucherManager=new ClientVoucherManager(clientID,fileID);
    openVoucherMap.put(clientID,clientVoucherManager);
  }
  blockedSpace+=voucherSize;
  clientVoucherManager.addVoucher(expireTime);
  return fileSize + blockedSpace;
}",0.944954128440367
113363,"private void processStep2(final Volume volData,final String volumeId,final MRCRequest rq,ServiceSet response){
  try {
    for (    Service reg : response.getServicesList())     if (volData.getName().equals(reg.getName())) {
      String uuid=reg.getUuid();
      throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + volData.getName() + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
    }
    String uid=volData.getOwnerUserId();
    String gid=volData.getOwnerGroupId();
    if (""String_Node_Str"".equals(uid))     uid=rq.getDetails().userId;
    if (""String_Node_Str"".equals(gid))     gid=rq.getDetails().groupIds.get(0);
    master.getVolumeManager().createVolume(master.getFileAccessManager(),volumeId,volData.getName(),(short)volData.getAccessControlPolicy().getNumber(),uid,gid,volData.getDefaultStripingPolicy(),volData.getMode(),volData.getQuota(),volData.getAttrsList());
    master.notifyVolumeCreated();
    ServiceDataMap.Builder dmap=ServiceDataMap.newBuilder();
    dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"").setValue(master.getConfig().getUUID().toString()));
    dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"").setValue(""String_Node_Str""));
    for (    KeyValuePair kv : volData.getAttrsList())     dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"" + kv.getKey()).setValue(kv.getValue()));
    final Service vol=Service.newBuilder().setType(ServiceType.SERVICE_TYPE_VOLUME).setUuid(volumeId).setVersion(0).setName(volData.getName()).setLastUpdatedS(0).setData(dmap).build();
    Runnable rqThr=new Runnable(){
      @Override public void run(){
        try {
          master.getDirClient().xtreemfs_service_register(null,rq.getDetails().auth,RPCAuthentication.userService,vol);
          processStep3(volData,volumeId,rq);
        }
 catch (        Exception ex) {
          finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
        }
      }
    }
;
    Thread thr=new Thread(rqThr);
    thr.start();
    new VolumeQuotaManager(master.getMrcQuotaManager(),master.getVolumeManager().getStorageManager(volumeId),volumeId);
  }
 catch (  UserException exc) {
    if (Logging.isDebug())     Logging.logUserError(Logging.LEVEL_DEBUG,Category.proc,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorType.ERRNO,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  DatabaseException exc) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",exc));
  }
}","private void processStep2(final Volume volData,final String volumeId,final MRCRequest rq,ServiceSet response){
  try {
    for (    Service reg : response.getServicesList())     if (volData.getName().equals(reg.getName())) {
      String uuid=reg.getUuid();
      throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + volData.getName() + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
    }
    String uid=volData.getOwnerUserId();
    String gid=volData.getOwnerGroupId();
    if (""String_Node_Str"".equals(uid))     uid=rq.getDetails().userId;
    if (""String_Node_Str"".equals(gid))     gid=rq.getDetails().groupIds.get(0);
    master.getVolumeManager().createVolume(master.getFileAccessManager(),volumeId,volData.getName(),(short)volData.getAccessControlPolicy().getNumber(),uid,gid,volData.getDefaultStripingPolicy(),volData.getMode(),volData.getQuota(),volData.getAttrsList());
    master.notifyVolumeCreated();
    ServiceDataMap.Builder dmap=ServiceDataMap.newBuilder();
    dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"").setValue(master.getConfig().getUUID().toString()));
    dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"").setValue(""String_Node_Str""));
    for (    KeyValuePair kv : volData.getAttrsList())     dmap.addData(KeyValuePair.newBuilder().setKey(""String_Node_Str"" + kv.getKey()).setValue(kv.getValue()));
    final Service vol=Service.newBuilder().setType(ServiceType.SERVICE_TYPE_VOLUME).setUuid(volumeId).setVersion(0).setName(volData.getName()).setLastUpdatedS(0).setData(dmap).build();
    Runnable rqThr=new Runnable(){
      @Override public void run(){
        try {
          master.getDirClient().xtreemfs_service_register(null,rq.getDetails().auth,RPCAuthentication.userService,vol);
          processStep3(volData,volumeId,rq);
        }
 catch (        Exception ex) {
          finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
        }
      }
    }
;
    Thread thr=new Thread(rqThr);
    thr.start();
    VolumeQuotaManager volumeQuotaManager=new VolumeQuotaManager(master.getMrcQuotaManager(),master.getVolumeManager().getStorageManager(volumeId),volumeId);
    volumeQuotaManager.init();
  }
 catch (  UserException exc) {
    if (Logging.isDebug())     Logging.logUserError(Logging.LEVEL_DEBUG,Category.proc,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorType.ERRNO,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  DatabaseException exc) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",exc));
  }
}",0.987475040842258
113364,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  try {
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    if (create || truncate || write) {
      QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),file);
      master.getMrcVoucherManager().checkVoucherAvailability(quotaFileInformation);
    }
    if (file.isDirectory() || sMan.getSoftlinkTarget(file.getId()) != null)     throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == POSIXErrno.POSIX_ERROR_ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      if ((rqArgs.getMode() & GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_S_IFIFO.getNumber()) != 0) {
        throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"");
      }
      String groupId=rq.getDetails().groupIds.get(0);
      int parentMode=faMan.getPosixAccessMode(sMan,res.getParentDir(),rq.getDetails().userId,rq.getDetails().groupIds);
      if ((parentMode & 02000) > 0) {
        groupId=res.getParentDir().getOwningGroupId();
      }
      QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),fileId,rq.getDetails().userId,groupId,0);
      master.getMrcVoucherManager().checkVoucherAvailability(quotaFileInformation);
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,groupId,rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  XLocList xLocList=file.getXLocList();
  XLocSetLock lock=master.getXLocSetCoordinator().getXLocSetLock(file,sMan);
  if (lock.isLocked()) {
    if (lock.hasCrashed()) {
      XLoc[] replicas=new XLoc[xLocList.getReplicaCount()];
      for (int i=0; i < xLocList.getReplicaCount(); i++) {
        replicas[i]=xLocList.getReplica(i);
      }
      xLocList=sMan.createXLocList(replicas,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
      master.getXLocSetCoordinator().unlockXLocSet(file,sMan,update);
    }
 else {
      throw new UserException(POSIXErrno.POSIX_ERROR_EAGAIN,""String_Node_Str"");
    }
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  ReplicationPolicy defaultReplPolicy=sMan.getDefaultReplicationPolicy(res.getParentDirId());
  if (defaultReplPolicy == null)   defaultReplPolicy=sMan.getDefaultReplicationPolicy(1);
  boolean replicateOnClose=defaultReplPolicy != null && ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(defaultReplPolicy.getName());
  if ((xLocList == null || xLocList.getReplicaCount() == 0) && (create || write)) {
    boolean singleReplica=defaultReplPolicy == null || ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(defaultReplPolicy.getName()) || replicateOnClose;
    if (singleReplica) {
      XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,0);
      String[] osds=new String[replica.getOSDCount()];
      for (int j=0; j < osds.length; j++)       osds[j]=replica.getOSD(j);
      List<XLoc> repls=new ArrayList<XLoc>();
      repls.add(replica);
      xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
    }
 else {
      int numReplicas=1;
      if (defaultReplPolicy != null)       numReplicas=defaultReplPolicy.getFactor();
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < numReplicas; i++) {
        XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,defaultReplPolicy != null ? defaultReplPolicy.getFlags() : 0);
        String[] osds=new String[replica.getOSDCount()];
        for (int j=0; j < osds.length; j++)         osds[j]=replica.getOSD(j);
        repls.add(replica);
        xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),defaultReplPolicy != null ? defaultReplPolicy.getName() : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
      }
    }
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocList.toString());
  }
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(xLocList);
  List<Replica> sortedReplList=master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocSet.getReplicasList(),xLocList).getReplicasList();
  xLocSet.clearReplicas();
  xLocSet.addAllReplicas(sortedReplList);
  xLocSet.setReadOnlyFileSize(file.getSize());
  String globalFileId=MRCHelper.createGlobalFileId(volume,file);
  long expireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  String clientID=((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress();
  long voucherSize=0;
  if (create || truncate || write) {
    QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),file);
    master.getMrcVoucherManager().getVoucher(quotaFileInformation,clientID,expireMs,update);
  }
  Capability cap=new Capability(globalFileId,rqArgs.getFlags(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),clientID,trEpoch,replicateOnClose,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),voucherSize,expireMs,master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,time,update);
  }
 else   if (!master.getConfig().isNoAtime()) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,time,update);
  }
 else {
    time=0;
  }
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,time,update);
  rq.setResponse(openResponse.newBuilder().setCreds(FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet)).setTimestampS(time).build());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  try {
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    if (create || truncate || write) {
      QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),file);
      master.getMrcVoucherManager().checkVoucherAvailability(quotaFileInformation);
    }
    if (file.isDirectory() || sMan.getSoftlinkTarget(file.getId()) != null)     throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == POSIXErrno.POSIX_ERROR_ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      if ((rqArgs.getMode() & GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_S_IFIFO.getNumber()) != 0) {
        throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"");
      }
      String groupId=rq.getDetails().groupIds.get(0);
      int parentMode=faMan.getPosixAccessMode(sMan,res.getParentDir(),rq.getDetails().userId,rq.getDetails().groupIds);
      if ((parentMode & 02000) > 0) {
        groupId=res.getParentDir().getOwningGroupId();
      }
      QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),fileId,rq.getDetails().userId,groupId,0);
      master.getMrcVoucherManager().checkVoucherAvailability(quotaFileInformation);
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,groupId,rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  XLocList xLocList=file.getXLocList();
  XLocSetLock lock=master.getXLocSetCoordinator().getXLocSetLock(file,sMan);
  if (lock.isLocked()) {
    if (lock.hasCrashed()) {
      XLoc[] replicas=new XLoc[xLocList.getReplicaCount()];
      for (int i=0; i < xLocList.getReplicaCount(); i++) {
        replicas[i]=xLocList.getReplica(i);
      }
      xLocList=sMan.createXLocList(replicas,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
      master.getXLocSetCoordinator().unlockXLocSet(file,sMan,update);
    }
 else {
      throw new UserException(POSIXErrno.POSIX_ERROR_EAGAIN,""String_Node_Str"");
    }
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  ReplicationPolicy defaultReplPolicy=sMan.getDefaultReplicationPolicy(res.getParentDirId());
  if (defaultReplPolicy == null)   defaultReplPolicy=sMan.getDefaultReplicationPolicy(1);
  boolean replicateOnClose=defaultReplPolicy != null && ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(defaultReplPolicy.getName());
  if ((xLocList == null || xLocList.getReplicaCount() == 0) && (create || write)) {
    boolean singleReplica=defaultReplPolicy == null || ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(defaultReplPolicy.getName()) || replicateOnClose;
    if (singleReplica) {
      XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,0);
      String[] osds=new String[replica.getOSDCount()];
      for (int j=0; j < osds.length; j++)       osds[j]=replica.getOSD(j);
      List<XLoc> repls=new ArrayList<XLoc>();
      repls.add(replica);
      xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
    }
 else {
      int numReplicas=1;
      if (defaultReplPolicy != null)       numReplicas=defaultReplPolicy.getFactor();
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < numReplicas; i++) {
        XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,defaultReplPolicy != null ? defaultReplPolicy.getFlags() : 0);
        String[] osds=new String[replica.getOSDCount()];
        for (int j=0; j < osds.length; j++)         osds[j]=replica.getOSD(j);
        repls.add(replica);
        xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),defaultReplPolicy != null ? defaultReplPolicy.getName() : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
      }
    }
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocList.toString());
  }
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(xLocList);
  List<Replica> sortedReplList=master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocSet.getReplicasList(),xLocList).getReplicasList();
  xLocSet.clearReplicas();
  xLocSet.addAllReplicas(sortedReplList);
  xLocSet.setReadOnlyFileSize(file.getSize());
  String globalFileId=MRCHelper.createGlobalFileId(volume,file);
  long expireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  String clientID=((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress();
  long voucherSize=0;
  if (create || truncate || write) {
    QuotaFileInformation quotaFileInformation=new QuotaFileInformation(volume.getId(),file);
    voucherSize=master.getMrcVoucherManager().getVoucher(quotaFileInformation,clientID,expireMs,update);
  }
  Capability cap=new Capability(globalFileId,rqArgs.getFlags(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),clientID,trEpoch,replicateOnClose,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),voucherSize,expireMs,master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,time,update);
  }
 else   if (!master.getConfig().isNoAtime()) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,time,update);
  }
 else {
    time=0;
  }
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,time,update);
  rq.setResponse(openResponse.newBuilder().setCreds(FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet)).setTimestampS(time).build());
  update.execute();
}",0.999310265547764
113365,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_renew_capabilityRequest renewCapabilityRequest=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
  Capability cap=new Capability(renewCapabilityRequest.getXcap(),master.getConfig().getCapabilitySecret());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cap.getFileId() + ""String_Node_Str""+ cap.getClientIdentity()+ ""String_Node_Str""+ ""String_Node_Str""+ renewCapabilityRequest.getIncreaseVoucher());
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired() && !renewTimedOutCaps)   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  long newExpireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  long voucherSize=cap.getVoucherSize();
  if (renewCapabilityRequest.getIncreaseVoucher()) {
    GlobalFileIdResolver globalFileIdResolver=new GlobalFileIdResolver(cap.getFileId());
    StorageManager sMan=master.getVolumeManager().getStorageManager(globalFileIdResolver.getVolumeId());
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
    voucherSize=master.getMrcVoucherManager().checkAndRenewVoucher(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs,update);
    update.execute();
  }
 else {
    master.getMrcVoucherManager().addRenewedTimestamp(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs);
  }
  Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),cap.getClientIdentity(),cap.getEpochNo(),cap.isReplicateOnClose(),cap.getSnapConfig(),cap.getSnapTimestamp(),voucherSize,newExpireMs,master.getConfig().getCapabilitySecret());
  rq.setResponse(newCap.getXCap());
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_renew_capabilityRequest renewCapabilityRequest=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
  Capability cap=new Capability(renewCapabilityRequest.getXcap(),master.getConfig().getCapabilitySecret());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cap.getFileId() + ""String_Node_Str""+ cap.getClientIdentity()+ ""String_Node_Str""+ ""String_Node_Str""+ renewCapabilityRequest.getIncreaseVoucher());
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired() && !renewTimedOutCaps)   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  long newExpireMs=TimeSync.getGlobalTime() + master.getConfig().getCapabilityTimeout() * 1000;
  long voucherSize=cap.getVoucherSize();
  if (MRCVoucherManager.checkManageableAccess(cap.getAccessMode())) {
    if (renewCapabilityRequest.getIncreaseVoucher()) {
      GlobalFileIdResolver globalFileIdResolver=new GlobalFileIdResolver(cap.getFileId());
      StorageManager sMan=master.getVolumeManager().getStorageManager(globalFileIdResolver.getVolumeId());
      AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
      voucherSize=master.getMrcVoucherManager().checkAndRenewVoucher(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs,update);
      update.execute();
    }
 else {
      master.getMrcVoucherManager().addRenewedTimestamp(cap.getFileId(),cap.getClientIdentity(),cap.getExpireMs(),newExpireMs);
    }
  }
  Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),cap.getClientIdentity(),cap.getEpochNo(),cap.isReplicateOnClose(),cap.getSnapConfig(),cap.getSnapTimestamp(),voucherSize,newExpireMs,master.getConfig().getCapabilitySecret());
  rq.setResponse(newCap.getXCap());
  finishRequest(rq);
}",0.9767088607594936
113366,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  System.out.println(getClass() + ""String_Node_Str"");
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    if (osdFinalizeVouchersResponse.getSizeInBytes() > newFileSizeMax) {
      newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    }
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  master.getMrcVoucherManager().clearVouchers(cap.getFileId(),cap.getClientIdentity(),newFileSizeMax,expireTimeSet);
  rq.setResponse(emptyResponse.getDefaultInstance());
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  System.out.println(getClass() + ""String_Node_Str"");
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    if (osdFinalizeVouchersResponse.getSizeInBytes() > newFileSizeMax) {
      newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    }
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  master.getMrcVoucherManager().clearVouchers(cap.getFileId(),cap.getClientIdentity(),newFileSizeMax,expireTimeSet);
  rq.setResponse(emptyResponse.getDefaultInstance());
  finishRequest(rq);
}",0.985122453650721
113367,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  System.out.println(getClass() + ""String_Node_Str"");
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  master.getMrcVoucherManager().clearVouchers(cap.getFileId(),cap.getClientIdentity(),newFileSizeMax,expireTimeSet);
  rq.setResponse(emptyResponse.getDefaultInstance());
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  System.out.println(getClass() + ""String_Node_Str"");
  final xtreemfs_clear_vouchersRequest cvRequest=(xtreemfs_clear_vouchersRequest)rq.getRequestArgs();
  Capability cap=new Capability(cvRequest.getCreds().getXcap(),master.getConfig().getCapabilitySecret());
  Set<Long> expireTimeSet=new HashSet<Long>(cvRequest.getExpireTimeMsList());
  List<OSDFinalizeVouchersResponse> osdFinalizeVouchersResponseList=cvRequest.getOsdFinalizeVouchersResponseList();
  if (!cap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,cap + ""String_Node_Str"");
  StripingPolicy sp=cvRequest.getCreds().getXlocs().getReplicasList().get(0).getStripingPolicy();
  if (osdFinalizeVouchersResponseList.size() != sp.getWidth()) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,cvRequest + ""String_Node_Str"");
  }
  expireTimeSet.add(cap.getExpireMs());
  FinalizeVoucherResponseHelper responseHelper=new FinalizeVoucherResponseHelper(master.getConfig().getCapabilitySecret());
  long newFileSizeMax=-1;
  for (  OSDFinalizeVouchersResponse osdFinalizeVouchersResponse : osdFinalizeVouchersResponseList) {
    boolean valid=responseHelper.validateSignature(osdFinalizeVouchersResponse,expireTimeSet);
    if (!valid) {
      throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,osdFinalizeVouchersResponse + ""String_Node_Str"");
    }
    newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    if (osdFinalizeVouchersResponse.getSizeInBytes() > newFileSizeMax) {
      newFileSizeMax=osdFinalizeVouchersResponse.getSizeInBytes();
    }
  }
  if (newFileSizeMax == -1) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  master.getMrcVoucherManager().clearVouchers(cap.getFileId(),cap.getClientIdentity(),newFileSizeMax,expireTimeSet);
  rq.setResponse(emptyResponse.getDefaultInstance());
  finishRequest(rq);
}",0.9659514925373134
113368,"public synchronized long getVoucher(boolean test) throws UserException {
  if (!active) {
    return 0;
  }
  System.out.println(getClass() + ""String_Node_Str"" + test);
  long currentFreeSpace=getFreeSpace();
  if (currentFreeSpace <= 0) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  }
  long voucherSize=volumeVoucherSize;
  if (currentFreeSpace >= volumeVoucherSize) {
    voucherSize=currentFreeSpace;
  }
  if (!test) {
    curBlockedSpace+=voucherSize;
    try {
      AtomicDBUpdate update=volStorageManager.createAtomicDBUpdate(null,null);
      volStorageManager.setVolumeBlockedSpace(curBlockedSpace,update);
      update.execute();
    }
 catch (    DatabaseException e) {
      e.printStackTrace();
    }
  }
  System.out.println(getClass() + ""String_Node_Str"" + voucherSize+ ""String_Node_Str""+ curUsedSpace+ ""String_Node_Str""+ curBlockedSpace+ ""String_Node_Str""+ volumeQuota+ ""String_Node_Str"");
  return voucherSize;
}","public synchronized long getVoucher(boolean test) throws UserException {
  if (!active) {
    return 0;
  }
  System.out.println(getClass() + ""String_Node_Str"" + test);
  long currentFreeSpace=getFreeSpace();
  if (currentFreeSpace <= 0) {
    throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  }
  long voucherSize=volumeVoucherSize;
  if (volumeVoucherSize > currentFreeSpace) {
    voucherSize=currentFreeSpace;
  }
  if (!test) {
    curBlockedSpace+=voucherSize;
    try {
      AtomicDBUpdate update=volStorageManager.createAtomicDBUpdate(null,null);
      volStorageManager.setVolumeBlockedSpace(curBlockedSpace,update);
      update.execute();
    }
 catch (    DatabaseException e) {
      e.printStackTrace();
    }
  }
  System.out.println(getClass() + ""String_Node_Str"" + voucherSize+ ""String_Node_Str""+ curUsedSpace+ ""String_Node_Str""+ curBlockedSpace+ ""String_Node_Str""+ volumeQuota+ ""String_Node_Str"");
  return voucherSize;
}",0.9794486215538848
113369,"@Override @Deprecated public int read(UserCredentials userCredentials,byte[] data,int dataOffset,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  throw new RuntimeException(""String_Node_Str"");
}","public int read(UserCredentials userCredentials,ByteBuffer data,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  if (data.isDirect()) {
    return proxy.readDirect(data,count,offset);
  }
 else   if (data.hasArray()) {
    return proxy.read(data.array(),count,offset);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.6212361331220285
113370,"@Override @Deprecated public int write(UserCredentials userCredentials,byte[] data,int dataOffset,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  throw new RuntimeException(""String_Node_Str"");
}","public int write(UserCredentials userCredentials,ByteBuffer data,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  if (data.isDirect()) {
    return proxy.writeDirect(data,count,offset);
  }
 else   if (data.hasArray()) {
    return proxy.write(data.array(),count,offset);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.6204724409448819
113371,"/** 
 * Load the library with the platform independent name. (f.ex. jni-libxtreemfs instead of libjni-xtreemfs.so) <br> If the library does not exists in the java.library.path, but the current class is running within a xtreemfs source directory, the cpp/build directory is searched as well.
 * @param name
 */
public static void loadLibrary(String name){
  try {
    System.loadLibrary(name);
  }
 catch (  UnsatisfiedLinkError error) {
    URL classURL=NativeHelper.class.getResource(""String_Node_Str"");
    if (classURL == null || !""String_Node_Str"".equalsIgnoreCase(classURL.getProtocol())) {
      throw error;
    }
    String path=null;
    String[] components=classURL.getPath().split(File.separator);
    for (int i=0; i < components.length; i++) {
      if (i < components.length - 2 && ""String_Node_Str"".equals(components[i]) && ""String_Node_Str"".equals(components[i + 1]) && ""String_Node_Str"".equals(components[i + 2])) {
        path=String.join(""String_Node_Str"",Arrays.copyOf(components,i + 1));
      }
    }
    if (path == null) {
      throw error;
    }
    String libName=System.mapLibraryName(""String_Node_Str"");
    System.load(path + ""String_Node_Str"" + libName);
  }
}","/** 
 * Load the library with the platform independent name. (f.ex. jni-libxtreemfs instead of libjni-xtreemfs.so) <br> If the library does not exists in the java.library.path, but the current class is running within a xtreemfs source directory, the cpp/build directory is searched as well.
 * @param name
 */
public static void loadLibrary(String name){
  try {
    System.loadLibrary(name);
  }
 catch (  UnsatisfiedLinkError error) {
    URL classURL=NativeHelper.class.getResource(""String_Node_Str"");
    if (classURL == null || !""String_Node_Str"".equalsIgnoreCase(classURL.getProtocol())) {
      throw error;
    }
    String path=classURL.getPath();
    path=path.replace(File.separator,""String_Node_Str"");
    int pos=path.lastIndexOf(""String_Node_Str"");
    if (pos < 0) {
      throw error;
    }
    path=path.substring(0,pos);
    path=path + ""String_Node_Str"" + System.mapLibraryName(""String_Node_Str"");
    System.load(path.replace(""String_Node_Str"",File.separator));
  }
}",0.6681964203763194
113372,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  final Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  final StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  final PathResolver res=new PathResolver(sMan,p);
  if (res.getParentDir() == null)   throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + res.getFileName() + ""String_Node_Str"");
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileExistsAlready();
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  long fileId=sMan.getNextFileId();
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,update);
  sMan.setLastFileId(fileId,update);
  MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,time,update);
  rq.setResponse(timestampResponse.newBuilder().setTimestampS(time).build());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  final Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  final StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  final PathResolver res=new PathResolver(sMan,p);
  final FileMetadata parent=res.getParentDir();
  if (parent == null)   throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + res.getFileName() + ""String_Node_Str"");
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,parent,parent.getId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileExistsAlready();
  String groupId=rq.getDetails().groupIds.get(0);
  int parentMode=faMan.getPosixAccessMode(sMan,parent,rq.getDetails().userId,rq.getDetails().groupIds);
  if ((parentMode & 02000) > 0) {
    groupId=parent.getOwningGroupId();
  }
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  long fileId=sMan.getNextFileId();
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  sMan.createDir(fileId,parent.getId(),res.getFileName(),time,time,time,rq.getDetails().userId,groupId,rqArgs.getMode(),0,update);
  sMan.setLastFileId(fileId,update);
  MRCHelper.updateFileTimes(parent.getId(),parent,false,true,true,sMan,time,update);
  rq.setResponse(timestampResponse.newBuilder().setTimestampS(time).build());
  update.execute();
}",0.8367868294067556
113373,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  try {
    long volumeQuota=volume.getVolumeQuota();
    if ((write || create) && volumeQuota != 0 && volumeQuota <= volume.getVolumeSize()) {
      throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"");
    }
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    if (file.isDirectory() || sMan.getSoftlinkTarget(file.getId()) != null)     throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == POSIXErrno.POSIX_ERROR_ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      if ((rqArgs.getMode() & GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_S_IFIFO.getNumber()) != 0) {
        throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"");
      }
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  XLocList xLocList=file.getXLocList();
  XLocSetLock lock=master.getXLocSetCoordinator().getXLocSetLock(file,sMan);
  if (lock.isLocked()) {
    if (lock.hasCrashed()) {
      XLoc[] replicas=new XLoc[xLocList.getReplicaCount()];
      for (int i=0; i < xLocList.getReplicaCount(); i++) {
        replicas[i]=xLocList.getReplica(i);
      }
      xLocList=sMan.createXLocList(replicas,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
      master.getXLocSetCoordinator().unlockXLocSet(file,sMan,update);
    }
 else {
      throw new UserException(POSIXErrno.POSIX_ERROR_EAGAIN,""String_Node_Str"");
    }
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  ReplicationPolicy defaultReplPolicy=sMan.getDefaultReplicationPolicy(res.getParentDirId());
  if (defaultReplPolicy == null)   defaultReplPolicy=sMan.getDefaultReplicationPolicy(1);
  boolean replicateOnClose=defaultReplPolicy != null && ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(defaultReplPolicy.getName());
  if ((xLocList == null || xLocList.getReplicaCount() == 0) && (create || write)) {
    boolean singleReplica=defaultReplPolicy == null || ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(defaultReplPolicy.getName()) || replicateOnClose;
    if (singleReplica) {
      XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,0);
      String[] osds=new String[replica.getOSDCount()];
      for (int j=0; j < osds.length; j++)       osds[j]=replica.getOSD(j);
      List<XLoc> repls=new ArrayList<XLoc>();
      repls.add(replica);
      xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
    }
 else {
      int numReplicas=1;
      if (defaultReplPolicy != null)       numReplicas=defaultReplPolicy.getFactor();
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < numReplicas; i++) {
        XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,defaultReplPolicy != null ? defaultReplPolicy.getFlags() : 0);
        String[] osds=new String[replica.getOSDCount()];
        for (int j=0; j < osds.length; j++)         osds[j]=replica.getOSD(j);
        repls.add(replica);
        xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),defaultReplPolicy != null ? defaultReplPolicy.getName() : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
      }
    }
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocList.toString());
  }
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(xLocList);
  List<Replica> sortedReplList=master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocSet.getReplicasList(),xLocList).getReplicasList();
  xLocSet.clearReplicas();
  xLocSet.addAllReplicas(sortedReplList);
  xLocSet.setReadOnlyFileSize(file.getSize());
  Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,file),rqArgs.getFlags(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),trEpoch,replicateOnClose,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,time,update);
  }
 else   if (!master.getConfig().isNoAtime()) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,time,update);
  }
 else {
    time=0;
  }
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,time,update);
  rq.setResponse(openResponse.newBuilder().setCreds(FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet)).setTimestampS(time).build());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  try {
    long volumeQuota=volume.getVolumeQuota();
    if ((write || create) && volumeQuota != 0 && volumeQuota <= volume.getVolumeSize()) {
      throw new UserException(POSIXErrno.POSIX_ERROR_ENOSPC,""String_Node_Str"");
    }
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    if (file.isDirectory() || sMan.getSoftlinkTarget(file.getId()) != null)     throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == POSIXErrno.POSIX_ERROR_ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      if ((rqArgs.getMode() & GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_S_IFIFO.getNumber()) != 0) {
        throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"");
      }
      String groupId=rq.getDetails().groupIds.get(0);
      int parentMode=faMan.getPosixAccessMode(sMan,res.getParentDir(),rq.getDetails().userId,rq.getDetails().groupIds);
      if ((parentMode & 02000) > 0) {
        groupId=res.getParentDir().getOwningGroupId();
      }
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,groupId,rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  XLocList xLocList=file.getXLocList();
  XLocSetLock lock=master.getXLocSetCoordinator().getXLocSetLock(file,sMan);
  if (lock.isLocked()) {
    if (lock.hasCrashed()) {
      XLoc[] replicas=new XLoc[xLocList.getReplicaCount()];
      for (int i=0; i < xLocList.getReplicaCount(); i++) {
        replicas[i]=xLocList.getReplica(i);
      }
      xLocList=sMan.createXLocList(replicas,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
      master.getXLocSetCoordinator().unlockXLocSet(file,sMan,update);
    }
 else {
      throw new UserException(POSIXErrno.POSIX_ERROR_EAGAIN,""String_Node_Str"");
    }
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  ReplicationPolicy defaultReplPolicy=sMan.getDefaultReplicationPolicy(res.getParentDirId());
  if (defaultReplPolicy == null)   defaultReplPolicy=sMan.getDefaultReplicationPolicy(1);
  boolean replicateOnClose=defaultReplPolicy != null && ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(defaultReplPolicy.getName());
  if ((xLocList == null || xLocList.getReplicaCount() == 0) && (create || write)) {
    boolean singleReplica=defaultReplPolicy == null || ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(defaultReplPolicy.getName()) || replicateOnClose;
    if (singleReplica) {
      XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,0);
      String[] osds=new String[replica.getOSDCount()];
      for (int j=0; j < osds.length; j++)       osds[j]=replica.getOSD(j);
      List<XLoc> repls=new ArrayList<XLoc>();
      repls.add(replica);
      xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
    }
 else {
      int numReplicas=1;
      if (defaultReplPolicy != null)       numReplicas=defaultReplPolicy.getFactor();
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < numReplicas; i++) {
        XLoc replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),p.toString(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocList,defaultReplPolicy != null ? defaultReplPolicy.getFlags() : 0);
        String[] osds=new String[replica.getOSDCount()];
        for (int j=0; j < osds.length; j++)         osds[j]=replica.getOSD(j);
        repls.add(replica);
        xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),defaultReplPolicy != null ? defaultReplPolicy.getName() : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,0);
      }
    }
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocList.toString());
  }
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(xLocList);
  List<Replica> sortedReplList=master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress(),rqArgs.getCoordinates(),xLocSet.getReplicasList(),xLocList).getReplicasList();
  xLocSet.clearReplicas();
  xLocSet.addAllReplicas(sortedReplList);
  xLocSet.setReadOnlyFileSize(file.getSize());
  Capability cap=new Capability(MRCHelper.createGlobalFileId(volume,file),rqArgs.getFlags(),master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),trEpoch,replicateOnClose,!volume.isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : volume.isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,volume.getCreationTime(),master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,time,update);
  }
 else   if (!master.getConfig().isNoAtime()) {
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,time,update);
  }
 else {
    time=0;
  }
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,time,update);
  rq.setResponse(openResponse.newBuilder().setCreds(FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet)).setTimestampS(time).build());
  update.execute();
}",0.9805035017982208
113374,"private void parsePath(String path){
  if (path.length() == 0) {
    this.path=""String_Node_Str"";
    this.compIndices=new ArrayList<Integer>(15);
    compIndices.add(-1);
  }
 else {
    this.path=path.charAt(path.length() - 1) == SEPARATOR ? path.substring(0,path.length() - 1) : path;
    this.compIndices=new ArrayList<Integer>(15);
    compIndices.add(-1);
    char[] chars=this.path.toCharArray();
    for (int i=0; i < chars.length; i++)     if (chars[i] == SEPARATOR)     compIndices.add(i);
  }
}","private void parsePath(String path){
  if (path.length() == 0) {
    this.path=""String_Node_Str"";
    this.compIndices=new ArrayList<Integer>(15);
    compIndices.add(-1);
  }
 else {
    while (path.contains(""String_Node_Str"")) {
      path=path.replace(""String_Node_Str"",""String_Node_Str"");
    }
    this.path=path.charAt(path.length() - 1) == SEPARATOR ? path.substring(0,path.length() - 1) : path;
    this.compIndices=new ArrayList<Integer>(15);
    compIndices.add(-1);
    char[] chars=this.path.toCharArray();
    for (int i=0; i < chars.length; i++)     if (chars[i] == SEPARATOR)     compIndices.add(i);
  }
}",0.8977777777777778
113375,"private boolean isHealthy(Service osd){
  int smartTestResult=Integer.valueOf(KeyValuePairs.getValue(osd.getData().getDataList(),""String_Node_Str""));
  return smartTestResult != SmartTestResult.SMART_TEST_RESULT_FAILED_VALUE;
}","private boolean isHealthy(Service osd){
  String smartTestResult=KeyValuePairs.getValue(osd.getData().getDataList(),""String_Node_Str"");
  if (smartTestResult == null) {
    return true;
  }
  return Integer.valueOf(smartTestResult) != SmartTestResult.SMART_TEST_RESULT_FAILED_VALUE;
}",0.4344422700587084
113376,"/** 
 * Invalidate the majority of the replicas listed in xLocList. Will sleep until the lease has timed out if the primary didn't respond.
 * @param fileId
 * @param capability
 * @param xLocSet
 * @param numAcksRequired
 * @throws InterruptedException
 * @throws MRCException
 */
private ReplicaStatus[] invalidateReplicas(String fileId,Capability cap,XLocSet xLocSet,int numAcksRequired) throws InterruptedException, MRCException {
  @SuppressWarnings(""String_Node_Str"") final RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses=new RPCResponse[xLocSet.getReplicasCount()];
  OSDServiceClient client=master.getOSDClient();
  FileCredentials creds=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();
  for (int i=0; i < responses.length; i++) {
    ServiceUUID OSDServiceUUID=new ServiceUUID(Helper.getOSDUUIDFromXlocSet(xLocSet,i,0));
    try {
      responses[i]=client.xtreemfs_xloc_set_invalidate(OSDServiceUUID.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,creds,fileId);
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_DEBUG,this,ex);
      }
    }
  }
  /** 
 * This local class is used to collect responses to the asynchronous invalidate requests. <br> It counts the number of errors and successful requests and stores an array of returned ReplicaStatus and a flag indicating if the primary did respond.
 */
class InvalidatedResponseListener implements RPCResponseAvailableListener<xtreemfs_xloc_set_invalidateResponse> {
    private int numResponses=0;
    private int numErrors=0;
    private boolean primaryResponded=false;
    private RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses;
    private ReplicaStatus[] states;
    public InvalidatedResponseListener(    RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses){
      this.responses=responses;
      states=new ReplicaStatus[responses.length];
      for (int i=0; i < responses.length; i++) {
        responses[i].registerListener(this);
      }
    }
    @Override synchronized public void responseAvailable(    RPCResponse<xtreemfs_xloc_set_invalidateResponse> r){
      int osdNum=-1;
      for (int i=0; i < responses.length; i++) {
        if (responses[i] == r) {
          osdNum=i;
          break;
        }
      }
      assert(osdNum > -1);
      try {
        xtreemfs_xloc_set_invalidateResponse response=r.get();
        if (response.hasStatus()) {
          states[osdNum]=response.getStatus();
        }
        if (response.getIsPrimary()) {
          primaryResponded=true;
        }
        numResponses++;
      }
 catch (      Exception ex) {
        numErrors++;
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",ex.toString());
      }
 finally {
        r.freeBuffers();
        this.notifyAll();
      }
    }
    synchronized ReplicaStatus[] getReplicaStates(){
      ReplicaStatus[] result=new ReplicaStatus[states.length];
      System.arraycopy(states,0,result,0,states.length);
      return result;
    }
  }
  InvalidatedResponseListener listener=new InvalidatedResponseListener(responses);
  int numMaxErrors=responses.length - numAcksRequired;
synchronized (listener) {
    while (listener.numResponses < numAcksRequired) {
      listener.wait();
      if (listener.numErrors > numMaxErrors) {
        throw new MRCException(""String_Node_Str"");
      }
    }
  }
  long now=System.currentTimeMillis();
  long leaseEndTimeMs=now + leaseToMS;
synchronized (listener) {
    while (!listener.primaryResponded && now < leaseEndTimeMs && (listener.numResponses + listener.numErrors) < responses.length) {
      listener.wait(leaseEndTimeMs - now);
      now=System.currentTimeMillis();
    }
  }
  ReplicaStatus[] states=listener.getReplicaStates();
  return states;
}","/** 
 * Invalidate the majority of the replicas listed in xLocList. Will sleep until the lease has timed out if the primary didn't respond.
 * @param fileId
 * @param capability
 * @param xLocSet
 * @param numAcksRequired
 * @throws InterruptedException
 * @throws MRCException
 */
private ReplicaStatus[] invalidateReplicas(String fileId,Capability cap,XLocSet xLocSet,int numAcksRequired) throws InterruptedException, MRCException {
  @SuppressWarnings(""String_Node_Str"") final RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses=new RPCResponse[xLocSet.getReplicasCount()];
  OSDServiceClient client=master.getOSDClient();
  FileCredentials creds=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();
  for (int i=0; i < responses.length; i++) {
    ServiceUUID OSDServiceUUID=new ServiceUUID(Helper.getOSDUUIDFromXlocSet(xLocSet,i,0));
    try {
      responses[i]=client.xtreemfs_xloc_set_invalidate(OSDServiceUUID.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,creds,fileId);
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_DEBUG,this,ex);
      }
      throw new MRCException(ex);
    }
  }
  /** 
 * This local class is used to collect responses to the asynchronous invalidate requests. <br> It counts the number of errors and successful requests and stores an array of returned ReplicaStatus and a flag indicating if the primary did respond.
 */
class InvalidatedResponseListener implements RPCResponseAvailableListener<xtreemfs_xloc_set_invalidateResponse> {
    private int numResponses=0;
    private int numErrors=0;
    private boolean primaryResponded=false;
    private RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses;
    private ReplicaStatus[] states;
    public InvalidatedResponseListener(    RPCResponse<xtreemfs_xloc_set_invalidateResponse>[] responses){
      this.responses=responses;
      states=new ReplicaStatus[responses.length];
      for (int i=0; i < responses.length; i++) {
        responses[i].registerListener(this);
      }
    }
    @Override synchronized public void responseAvailable(    RPCResponse<xtreemfs_xloc_set_invalidateResponse> r){
      int osdNum=-1;
      for (int i=0; i < responses.length; i++) {
        if (responses[i] == r) {
          osdNum=i;
          break;
        }
      }
      assert(osdNum > -1);
      try {
        xtreemfs_xloc_set_invalidateResponse response=r.get();
        if (response.hasStatus()) {
          states[osdNum]=response.getStatus();
        }
        if (response.getIsPrimary()) {
          primaryResponded=true;
        }
        numResponses++;
      }
 catch (      Exception ex) {
        numErrors++;
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",ex.toString());
      }
 finally {
        r.freeBuffers();
        this.notifyAll();
      }
    }
    synchronized ReplicaStatus[] getReplicaStates(){
      ReplicaStatus[] result=new ReplicaStatus[states.length];
      System.arraycopy(states,0,result,0,states.length);
      return result;
    }
  }
  InvalidatedResponseListener listener=new InvalidatedResponseListener(responses);
  int numMaxErrors=responses.length - numAcksRequired;
synchronized (listener) {
    while (listener.numResponses < numAcksRequired) {
      listener.wait();
      if (listener.numErrors > numMaxErrors) {
        throw new MRCException(""String_Node_Str"");
      }
    }
  }
  long now=System.currentTimeMillis();
  long leaseEndTimeMs=now + leaseToMS;
synchronized (listener) {
    while (!listener.primaryResponded && now < leaseEndTimeMs && (listener.numResponses + listener.numErrors) < responses.length) {
      listener.wait(leaseEndTimeMs - now);
      now=System.currentTimeMillis();
    }
  }
  ReplicaStatus[] states=listener.getReplicaStates();
  return states;
}",0.995601552393273
113377,"/** 
 * Send update requests to every replica in the xLocSet that is not already up to date.
 * @param fileId
 * @param cap
 * @param xLocSet
 * @param authState
 * @param numAcksRequired
 * @param replicasUpToDate
 * @throws InterruptedException
 * @throws MRCException
 */
private void updateReplicas(String fileId,Capability cap,XLocSet xLocSet,AuthoritativeReplicaState authState,int numAcksRequired,Set<String> replicasUpToDate) throws InterruptedException, MRCException {
  final OSDServiceClient client=master.getOSDClient();
  ArrayList<ServiceUUID> OSDServiceUUIDs=new ArrayList<ServiceUUID>();
  for (int i=0; i < xLocSet.getReplicasCount(); i++) {
    String OSDUUID=Helper.getOSDUUIDFromXlocSet(xLocSet,i,0);
    if (!replicasUpToDate.contains(OSDUUID.toString())) {
      OSDServiceUUIDs.add(new ServiceUUID(OSDUUID));
    }
  }
  FileCredentials fileCredentials=FileCredentials.newBuilder().setXlocs(xLocSet).setXcap(cap.getXCap()).build();
  xtreemfs_rwr_auth_stateRequest authStateRequest=xtreemfs_rwr_auth_stateRequest.newBuilder().setFileId(fileId).setFileCredentials(fileCredentials).setState(authState).build();
  @SuppressWarnings(""String_Node_Str"") final RPCResponse<emptyResponse>[] responses=new RPCResponse[OSDServiceUUIDs.size()];
  for (int i=0; i < OSDServiceUUIDs.size(); i++) {
    try {
      final ServiceUUID OSDUUID=OSDServiceUUIDs.get(i);
      @SuppressWarnings(""String_Node_Str"") final RPCResponse<emptyResponse> rpcResponse=client.xtreemfs_rwr_auth_state_invalidated(OSDUUID.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,authStateRequest);
      responses[i]=rpcResponse;
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_DEBUG,this,ex);
      }
    }
  }
  /** 
 * This local class is used to collect responses to the asynchronous update requests.<br> It counts the number of errors and successful requests.
 */
class FetchInvalidatedResponseListener implements RPCResponseAvailableListener<emptyResponse> {
    private int numResponses=0;
    private int numErrors=0;
    FetchInvalidatedResponseListener(    RPCResponse<emptyResponse>[] responses){
      for (int i=0; i < responses.length; i++) {
        responses[i].registerListener(this);
      }
    }
    @Override synchronized public void responseAvailable(    RPCResponse<emptyResponse> r){
      try {
        r.get();
        numResponses++;
      }
 catch (      Exception ex) {
        numErrors++;
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",ex.toString());
      }
 finally {
        r.freeBuffers();
        this.notifyAll();
      }
    }
  }
  FetchInvalidatedResponseListener listener=new FetchInvalidatedResponseListener(responses);
  int numRequiredUpdates=numAcksRequired - replicasUpToDate.size();
  int numMaxErrors=OSDServiceUUIDs.size() - numRequiredUpdates;
synchronized (listener) {
    while (listener.numResponses < numRequiredUpdates) {
      listener.wait();
      if (listener.numErrors > numMaxErrors) {
        throw new MRCException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Send update requests to every replica in the xLocSet that is not already up to date.
 * @param fileId
 * @param cap
 * @param xLocSet
 * @param authState
 * @param numAcksRequired
 * @param replicasUpToDate
 * @throws InterruptedException
 * @throws MRCException
 */
private void updateReplicas(String fileId,Capability cap,XLocSet xLocSet,AuthoritativeReplicaState authState,int numAcksRequired,Set<String> replicasUpToDate) throws InterruptedException, MRCException {
  final OSDServiceClient client=master.getOSDClient();
  ArrayList<ServiceUUID> OSDServiceUUIDs=new ArrayList<ServiceUUID>();
  for (int i=0; i < xLocSet.getReplicasCount(); i++) {
    String OSDUUID=Helper.getOSDUUIDFromXlocSet(xLocSet,i,0);
    if (!replicasUpToDate.contains(OSDUUID.toString())) {
      OSDServiceUUIDs.add(new ServiceUUID(OSDUUID));
    }
  }
  FileCredentials fileCredentials=FileCredentials.newBuilder().setXlocs(xLocSet).setXcap(cap.getXCap()).build();
  xtreemfs_rwr_auth_stateRequest authStateRequest=xtreemfs_rwr_auth_stateRequest.newBuilder().setFileId(fileId).setFileCredentials(fileCredentials).setState(authState).build();
  @SuppressWarnings(""String_Node_Str"") final RPCResponse<emptyResponse>[] responses=new RPCResponse[OSDServiceUUIDs.size()];
  for (int i=0; i < OSDServiceUUIDs.size(); i++) {
    try {
      final ServiceUUID OSDUUID=OSDServiceUUIDs.get(i);
      @SuppressWarnings(""String_Node_Str"") final RPCResponse<emptyResponse> rpcResponse=client.xtreemfs_rwr_auth_state_invalidated(OSDUUID.getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,authStateRequest);
      responses[i]=rpcResponse;
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_DEBUG,this,ex);
      }
      throw new MRCException(ex);
    }
  }
  /** 
 * This local class is used to collect responses to the asynchronous update requests.<br> It counts the number of errors and successful requests.
 */
class FetchInvalidatedResponseListener implements RPCResponseAvailableListener<emptyResponse> {
    private int numResponses=0;
    private int numErrors=0;
    FetchInvalidatedResponseListener(    RPCResponse<emptyResponse>[] responses){
      for (int i=0; i < responses.length; i++) {
        responses[i].registerListener(this);
      }
    }
    @Override synchronized public void responseAvailable(    RPCResponse<emptyResponse> r){
      try {
        r.get();
        numResponses++;
      }
 catch (      Exception ex) {
        numErrors++;
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",ex.toString());
      }
 finally {
        r.freeBuffers();
        this.notifyAll();
      }
    }
  }
  FetchInvalidatedResponseListener listener=new FetchInvalidatedResponseListener(responses);
  int numRequiredUpdates=numAcksRequired - replicasUpToDate.size();
  int numMaxErrors=OSDServiceUUIDs.size() - numRequiredUpdates;
synchronized (listener) {
    while (listener.numResponses < numRequiredUpdates) {
      listener.wait();
      if (listener.numErrors > numMaxErrors) {
        throw new MRCException(""String_Node_Str"");
      }
    }
  }
}",0.9945894334818588
113378,"/** 
 * Remove the primary replica and provoke an invalid view error by accessing the file with an outdated xLocSet.
 * @param volumeName
 * @param fileName
 * @throws Exception
 */
private void removeReadOutdated(String volumeName,String fileName) throws Exception {
  AdminVolume volume=client.openVolume(volumeName,null,options);
  AdminFileHandle fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  int count=256 * 1024;
  ReusableBuffer data=SetupUtils.generateData(count,(byte)1);
  fileHandle.write(userCredentials,data.createViewBuffer().getData(),count,0);
  fileHandle.close();
  Thread.sleep(5 * 1000);
  fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  List<Replica> replicas=fileHandle.getReplicasList();
  Replica replica=replicas.get(0);
  int prevReplicaCount=fileHandle.getReplicasList().size();
  assertEquals(1,replica.getOsdUuidsCount());
  AdminVolume controlVolume=client.openVolume(volumeName,null,options);
  controlVolume.removeReplica(userCredentials,fileName,replica.getOsdUuids(0));
  AdminFileHandle controlFile=controlVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  assertEquals(controlFile.getReplicasList().size(),prevReplicaCount - 1);
  controlFile.close();
  controlVolume.close();
  readInvalidView(fileHandle);
  fileHandle.close();
  volume.close();
}","/** 
 * Remove the primary replica and provoke an invalid view error by accessing the file with an outdated xLocSet.
 * @param volumeName
 * @param fileName
 * @throws Exception
 */
private void removeReadOutdated(String volumeName,String fileName) throws Exception {
  AdminVolume volume=client.openVolume(volumeName,null,options);
  AdminFileHandle fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  int count=256 * 1024;
  ReusableBuffer data=SetupUtils.generateData(count,(byte)1);
  fileHandle.write(userCredentials,data.createViewBuffer().getData(),count,0);
  fileHandle.close();
  Thread.sleep(5 * 1000);
  fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  List<Replica> replicas=fileHandle.getReplicasList();
  Replica replica=replicas.get(1);
  int prevReplicaCount=fileHandle.getReplicasList().size();
  assertEquals(1,replica.getOsdUuidsCount());
  AdminVolume controlVolume=client.openVolume(volumeName,null,options);
  controlVolume.removeReplica(userCredentials,fileName,replica.getOsdUuids(0));
  AdminFileHandle controlFile=controlVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  assertEquals(controlFile.getReplicasList().size(),prevReplicaCount - 1);
  controlFile.close();
  controlVolume.close();
  readInvalidView(fileHandle);
  fileHandle.close();
  volume.close();
}",0.9993150684931508
113379,"private static void readInvalidView(AdminFileHandle file) throws AddressToUUIDNotFoundException, IOException {
  PosixErrorException catched=null;
  try {
    byte[] dataOut=new byte[1];
    file.read(userCredentials,dataOut,1,0);
  }
 catch (  PosixErrorException e) {
    catched=e;
  }
  assertTrue(catched != null);
  assertEquals(catched.getPosixError(),RPC.POSIXErrno.POSIX_ERROR_EAGAIN);
  assertTrue(catched.getMessage().contains(""String_Node_Str""));
}","private static void readInvalidView(AdminFileHandle file) throws AddressToUUIDNotFoundException, IOException {
  int prevMaxTries=options.getMaxTries();
  options.setMaxTries(1);
  try {
    byte[] dataOut=new byte[1];
    file.read(userCredentials,dataOut,1,0);
  }
 catch (  InvalidViewException e) {
  }
 finally {
    options.setMaxTries(prevMaxTries);
  }
}",0.5742092457420924
113380,"private void doUpdateXLocSetFromFlease(StageRequest m){
  final ASCIIString cellId=(ASCIIString)m.getArgs()[0];
  final int version=(Integer)m.getArgs()[1];
  final String fileId=ReplicaUpdatePolicy.cellToFileId(cellId);
  XLocSetVersionState state;
  try {
    state=layout.getXLocSetVersionState(fileId);
  }
 catch (  IOException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
    return;
  }
  if (state.getVersion() < version || (state.getVersion() == version && state.getInvalidated())) {
    state=state.toBuilder().setInvalidated(false).setVersion(version).build();
    try {
      layout.setXLocSetVersionState(fileId,state);
      master.getRWReplicationStage().setFleaseView(fileId,cellId,state);
    }
 catch (    IOException e) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
  }
  return;
}","private void doUpdateXLocSetFromFlease(StageRequest m){
  final ASCIIString cellId=(ASCIIString)m.getArgs()[0];
  final int version=(Integer)m.getArgs()[1];
  final String fileId=ReplicaUpdatePolicy.cellToFileId(cellId);
  XLocSetVersionState state;
  try {
    state=layout.getXLocSetVersionState(fileId);
  }
 catch (  IOException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
    return;
  }
  if (state.getVersion() < version) {
    state=state.toBuilder().setInvalidated(false).setVersion(version).build();
    try {
      layout.setXLocSetVersionState(fileId,state);
      master.getRWReplicationStage().setFleaseView(fileId,cellId,state);
    }
 catch (    IOException e) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
  }
  return;
}",0.9660922734852696
113381,"@BeforeClass public static void initializeTest() throws Exception {
  System.out.println(""String_Node_Str"" + VersionedXLocSetTest.class.getSimpleName());
  FSUtils.delTree(new java.io.File(SetupUtils.TEST_DIR));
  Logging.start(Logging.LEVEL_WARN);
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.RPC_CLIENT,TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.DIR_CLIENT,TestEnvironment.Services.MRC,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osds=new OSD[NUM_OSDS];
  configs=SetupUtils.createMultipleOSDConfigs(NUM_OSDS);
  for (int i=0; i < NUM_OSDS; i++) {
    osds[i]=new OSD(configs[i]);
  }
  dirAddress=testEnv.getDIRAddress().getHostName() + ""String_Node_Str"" + testEnv.getDIRAddress().getPort();
  mrcAddress=testEnv.getMRCAddress().getHostName() + ""String_Node_Str"" + testEnv.getMRCAddress().getPort();
  defaultStripingPolicy=StripingPolicy.newBuilder().setType(StripingPolicyType.STRIPING_POLICY_RAID0).setStripeSize(128).setWidth(1).build();
  userCredentials=UserCredentials.newBuilder().setUsername(""String_Node_Str"").addGroups(""String_Node_Str"").build();
  auth=RPCAuthentication.authNone;
  options=new Options();
  client=ClientFactory.createAdminClient(dirAddress,userCredentials,null,options);
  client.start();
}","@BeforeClass public static void initializeTest() throws Exception {
  System.out.println(""String_Node_Str"" + VersionedXLocSetTest.class.getSimpleName());
  FSUtils.delTree(new java.io.File(SetupUtils.TEST_DIR));
  Logging.start(Logging.LEVEL_WARN);
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.RPC_CLIENT,TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.DIR_CLIENT,TestEnvironment.Services.MRC,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osds=new OSD[NUM_OSDS];
  configs=SetupUtils.createMultipleOSDConfigs(NUM_OSDS);
  for (int i=0; i < NUM_OSDS; i++) {
    osds[i]=new OSD(configs[i]);
  }
  dirAddress=testEnv.getDIRAddress().getHostName() + ""String_Node_Str"" + testEnv.getDIRAddress().getPort();
  mrcAddress=testEnv.getMRCAddress().getHostName() + ""String_Node_Str"" + testEnv.getMRCAddress().getPort();
  defaultStripingPolicy=StripingPolicy.newBuilder().setType(StripingPolicyType.STRIPING_POLICY_RAID0).setStripeSize(128).setWidth(1).build();
  userCredentials=UserCredentials.newBuilder().setUsername(""String_Node_Str"").addGroups(""String_Node_Str"").build();
  auth=RPCAuthentication.authNone;
  options=new Options();
  options.setMaxTries(2);
  client=ClientFactory.createAdminClient(dirAddress,userCredentials,null,options);
  client.start();
  OFT_CLEAN_INTERVAL_MS=(Long)PA.getValue(osds[0].getDispatcher().getPreprocStage(),""String_Node_Str"");
  LEASE_TIMEOUT_MS=configs[0].getFleaseLeaseToMS();
}",0.9393333333333334
113382,"private void testInvalidViewOnAdd(String volumeName,String fileName) throws Exception {
  AdminVolume outdatedVolume=client.openVolume(volumeName,null,options);
  AdminFileHandle outdatedFile=outdatedVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  System.out.println(""String_Node_Str"");
  ReusableBuffer data=SetupUtils.generateData(256,(byte)1);
  outdatedFile.write(userCredentials,data.createViewBuffer().getData(),256,0);
  outdatedFile.close();
  System.out.println(""String_Node_Str"");
  outdatedFile=outdatedVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  AdminVolume volume=client.openVolume(volumeName,null,options);
  System.out.println(""String_Node_Str"");
  addReplicas(volume,fileName,1);
  volume.close();
  System.out.println(""String_Node_Str"");
  PosixErrorException catched=null;
  try {
    byte[] dataOut=new byte[1];
    outdatedFile.read(userCredentials,dataOut,1,0);
  }
 catch (  PosixErrorException e) {
    catched=e;
  }
 finally {
    outdatedFile.close();
    outdatedVolume.close();
  }
  assertTrue(catched != null);
  assertEquals(catched.getPosixError(),RPC.POSIXErrno.POSIX_ERROR_EAGAIN);
  assertTrue(catched.getMessage().contains(""String_Node_Str""));
}","private void testInvalidViewOnAdd(String volumeName,String fileName) throws Exception {
  AdminVolume outdatedVolume=client.openVolume(volumeName,null,options);
  AdminFileHandle outdatedFile=outdatedVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  System.out.println(""String_Node_Str"");
  ReusableBuffer data=SetupUtils.generateData(256,(byte)1);
  outdatedFile.write(userCredentials,data.createViewBuffer().getData(),256,0);
  outdatedFile.close();
  System.out.println(""String_Node_Str"");
  outdatedFile=outdatedVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  AdminVolume volume=client.openVolume(volumeName,null,options);
  System.out.println(""String_Node_Str"");
  addReplicas(volume,fileName,1);
  volume.close();
  System.out.println(""String_Node_Str"");
  readInvalidView(outdatedFile);
  outdatedFile.close();
  outdatedVolume.close();
}",0.7779751332149201
113383,"@Ignore @Test public void testRonlyInvalidViewOnAdd() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.close();
  int repl_flags=ReplicationFlags.setFullReplica(ReplicationFlags.setSequentialStrategy(0));
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY,2,repl_flags);
  testInvalidViewOnAdd(volumeName,fileName);
}","@Test public void testRonlyInvalidViewOnAdd() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.setReplicaSelectionPolicy(userCredentials,Helper.policiesToString(new OSDSelectionPolicyType[]{OSDSelectionPolicyType.OSD_SELECTION_POLICY_SORT_UUID}));
  int repl_flags=ReplicationFlags.setFullReplica(ReplicationFlags.setSequentialStrategy(0));
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY,2,repl_flags);
  volume.close();
  testInvalidViewOnAdd(volumeName,fileName);
}",0.8586956521739131
113384,"@Ignore @Test public void testWqRqRemoveReadOutdated() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ,3,0);
  volume.setOSDSelectionPolicy(userCredentials,Helper.policiesToString(new OSDSelectionPolicyType[]{OSDSelectionPolicyType.OSD_SELECTION_POLICY_FILTER_DEFAULT,OSDSelectionPolicyType.OSD_SELECTION_POLICY_SORT_UUID}));
  volume.setReplicaSelectionPolicy(userCredentials,Helper.policiesToString(new OSDSelectionPolicyType[]{OSDSelectionPolicyType.OSD_SELECTION_POLICY_SORT_UUID}));
  volume.close();
  removeReadOutdated(volumeName,fileName);
}","@Test public void testWqRqRemoveReadOutdated() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ,3,0);
  volume.setOSDSelectionPolicy(userCredentials,Helper.policiesToString(new OSDSelectionPolicyType[]{OSDSelectionPolicyType.OSD_SELECTION_POLICY_FILTER_DEFAULT,OSDSelectionPolicyType.OSD_SELECTION_POLICY_SORT_UUID}));
  volume.setReplicaSelectionPolicy(userCredentials,Helper.policiesToString(new OSDSelectionPolicyType[]{OSDSelectionPolicyType.OSD_SELECTION_POLICY_SORT_UUID}));
  volume.close();
  removeReadOutdated(volumeName,fileName);
}",0.9952267303102624
113385,"private void removeReadOutdated(String volumeName,String fileName) throws Exception {
  AdminVolume volume=client.openVolume(volumeName,null,options);
  AdminFileHandle fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  int count=256 * 1024;
  ReusableBuffer data=SetupUtils.generateData(count,(byte)1);
  System.out.println(""String_Node_Str"");
  fileHandle.write(userCredentials,data.createViewBuffer().getData(),count,0);
  fileHandle.close();
  Thread.sleep(20 * 1000);
  System.out.println(""String_Node_Str"");
  fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  List<Replica> replicas=fileHandle.getReplicasList();
  System.out.println(replicas);
  Replica replica=replicas.get(0);
  int prevReplicaCount=fileHandle.getReplicasList().size();
  System.out.println(""String_Node_Str"" + replica.getOsdUuids(0));
  assertEquals(1,replica.getOsdUuidsCount());
  AdminVolume controlVolume=client.openVolume(volumeName,null,options);
  controlVolume.removeReplica(userCredentials,fileName,replica.getOsdUuids(0));
  AdminFileHandle controlFile=controlVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  assertEquals(controlFile.getReplicasList().size(),prevReplicaCount - 1);
  System.out.println(controlFile.getReplicasList());
  controlFile.close();
  controlVolume.close();
  System.out.println(""String_Node_Str"");
  Thread.sleep(70 * 1000);
  byte[] data2=new byte[1];
  fileHandle.read(userCredentials,data2,1,0);
  fileHandle.close();
  assertEquals(data2[0],(byte)1);
  volume.close();
}","private void removeReadOutdated(String volumeName,String fileName) throws Exception {
  AdminVolume volume=client.openVolume(volumeName,null,options);
  AdminFileHandle fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_CREAT,SYSTEM_V_FCNTL_H_O_RDWR),0777);
  int count=256 * 1024;
  ReusableBuffer data=SetupUtils.generateData(count,(byte)1);
  System.out.println(""String_Node_Str"");
  fileHandle.write(userCredentials,data.createViewBuffer().getData(),count,0);
  fileHandle.close();
  Thread.sleep(20 * 1000);
  System.out.println(""String_Node_Str"");
  fileHandle=volume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  List<Replica> replicas=fileHandle.getReplicasList();
  System.out.println(replicas);
  Replica replica=replicas.get(0);
  int prevReplicaCount=fileHandle.getReplicasList().size();
  System.out.println(""String_Node_Str"" + replica.getOsdUuids(0));
  assertEquals(1,replica.getOsdUuidsCount());
  AdminVolume controlVolume=client.openVolume(volumeName,null,options);
  controlVolume.removeReplica(userCredentials,fileName,replica.getOsdUuids(0));
  AdminFileHandle controlFile=controlVolume.openFile(userCredentials,fileName,Helper.flagsToInt(SYSTEM_V_FCNTL_H_O_RDONLY));
  assertEquals(controlFile.getReplicasList().size(),prevReplicaCount - 1);
  System.out.println(controlFile.getReplicasList());
  controlFile.close();
  controlVolume.close();
  System.out.println(""String_Node_Str"");
  Thread.sleep(70 * 1000);
  System.out.println(""String_Node_Str"");
  readInvalidView(fileHandle);
  fileHandle.close();
  volume.close();
}",0.9560707748627212
113386,"@Ignore @Test public void testWqRqInvalidViewOnAdd() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ,2,0);
  volume.close();
  testInvalidViewOnAdd(volumeName,fileName);
}","@Test public void testWqRqInvalidViewOnAdd() throws Exception {
  String volumeName=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  client.createVolume(mrcAddress,auth,userCredentials,volumeName);
  AdminVolume volume=client.openVolume(volumeName,null,options);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ,2,0);
  volume.close();
  testInvalidViewOnAdd(volumeName,fileName);
}",0.9912854030501088
113387,"private void processObjectFetched(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final ObjectVersionMapping record=(ObjectVersionMapping)method.getArgs()[1];
    final InternalObjectData data=(InternalObjectData)method.getArgs()[2];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[3];
    ReplicatedFileState state=files.get(fileId);
    if (state != null) {
      if (error != null) {
        numObjsInFlight--;
        fetchObjects();
        failed(state,error,""String_Node_Str"");
      }
 else {
        final int bytes=data.getData().remaining();
        master.getStorageStage().writeObjectWithoutGMax(fileId,record.getObjectNumber(),state.getsPolicy(),0,data.getData(),CowPolicy.PolicyNoCow,null,false,record.getObjectVersion(),null,new WriteObjectCallback(){
          @Override public void writeComplete(          OSDWriteResponse result,          ErrorResponse error){
            if (error != null) {
              Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",ErrorUtils.formatError(error));
            }
          }
        }
);
        master.getPreprocStage().pingFile(fileId);
        master.objectReplicated();
        master.replicatedDataReceived(bytes);
        numObjsInFlight--;
        final int numPendingFile=state.getNumObjectsPending() - 1;
        state.setNumObjectsPending(numPendingFile);
        state.getPolicy().objectFetched(record.getObjectVersion());
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId,numPendingFile);
        fetchObjects();
        if (numPendingFile == 0) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId);
          doOpen(state);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","private void processObjectFetched(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final ObjectVersionMapping record=(ObjectVersionMapping)method.getArgs()[1];
    final InternalObjectData data=(InternalObjectData)method.getArgs()[2];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[3];
    ReplicatedFileState state=files.get(fileId);
    if (state != null) {
      if (error != null) {
        numObjsInFlight--;
        fetchObjects();
        failed(state,error,""String_Node_Str"");
      }
 else       if (data.getData() == null) {
        numObjsInFlight--;
        fetchObjects();
        ErrorResponse generatedError=ErrorResponse.newBuilder().setErrorType(RPC.ErrorType.INTERNAL_SERVER_ERROR).setErrorMessage(""String_Node_Str"").build();
        failed(state,generatedError,""String_Node_Str"");
      }
 else {
        final int bytes=data.getData().remaining();
        master.getStorageStage().writeObjectWithoutGMax(fileId,record.getObjectNumber(),state.getsPolicy(),0,data.getData(),CowPolicy.PolicyNoCow,null,false,record.getObjectVersion(),null,new WriteObjectCallback(){
          @Override public void writeComplete(          OSDWriteResponse result,          ErrorResponse error){
            if (error != null) {
              Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",ErrorUtils.formatError(error));
            }
          }
        }
);
        master.getPreprocStage().pingFile(fileId);
        master.objectReplicated();
        master.replicatedDataReceived(bytes);
        numObjsInFlight--;
        final int numPendingFile=state.getNumObjectsPending() - 1;
        state.setNumObjectsPending(numPendingFile);
        state.getPolicy().objectFetched(record.getObjectVersion());
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId,numPendingFile);
        fetchObjects();
        if (numPendingFile == 0) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId);
          doOpen(state);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.924838940586972
113388,"public void waitForShutdown() throws Exception {
  client.waitForShutdown();
  fleaseClient.waitForShutdown();
  fstage.waitForShutdown();
  masterEpochThread.waitForShutdown();
  super.waitForShutdown();
}","@Override public void waitForShutdown() throws Exception {
  client.waitForShutdown();
  fleaseClient.waitForShutdown();
  fstage.waitForShutdown();
  masterEpochThread.waitForShutdown();
  super.waitForShutdown();
}",0.976303317535545
113389,"private void doUpdateXLocSetFromFlease(StageRequest m){
  final ASCIIString cellId=(ASCIIString)m.getArgs()[0];
  final int version=(int)m.getArgs()[1];
  final String fileId=ReplicaUpdatePolicy.cellToFileId(cellId);
  XLocSetVersionState state;
  try {
    state=layout.getXLocSetVersionState(fileId);
  }
 catch (  IOException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
    return;
  }
  if (state.getVersion() < version || (state.getVersion() == version && state.getInvalidated())) {
    state=state.toBuilder().setInvalidated(false).setVersion(version).build();
    try {
      layout.setXLocSetVersionState(fileId,state);
      master.getRWReplicationStage().setFleaseView(fileId,cellId,state);
    }
 catch (    IOException e) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
  }
  return;
}","private void doUpdateXLocSetFromFlease(StageRequest m){
  final ASCIIString cellId=(ASCIIString)m.getArgs()[0];
  final int version=(Integer)m.getArgs()[1];
  final String fileId=ReplicaUpdatePolicy.cellToFileId(cellId);
  XLocSetVersionState state;
  try {
    state=layout.getXLocSetVersionState(fileId);
  }
 catch (  IOException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
    return;
  }
  if (state.getVersion() < version || (state.getVersion() == version && state.getInvalidated())) {
    state=state.toBuilder().setInvalidated(false).setVersion(version).build();
    try {
      layout.setXLocSetVersionState(fileId,state);
      master.getRWReplicationStage().setFleaseView(fileId,cellId,state);
    }
 catch (    IOException e) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
  }
  return;
}",0.9946120689655172
113390,"private void addReplicas(Volume volume,String fileName,int replicaNumber) throws IOException, InterruptedException {
  List<String> osdUUIDs=volume.getSuitableOSDs(userCredentials,fileName,replicaNumber);
  assert(osdUUIDs.size() >= replicaNumber);
  int currentReplicaNumber=volume.listReplicas(userCredentials,fileName).getReplicasCount();
  int repl_flags;
  try {
    String rpAsJSON=volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"");
    Map<String,Object> rp=(Map<String,Object>)JSONParser.parseJSON(new JSONString(rpAsJSON));
    repl_flags=(int)((long)rp.get(""String_Node_Str""));
  }
 catch (  JSONException e) {
    throw new IOException(e);
  }
  Thread.sleep(16 * 1000);
  for (int i=0; i < replicaNumber; i++) {
    Replica replica=Replica.newBuilder().setStripingPolicy(defaultStripingPolicy).setReplicationFlags(repl_flags).addOsdUuids(osdUUIDs.get(i)).build();
    volume.addReplica(userCredentials,fileName,replica);
    Thread.sleep(16 * 1000);
    System.out.println(""String_Node_Str"" + osdUUIDs.get(i));
  }
  assertEquals(currentReplicaNumber + replicaNumber,volume.listReplicas(userCredentials,fileName).getReplicasCount());
}","private void addReplicas(Volume volume,String fileName,int replicaNumber) throws IOException, InterruptedException {
  List<String> osdUUIDs=volume.getSuitableOSDs(userCredentials,fileName,replicaNumber);
  assert(osdUUIDs.size() >= replicaNumber);
  int currentReplicaNumber=volume.listReplicas(userCredentials,fileName).getReplicasCount();
  int repl_flags;
  try {
    String rpAsJSON=volume.getXAttr(userCredentials,""String_Node_Str"",""String_Node_Str"");
    Map<String,Object> rp=(Map<String,Object>)JSONParser.parseJSON(new JSONString(rpAsJSON));
    long temp=((Long)rp.get(""String_Node_Str""));
    repl_flags=(int)temp;
  }
 catch (  JSONException e) {
    throw new IOException(e);
  }
  Thread.sleep(16 * 1000);
  for (int i=0; i < replicaNumber; i++) {
    Replica replica=Replica.newBuilder().setStripingPolicy(defaultStripingPolicy).setReplicationFlags(repl_flags).addOsdUuids(osdUUIDs.get(i)).build();
    volume.addReplica(userCredentials,fileName,replica);
    Thread.sleep(16 * 1000);
    System.out.println(""String_Node_Str"" + osdUUIDs.get(i));
  }
  assertEquals(currentReplicaNumber + replicaNumber,volume.listReplicas(userCredentials,fileName).getReplicasCount());
}",0.96343537414966
113391,"/** 
 * Build the   {@link BenchmarkConfig} object.
 * @return the build {@link BenchmarkConfig} object
 * @throws Exception
 */
public BenchmarkConfig build() throws Exception {
  verifyNoCleanup();
  if (null != this.parent)   mergeParent();
  String[] dirAddresses=Controller.getDefaultDir();
  if (null != dirAddresses)   setDirAddresses(dirAddresses);
  if (null == props.getProperty(""String_Node_Str""))   setDirAddresses(new String[]{""String_Node_Str""});
  BenchmarkConfig config=new BenchmarkConfig(props,this.options,this.policyAttributes);
  config.setDefaults();
  return config;
}","/** 
 * Build the   {@link BenchmarkConfig} object.
 * @return the build {@link BenchmarkConfig} object
 * @throws Exception
 */
public BenchmarkConfig build() throws Exception {
  verifyNoCleanup();
  if (null != this.parent)   mergeParent();
  if (null == props.getProperty(""String_Node_Str"")) {
    String[] dirAddresses=Controller.getDefaultDir();
    if (null != dirAddresses)     setDirAddresses(dirAddresses);
 else     setDirAddresses(new String[]{""String_Node_Str""});
  }
  BenchmarkConfig config=new BenchmarkConfig(props,this.options,this.policyAttributes);
  config.setDefaults();
  return config;
}",0.9001663893510815
113392,"@Override public FSDataOutputStream create(Path path,FsPermission fp,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable p) throws IOException {
  Volume xtreemfsVolume=getVolumeFromPath(path);
  final String pathString=preparePath(path,xtreemfsVolume);
  int flags=SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber();
  if (overwrite) {
    flags|=SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber();
  }
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",pathString,overwrite);
  }
  mkdirs(path.getParent());
  final FileHandle fileHandle=xtreemfsVolume.openFile(userCredentials,pathString,flags,fp.toShort());
  return new FSDataOutputStream(new XtreemFSFileOutputStream(userCredentials,fileHandle,pathString,useWriteBuffer,writeBufferSize),statistics);
}","@Override public FSDataOutputStream create(Path path,FsPermission fp,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable p) throws IOException {
  Volume xtreemfsVolume=getVolumeFromPath(path);
  final String pathString=preparePath(path,xtreemfsVolume);
  int flags=SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber();
  if (overwrite) {
    flags|=SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber();
  }
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",pathString,overwrite);
  }
  if (pathString.lastIndexOf(""String_Node_Str"") != 0) {
    mkdirs(path.getParent());
  }
  final FileHandle fileHandle=xtreemfsVolume.openFile(userCredentials,pathString,flags,fp.toShort());
  return new FSDataOutputStream(new XtreemFSFileOutputStream(userCredentials,fileHandle,pathString,useWriteBuffer,writeBufferSize),statistics);
}",0.9660087719298246
113393,"@Override public FSDataOutputStream append(Path path,int i,Progressable p) throws IOException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public FSDataOutputStream append(Path path,int bufferSize,Progressable p) throws IOException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9724770642201837
113394,"/** 
 * Deletes all created volumes and files and shuts down all clients. This method should be called when all benchmarks are finished. The deletion of the volumes and files is regulated by the noCleanup options in  {@link Config}.
 * @throws Exception
 */
public void teardown() throws Exception {
  deleteVolumesAndFiles();
  clientManager.shutdownClients();
  if (config.isOsdCleanup())   volumeManager.cleanupOSD();
}","/** 
 * Deletes all created volumes and files and shuts down all clients. This method should be called when all benchmarks are finished. The deletion of the volumes and files is regulated by the noCleanup options in  {@link Config}.
 * @throws Exception
 */
public void teardown() throws Exception {
  deleteVolumesAndFiles();
  if (config.isOsdCleanup())   volumeManager.cleanupOSD();
  clientManager.shutdownClients();
}",0.9170616113744076
113395,"private void verifySizesAndThreads(long size,int threads,BenchmarkType type){
  if (size % (config.getStripeSizeInBytes() * config.getStripeWidth()) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  if ((type == BenchmarkType.RAND_READ) || (type == BenchmarkType.RAND_WRITE)) {
    if (config.getBasefileSizeInBytes() < size)     throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if ((type == BenchmarkType.FILES_WRITE) || (type == BenchmarkType.FILES_READ)) {
    if (size % config.getFilesize() != 0)     throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  if (volumeManager.getVolumes().size() < threads)   throw new IllegalArgumentException(""String_Node_Str"");
}","private void verifySizesAndThreads(long size,int threads,BenchmarkType type){
  if ((type == BenchmarkType.SEQ_READ) || (type == BenchmarkType.SEQ_WRITE)) {
    if (size % (config.getStripeSizeInBytes() * config.getStripeWidth()) != 0)     throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  if ((type == BenchmarkType.RAND_READ) || (type == BenchmarkType.RAND_WRITE)) {
    if (config.getBasefileSizeInBytes() < size)     throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if ((type == BenchmarkType.FILES_WRITE) || (type == BenchmarkType.FILES_READ)) {
    if (size % config.getFilesize() != 0)     throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  if (volumeManager.getVolumes().size() < threads)   throw new IllegalArgumentException(""String_Node_Str"");
}",0.9459962756052142
113396,"void openVolumes(String... volumeName) throws IOException {
  this.volumes=new LinkedList<Volume>();
  for (  String each : volumeName) {
    volumes.add(createAndOpenVolume(each));
  }
}","void openVolumes(String... volumeName) throws IOException {
  this.volumes=new LinkedList<Volume>();
  for (  String each : volumeName) {
    volumes.add(createAndOpenVolume(each));
  }
  verifyVolumeSizes();
}",0.9420654911838792
113397,"private void setStripeSizeAndWidth(Volume volume) throws IOException {
  int size, width;
  int sizeConf=config.getStripeSizeInKiB();
  int widthConf=config.getStripeWidth();
  int sizeVol=getVolStripeSize(volume);
  int widthVol=getVolStripeWidth(volume);
  if (!config.isStripeSizeSet() && !config.isStripeWidthSet()) {
    config.setStripeSizeInBytes(sizeVol * BenchmarkUtils.KiB_IN_BYTES);
    config.setStripeWidth(widthVol);
    return;
  }
 else {
    if (!config.isStripeSizeSet() && config.isStripeWidthSet()) {
      size=sizeVol;
      width=widthConf;
    }
 else     if (config.isStripeSizeSet() && !config.isStripeWidthSet()) {
      size=sizeConf;
      width=widthVol;
    }
 else     if (config.isStripeSizeSet() && config.isStripeWidthSet()) {
      size=sizeConf;
      width=widthConf;
    }
 else     throw new UnknownError(""String_Node_Str"");
  }
  String val=""String_Node_Str"" + width + ""String_Node_Str""+ size+ ""String_Node_Str"";
  volume.setXAttr(config.getUserCredentials(),""String_Node_Str"",""String_Node_Str"",val,MRC.XATTR_FLAGS.XATTR_FLAGS_REPLACE);
  config.setStripeSizeInBytes(size);
  config.setStripeWidth(width);
}","private void setStripeSizeAndWidth(Volume volume) throws IOException {
  int size, width;
  int sizeConf=config.getStripeSizeInKiB();
  int widthConf=config.getStripeWidth();
  int sizeVol=getVolStripeSize(volume);
  int widthVol=getVolStripeWidth(volume);
  if (!config.isStripeSizeSet() && !config.isStripeWidthSet()) {
    config.setStripeSizeInBytes(sizeVol * BenchmarkUtils.KiB_IN_BYTES);
    config.setStripeWidth(widthVol);
    return;
  }
 else {
    if (!config.isStripeSizeSet() && config.isStripeWidthSet()) {
      size=sizeVol;
      width=widthConf;
    }
 else     if (config.isStripeSizeSet() && !config.isStripeWidthSet()) {
      size=sizeConf;
      width=widthVol;
    }
 else     if (config.isStripeSizeSet() && config.isStripeWidthSet()) {
      size=sizeConf;
      width=widthConf;
    }
 else     throw new UnknownError(""String_Node_Str"");
  }
  String val=""String_Node_Str"" + width + ""String_Node_Str""+ size+ ""String_Node_Str"";
  volume.setXAttr(config.getUserCredentials(),""String_Node_Str"",""String_Node_Str"",val,MRC.XATTR_FLAGS.XATTR_FLAGS_REPLACE);
  config.setStripeSizeInBytes(size * BenchmarkUtils.KiB_IN_BYTES);
  config.setStripeWidth(width);
}",0.9871023215821152
113398,"@Test public void testUnenabledMdCache(){
  metadataCache=new MetadataCache(0,10000);
  assertEquals(0,metadataCache.size());
  assertEquals(0,metadataCache.capacity());
  assertNull(metadataCache.getDirEntries(""String_Node_Str"",10,100));
  assertNull(metadataCache.getStat(""String_Node_Str""));
  assertNull(metadataCache.getXAttr(""String_Node_Str"",""String_Node_Str"").getFirst());
  assertFalse(metadataCache.getXAttr(""String_Node_Str"",""String_Node_Str"").getSecond());
  assertNull(metadataCache.getXAttrs(""String_Node_Str""));
  assertEquals(0,metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"").getFirst());
  assertFalse(metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"").getSecond());
  metadataCache.invalidate(""String_Node_Str"");
  metadataCache.invalidateDirEntries(""String_Node_Str"");
  metadataCache.invalidateDirEntry(""String_Node_Str"",""String_Node_Str"");
  metadataCache.invalidatePrefix(""String_Node_Str"");
  metadataCache.invalidateStat(""String_Node_Str"");
  metadataCache.invalidateXAttr(""String_Node_Str"",""String_Node_Str"");
  metadataCache.invalidateXAttrs(""String_Node_Str"");
  metadataCache.updateDirEntries(""String_Node_Str"",DirectoryEntries.getDefaultInstance());
  metadataCache.updateStat(""String_Node_Str"",Stat.getDefaultInstance());
  metadataCache.updateStatAttributes(""String_Node_Str"",Stat.getDefaultInstance(),100);
  metadataCache.updateStatFromOSDWriteResponse(""String_Node_Str"",OSDWriteResponse.getDefaultInstance());
  metadataCache.updateStatTime(""String_Node_Str"",1034l,100);
  metadataCache.updateXAttr(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  metadataCache.updateXAttrs(""String_Node_Str"",listxattrResponse.getDefaultInstance());
  metadataCache.renamePrefix(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testUnenabledMdCache(){
  metadataCache=new MetadataCache(0,10000);
  assertEquals(0,metadataCache.size());
  assertEquals(0,metadataCache.capacity());
  assertNull(metadataCache.getDirEntries(""String_Node_Str"",10,100));
  assertNull(metadataCache.getStat(""String_Node_Str""));
  assertNull(metadataCache.getXAttr(""String_Node_Str"",""String_Node_Str"").getFirst());
  assertFalse(metadataCache.getXAttr(""String_Node_Str"",""String_Node_Str"").getSecond());
  assertNull(metadataCache.getXAttrs(""String_Node_Str""));
  assertEquals(0,metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"").getFirst().intValue());
  assertFalse(metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"").getSecond());
  metadataCache.invalidate(""String_Node_Str"");
  metadataCache.invalidateDirEntries(""String_Node_Str"");
  metadataCache.invalidateDirEntry(""String_Node_Str"",""String_Node_Str"");
  metadataCache.invalidatePrefix(""String_Node_Str"");
  metadataCache.invalidateStat(""String_Node_Str"");
  metadataCache.invalidateXAttr(""String_Node_Str"",""String_Node_Str"");
  metadataCache.invalidateXAttrs(""String_Node_Str"");
  metadataCache.updateDirEntries(""String_Node_Str"",DirectoryEntries.getDefaultInstance());
  metadataCache.updateStat(""String_Node_Str"",Stat.getDefaultInstance());
  metadataCache.updateStatAttributes(""String_Node_Str"",Stat.getDefaultInstance(),100);
  metadataCache.updateStatFromOSDWriteResponse(""String_Node_Str"",OSDWriteResponse.getDefaultInstance());
  metadataCache.updateStatTime(""String_Node_Str"",1034l,100);
  metadataCache.updateXAttr(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  metadataCache.updateXAttrs(""String_Node_Str"",listxattrResponse.getDefaultInstance());
  metadataCache.renamePrefix(""String_Node_Str"",""String_Node_Str"");
}",0.9969092441697106
113399,"@Test public void testGetXAttrSize() throws Exception {
  metadataCache.updateXAttrs(""String_Node_Str"",getDummyXattrs());
  metadataCache.updateXAttr(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Tupel<Integer,Boolean> tupel=metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"");
  assertEquals(10,tupel.getFirst());
  assertTrue(tupel.getSecond());
}","@Test public void testGetXAttrSize() throws Exception {
  metadataCache.updateXAttrs(""String_Node_Str"",getDummyXattrs());
  metadataCache.updateXAttr(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Tupel<Integer,Boolean> tupel=metadataCache.getXAttrSize(""String_Node_Str"",""String_Node_Str"");
  assertEquals(10,tupel.getFirst().intValue());
  assertTrue(tupel.getSecond());
}",0.9854689564068692
113400,"@Test public final void testReusableViewBuffersOfReusableViewBuffers(){
  ReusableBuffer buf=null;
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  ReusableBuffer viewBuffer2=viewBuffer.createViewBuffer();
  BufferPool.free(viewBuffer2);
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(viewBuffer);
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}","@Test public final void testReusableViewBuffersOfReusableViewBuffers(){
  ReusableBuffer buf=null;
  int currentPoolSize=Math.max(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE) - 1);
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  ReusableBuffer viewBuffer2=viewBuffer.createViewBuffer();
  BufferPool.free(viewBuffer2);
  assertEquals(""String_Node_Str"",currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(viewBuffer);
  assertEquals(""String_Node_Str"",currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}",0.9236479321314952
113401,"@Test public final void testReusableViewBuffers(){
  ReusableBuffer buf=null;
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  BufferPool.free(viewBuffer);
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}","@Test public final void testReusableViewBuffers(){
  ReusableBuffer buf=null;
  int currentPoolSize=Math.max(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE) - 1);
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  BufferPool.free(viewBuffer);
  assertEquals(""String_Node_Str"",currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}",0.9140939597315436
113402,"@Test(expected=AssertionError.class) public final void testDoubleFreeOfRecursiveViewBuffersThrows(){
  assertThatAssertionsAreEnabled();
  ReusableBuffer buf=null;
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  ReusableBuffer viewBuffer2=viewBuffer.createViewBuffer();
  BufferPool.free(viewBuffer2);
  BufferPool.free(viewBuffer);
  BufferPool.free(buf);
  BufferPool.free(viewBuffer2);
}","@Test(expected=AssertionError.class) public final void testDoubleFreeOfRecursiveViewBuffersThrows(){
  assertThatAssertionsAreEnabled();
  ReusableBuffer buf=null;
  int currentPoolSize=Math.max(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE) - 1);
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  ReusableBuffer viewBuffer=buf.createViewBuffer();
  ReusableBuffer viewBuffer2=viewBuffer.createViewBuffer();
  BufferPool.free(viewBuffer2);
  BufferPool.free(viewBuffer);
  BufferPool.free(buf);
  BufferPool.free(viewBuffer2);
}",0.9399744572158364
113403,"@Test public final void testSimpleAllocateAndFree(){
  ReusableBuffer buf=null;
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(""String_Node_Str"",0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}","@Test public final void testSimpleAllocateAndFree(){
  ReusableBuffer buf=null;
  int currentPoolSize=Math.max(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE) - 1);
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(""String_Node_Str"",currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(""String_Node_Str"",currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(""String_Node_Str"",currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
}",0.897196261682243
113404,"@Test(expected=AssertionError.class) public final void testDoubleFreeThrows(){
  assertThatAssertionsAreEnabled();
  ReusableBuffer buf=null;
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
}","@Test(expected=AssertionError.class) public final void testDoubleFreeThrows(){
  assertThatAssertionsAreEnabled();
  ReusableBuffer buf=null;
  int currentPoolSize=Math.max(0,BufferPool.getPoolSize(TEST_BUFFER_SIZE) - 1);
  buf=BufferPool.allocate(TEST_BUFFER_SIZE);
  assertEquals(currentPoolSize,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
  assertEquals(currentPoolSize + 1,BufferPool.getPoolSize(TEST_BUFFER_SIZE));
  BufferPool.free(buf);
}",0.9117647058823528
113405,"/** 
 * @param args args[0] = URL to existing volume e.g., pbrpcs://localhost/regular
 * @return
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.out.println(""String_Node_Str"");
    return;
  }
  Client client=null;
  FileHandle fileHandle=null;
  try {
    int lastSlashIndex=args[0].lastIndexOf('/');
    final ONCRPCServiceURL url=new ONCRPCServiceURL(args[0].substring(0,lastSlashIndex),Schemes.SCHEME_PBRPC,PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber());
    final String volumeName=args[0].substring(lastSlashIndex + 1);
    final Options options=new Options();
    final UserCredentials userCredentials=UserCredentials.newBuilder().setUsername(System.getProperty(""String_Node_Str"")).addGroups(""String_Node_Str"").build();
    final SSLOptions sslOptions=!url.getProtocol().equals(Schemes.SCHEME_PBRPC) ? SetupUtils.createClientSSLOptions() : null;
    Logging.start(Logging.LEVEL_WARN);
    client=ClientFactory.createClient(url.getHost() + ""String_Node_Str"" + url.getPort(),userCredentials,sslOptions,options);
    client.start();
    Volume volume=client.openVolume(volumeName,sslOptions,options);
    fileHandle=volume.openFile(userCredentials,""String_Node_Str"" + String.format(""String_Node_Str"",(int)(Math.random() * 1000)) + ""String_Node_Str"",SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_EXCL.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),0644);
    byte[] data=new byte[1 << 17];
    Arrays.fill(data,(byte)0xAB);
    for (int offset=0; offset < (1 << 20); offset+=data.length) {
      fileHandle.write(userCredentials,data,data.length,offset);
    }
    byte[] readData=new byte[data.length];
    for (int offset=0; offset < (1 << 20); offset+=data.length) {
      int readCount=fileHandle.read(userCredentials,readData,data.length,offset);
      if (readCount != data.length) {
        throw new IOException(""String_Node_Str"" + readCount + ""String_Node_Str""+ data.length);
      }
      if (!Arrays.equals(readData,data)) {
        throw new IOException(""String_Node_Str"" + offset);
      }
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ e.getStackTrace());
    return;
  }
 finally {
    if (fileHandle != null) {
      try {
        fileHandle.close();
      }
 catch (      IOException e) {
        System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ e.getStackTrace());
        return;
      }
    }
    if (client != null) {
      client.shutdown();
    }
    System.out.println(""String_Node_Str"");
  }
  return;
}","/** 
 * @param args args[0] = URL to existing volume e.g., pbrpcs://localhost/regular
 * @return
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.out.println(""String_Node_Str"");
    return;
  }
  Client client=null;
  FileHandle fileHandle=null;
  try {
    int lastSlashIndex=args[0].lastIndexOf('/');
    final ONCRPCServiceURL url=new ONCRPCServiceURL(args[0].substring(0,lastSlashIndex),Schemes.SCHEME_PBRPC,PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber());
    final String volumeName=args[0].substring(lastSlashIndex + 1);
    final Options options=new Options();
    final UserCredentials userCredentials=UserCredentials.newBuilder().setUsername(System.getProperty(""String_Node_Str"")).addGroups(""String_Node_Str"").build();
    final SSLOptions sslOptions=url.getProtocol().equals(Schemes.SCHEME_PBRPC) ? null : new SSLOptions(new FileInputStream(CERT_DIR + ""String_Node_Str""),""String_Node_Str"",SSLOptions.PKCS12_CONTAINER,new FileInputStream(CERT_DIR + ""String_Node_Str""),""String_Node_Str"",SSLOptions.JKS_CONTAINER,false,false,null);
    Logging.start(Logging.LEVEL_WARN);
    client=ClientFactory.createClient(url.getHost() + ""String_Node_Str"" + url.getPort(),userCredentials,sslOptions,options);
    client.start();
    Volume volume=client.openVolume(volumeName,sslOptions,options);
    fileHandle=volume.openFile(userCredentials,""String_Node_Str"" + String.format(""String_Node_Str"",(int)(Math.random() * 1000)) + ""String_Node_Str"",SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_EXCL.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),0644);
    byte[] data=new byte[1 << 17];
    Arrays.fill(data,(byte)0xAB);
    for (int offset=0; offset < (1 << 20); offset+=data.length) {
      fileHandle.write(userCredentials,data,data.length,offset);
    }
    byte[] readData=new byte[data.length];
    for (int offset=0; offset < (1 << 20); offset+=data.length) {
      int readCount=fileHandle.read(userCredentials,readData,data.length,offset);
      if (readCount != data.length) {
        throw new IOException(""String_Node_Str"" + readCount + ""String_Node_Str""+ data.length);
      }
      if (!Arrays.equals(readData,data)) {
        throw new IOException(""String_Node_Str"" + offset);
      }
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ e.getStackTrace());
    return;
  }
 finally {
    if (fileHandle != null) {
      try {
        fileHandle.close();
      }
 catch (      IOException e) {
        System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ e.getStackTrace());
        return;
      }
    }
    if (client != null) {
      client.shutdown();
    }
    System.out.println(""String_Node_Str"");
  }
  return;
}",0.9543035419343
113406,"protected void finalize(){
  if (!returned && reusable) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.toString(),getRefCount());
    if (allocStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",allocStack);
      if (this.viewParent != null)       Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",viewParent.allocStack);
    }
    if (freeStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",freeStack);
    }
 else     if (viewParent != null && viewParent.freeStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",viewParent.freeStack);
    }
    if (Logging.isDebug()) {
      byte[] data=new byte[(this.capacity() > 128) ? 128 : this.capacity()];
      this.position(0);
      this.limit(this.capacity());
      this.get(data);
      String content=new String(data);
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",content);
      if (this.viewParent != null) {
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.viewParent.toString());
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.viewParent.refCount.get());
      }
 else {
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.refCount.get());
      }
    }
    BufferPool.free(this);
  }
}","@Override protected void finalize(){
  if (!returned && reusable) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.toString(),getRefCount());
    if (allocStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",allocStack);
      if (this.viewParent != null)       Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",viewParent.allocStack);
    }
    if (freeStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",freeStack);
    }
 else     if (viewParent != null && viewParent.freeStack != null) {
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",viewParent.freeStack);
    }
    if (Logging.isDebug()) {
      byte[] data=new byte[(this.capacity() > 128) ? 128 : this.capacity()];
      this.position(0);
      this.limit(this.capacity());
      this.get(data);
      String content=new String(data);
      Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",content);
      if (this.viewParent != null) {
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.viewParent.toString());
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.viewParent.refCount.get());
      }
 else {
        Logging.logMessage(Logging.LEVEL_WARN,Category.buffer,this,""String_Node_Str"",this.refCount.get());
      }
    }
    BufferPool.free(this);
  }
}",0.996704021094265
113407,"public String toString(){
  return ""String_Node_Str"" + this.capacity() + ""String_Node_Str""+ this.limit()+ ""String_Node_Str""+ this.position()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + this.capacity() + ""String_Node_Str""+ this.limit()+ ""String_Node_Str""+ this.position()+ ""String_Node_Str"";
}",0.9700598802395208
113408,"public void testPUTandGET() throws Exception {
  final int numObjs=5;
  final int[] testSizes={1,2,SIZE - 1,SIZE};
  for (  int ts : testSizes) {
    ReusableBuffer data=SetupUtils.generateData(ts);
    data.flip();
    String file=""String_Node_Str"" + ts;
    final FileCredentials fcred=FileCredentials.newBuilder().setXcap(getCap(file).getXCap()).setXlocs(xloc).build();
    for (int i=0, osdIndex=0; i < numObjs; i++, osdIndex=i % osdIDs.size()) {
      ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
      RPCResponse<OSDWriteResponse> r=client.write(osdIDs.get(osdIndex).getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,file,i,0,0,0,objdata,data.createViewBuffer());
      OSDWriteResponse resp=r.get();
      r.freeBuffers();
      assertTrue(resp.hasSizeInBytes());
      assertEquals(i * SIZE + ts,resp.getSizeInBytes());
      RPCResponse<ObjectData> r2=client.read(osdIDs.get(osdIndex).getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,file,i,0,0,data.capacity());
      ObjectData result=r2.get();
      checkResponse(data.array(),result,r2.getData());
      r2.freeBuffers();
    }
  }
}","public void testPUTandGET() throws Exception {
  final int numObjs=5;
  final int[] testSizes={1,2,SIZE - 1,SIZE};
  for (  int ts : testSizes) {
    ReusableBuffer data=SetupUtils.generateData(ts);
    String file=""String_Node_Str"" + ts;
    final FileCredentials fcred=FileCredentials.newBuilder().setXcap(getCap(file).getXCap()).setXlocs(xloc).build();
    for (int i=0, osdIndex=0; i < numObjs; i++, osdIndex=i % osdIDs.size()) {
      ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
      RPCResponse<OSDWriteResponse> r=client.write(osdIDs.get(osdIndex).getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,file,i,0,0,0,objdata,data.createViewBuffer());
      OSDWriteResponse resp=r.get();
      r.freeBuffers();
      assertTrue(resp.hasSizeInBytes());
      assertEquals(i * SIZE + ts,resp.getSizeInBytes());
      RPCResponse<ObjectData> r2=client.read(osdIDs.get(osdIndex).getAddress(),RPCAuthentication.authNone,RPCAuthentication.userService,fcred,file,i,0,0,data.capacity());
      ObjectData result=r2.get();
      checkResponse(data.array(),result,r2.getData());
      r2.freeBuffers();
    }
  }
}",0.9929896907216494
113409,"protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (r.getData() != null) {
          if (buffer != null) {
            buffer.put(r.getData());
          }
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s(),ioe.getMessage());
            if (Logging.isDebug()) {
              Logging.logError(Logging.LEVEL_DEBUG,null,ioe);
            }
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}","protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (r.getData() != null) {
          if (buffer != null) {
            buffer.put(r.getData());
          }
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          waitDelay(options.getRetryDelay_s());
          continue;
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if ((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s(),ioe.getMessage());
            if (Logging.isDebug()) {
              Logging.logError(Logging.LEVEL_DEBUG,null,ioe);
            }
          }
          it.markUUIDAsFailed(it.getUUID());
          waitDelay(options.getRetryDelay_s());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}",0.9874455547015116
113410,"/** 
 * Sets the extended attribute ""name"" of ""path"" to ""value"".
 * @param userCredentials Name and Groups of the user.
 * @param path Path to the file/directory.
 * @param name Name of the extended attribute.
 * @param value Value of the extended attribute.
 * @param flags May be XATTR_CREATE or XATTR_REPLACE.
 * @throws AddressToUUIDNotFoundException
 * @throws {@link IOException}
 * @throws PosixErrorException
 * @throws UnknownAddressSchemeException
 */
public void setXAttr(UserCredentials userCredentials,String path,String name,String value,XATTR_FLAGS flags) throws IOException, PosixErrorException, AddressToUUIDNotFoundException ;","/** 
 * Sets the extended attribute ""name"" of ""path"" to ""value"".
 * @param userCredentials Name and Groups of the user.
 * @param auth Authentication data, e.g. of type AUTH_PASSWORD.
 * @param path Path to the file/directory.
 * @param name Name of the extended attribute.
 * @param value Value of the extended attribute.
 * @param flags May be XATTR_CREATE or XATTR_REPLACE.
 * @throws AddressToUUIDNotFoundException
 * @throws {@link IOException}
 * @throws PosixErrorException
 * @throws UnknownAddressSchemeException
 */
public void setXAttr(UserCredentials userCredentials,Auth auth,String path,String name,String value,XATTR_FLAGS flags) throws IOException, PosixErrorException, AddressToUUIDNotFoundException ;",0.945668135095448
113411,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final setxattrRequest rqArgs=(setxattrRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  final String attrKey=rqArgs.getName();
  final byte[] attrVal=rqArgs.hasValueBytesString() ? rqArgs.getValueBytesString().toByteArray() : rqArgs.hasValue() ? rqArgs.getValue().getBytes() : null;
  if (attrKey.startsWith(StorageManager.SYS_ATTR_KEY_PREFIX)) {
    if (master.getConfig().getAdminPassword().length() == 0)     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    MRCHelper.setSysAttrValue(sMan,vMan,faMan,res.getParentDirId(),file,attrKey.substring(StorageManager.SYS_ATTR_KEY_PREFIX.length()),new String(attrVal),update);
  }
 else {
    boolean exists=sMan.getXAttr(file.getId(),rq.getDetails().userId,attrKey) != null;
    if (exists && rqArgs.getFlags() == XATTR_FLAGS.XATTR_FLAGS_CREATE.getNumber())     throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"");
    if (!exists && rqArgs.getFlags() == XATTR_FLAGS.XATTR_FLAGS_REPLACE.getNumber())     throw new UserException(POSIXErrno.POSIX_ERROR_ENODATA,""String_Node_Str"");
    sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,attrVal.length == 0 ? null : attrVal,update);
  }
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,time,update);
  rq.setResponse(emptyResponse.getDefaultInstance());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final setxattrRequest rqArgs=(setxattrRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  final String attrKey=rqArgs.getName();
  final byte[] attrVal=rqArgs.hasValueBytesString() ? rqArgs.getValueBytesString().toByteArray() : rqArgs.hasValue() ? rqArgs.getValue().getBytes() : null;
  if (attrKey.startsWith(StorageManager.SYS_ATTR_KEY_PREFIX)) {
    boolean privileged=false;
    if (master.getConfig().getAdminPassword().length() > 0 && master.getConfig().getAdminPassword().equals(rq.getDetails().password)) {
      privileged=true;
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser || privileged,rq.getDetails().groupIds);
    MRCHelper.setSysAttrValue(sMan,vMan,faMan,res.getParentDirId(),file,attrKey.substring(StorageManager.SYS_ATTR_KEY_PREFIX.length()),new String(attrVal),update);
  }
 else {
    boolean exists=sMan.getXAttr(file.getId(),rq.getDetails().userId,attrKey) != null;
    if (exists && rqArgs.getFlags() == XATTR_FLAGS.XATTR_FLAGS_CREATE.getNumber())     throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"");
    if (!exists && rqArgs.getFlags() == XATTR_FLAGS.XATTR_FLAGS_REPLACE.getNumber())     throw new UserException(POSIXErrno.POSIX_ERROR_ENODATA,""String_Node_Str"");
    sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,attrVal.length == 0 ? null : attrVal,update);
  }
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,time,update);
  rq.setResponse(emptyResponse.getDefaultInstance());
  update.execute();
}",0.9628933771723814
113412,"@Test public void testROnlyReplicatedFileWithWrongChecksum() throws Exception {
  final String VOLUME_NAME=""String_Node_Str"";
  final String FILE_NAME=""String_Node_Str"";
  client.createVolume(mrc1Address.getHostName() + ""String_Node_Str"" + mrc1Address.getPort(),RPCAuthentication.authNone,userCredentials,VOLUME_NAME);
  AdminVolume volume=client.openVolume(VOLUME_NAME,null,new Options());
  volume.start();
  int replicationFlags=ReplicationFlags.setRarestFirstStrategy(0);
  replicationFlags=ReplicationFlags.setFullReplica(replicationFlags);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY,3,replicationFlags);
  AdminFileHandle file=volume.openFile(userCredentials,FILE_NAME,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),accessMode);
  int contentSize=file.getStripingPolicy().getStripeSize() * 1024;
  file.write(userCredentials,content,contentSize,0);
  file.close();
  file=volume.openFile(userCredentials,FILE_NAME,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDONLY.getNumber());
  Thread.sleep(5000);
  File objFile=openObjectFile(file,1,0);
  FileWriter fw=new FileWriter(objFile,false);
  fw.write(""String_Node_Str"");
  fw.close();
  xtfs_scrub scrubber=new xtfs_scrub(client,volume,3,true,true,true);
  scrubber.scrub();
  Thread.sleep(5000);
  objFile=openObjectFile(file,1,0);
  assertEquals(contentSize,objFile.length());
  client.deleteVolume(mrc1Address.getHostName() + ""String_Node_Str"" + mrc1Address.getPort(),RPCAuthentication.authNone,userCredentials,VOLUME_NAME);
}","@Test public void testROnlyReplicatedFileWithWrongChecksum() throws Exception {
  final String VOLUME_NAME=""String_Node_Str"";
  final String FILE_NAME=""String_Node_Str"";
  client.createVolume(mrc1Address.getHostName() + ""String_Node_Str"" + mrc1Address.getPort(),RPCAuthentication.authNone,userCredentials,VOLUME_NAME);
  AdminVolume volume=client.openVolume(VOLUME_NAME,null,new Options());
  volume.start();
  int replicationFlags=ReplicationFlags.setRarestFirstStrategy(0);
  replicationFlags=ReplicationFlags.setFullReplica(replicationFlags);
  volume.setDefaultReplicationPolicy(userCredentials,""String_Node_Str"",ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY,3,replicationFlags);
  AdminFileHandle file=volume.openFile(userCredentials,FILE_NAME,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),accessMode);
  int contentSize=file.getStripingPolicy().getStripeSize() * 1024;
  file.write(userCredentials,content,contentSize,0);
  file.close();
  file=volume.openFile(userCredentials,FILE_NAME,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDONLY.getNumber());
  Thread.sleep(5000);
  File objFile=openObjectFile(file,1,0);
  FileWriter fw=new FileWriter(objFile,false);
  fw.write(""String_Node_Str"");
  fw.close();
  xtfs_scrub scrubber=new xtfs_scrub(client,volume,3,true,true,true);
  scrubber.scrub();
  Thread.sleep(5000);
  objFile=openObjectFile(file,1,0);
  assertEquals(contentSize,objFile.length());
  file.close();
  client.deleteVolume(mrc1Address.getHostName() + ""String_Node_Str"" + mrc1Address.getPort(),RPCAuthentication.authNone,userCredentials,VOLUME_NAME);
}",0.9950341402855368
113413,"@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword().length() > 0)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  try {
    master.pauseHeartbeatThread();
  }
 catch (  InterruptedException ex) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
  }
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        master.resumeHeartbeatThread();
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}","@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword().length() != 0)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  try {
    master.pauseHeartbeatThread();
  }
 catch (  InterruptedException ex) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
  }
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        master.resumeHeartbeatThread();
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}",0.999194198227236
113414,"@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword().length() != 0)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  try {
    master.pauseHeartbeatThread();
  }
 catch (  InterruptedException ex) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
  }
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        master.resumeHeartbeatThread();
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}","@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword().length() == 0)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  try {
    master.pauseHeartbeatThread();
  }
 catch (  InterruptedException ex) {
    finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
  }
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        master.resumeHeartbeatThread();
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}",0.9994629430719656
113415,"@Override public int read(UserCredentials userCredentials,byte[] data,int dataOffset,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  fileInfo.waitForPendingAsyncWrites();
  FileCredentials.Builder fcBuilder=FileCredentials.newBuilder();
synchronized (this) {
    if (asyncWritesFailed) {
      throw new PosixErrorException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + ""String_Node_Str"");
    }
    fcBuilder.setXcap(xcap.toBuilder());
  }
  FileCredentials fc=fcBuilder.setXlocs(fileInfo.getXLocSet()).build();
  ReusableBuffer buf=ReusableBuffer.wrap(data,dataOffset,count);
  int receivedData=0;
  if (fc.getXlocs().getReplicasCount() == 0) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",fileInfo.getPath());
    throw new PosixErrorException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + fileInfo.getPath());
  }
  StripingPolicy policy=fc.getXlocs().getReplicas(0).getStripingPolicy();
  StripeTranslator translator=getStripeTranslator(policy.getType());
  Vector<ReadOperation> operations=new Vector<ReadOperation>();
  translator.translateReadRequest(count,offset,policy,operations);
  UUIDIterator tempUuidIteratorForStriping=new UUIDIterator();
  String osdUuid=""String_Node_Str"";
  for (int j=0; j < operations.size(); j++) {
    readRequest.Builder readRqBuilder=readRequest.newBuilder();
    readRqBuilder.setFileCredentials(fc);
    readRqBuilder.setFileId(fc.getXcap().getFileId());
    readRqBuilder.setObjectNumber(operations.get(j).getObjNumber());
    readRqBuilder.setObjectVersion(0);
    readRqBuilder.setOffset(operations.get(j).getReqOffset());
    readRqBuilder.setLength(operations.get(j).getReqSize());
    UUIDIterator uuidIterator;
    if (readRqBuilder.getFileCredentials().getXlocs().getReplicas(0).getOsdUuidsCount() > 1) {
      osdUuid=Helper.getOSDUUIDFromXlocSet(fc.getXlocs(),0,operations.get(j).getOsdOffset());
      tempUuidIteratorForStriping.clearAndAddUUID(osdUuid);
      uuidIterator=tempUuidIteratorForStriping;
    }
 else {
      uuidIterator=osdUuidIterator;
    }
    buf.position(operations.get(j).getBufferStart());
    ObjectData objectData=RPCCaller.<readRequest,ObjectData>syncCall(SERVICES.OSD,userCredentialsBogus,authBogus,volumeOptions,uuidResolver,uuidIterator,false,readRqBuilder.build(),buf,new CallGenerator<readRequest,ObjectData>(){
      @Override public RPCResponse<ObjectData> executeCall(      InetSocketAddress server,      Auth auth,      UserCredentials userCreds,      readRequest callRequest) throws IOException {
        return osdServiceClient.read(server,auth,userCreds,callRequest);
      }
    }
);
    for (int i=0; i < objectData.getZeroPadding(); i++) {
      buf.put((byte)0);
    }
    receivedData+=buf.position() - operations.get(j).getBufferStart();
  }
  return receivedData;
}","@Override public int read(UserCredentials userCredentials,byte[] data,int dataOffset,int count,long offset) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  fileInfo.waitForPendingAsyncWrites();
  FileCredentials.Builder fcBuilder=FileCredentials.newBuilder();
synchronized (this) {
    if (asyncWritesFailed) {
      throw new PosixErrorException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + ""String_Node_Str"");
    }
    fcBuilder.setXcap(xcap.toBuilder());
  }
  FileCredentials fc=fcBuilder.setXlocs(fileInfo.getXLocSet()).build();
  ReusableBuffer buf=ReusableBuffer.wrap(data,dataOffset,count);
  int receivedData=0;
  if (fc.getXlocs().getReplicasCount() == 0) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",fileInfo.getPath());
    throw new PosixErrorException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + fileInfo.getPath());
  }
  StripingPolicy policy=fc.getXlocs().getReplicas(0).getStripingPolicy();
  StripeTranslator translator=getStripeTranslator(policy.getType());
  Vector<ReadOperation> operations=new Vector<ReadOperation>();
  translator.translateReadRequest(count,offset,policy,operations);
  UUIDIterator tempUuidIteratorForStriping=new UUIDIterator();
  for (int j=0; j < operations.size(); j++) {
    readRequest.Builder readRqBuilder=readRequest.newBuilder();
    readRqBuilder.setFileCredentials(fc);
    readRqBuilder.setFileId(fc.getXcap().getFileId());
    readRqBuilder.setObjectNumber(operations.get(j).getObjNumber());
    readRqBuilder.setObjectVersion(0);
    readRqBuilder.setOffset(operations.get(j).getReqOffset());
    readRqBuilder.setLength(operations.get(j).getReqSize());
    UUIDIterator uuidIterator;
    if (readRqBuilder.getFileCredentials().getXlocs().getReplicas(0).getOsdUuidsCount() > 1) {
      tempUuidIteratorForStriping.clear();
      int stripeWidthFirstReplica=fc.getXlocs().getReplicas(0).getStripingPolicy().getWidth();
      for (int replicaIdx=0; replicaIdx < fc.getXlocs().getReplicasCount(); replicaIdx++) {
        if (fc.getXlocs().getReplicas(replicaIdx).getStripingPolicy().getWidth() == stripeWidthFirstReplica) {
          tempUuidIteratorForStriping.addUUID(Helper.getOSDUUIDFromXlocSet(fc.getXlocs(),replicaIdx,operations.get(j).getOsdOffset()));
        }
      }
      uuidIterator=tempUuidIteratorForStriping;
    }
 else {
      uuidIterator=osdUuidIterator;
    }
    buf.position(operations.get(j).getBufferStart());
    ObjectData objectData=RPCCaller.<readRequest,ObjectData>syncCall(SERVICES.OSD,userCredentialsBogus,authBogus,volumeOptions,uuidResolver,uuidIterator,false,readRqBuilder.build(),buf,new CallGenerator<readRequest,ObjectData>(){
      @Override public RPCResponse<ObjectData> executeCall(      InetSocketAddress server,      Auth auth,      UserCredentials userCreds,      readRequest callRequest) throws IOException {
        return osdServiceClient.read(server,auth,userCreds,callRequest);
      }
    }
);
    for (int i=0; i < objectData.getZeroPadding(); i++) {
      buf.put((byte)0);
    }
    receivedData+=buf.position() - operations.get(j).getBufferStart();
  }
  return receivedData;
}",0.915654633172517
113416,"protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (r.getData() != null) {
          if (buffer != null) {
            buffer.put(r.getData());
          }
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s(),ioe.getMessage());
            if (Logging.isDebug()) {
              Logging.logError(Logging.LEVEL_DEBUG,null,ioe);
            }
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}","protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (r.getData() != null) {
          if (buffer != null) {
            buffer.put(r.getData());
          }
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s(),ioe.getMessage());
            if (Logging.isDebug()) {
              Logging.logError(Logging.LEVEL_DEBUG,null,ioe);
            }
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}",0.9973998959958398
113417,"private void processMaxObjAvail(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final Long maxObjVersion=(Long)method.getArgs()[1];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[2];
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ maxObjVersion,localID);
    ReplicatedFileState state=files.get(fileId);
    if (state == null) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
    assert(state.getState() == ReplicaState.INITIALIZING);
    state.getPolicy().setLocalObjectVersion(maxObjVersion);
    doOpen(state);
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","private void processMaxObjAvail(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final Long maxObjVersion=(Long)method.getArgs()[1];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[2];
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ maxObjVersion,localID);
    ReplicatedFileState state=files.get(fileId);
    if (state == null) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileId);
      return;
    }
    if (state.getState() == ReplicaState.INITIALIZING) {
      state.getPolicy().setLocalObjectVersion(maxObjVersion);
      doOpen(state);
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"");
      return;
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9146410401356698
113418,"public static void setSysAttrValue(StorageManager sMan,VolumeManager vMan,FileAccessManager faMan,long parentId,FileMetadata file,String keyString,String value,AtomicDBUpdate update) throws UserException, DatabaseException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str"")) {
    setPolicyValue(sMan,keyString,value,update);
    return;
  }
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
switch (key) {
case default_sp:
    if (!file.isDirectory())     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  try {
    org.xtreemfs.pbrpc.generatedinterfaces.GlobalTypes.StripingPolicy sp=null;
    sp=Converter.jsonStringToStripingPolicy(value);
    if (file.getId() == 1 && sp == null)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    sMan.setDefaultStripingPolicy(file.getId(),sp,update);
  }
 catch (  JSONException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  ClassCastException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  NullPointerException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
break;
case osel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setOsdPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case rsel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setReplicaPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case read_only:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
boolean readOnly=Boolean.valueOf(value);
if (!readOnly && file.getXLocList() != null && file.getXLocList().getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
if (file.getXLocList() != null) {
XLocList xLoc=file.getXLocList();
XLoc[] replicas=new XLoc[xLoc.getReplicaCount()];
for (int i=0; i < replicas.length; i++) replicas[i]=xLoc.getReplica(i);
replicas[0].setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(replicas[0].getReplicationFlags())));
XLocList newXLoc=sMan.createXLocList(replicas,readOnly ? ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,xLoc.getVersion() + 1);
file.setXLocList(newXLoc);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
}
file.setReadOnly(readOnly);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case snapshots:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"");
int index=value.indexOf(""String_Node_Str"");
String command=null;
String name=null;
try {
command=value.substring(0,index);
name=value.substring(index + 1);
}
 catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
if (command.charAt(0) == 'c') vMan.createSnapshot(sMan.getVolumeInfo().getId(),name,parentId,file,command.equals(""String_Node_Str""));
 else if (command.equals(""String_Node_Str"")) vMan.deleteSnapshot(sMan.getVolumeInfo().getId(),file,name);
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
break;
case snapshots_enabled:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
boolean enable=Boolean.parseBoolean(value);
sMan.getVolumeInfo().setAllowSnaps(enable,update);
break;
case mark_replica_complete:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
XLocList xlocs=file.getXLocList();
XLoc[] xlocArray=new XLoc[xlocs.getReplicaCount()];
Iterator<XLoc> it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) {
XLoc xloc=it.next();
if (value.equals(xloc.getOSD(0))) xloc.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(xloc.getReplicationFlags()));
xlocArray[i]=xloc;
}
XLocList newXLocList=sMan.createXLocList(xlocArray,xlocs.getReplUpdatePolicy(),xlocs.getVersion());
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case acl:
index=value.indexOf(""String_Node_Str"");
try {
command=value.substring(0,index);
String params=value.substring(index + 1);
if (command.equals(""String_Node_Str"")) {
int index2=params.lastIndexOf(':');
String entity=params.substring(0,index2);
String rights=params.substring(index2 + 1);
Map<String,Object> entries=new HashMap<String,Object>();
entries.put(entity,rights);
faMan.updateACLEntries(sMan,file,parentId,entries,update);
}
 else if (command.equals(""String_Node_Str"")) {
List<Object> entries=new ArrayList<Object>(1);
entries.add(params);
faMan.removeACLEntries(sMan,file,parentId,entries,update);
}
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + command);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
break;
case set_repl_update_policy:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
xlocs=file.getXLocList();
xlocArray=new XLoc[xlocs.getReplicaCount()];
it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) xlocArray[i]=it.next();
String replUpdatePolicy=xlocs.getReplUpdatePolicy();
if (!ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)&& !ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_WARA.equals(value)) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && xlocArray.length > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
if (xlocs.getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE + ""String_Node_Str""+ xlocs.getReplicaCount()+ ""String_Node_Str"");
}
if ((ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && (ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(value) || ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value))) || (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value) && (ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(replUpdatePolicy) || ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(replUpdatePolicy)))) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
newXLocList=sMan.createXLocList(xlocArray,value,xlocs.getVersion() + 1);
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) {
newXLocList.getReplica(0).setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(newXLocList.getReplica(0).getReplicationFlags())));
file.setReadOnly(true);
}
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
file.setReadOnly(false);
}
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case default_rp:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
try {
ReplicationPolicy rp=null;
rp=Converter.jsonStringToReplicationPolicy(value);
if (rp.getFactor() == 1 && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
}
sMan.setDefaultReplicationPolicy(file.getId(),rp,update);
}
 catch (JSONException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (ClassCastException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (NullPointerException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (IllegalArgumentException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
default :
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
}
}","public static void setSysAttrValue(StorageManager sMan,VolumeManager vMan,FileAccessManager faMan,long parentId,FileMetadata file,String keyString,String value,AtomicDBUpdate update) throws UserException, DatabaseException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str"")) {
    setPolicyValue(sMan,keyString,value,update);
    return;
  }
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
switch (key) {
case default_sp:
    if (!file.isDirectory())     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  try {
    org.xtreemfs.pbrpc.generatedinterfaces.GlobalTypes.StripingPolicy sp=null;
    sp=Converter.jsonStringToStripingPolicy(value);
    if (file.getId() == 1 && sp == null)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    sMan.setDefaultStripingPolicy(file.getId(),sp,update);
  }
 catch (  JSONException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  ClassCastException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  NullPointerException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
break;
case osel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setOsdPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case rsel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setReplicaPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case read_only:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
boolean readOnly=Boolean.valueOf(value);
if (!readOnly && file.getXLocList() != null && file.getXLocList().getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
if (file.getXLocList() != null) {
XLocList xLoc=file.getXLocList();
XLoc[] replicas=new XLoc[xLoc.getReplicaCount()];
for (int i=0; i < replicas.length; i++) replicas[i]=xLoc.getReplica(i);
replicas[0].setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(replicas[0].getReplicationFlags())));
XLocList newXLoc=sMan.createXLocList(replicas,readOnly ? ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,xLoc.getVersion() + 1);
file.setXLocList(newXLoc);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
}
file.setReadOnly(readOnly);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case snapshots:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"");
int index=value.indexOf(""String_Node_Str"");
String command=null;
String name=null;
try {
command=value.substring(0,index);
name=value.substring(index + 1);
}
 catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
if (command.charAt(0) == 'c') vMan.createSnapshot(sMan.getVolumeInfo().getId(),name,parentId,file,command.equals(""String_Node_Str""));
 else if (command.equals(""String_Node_Str"")) vMan.deleteSnapshot(sMan.getVolumeInfo().getId(),file,name);
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
break;
case snapshots_enabled:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
boolean enable=Boolean.parseBoolean(value);
sMan.getVolumeInfo().setAllowSnaps(enable,update);
break;
case mark_replica_complete:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
XLocList xlocs=file.getXLocList();
XLoc[] xlocArray=new XLoc[xlocs.getReplicaCount()];
Iterator<XLoc> it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) {
XLoc xloc=it.next();
if (value.equals(xloc.getOSD(0))) xloc.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(xloc.getReplicationFlags()));
xlocArray[i]=xloc;
}
XLocList newXLocList=sMan.createXLocList(xlocArray,xlocs.getReplUpdatePolicy(),xlocs.getVersion());
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case acl:
index=value.indexOf(""String_Node_Str"");
try {
command=value.substring(0,index);
String params=value.substring(index + 1);
if (command.equals(""String_Node_Str"")) {
int index2=params.lastIndexOf(':');
String entity=params.substring(0,index2);
String rights=params.substring(index2 + 1);
Map<String,Object> entries=new HashMap<String,Object>();
entries.put(entity,rights);
faMan.updateACLEntries(sMan,file,parentId,entries,update);
}
 else if (command.equals(""String_Node_Str"")) {
List<Object> entries=new ArrayList<Object>(1);
entries.add(params);
faMan.removeACLEntries(sMan,file,parentId,entries,update);
}
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + command);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
break;
case set_repl_update_policy:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
xlocs=file.getXLocList();
xlocArray=new XLoc[xlocs.getReplicaCount()];
it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) xlocArray[i]=it.next();
String replUpdatePolicy=xlocs.getReplUpdatePolicy();
if (!ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)&& !ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_WARA.equals(value)) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && xlocArray.length > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
if (xlocs.getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE + ""String_Node_Str""+ xlocs.getReplicaCount()+ ""String_Node_Str"");
}
if ((ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && (ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(value) || ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value))) || (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value) && (ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ.equals(replUpdatePolicy) || ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(replUpdatePolicy)))) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
newXLocList=sMan.createXLocList(xlocArray,value,xlocs.getVersion() + 1);
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) {
newXLocList.getReplica(0).setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(newXLocList.getReplica(0).getReplicationFlags())));
file.setReadOnly(true);
}
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy) && ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
file.setReadOnly(false);
}
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case default_rp:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
try {
ReplicationPolicy rp=null;
rp=Converter.jsonStringToReplicationPolicy(value);
if (rp.getFactor() == 1 && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(rp.getName())) {
throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
}
sMan.setDefaultReplicationPolicy(file.getId(),rp,update);
}
 catch (JSONException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (ClassCastException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (NullPointerException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (IllegalArgumentException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
default :
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
}
}",0.9990694619300454
113419,"public static XLoc createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress,VivaldiCoordinates clientCoordinates,XLocList currentXLoc,int replFlags) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  ServiceSet.Builder usableOSDs=osdMan.getUsableOSDs(volume.getId(),clientAddress,clientCoordinates,currentXLoc,stripingPolicy.getWidth());
  if (usableOSDs == null || usableOSDs.getServicesCount() == 0) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.all,(Object)null,""String_Node_Str"",path);
    throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  }
  int width=Math.min((int)stripingPolicy.getWidth(),usableOSDs.getServicesCount());
  List<Service> osdServices=usableOSDs.getServicesList();
  String[] osds=new String[width];
  for (int i=0; i < width; i++)   osds[i]=osdServices.get(i).getUuid();
  if (width != stripingPolicy.getWidth())   stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  return sMan.createXLoc(stripingPolicy,osds,replFlags);
}","public static XLoc createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress,VivaldiCoordinates clientCoordinates,XLocList currentXLoc,int replFlags) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  ServiceSet.Builder usableOSDs=osdMan.getUsableOSDs(volume.getId(),clientAddress,clientCoordinates,currentXLoc,stripingPolicy.getWidth());
  if (usableOSDs == null || usableOSDs.getServicesCount() == 0) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.all,(Object)null,""String_Node_Str"",path);
    throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  }
  int width=Math.min(stripingPolicy.getWidth(),usableOSDs.getServicesCount());
  List<Service> osdServices=usableOSDs.getServicesList();
  String[] osds=new String[width];
  for (int i=0; i < width; i++)   osds[i]=osdServices.get(i).getUuid();
  if (width != stripingPolicy.getWidth())   stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  return sMan.createXLoc(stripingPolicy,osds,replFlags);
}",0.99830220713073
113420,"@Override long performIO(byte[] data,long numberOfBlocks) throws IOException {
  numberOfBlocks=convertTo4KiBBlocks(numberOfBlocks);
  long byteCounter=0;
  int flags=GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber();
  for (long j=0; j < numberOfBlocks; j++) {
    FileHandle fileHandle=volume.openFile(params.userCredentials,BASFILE_FILENAME,flags,511);
    long nextOffset=generateNextRandomOffset();
    byteCounter+=fileHandle.write(params.userCredentials,data,RANDOM_IO_BLOCKSIZE,nextOffset);
    fileHandle.close();
  }
  return byteCounter;
}","@Override long performIO(byte[] data,long numberOfBlocks) throws IOException {
  numberOfBlocks=convertTo4KiBBlocks(numberOfBlocks);
  long byteCounter=0;
  int flags=GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | GlobalTypes.SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber();
  for (long j=0; j < numberOfBlocks - 1; j++) {
    FileHandle fileHandle=volume.openFile(params.userCredentials,BASFILE_FILENAME,flags,511);
    long nextOffset=generateNextRandomOffset();
    byteCounter+=fileHandle.write(params.userCredentials,data,RANDOM_IO_BLOCKSIZE,nextOffset);
    fileHandle.close();
  }
  FileHandle fileHandle=volume.openFile(params.userCredentials,BASFILE_FILENAME,flags,511);
  byteCounter+=fileHandle.write(params.userCredentials,data,RANDOM_IO_BLOCKSIZE,params.basefileSizeInBytes - RANDOM_IO_BLOCKSIZE);
  fileHandle.close();
  return byteCounter;
}",0.8407565588773642
113421,"@Override public DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  DirectoryEntries result=null;
  if (count == 0) {
    count=Integer.MAX_VALUE - offset - 1;
  }
  result=metadataCache.getDirEntries(path,offset,count);
  if (result != null) {
    return result;
  }
  DirectoryEntries.Builder dirEntriesBuilder=DirectoryEntries.newBuilder();
  for (int currentOffset=offset; currentOffset < offset + count; currentOffset+=volumeOptions.getReaddirChunkSize()) {
    int limitDirEntriesCount=(currentOffset > offset + count) ? (currentOffset - offset - count) : volumeOptions.getReaddirChunkSize();
    readdirRequest request=readdirRequest.newBuilder().setPath(path).setVolumeName(volumeName).setNamesOnly(namesOnly).setKnownEtag(0).setSeenDirectoryEntriesCount(currentOffset).setLimitDirectoryEntriesCount(limitDirEntriesCount).build();
    result=RPCCaller.<readdirRequest,DirectoryEntries>syncCall(SERVICES.MRC,userCredentials,authBogus,volumeOptions,uuidResolver,mrcUUIDIterator,false,request,new CallGenerator<readdirRequest,DirectoryEntries>(){
      @Override public RPCResponse<DirectoryEntries> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      readdirRequest input) throws IOException {
        return mrcServiceClient.readdir(server,authHeader,userCreds,input);
      }
    }
);
    assert(result != null);
    dirEntriesBuilder.addAllEntries(result.getEntriesList());
    if (dirEntriesBuilder.getEntriesCount() < (currentOffset + volumeOptions.getReaddirChunkSize())) {
      break;
    }
  }
  int minimum=(volumeOptions.getMetadataCacheSize() > dirEntriesBuilder.getEntriesCount()) ? dirEntriesBuilder.getEntriesCount() : volumeOptions.getMetadataCacheSize();
  for (int i=0; i < minimum; i++) {
    if (dirEntriesBuilder.getEntries(i).hasStbuf()) {
      if (dirEntriesBuilder.getEntries(i).getStbuf().getNlink() > 1) {
        metadataCache.invalidate(path);
      }
 else {
        metadataCache.updateStat(Helper.concatenatePath(path,dirEntriesBuilder.getEntries(i).getName()),dirEntriesBuilder.getEntries(i).getStbuf());
      }
    }
  }
  if (!namesOnly && offset == 0 && dirEntriesBuilder.getEntriesCount() < count) {
    metadataCache.updateDirEntries(path,result);
  }
  return dirEntriesBuilder.build();
}","@Override public DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  DirectoryEntries result=null;
  if (count == 0) {
    count=Integer.MAX_VALUE - offset - 1;
  }
  result=metadataCache.getDirEntries(path,offset,count);
  if (result != null) {
    return result;
  }
  DirectoryEntries.Builder dirEntriesBuilder=DirectoryEntries.newBuilder();
  for (int currentOffset=offset; currentOffset < offset + count; currentOffset+=volumeOptions.getReaddirChunkSize()) {
    int limitDirEntriesCount=(currentOffset > offset + count) ? (currentOffset - offset - count) : volumeOptions.getReaddirChunkSize();
    readdirRequest request=readdirRequest.newBuilder().setPath(path).setVolumeName(volumeName).setNamesOnly(namesOnly).setKnownEtag(0).setSeenDirectoryEntriesCount(currentOffset).setLimitDirectoryEntriesCount(limitDirEntriesCount).build();
    DirectoryEntries readDirResponse=RPCCaller.<readdirRequest,DirectoryEntries>syncCall(SERVICES.MRC,userCredentials,authBogus,volumeOptions,uuidResolver,mrcUUIDIterator,false,request,new CallGenerator<readdirRequest,DirectoryEntries>(){
      @Override public RPCResponse<DirectoryEntries> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      readdirRequest input) throws IOException {
        return mrcServiceClient.readdir(server,authHeader,userCreds,input);
      }
    }
);
    assert(readDirResponse != null);
    dirEntriesBuilder.addAllEntries(readDirResponse.getEntriesList());
    if (dirEntriesBuilder.getEntriesCount() < (currentOffset + volumeOptions.getReaddirChunkSize())) {
      break;
    }
  }
  int minimum=(volumeOptions.getMetadataCacheSize() > dirEntriesBuilder.getEntriesCount()) ? dirEntriesBuilder.getEntriesCount() : volumeOptions.getMetadataCacheSize();
  for (int i=0; i < minimum; i++) {
    if (dirEntriesBuilder.getEntries(i).hasStbuf()) {
      if (dirEntriesBuilder.getEntries(i).getStbuf().getNlink() > 1) {
        metadataCache.invalidate(path);
      }
 else {
        metadataCache.updateStat(Helper.concatenatePath(path,dirEntriesBuilder.getEntries(i).getName()),dirEntriesBuilder.getEntries(i).getStbuf());
      }
    }
  }
  result=dirEntriesBuilder.build();
  if (!namesOnly && offset == 0 && result.getEntriesCount() < count) {
    metadataCache.updateDirEntries(path,result);
  }
  return result;
}",0.9668576104746316
113422,"public long getFileInfoLoadCount(){
  return _stat_fileInfoLoads;
}","@Override public long getFileInfoLoadCount(){
  return _stat_fileInfoLoads;
}",0.9305555555555556
113423,"public void setTruncateLog(String fileId,TruncateLog log) throws IOException {
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (!fileDir.exists()) {
    fileDir.mkdirs();
  }
  File tlog=new File(fileDir,TRUNCATE_LOG_FILENAME);
  FileOutputStream output=null;
  try {
    output=new FileOutputStream(tlog);
    log.writeDelimitedTo(output);
  }
  finally {
    if (output != null) {
      output.close();
    }
  }
}","@Override public void setTruncateLog(String fileId,TruncateLog log) throws IOException {
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (!fileDir.exists()) {
    fileDir.mkdirs();
  }
  File tlog=new File(fileDir,TRUNCATE_LOG_FILENAME);
  FileOutputStream output=null;
  try {
    output=new FileOutputStream(tlog);
    log.writeDelimitedTo(output);
  }
  finally {
    if (output != null) {
      output.close();
    }
  }
}",0.988558352402746
113424,"public void setMasterEpoch(String fileId,int masterEpoch) throws IOException {
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (!fileDir.exists()) {
    fileDir.mkdirs();
  }
  File mepoch=new File(fileDir,MASTER_EPOCH_FILENAME);
  RandomAccessFile rf=new RandomAccessFile(mepoch,""String_Node_Str"");
  rf.writeInt(masterEpoch);
  rf.close();
}","@Override public void setMasterEpoch(String fileId,int masterEpoch) throws IOException {
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (!fileDir.exists()) {
    fileDir.mkdirs();
  }
  File mepoch=new File(fileDir,MASTER_EPOCH_FILENAME);
  RandomAccessFile rf=new RandomAccessFile(mepoch,""String_Node_Str"");
  rf.writeInt(masterEpoch);
  rf.close();
}",0.9862637362637364
113425,"@Override public void deleteObject(String fileId,FileMetadata md,final long objNo,long version) throws IOException {
  final long verToDel=(version == LATEST_VERSION) ? md.getLatestObjectVersion(objNo) : version;
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  File[] objs=fileDir.listFiles(new FileFilter(){
    public boolean accept(    File pathname){
      if (pathname.getName().startsWith(""String_Node_Str"")) {
        return false;
      }
      ObjFileData ofd=parseFileName(pathname.getName());
      return (ofd.objNo == objNo) && (ofd.objVersion == verToDel);
    }
  }
);
  for (  File obj : objs) {
    obj.delete();
  }
}","@Override public void deleteObject(String fileId,FileMetadata md,final long objNo,long version) throws IOException {
  final long verToDel=(version == LATEST_VERSION) ? md.getLatestObjectVersion(objNo) : version;
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  File[] objs=fileDir.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      if (pathname.getName().startsWith(""String_Node_Str"")) {
        return false;
      }
      ObjFileData ofd=parseFileName(pathname.getName());
      return (ofd.objNo == objNo) && (ofd.objVersion == verToDel);
    }
  }
);
  for (  File obj : objs) {
    obj.delete();
  }
}",0.9923430321592648
113426,"protected FileMetadata loadFileMetadata(String fileId,StripingPolicyImpl sp) throws IOException {
  _stat_fileInfoLoads=0;
  FileMetadata info=new FileMetadata(sp);
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (fileDir.exists()) {
    Map<Long,Long> largestObjVersions=new HashMap<Long,Long>();
    Map<Long,Map<Long,Long>> objChecksums=new HashMap<Long,Map<Long,Long>>();
    Map<Long,Long> latestObjVersions=null;
    long lastObjNum=-1;
    String lastObject=null;
    File currVerFile=new File(fileDir,CURRENT_VER_FILENAME);
    boolean multiVersionSupport=currVerFile.exists();
    if (multiVersionSupport) {
      latestObjVersions=new HashMap<Long,Long>();
      RandomAccessFile rf=new RandomAccessFile(currVerFile,""String_Node_Str"");
      for (long l=0; ; l++) {
        try {
          long objVer=rf.readLong();
          if (objVer != 0)           latestObjVersions.put(l,objVer);
        }
 catch (        EOFException exc) {
          lastObjNum=l - 1;
          break;
        }
      }
      rf.close();
    }
    String[] objs=fileDir.list();
    for (    String obj : objs) {
      if (obj.startsWith(""String_Node_Str"")) {
        continue;
      }
      ObjFileData ofd=parseFileName(obj);
      if (ofd.checksum != 0) {
        Map<Long,Long> checksums=objChecksums.get(ofd.objNo);
        if (checksums == null) {
          checksums=new HashMap<Long,Long>();
          objChecksums.put(ofd.objNo,checksums);
        }
        checksums.put(ofd.objVersion,ofd.checksum);
      }
      if (multiVersionSupport) {
        Long latestObjVer=latestObjVersions.get(ofd.objNo);
        if (ofd.objNo == lastObjNum && latestObjVer != null && ofd.objVersion == latestObjVer)         lastObject=obj;
      }
 else {
        if (ofd.objNo > lastObjNum) {
          lastObject=obj;
          lastObjNum=ofd.objNo;
        }
      }
      Long oldver=largestObjVersions.get(ofd.objNo);
      if ((oldver == null) || (oldver < ofd.objVersion))       largestObjVersions.put((long)ofd.objNo,ofd.objVersion);
    }
    if (multiVersionSupport) {
      info.initLatestObjectVersions(latestObjVersions);
      info.initLargestObjectVersions(largestObjVersions);
    }
 else {
      info.initLatestObjectVersions(largestObjVersions);
      info.initLargestObjectVersions(largestObjVersions);
    }
    info.initObjectChecksums(objChecksums);
    if (lastObjNum > -1) {
      File lastObjFile=new File(fileDir.getAbsolutePath() + ""String_Node_Str"" + lastObject);
      long lastObjSize=lastObjFile.length();
      if (lastObjSize == 0) {
        lastObjSize=sp.getStripeSizeForObject(lastObjSize);
      }
      long fsize=lastObjSize;
      if (lastObjNum > 0) {
        fsize+=sp.getObjectEndOffset(lastObjNum - 1) + 1;
      }
      assert(fsize >= 0);
      info.setFilesize(fsize);
      info.setLastObjectNumber(lastObjNum);
    }
 else {
      info.setFilesize(0l);
      info.setLastObjectNumber(-1);
    }
    File tepoch=new File(fileDir,TEPOCH_FILENAME);
    if (tepoch.exists()) {
      RandomAccessFile raf=null;
      try {
        raf=new RandomAccessFile(tepoch,""String_Node_Str"");
        info.setTruncateEpoch(raf.readLong());
      }
  finally {
        if (raf != null) {
          raf.close();
        }
      }
    }
    File vtFile=new File(fileDir,VTABLE_FILENAME);
    VersionTable vt=new VersionTable(vtFile);
    if (vtFile.exists())     vt.load();
    info.initVersionTable(vt);
  }
 else {
    info.setFilesize(0);
    info.setLastObjectNumber(-1);
    info.initLatestObjectVersions(new HashMap<Long,Long>());
    info.initLargestObjectVersions(new HashMap<Long,Long>());
    info.initObjectChecksums(new HashMap<Long,Map<Long,Long>>());
    info.initVersionTable(new VersionTable(new File(fileDir,VTABLE_FILENAME)));
  }
  info.setGlobalLastObjectNumber(-1);
  return info;
}","@Override protected FileMetadata loadFileMetadata(String fileId,StripingPolicyImpl sp) throws IOException {
  _stat_fileInfoLoads=0;
  FileMetadata info=new FileMetadata(sp);
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  if (fileDir.exists()) {
    Map<Long,Long> largestObjVersions=new HashMap<Long,Long>();
    Map<Long,Map<Long,Long>> objChecksums=new HashMap<Long,Map<Long,Long>>();
    Map<Long,Long> latestObjVersions=null;
    long lastObjNum=-1;
    String lastObject=null;
    File currVerFile=new File(fileDir,CURRENT_VER_FILENAME);
    boolean multiVersionSupport=currVerFile.exists();
    if (multiVersionSupport) {
      latestObjVersions=new HashMap<Long,Long>();
      RandomAccessFile rf=new RandomAccessFile(currVerFile,""String_Node_Str"");
      for (long l=0; ; l++) {
        try {
          long objVer=rf.readLong();
          if (objVer != 0)           latestObjVersions.put(l,objVer);
        }
 catch (        EOFException exc) {
          lastObjNum=l - 1;
          break;
        }
      }
      rf.close();
    }
    String[] objs=fileDir.list();
    for (    String obj : objs) {
      if (obj.startsWith(""String_Node_Str"")) {
        continue;
      }
      ObjFileData ofd=parseFileName(obj);
      if (ofd.checksum != 0) {
        Map<Long,Long> checksums=objChecksums.get(ofd.objNo);
        if (checksums == null) {
          checksums=new HashMap<Long,Long>();
          objChecksums.put(ofd.objNo,checksums);
        }
        checksums.put(ofd.objVersion,ofd.checksum);
      }
      if (multiVersionSupport) {
        Long latestObjVer=latestObjVersions.get(ofd.objNo);
        if (ofd.objNo == lastObjNum && latestObjVer != null && ofd.objVersion == latestObjVer)         lastObject=obj;
      }
 else {
        if (ofd.objNo > lastObjNum) {
          lastObject=obj;
          lastObjNum=ofd.objNo;
        }
      }
      Long oldver=largestObjVersions.get(ofd.objNo);
      if ((oldver == null) || (oldver < ofd.objVersion))       largestObjVersions.put(ofd.objNo,ofd.objVersion);
    }
    if (multiVersionSupport) {
      info.initLatestObjectVersions(latestObjVersions);
      info.initLargestObjectVersions(largestObjVersions);
    }
 else {
      info.initLatestObjectVersions(largestObjVersions);
      info.initLargestObjectVersions(largestObjVersions);
    }
    info.initObjectChecksums(objChecksums);
    if (lastObjNum > -1) {
      File lastObjFile=new File(fileDir.getAbsolutePath() + ""String_Node_Str"" + lastObject);
      long lastObjSize=lastObjFile.length();
      if (lastObjSize == 0) {
        lastObjSize=sp.getStripeSizeForObject(lastObjSize);
      }
      long fsize=lastObjSize;
      if (lastObjNum > 0) {
        fsize+=sp.getObjectEndOffset(lastObjNum - 1) + 1;
      }
      assert(fsize >= 0);
      info.setFilesize(fsize);
      info.setLastObjectNumber(lastObjNum);
    }
 else {
      info.setFilesize(0l);
      info.setLastObjectNumber(-1);
    }
    File tepoch=new File(fileDir,TEPOCH_FILENAME);
    if (tepoch.exists()) {
      RandomAccessFile raf=null;
      try {
        raf=new RandomAccessFile(tepoch,""String_Node_Str"");
        info.setTruncateEpoch(raf.readLong());
      }
  finally {
        if (raf != null) {
          raf.close();
        }
      }
    }
    File vtFile=new File(fileDir,VTABLE_FILENAME);
    VersionTable vt=new VersionTable(vtFile);
    if (vtFile.exists())     vt.load();
    info.initVersionTable(vt);
  }
 else {
    info.setFilesize(0);
    info.setLastObjectNumber(-1);
    info.initLatestObjectVersions(new HashMap<Long,Long>());
    info.initLargestObjectVersions(new HashMap<Long,Long>());
    info.initObjectChecksums(new HashMap<Long,Map<Long,Long>>());
    info.initVersionTable(new VersionTable(new File(fileDir,VTABLE_FILENAME)));
  }
  info.setGlobalLastObjectNumber(-1);
  return info;
}",0.9979101358411704
113427,"public TruncateLog getTruncateLog(String fileId) throws IOException {
  TruncateLog.Builder tlbuilder=TruncateLog.newBuilder();
  try {
    File fileDir=new File(generateAbsoluteFilePath(fileId));
    File tlog=new File(fileDir,TRUNCATE_LOG_FILENAME);
    FileInputStream input=null;
    try {
      input=new FileInputStream(tlog);
      tlbuilder.mergeDelimitedFrom(input);
    }
  finally {
      if (input != null) {
        input.close();
      }
    }
  }
 catch (  IOException ex) {
  }
  return tlbuilder.build();
}","@Override public TruncateLog getTruncateLog(String fileId) throws IOException {
  TruncateLog.Builder tlbuilder=TruncateLog.newBuilder();
  try {
    File fileDir=new File(generateAbsoluteFilePath(fileId));
    File tlog=new File(fileDir,TRUNCATE_LOG_FILENAME);
    FileInputStream input=null;
    try {
      input=new FileInputStream(tlog);
      tlbuilder.mergeDelimitedFrom(input);
    }
  finally {
      if (input != null) {
        input.close();
      }
    }
  }
 catch (  IOException ex) {
  }
  return tlbuilder.build();
}",0.990530303030303
113428,"@Override public int getMasterEpoch(String fileId) throws IOException {
  int masterEpoch=0;
  RandomAccessFile raf=null;
  try {
    File fileDir=new File(generateAbsoluteFilePath(fileId));
    File mepoch=new File(fileDir,MASTER_EPOCH_FILENAME);
    raf=new RandomAccessFile(mepoch,""String_Node_Str"");
    masterEpoch=raf.readInt();
  }
 catch (  FileNotFoundException ex) {
  }
 finally {
    if (raf != null) {
      raf.close();
    }
  }
  return masterEpoch;
}","@Override public int getMasterEpoch(String fileId) throws IOException {
  int masterEpoch=0;
  RandomAccessFile raf=null;
  File fileDir=new File(generateAbsoluteFilePath(fileId));
  File mepoch=new File(fileDir,MASTER_EPOCH_FILENAME);
  try {
    raf=new RandomAccessFile(mepoch,""String_Node_Str"");
    masterEpoch=raf.readInt();
  }
 catch (  FileNotFoundException ex) {
    String oldFileId=""String_Node_Str"" + fileId;
    File oldFileDir=new File(generateAbsoluteFilePath(oldFileId));
    File oldMepoch=new File(oldFileDir,MASTER_EPOCH_FILENAME);
    if (oldMepoch.isFile()) {
      if (!fileDir.exists()) {
        fileDir.mkdirs();
      }
      if (oldMepoch.renameTo(mepoch)) {
        del(oldFileDir);
        raf=new RandomAccessFile(mepoch,""String_Node_Str"");
      }
 else {
        Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"",MASTER_EPOCH_FILENAME,oldFileDir.getPath(),fileDir.getPath());
        raf=new RandomAccessFile(oldMepoch,""String_Node_Str"");
      }
      masterEpoch=raf.readInt();
    }
  }
 finally {
    if (raf != null) {
      raf.close();
    }
  }
  return masterEpoch;
}",0.573408947700063
113429,"/** 
 * Creates a new instance of Main
 */
public OSD(OSDConfig config){
  if (Logging.isInfo()) {
    Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",System.getProperty(""String_Node_Str""));
    Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",config.getUUID());
  }
  try {
    dispatcher=new OSDRequestDispatcher(config);
    dispatcher.start();
    final OSDRequestDispatcher ctrl=dispatcher;
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        try {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
          ctrl.heartbeatThread.shutdown();
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
        }
 catch (        Throwable ex) {
          ex.printStackTrace();
        }
      }
    }
);
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,null,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,null,ex);
    if (dispatcher != null)     try {
      dispatcher.shutdown();
    }
 catch (    Exception e) {
      Logging.logMessage(Logging.LEVEL_ERROR,config.getUUID(),""String_Node_Str"");
      Logging.logError(Logging.LEVEL_ERROR,config.getUUID(),e);
    }
    System.exit(1);
  }
}","/** 
 * Creates a new instance of Main
 */
public OSD(OSDConfig config){
  if (Logging.isInfo()) {
    Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",System.getProperty(""String_Node_Str""));
    Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",config.getUUID());
  }
  try {
    dispatcher=new OSDRequestDispatcher(config);
    dispatcher.start();
    final OSDRequestDispatcher ctrl=dispatcher;
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        try {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
          ctrl.shutdown();
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
        }
 catch (        Throwable ex) {
          ex.printStackTrace();
        }
      }
    }
);
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,null,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,null,ex);
    if (dispatcher != null)     try {
      dispatcher.shutdown();
    }
 catch (    Exception e) {
      Logging.logMessage(Logging.LEVEL_ERROR,config.getUUID(),""String_Node_Str"");
      Logging.logError(Logging.LEVEL_ERROR,config.getUUID(),e);
    }
    System.exit(1);
  }
}",0.994198694706309
113430,"@Override public void run(){
  try {
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
    ctrl.heartbeatThread.shutdown();
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
  }
}","@Override public void run(){
  try {
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
    ctrl.shutdown();
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
  }
}",0.9772079772079773
113431,"public void translateReadRequest(int size,long offset,StripingPolicy policy,Vector<ReadOperation> operations){
  int stripeSize=policy.getStripeSize() * 1024;
  int osdCount=policy.getWidth();
  int start=0;
  while (start < size) {
    long objNumber=(start + offset) / stripeSize;
    int osdOffset=(int)(objNumber % osdCount);
    int reqOffset=(int)(start + offset) % stripeSize;
    int reqSize=Math.min(size - start,stripeSize - reqOffset);
    operations.add(new ReadOperation(objNumber,osdOffset,reqSize,reqOffset,start));
    start+=reqSize;
  }
}","public void translateReadRequest(int size,long offset,StripingPolicy policy,Vector<ReadOperation> operations){
  int stripeSize=policy.getStripeSize() * 1024;
  int osdCount=policy.getWidth();
  int start=0;
  while (start < size) {
    long objNumber=(start + offset) / stripeSize;
    int osdOffset=(int)(objNumber % osdCount);
    int reqOffset=(int)((start + offset) % stripeSize);
    int reqSize=Math.min(size - start,stripeSize - reqOffset);
    operations.add(new ReadOperation(objNumber,osdOffset,reqSize,reqOffset,start));
    start+=reqSize;
  }
}",0.9982046678635548
113432,"public void translateReadRequest(int size,long offset,StripingPolicy policy,Vector<ReadOperation> operations){
  int stripeSize=policy.getStripeSize() * 1024;
  int osdCount=policy.getWidth();
  int start=0;
  while (start < size) {
    long objNumber=(start + offset) / stripeSize;
    int osdOffset=(int)(objNumber % osdCount);
    int reqOffset=(int)(start + offset) % stripeSize;
    int reqSize=Math.min(size - start,stripeSize - reqOffset);
    operations.add(new ReadOperation(objNumber,osdOffset,reqSize,reqOffset,start));
    start+=reqSize;
  }
}","public void translateReadRequest(int size,long offset,StripingPolicy policy,Vector<ReadOperation> operations){
  int stripeSize=policy.getStripeSize() * 1024;
  int osdCount=policy.getWidth();
  int start=0;
  while (start < size) {
    long objNumber=(start + offset) / stripeSize;
    int osdOffset=(int)(objNumber % osdCount);
    int reqOffset=(int)((start + offset) % stripeSize);
    int reqSize=Math.min(size - start,stripeSize - reqOffset);
    operations.add(new ReadOperation(objNumber,osdOffset,reqSize,reqOffset,start));
    start+=reqSize;
  }
}",0.9982046678635548
113433,"@Override public void run(){
  if (COLLECT_STATISTICS)   statThr.start();
  Logging.logMessage(Logging.LEVEL_INFO,Category.replication,this,""String_Node_Str"",FLEASE_VERSION);
  notifyStarted();
  long nextTimerRunInMS=TIMER_INTERVAL_IN_MS;
  lastTimerRun=0;
  List<Object> rqList=new ArrayList(1000);
  while (!quit) {
    try {
      final Object tmp=messages.poll(nextTimerRunInMS,TimeUnit.MILLISECONDS);
      if (quit) {
        break;
      }
      if ((tmp == null) || (TimeSync.getLocalSystemTime() >= lastTimerRun + nextTimerRunInMS)) {
        if (ENABLE_TIMEOUT_EVENTS) {
          checkTimers();
          checkLeaseTimeouts();
        }
 else {
          nextTimerRunInMS=checkTimers();
        }
        lastTimerRun=TimeSync.getLocalSystemTime();
      }
      if (tmp == null) {
        continue;
      }
      rqList.add(tmp);
      messages.drainTo(rqList,25);
      while (!rqList.isEmpty()) {
        final Object request=rqList.remove(rqList.size() - 1);
        long rqStart;
        if (COLLECT_STATISTICS) {
          rqStart=System.nanoTime();
        }
        if (request instanceof FleaseMessage) {
          final FleaseMessage msg=(FleaseMessage)request;
          if (msg.isInternalEvent()) {
            Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",msg);
          }
 else           if (msg.isAcceptorMessage()) {
            final FleaseMessage response=acceptor.processMessage(msg);
            if (response != null) {
              if (msg.getMasterEpochNumber() == FleaseMessage.REQUEST_MASTER_EPOCH) {
                if (meHandler != null) {
                  MasterEpochHandlerInterface.Continuation cont=new MasterEpochHandlerInterface.Continuation(){
                    @Override public void processingFinished(){
                      sender.sendMessage(response,msg.getSender());
                    }
                  }
;
                  if (response.getMsgType() == FleaseMessage.MsgType.MSG_PREPARE_ACK) {
                    meHandler.sendMasterEpoch(response,cont);
                  }
 else                   if (response.getMsgType() == FleaseMessage.MsgType.MSG_ACCEPT_ACK) {
                    meHandler.storeMasterEpoch(response,cont);
                  }
                }
 else {
                  Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
                  sender.sendMessage(response,msg.getSender());
                }
              }
 else {
                sender.sendMessage(response,msg.getSender());
              }
            }
          }
 else {
            proposer.processMessage(msg);
          }
          if (COLLECT_STATISTICS) {
            long rqEnd=System.nanoTime();
            durMsgs.get().add(Integer.valueOf((int)(rqEnd - rqStart)));
            outMsgs.incrementAndGet();
          }
        }
 else {
          Request rq=(Request)request;
switch (rq.type) {
case OPEN_CELL_REQUEST:
{
              assert(rq.acceptors != null);
              try {
                proposer.openCell(rq.cellId,rq.acceptors,rq.requestME);
                if (rq.listener != null)                 rq.listener.proposalResult(rq.cellId,null,0,FleaseMessage.IGNORE_MASTER_EPOCH);
              }
 catch (              FleaseException ex) {
                Logging.logError(Logging.LEVEL_DEBUG,this,ex);
                leaseListener.leaseFailed(rq.cellId,ex);
              }
              break;
            }
case CLOSE_CELL_REQUEST:
{
            proposer.closeCell(rq.cellId);
            rq.listener.proposalResult(rq.cellId,null,0,FleaseMessage.IGNORE_MASTER_EPOCH);
            break;
          }
case HANDOVER_LEASE:
{
          try {
            Flease prevLease=proposer.updatePrevLeaseForCell(rq.cellId,Flease.EMPTY_LEASE);
            if (prevLease != null) {
              leaseTimeouts.remove(prevLease);
            }
            proposer.handoverLease(rq.cellId,rq.newLeaseOwner);
          }
 catch (          FleaseException ex) {
            rq.listener.proposalFailed(rq.cellId,ex);
          }
          break;
        }
case SET_VIEW:
{
        try {
          proposer.setViewId(rq.cellId,rq.viewId);
          acceptor.setViewId(rq.cellId,rq.viewId);
        }
 catch (        FleaseException ex) {
          rq.listener.proposalFailed(rq.cellId,ex);
        }
        rq.listener.proposalResult(rq.cellId,null,0,FleaseMessage.IGNORE_MASTER_EPOCH);
        break;
      }
case GET_STATE:
{
      try {
        rq.cback.localStateResult(acceptor.localState());
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
    }
}
if (COLLECT_STATISTICS) {
  long rqEnd=System.nanoTime();
  durRequests.get().add(Integer.valueOf((int)(rqEnd - rqStart)));
}
}
}
if (DISABLE_RENEW_FOR_TESTING) {
Thread.sleep(0,2);
}
}
 catch (InterruptedException ex) {
if (quit) {
break;
}
}
catch (Throwable ex) {
notifyCrashed(ex);
break;
}
}
acceptor.shutdown();
notifyStopped();
Logging.logMessage(Logging.LEVEL_INFO,Category.replication,this,""String_Node_Str"",FLEASE_VERSION);
}","@Override public void run(){
}",0.0118577075098814
113434,"private void processObjectFetched(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final ObjectVersionMapping record=(ObjectVersionMapping)method.getArgs()[1];
    final InternalObjectData data=(InternalObjectData)method.getArgs()[2];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[3];
    ReplicatedFileState state=files.get(fileId);
    if (state != null) {
      if (error != null) {
        numObjsInFlight--;
        fetchObjects();
        failed(state,error,""String_Node_Str"");
      }
 else {
        final int bytes=data.getData().remaining();
        master.getStorageStage().writeObjectWithoutGMax(fileId,record.getObjectNumber(),state.getsPolicy(),0,data.getData(),CowPolicy.PolicyNoCow,null,false,record.getObjectVersion(),null,new WriteObjectCallback(){
          @Override public void writeComplete(          OSDWriteResponse result,          ErrorResponse error){
            if (error != null) {
              Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",ErrorUtils.formatError(error));
            }
          }
        }
);
        master.getPreprocStage().pingFile(fileId);
        master.objectReplicated();
        master.replicatedDataReceived(bytes);
        numObjsInFlight--;
        final int numPendingFile=state.getNumObjectsPending() - 1;
        state.setNumObjectsPending(numPendingFile);
        state.getPolicy().objectFetched(record.getObjectVersion());
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId,numPendingFile);
        fetchObjects();
        if (numPendingFile == 0) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId);
          doOpen(state);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","private void processObjectFetched(StageRequest method){
  try {
    final String fileId=(String)method.getArgs()[0];
    final ObjectVersionMapping record=(ObjectVersionMapping)method.getArgs()[1];
    final InternalObjectData data=(InternalObjectData)method.getArgs()[2];
    final ErrorResponse error=(ErrorResponse)method.getArgs()[3];
    ReplicatedFileState state=files.get(fileId);
    if (state != null) {
      if (error != null || data.getData() == null) {
        numObjsInFlight--;
        fetchObjects();
        failed(state,error,""String_Node_Str"");
      }
 else {
        final int bytes=data.getData().remaining();
        master.getStorageStage().writeObjectWithoutGMax(fileId,record.getObjectNumber(),state.getsPolicy(),0,data.getData(),CowPolicy.PolicyNoCow,null,false,record.getObjectVersion(),null,new WriteObjectCallback(){
          @Override public void writeComplete(          OSDWriteResponse result,          ErrorResponse error){
            if (error != null) {
              Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",ErrorUtils.formatError(error));
            }
          }
        }
);
        master.getPreprocStage().pingFile(fileId);
        master.objectReplicated();
        master.replicatedDataReceived(bytes);
        numObjsInFlight--;
        final int numPendingFile=state.getNumObjectsPending() - 1;
        state.setNumObjectsPending(numPendingFile);
        state.getPolicy().objectFetched(record.getObjectVersion());
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId,numPendingFile);
        fetchObjects();
        if (numPendingFile == 0) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",localID,fileId);
          doOpen(state);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9933367503844184
113435,"public void waitForShutdown() throws Exception {
  client.waitForShutdown();
  fleaseClient.waitForShutdown();
  fstage.waitForShutdown();
  masterEpochThread.waitForShutdown();
  super.waitForShutdown();
}","@Override public void waitForShutdown() throws Exception {
  client.waitForShutdown();
  fleaseClient.waitForShutdown();
  fstage.waitForShutdown();
  masterEpochThread.waitForShutdown();
  super.waitForShutdown();
}",0.976303317535545
113436,"/** 
 * enqueues the request and corresponding object for replication
 * @see java.util.ArrayList#add(java.lang.Object)
 */
public boolean addObjectForReplication(Long objectNo,StageRequest rq){
  assert(rq != null);
  ReplicatingObject info=objectsInProgress.get(objectNo);
  if (info == null) {
    info=new ReplicatingObject(objectNo);
    info.getWaitingRequests().add(rq);
    waitingRequests.put(objectNo,info);
    strategy.addObject(objectNo,true);
  }
 else {
    info.getWaitingRequests().add(rq);
  }
  return true;
}","/** 
 * enqueues the request and corresponding object for replication
 * @see java.util.ArrayList#add(java.lang.Object)
 */
public boolean addObjectForReplication(Long objectNo,StageRequest rq){
  assert(rq != null);
  ReplicatingObject info=objectsInProgress.get(objectNo);
  if (info == null) {
    info=waitingRequests.get(objectNo);
    if (info == null) {
      info=new ReplicatingObject(objectNo);
      waitingRequests.put(objectNo,info);
      strategy.addObject(objectNo,true);
    }
  }
  info.getWaitingRequests().add(rq);
  return true;
}",0.7025023169601483
113437,"private void doPrepareRequest(StageRequest rq){
  final OSDRequest request=(OSDRequest)rq.getArgs()[0];
  final ParseCompleteCallback callback=(ParseCompleteCallback)rq.getCallback();
  numRequests++;
  if (parseRequest(request) == false)   return;
  if (request.getOperation().requiresCapability()) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"");
    ErrorResponse err=processAuthenticate(request);
    if (err != null) {
      callback.parseComplete(request,err);
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",ErrorUtils.formatError(err));
      }
      return;
    }
  }
  String fileId=request.getFileId();
  if (fileId != null) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"");
    boolean write=request.getCapability() != null && request.getCapability().getSnapConfig() != SnapConfig.SNAP_CONFIG_SNAPS_DISABLED && ((SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber()) & request.getCapability().getAccessMode()) > 0;
    CowPolicy cowPolicy;
    if (oft.contains(fileId)) {
      cowPolicy=oft.refresh(fileId,TimeSync.getLocalSystemTime() + OFT_OPEN_EXTENSION,write);
    }
 else {
      if (request.getCapability() == null || request.getCapability().getSnapConfig() == SnapConfig.SNAP_CONFIG_SNAPS_DISABLED)       cowPolicy=CowPolicy.PolicyNoCow;
 else       cowPolicy=new CowPolicy(cowMode.COW_ONCE);
      oft.openFile(fileId,TimeSync.getLocalSystemTime() + OFT_OPEN_EXTENSION,cowPolicy,write);
      request.setFileOpen(true);
    }
    request.setCowPolicy(cowPolicy);
  }
  callback.parseComplete(request,null);
}","private void doPrepareRequest(StageRequest rq){
  final OSDRequest request=(OSDRequest)rq.getArgs()[0];
  final ParseCompleteCallback callback=(ParseCompleteCallback)rq.getCallback();
  numRequests++;
  if (parseRequest(request) == false)   return;
  if (request.getOperation().requiresCapability()) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"");
    ErrorResponse err=processAuthenticate(request);
    if (err != null) {
      callback.parseComplete(request,err);
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",ErrorUtils.formatError(err));
      }
      return;
    }
  }
  String fileId=request.getFileId();
  if (fileId != null) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"");
    CowPolicy cowPolicy=CowPolicy.PolicyNoCow;
    if (!(request.getOperation() instanceof DeleteOperation)) {
      boolean write=request.getCapability() != null && request.getCapability().getSnapConfig() != SnapConfig.SNAP_CONFIG_SNAPS_DISABLED && ((SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber()) & request.getCapability().getAccessMode()) > 0;
      if (oft.contains(fileId)) {
        cowPolicy=oft.refresh(fileId,TimeSync.getLocalSystemTime() + OFT_OPEN_EXTENSION,write);
      }
 else {
        if (request.getCapability() == null || request.getCapability().getSnapConfig() == SnapConfig.SNAP_CONFIG_SNAPS_DISABLED)         cowPolicy=CowPolicy.PolicyNoCow;
 else         cowPolicy=new CowPolicy(cowMode.COW_ONCE);
        oft.openFile(fileId,TimeSync.getLocalSystemTime() + OFT_OPEN_EXTENSION,cowPolicy,write);
        request.setFileOpen(true);
      }
    }
    request.setCowPolicy(cowPolicy);
  }
  callback.parseComplete(request,null);
}",0.9580456718003186
113438,"protected void processMethod(StageRequest m){
  final int requestedMethod=m.getStageMethod();
switch (requestedMethod) {
case STAGEOP_PARSE_AUTH_OFTOPEN:
    doPrepareRequest(m);
  break;
case STAGEOP_OFT_DELETE:
doCheckDeleteOnClose(m);
break;
case STAGEOP_ACQUIRE_LOCK:
doAcquireLock(m);
break;
case STAGEOP_CHECK_LOCK:
doCheckLock(m);
break;
case STAGEOP_UNLOCK:
doUnlock(m);
break;
case STAGEOP_PING_FILE:
doPingFile(m);
break;
default :
Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",requestedMethod);
break;
}
}","@Override protected void processMethod(StageRequest m){
  final int requestedMethod=m.getStageMethod();
switch (requestedMethod) {
case STAGEOP_PARSE_AUTH_OFTOPEN:
    doPrepareRequest(m);
  break;
case STAGEOP_OFT_DELETE:
doCheckDeleteOnClose(m);
break;
case STAGEOP_ACQUIRE_LOCK:
doAcquireLock(m);
break;
case STAGEOP_CHECK_LOCK:
doCheckLock(m);
break;
case STAGEOP_UNLOCK:
doUnlock(m);
break;
case STAGEOP_PING_FILE:
doPingFile(m);
break;
default :
Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",requestedMethod);
break;
}
}",0.9906890130353816
113439,"public static void main(String[] args){
  if (args.length < 1 || !args[0].equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  Logging.start(Logging.LEVEL_ERROR,Category.tool);
  userCredentials=UserCredentials.newBuilder().setUsername(""String_Node_Str"").addGroups(""String_Node_Str"").build();
  String dirAddress=""String_Node_Str"";
  SSLOptions sslOptions=null;
  Options options=new Options();
  try {
    client=ClientFactory.createClient(dirAddress,userCredentials,sslOptions,options);
    client.start();
    volume=client.openVolume(""String_Node_Str"",sslOptions,options);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(2);
  }
  String exampleFilesDir=""String_Node_Str"";
  java.io.File dir=new java.io.File(exampleFilesDir);
  String[] files=dir.list();
  exampleFiles=new ArrayList<String>(files.length);
  if (files != null) {
    for (    String file : files) {
      exampleFiles.add(exampleFilesDir + file);
    }
  }
  boolean errorsOccurred=DeleteDirectoryRecursively(""String_Node_Str"");
  for (  String filename : exampleFiles) {
    java.io.File sourceFile=new java.io.File(filename);
    FileInputStream source=null;
    FileHandle target=null;
    try {
      source=new FileInputStream(sourceFile);
      target=volume.openFile(userCredentials,""String_Node_Str"" + sourceFile.getName(),SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber());
      byte[] buffer=new byte[128 * 1024];
      int bytesRead;
      while ((bytesRead=source.read(buffer)) != -1) {
        target.write(userCredentials,buffer,bytesRead,0);
      }
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
 finally {
      if (source != null) {
        try {
          source.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
          e.printStackTrace();
          errorsOccurred=true;
        }
      }
      if (target != null) {
        try {
          target.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + sourceFile.getName() + ""String_Node_Str"");
          e.printStackTrace();
          errorsOccurred=true;
        }
      }
    }
  }
  for (  String file : exampleFiles) {
    String fileName=new java.io.File(file).getName();
    long fileSize=new java.io.File(file).length();
    FileHandle xtreemfsFile=null;
    try {
      xtreemfsFile=volume.openFile(userCredentials,""String_Node_Str"" + fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
      Stat stbuf=xtreemfsFile.getAttr(userCredentials).toBuilder().setMode(0666).build();
      volume.setAttr(userCredentials,""String_Node_Str"" + fileName,stbuf,Setattrs.SETATTR_MODE.getNumber());
      xtreemfsFile.truncate(userCredentials,fileSize);
      xtreemfsFile.close();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ fileSize+ ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
  }
  client.shutdown();
  if (errorsOccurred) {
    System.out.println(""String_Node_Str"");
    System.exit(3);
  }
}","public static void main(String[] args){
  if (args.length < 1 || !args[0].equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  Logging.start(Logging.LEVEL_ERROR,Category.tool);
  userCredentials=UserCredentials.newBuilder().setUsername(""String_Node_Str"").addGroups(""String_Node_Str"").build();
  String dirAddress=""String_Node_Str"";
  SSLOptions sslOptions=null;
  Options options=new Options();
  try {
    client=ClientFactory.createClient(dirAddress,userCredentials,sslOptions,options);
    client.start();
    volume=client.openVolume(""String_Node_Str"",sslOptions,options);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(2);
  }
  String exampleFilesDir=""String_Node_Str"";
  java.io.File dir=new java.io.File(exampleFilesDir);
  String[] files=dir.list();
  exampleFiles=new ArrayList<String>(files.length);
  if (files != null) {
    for (    String file : files) {
      exampleFiles.add(exampleFilesDir + file);
    }
  }
  boolean errorsOccurred=DeleteDirectoryRecursively(""String_Node_Str"");
  for (  String filename : exampleFiles) {
    java.io.File sourceFile=new java.io.File(filename);
    FileInputStream source=null;
    FileHandle target=null;
    try {
      source=new FileInputStream(sourceFile);
      target=volume.openFile(userCredentials,""String_Node_Str"" + sourceFile.getName(),SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber());
      byte[] buffer=new byte[128 * 1024];
      int bytesRead=0;
      long bytewritten=0;
      while ((bytesRead=source.read(buffer)) != -1) {
        target.write(userCredentials,buffer,bytesRead,bytewritten);
        bytewritten+=bytesRead;
      }
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
 finally {
      if (source != null) {
        try {
          source.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
          e.printStackTrace();
          errorsOccurred=true;
        }
      }
      if (target != null) {
        try {
          target.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + sourceFile.getName() + ""String_Node_Str"");
          e.printStackTrace();
          errorsOccurred=true;
        }
      }
    }
  }
  for (  String file : exampleFiles) {
    String fileName=new java.io.File(file).getName();
    long fileSize=new java.io.File(file).length();
    FileHandle xtreemfsFile=null;
    try {
      xtreemfsFile=volume.openFile(userCredentials,""String_Node_Str"" + fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
      Stat stbuf=xtreemfsFile.getAttr(userCredentials).toBuilder().setMode(0666).build();
      volume.setAttr(userCredentials,""String_Node_Str"" + fileName,stbuf,Setattrs.SETATTR_MODE.getNumber());
      xtreemfsFile.truncate(userCredentials,fileSize);
      xtreemfsFile.close();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ fileSize+ ""String_Node_Str"");
      e.printStackTrace();
      errorsOccurred=true;
    }
  }
  client.shutdown();
  if (errorsOccurred) {
    System.out.println(""String_Node_Str"");
    System.exit(3);
  }
}",0.9898099697053152
113440,"public FileScrubber(String fileName,AdminVolume volume,FileScrubbedListener listener,Set<String> removedOSDs,boolean repair,boolean delete) throws PosixErrorException, AddressToUUIDNotFoundException, IOException {
  this.volume=volume;
  try {
    this.fileHandle=volume.openFile(xtfs_scrub.credentials,fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
    isReadOnly=false;
  }
 catch (  PosixErrorException e) {
    this.fileHandle=volume.openFile(xtfs_scrub.credentials,fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDONLY.getNumber());
    isReadOnly=true;
  }
  this.fileName=fileName;
  this.listener=listener;
  returnStatus=new TreeSet<ReturnStatus>();
  nextObjectToScrub=0;
  byteCounter=0;
  osdFileSize=0;
  this.removedOSDs=removedOSDs;
  this.repair=repair;
  this.delete=delete;
}","public FileScrubber(String fileName,AdminVolume volume,FileScrubbedListener listener,Set<String> removedOSDs,boolean repair,boolean delete) throws PosixErrorException, AddressToUUIDNotFoundException, IOException {
  this.volume=volume;
  try {
    this.fileHandle=volume.openFile(xtfs_scrub.credentials,fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber());
    isReadOnly=false;
  }
 catch (  PosixErrorException e) {
    this.fileHandle=volume.openFile(xtfs_scrub.credentials,fileName,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDONLY.getNumber());
    isReadOnly=true;
  }
  this.fileName=fileName;
  this.listener=listener;
  returnStatus=new TreeSet<ReturnStatus>();
  nextObjectToScrub=0;
  byteCounter=0;
  this.removedOSDs=removedOSDs;
  this.repair=repair;
  this.delete=delete;
}",0.9893148962916404
113441,"private void scrubRWOrNonReplicatedFile(){
  boolean checkMrcFileSize=true;
  List<Replica> replicas=fileHandle.getReplicasList();
  List<Replica> removedReplicas=new LinkedList<Replica>();
  for (int r=0; r < replicas.size(); r++) {
    Replica replica=replicas.get(r);
    boolean isReplOnDeadOsd=false;
    for (    String osd : replica.getOsdUuidsList()) {
      if (removedOSDs.contains(osd)) {
        if (fileHandle.getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE) | fileHandle.getReplicasList().size() == 1) {
          String errMsg=""String_Node_Str"";
          if (delete) {
            errMsg=""String_Node_Str"";
            try {
              volume.unlink(xtfs_scrub.credentials,fileName);
            }
 catch (            IOException ex2) {
              errMsg=""String_Node_Str"" + fileName + ""String_Node_Str""+ ex2.getMessage();
            }
          }
          printFileErrorMessage(errMsg);
          returnStatus.add(ReturnStatus.FILE_LOST);
          return;
        }
 else {
          removedReplicas.add(replica);
          isReplOnDeadOsd=true;
          break;
        }
      }
    }
    if (!isReplOnDeadOsd) {
      byteCounter=0;
      boolean eof=false;
      nextObjectToScrub=0;
      while (!eof) {
        try {
          int objSize=fileHandle.checkObjectAndGetSize(r,nextObjectToScrub++);
          byteCounter+=objSize;
          if (objSize < replica.getStripingPolicy().getStripeSize()) {
            eof=true;
          }
        }
 catch (        InvalidChecksumException ex) {
          printFileErrorMessage(""String_Node_Str"" + (nextObjectToScrub - 1) + ""String_Node_Str""+ r+ ""String_Node_Str""+ replica.getOsdUuids((int)((nextObjectToScrub - 1) % replica.getOsdUuidsCount())));
          checkMrcFileSize=false;
          returnStatus.add(ReturnStatus.FAILURE_OBJECTS);
          break;
        }
catch (        IOException ex) {
          printFileErrorMessage(""String_Node_Str"" + (nextObjectToScrub - 1) + ""String_Node_Str""+ r+ ""String_Node_Str""+ ex);
          checkMrcFileSize=false;
          returnStatus.add(ReturnStatus.UNREACHABLE);
          break;
        }
      }
    }
  }
  if (!removedReplicas.isEmpty()) {
    if (repair) {
      recreateReplicas(removedReplicas);
    }
 else {
      printFileErrorMessage(""String_Node_Str"" + removedReplicas.size() + ""String_Node_Str"");
    }
    returnStatus.add(ReturnStatus.FAILURE_REPLICAS);
  }
  if (fileHandle.getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE) & checkMrcFileSize) {
    try {
      long mrcFileSize=volume.getAttr(xtfs_scrub.credentials,fileName).getSize();
      if ((osdFileSize != mrcFileSize)) {
        if (repair) {
          fileHandle.truncate(xtfs_scrub.credentials,(int)byteCounter,true);
          printFileErrorMessage(""String_Node_Str"" + mrcFileSize + ""String_Node_Str""+ byteCounter+ ""String_Node_Str"");
        }
 else {
          printFileErrorMessage(""String_Node_Str"" + mrcFileSize + ""String_Node_Str""+ byteCounter+ ""String_Node_Str"");
        }
        returnStatus.add(ReturnStatus.WRONG_FILE_SIZE);
      }
    }
 catch (    IOException ex) {
      printFileErrorMessage(""String_Node_Str"" + ex);
      returnStatus.add(ReturnStatus.UNREACHABLE);
    }
  }
  if (returnStatus.size() == 0) {
    returnStatus.add(ReturnStatus.FILE_OK);
  }
}","private void scrubRWOrNonReplicatedFile(){
  boolean checkMrcFileSize=true;
  List<Replica> replicas=fileHandle.getReplicasList();
  List<Replica> removedReplicas=new LinkedList<Replica>();
  for (int r=0; r < replicas.size(); r++) {
    Replica replica=replicas.get(r);
    boolean isReplOnDeadOsd=false;
    for (    String osd : replica.getOsdUuidsList()) {
      if (removedOSDs.contains(osd)) {
        if (fileHandle.getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE) | fileHandle.getReplicasList().size() == 1) {
          String errMsg=""String_Node_Str"";
          if (delete) {
            errMsg=""String_Node_Str"";
            try {
              volume.unlink(xtfs_scrub.credentials,fileName);
            }
 catch (            IOException ex2) {
              errMsg=""String_Node_Str"" + fileName + ""String_Node_Str""+ ex2.getMessage();
            }
          }
          printFileErrorMessage(errMsg);
          returnStatus.add(ReturnStatus.FILE_LOST);
          return;
        }
 else {
          removedReplicas.add(replica);
          isReplOnDeadOsd=true;
          break;
        }
      }
    }
    if (!isReplOnDeadOsd) {
      byteCounter=0;
      boolean eof=false;
      nextObjectToScrub=0;
      while (!eof) {
        try {
          int objSize=fileHandle.checkObjectAndGetSize(r,nextObjectToScrub++);
          byteCounter+=objSize;
          if (objSize < replica.getStripingPolicy().getStripeSize()) {
            eof=true;
          }
        }
 catch (        InvalidChecksumException ex) {
          printFileErrorMessage(""String_Node_Str"" + (nextObjectToScrub - 1) + ""String_Node_Str""+ r+ ""String_Node_Str""+ replica.getOsdUuids((int)((nextObjectToScrub - 1) % replica.getOsdUuidsCount())));
          checkMrcFileSize=false;
          returnStatus.add(ReturnStatus.FAILURE_OBJECTS);
          break;
        }
catch (        IOException ex) {
          printFileErrorMessage(""String_Node_Str"" + (nextObjectToScrub - 1) + ""String_Node_Str""+ r+ ""String_Node_Str""+ ex);
          checkMrcFileSize=false;
          returnStatus.add(ReturnStatus.UNREACHABLE);
          break;
        }
      }
    }
  }
  if (!removedReplicas.isEmpty()) {
    if (repair) {
      recreateReplicas(removedReplicas);
    }
 else {
      printFileErrorMessage(""String_Node_Str"" + removedReplicas.size() + ""String_Node_Str"");
    }
    returnStatus.add(ReturnStatus.FAILURE_REPLICAS);
  }
  if (fileHandle.getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE) & checkMrcFileSize) {
    try {
      long mrcFileSize=volume.getAttr(xtfs_scrub.credentials,fileName).getSize();
      if (byteCounter != mrcFileSize) {
        if (repair) {
          fileHandle.truncate(xtfs_scrub.credentials,byteCounter,true);
          printFileErrorMessage(""String_Node_Str"" + mrcFileSize + ""String_Node_Str""+ byteCounter+ ""String_Node_Str"");
        }
 else {
          printFileErrorMessage(""String_Node_Str"" + mrcFileSize + ""String_Node_Str""+ byteCounter+ ""String_Node_Str"");
        }
        returnStatus.add(ReturnStatus.WRONG_FILE_SIZE);
      }
    }
 catch (    IOException ex) {
      printFileErrorMessage(""String_Node_Str"" + ex);
      returnStatus.add(ReturnStatus.UNREACHABLE);
    }
  }
  if (returnStatus.size() == 0) {
    returnStatus.add(ReturnStatus.FILE_OK);
  }
}",0.9956423741547707
113442,"@Override public void volumeNameToMRCUUID(String volumeName,UUIDIterator uuidIterator) throws VolumeNotFoundException, AddressToUUIDNotFoundException {
  assert(uuidIterator != null);
  assert(!volumeName.isEmpty());
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volumeName);
  }
  String parsedVolumeName=parseVolumeName(volumeName);
  ServiceSet sSet=null;
  try {
    sSet=RPCCaller.<String,ServiceSet>syncCall(SERVICES.DIR,this.dirServiceUserCredentials,this.dirServiceAuth,this.options,this,this.dirServiceAddresses,true,parsedVolumeName,new CallGenerator<String,ServiceSet>(){
      @Override public RPCResponse<ServiceSet> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      String input) throws IOException {
        return ClientImplementation.this.dirServiceClient.xtreemfs_service_get_by_name(server,authHeader,userCreds,input);
      }
    }
);
  }
 catch (  IOException e) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",volumeName,e.getMessage());
      throw new VolumeNotFoundException(parsedVolumeName);
    }
  }
  boolean mrcFound=false;
  for (  Service service : sSet.getServicesList()) {
    if (service.getType().equals(ServiceType.SERVICE_TYPE_VOLUME) && service.getName().equals(parsedVolumeName)) {
      for (      KeyValuePair kvp : service.getData().getDataList()) {
        if (kvp.getKey().substring(0,3).equals(""String_Node_Str"")) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",kvp.getValue(),kvp.getKey());
          }
          uuidIterator.addUUID(kvp.getValue());
          mrcFound=true;
        }
      }
    }
  }
  if (!mrcFound) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",parsedVolumeName);
    }
    throw new VolumeNotFoundException(parsedVolumeName);
  }
}","@Override public void volumeNameToMRCUUID(String volumeName,UUIDIterator uuidIterator) throws VolumeNotFoundException, AddressToUUIDNotFoundException {
  assert(uuidIterator != null);
  assert(!volumeName.isEmpty());
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volumeName);
  }
  String parsedVolumeName=parseVolumeName(volumeName);
  ServiceSet sSet=null;
  try {
    sSet=RPCCaller.<String,ServiceSet>syncCall(SERVICES.DIR,this.dirServiceUserCredentials,this.dirServiceAuth,this.options,this,this.dirServiceAddresses,true,parsedVolumeName,new CallGenerator<String,ServiceSet>(){
      @Override public RPCResponse<ServiceSet> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      String input) throws IOException {
        return ClientImplementation.this.dirServiceClient.xtreemfs_service_get_by_name(server,authHeader,userCreds,input);
      }
    }
);
  }
 catch (  IOException e) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",volumeName,e.getMessage());
    }
    throw new VolumeNotFoundException(parsedVolumeName);
  }
  boolean mrcFound=false;
  for (  Service service : sSet.getServicesList()) {
    if (service.getType().equals(ServiceType.SERVICE_TYPE_VOLUME) && service.getName().equals(parsedVolumeName)) {
      for (      KeyValuePair kvp : service.getData().getDataList()) {
        if (kvp.getKey().substring(0,3).equals(""String_Node_Str"")) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",kvp.getValue(),kvp.getKey());
          }
          uuidIterator.addUUID(kvp.getValue());
          mrcFound=true;
        }
      }
    }
  }
  if (!mrcFound) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",parsedVolumeName);
    }
    throw new VolumeNotFoundException(parsedVolumeName);
  }
}",0.997577519379845
113443,"protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (buffer != null && r.getData() != null) {
          buffer.put(r.getData());
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}","protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (r.getData() != null) {
          if (buffer != null) {
            buffer.put(r.getData());
          }
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}",0.9899783315276272
113444,"protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (buffer != null && r.getData() != null) {
          buffer.put(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}","protected static <C,R extends Message>R syncCall(SERVICES service,UserCredentials userCreds,Auth auth,Options options,UUIDResolver uuidResolver,UUIDIterator it,boolean uuidIteratorHasAddresses,boolean delayNextTry,int maxRetries,C callRequest,ReusableBuffer buffer,CallGenerator<C,R> callGen) throws PosixErrorException, IOException, InternalServerErrorException, AddressToUUIDNotFoundException {
  int maxTries=maxRetries;
  int attempt=0;
  R response=null;
  try {
    while (++attempt <= maxTries || maxTries == 0) {
      RPCResponse<R> r=null;
      try {
        InetSocketAddress server;
        if (uuidIteratorHasAddresses) {
          server=getInetSocketAddressFromAddress(it.getUUID(),service);
        }
 else {
          String address=uuidResolver.uuidToAddress(it.getUUID());
          server=getInetSocketAddressFromAddress(address,service);
        }
        r=callGen.executeCall(server,auth,userCreds,callRequest);
        response=r.get();
        if (buffer != null && r.getData() != null) {
          buffer.put(r.getData());
          BufferPool.free(r.getData());
        }
      }
 catch (      PBRPCException pbe) {
        if (pbe.getErrorType().equals(ErrorType.REDIRECT)) {
          assert(pbe.getRedirectToServerUUID() != null);
          if (Logging.isInfo()) {
            String error;
            if (uuidIteratorHasAddresses) {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
 else {
              error=""String_Node_Str"" + it.getUUID() + ""String_Node_Str""+ pbe.getRedirectToServerUUID()+ ""String_Node_Str""+ attempt;
            }
            Logging.logMessage(Logging.LEVEL_INFO,Category.misc,pbe,error);
          }
          if (maxTries != 0 && attempt == maxTries) {
            maxTries++;
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry)) && (pbe.getErrorType().equals(ErrorType.IO_ERROR) || pbe.getErrorType().equals(ErrorType.INTERNAL_SERVER_ERROR))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,pbe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
        }
 else {
          throw pbe;
        }
      }
catch (      IOException ioe) {
        if (((attempt < maxTries || maxTries == 0) || (attempt == maxTries && delayNextTry))) {
          if (attempt == 1 && maxTries != 1) {
            String retriesLeft=(maxTries == 0) ? (""String_Node_Str"") : (String.valueOf(maxTries - attempt));
            Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,ioe,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",it.getUUID(),retriesLeft,options.getRetryDelay_s());
          }
          it.markUUIDAsFailed(it.getUUID());
          continue;
        }
 else {
          throw ioe;
        }
      }
catch (      InterruptedException ie) {
        if (options.getInterruptSignal() == 0) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,ie,""String_Node_Str"");
          }
          break;
        }
        throw new IOException();
      }
 finally {
        if (r != null) {
          r.freeBuffers();
        }
      }
      return response;
    }
  }
 catch (  PBRPCException e) {
    handleErrorAfterMaxTriesExceeded(e,it);
  }
  return null;
}",0.9945325314379442
113445,"/** 
 * Called by the file size update callback of FileHandle.
 */
protected void asyncFileSizeUpdateResponseHandler(OSDWriteResponse owr,FileHandleImplementation fileHandle,boolean success){
synchronized (osdWriteResponseLock) {
    if (Helper.compareOSDWriteResponses(owr,osdWriteResponse) == 0) {
      assert(osdWriteResponseStatus == FilesizeUpdateStatus.kDirtyAndAsyncPending);
      if (success) {
        osdWriteResponseStatus=FilesizeUpdateStatus.kClean;
      }
 else {
        osdWriteResponseStatus=FilesizeUpdateStatus.kDirty;
      }
    }
    pendingFilesizeUpdates.remove(fileHandle);
    if (pendingFilesizeUpdates.size() == 0) {
      osdWriteResponseLock.notifyAll();
    }
  }
}","/** 
 * Called by the file size update callback of FileHandle.
 */
protected void asyncFileSizeUpdateResponseHandler(OSDWriteResponse owr,FileHandleImplementation fileHandle,boolean success){
synchronized (osdWriteResponseLock) {
    if (Helper.compareOSDWriteResponses(owr,osdWriteResponse) == 0) {
      assert(osdWriteResponseStatus == FilesizeUpdateStatus.kDirtyAndAsyncPending);
      if (success) {
        osdWriteResponseStatus=FilesizeUpdateStatus.kClean;
      }
 else {
        osdWriteResponseStatus=FilesizeUpdateStatus.kDirty;
      }
    }
    pendingFilesizeUpdates.remove(fileHandle);
    decreaseReferenceCount();
    if (pendingFilesizeUpdates.size() == 0) {
      osdWriteResponseLock.notifyAll();
    }
  }
}",0.9789915966386554
113446,"/** 
 * Implements callback for an async write request.
 */
private void writeFinished(OSDWriteResponse response,ReusableBuffer data,AsyncWriteBuffer writeBuffer){
  if (response.hasSizeInBytes()) {
    XCap xcap=writeBuffer.getFileHandle().getXcap();
    fileInfo.tryToUpdateOSDWriteResponse(response,xcap);
    decreasePendingBytesHelper(writeBuffer);
  }
}","/** 
 * Implements callback for an async write request.
 */
private void writeFinished(OSDWriteResponse response,ReusableBuffer data,AsyncWriteBuffer writeBuffer){
  if (response.hasSizeInBytes()) {
    XCap xcap=writeBuffer.getFileHandle().getXcap();
    fileInfo.tryToUpdateOSDWriteResponse(response,xcap);
  }
  decreasePendingBytesHelper(writeBuffer);
}",0.9916201117318436
113447,"@Override public byte[] getXAttr(long fileId,String uid,String key) throws DatabaseException {
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(XATTRS_INDEX,prefix,null).get();
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public byte[] getXAttr(long fileId,String uid,String key) throws DatabaseException {
  ResultSet<byte[],byte[]> it=null;
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    it=database.prefixLookup(XATTRS_INDEX,prefix,null).get();
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
 finally {
    if (it != null)     it.free();
  }
}",0.8060836501901141
113448,"public static String getRootDirName(DatabaseRO database,long rootParentId) throws BabuDBException {
  byte[] rootParentIdBytes=ByteBuffer.wrap(new byte[8]).putLong(rootParentId).array();
  Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(BabuDBStorageManager.FILE_INDEX,rootParentIdBytes,null).get();
  if (!it.hasNext())   return null;
  byte[] key=it.next().getKey();
  return new String(key,8,key.length - 9);
}","public static String getRootDirName(DatabaseRO database,long rootParentId) throws BabuDBException {
  byte[] rootParentIdBytes=ByteBuffer.wrap(new byte[8]).putLong(rootParentId).array();
  ResultSet<byte[],byte[]> it=database.prefixLookup(BabuDBStorageManager.FILE_INDEX,rootParentIdBytes,null).get();
  if (!it.hasNext())   return null;
  byte[] key=it.next().getKey();
  it.free();
  return new String(key,8,key.length - 9);
}",0.9564193168433452
113449,"@Override public byte[] getXAttr(long fileId,String uid,String key) throws DatabaseException {
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(XATTRS_INDEX,prefix,null).get();
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public byte[] getXAttr(long fileId,String uid,String key) throws DatabaseException {
  ResultSet<byte[],byte[]> it=null;
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    it=database.prefixLookup(XATTRS_INDEX,prefix,null).get();
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
 finally {
    if (it != null)     it.free();
  }
}",0.8060836501901141
113450,"@Override public short delete(final long parentId,final String fileName,final AtomicDBUpdate update) throws DatabaseException {
  try {
    BufferBackedFileMetadata file=BabuDBStorageHelper.getMetadata(database,parentId,fileName);
    short newLinkCount=(short)(file.getLinkCount() - 1);
    assert(newLinkCount >= 0);
    file.setLinkCount(newLinkCount);
    if (newLinkCount > 0)     update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),file.getRCMetadata().getValue());
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),null);
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA),null);
    if (newLinkCount == 0) {
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),(byte)3),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.FC_METADATA),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),null);
      byte[] idBytes=new byte[8];
      ByteBuffer.wrap(idBytes).putLong(file.getId());
      Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(BabuDBStorageManager.ACL_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.ACL_INDEX,it.next().getKey(),null);
      it=database.prefixLookup(BabuDBStorageManager.XATTRS_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.XATTRS_INDEX,it.next().getKey(),null);
      if (file.isDirectory()) {
        updateCount(NUM_DIRS_KEY,false,update);
      }
 else       if (file.getXLocList() != null) {
        volume.updateVolumeSize(-file.getSize(),update);
        updateCount(NUM_FILES_KEY,false,update);
      }
    }
    return file.getLinkCount();
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public short delete(final long parentId,final String fileName,final AtomicDBUpdate update) throws DatabaseException {
  try {
    BufferBackedFileMetadata file=BabuDBStorageHelper.getMetadata(database,parentId,fileName);
    short newLinkCount=(short)(file.getLinkCount() - 1);
    assert(newLinkCount >= 0);
    file.setLinkCount(newLinkCount);
    if (newLinkCount > 0)     update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),file.getRCMetadata().getValue());
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),null);
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA),null);
    if (newLinkCount == 0) {
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),(byte)3),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.FC_METADATA),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),null);
      byte[] idBytes=new byte[8];
      ByteBuffer.wrap(idBytes).putLong(file.getId());
      ResultSet<byte[],byte[]> it=database.prefixLookup(BabuDBStorageManager.ACL_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.ACL_INDEX,it.next().getKey(),null);
      it.free();
      it=database.prefixLookup(BabuDBStorageManager.XATTRS_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.XATTRS_INDEX,it.next().getKey(),null);
      it.free();
      if (file.isDirectory()) {
        updateCount(NUM_DIRS_KEY,false,update);
      }
 else       if (file.getXLocList() != null) {
        volume.updateVolumeSize(-file.getSize(),update);
        updateCount(NUM_FILES_KEY,false,update);
      }
    }
    return file.getLinkCount();
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}",0.986442262739598
113451,"public void dump() throws BabuDBException {
  System.out.println(""String_Node_Str"");
  Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(FILE_ID_INDEX,new byte[0],null).get();
  while (it.hasNext()) {
    Entry<byte[],byte[]> next=it.next();
    System.out.println(Arrays.toString(next.getKey()) + ""String_Node_Str"" + Arrays.toString(next.getValue()));
  }
  System.out.println(""String_Node_Str"");
  it=database.prefixLookup(FILE_INDEX,new byte[0],null).get();
  while (it.hasNext()) {
    Entry<byte[],byte[]> next=it.next();
    System.out.println(Arrays.toString(next.getKey()) + ""String_Node_Str"" + Arrays.toString(next.getValue()));
  }
}","public void dump() throws BabuDBException {
  System.out.println(""String_Node_Str"");
  ResultSet<byte[],byte[]> it=database.prefixLookup(FILE_ID_INDEX,new byte[0],null).get();
  while (it.hasNext()) {
    Entry<byte[],byte[]> next=it.next();
    System.out.println(Arrays.toString(next.getKey()) + ""String_Node_Str"" + Arrays.toString(next.getValue()));
  }
  it.free();
  System.out.println(""String_Node_Str"");
  it=database.prefixLookup(FILE_INDEX,new byte[0],null).get();
  while (it.hasNext()) {
    Entry<byte[],byte[]> next=it.next();
    System.out.println(Arrays.toString(next.getKey()) + ""String_Node_Str"" + Arrays.toString(next.getValue()));
  }
  it.free();
}",0.96206373292868
113452,"@Override public Collection<Long> getSnapTimestamps(String volName) throws UserException, DatabaseException {
  try {
    Collection<Long> result=new LinkedList<Long>();
    byte[] prefix=(volName + SNAPSHOT_SEPARATOR).getBytes();
    try {
      Iterator<Entry<byte[],byte[]>> it=snapVersionDB.prefixLookup(0,prefix,null).get();
      while (it.hasNext()) {
        byte[] bytes=it.next().getValue();
        long ts=ByteBuffer.wrap(bytes).getLong();
        result.add(ts);
      }
    }
 catch (    BabuDBException exc) {
      throw new DatabaseException(exc);
    }
    return result;
  }
 catch (  DatabaseException exc) {
    if (((BabuDBException)exc.getCause()).getErrorCode() == ErrorCode.SNAP_EXISTS)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,exc.getMessage());
 else     throw exc;
  }
}","@Override public Collection<Long> getSnapTimestamps(String volName) throws UserException, DatabaseException {
  try {
    Collection<Long> result=new LinkedList<Long>();
    byte[] prefix=(volName + SNAPSHOT_SEPARATOR).getBytes();
    ResultSet<byte[],byte[]> it=null;
    try {
      it=snapVersionDB.prefixLookup(0,prefix,null).get();
      while (it.hasNext()) {
        byte[] bytes=it.next().getValue();
        long ts=ByteBuffer.wrap(bytes).getLong();
        result.add(ts);
      }
    }
 catch (    BabuDBException exc) {
      throw new DatabaseException(exc);
    }
 finally {
      if (it != null)       it.free();
    }
    return result;
  }
 catch (  DatabaseException exc) {
    if (((BabuDBException)exc.getCause()).getErrorCode() == ErrorCode.SNAP_EXISTS)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,exc.getMessage());
 else     throw exc;
  }
}",0.930810171496156
113453,"public void registerListener(RPCResponseAvailableListener<V> listener){
  this.listener=listener;
synchronized (this) {
    if (request != null || failed) {
      listener.responseAvailable(this);
    }
  }
}","public void registerListener(RPCResponseAvailableListener<V> listener){
synchronized (this) {
    this.listener=listener;
    if (request != null || failed) {
      listener.responseAvailable(this);
    }
  }
}",0.8899521531100478
113454,"@Override public short delete(final long parentId,final String fileName,final AtomicDBUpdate update) throws DatabaseException {
  try {
    BufferBackedFileMetadata file=BabuDBStorageHelper.getMetadata(database,parentId,fileName);
    short newLinkCount=(short)(file.getLinkCount() - 1);
    assert(newLinkCount >= 0);
    file.setLinkCount(newLinkCount);
    if (newLinkCount > 0)     update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),file.getRCMetadata().getValue());
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),null);
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA),null);
    if (newLinkCount == 0) {
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),(byte)3),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.FC_METADATA),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),null);
      byte[] idBytes=new byte[8];
      ByteBuffer.wrap(idBytes).putLong(file.getId());
      Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(BabuDBStorageManager.ACL_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.ACL_INDEX,it.next().getKey(),null);
      it=database.prefixLookup(BabuDBStorageManager.XATTRS_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.XATTRS_INDEX,it.next().getKey(),null);
      if (file.isDirectory())       updateCount(NUM_DIRS_KEY,false,update);
 else {
        volume.updateVolumeSize(-file.getSize(),update);
        updateCount(NUM_FILES_KEY,false,update);
      }
    }
    return file.getLinkCount();
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public short delete(final long parentId,final String fileName,final AtomicDBUpdate update) throws DatabaseException {
  try {
    BufferBackedFileMetadata file=BabuDBStorageHelper.getMetadata(database,parentId,fileName);
    short newLinkCount=(short)(file.getLinkCount() - 1);
    assert(newLinkCount >= 0);
    file.setLinkCount(newLinkCount);
    if (newLinkCount > 0)     update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),file.getRCMetadata().getValue());
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),null);
    update.addUpdate(BabuDBStorageManager.FILE_INDEX,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA),null);
    if (newLinkCount == 0) {
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),(byte)3),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.FC_METADATA),null);
      update.addUpdate(BabuDBStorageManager.FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(file.getId(),FileMetadata.RC_METADATA),null);
      byte[] idBytes=new byte[8];
      ByteBuffer.wrap(idBytes).putLong(file.getId());
      Iterator<Entry<byte[],byte[]>> it=database.prefixLookup(BabuDBStorageManager.ACL_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.ACL_INDEX,it.next().getKey(),null);
      it=database.prefixLookup(BabuDBStorageManager.XATTRS_INDEX,idBytes,null).get();
      while (it.hasNext())       update.addUpdate(BabuDBStorageManager.XATTRS_INDEX,it.next().getKey(),null);
      if (file.getXLocList() != null) {
        if (file.isDirectory())         updateCount(NUM_DIRS_KEY,false,update);
 else {
          volume.updateVolumeSize(-file.getSize(),update);
          updateCount(NUM_FILES_KEY,false,update);
        }
      }
    }
    return file.getLinkCount();
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}",0.9833650190114068
113455,"public BufferBackedXLocList getXLocList(){
  if (cachedXLocList == null) {
    byte[] bytes=valBuf.array();
    int index=valBuf.getShort(RC_XLOC_OFFSET);
    if (bytes.length - index > 0)     cachedXLocList=new BufferBackedXLocList(bytes,index,bytes.length - index);
  }
  return cachedXLocList;
}","public BufferBackedXLocList getXLocList(){
  if (directory)   return null;
  if (cachedXLocList == null) {
    byte[] bytes=valBuf.array();
    int index=valBuf.getShort(RC_XLOC_OFFSET);
    assert(bytes.length - index >= 0);
    if (bytes.length - index != 0)     cachedXLocList=new BufferBackedXLocList(bytes,index,bytes.length - index);
  }
  return cachedXLocList;
}",0.8832335329341318
113456,"@Override public void updateACLEntries(StorageManager sMan,FileMetadata file,long parentId,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  DatabaseResultSet<ACLEntry> acl=null;
  try {
    Map<String,Object> aclMap=null;
    acl=sMan.getACL(file.getId());
    if (!acl.hasNext())     aclMap=convertToACL(file.getPerms());
 else {
      aclMap=new HashMap<String,Object>();
      while (acl.hasNext()) {
        ACLEntry next=acl.next();
        aclMap.put(next.getEntity(),next.getRights());
      }
    }
    for (    Entry<String,Object> entry : entries.entrySet()) {
      String entity=entry.getKey();
      String rwx=(String)entry.getValue();
      if (rwx != null) {
        int rights=0;
        if (rwx.length() == 1 && rwx.charAt(0) >= '0' && rwx.charAt(0) <= '7')         rights=Integer.parseInt(rwx,8);
 else {
          if (rwx.indexOf('r') != -1)           rights|=PERM_READ;
          if (rwx.indexOf('w') != -1)           rights|=PERM_WRITE;
          if (rwx.indexOf('x') != -1)           rights|=PERM_EXECUTE;
        }
        aclMap.put(entity,rights);
      }
 else       aclMap.put(entity,null);
    }
    for (    Entry<String,Object> entry : aclMap.entrySet()) {
      Number rights=(Number)entry.getValue();
      sMan.setACLEntry(file.getId(),entry.getKey(),rights == null ? null : rights.shortValue(),update);
    }
    int owner=((Number)aclMap.get(OWNER)).intValue();
    Integer group=aclMap.get(MASK) != null ? ((Number)aclMap.get(MASK)).intValue() : null;
    if (group == null)     group=((Number)aclMap.get(OWNER_GROUP)).intValue();
    int other=((Number)aclMap.get(OTHER)).intValue();
    int posixRights=((owner & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | (file.getPerms() & POSIX_STICKY)| ((owner & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0);
    file.setPerms(posixRights);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
 finally {
    if (acl != null)     acl.destroy();
  }
}","@Override public void updateACLEntries(StorageManager sMan,FileMetadata file,long parentId,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  DatabaseResultSet<ACLEntry> acl=null;
  try {
    Map<String,Object> aclMap=null;
    acl=sMan.getACL(file.getId());
    if (!acl.hasNext())     aclMap=convertToACL(file.getPerms());
 else {
      aclMap=new HashMap<String,Object>();
      while (acl.hasNext()) {
        ACLEntry next=acl.next();
        aclMap.put(next.getEntity(),next.getRights());
      }
    }
    for (    Entry<String,Object> entry : entries.entrySet()) {
      String entity=entry.getKey();
      String rwx=(String)entry.getValue();
      if (rwx != null) {
        int rights=0;
        if (rwx.length() == 1 && rwx.charAt(0) >= '0' && rwx.charAt(0) <= '7') {
          rights=Integer.parseInt(rwx,8);
          int tmp=((rights >> 3) ^ (rights >> 1)) & 1;
          rights=rights ^ ((tmp << 3) | (tmp << 1));
        }
 else {
          if (rwx.indexOf('r') != -1)           rights|=PERM_READ;
          if (rwx.indexOf('w') != -1)           rights|=PERM_WRITE;
          if (rwx.indexOf('x') != -1)           rights|=PERM_EXECUTE;
        }
        aclMap.put(entity,rights);
      }
 else       aclMap.put(entity,null);
    }
    for (    Entry<String,Object> entry : aclMap.entrySet()) {
      Number rights=(Number)entry.getValue();
      sMan.setACLEntry(file.getId(),entry.getKey(),rights == null ? null : rights.shortValue(),update);
    }
    int owner=((Number)aclMap.get(OWNER)).intValue();
    Integer group=aclMap.get(MASK) != null ? ((Number)aclMap.get(MASK)).intValue() : null;
    if (group == null)     group=((Number)aclMap.get(OWNER_GROUP)).intValue();
    int other=((Number)aclMap.get(OTHER)).intValue();
    int posixRights=((owner & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | (file.getPerms() & POSIX_STICKY)| ((owner & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0);
    file.setPerms(posixRights);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
 finally {
    if (acl != null)     acl.destroy();
  }
}",0.9761532447224394
113457,"@Override public Map<String,Object> getACLEntries(StorageManager sMan,FileMetadata file) throws MRCException {
  try {
    DatabaseResultSet<ACLEntry> acl=sMan.getACL(file.getId());
    Map<String,Object> aclMap=Converter.aclToMap(acl);
    acl.destroy();
    return aclMap;
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","@Override public Map<String,Object> getACLEntries(StorageManager sMan,FileMetadata file) throws MRCException {
  try {
    DatabaseResultSet<ACLEntry> acl=sMan.getACL(file.getId());
    Map<String,Object> aclMap=Converter.aclToMap(acl,this);
    acl.destroy();
    return aclMap;
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.9927849927849928
113458,"/** 
 * Converts an <code>ACLEntry</code> iterator to a mapping: userID:String -> rights:Long.
 * @param acl
 * @return
 */
public static Map<String,Object> aclToMap(Iterator<ACLEntry> acl){
  if (acl == null)   return null;
  Map<String,Object> aclMap=new HashMap<String,Object>();
  while (acl.hasNext()) {
    ACLEntry next=acl.next();
    aclMap.put(next.getEntity(),(long)next.getRights());
  }
  return aclMap;
}","/** 
 * Converts an <code>ACLEntry</code> iterator to a mapping: userID:String -> rights:Long.
 * @param acl
 * @return
 */
public static Map<String,Object> aclToMap(Iterator<ACLEntry> acl,FileAccessPolicy policy){
  if (acl == null)   return null;
  Map<String,Object> aclMap=new HashMap<String,Object>();
  while (acl.hasNext()) {
    ACLEntry next=acl.next();
    aclMap.put(next.getEntity(),policy.translatePermissions(next.getRights()));
  }
  return aclMap;
}",0.9331823329558324
113459,"private String retrieveOSDUuidAndSetItInWriteBuffer(AsyncWriteBuffer writeBuffer){
  String osdUuid;
  if (writeBuffer.isUsingUuidIterator()) {
    osdUuid=uuidIterator.getUUID();
    writeBuffer.setOsdUuid(osdUuid);
  }
 else {
    osdUuid=writeBuffer.getOsdUuid();
  }
  return osdUuid;
}","private String retrieveOSDUuidAndSetItInWriteBuffer(AsyncWriteBuffer writeBuffer) throws UUIDIteratorListIsEmpyException {
  String osdUuid;
  if (writeBuffer.isUsingUuidIterator()) {
    osdUuid=uuidIterator.getUUID();
    writeBuffer.setOsdUuid(osdUuid);
  }
 else {
    osdUuid=writeBuffer.getOsdUuid();
  }
  return osdUuid;
}",0.935483870967742
113460,"/** 
 * Adds writeBuffer to the list of pending writes and sends it to the OSD specified by writeBuffer.uuidIterator (or write_buffer.osdUuid if writeBuffer.useUuidIterator is false). Blocks if the number of pending bytes exceeds the maximum write-ahead or waitForPendingWrites() was called beforehand.
 */
protected void write(AsyncWriteBuffer writeBuffer) throws AddressToUUIDNotFoundException {
  assert(writeBuffer != null);
  if (writeBuffer.getDataLength() > maxWriteahead) {
    throw new XtreemFSException(""String_Node_Str"" + maxWriteahead + ""String_Node_Str""+ writeBuffer.getDataLength());
  }
synchronized (this) {
    while (writingPaused || (pendingBytes + writeBuffer.getDataLength()) > maxWriteahead || writesInFlight.size() == maxWriteaheadRequests) {
      try {
        this.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    increasePendingBytesHelper(writeBuffer);
  }
  String osdUuid=retrieveOSDUuidAndSetItInWriteBuffer(writeBuffer);
  String osdAddress=uuidResolver.uuidToAddress(osdUuid);
  InetSocketAddress osdInetSocketAddress=Helper.stringToInetSocketAddress(osdAddress,GlobalTypes.PORTS.OSD_PBRPC_PORT_DEFAULT.getNumber());
  final AsyncWriteBuffer finalWriteBufferForCallback=writeBuffer;
  RPCResponse<OSDWriteResponse> response;
  try {
    response=osdServiceClient.write(osdInetSocketAddress,authBogus,userCredentialsBogus,writeBuffer.getWriteRequest(),ReusableBuffer.wrap(writeBuffer.getData()));
    response.registerListener(new RPCResponseAvailableListener<OSDWriteResponse>(){
      @Override public void responseAvailable(      RPCResponse<OSDWriteResponse> r){
        try {
          OSDWriteResponse osdWriteResponse=r.get();
          writeFinished(osdWriteResponse,r.getData(),finalWriteBufferForCallback);
        }
 catch (        PBRPCException e) {
          String errorTypeName=e.getErrorType().toString();
          EnumValueDescriptor enumDescriptor=ErrorType.getDescriptor().findValueByNumber(e.getErrorType().getNumber());
          if (enumDescriptor != null) {
            errorTypeName=enumDescriptor.getName();
          }
          Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",finalWriteBufferForCallback.getOsdUuid(),errorTypeName,e.getErrorMessage(),e.getDebugInfo());
          System.out.println(""String_Node_Str"" + this.toString());
          decreasePendingBytesHelper(finalWriteBufferForCallback);
        }
catch (        Exception e) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",e.getMessage());
          decreasePendingBytesHelper(finalWriteBufferForCallback);
        }
 finally {
          r.freeBuffers();
        }
      }
    }
);
  }
 catch (  IOException e1) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",e1.getMessage());
    decreasePendingBytesHelper(finalWriteBufferForCallback);
  }
}","/** 
 * Adds writeBuffer to the list of pending writes and sends it to the OSD specified by writeBuffer.uuidIterator (or write_buffer.osdUuid if writeBuffer.useUuidIterator is false). Blocks if the number of pending bytes exceeds the maximum write-ahead or waitForPendingWrites() was called beforehand.
 */
protected void write(AsyncWriteBuffer writeBuffer) throws AddressToUUIDNotFoundException, XtreemFSException {
  assert(writeBuffer != null);
  if (writeBuffer.getDataLength() > maxWriteahead) {
    throw new XtreemFSException(""String_Node_Str"" + maxWriteahead + ""String_Node_Str""+ writeBuffer.getDataLength());
  }
synchronized (this) {
    while (writingPaused || (pendingBytes + writeBuffer.getDataLength()) > maxWriteahead || writesInFlight.size() == maxWriteaheadRequests) {
      try {
        this.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    increasePendingBytesHelper(writeBuffer);
  }
  String osdUuid=retrieveOSDUuidAndSetItInWriteBuffer(writeBuffer);
  String osdAddress=uuidResolver.uuidToAddress(osdUuid);
  InetSocketAddress osdInetSocketAddress=Helper.stringToInetSocketAddress(osdAddress,GlobalTypes.PORTS.OSD_PBRPC_PORT_DEFAULT.getNumber());
  final AsyncWriteBuffer finalWriteBufferForCallback=writeBuffer;
  RPCResponse<OSDWriteResponse> response;
  try {
    response=osdServiceClient.write(osdInetSocketAddress,authBogus,userCredentialsBogus,writeBuffer.getWriteRequest(),ReusableBuffer.wrap(writeBuffer.getData()));
    response.registerListener(new RPCResponseAvailableListener<OSDWriteResponse>(){
      @Override public void responseAvailable(      RPCResponse<OSDWriteResponse> r){
        try {
          OSDWriteResponse osdWriteResponse=r.get();
          writeFinished(osdWriteResponse,r.getData(),finalWriteBufferForCallback);
        }
 catch (        PBRPCException e) {
          String errorTypeName=e.getErrorType().toString();
          EnumValueDescriptor enumDescriptor=ErrorType.getDescriptor().findValueByNumber(e.getErrorType().getNumber());
          if (enumDescriptor != null) {
            errorTypeName=enumDescriptor.getName();
          }
          Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",finalWriteBufferForCallback.getOsdUuid(),errorTypeName,e.getErrorMessage(),e.getDebugInfo());
          System.out.println(""String_Node_Str"" + this.toString());
          decreasePendingBytesHelper(finalWriteBufferForCallback);
        }
catch (        Exception e) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",e.getMessage());
          decreasePendingBytesHelper(finalWriteBufferForCallback);
        }
 finally {
          r.freeBuffers();
        }
      }
    }
);
  }
 catch (  IOException e1) {
    Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"" + ""String_Node_Str"",e1.getMessage());
    decreasePendingBytesHelper(finalWriteBufferForCallback);
  }
}",0.9968008082168716
113461,"/** 
 * Calls asyncWriteHandler.write().
 */
void asyncWrite(AsyncWriteBuffer writeBuffer) throws AddressToUUIDNotFoundException {
  asyncWriteHandler.write(writeBuffer);
}","/** 
 * Calls asyncWriteHandler.write().
 */
void asyncWrite(AsyncWriteBuffer writeBuffer) throws XtreemFSException {
  asyncWriteHandler.write(writeBuffer);
}",0.9305135951661632
113462,"@Override public void run(){
  while (!isInterrupted()) {
    try {
      Thread.sleep(volume.getOptions().getPeriodicFileSizeUpdatesIntervalS() * 1000);
    }
 catch (    InterruptedException e) {
      break;
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volume.getOpenFileTable().size());
    }
    for (    Entry<Long,FileInfo> entry : volume.getOpenFileTable().entrySet()) {
      try {
        entry.getValue().writeBackFileSizeAsync();
      }
 catch (      IOException e) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",e.getMessage());
        }
      }
catch (      AddressToUUIDNotFoundException e) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",e.getMessage());
        }
      }
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volume.getOpenFileTable().size());
    }
  }
}","@Override public void run(){
  while (!isInterrupted()) {
    try {
      Thread.sleep(volume.getOptions().getPeriodicFileSizeUpdatesIntervalS() * 1000);
    }
 catch (    InterruptedException e) {
      break;
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volume.getOpenFileTable().size());
    }
    for (    Entry<Long,FileInfo> entry : volume.getOpenFileTable().entrySet()) {
      try {
        entry.getValue().writeBackFileSizeAsync();
      }
 catch (      IOException e) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",e.getMessage());
        }
      }
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",volume.getOpenFileTable().size());
    }
  }
}",0.833762223365929
113463,"/** 
 * Appends the list of requested directory entries to ""dirEntries"". There does not exist something like openDir and closeDir. Instead one can limit the number of requested entries (count) and specify the offset.  {@link DirectoryEntries} will contain the names of the entries and, if not disabled by ""namesOnly"", a{@link Stat} object for every entry.
 * @param userCredentials Name and Groups of the user.
 * @param path Path to the directory.
 * @param offset Index of first requested entry.
 * @param count Number of requested entries.
 * @param namesOnly If set to true, the  {@link Stat} object of every entry will be omitted.
 * @throws AddressToUUIDNotFoundException
 * @throws {@link IOException}
 * @throws PosixErrorException
 * @throws UnknownAddressSchemeException
 * @remark Ownership is transferred to the caller.
 */
public abstract DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException ;","/** 
 * Returns a list of ""count"" directories/files contained in the directory ""path"" beginning by ""offset"". If count equals 0 all entries beginning by ""offset"" will be in the list.
 * @param userCredentials Name and Groups of the user.
 * @param path Path to the directory.
 * @param offset Index of first requested entry.
 * @param count Number of requested entries.
 * @param namesOnly If set to true, the  {@link Stat} object of every entry will be omitted.
 * @return {@link DirectoryEntries} will contain the names of the entries and, if not disabled by""namesOnly"", a  {@link Stat} object for every entry.
 * @throws AddressToUUIDNotFoundException
 * @throws {@link IOException}
 * @throws PosixErrorException
 * @throws UnknownAddressSchemeException
 */
public abstract DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException ;",0.4947315604616156
113464,"@Override public DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  DirectoryEntries result=null;
  result=metadataCache.getDirEntries(path,offset,count);
  if (result != null) {
    return result;
  }
  DirectoryEntries.Builder dirEntriesBuilder=DirectoryEntries.newBuilder();
  for (int currentOffset=offset; currentOffset < offset + count; offset+=volumeOptions.getReaddirChunkSize()) {
    int limitDirEntriesCount=(currentOffset > offset + count) ? (currentOffset - offset - count) : volumeOptions.getReaddirChunkSize();
    readdirRequest request=readdirRequest.newBuilder().setPath(path).setVolumeName(volumeName).setNamesOnly(namesOnly).setKnownEtag(0).setSeenDirectoryEntriesCount(currentOffset).setLimitDirectoryEntriesCount(limitDirEntriesCount).build();
    result=RPCCaller.<readdirRequest,DirectoryEntries>syncCall(SERVICES.MRC,userCredentials,authBogus,volumeOptions,uuidResolver,mrcUUIDIterator,false,request,new CallGenerator<readdirRequest,DirectoryEntries>(){
      @Override public RPCResponse<DirectoryEntries> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      readdirRequest input) throws IOException {
        return mrcServiceClient.readdir(server,authHeader,userCreds,input);
      }
    }
);
    assert(result != null);
    dirEntriesBuilder.addAllEntries(result.getEntriesList());
    if (result.getEntriesCount() < (currentOffset + volumeOptions.getReaddirChunkSize())) {
      break;
    }
  }
  int minimum=(volumeOptions.getMetadataCacheSize() > result.getEntriesCount()) ? result.getEntriesCount() : volumeOptions.getMetadataCacheSize();
  for (int i=0; i < minimum; i++) {
    if (result.getEntries(i).hasStbuf()) {
      if (result.getEntries(i).getStbuf().getNlink() > 1) {
        metadataCache.invalidate(path);
      }
 else {
        metadataCache.updateStat(Helper.concatenatePath(path,result.getEntries(i).getName()),result.getEntries(i).getStbuf());
      }
    }
  }
  if (!namesOnly && offset == 0 && result.getEntriesCount() < count) {
    metadataCache.updateDirEntries(path,result);
  }
  return dirEntriesBuilder.build();
}","@Override public DirectoryEntries readDir(UserCredentials userCredentials,String path,int offset,int count,boolean namesOnly) throws IOException, PosixErrorException, AddressToUUIDNotFoundException {
  DirectoryEntries result=null;
  if (count == 0) {
    count=Integer.MAX_VALUE - offset - 1;
  }
  result=metadataCache.getDirEntries(path,offset,count);
  if (result != null) {
    return result;
  }
  DirectoryEntries.Builder dirEntriesBuilder=DirectoryEntries.newBuilder();
  for (int currentOffset=offset; currentOffset < offset + count; offset+=volumeOptions.getReaddirChunkSize()) {
    int limitDirEntriesCount=(currentOffset > offset + count) ? (currentOffset - offset - count) : volumeOptions.getReaddirChunkSize();
    readdirRequest request=readdirRequest.newBuilder().setPath(path).setVolumeName(volumeName).setNamesOnly(namesOnly).setKnownEtag(0).setSeenDirectoryEntriesCount(currentOffset).setLimitDirectoryEntriesCount(limitDirEntriesCount).build();
    result=RPCCaller.<readdirRequest,DirectoryEntries>syncCall(SERVICES.MRC,userCredentials,authBogus,volumeOptions,uuidResolver,mrcUUIDIterator,false,request,new CallGenerator<readdirRequest,DirectoryEntries>(){
      @Override public RPCResponse<DirectoryEntries> executeCall(      InetSocketAddress server,      Auth authHeader,      UserCredentials userCreds,      readdirRequest input) throws IOException {
        return mrcServiceClient.readdir(server,authHeader,userCreds,input);
      }
    }
);
    assert(result != null);
    dirEntriesBuilder.addAllEntries(result.getEntriesList());
    if (result.getEntriesCount() < (currentOffset + volumeOptions.getReaddirChunkSize())) {
      break;
    }
  }
  int minimum=(volumeOptions.getMetadataCacheSize() > dirEntriesBuilder.getEntriesCount()) ? dirEntriesBuilder.getEntriesCount() : volumeOptions.getMetadataCacheSize();
  for (int i=0; i < minimum; i++) {
    if (dirEntriesBuilder.getEntries(i).hasStbuf()) {
      if (dirEntriesBuilder.getEntries(i).getStbuf().getNlink() > 1) {
        metadataCache.invalidate(path);
      }
 else {
        metadataCache.updateStat(Helper.concatenatePath(path,dirEntriesBuilder.getEntries(i).getName()),dirEntriesBuilder.getEntries(i).getStbuf());
      }
    }
  }
  if (!namesOnly && offset == 0 && dirEntriesBuilder.getEntriesCount() < count) {
    metadataCache.updateDirEntries(path,result);
  }
  return dirEntriesBuilder.build();
}",0.9512770980897188
113465,"public void localWrite(final OSDRequest rq,final xtreemfs_rwr_updateRequest args){
  master.replicatedDataReceived(rq.getRPCRequest().getData().capacity());
  master.getStorageStage().writeObject(args.getFileId(),args.getObjectNumber(),rq.getLocationList().getLocalReplica().getStripingPolicy(),args.getOffset(),rq.getRPCRequest().getData(),CowPolicy.PolicyNoCow,rq.getLocationList(),false,args.getObjectVersion(),rq,null,new WriteObjectCallback(){
    @Override public void writeComplete(    OSDWriteResponse result,    ErrorResponse error){
      sendResult(rq,error);
    }
  }
);
}","public void localWrite(final OSDRequest rq,final xtreemfs_rwr_updateRequest args){
  master.replicatedDataReceived(rq.getRPCRequest().getData().capacity());
  ReusableBuffer viewBuffer=rq.getRPCRequest().getData().createViewBuffer();
  master.getStorageStage().writeObject(args.getFileId(),args.getObjectNumber(),rq.getLocationList().getLocalReplica().getStripingPolicy(),args.getOffset(),viewBuffer,CowPolicy.PolicyNoCow,rq.getLocationList(),false,args.getObjectVersion(),rq,viewBuffer,new WriteObjectCallback(){
    @Override public void writeComplete(    OSDWriteResponse result,    ErrorResponse error){
      sendResult(rq,error);
    }
  }
);
}",0.6931174089068826
113466,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final listxattrRequest rqArgs=(listxattrRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  Map<String,byte[]> attrs=new HashMap<String,byte[]>();
  DatabaseResultSet<XAttr> myAttrs=sMan.getXAttrs(file.getId(),rq.getDetails().userId);
  DatabaseResultSet<XAttr> globalAttrs=sMan.getXAttrs(file.getId(),StorageManager.GLOBAL_ID);
  while (globalAttrs.hasNext()) {
    XAttr attr=globalAttrs.next();
    attrs.put(attr.getKey(),attr.getValue());
  }
  globalAttrs.destroy();
  while (myAttrs.hasNext()) {
    XAttr attr=myAttrs.next();
    attrs.put(attr.getKey(),attr.getValue());
  }
  myAttrs.destroy();
  for (  SysAttrs attr : SysAttrs.values()) {
    String key=""String_Node_Str"" + attr.toString();
    String value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),faMan,res.toString(),file,attr.toString());
    if (!value.equals(""String_Node_Str""))     attrs.put(key,value.getBytes());
  }
  List<String> policyAttrNames=MRCHelper.getSpecialAttrNames(sMan,file.getId(),MRCHelper.POLICY_ATTR_PREFIX);
  for (  String attr : policyAttrNames)   attrs.put(attr,new byte[0]);
  List<String> volAttrAttrNames=MRCHelper.getSpecialAttrNames(sMan,file.getId(),MRCHelper.VOL_ATTR_PREFIX);
  for (  String attr : volAttrAttrNames)   attrs.put(attr,new byte[0]);
  listxattrResponse.Builder result=listxattrResponse.newBuilder();
  Iterator<Entry<String,byte[]>> it=attrs.entrySet().iterator();
  while (it.hasNext()) {
    Entry<String,byte[]> attr=it.next();
    org.xtreemfs.pbrpc.generatedinterfaces.MRC.XAttr.Builder builder=org.xtreemfs.pbrpc.generatedinterfaces.MRC.XAttr.newBuilder().setName(attr.getKey());
    if (!rqArgs.getNamesOnly())     builder.setValue(new String(attr.getValue())).setValueBytes(ByteString.copyFrom(attr.getValue()));
    result.addXattrs(builder.build());
  }
  rq.setResponse(result.build());
  finishRequest(rq);
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final listxattrRequest rqArgs=(listxattrRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  Map<String,byte[]> attrs=new HashMap<String,byte[]>();
  DatabaseResultSet<XAttr> myAttrs=sMan.getXAttrs(file.getId(),rq.getDetails().userId);
  DatabaseResultSet<XAttr> globalAttrs=sMan.getXAttrs(file.getId(),StorageManager.GLOBAL_ID);
  while (globalAttrs.hasNext()) {
    XAttr attr=globalAttrs.next();
    attrs.put(attr.getKey(),attr.getValue());
  }
  globalAttrs.destroy();
  while (myAttrs.hasNext()) {
    XAttr attr=myAttrs.next();
    attrs.put(attr.getKey(),attr.getValue());
  }
  myAttrs.destroy();
  for (  SysAttrs attr : SysAttrs.values()) {
    String key=""String_Node_Str"" + attr.toString();
    String value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),faMan,res.toString(),file,attr.toString());
    if (!value.equals(""String_Node_Str""))     attrs.put(key,value.getBytes());
  }
  if (file.getId() == 1) {
    List<String> policyAttrNames=MRCHelper.getSpecialAttrNames(sMan,MRCHelper.POLICY_ATTR_PREFIX);
    for (    String attr : policyAttrNames)     attrs.put(attr,sMan.getXAttr(1,StorageManager.SYSTEM_UID,attr));
    List<String> volAttrAttrNames=MRCHelper.getSpecialAttrNames(sMan,MRCHelper.VOL_ATTR_PREFIX);
    for (    String attr : volAttrAttrNames)     attrs.put(attr,sMan.getXAttr(1,StorageManager.SYSTEM_UID,attr));
  }
  listxattrResponse.Builder result=listxattrResponse.newBuilder();
  for (  Entry<String,byte[]> attr : attrs.entrySet()) {
    org.xtreemfs.pbrpc.generatedinterfaces.MRC.XAttr.Builder builder=org.xtreemfs.pbrpc.generatedinterfaces.MRC.XAttr.newBuilder().setName(attr.getKey());
    if (!rqArgs.getNamesOnly())     builder.setValue(new String(attr.getValue())).setValueBytes(ByteString.copyFrom(attr.getValue()));
    result.addXattrs(builder.build());
  }
  rq.setResponse(result.build());
  finishRequest(rq);
}",0.9198764160659114
113467,"public static List<String> getSpecialAttrNames(StorageManager sMan,long fileId,String namePrefix) throws DatabaseException {
  final String prefix=""String_Node_Str"" + namePrefix;
  final List<String> result=new LinkedList<String>();
  if (fileId != 1)   return result;
  DatabaseResultSet<XAttr> it=sMan.getXAttrs(1,StorageManager.SYSTEM_UID);
  while (it.hasNext()) {
    XAttr attr=it.next();
    if (attr.getKey().startsWith(prefix))     result.add(attr.getKey());
  }
  it.destroy();
  return result;
}","public static List<String> getSpecialAttrNames(StorageManager sMan,String namePrefix) throws DatabaseException {
  final String prefix=""String_Node_Str"" + namePrefix;
  final List<String> result=new LinkedList<String>();
  DatabaseResultSet<XAttr> it=sMan.getXAttrs(1,StorageManager.SYSTEM_UID);
  while (it.hasNext()) {
    XAttr attr=it.next();
    if (attr.getKey().startsWith(prefix))     result.add(attr.getKey());
  }
  it.destroy();
  return result;
}",0.950207468879668
113468,"@Override public void startRequest(final OSDRequest rq){
  final truncateRequest args=(truncateRequest)rq.getRequestArgs();
  if (args.getNewFileSize() < 0) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
    return;
  }
  if (!rq.getLocationList().getLocalReplica().getHeadOsd().equals(localUUID)) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
    return;
  }
  if (rq.getLocationList().getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY)) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  }
  if ((rq.getLocationList().getReplicaUpdatePolicy().length() == 0) || (rq.getLocationList().getNumReplicas() == 1)) {
    master.getStorageStage().truncate(args.getFileId(),args.getNewFileSize(),rq.getLocationList().getLocalReplica().getStripingPolicy(),rq.getLocationList().getLocalReplica(),rq.getCapability().getEpochNo(),rq.getCowPolicy(),null,false,rq,new TruncateCallback(){
      @Override public void truncateComplete(      OSDWriteResponse result,      ErrorResponse error){
        step2(rq,args,result,error);
      }
    }
);
  }
 else {
    rwReplicatedTruncate(rq,args);
  }
}","@Override public void startRequest(final OSDRequest rq){
  final truncateRequest args=(truncateRequest)rq.getRequestArgs();
  if (args.getNewFileSize() < 0) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
    return;
  }
  if (!rq.getLocationList().getLocalReplica().getHeadOsd().equals(localUUID)) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
    return;
  }
  if (rq.getLocationList().getReplicaUpdatePolicy().equals(ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY)) {
    rq.sendError(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    return;
  }
  if ((rq.getLocationList().getReplicaUpdatePolicy().length() == 0) || (rq.getLocationList().getNumReplicas() == 1)) {
    master.getStorageStage().truncate(args.getFileId(),args.getNewFileSize(),rq.getLocationList().getLocalReplica().getStripingPolicy(),rq.getLocationList().getLocalReplica(),rq.getCapability().getEpochNo(),rq.getCowPolicy(),null,false,rq,new TruncateCallback(){
      @Override public void truncateComplete(      OSDWriteResponse result,      ErrorResponse error){
        step2(rq,args,result,error);
      }
    }
);
  }
 else {
    rwReplicatedTruncate(rq,args);
  }
}",0.99510603588907
113469,"private ErrorResponse processAuthenticate(OSDRequest rq){
  final Capability rqCap=rq.getCapability();
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",rqCap.getXCap().toString().replace('\n','/'));
  }
  if (rqCap.getFileId().length() == 0) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  if (rqCap.getEpochNo() < 0) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  if (ignoreCaps)   return null;
  if (!rqCap.getFileId().equals(rq.getFileId())) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
  }
  boolean isValid=false;
  LRUCache<String,Capability> cachedCaps=capCache.get(rqCap.getFileId());
  if (cachedCaps != null) {
    final Capability cap=cachedCaps.get(rqCap.getSignature());
    if (cap != null) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cap.getFileId(),cap.getSignature());
      }
      isValid=!cap.hasExpired();
    }
  }
  if (!isValid) {
    isValid=rqCap.isValid();
    if (isValid) {
      if (cachedCaps == null) {
        cachedCaps=new LRUCache<String,Capability>(MAX_CAP_CACHE);
        capCache.put(rqCap.getFileId(),cachedCaps);
      }
      cachedCaps.put(rqCap.getSignature(),rqCap);
    }
  }
  if (!isValid) {
    if (rqCap.hasExpired())     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
    if (!rqCap.hasValidSignature())     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
  }
  return null;
}","private ErrorResponse processAuthenticate(OSDRequest rq){
  final Capability rqCap=rq.getCapability();
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",rqCap.getXCap().toString().replace('\n','/'));
  }
  if (rqCap.getFileId().length() == 0) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  if (rqCap.getEpochNo() < 0) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  }
  if (ignoreCaps)   return null;
  boolean isValid=false;
  LRUCache<String,Capability> cachedCaps=capCache.get(rqCap.getFileId());
  if (cachedCaps != null) {
    final Capability cap=cachedCaps.get(rqCap.getSignature());
    if (cap != null) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cap.getFileId(),cap.getSignature());
      }
      isValid=!cap.hasExpired();
    }
  }
  if (!isValid) {
    isValid=rqCap.isValid();
    if (isValid) {
      if (cachedCaps == null) {
        cachedCaps=new LRUCache<String,Capability>(MAX_CAP_CACHE);
        capCache.put(rqCap.getFileId(),cachedCaps);
      }
      cachedCaps.put(rqCap.getSignature(),rqCap);
    }
  }
  if (!isValid) {
    if (rqCap.hasExpired())     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
    if (!rqCap.hasValidSignature())     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
  }
  if (!rqCap.getFileId().equals(rq.getFileId())) {
    return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"");
  }
  if (rq.getOperation().getProcedureId() == OSDServiceConstants.PROC_ID_READ) {
    if ((rqCap.getAccessMode() & (SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber())) != 0)     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"" + rqCap.getFileId());
  }
 else   if (rq.getOperation().getProcedureId() == OSDServiceConstants.PROC_ID_WRITE) {
    if ((rqCap.getAccessMode() & (SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_CREAT.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_WRONLY.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber())) == 0)     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"" + rqCap.getFileId());
  }
 else   if (rq.getOperation().getProcedureId() == OSDServiceConstants.PROC_ID_TRUNCATE) {
    if ((rqCap.getAccessMode() & SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber()) == 0)     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"" + rqCap.getFileId());
  }
 else   if (rq.getOperation().getProcedureId() == OSDServiceConstants.PROC_ID_UNLINK) {
    if ((rqCap.getAccessMode() & 010000000) == 0)     return ErrorUtils.getErrorResponse(ErrorType.ERRNO,POSIXErrno.POSIX_ERROR_EACCES,""String_Node_Str"" + rqCap.getFileId());
  }
  return null;
}",0.6696177062374246
113470,"public OSDDataIntegrityTest(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}","public OSDDataIntegrityTest(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}",0.9676601141407736
113471,"public OSDRangeReads(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}","public OSDRangeReads(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}",0.9673704414587332
113472,"public OSDTruncateTest(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}","public OSDTruncateTest(String testName) throws Exception {
  super(testName);
  Logging.start(Logging.LEVEL_DEBUG);
  osdConfig=SetupUtils.createOSD1Config();
  serverID=SetupUtils.getOSD1UUID();
  fileId=""String_Node_Str"";
  cap=new Capability(fileId,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | FileAccessManager.NON_POSIX_DELETE,60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,osdConfig.getCapabilitySecret());
  Replica r=Replica.newBuilder().setReplicationFlags(0).setStripingPolicy(SetupUtils.getStripingPolicy(1,2)).addOsdUuids(serverID.toString()).build();
  XLocSet xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(""String_Node_Str"").addReplicas(r).setVersion(1).build();
  fcred=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xloc).build();
}",0.9143546441495778
113473,"private Capability getCap(String fname){
  return new Capability(fname,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}","private Capability getCap(String fname){
  return new Capability(fname,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",0,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}",0.8121645796064401
113474,"Capability open(char mode){
  if (mode == 't')   issuedEpoch++;
  return new Capability(FILE_ID,0,60,System.currentTimeMillis(),""String_Node_Str"",(int)issuedEpoch,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}","Capability open(char mode){
  if (mode == 't')   issuedEpoch++;
  return new Capability(FILE_ID,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",(int)issuedEpoch,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}",0.8356807511737089
113475,"private Capability getCap(String fname){
  return new Capability(fname,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}","private Capability getCap(String fname){
  return new Capability(fname,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",0,false,COW ? SnapConfig.SNAP_CONFIG_ACCESS_CURRENT : SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,capSecret);
}",0.8121645796064401
113476,"protected void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  FSUtils.delTree(new File(SetupUtils.TEST_DIR));
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osdId=SetupUtils.getOSD1UUID();
  osdServer=new OSD(osdCfg);
  client=testEnv.getOSDClient();
  List<String> osdset=new ArrayList(1);
  osdset.add(SetupUtils.getOSD1UUID().toString());
  Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,KB)).setReplicationFlags(0).addAllOsdUuids(osdset).build();
  xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setVersion(1).addReplicas(r).setReplicaUpdatePolicy(""String_Node_Str"").build();
}","protected void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  FSUtils.delTree(new File(SetupUtils.TEST_DIR));
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osdId=SetupUtils.getOSD1UUID();
  osdServer=new OSD(osdCfg);
  client=testEnv.getOSDClient();
  List<String> osdset=new ArrayList<String>(1);
  osdset.add(SetupUtils.getOSD1UUID().toString());
  Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,KB)).setReplicationFlags(0).addAllOsdUuids(osdset).build();
  xloc=XLocSet.newBuilder().setReadOnlyFileSize(0).setVersion(1).addReplicas(r).setReplicaUpdatePolicy(""String_Node_Str"").build();
}",0.9956709956709956
113477,"private FileCredentials getFileCredentials(int truncateEpoch,long snapTimestamp){
  return FileCredentials.newBuilder().setXcap(new Capability(FILE_ID,0,60,System.currentTimeMillis(),""String_Node_Str"",truncateEpoch,false,SnapConfig.SNAP_CONFIG_ACCESS_SNAP,snapTimestamp,capSecret).getXCap()).setXlocs(xloc).build();
}","private FileCredentials getFileCredentials(int truncateEpoch,long snapTimestamp){
  return FileCredentials.newBuilder().setXcap(new Capability(FILE_ID,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDONLY.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",truncateEpoch,false,SnapConfig.SNAP_CONFIG_ACCESS_SNAP,snapTimestamp,capSecret).getXCap()).setXlocs(xloc).build();
}",0.9226277372262772
113478,"/** 
 * @throws java.lang.Exception
 */
@Before public void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  this.stripeSize=128 * 1024;
  this.data=SetupUtils.generateData(stripeSize);
  File testDir=new File(SetupUtils.TEST_DIR);
  FSUtils.delTree(testDir);
  testDir.mkdirs();
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osds=new OSD[12];
  configs=SetupUtils.createMultipleOSDConfigs(12);
  for (int i=0; i < osds.length; i++) {
    osds[i]=new OSD(configs[i]);
  }
  client=testEnv.getOSDClient();
  fileID=""String_Node_Str"";
  objectNo=0;
  cap=new Capability(fileID,0,60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  xLoc=createLocations(4,3);
}","/** 
 * @throws java.lang.Exception
 */
@Before public void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  this.stripeSize=128 * 1024;
  this.data=SetupUtils.generateData(stripeSize);
  File testDir=new File(SetupUtils.TEST_DIR);
  FSUtils.delTree(testDir);
  testDir.mkdirs();
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_SERVICE,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.OSD_CLIENT});
  testEnv.start();
  osds=new OSD[12];
  configs=SetupUtils.createMultipleOSDConfigs(12);
  for (int i=0; i < osds.length; i++) {
    osds[i]=new OSD(configs[i]);
  }
  client=testEnv.getOSDClient();
  fileID=""String_Node_Str"";
  objectNo=0;
  cap=new Capability(fileID,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),60,System.currentTimeMillis(),""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  xLoc=createLocations(4,3);
}",0.975230694511899
113479,"@Test public void testReplicatedWrite() throws Exception {
  Capability cap=new Capability(fileId,0,60,System.currentTimeMillis() + 10000,""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  List<Replica> rlist=new LinkedList();
  for (  OSDConfig osd : this.configs) {
    Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(osd.getUUID().toString()).build();
    rlist.add(r);
  }
  UUIDResolver.addTestMapping(""String_Node_Str"",""String_Node_Str"",32640,false);
  Replica replica=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(""String_Node_Str"").build();
  rlist.add(replica);
  XLocSet locSet=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ).setVersion(1).addAllReplicas(rlist).build();
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(locSet).build();
  final OSDServiceClient client=testEnv.getOSDClient();
  final InetSocketAddress osd1=new InetSocketAddress(""String_Node_Str"",configs[0].getPort());
  final InetSocketAddress osd2=new InetSocketAddress(""String_Node_Str"",configs[1].getPort());
  ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
  ReusableBuffer rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  RPCResponse<OSDWriteResponse> r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,rb);
  try {
    r.get();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  ReusableBuffer data=BufferPool.allocate(1024 * 8);
  r=client.write(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,data);
  try {
    r.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r.freeBuffers();
  rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,1024,0,objdata,rb);
  r.get();
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  System.out.println(""String_Node_Str"");
  RPCResponse<ObjectData> r2=client.read(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  try {
    r2.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r2.freeBuffers();
  r2=client.read(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  ObjectData od=r2.get();
  rb=r2.getData();
  assertEquals(rb.get(0),(byte)'Y');
  assertEquals(rb.get(1),(byte)'a');
  r2.freeBuffers();
  XCap newCap=fc.getXcap().toBuilder().setTruncateEpoch(1).build();
  fc=fc.toBuilder().setXcap(newCap).build();
  RPCResponse r3=client.truncate(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,128 * 1024 * 2);
  r3.get();
  r3.freeBuffers();
}","@Test public void testReplicatedWrite() throws Exception {
  Capability cap=new Capability(fileId,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),60,System.currentTimeMillis() + 10000,""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  List<Replica> rlist=new LinkedList();
  for (  OSDConfig osd : this.configs) {
    Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(osd.getUUID().toString()).build();
    rlist.add(r);
  }
  UUIDResolver.addTestMapping(""String_Node_Str"",""String_Node_Str"",32640,false);
  Replica replica=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(""String_Node_Str"").build();
  rlist.add(replica);
  XLocSet locSet=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ).setVersion(1).addAllReplicas(rlist).build();
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(locSet).build();
  final OSDServiceClient client=testEnv.getOSDClient();
  final InetSocketAddress osd1=new InetSocketAddress(""String_Node_Str"",configs[0].getPort());
  final InetSocketAddress osd2=new InetSocketAddress(""String_Node_Str"",configs[1].getPort());
  ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
  ReusableBuffer rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  RPCResponse<OSDWriteResponse> r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,rb);
  try {
    r.get();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  ReusableBuffer data=BufferPool.allocate(1024 * 8);
  r=client.write(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,data);
  try {
    r.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r.freeBuffers();
  rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,1024,0,objdata,rb);
  r.get();
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  System.out.println(""String_Node_Str"");
  RPCResponse<ObjectData> r2=client.read(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  try {
    r2.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r2.freeBuffers();
  r2=client.read(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  ObjectData od=r2.get();
  rb=r2.getData();
  assertEquals(rb.get(0),(byte)'Y');
  assertEquals(rb.get(1),(byte)'a');
  r2.freeBuffers();
  XCap newCap=fc.getXcap().toBuilder().setTruncateEpoch(1).build();
  fc=fc.toBuilder().setXcap(newCap).build();
  RPCResponse r3=client.truncate(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,128 * 1024 * 2);
  r3.get();
  r3.freeBuffers();
}",0.984941918829772
113480,"@Test public void testTwoReplicas() throws Exception {
  Capability cap=new Capability(fileId,0,60,System.currentTimeMillis() + 10000,""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  List<Replica> rlist=new LinkedList();
  for (  OSDConfig osd : this.configs) {
    Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(osd.getUUID().toString()).build();
    rlist.add(r);
  }
  XLocSet locSet=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ).setVersion(1).addAllReplicas(rlist).build();
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(locSet).build();
  final OSDServiceClient client=testEnv.getOSDClient();
  final InetSocketAddress osd1=new InetSocketAddress(""String_Node_Str"",configs[0].getPort());
  final InetSocketAddress osd2=new InetSocketAddress(""String_Node_Str"",configs[1].getPort());
  ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
  ReusableBuffer rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  RPCResponse<OSDWriteResponse> r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,rb);
  try {
    r.get();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  ReusableBuffer data=BufferPool.allocate(1024 * 8);
  r=client.write(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,data);
  try {
    r.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r.freeBuffers();
  rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,1024,0,objdata,rb);
  r.get();
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  System.out.println(""String_Node_Str"");
  RPCResponse<ObjectData> r2=client.read(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  try {
    r2.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r2.freeBuffers();
  r2=client.read(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  ObjectData od=r2.get();
  rb=r2.getData();
  assertEquals(rb.get(0),(byte)'Y');
  assertEquals(rb.get(1),(byte)'a');
  r2.freeBuffers();
  XCap newCap=fc.getXcap().toBuilder().setTruncateEpoch(1).build();
  fc=fc.toBuilder().setXcap(newCap).build();
  RPCResponse r3=client.truncate(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,128 * 1024 * 2);
  r3.get();
  r3.freeBuffers();
}","@Test public void testTwoReplicas() throws Exception {
  Capability cap=new Capability(fileId,SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_TRUNC.getNumber() | SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(),60,System.currentTimeMillis() + 10000,""String_Node_Str"",0,false,SnapConfig.SNAP_CONFIG_SNAPS_DISABLED,0,configs[0].getCapabilitySecret());
  List<Replica> rlist=new LinkedList();
  for (  OSDConfig osd : this.configs) {
    Replica r=Replica.newBuilder().setStripingPolicy(SetupUtils.getStripingPolicy(1,128)).setReplicationFlags(0).addOsdUuids(osd.getUUID().toString()).build();
    rlist.add(r);
  }
  XLocSet locSet=XLocSet.newBuilder().setReadOnlyFileSize(0).setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_WQRQ).setVersion(1).addAllReplicas(rlist).build();
  FileCredentials fc=FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(locSet).build();
  final OSDServiceClient client=testEnv.getOSDClient();
  final InetSocketAddress osd1=new InetSocketAddress(""String_Node_Str"",configs[0].getPort());
  final InetSocketAddress osd2=new InetSocketAddress(""String_Node_Str"",configs[1].getPort());
  ObjectData objdata=ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false).build();
  ReusableBuffer rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  RPCResponse<OSDWriteResponse> r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,rb);
  try {
    r.get();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  ReusableBuffer data=BufferPool.allocate(1024 * 8);
  r=client.write(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,0,0,objdata,data);
  try {
    r.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r.freeBuffers();
  rb=BufferPool.allocate(1024);
  rb.put(""String_Node_Str"".getBytes());
  rb.limit(rb.capacity());
  rb.position(0);
  r=client.write(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,0,1024,0,objdata,rb);
  r.get();
  System.out.println(""String_Node_Str"");
  r.freeBuffers();
  System.out.println(""String_Node_Str"");
  RPCResponse<ObjectData> r2=client.read(osd2,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  try {
    r2.get();
    fail(""String_Node_Str"");
  }
 catch (  PBRPCException ex) {
    if (ex.getErrorType() != ErrorType.REDIRECT)     fail(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ex);
  }
  r2.freeBuffers();
  r2=client.read(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,0,-1,0,2048);
  ObjectData od=r2.get();
  rb=r2.getData();
  assertEquals(rb.get(0),(byte)'Y');
  assertEquals(rb.get(1),(byte)'a');
  r2.freeBuffers();
  XCap newCap=fc.getXcap().toBuilder().setTruncateEpoch(1).build();
  fc=fc.toBuilder().setXcap(newCap).build();
  RPCResponse r3=client.truncate(osd1,RPCAuthentication.authNone,RPCAuthentication.userService,fc,fileId,128 * 1024 * 2);
  r3.get();
  r3.freeBuffers();
}",0.98371335504886
113481,"public void initialize() throws IOException {
  try {
    for (; ; ) {
      try {
        registerServices(-1);
        break;
      }
 catch (      PBRPCException ex) {
        if (ex.getPOSIXErrno() == POSIXErrno.POSIX_ERROR_EAGAIN) {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.misc,this,""String_Node_Str"",CONCURRENT_RETRY_INTERVALL);
        }
 else         throw ex;
      }
    }
    List<AddressMapping.Builder> endpoints=null;
    if (""String_Node_Str"".equals(config.getHostName()) && config.getAddress() == null) {
      endpoints=NetUtils.getReachableEndpoints(config.getPort(),proto);
      if (endpoints.size() > 0)       advertisedHostName=endpoints.get(0).getAddress();
      if (advertiseUDPEndpoints) {
        endpoints.addAll(NetUtils.getReachableEndpoints(config.getPort(),Schemes.SCHEME_PBRPCU));
      }
      for (      AddressMapping.Builder endpoint : endpoints) {
        endpoint.setUuid(uuid.toString());
      }
    }
 else {
      endpoints=new ArrayList(10);
      String host=""String_Node_Str"".equals(config.getHostName()) ? config.getAddress().getHostName() : config.getHostName();
      if (host.startsWith(""String_Node_Str"")) {
        host=host.substring(1);
      }
      try {
        InetAddress ia=InetAddress.getByName(host);
      }
 catch (      Exception ex) {
        Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",host);
      }
      AddressMapping.Builder tmp=AddressMapping.newBuilder().setUuid(uuid.toString()).setVersion(0).setProtocol(proto).setAddress(host).setPort(config.getPort()).setMatchNetwork(""String_Node_Str"").setTtlS(3600).setUri(proto + ""String_Node_Str"" + host+ ""String_Node_Str""+ config.getPort());
      endpoints.add(tmp);
      advertisedHostName=host;
      if (advertiseUDPEndpoints) {
        tmp=AddressMapping.newBuilder().setUuid(uuid.toString()).setVersion(0).setProtocol(Schemes.SCHEME_PBRPCU).setAddress(host).setPort(config.getPort()).setMatchNetwork(""String_Node_Str"").setTtlS(3600).setUri(Schemes.SCHEME_PBRPCU + ""String_Node_Str"" + host+ ""String_Node_Str""+ config.getPort());
        endpoints.add(tmp);
      }
    }
    if (Logging.isInfo()) {
      Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"");
      for (      AddressMapping.Builder mapping : endpoints) {
        Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,OutputUtils.addressMappingToString(mapping));
      }
    }
    long version=0;
    AddressMappingSet ams=client.xtreemfs_address_mappings_get(null,authNone,uc,uuid.toString());
    if (ams.getMappingsCount() > 0) {
      version=ams.getMappings(0).getVersion();
    }
    if (endpoints.size() > 0) {
      endpoints.get(0).setVersion(version);
    }
    AddressMappingSet.Builder amsb=AddressMappingSet.newBuilder();
    for (    AddressMapping.Builder mapping : endpoints) {
      amsb.addMappings(mapping);
    }
    client.xtreemfs_address_mappings_set(null,authNone,uc,amsb.build());
  }
 catch (  InterruptedException ex) {
  }
catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ex);
    throw new IOException(""String_Node_Str"" + ex,ex);
  }
  try {
    this.setServiceConfiguration();
  }
 catch (  Exception e) {
    Logging.logError(Logging.LEVEL_ERROR,this,e);
  }
}","public void initialize() throws IOException {
  try {
    for (; ; ) {
      try {
        registerServices(-1);
        break;
      }
 catch (      PBRPCException ex) {
        if (ex.getPOSIXErrno() == POSIXErrno.POSIX_ERROR_EAGAIN) {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.misc,this,""String_Node_Str"",CONCURRENT_RETRY_INTERVALL);
        }
 else         throw ex;
      }
    }
    List<AddressMapping.Builder> endpoints=null;
    if (""String_Node_Str"".equals(config.getHostName()) && config.getAddress() == null) {
      endpoints=NetUtils.getReachableEndpoints(config.getPort(),proto);
      if (endpoints.size() > 0)       advertisedHostName=endpoints.get(0).getAddress();
      if (advertiseUDPEndpoints) {
        endpoints.addAll(NetUtils.getReachableEndpoints(config.getPort(),Schemes.SCHEME_PBRPCU));
      }
      for (      AddressMapping.Builder endpoint : endpoints) {
        endpoint.setUuid(uuid.toString());
      }
    }
 else {
      endpoints=new ArrayList(10);
      String host=""String_Node_Str"".equals(config.getHostName()) ? config.getAddress().getHostName() : config.getHostName();
      if (host.startsWith(""String_Node_Str"")) {
        host=host.substring(1);
      }
      try {
        InetAddress ia=InetAddress.getByName(host);
      }
 catch (      Exception ex) {
        Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",host);
      }
      AddressMapping.Builder tmp=AddressMapping.newBuilder().setUuid(uuid.toString()).setVersion(0).setProtocol(proto).setAddress(host).setPort(config.getPort()).setMatchNetwork(""String_Node_Str"").setTtlS(3600).setUri(proto + ""String_Node_Str"" + host+ ""String_Node_Str""+ config.getPort());
      endpoints.add(tmp);
      advertisedHostName=host;
      if (advertiseUDPEndpoints) {
        tmp=AddressMapping.newBuilder().setUuid(uuid.toString()).setVersion(0).setProtocol(Schemes.SCHEME_PBRPCU).setAddress(host).setPort(config.getPort()).setMatchNetwork(""String_Node_Str"").setTtlS(3600).setUri(Schemes.SCHEME_PBRPCU + ""String_Node_Str"" + host+ ""String_Node_Str""+ config.getPort());
        endpoints.add(tmp);
      }
    }
    if (Logging.isInfo()) {
      Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"");
      for (      AddressMapping.Builder mapping : endpoints) {
        Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"",mapping.getUuid(),mapping.getUri());
      }
    }
    long version=0;
    AddressMappingSet ams=client.xtreemfs_address_mappings_get(null,authNone,uc,uuid.toString());
    if (ams.getMappingsCount() > 0) {
      version=ams.getMappings(0).getVersion();
    }
    if (endpoints.size() > 0) {
      endpoints.get(0).setVersion(version);
    }
    AddressMappingSet.Builder amsb=AddressMappingSet.newBuilder();
    for (    AddressMapping.Builder mapping : endpoints) {
      amsb.addMappings(mapping);
    }
    client.xtreemfs_address_mappings_set(null,authNone,uc,amsb.build());
  }
 catch (  InterruptedException ex) {
  }
catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ex);
    throw new IOException(""String_Node_Str"" + ex,ex);
  }
  try {
    this.setServiceConfiguration();
  }
 catch (  Exception e) {
    Logging.logError(Logging.LEVEL_ERROR,this,e);
  }
}",0.9888971132494448
113482,"public static void main(String[] args){
  Map<String,CliOption> options=null;
  try {
    options=utils.getDefaultAdminToolOptions(true);
    List<String> arguments=new ArrayList<String>(1);
    CliOption oDir=new CliOption(CliOption.OPTIONTYPE.URL,""String_Node_Str"",""String_Node_Str"");
    oDir.urlDefaultPort=PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber();
    oDir.urlDefaultProtocol=Schemes.SCHEME_PBRPC;
    options.put(""String_Node_Str"",oDir);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    CLIParser.parseCLI(args,options,arguments);
    if (options.get(""String_Node_Str"").switchValue) {
      Logging.start(Logging.LEVEL_DEBUG);
    }
 else {
      Logging.start(Logging.LEVEL_ERROR);
    }
    if (options.get(utils.OPTION_HELP).switchValue || options.get(utils.OPTION_HELP_LONG).switchValue) {
      usage(options);
      return;
    }
    if (arguments.size() != 1) {
      error(""String_Node_Str"",options,false);
    }
    ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
    boolean shutdown=options.get(""String_Node_Str"").switchValue;
    String password=(options.get(utils.OPTION_ADMIN_PASS).stringValue != null) ? options.get(utils.OPTION_ADMIN_PASS).stringValue : ""String_Node_Str"";
    boolean useSSL=false;
    boolean gridSSL=false;
    String serviceCredsFile=null;
    String serviceCredsPass=null;
    String trustedCAsFile=null;
    String trustedCAsPass=null;
    InetSocketAddress dirAddr=null;
    String osdUUID=null;
    if (arguments.get(0).startsWith(""String_Node_Str"")) {
      osdUUID=arguments.get(0).substring(""String_Node_Str"".length());
    }
 else {
      error(""String_Node_Str"",options);
    }
    if (dirURL != null && (Schemes.SCHEME_PBRPCS.equals(dirURL.getProtocol()) || Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol()))) {
      useSSL=true;
      serviceCredsFile=options.get(utils.OPTION_USER_CREDS_FILE).stringValue;
      serviceCredsPass=options.get(utils.OPTION_USER_CREDS_PASS).stringValue;
      trustedCAsFile=options.get(utils.OPTION_TRUSTSTORE_FILE).stringValue;
      trustedCAsPass=options.get(utils.OPTION_TRUSTSTORE_PASS).stringValue;
      if (Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol())) {
        gridSSL=true;
      }
      if (serviceCredsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_USER_CREDS_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
 else       if (trustedCAsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_TRUSTSTORE_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
    }
    if (dirURL == null) {
      try {
        DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
        cfg.read();
        dirAddr=cfg.getDirectoryService();
        useSSL=cfg.isSslEnabled();
        serviceCredsFile=cfg.getServiceCredsFile();
        serviceCredsPass=cfg.getServiceCredsPassphrase();
        trustedCAsFile=cfg.getTrustedCertsFile();
        trustedCAsPass=cfg.getTrustedCertsPassphrase();
      }
 catch (      IOException e) {
        error(""String_Node_Str"",options);
      }
    }
 else {
      dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
    }
    SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false,gridSSL,null) : null;
    xtfs_remove_osd removeOsd=new xtfs_remove_osd(dirAddr,osdUUID,sslOptions,password);
    removeOsd.initialize();
    removeOsd.drainOSD(shutdown);
    removeOsd.shutdown();
    System.exit(0);
  }
 catch (  Exception e) {
    error(e.getMessage(),options);
  }
}","public static void main(String[] args){
  Map<String,CliOption> options=null;
  try {
    options=utils.getDefaultAdminToolOptions(true);
    List<String> arguments=new ArrayList<String>(1);
    CliOption oDir=new CliOption(CliOption.OPTIONTYPE.URL,""String_Node_Str"",""String_Node_Str"");
    oDir.urlDefaultPort=PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber();
    oDir.urlDefaultProtocol=Schemes.SCHEME_PBRPC;
    options.put(""String_Node_Str"",oDir);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    CLIParser.parseCLI(args,options,arguments);
    if (options.get(""String_Node_Str"").switchValue) {
      Logging.start(Logging.LEVEL_DEBUG);
    }
 else {
      Logging.start(Logging.LEVEL_ERROR);
    }
    if (options.get(utils.OPTION_HELP).switchValue || options.get(utils.OPTION_HELP_LONG).switchValue || arguments.size() == 0) {
      usage(options);
      return;
    }
    if (arguments.size() > 1) {
      error(""String_Node_Str"",options,true);
    }
    ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
    boolean shutdown=options.get(""String_Node_Str"").switchValue;
    String password=(options.get(utils.OPTION_ADMIN_PASS).stringValue != null) ? options.get(utils.OPTION_ADMIN_PASS).stringValue : ""String_Node_Str"";
    boolean useSSL=false;
    boolean gridSSL=false;
    String serviceCredsFile=null;
    String serviceCredsPass=null;
    String trustedCAsFile=null;
    String trustedCAsPass=null;
    InetSocketAddress dirAddr=null;
    String osdUUID=null;
    if (arguments.get(0).startsWith(""String_Node_Str"")) {
      osdUUID=arguments.get(0).substring(""String_Node_Str"".length());
    }
 else {
      error(""String_Node_Str"",options);
    }
    if (dirURL != null && (Schemes.SCHEME_PBRPCS.equals(dirURL.getProtocol()) || Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol()))) {
      useSSL=true;
      serviceCredsFile=options.get(utils.OPTION_USER_CREDS_FILE).stringValue;
      serviceCredsPass=options.get(utils.OPTION_USER_CREDS_PASS).stringValue;
      trustedCAsFile=options.get(utils.OPTION_TRUSTSTORE_FILE).stringValue;
      trustedCAsPass=options.get(utils.OPTION_TRUSTSTORE_PASS).stringValue;
      if (Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol())) {
        gridSSL=true;
      }
      if (serviceCredsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_USER_CREDS_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
 else       if (trustedCAsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_TRUSTSTORE_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
    }
    if (dirURL == null) {
      try {
        DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
        cfg.read();
        dirAddr=cfg.getDirectoryService();
        useSSL=cfg.isSslEnabled();
        serviceCredsFile=cfg.getServiceCredsFile();
        serviceCredsPass=cfg.getServiceCredsPassphrase();
        trustedCAsFile=cfg.getTrustedCertsFile();
        trustedCAsPass=cfg.getTrustedCertsPassphrase();
      }
 catch (      IOException e) {
        error(""String_Node_Str"",options);
      }
    }
 else {
      dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
    }
    SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false,gridSSL,null) : null;
    xtfs_remove_osd removeOsd=new xtfs_remove_osd(dirAddr,osdUUID,sslOptions,password);
    removeOsd.initialize();
    removeOsd.drainOSD(shutdown);
    removeOsd.shutdown();
    System.exit(0);
  }
 catch (  Exception e) {
    error(e.getMessage(),options);
  }
}",0.995512245159636
113483,"@Override public Collection<StorageManager> getStorageManagers(){
  if (!initialized.get())   return null;
  return volsById.values();
}","@Override public Collection<StorageManager> getStorageManagers(){
  if (!initialized.get())   return null;
  final Collection<StorageManager> result=new HashSet<StorageManager>();
  final Collection<StorageManager> sMans=volsById.values();
synchronized (volsById) {
    for (    StorageManager sMan : sMans) {
      result.add(sMan);
    }
  }
  return result;
}",0.5180722891566265
113484,"public static void main(String[] args){
  Map<String,CliOption> options=null;
  try {
    options=utils.getDefaultAdminToolOptions(true);
    List<String> arguments=new ArrayList<String>(1);
    CliOption oDir=new CliOption(CliOption.OPTIONTYPE.URL,""String_Node_Str"",""String_Node_Str"");
    oDir.urlDefaultPort=PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber();
    oDir.urlDefaultProtocol=Schemes.SCHEME_PBRPC;
    options.put(""String_Node_Str"",oDir);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    CLIParser.parseCLI(args,options,arguments);
    if (options.get(""String_Node_Str"").switchValue) {
      Logging.start(Logging.LEVEL_DEBUG);
    }
 else {
      Logging.start(Logging.LEVEL_ERROR);
    }
    if (options.get(utils.OPTION_HELP).switchValue || options.get(utils.OPTION_HELP_LONG).switchValue) {
      usage(options);
      return;
    }
    if (arguments.size() != 1) {
      error(""String_Node_Str"",options);
    }
    ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
    boolean shutdown=options.get(""String_Node_Str"").switchValue;
    String password=(options.get(utils.OPTION_ADMIN_PASS).stringValue != null) ? options.get(utils.OPTION_ADMIN_PASS).stringValue : ""String_Node_Str"";
    boolean useSSL=false;
    boolean gridSSL=false;
    String serviceCredsFile=null;
    String serviceCredsPass=null;
    String trustedCAsFile=null;
    String trustedCAsPass=null;
    InetSocketAddress dirAddr=null;
    String osdUUID=null;
    if (arguments.get(0).startsWith(""String_Node_Str"")) {
      osdUUID=arguments.get(0).substring(""String_Node_Str"".length());
    }
 else {
      error(""String_Node_Str"",options);
    }
    if (dirURL != null && (Schemes.SCHEME_PBRPCS.equals(dirURL.getProtocol()) || Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol()))) {
      useSSL=true;
      serviceCredsFile=options.get(utils.OPTION_USER_CREDS_FILE).stringValue;
      serviceCredsPass=options.get(utils.OPTION_USER_CREDS_PASS).stringValue;
      trustedCAsFile=options.get(utils.OPTION_TRUSTSTORE_FILE).stringValue;
      trustedCAsPass=options.get(utils.OPTION_TRUSTSTORE_PASS).stringValue;
      if (Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol())) {
        gridSSL=true;
      }
      if (serviceCredsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_USER_CREDS_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
 else       if (trustedCAsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_TRUSTSTORE_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
    }
    if (dirURL == null) {
      try {
        DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
        cfg.read();
        dirAddr=cfg.getDirectoryService();
        useSSL=cfg.isSslEnabled();
        serviceCredsFile=cfg.getServiceCredsFile();
        serviceCredsPass=cfg.getServiceCredsPassphrase();
        trustedCAsFile=cfg.getTrustedCertsFile();
        trustedCAsPass=cfg.getTrustedCertsPassphrase();
      }
 catch (      IOException e) {
        error(""String_Node_Str"",options);
      }
    }
 else {
      dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
    }
    SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false,gridSSL,null) : null;
    xtfs_remove_osd removeOsd=new xtfs_remove_osd(dirAddr,osdUUID,sslOptions,password);
    removeOsd.initialize();
    removeOsd.drainOSD(shutdown);
    removeOsd.shutdown();
    System.exit(0);
  }
 catch (  Exception e) {
    error(e.getMessage(),options);
  }
}","public static void main(String[] args){
  Map<String,CliOption> options=null;
  try {
    options=utils.getDefaultAdminToolOptions(true);
    List<String> arguments=new ArrayList<String>(1);
    CliOption oDir=new CliOption(CliOption.OPTIONTYPE.URL,""String_Node_Str"",""String_Node_Str"");
    oDir.urlDefaultPort=PORTS.DIR_PBRPC_PORT_DEFAULT.getNumber();
    oDir.urlDefaultProtocol=Schemes.SCHEME_PBRPC;
    options.put(""String_Node_Str"",oDir);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH,""String_Node_Str"",""String_Node_Str""));
    CLIParser.parseCLI(args,options,arguments);
    if (options.get(""String_Node_Str"").switchValue) {
      Logging.start(Logging.LEVEL_DEBUG);
    }
 else {
      Logging.start(Logging.LEVEL_ERROR);
    }
    if (options.get(utils.OPTION_HELP).switchValue || options.get(utils.OPTION_HELP_LONG).switchValue) {
      usage(options);
      return;
    }
    if (arguments.size() != 1) {
      error(""String_Node_Str"",options,false);
    }
    ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
    boolean shutdown=options.get(""String_Node_Str"").switchValue;
    String password=(options.get(utils.OPTION_ADMIN_PASS).stringValue != null) ? options.get(utils.OPTION_ADMIN_PASS).stringValue : ""String_Node_Str"";
    boolean useSSL=false;
    boolean gridSSL=false;
    String serviceCredsFile=null;
    String serviceCredsPass=null;
    String trustedCAsFile=null;
    String trustedCAsPass=null;
    InetSocketAddress dirAddr=null;
    String osdUUID=null;
    if (arguments.get(0).startsWith(""String_Node_Str"")) {
      osdUUID=arguments.get(0).substring(""String_Node_Str"".length());
    }
 else {
      error(""String_Node_Str"",options);
    }
    if (dirURL != null && (Schemes.SCHEME_PBRPCS.equals(dirURL.getProtocol()) || Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol()))) {
      useSSL=true;
      serviceCredsFile=options.get(utils.OPTION_USER_CREDS_FILE).stringValue;
      serviceCredsPass=options.get(utils.OPTION_USER_CREDS_PASS).stringValue;
      trustedCAsFile=options.get(utils.OPTION_TRUSTSTORE_FILE).stringValue;
      trustedCAsPass=options.get(utils.OPTION_TRUSTSTORE_PASS).stringValue;
      if (Schemes.SCHEME_PBRPCG.equals(dirURL.getProtocol())) {
        gridSSL=true;
      }
      if (serviceCredsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_USER_CREDS_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
 else       if (trustedCAsFile == null) {
        System.out.println(""String_Node_Str"" + utils.OPTION_TRUSTSTORE_FILE + ""String_Node_Str"");
        usage(options);
        System.exit(1);
      }
    }
    if (dirURL == null) {
      try {
        DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
        cfg.read();
        dirAddr=cfg.getDirectoryService();
        useSSL=cfg.isSslEnabled();
        serviceCredsFile=cfg.getServiceCredsFile();
        serviceCredsPass=cfg.getServiceCredsPassphrase();
        trustedCAsFile=cfg.getTrustedCertsFile();
        trustedCAsPass=cfg.getTrustedCertsPassphrase();
      }
 catch (      IOException e) {
        error(""String_Node_Str"",options);
      }
    }
 else {
      dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
    }
    SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false,gridSSL,null) : null;
    xtfs_remove_osd removeOsd=new xtfs_remove_osd(dirAddr,osdUUID,sslOptions,password);
    removeOsd.initialize();
    removeOsd.drainOSD(shutdown);
    removeOsd.shutdown();
    System.exit(0);
  }
 catch (  Exception e) {
    error(e.getMessage(),options);
  }
}",0.9992277992277993
113485,"/** 
 * Prints the error <code>message</code> and delegates to usage().
 * @param message
 */
private static void error(String message,Map<String,CliOption> options){
  System.err.println(message);
  System.out.println();
  usage(options);
  System.exit(1);
}","/** 
 * Prints the error <code>message</code> and delegates to usage().
 * @param message The error message
 * @param options The CLI Options.
 */
private static void error(String message,Map<String,CliOption> options){
  error(message,options,false);
}",0.68359375
113486,"private void checkForTimers(){
  long now=System.currentTimeMillis();
  if (now >= lastCheck + TIMEOUT_GRANULARITY) {
synchronized (connections) {
      Iterator<RPCClientConnection> conIter=connections.values().iterator();
      while (conIter.hasNext()) {
        final RPCClientConnection con=conIter.next();
        if (con.getLastUsed() < (now - connectionTimeout)) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
          }
          try {
            conIter.remove();
            closeConnection(con.getChannel().keyFor(selector),null);
          }
 catch (          Exception ex) {
          }
        }
 else {
          List<RPCClientRequest> cancelRq=new LinkedList<RPCClientRequest>();
synchronized (con) {
            Iterator<RPCClientRequest> iter=con.getRequests().values().iterator();
            while (iter.hasNext()) {
              final RPCClientRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
            }
            iter=con.getSendQueue().iterator();
            while (iter.hasNext()) {
              final RPCClientRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
 else {
                break;
              }
            }
          }
          for (          RPCClientRequest rq : cancelRq) {
            rq.getResponse().requestFailed(""String_Node_Str"");
          }
        }
      }
      lastCheck=now;
    }
  }
}","private void checkForTimers(){
  long now=System.currentTimeMillis();
  if (now >= lastCheck + TIMEOUT_GRANULARITY) {
synchronized (connections) {
      Iterator<RPCClientConnection> conIter=connections.values().iterator();
      while (conIter.hasNext()) {
        final RPCClientConnection con=conIter.next();
        if (con.getLastUsed() < (now - connectionTimeout)) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
          }
          try {
            conIter.remove();
            closeConnection(con.getChannel().keyFor(selector),null);
          }
 catch (          Exception ex) {
          }
        }
 else {
          List<RPCClientRequest> cancelRq=new LinkedList<RPCClientRequest>();
synchronized (con) {
            Iterator<RPCClientRequest> iter=con.getRequests().values().iterator();
            while (iter.hasNext()) {
              final RPCClientRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
            }
            iter=con.getSendQueue().iterator();
            while (iter.hasNext()) {
              final RPCClientRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
 else {
                break;
              }
            }
          }
          for (          RPCClientRequest rq : cancelRq) {
            rq.getResponse().requestFailed(""String_Node_Str"");
            rq.freeBuffers();
          }
        }
      }
      lastCheck=now;
    }
  }
}",0.9910926365795724
113487,"private void establishConnection(InetSocketAddress server,RPCClientConnection con){
  if (con.canReconnect()) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",server.toString());
    }
    ChannelIO channel;
    try {
      if (sslOptions == null) {
        channel=new ChannelIO(SocketChannel.open());
      }
 else {
        if (sslOptions.isFakeSSLMode()) {
          channel=new SSLHandshakeOnlyChannelIO(SocketChannel.open(),sslOptions,true);
        }
 else {
          channel=new SSLChannelIO(SocketChannel.open(),sslOptions,true);
        }
      }
      channel.configureBlocking(false);
      channel.socket().setTcpNoDelay(true);
      if (sendBufferSize != -1) {
        channel.socket().setSendBufferSize(sendBufferSize);
        if (channel.socket().getSendBufferSize() != sendBufferSize) {
          Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"" + sendBufferSize + ""String_Node_Str""+ channel.socket().getSendBufferSize());
        }
      }
      if (receiveBufferSize != -1) {
        channel.socket().setReceiveBufferSize(receiveBufferSize);
        if (channel.socket().getReceiveBufferSize() != receiveBufferSize) {
          Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"" + receiveBufferSize + ""String_Node_Str""+ channel.socket().getReceiveBufferSize());
        }
      }
 else {
        channel.socket().setReceiveBufferSize(256 * 1024);
      }
      channel.connect(server);
      con.setChannel(channel);
      toBeEstablished.add(con);
      selector.wakeup();
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",channel.socket().getSendBufferSize());
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",channel.socket().getReceiveBufferSize());
      }
    }
 catch (    Exception ex) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getEndpoint().toString());
      }
      con.connectFailed();
      for (      RPCClientRequest rq : con.getSendQueue()) {
        rq.getResponse().requestFailed(""String_Node_Str"" + con.getEndpoint() + ""String_Node_Str""+ ex+ ""String_Node_Str"");
      }
      con.getSendQueue().clear();
    }
  }
 else {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getEndpoint().toString());
    }
synchronized (con) {
      for (      RPCClientRequest rq : con.getSendQueue()) {
        rq.getResponse().requestFailed(""String_Node_Str"" + con.getEndpoint() + ""String_Node_Str"");
        rq.freeBuffers();
      }
      con.getSendQueue().clear();
    }
  }
}","private void establishConnection(InetSocketAddress server,RPCClientConnection con){
  if (con.canReconnect()) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",server.toString());
    }
    ChannelIO channel;
    try {
      if (sslOptions == null) {
        channel=new ChannelIO(SocketChannel.open());
      }
 else {
        if (sslOptions.isFakeSSLMode()) {
          channel=new SSLHandshakeOnlyChannelIO(SocketChannel.open(),sslOptions,true);
        }
 else {
          channel=new SSLChannelIO(SocketChannel.open(),sslOptions,true);
        }
      }
      channel.configureBlocking(false);
      channel.socket().setTcpNoDelay(true);
      if (sendBufferSize != -1) {
        channel.socket().setSendBufferSize(sendBufferSize);
        if (channel.socket().getSendBufferSize() != sendBufferSize) {
          Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"" + sendBufferSize + ""String_Node_Str""+ channel.socket().getSendBufferSize());
        }
      }
      if (receiveBufferSize != -1) {
        channel.socket().setReceiveBufferSize(receiveBufferSize);
        if (channel.socket().getReceiveBufferSize() != receiveBufferSize) {
          Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"" + receiveBufferSize + ""String_Node_Str""+ channel.socket().getReceiveBufferSize());
        }
      }
 else {
        channel.socket().setReceiveBufferSize(256 * 1024);
      }
      channel.connect(server);
      con.setChannel(channel);
      toBeEstablished.add(con);
      selector.wakeup();
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",channel.socket().getSendBufferSize());
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",channel.socket().getReceiveBufferSize());
      }
    }
 catch (    Exception ex) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getEndpoint().toString());
      }
      con.connectFailed();
      for (      RPCClientRequest rq : con.getSendQueue()) {
        rq.getResponse().requestFailed(""String_Node_Str"" + con.getEndpoint() + ""String_Node_Str""+ ex+ ""String_Node_Str"");
        rq.freeBuffers();
      }
      con.getSendQueue().clear();
    }
  }
 else {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getEndpoint().toString());
    }
synchronized (con) {
      for (      RPCClientRequest rq : con.getSendQueue()) {
        rq.getResponse().requestFailed(""String_Node_Str"" + con.getEndpoint() + ""String_Node_Str"");
        rq.freeBuffers();
      }
      con.getSendQueue().clear();
    }
  }
}",0.9954449894884372
113488,"@Override public void createVolume(FileAccessManager faMan,String volumeId,String volumeName,short fileAccessPolicyId,String ownerId,String owningGroupId,StripingPolicy defaultStripingPolicy,int initialAccessMode,List<KeyValuePair> attrs) throws UserException, DatabaseException {
  waitLock.set(false);
  if (volumeName.indexOf(SNAPSHOT_SEPARATOR) != -1 || volumeName.indexOf('/') != -1 || volumeName.indexOf('\\') != -1)   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + SNAPSHOT_SEPARATOR + ""String_Node_Str"");
  if (hasVolume(volumeName))   throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + volumeName + ""String_Node_Str"");
  ACLEntry[] acl=faMan.getFileAccessPolicy(fileAccessPolicyId).getDefaultRootACL();
  new BabuDBStorageManager(database,volumeId,volumeName,fileAccessPolicyId,DEFAULT_OSD_POLICY,DEFAULT_REPL_POLICY,ownerId,owningGroupId,initialAccessMode,acl,defaultStripingPolicy,DEFAULT_ALLOW_SNAPS,KeyValuePairs.toMap(attrs));
synchronized (waitLock) {
    while (!waitLock.get())     try {
      waitLock.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  System.out.println(""String_Node_Str"");
}","@Override public void createVolume(FileAccessManager faMan,String volumeId,String volumeName,short fileAccessPolicyId,String ownerId,String owningGroupId,StripingPolicy defaultStripingPolicy,int initialAccessMode,List<KeyValuePair> attrs) throws UserException, DatabaseException {
  waitLock.set(false);
  if (volumeName.indexOf(SNAPSHOT_SEPARATOR) != -1 || volumeName.indexOf('/') != -1 || volumeName.indexOf('\\') != -1)   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + SNAPSHOT_SEPARATOR + ""String_Node_Str"");
  if (hasVolume(volumeName))   throw new UserException(POSIXErrno.POSIX_ERROR_EEXIST,""String_Node_Str"" + volumeName + ""String_Node_Str"");
  ACLEntry[] acl=faMan.getFileAccessPolicy(fileAccessPolicyId).getDefaultRootACL();
  new BabuDBStorageManager(database,volumeId,volumeName,fileAccessPolicyId,DEFAULT_OSD_POLICY,DEFAULT_REPL_POLICY,ownerId,owningGroupId,initialAccessMode,acl,defaultStripingPolicy,DEFAULT_ALLOW_SNAPS,KeyValuePairs.toMap(attrs));
synchronized (waitLock) {
    while (!waitLock.get())     try {
      waitLock.wait();
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9822280017338536
113489,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final XCap xcap=(XCap)rq.getRequestArgs();
  Capability writeCap=new Capability(xcap,master.getConfig().getCapabilitySecret());
  if (!writeCap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,writeCap + ""String_Node_Str"");
  if (writeCap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,writeCap + ""String_Node_Str"");
  if ((writeCap.getAccessMode() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR | FileAccessManager.O_TRUNC)) == 0)   throw new UserException(POSIXErrno.POSIX_ERROR_EACCES,writeCap + ""String_Node_Str"");
  GlobalFileIdResolver idRes=new GlobalFileIdResolver(writeCap.getFileId());
  StorageManager sMan=master.getVolumeManager().getStorageManager(idRes.getVolumeId());
  FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
  if (file == null)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + writeCap.getFileId() + ""String_Node_Str"");
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  int newEpoch=file.getIssuedEpoch() + 1;
  file.setIssuedEpoch(newEpoch);
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  Capability truncCap=new Capability(writeCap.getFileId(),writeCap.getAccessMode() | FileAccessManager.O_TRUNC,master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),newEpoch,false,!sMan.getVolumeInfo().isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : sMan.getVolumeInfo().isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,sMan.getVolumeInfo().getCreationTime(),master.getConfig().getCapabilitySecret());
  rq.setResponse(truncCap.getXCap());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final XCap xcap=(XCap)rq.getRequestArgs();
  Capability writeCap=new Capability(xcap,master.getConfig().getCapabilitySecret());
  if (!writeCap.hasValidSignature())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,writeCap + ""String_Node_Str"");
  if (writeCap.hasExpired())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,writeCap + ""String_Node_Str"");
  if ((writeCap.getAccessMode() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR | FileAccessManager.O_TRUNC)) == 0)   throw new UserException(POSIXErrno.POSIX_ERROR_EACCES,writeCap + ""String_Node_Str"");
  GlobalFileIdResolver idRes=new GlobalFileIdResolver(writeCap.getFileId());
  StorageManager sMan=master.getVolumeManager().getStorageManager(idRes.getVolumeId());
  FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
  if (file == null)   throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + writeCap.getFileId() + ""String_Node_Str"");
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  int newEpoch=file.getIssuedEpoch() + 1;
  file.setIssuedEpoch(newEpoch);
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  Capability truncCap=new Capability(writeCap.getFileId(),writeCap.getAccessMode() | FileAccessManager.O_TRUNC,master.getConfig().getCapabilityTimeout(),TimeSync.getGlobalTime() / 1000 + master.getConfig().getCapabilityTimeout(),((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),newEpoch,writeCap.isReplicateOnClose(),!sMan.getVolumeInfo().isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : sMan.getVolumeInfo().isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,sMan.getVolumeInfo().getCreationTime(),master.getConfig().getCapabilitySecret());
  rq.setResponse(truncCap.getXCap());
  update.execute();
}",0.9917874396135266
113490,"@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword() == null)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}","@Override public void startRequest(final MRCRequest rq) throws Throwable {
  String replMasterUUID=master.getReplMasterUUID();
  if (replMasterUUID != null && !replMasterUUID.equals(master.getConfig().getUUID().toString())) {
    ServiceUUID uuid=new ServiceUUID(replMasterUUID);
    throw new DatabaseException(ExceptionType.REDIRECT,uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
  }
  final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
  if (master.getConfig().getAdminPassword().length() > 0 && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  final StorageManager sMan=master.getVolumeManager().getStorageManagerByName(rqArgs.getVolumeName());
  final VolumeInfo volume=sMan.getVolumeInfo();
  FileMetadata file=sMan.getMetadata(0,volume.getName());
  if (master.getConfig().getAdminPassword().length() > 0)   master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  Runnable rqThr=new Runnable(){
    @Override public void run(){
      try {
        master.getDirClient().xtreemfs_service_deregister(null,rq.getDetails().auth,RPCAuthentication.userService,volume.getId());
        processStep2(rqArgs,volume.getId(),rq);
      }
 catch (      Exception ex) {
        finishRequest(rq,new ErrorRecord(ErrorType.INTERNAL_SERVER_ERROR,POSIXErrno.POSIX_ERROR_NONE,""String_Node_Str"",ex));
      }
    }
  }
;
  Thread thr=new Thread(rqThr);
  thr.start();
}",0.9934762348555451
113491,"public FleaseConfig(int leaseTimeout_ms,int dmax_ms,int messageTimeout_ms,InetSocketAddress endpoint,String identity,int maxRetries,boolean sendLearnMessages,int toNotification_ms){
  this.maxLeaseTimeout_ms=leaseTimeout_ms;
  this.dmax_ms=dmax_ms;
  this.messageTimeout_ms=messageTimeout_ms;
  this.cellTimeout_ms=maxLeaseTimeout_ms * 2;
  this.roundTimeout_ms=messageTimeout_ms * 2;
  this.restartWait_ms=maxLeaseTimeout_ms + dmax_ms * 2 + messageTimeout_ms;
  this.endpoint=endpoint;
  this.senderId=identity.hashCode();
  checkValidConfiguration();
  this.identity=new ASCIIString(identity);
  this.maxRetries=maxRetries;
  this.sendLearnMessages=sendLearnMessages;
  this.toNotification_ms=toNotification_ms;
}","public FleaseConfig(int leaseTimeout_ms,int dmax_ms,int messageTimeout_ms,InetSocketAddress endpoint,String identity,int maxRetries,boolean sendLearnMessages,int toNotification_ms,boolean debugPrintMessages){
  this.maxLeaseTimeout_ms=leaseTimeout_ms;
  this.dmax_ms=dmax_ms;
  this.messageTimeout_ms=messageTimeout_ms;
  this.cellTimeout_ms=maxLeaseTimeout_ms * 2;
  this.roundTimeout_ms=messageTimeout_ms * 2;
  this.restartWait_ms=maxLeaseTimeout_ms + dmax_ms * 2 + messageTimeout_ms;
  this.endpoint=endpoint;
  this.senderId=identity.hashCode();
  checkValidConfiguration();
  this.identity=new ASCIIString(identity);
  this.maxRetries=maxRetries;
  this.sendLearnMessages=sendLearnMessages;
  this.toNotification_ms=toNotification_ms;
  this.debugPrintMessages=debugPrintMessages;
}",0.9514304723885564
113492,"private int checkTimers(){
  final long now=TimeSync.getLocalSystemTime();
  TimerEntry e=timers.peek();
  if (e == null) {
    return TIMER_INTERVAL_IN_MS;
  }
  if (e.getScheduledTime() <= now + TIMER_INTERVAL_IN_MS) {
    do {
      e=timers.poll();
      long rqStart;
      if (COLLECT_STATISTICS) {
        rqStart=System.nanoTime();
        inTimers.incrementAndGet();
      }
      e.getMessage().setSendTimestamp(TimeSync.getGlobalTime());
      proposer.processMessage(e.getMessage());
      if (COLLECT_STATISTICS) {
        long rqEnd=System.nanoTime();
        durTimers.get().add(Integer.valueOf((int)(rqEnd - rqStart)));
      }
      e=timers.peek();
      if (e == null) {
        return TIMER_INTERVAL_IN_MS;
      }
    }
 while (e.getScheduledTime() <= now + TIMER_INTERVAL_IN_MS);
    return (int)(e.getScheduledTime() - now);
  }
 else {
    return (int)(e.getScheduledTime() - now);
  }
}","private int checkTimers(){
  final long now=TimeSync.getLocalSystemTime();
  TimerEntry e=timers.peek();
  if (e == null) {
    return TIMER_INTERVAL_IN_MS;
  }
  if (e.getScheduledTime() <= now + TIMER_INTERVAL_IN_MS) {
    do {
      e=timers.poll();
      long rqStart;
      if (COLLECT_STATISTICS) {
        rqStart=System.nanoTime();
        inTimers.incrementAndGet();
      }
      if (e.getScheduledTime() < now) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",e.message);
      }
      e.getMessage().setSendTimestamp(TimeSync.getGlobalTime());
      proposer.processMessage(e.getMessage());
      if (COLLECT_STATISTICS) {
        long rqEnd=System.nanoTime();
        durTimers.get().add(Integer.valueOf((int)(rqEnd - rqStart)));
      }
      e=timers.peek();
      if (e == null) {
        return TIMER_INTERVAL_IN_MS;
      }
    }
 while (e.getScheduledTime() <= now + TIMER_INTERVAL_IN_MS);
    return (int)(e.getScheduledTime() - now);
  }
 else {
    return (int)(e.getScheduledTime() - now);
  }
}",0.9334016393442623
113493,"/** 
 * main loop
 */
public FleaseMessage processMessage(FleaseMessage msg){
  assert(!quit);
  final long now=TimeSync.getLocalSystemTime();
  if (msg.getSendTimestamp() + config.getMessageTimeout() < TimeSync.getGlobalTime()) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",msg.toString());
    return null;
  }
  if (this.waitUntilTimestamp_ms >= now) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"");
    return null;
  }
  assert(msg.getCellId() != null);
  final int myViewId=getCell(msg.getCellId()).getViewId();
  if ((myViewId == FleaseMessage.VIEW_ID_INVALIDATED) || (myViewId > msg.getViewId())) {
    FleaseMessage response=new FleaseMessage(FleaseMessage.MsgType.MSG_WRONG_VIEW,msg);
    response.setViewId(myViewId);
    return response;
  }
  if (myViewId < msg.getViewId()) {
    viewListener.viewIdChangeEvent(msg.getCellId(),msg.getViewId());
    return null;
  }
  FleaseMessage response=null;
  if (msg.getMsgType() == FleaseMessage.MsgType.MSG_PREPARE)   response=handlePREPARE(msg);
 else   if (msg.getMsgType() == FleaseMessage.MsgType.MSG_ACCEPT)   response=handleACCEPT(msg);
 else   if (msg.getMsgType() == FleaseMessage.MsgType.MSG_LEARN)   handleLEARN(msg);
 else   Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",msg.toString());
  return response;
}","/** 
 * main loop
 */
public FleaseMessage processMessage(FleaseMessage msg){
  assert(!quit);
  final long now=TimeSync.getLocalSystemTime();
  if (msg.getSendTimestamp() + config.getMessageTimeout() < TimeSync.getGlobalTime()) {
    if (Logging.isDebug() && config.isDebugPrintMessages())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",msg.toString());
    return null;
  }
  if (this.waitUntilTimestamp_ms >= now) {
    if (Logging.isDebug() && config.isDebugPrintMessages())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"");
    return null;
  }
  assert(msg.getCellId() != null);
  final int myViewId=getCell(msg.getCellId()).getViewId();
  if ((myViewId == FleaseMessage.VIEW_ID_INVALIDATED) || (myViewId > msg.getViewId())) {
    FleaseMessage response=new FleaseMessage(FleaseMessage.MsgType.MSG_WRONG_VIEW,msg);
    response.setViewId(myViewId);
    return response;
  }
  if (myViewId < msg.getViewId()) {
    viewListener.viewIdChangeEvent(msg.getCellId(),msg.getViewId());
    return null;
  }
  FleaseMessage response=null;
  if (msg.getMsgType() == FleaseMessage.MsgType.MSG_PREPARE)   response=handlePREPARE(msg);
 else   if (msg.getMsgType() == FleaseMessage.MsgType.MSG_ACCEPT)   response=handleACCEPT(msg);
 else   if (msg.getMsgType() == FleaseMessage.MsgType.MSG_LEARN)   handleLEARN(msg);
 else   Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",msg.toString());
  return response;
}",0.9777628032345014
113494,"/** 
 * Handles paxos prepare messages
 * @param msg the incomming message
 * @return a response message
 */
public FleaseMessage handlePREPARE(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg))) {
    if (Logging.isDebug()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str"");
    }
    FleaseMessage reject=new FleaseMessage(FleaseMessage.MsgType.MSG_PREPARE_NACK,msg);
    reject.setPrevProposalNo(cc.getPrepared().getProposalNo());
    reject.setLeaseHolder(null);
    reject.setLeaseTimeout(0);
    reject.setSendTimestamp(TimeSync.getGlobalTime());
    return reject;
  }
 else {
    if (Logging.isDebug()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ acced);
    }
    cc.setPrepared(msg);
    FleaseMessage response=new FleaseMessage(FleaseMessage.MsgType.MSG_PREPARE_ACK,msg);
    if (cc.getAccepted() != null) {
      response.setPrevProposalNo(cc.getAccepted().getProposalNo());
      response.setLeaseHolder(cc.getAccepted().getLeaseHolder());
      assert(response.getLeaseHolder() != null);
      response.setLeaseTimeout(cc.getAccepted().getLeaseTimeout());
    }
    response.setSendTimestamp(TimeSync.getGlobalTime());
    return response;
  }
}","/** 
 * Handles paxos prepare messages
 * @param msg the incomming message
 * @return a response message
 */
public FleaseMessage handlePREPARE(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg))) {
    if (Logging.isDebug() && config.isDebugPrintMessages()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str"");
    }
    FleaseMessage reject=new FleaseMessage(FleaseMessage.MsgType.MSG_PREPARE_NACK,msg);
    reject.setPrevProposalNo(cc.getPrepared().getProposalNo());
    reject.setLeaseHolder(null);
    reject.setLeaseTimeout(0);
    reject.setSendTimestamp(TimeSync.getGlobalTime());
    return reject;
  }
 else {
    if (Logging.isDebug() && config.isDebugPrintMessages()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ acced);
    }
    cc.setPrepared(msg);
    FleaseMessage response=new FleaseMessage(FleaseMessage.MsgType.MSG_PREPARE_ACK,msg);
    if (cc.getAccepted() != null) {
      response.setPrevProposalNo(cc.getAccepted().getProposalNo());
      response.setLeaseHolder(cc.getAccepted().getLeaseHolder());
      assert(response.getLeaseHolder() != null);
      response.setLeaseTimeout(cc.getAccepted().getLeaseTimeout());
    }
    response.setSendTimestamp(TimeSync.getGlobalTime());
    return response;
  }
}",0.983996120271581
113495,"/** 
 * Handles requests for lease information. Returns current lease holder+timeout or the current instance id.
 * @param msg incomming message
 * @return a response message
 */
public FleaseMessage getLocalLeaseInformation(ASCIIString cellId){
  FleaseAcceptorCell cc=getCell(cellId);
  if (cc.isLearned())   return new FleaseMessage(cc.getAccepted());
 else   return null;
}","/** 
 * Handles requests for lease information. Returns current lease holder+timeout or the current instance id.
 * @param msg incomming message
 * @return a response message
 */
public FleaseMessage getLocalLeaseInformation(ASCIIString cellId){
  FleaseAcceptorCell cc=getCell(cellId);
  return cc.getLatestLearn();
}",0.8575539568345324
113496,"/** 
 * Handles paxos accept (vote) messages.
 * @param msg incomming message
 * @return a response message or null
 */
public FleaseMessage handleACCEPT(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg))) {
    if (Logging.isDebug()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str"");
    }
    FleaseMessage tmp=new FleaseMessage(FleaseMessage.MsgType.MSG_ACCEPT_NACK,msg);
    tmp.setSendTimestamp(TimeSync.getGlobalTime());
    tmp.setLeaseHolder(null);
    tmp.setLeaseTimeout(0);
    tmp.setPrevProposalNo(cc.getPrepared().getProposalNo());
    return tmp;
  }
 else {
    if (Logging.isDebug()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ acced+ ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ msg.getLeaseHolder()+ ""String_Node_Str""+ msg.getLeaseTimeout());
    }
    assert(msg.getLeaseHolder() != null);
    cc.setAccepted(msg);
    cc.setPrepared(msg);
    FleaseMessage tmp=new FleaseMessage(FleaseMessage.MsgType.MSG_ACCEPT_ACK,msg);
    tmp.setSendTimestamp(TimeSync.getGlobalTime());
    return tmp;
  }
}","/** 
 * Handles paxos accept (vote) messages.
 * @param msg incomming message
 * @return a response message or null
 */
public FleaseMessage handleACCEPT(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg))) {
    if (Logging.isDebug() && config.isDebugPrintMessages()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str"");
    }
    FleaseMessage tmp=new FleaseMessage(FleaseMessage.MsgType.MSG_ACCEPT_NACK,msg);
    tmp.setSendTimestamp(TimeSync.getGlobalTime());
    tmp.setLeaseHolder(null);
    tmp.setLeaseTimeout(0);
    tmp.setPrevProposalNo(cc.getPrepared().getProposalNo());
    return tmp;
  }
 else {
    if (Logging.isDebug() && config.isDebugPrintMessages()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ acced+ ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ msg.getLeaseHolder()+ ""String_Node_Str""+ msg.getLeaseTimeout());
    }
    assert(msg.getLeaseHolder() != null);
    cc.setAccepted(msg);
    cc.setPrepared(msg);
    FleaseMessage tmp=new FleaseMessage(FleaseMessage.MsgType.MSG_ACCEPT_ACK,msg);
    tmp.setSendTimestamp(TimeSync.getGlobalTime());
    return tmp;
  }
}",0.9825765575501584
113497,"/** 
 * Handles paxos learn messages. Removes oudated instances and updates maxLearnedInstId accordingly
 * @param msg incomming message
 */
public void handleLEARN(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg))) {
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + msg.getProposalNo());
  }
 else {
    if (Logging.isDebug()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ acced+ ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ msg.getLeaseHolder()+ ""String_Node_Str""+ msg.getLeaseTimeout());
    }
    cc.setAccepted(msg);
    cc.setPrepared(msg);
    cc.setLatestLearn(msg);
    evtListener.learnedEvent(msg.getCellId(),msg.getLeaseHolder(),msg.getLeaseTimeout(),msg.getMasterEpochNumber());
  }
}","/** 
 * Handles paxos learn messages. Removes oudated instances and updates maxLearnedInstId accordingly
 * @param msg incomming message
 */
public void handleLEARN(FleaseMessage msg){
  final FleaseAcceptorCell cc=getCell(msg);
  cc.touch();
  if ((cc.getPrepared() != null) && (cc.getPrepared().after(msg)) || (cc.getAccepted() != null) && (cc.getAccepted().after(msg))) {
    if (Logging.isDebug() && config.isDebugPrintMessages())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + msg.getProposalNo());
  }
 else {
    if (Logging.isDebug() && config.isDebugPrintMessages()) {
      final String preped=(cc.getPrepared() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getPrepared().getProposalNo().toString();
      final String acced=(cc.getAccepted() == null) ? ProposalNumber.EMPTY_PROPOSAL_NUMBER.toString() : cc.getAccepted().getProposalNo() + ""String_Node_Str"" + cc.getAccepted().getLeaseHolder()+ ""String_Node_Str""+ cc.getAccepted().getLeaseTimeout();
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"" + preped + ""String_Node_Str""+ acced+ ""String_Node_Str""+ msg.getProposalNo()+ ""String_Node_Str""+ msg.getLeaseHolder()+ ""String_Node_Str""+ msg.getLeaseTimeout());
    }
    cc.setAccepted(msg);
    cc.setPrepared(msg);
    cc.setLatestLearn(msg);
    evtListener.learnedEvent(msg.getCellId(),msg.getLeaseHolder(),msg.getLeaseTimeout(),msg.getMasterEpochNumber());
  }
}",0.9542715349166964
113498,"public boolean isLearned(){
  if (accepted == null)   return false;
  return (accepted.getMsgType() == FleaseMessage.MsgType.MSG_LEARN);
}","public boolean isLearned(){
  return latestLearn.get() != null;
}",0.541871921182266
113499,"public void setLatestLearn(FleaseMessage msg){
  latestLearn.set(msg);
}","public void setLatestLearn(FleaseMessage msg){
  assert(msg.getMsgType() == FleaseMessage.MsgType.MSG_LEARN);
  latestLearn.set(msg);
}",0.6956521739130435
113500,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
  final FileAccessManager faMan=master.getFileAccessManager();
  final VolumeManager vMan=master.getVolumeManager();
  validateContext(rq);
  StorageManager sMan;
  FileMetadata file;
  String volumeId;
  if (rqArgs.hasFileId()) {
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFileId());
    volumeId=idRes.getVolumeId();
    sMan=vMan.getStorageManager(idRes.getVolumeId());
    file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  }
 else   if (rqArgs.hasVolumeName() && rqArgs.hasPath()) {
    final Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
    sMan=vMan.getStorageManagerByName(p.getComp(0));
    volumeId=sMan.getVolumeInfo().getId();
    final PathResolver res=new PathResolver(sMan,p);
    res.checkIfFileDoesNotExist();
    file=res.getFile();
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 else   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  if (file.isDirectory())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  if (sMan.getSoftlinkTarget(file.getId()) != null)   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  XLocList oldXLocList=file.getXLocList();
  assert(oldXLocList != null);
  int i=0;
  for (; i < oldXLocList.getReplicaCount(); i++) {
    XLoc replica=oldXLocList.getReplica(i);
    if (replica.getOSD(0).equals(rqArgs.getOsdUuid()))     break;
  }
  XLoc[] newReplList=new XLoc[oldXLocList.getReplicaCount() - 1];
  for (int j=0, count=0; j < oldXLocList.getReplicaCount(); j++)   if (j != i)   newReplList[count++]=oldXLocList.getReplica(j);
  XLocList newXLocList=sMan.createXLocList(newReplList,oldXLocList.getReplUpdatePolicy(),oldXLocList.getVersion() + 1);
  file.setXLocList(newXLocList);
  if (newXLocList.getReplicaCount() == 1)   file.setReadOnly(false);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  Capability deleteCap=new Capability(volumeId + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,master.getConfig().getCapabilityTimeout(),Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),file.getEpoch(),false,!sMan.getVolumeInfo().isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : sMan.getVolumeInfo().isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,sMan.getVolumeInfo().getCreationTime(),master.getConfig().getCapabilitySecret());
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(oldXLocList);
  FileCredentials fc=FileCredentials.newBuilder().setXcap(deleteCap.getXCap()).setXlocs(xLocSet).build();
  rq.setResponse(fc);
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (master.getReplMasterUUID() != null && !master.getReplMasterUUID().equals(master.getConfig().getUUID().toString()))   throw new DatabaseException(ExceptionType.REDIRECT);
  final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
  final FileAccessManager faMan=master.getFileAccessManager();
  final VolumeManager vMan=master.getVolumeManager();
  validateContext(rq);
  StorageManager sMan;
  FileMetadata file;
  String volumeId;
  if (rqArgs.hasFileId()) {
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFileId());
    volumeId=idRes.getVolumeId();
    sMan=vMan.getStorageManager(idRes.getVolumeId());
    file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(POSIXErrno.POSIX_ERROR_ENOENT,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  }
 else   if (rqArgs.hasVolumeName() && rqArgs.hasPath()) {
    final Path p=new Path(rqArgs.getVolumeName(),rqArgs.getPath());
    sMan=vMan.getStorageManagerByName(p.getComp(0));
    volumeId=sMan.getVolumeInfo().getId();
    final PathResolver res=new PathResolver(sMan,p);
    res.checkIfFileDoesNotExist();
    file=res.getFile();
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 else   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
  if (file.isDirectory())   throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  if (sMan.getSoftlinkTarget(file.getId()) != null)   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + rqArgs.getFileId() + ""String_Node_Str"");
  faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  XLocList oldXLocList=file.getXLocList();
  assert(oldXLocList != null);
  int i=0;
  for (; i < oldXLocList.getReplicaCount(); i++) {
    XLoc replica=oldXLocList.getReplica(i);
    if (replica.getOSD(0).equals(rqArgs.getOsdUuid()))     break;
  }
  if (i == oldXLocList.getReplicaCount())   throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + rqArgs.getOsdUuid() + ""String_Node_Str"");
  XLoc[] newReplList=new XLoc[oldXLocList.getReplicaCount() - 1];
  for (int j=0, count=0; j < oldXLocList.getReplicaCount(); j++)   if (j != i)   newReplList[count++]=oldXLocList.getReplica(j);
  XLocList newXLocList=sMan.createXLocList(newReplList,oldXLocList.getReplUpdatePolicy(),oldXLocList.getVersion() + 1);
  file.setXLocList(newXLocList);
  if (newXLocList.getReplicaCount() == 1)   file.setReadOnly(false);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  Capability deleteCap=new Capability(volumeId + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,master.getConfig().getCapabilityTimeout(),Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getSenderAddress()).getAddress().getHostAddress(),file.getEpoch(),false,!sMan.getVolumeInfo().isSnapshotsEnabled() ? SnapConfig.SNAP_CONFIG_SNAPS_DISABLED : sMan.getVolumeInfo().isSnapVolume() ? SnapConfig.SNAP_CONFIG_ACCESS_SNAP : SnapConfig.SNAP_CONFIG_ACCESS_CURRENT,sMan.getVolumeInfo().getCreationTime(),master.getConfig().getCapabilitySecret());
  XLocSet.Builder xLocSet=Converter.xLocListToXLocSet(oldXLocList);
  FileCredentials fc=FileCredentials.newBuilder().setXcap(deleteCap.getXCap()).setXlocs(xLocSet).build();
  rq.setResponse(fc);
  update.execute();
}",0.9772468714448236
113501,"/** 
 * removes replicas of all file in fileIDList which are on osdUUID
 * @param fileIDList
 * @param mrc
 * @param osdUUID
 * @throws InterruptedException
 * @throws IOException
 */
public void removeOriginalFromReplica(List<FileInformation> fileInfos) throws OSDDrainException {
  List<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  for (  FileInformation fileInfo : fileInfos) {
    RPCResponse<FileCredentials> resp=null;
    try {
      xtreemfs_replica_removeRequest replRemReq=xtreemfs_replica_removeRequest.newBuilder().setFileId(fileInfo.fileID).setOsdUuid(osdUUID.toString()).build();
      resp=mrcClient.xtreemfs_replica_remove(fileInfo.mrcAddress,password,userCreds,replRemReq);
      resp.get();
      finishedFileInfos.add(fileInfo);
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.REMOVE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (resp != null)       resp.freeBuffers();
    }
  }
}","/** 
 * removes replicas of all file in fileIDList which are on osdUUID
 * @param fileIDList
 * @param mrc
 * @param osdUUID
 * @throws InterruptedException
 * @throws IOException
 */
public void removeOriginalFromReplica(List<FileInformation> fileInfos) throws OSDDrainException {
  List<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  for (  FileInformation fileInfo : fileInfos) {
    RPCResponse<FileCredentials> resp=null;
    try {
      String headOSD=null;
      XLocSet xlocs=fileInfo.fileCredentials.getXlocs();
      for (      Replica xloc : xlocs.getReplicasList()) {
        if (xloc.getOsdUuidsList().contains(osdUUID.toString()))         headOSD=xloc.getOsdUuidsList().get(0);
      }
      assert(headOSD != null);
      xtreemfs_replica_removeRequest replRemReq=xtreemfs_replica_removeRequest.newBuilder().setFileId(fileInfo.fileID).setOsdUuid(headOSD).build();
      resp=mrcClient.xtreemfs_replica_remove(fileInfo.mrcAddress,password,userCreds,replRemReq);
      resp.get();
      finishedFileInfos.add(fileInfo);
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.REMOVE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (resp != null)       resp.freeBuffers();
    }
  }
}",0.8706650346797226
113502,"/** 
 * Create a new Replica for every fileID in fileIDList on a new OSD. OSDs will be chosen by get_suitable_osds MRC call.
 * @param fileIDList
 * @throws Exception
 */
public List<FileInformation> createReplicasForFiles(List<FileInformation> fileInfos) throws OSDDrainException {
  LinkedList<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  for (  FileInformation fileInfo : fileInfos) {
    RPCResponse<Replicas> replResp=null;
    Replicas reps=null;
    try {
      xtreemfs_replica_listRequest rlistReq=xtreemfs_replica_listRequest.newBuilder().setFileId(fileInfo.fileID).build();
      replResp=mrcClient.xtreemfs_replica_list(fileInfo.mrcAddress,password,userCreds,rlistReq);
      reps=replResp.get();
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (replResp != null)       replResp.freeBuffers();
    }
    Replica rep=reps.getReplicas(0);
    StripingPolicy sp=rep.getStripingPolicy();
    RPCResponse<xtreemfs_get_suitable_osdsResponse> sor=null;
    xtreemfs_get_suitable_osdsResponse suitOSDResp=null;
    try {
      xtreemfs_get_suitable_osdsRequest sosdsReq=xtreemfs_get_suitable_osdsRequest.newBuilder().setFileId(fileInfo.fileID).setNumOsds(1).build();
      sor=mrcClient.xtreemfs_get_suitable_osds(fileInfo.mrcAddress,password,userCreds,sosdsReq);
      suitOSDResp=sor.get();
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (sor != null)       sor.freeBuffers();
    }
    if (suitOSDResp.getOsdUuidsCount() == 0) {
      throw new OSDDrainException(""String_Node_Str"" + fileInfo.fileID,ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
    Replica replica=Replica.newBuilder().addOsdUuids(suitOSDResp.getOsdUuids(0)).setReplicationFlags(ReplicationFlags.setRandomStrategy(ReplicationFlags.setFullReplica(0))).setStripingPolicy(sp).build();
    fileInfo.newReplica=replica;
    RPCResponse<?> repAddResp=null;
    try {
      xtreemfs_replica_addRequest repAddReq=xtreemfs_replica_addRequest.newBuilder().setFileId(fileInfo.fileID).setNewReplica(replica).build();
      repAddResp=mrcClient.xtreemfs_replica_add(fileInfo.mrcAddress,password,userCreds,repAddReq);
      repAddResp.get();
      finishedFileInfos.add(fileInfo);
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (repAddResp != null)       repAddResp.freeBuffers();
    }
  }
  return finishedFileInfos;
}","/** 
 * Create a new Replica for every fileID in fileIDList on a new OSD. OSDs will be chosen by get_suitable_osds MRC call.
 * @param fileIDList
 * @throws Exception
 */
public List<FileInformation> createReplicasForFiles(List<FileInformation> fileInfos) throws OSDDrainException {
  LinkedList<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  for (  FileInformation fileInfo : fileInfos) {
    RPCResponse<Replicas> replResp=null;
    Replicas reps=null;
    try {
      xtreemfs_replica_listRequest rlistReq=xtreemfs_replica_listRequest.newBuilder().setFileId(fileInfo.fileID).build();
      replResp=mrcClient.xtreemfs_replica_list(fileInfo.mrcAddress,password,userCreds,rlistReq);
      reps=replResp.get();
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (replResp != null)       replResp.freeBuffers();
    }
    Replica rep=reps.getReplicas(0);
    StripingPolicy sp=rep.getStripingPolicy();
    RPCResponse<xtreemfs_get_suitable_osdsResponse> sor=null;
    xtreemfs_get_suitable_osdsResponse suitOSDResp=null;
    try {
      xtreemfs_get_suitable_osdsRequest sosdsReq=xtreemfs_get_suitable_osdsRequest.newBuilder().setFileId(fileInfo.fileID).setNumOsds(1).build();
      sor=mrcClient.xtreemfs_get_suitable_osds(fileInfo.mrcAddress,password,userCreds,sosdsReq);
      suitOSDResp=sor.get();
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (sor != null)       sor.freeBuffers();
    }
    if (suitOSDResp.getOsdUuidsCount() == 0) {
      throw new OSDDrainException(""String_Node_Str"" + fileInfo.fileID,ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
    sp=StripingPolicy.newBuilder().setType(sp.getType()).setStripeSize(sp.getStripeSize()).setWidth(1).build();
    Replica replica=Replica.newBuilder().addOsdUuids(suitOSDResp.getOsdUuids(0)).setReplicationFlags(ReplicationFlags.setRandomStrategy(ReplicationFlags.setFullReplica(0))).setStripingPolicy(sp).build();
    fileInfo.newReplica=replica;
    RPCResponse<?> repAddResp=null;
    try {
      xtreemfs_replica_addRequest repAddReq=xtreemfs_replica_addRequest.newBuilder().setFileId(fileInfo.fileID).setNewReplica(replica).build();
      repAddResp=mrcClient.xtreemfs_replica_add(fileInfo.mrcAddress,password,userCreds,repAddReq);
      repAddResp.get();
      finishedFileInfos.add(fileInfo);
    }
 catch (    Exception e) {
      if (Logging.isDebug()) {
        Logging.logError(Logging.LEVEL_WARN,this,e);
      }
      throw new OSDDrainException(e.getMessage(),ErrorState.CREATE_REPLICAS,fileInfos,finishedFileInfos);
    }
 finally {
      if (repAddResp != null)       repAddResp.freeBuffers();
    }
  }
  return finishedFileInfos;
}",0.9813891658358258
113503,"/** 
 * Polls MRC regularly to discover if replication is complete. Blocks until this event happens.
 * @param fileIDList
 * @throws Exception
 */
public List<FileInformation> waitForReplicationToComplete(List<FileInformation> fileInfos) throws OSDDrainException {
  List<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  List<FileInformation> toBeRemovedFileInfos=new LinkedList<FileInformation>();
  while (!fileInfos.isEmpty()) {
    for (    FileInformation fileInfo : fileInfos) {
      String fileID=fileInfo.fileID;
      FileCredentials fc=fileInfo.fileCredentials;
      Replica replica=fileInfo.newReplica;
      boolean isReplicated=true;
      StripingPolicyImpl sp=StripingPolicyImpl.getPolicy(replica,0);
      long lastObjectNo=sp.getObjectNoForOffset(fc.getXlocs().getReadOnlyFileSize() - 1);
      int osdRelPos=0;
      for (      String osdUUID : replica.getOsdUuidsList()) {
        RPCResponse<ObjectList> r=null;
        ObjectSet oSet=null;
        try {
          InetSocketAddress osdAddress=new ServiceUUID(osdUUID,resolver).getAddress();
          r=osdClient.xtreemfs_internal_get_object_set(osdAddress,password,userCreds,fc,fileID);
          ObjectList ol=r.get();
          byte[] serializedBitSet=ol.getSet().toByteArray();
          oSet=new ObjectSet(sp.getWidth(),osdRelPos,serializedBitSet);
        }
 catch (        Exception e) {
          if (Logging.isDebug()) {
            Logging.logError(Logging.LEVEL_WARN,this,e);
          }
          List<FileInformation> allInfos=new LinkedList<FileInformation>();
          allInfos.addAll(fileInfos);
          allInfos.addAll(finishedFileInfos);
          throw new OSDDrainException(e.getMessage(),ErrorState.WAIT_FOR_REPLICATION,finishedFileInfos,allInfos);
        }
 finally {
          if (r != null) {
            r.freeBuffers();
          }
        }
        for (long objNo=osdRelPos; objNo <= lastObjectNo; objNo+=sp.getWidth()) {
          if (oSet.contains(objNo) == false)           isReplicated=false;
        }
      }
      if (isReplicated) {
        toBeRemovedFileInfos.add(fileInfo);
        finishedFileInfos.add(fileInfo);
      }
    }
    fileInfos.removeAll(toBeRemovedFileInfos);
    toBeRemovedFileInfos.clear();
    if (fileInfos.isEmpty())     return finishedFileInfos;
    Logging.logMessage(Logging.LEVEL_INFO,Category.tool,this,""String_Node_Str"");
    try {
      Thread.sleep(10000);
    }
 catch (    Exception e) {
    }
  }
  return finishedFileInfos;
}","/** 
 * Polls MRC regularly to discover if replication is complete. Blocks until this event happens.
 * @param fileIDList
 * @throws Exception
 */
public List<FileInformation> waitForReplicationToComplete(List<FileInformation> fileInfos) throws OSDDrainException {
  List<FileInformation> finishedFileInfos=new LinkedList<FileInformation>();
  List<FileInformation> toBeRemovedFileInfos=new LinkedList<FileInformation>();
  while (!fileInfos.isEmpty()) {
    for (    FileInformation fileInfo : fileInfos) {
      String fileID=fileInfo.fileID;
      FileCredentials fc=fileInfo.fileCredentials;
      Replica replica=fileInfo.newReplica;
      boolean isReplicated=true;
      StripingPolicyImpl sp=StripingPolicyImpl.getPolicy(replica,0);
      long lastObjectNo=sp.getObjectNoForOffset(fc.getXlocs().getReadOnlyFileSize() - 1);
      int osdRelPos=0;
      for (      String osdUUID : replica.getOsdUuidsList()) {
        RPCResponse<ObjectList> r=null;
        ObjectSet oSet=null;
        try {
          InetSocketAddress osdAddress=new ServiceUUID(osdUUID,resolver).getAddress();
          r=osdClient.xtreemfs_internal_get_object_set(osdAddress,password,userCreds,fc,fileID);
          ObjectList ol=r.get();
          byte[] serializedBitSet=ol.getSet().toByteArray();
          oSet=new ObjectSet(sp.getWidth(),osdRelPos,serializedBitSet);
        }
 catch (        Exception e) {
          if (Logging.isDebug()) {
            Logging.logError(Logging.LEVEL_WARN,this,e);
          }
          List<FileInformation> allInfos=new LinkedList<FileInformation>();
          allInfos.addAll(fileInfos);
          allInfos.addAll(finishedFileInfos);
          throw new OSDDrainException(e.getMessage(),ErrorState.WAIT_FOR_REPLICATION,finishedFileInfos,allInfos);
        }
 finally {
          if (r != null) {
            r.freeBuffers();
          }
        }
        for (long objNo=osdRelPos; objNo <= lastObjectNo; objNo+=sp.getWidth()) {
          if (oSet.contains(objNo) == false)           isReplicated=false;
        }
      }
      if (isReplicated) {
        toBeRemovedFileInfos.add(fileInfo);
        finishedFileInfos.add(fileInfo);
      }
    }
    fileInfos.removeAll(toBeRemovedFileInfos);
    toBeRemovedFileInfos.clear();
    if (fileInfos.isEmpty())     return finishedFileInfos;
    Logging.logMessage(Logging.LEVEL_INFO,Category.tool,this,""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    Exception e) {
    }
  }
  return finishedFileInfos;
}",0.9993993993993994
113504,"/** 
 * send an request for a stage operation
 * @param rq the request
 * @param the method in the stage to execute
 */
protected void enqueueOperation(int stageOp,Object[] args,OSDRequest request,Object callback){
  if (!q.offer(new StageRequest(stageOp,args,request,callback))) {
    Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"",request.getRequestId(),request.getFileId());
    request.sendInternalServerError(new IllegalStateException(""String_Node_Str""));
  }
}","/** 
 * send an request for a stage operation
 * @param rq the request
 * @param the method in the stage to execute
 */
protected void enqueueOperation(int stageOp,Object[] args,OSDRequest request,Object callback){
  if (!q.offer(new StageRequest(stageOp,args,request,callback))) {
    if (request != null) {
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"",request.getRequestId(),request.getFileId());
      request.sendInternalServerError(new IllegalStateException(""String_Node_Str""));
    }
  }
}",0.962888665997994
113505,"/** 
 * Converts a string containing replication policy information to a <code>ReplicationPolicy</code> object.
 * @param sMan the storage manager
 * @param rpString the replication policy string
 * @return the replication policy
 */
public static ReplicationPolicy stringToReplicationPolicy(StorageManager sMan,String rpString){
  StringTokenizer st=new StringTokenizer(rpString,""String_Node_Str"");
  final String policy=st.nextToken();
  final int numRepls=Integer.parseInt(st.nextToken());
  final int flags=Integer.parseInt(st.nextToken());
  return new ReplicationPolicy(){
    @Override public String getName(){
      return policy;
    }
    @Override public int getFactor(){
      return numRepls;
    }
    @Override public int getFlags(){
      return flags;
    }
  }
;
}","/** 
 * Converts a string containing replication policy information to a <code>ReplicationPolicy</code> object.
 * @param sMan the storage manager
 * @param rpString the replication policy string
 * @return the replication policy
 */
public static ReplicationPolicy stringToReplicationPolicy(StorageManager sMan,String rpString){
  StringTokenizer st=new StringTokenizer(rpString,""String_Node_Str"");
  final String policy=rpString.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : st.nextToken();
  final int numRepls=Integer.parseInt(st.nextToken());
  final int flags=Integer.parseInt(st.nextToken());
  return new ReplicationPolicy(){
    @Override public String getName(){
      return policy;
    }
    @Override public int getFactor(){
      return numRepls;
    }
    @Override public int getFlags(){
      return flags;
    }
  }
;
}",0.9624615384615384
113506,"public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,FileAccessManager faMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  if (keyString.startsWith(VOL_ATTR_PREFIX + ""String_Node_Str""))   return getVolAttrValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + key + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        try {
          return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList,osdMan);
        }
 catch (        UnknownUUIDException exc) {
          throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + SysAttrs.locations.name() + ""String_Node_Str""+ exc);
        }
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
final String hostname=(config.getHostName().length() > 0) ? config.getHostName() : addr.getAddress().getCanonicalHostName();
return config.getURLScheme() + ""String_Node_Str"" + hostname+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
try {
ServiceSet.Builder srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs.getServicesList()) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
 catch (UnknownUUIDException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + SysAttrs.usable_osds.name() + ""String_Node_Str""+ exc);
}
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1 || sMan.getVolumeInfo().isSnapVolume()) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
Arrays.sort(snaps);
for (String snap : snaps) {
if (snap.equals(""String_Node_Str"")) continue;
sb.append(snap);
sb.append(""String_Node_Str"");
}
return sb.toString();
}
case snapshots_enabled:
return file.getId() == 1 && !sMan.getVolumeInfo().isSnapVolume() ? String.valueOf(sMan.getVolumeInfo().isSnapshotsEnabled()) : ""String_Node_Str"";
case snapshot_time:
return file.getId() == 1 && sMan.getVolumeInfo().isSnapVolume() ? Long.toString(sMan.getVolumeInfo().getCreationTime()) : ""String_Node_Str"";
case acl:
Map<String,Object> acl;
try {
acl=faMan.getACLEntries(sMan,file);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
if (acl != null) {
StringBuilder sb=new StringBuilder();
int i=0;
for (Entry<String,Object> entry : acl.entrySet()) {
sb.append(entry.getKey());
sb.append(""String_Node_Str"");
sb.append(entry.getValue());
if (i < acl.size() - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
case default_rp:
if (!file.isDirectory()) return ""String_Node_Str"";
ReplicationPolicy rp=sMan.getDefaultReplicationPolicy(file.getId());
if (rp == null) return ""String_Node_Str"";
return Converter.replicationPolicyToJSONString(rp);
}
}
return ""String_Node_Str"";
}","public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,FileAccessManager faMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  if (keyString.startsWith(VOL_ATTR_PREFIX + ""String_Node_Str""))   return getVolAttrValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        try {
          return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList,osdMan);
        }
 catch (        UnknownUUIDException exc) {
          throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + SysAttrs.locations.name() + ""String_Node_Str""+ exc);
        }
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
final String hostname=(config.getHostName().length() > 0) ? config.getHostName() : addr.getAddress().getCanonicalHostName();
return config.getURLScheme() + ""String_Node_Str"" + hostname+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
try {
ServiceSet.Builder srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs.getServicesList()) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
 catch (UnknownUUIDException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EIO,""String_Node_Str"" + SysAttrs.usable_osds.name() + ""String_Node_Str""+ exc);
}
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1 || sMan.getVolumeInfo().isSnapVolume()) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
Arrays.sort(snaps);
for (String snap : snaps) {
if (snap.equals(""String_Node_Str"")) continue;
sb.append(snap);
sb.append(""String_Node_Str"");
}
return sb.toString();
}
case snapshots_enabled:
return file.getId() == 1 && !sMan.getVolumeInfo().isSnapVolume() ? String.valueOf(sMan.getVolumeInfo().isSnapshotsEnabled()) : ""String_Node_Str"";
case snapshot_time:
return file.getId() == 1 && sMan.getVolumeInfo().isSnapVolume() ? Long.toString(sMan.getVolumeInfo().getCreationTime()) : ""String_Node_Str"";
case acl:
Map<String,Object> acl;
try {
acl=faMan.getACLEntries(sMan,file);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
if (acl != null) {
StringBuilder sb=new StringBuilder();
int i=0;
for (Entry<String,Object> entry : acl.entrySet()) {
sb.append(entry.getKey());
sb.append(""String_Node_Str"");
sb.append(entry.getValue());
if (i < acl.size() - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
case default_rp:
if (!file.isDirectory()) return ""String_Node_Str"";
ReplicationPolicy rp=sMan.getDefaultReplicationPolicy(file.getId());
if (rp == null) return ""String_Node_Str"";
return Converter.replicationPolicyToJSONString(rp);
}
}
return ""String_Node_Str"";
}",0.9994094488188976
113507,"public static void setSysAttrValue(StorageManager sMan,VolumeManager vMan,FileAccessManager faMan,long parentId,FileMetadata file,String keyString,String value,AtomicDBUpdate update) throws UserException, DatabaseException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str"")) {
    setPolicyValue(sMan,keyString,value,update);
    return;
  }
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + key + ""String_Node_Str"");
  }
switch (key) {
case default_sp:
    if (!file.isDirectory())     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  try {
    org.xtreemfs.pbrpc.generatedinterfaces.GlobalTypes.StripingPolicy sp=null;
    sp=Converter.jsonStringToStripingPolicy(value);
    if (file.getId() == 1 && sp == null)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    sMan.setDefaultStripingPolicy(file.getId(),sp,update);
  }
 catch (  JSONException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  ClassCastException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  NullPointerException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
break;
case osel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setOsdPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case rsel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setReplicaPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case read_only:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
boolean readOnly=Boolean.valueOf(value);
if (!readOnly && file.getXLocList() != null && file.getXLocList().getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
if (file.getXLocList() != null) {
XLocList xLoc=file.getXLocList();
XLoc[] replicas=new XLoc[xLoc.getReplicaCount()];
for (int i=0; i < replicas.length; i++) replicas[i]=xLoc.getReplica(i);
replicas[0].setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(replicas[0].getReplicationFlags())));
XLocList newXLoc=sMan.createXLocList(replicas,readOnly ? ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,xLoc.getVersion() + 1);
file.setXLocList(newXLoc);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
}
file.setReadOnly(readOnly);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case snapshots:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"");
int index=value.indexOf(""String_Node_Str"");
String command=null;
String name=null;
try {
command=value.substring(0,index);
name=value.substring(index + 1);
}
 catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
if (command.charAt(0) == 'c') vMan.createSnapshot(sMan.getVolumeInfo().getId(),name,parentId,file,command.equals(""String_Node_Str""));
 else if (command.equals(""String_Node_Str"")) vMan.deleteSnapshot(sMan.getVolumeInfo().getId(),file,name);
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
break;
case snapshots_enabled:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
boolean enable=Boolean.parseBoolean(value);
sMan.getVolumeInfo().setAllowSnaps(enable,update);
break;
case mark_replica_complete:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
XLocList xlocs=file.getXLocList();
XLoc[] xlocArray=new XLoc[xlocs.getReplicaCount()];
Iterator<XLoc> it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) {
XLoc xloc=it.next();
if (value.equals(xloc.getOSD(0))) xloc.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(xloc.getReplicationFlags()));
xlocArray[i]=xloc;
}
XLocList newXLocList=sMan.createXLocList(xlocArray,xlocs.getReplUpdatePolicy(),xlocs.getVersion());
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case acl:
index=value.indexOf(""String_Node_Str"");
try {
command=value.substring(0,index);
String params=value.substring(index + 1);
if (command.equals(""String_Node_Str"")) {
int index2=params.lastIndexOf(':');
String entity=params.substring(0,index2);
String rights=params.substring(index2 + 1);
Map<String,Object> entries=new HashMap<String,Object>();
entries.put(entity,rights);
faMan.updateACLEntries(sMan,file,parentId,entries,update);
}
 else if (command.equals(""String_Node_Str"")) {
List<Object> entries=new ArrayList<Object>(1);
entries.add(params);
faMan.removeACLEntries(sMan,file,parentId,entries,update);
}
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + command);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
break;
case set_repl_update_policy:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
xlocs=file.getXLocList();
xlocArray=new XLoc[xlocs.getReplicaCount()];
it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) xlocArray[i]=it.next();
String replUpdatePolicy=xlocs.getReplUpdatePolicy();
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
if (xlocs.getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE + ""String_Node_Str""+ xlocs.getReplicaCount()+ ""String_Node_Str"");
}
if (!ReplicaUpdatePolicies.REPL_UPDATE_PC_WARA.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)&& !ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
newXLocList=sMan.createXLocList(xlocArray,value,xlocs.getVersion() + 1);
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case default_rp:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
try {
ReplicationPolicy rp=null;
rp=Converter.jsonStringToReplicationPolicy(value);
sMan.setDefaultReplicationPolicy(file.getId(),rp,update);
}
 catch (JSONException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (ClassCastException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (NullPointerException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (IllegalArgumentException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
default :
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + key + ""String_Node_Str"");
}
}","public static void setSysAttrValue(StorageManager sMan,VolumeManager vMan,FileAccessManager faMan,long parentId,FileMetadata file,String keyString,String value,AtomicDBUpdate update) throws UserException, DatabaseException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str"")) {
    setPolicyValue(sMan,keyString,value,update);
    return;
  }
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
switch (key) {
case default_sp:
    if (!file.isDirectory())     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
  try {
    org.xtreemfs.pbrpc.generatedinterfaces.GlobalTypes.StripingPolicy sp=null;
    sp=Converter.jsonStringToStripingPolicy(value);
    if (file.getId() == 1 && sp == null)     throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
    sMan.setDefaultStripingPolicy(file.getId(),sp,update);
  }
 catch (  JSONException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  ClassCastException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  NullPointerException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
catch (  IllegalArgumentException exc) {
    throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
  }
break;
case osel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setOsdPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case rsel_policy:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
try {
short[] newPol=Converter.stringToShortArray(value);
sMan.getVolumeInfo().setReplicaPolicy(newPol,update);
}
 catch (NumberFormatException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
case read_only:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
boolean readOnly=Boolean.valueOf(value);
if (!readOnly && file.getXLocList() != null && file.getXLocList().getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
if (file.getXLocList() != null) {
XLocList xLoc=file.getXLocList();
XLoc[] replicas=new XLoc[xLoc.getReplicaCount()];
for (int i=0; i < replicas.length; i++) replicas[i]=xLoc.getReplica(i);
replicas[0].setReplicationFlags(ReplicationFlags.setFullReplica(ReplicationFlags.setReplicaIsComplete(replicas[0].getReplicationFlags())));
XLocList newXLoc=sMan.createXLocList(replicas,readOnly ? ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY : ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE,xLoc.getVersion() + 1);
file.setXLocList(newXLoc);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
}
file.setReadOnly(readOnly);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case snapshots:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_ENOTDIR,""String_Node_Str"");
int index=value.indexOf(""String_Node_Str"");
String command=null;
String name=null;
try {
command=value.substring(0,index);
name=value.substring(index + 1);
}
 catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
if (command.charAt(0) == 'c') vMan.createSnapshot(sMan.getVolumeInfo().getId(),name,parentId,file,command.equals(""String_Node_Str""));
 else if (command.equals(""String_Node_Str"")) vMan.deleteSnapshot(sMan.getVolumeInfo().getId(),file,name);
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
break;
case snapshots_enabled:
if (file.getId() != 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
boolean enable=Boolean.parseBoolean(value);
sMan.getVolumeInfo().setAllowSnaps(enable,update);
break;
case mark_replica_complete:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
XLocList xlocs=file.getXLocList();
XLoc[] xlocArray=new XLoc[xlocs.getReplicaCount()];
Iterator<XLoc> it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) {
XLoc xloc=it.next();
if (value.equals(xloc.getOSD(0))) xloc.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(xloc.getReplicationFlags()));
xlocArray[i]=xloc;
}
XLocList newXLocList=sMan.createXLocList(xlocArray,xlocs.getReplUpdatePolicy(),xlocs.getVersion());
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case acl:
index=value.indexOf(""String_Node_Str"");
try {
command=value.substring(0,index);
String params=value.substring(index + 1);
if (command.equals(""String_Node_Str"")) {
int index2=params.lastIndexOf(':');
String entity=params.substring(0,index2);
String rights=params.substring(index2 + 1);
Map<String,Object> entries=new HashMap<String,Object>();
entries.put(entity,rights);
faMan.updateACLEntries(sMan,file,parentId,entries,update);
}
 else if (command.equals(""String_Node_Str"")) {
List<Object> entries=new ArrayList<Object>(1);
entries.add(params);
faMan.removeACLEntries(sMan,file,parentId,entries,update);
}
 else throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + command);
}
 catch (MRCException e) {
Logging.logError(Logging.LEVEL_ERROR,null,e);
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL);
}
catch (Exception exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
}
break;
case set_repl_update_policy:
if (file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EISDIR,""String_Node_Str"");
xlocs=file.getXLocList();
xlocArray=new XLoc[xlocs.getReplicaCount()];
it=xlocs.iterator();
for (int i=0; it.hasNext(); i++) xlocArray[i]=it.next();
String replUpdatePolicy=xlocs.getReplUpdatePolicy();
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(replUpdatePolicy)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"");
if (ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)) {
if (xlocs.getReplicaCount() > 1) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE + ""String_Node_Str""+ xlocs.getReplicaCount()+ ""String_Node_Str"");
}
if (!ReplicaUpdatePolicies.REPL_UPDATE_PC_WARA.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_WARONE.equals(value) && !ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE.equals(value)&& !ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY.equals(value)) throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
newXLocList=sMan.createXLocList(xlocArray,value,xlocs.getVersion() + 1);
file.setXLocList(newXLocList);
sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
break;
case default_rp:
if (!file.isDirectory()) throw new UserException(POSIXErrno.POSIX_ERROR_EPERM,""String_Node_Str"");
try {
ReplicationPolicy rp=null;
rp=Converter.jsonStringToReplicationPolicy(value);
sMan.setDefaultReplicationPolicy(file.getId(),rp,update);
}
 catch (JSONException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (ClassCastException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (NullPointerException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
catch (IllegalArgumentException exc) {
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + value);
}
break;
default :
throw new UserException(POSIXErrno.POSIX_ERROR_EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
}
}",0.9992397364419664
113508,"public int compareTo(OpenFileTableEntry e){
  int res=0;
  if (this.expTime < e.expTime) {
    res=-1;
  }
 else   if (this.expTime == e.expTime) {
    res=this.fileId.compareTo(e.fileId);
  }
 else {
    res=1;
  }
  return res;
}","public int compareTo(OpenFileTableEntry e){
  int res=0;
  if (this.expTime < e.expTime) {
    res=-1;
  }
 else   if (this.expTime == e.expTime) {
    res=e.fileId == null ? -1 : this.fileId.compareTo(e.fileId);
  }
 else {
    res=1;
  }
  return res;
}",0.8847736625514403
113509,"protected StorageLayout(OSDConfig config,MetadataCache cache) throws IOException {
  this.cache=cache;
  String tmp=config.getObjDir();
  if (!tmp.endsWith(""String_Node_Str""))   tmp=tmp + ""String_Node_Str"";
  storageDir=tmp;
  File stdir=new File(storageDir);
  stdir.mkdirs();
  File versionMetaFile=new File(storageDir,VERSION_FILENAME);
  if (versionMetaFile.exists()) {
    FileReader in=new FileReader(versionMetaFile);
    char[] text=new char[(int)versionMetaFile.length()];
    in.read(text);
    in.close();
    int versionOnDisk=Integer.valueOf(new String(text));
    if (!isCompatibleVersion(versionOnDisk)) {
      throw new IOException(""String_Node_Str"" + versionOnDisk + ""String_Node_Str""+ this.getClass().getSimpleName());
    }
  }
  FileWriter out=new FileWriter(versionMetaFile);
  out.write(Integer.toString(getLayoutVersionTag()));
  out.close();
}","protected StorageLayout(OSDConfig config,MetadataCache cache) throws IOException {
  this.cache=cache;
  String tmp=config.getObjDir();
  if (!tmp.endsWith(""String_Node_Str""))   tmp=tmp + ""String_Node_Str"";
  storageDir=tmp;
  File stdir=new File(storageDir);
  stdir.mkdirs();
  File versionMetaFile=new File(storageDir,VERSION_FILENAME);
  if (versionMetaFile.exists()) {
    FileReader in=new FileReader(versionMetaFile);
    char[] text=new char[(int)versionMetaFile.length()];
    in.read(text);
    in.close();
    int versionOnDisk=Integer.valueOf(new String(text));
    if (!isCompatibleVersion(versionOnDisk)) {
      throw new IOException(""String_Node_Str"" + versionOnDisk + ""String_Node_Str""+ this.getClass().getSimpleName());
    }
  }
  final File tmpFile=new File(versionMetaFile + ""String_Node_Str"");
  FileWriter out=new FileWriter(tmpFile);
  out.write(Integer.toString(getLayoutVersionTag()));
  out.close();
  tmpFile.renameTo(versionMetaFile);
}",0.8717948717948718
113510,"public static void main(String[] args){
  try {
    CLOptionParser parser=new CLOptionParser(""String_Node_Str"");
    CLOption.StringValue optVolname=(StringValue)parser.addOption(new CLOption.StringValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPath=(StringValue)parser.addOption(new CLOption.StringValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPKCS12file=(CLOption.StringValue)parser.addOption(new CLOption.StringValue(null,""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPKCS12passphrase=(CLOption.StringValue)parser.addOption(new CLOption.StringValue(null,""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optRandomOnly=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.IntegerValue optReplicas=(IntegerValue)parser.addOption(new CLOption.IntegerValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optTrunc=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optAddR=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    parser.parse(args);
    final List<String> arguments=parser.getArguments();
    Logging.start(Logging.LEVEL_WARN);
    TimeSync.initializeLocal(10000,50);
    if (arguments.size() != 1) {
      usage();
      return;
    }
    final String path=optPath.isSet() ? optPath.getValue() : ""String_Node_Str"";
    final String volname=optVolname.isSet() ? optVolname.getValue() : ""String_Node_Str"";
    final ONCRPCServiceURL dirURL=new ONCRPCServiceURL(arguments.get(0),XDRUtils.ONCRPC_SCHEME,DIRInterface.ONC_RPC_PORT_DEFAULT);
    final boolean useSSL=dirURL.getProtocol().equals(XDRUtils.ONCRPCG_SCHEME) || dirURL.getProtocol().equals(XDRUtils.ONCRPCS_SCHEME);
    final boolean randomOnly=optRandomOnly.isSet();
    final boolean addReplica=optAddR.isSet();
    final int replicas=optReplicas.isSet() ? optReplicas.getValue() : 1;
    SSLOptions sslOptions=null;
    if (useSSL) {
      if (!optPKCS12file.isSet())       throw new InvalidUsageException(""String_Node_Str"" + optPKCS12file.getName());
      if (!optPKCS12passphrase.isSet())       throw new InvalidUsageException(""String_Node_Str"" + optPKCS12passphrase.getName());
      final boolean gridSSL=dirURL.getProtocol().equals(XDRUtils.ONCRPCG_SCHEME);
      sslOptions=new SSLOptions(new FileInputStream(optPKCS12file.getValue()),optPKCS12passphrase.getValue(),""String_Node_Str"",null,null,""String_Node_Str"",false,gridSSL);
    }
    Client c=new Client(new InetSocketAddress[]{new InetSocketAddress(dirURL.getHost(),dirURL.getPort())},30 * 1000,5 * 60 * 1000,sslOptions);
    c.start();
    System.out.println(""String_Node_Str"");
    final int MIN_FS=64 * 1024;
    final int MAX_FS=512 * 1024 * 1024;
    final int MIN_REC=4 * 1024;
    final int MAX_REC=1024 * 1024;
    List<String> grs=new ArrayList(1);
    grs.add(""String_Node_Str"");
    final UserCredentials uc=MRCClient.getCredentials(""String_Node_Str"",grs);
    try {
      StripingPolicy sp=new StripingPolicy(StripingPolicyType.STRIPING_POLICY_RAID0,128,1);
      c.createVolume(volname,uc,sp,AccessControlPolicyType.ACCESS_CONTROL_POLICY_POSIX.intValue(),0777);
    }
 catch (    Exception ex) {
    }
    Volume v=c.getVolume(volname,uc);
    if (replicas > 1) {
      File f=v.getFile(""String_Node_Str"");
      f.setDefaultReplication(Constants.REPL_UPDATE_PC_WARONE,replicas);
    }
    RandomAccessFile tmp=v.getFile(path + ""String_Node_Str"").open(""String_Node_Str"",0666);
    if (!randomOnly) {
      for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
        for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
          if (testSequential_write(fsize,recsize,path,v)) {
            continue;
          }
        }
      }
      System.out.println(""String_Node_Str"");
      Thread.sleep(100 * 1000);
      int readRepl=replicas - 1;
      if (addReplica) {
        for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
          for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
            File f=v.getFile(path + ""String_Node_Str"" + fsize+ ""String_Node_Str""+ recsize);
            f.addReplica(1,f.getSuitableOSDs(1),0);
          }
        }
        readRepl=replicas;
      }
      for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
        for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
          if (testSequential_read(fsize,recsize,path,v,readRepl)) {
            continue;
          }
        }
      }
    }
    System.out.println(""String_Node_Str"");
    c.stop();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}","public static void main(String[] args){
  try {
    CLOptionParser parser=new CLOptionParser(""String_Node_Str"");
    CLOption.StringValue optVolname=(StringValue)parser.addOption(new CLOption.StringValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPath=(StringValue)parser.addOption(new CLOption.StringValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPKCS12file=(CLOption.StringValue)parser.addOption(new CLOption.StringValue(null,""String_Node_Str"",""String_Node_Str""));
    CLOption.StringValue optPKCS12passphrase=(CLOption.StringValue)parser.addOption(new CLOption.StringValue(null,""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optRandomOnly=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.IntegerValue optReplicas=(IntegerValue)parser.addOption(new CLOption.IntegerValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optTrunc=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    CLOption.Switch optAddR=(Switch)parser.addOption(new CLOption.Switch(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    parser.parse(args);
    final List<String> arguments=parser.getArguments();
    Logging.start(Logging.LEVEL_WARN);
    TimeSync.initializeLocal(10000,50);
    if (arguments.size() != 1) {
      usage();
      return;
    }
    final String path=optPath.isSet() ? optPath.getValue() : ""String_Node_Str"";
    final String volname=optVolname.isSet() ? optVolname.getValue() : ""String_Node_Str"";
    final ONCRPCServiceURL dirURL=new ONCRPCServiceURL(arguments.get(0),XDRUtils.ONCRPC_SCHEME,DIRInterface.ONC_RPC_PORT_DEFAULT);
    final boolean useSSL=dirURL.getProtocol().equals(XDRUtils.ONCRPCG_SCHEME) || dirURL.getProtocol().equals(XDRUtils.ONCRPCS_SCHEME);
    final boolean randomOnly=optRandomOnly.isSet();
    final boolean addReplica=optAddR.isSet();
    final int replicas=optReplicas.isSet() ? optReplicas.getValue() : 1;
    SSLOptions sslOptions=null;
    if (useSSL) {
      if (!optPKCS12file.isSet())       throw new InvalidUsageException(""String_Node_Str"" + optPKCS12file.getName());
      if (!optPKCS12passphrase.isSet())       throw new InvalidUsageException(""String_Node_Str"" + optPKCS12passphrase.getName());
      final boolean gridSSL=dirURL.getProtocol().equals(XDRUtils.ONCRPCG_SCHEME);
      sslOptions=new SSLOptions(new FileInputStream(optPKCS12file.getValue()),optPKCS12passphrase.getValue(),""String_Node_Str"",null,null,""String_Node_Str"",false,gridSSL);
    }
    Client c=new Client(new InetSocketAddress[]{new InetSocketAddress(dirURL.getHost(),dirURL.getPort())},30 * 1000,5 * 60 * 1000,sslOptions);
    c.start();
    System.out.println(""String_Node_Str"");
    final int MIN_FS=64 * 1024;
    final int MAX_FS=512 * 1024 * 1024;
    final int MIN_REC=4 * 1024;
    final int MAX_REC=1024 * 1024;
    List<String> grs=new ArrayList(1);
    grs.add(""String_Node_Str"");
    final UserCredentials uc=MRCClient.getCredentials(""String_Node_Str"",grs);
    try {
      StripingPolicy sp=new StripingPolicy(StripingPolicyType.STRIPING_POLICY_RAID0,128,1);
      c.createVolume(volname,uc,sp,AccessControlPolicyType.ACCESS_CONTROL_POLICY_POSIX.intValue(),0777);
    }
 catch (    Exception ex) {
    }
    Volume v=c.getVolume(volname,uc);
    if (replicas > 1) {
      File f=v.getFile(""String_Node_Str"");
      f.setDefaultReplication(Constants.REPL_UPDATE_PC_WARONE,replicas);
    }
    RandomAccessFile tmp=v.getFile(path + ""String_Node_Str"").open(""String_Node_Str"",0666);
    if (!randomOnly) {
      for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
        for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
          if (testSequential_write(fsize,recsize,path,v)) {
            continue;
          }
        }
      }
      System.out.println(""String_Node_Str"");
      Thread.sleep(100 * 1000);
      int readRepl=replicas - 1;
      if (addReplica) {
        for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
          for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
            final int numRecs=fsize / recsize;
            if (numRecs == 0) {
              break;
            }
            File f=v.getFile(path + ""String_Node_Str"" + fsize+ ""String_Node_Str""+ recsize);
            f.addReplica(1,f.getSuitableOSDs(1),0);
          }
        }
        readRepl=replicas;
      }
      for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
        for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
          if (testSequential_read(fsize,recsize,path,v,readRepl)) {
            continue;
          }
        }
      }
    }
    System.out.println(""String_Node_Str"");
    c.stop();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}",0.9883124871847448
113511,"@Override public void responseAvailable(RPCResponse r){
  try {
    Object res=r.get();
    ((Decoder)result.getDecoder()).setResult(res);
    if (update && depth != 0) {
      assert(address != null);
      root.updateDefaultServerAddress(address);
    }
  }
 catch (  RedirectException e) {
    if (e.getAddress() != null && depth < tries) {
      InetSocketAddress newAddress=new InetSocketAddress(e.getAddress(),e.getPort());
      if (!newAddress.equals(this.address)) {
        this.otherServers.add(this.address);
        redirect(newAddress);
      }
 else {
        Logging.logMessage(Logging.LEVEL_INFO,this.root,""String_Node_Str"" + ""String_Node_Str"",this.address.toString());
        if (this.otherServers != null && this.otherServers.size() != 0) {
          reconnect();
        }
 else {
          result.fill(r);
          return;
        }
      }
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e.getAddress(),depth);
    }
  }
catch (  InvalidArgumentException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getError_message());
    Logging.logError(Logging.LEVEL_DEBUG,this,e);
  }
catch (  ONCRPCException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getMessage());
    Logging.logError(Logging.LEVEL_INFO,this,e);
  }
catch (  Exception e) {
    Logging.logMessage(Logging.LEVEL_WARN,root,""String_Node_Str"",((address != null) ? address : root.getDefaultServerAddress()),e.getMessage());
    if (otherServers != null && otherServers.size() > 0) {
      reconnect();
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"");
      Logging.logError(Logging.LEVEL_DEBUG,this,e);
    }
  }
  result.fill(r);
}","@Override public void responseAvailable(RPCResponse r){
  try {
    Object res=r.get();
    ((Decoder)result.getDecoder()).setResult(res);
    if (update && depth != 0) {
      assert(address != null);
      root.updateDefaultServerAddress(address);
    }
  }
 catch (  RedirectException e) {
    if (e.getAddress() != null && depth < tries) {
      InetSocketAddress newAddress=new InetSocketAddress(e.getAddress(),e.getPort());
      if (!newAddress.equals(this.address)) {
        if (this.address != null)         this.otherServers.add(this.address);
        redirect(newAddress);
      }
 else {
        Logging.logMessage(Logging.LEVEL_INFO,this.root,""String_Node_Str"" + ""String_Node_Str"",this.address.toString());
        if (this.otherServers != null && this.otherServers.size() != 0) {
          reconnect();
        }
 else {
          result.fill(r);
          return;
        }
      }
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e.getAddress(),depth);
    }
  }
catch (  InvalidArgumentException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getError_message());
    Logging.logError(Logging.LEVEL_DEBUG,this,e);
  }
catch (  ONCRPCException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getMessage());
    Logging.logError(Logging.LEVEL_INFO,this,e);
  }
catch (  Exception e) {
    Logging.logMessage(Logging.LEVEL_WARN,root,""String_Node_Str"",((address != null) ? address : root.getDefaultServerAddress()),e.getMessage());
    if (otherServers != null && otherServers.size() > 0) {
      reconnect();
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"");
      Logging.logError(Logging.LEVEL_DEBUG,this,e);
    }
  }
  result.fill(r);
}",0.9912190082644629
113512,"/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && dbsReplicationManager != null && ((error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS)) || (error instanceof ConcurrentModificationException && dbsReplicationManager.isMaster()))) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      InetAddress host=this.master.getConfig().getAddress();
      int port=this.master.getConfig().getPort();
      InetSocketAddress address=(host == null) ? new InetSocketAddress(port) : new InetSocketAddress(host,port);
      rq.sendRedirectException(address.getAddress().getHostAddress(),port);
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}","/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && dbsReplicationManager != null && ((error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS)) || (error instanceof ConcurrentModificationException && !dbsReplicationManager.isMaster()))) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      InetAddress host=this.master.getConfig().getAddress();
      int port=this.master.getConfig().getPort();
      InetSocketAddress address=(host == null) ? new InetSocketAddress(port) : new InetSocketAddress(host,port);
      rq.sendRedirectException(address.getAddress().getHostAddress(),port);
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}",0.9997741133950756
113513,"private void processPrepareOp(StageRequest method){
  final RWReplicationCallback callback=(RWReplicationCallback)method.getCallback();
  try {
    final FileCredentials credentials=(FileCredentials)method.getArgs()[0];
    final XLocations loc=(XLocations)method.getArgs()[1];
    final Long objVersion=(Long)method.getArgs()[3];
    final Operation op=(Operation)method.getArgs()[4];
    final String fileId=credentials.getXcap().getFile_id();
    ReplicatedFileState state=getState(credentials,loc,false);
    if ((op == Operation.INTERNAL_UPDATE) || (op == Operation.INTERNAL_TRUNCATE)) {
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,state.getState());
          }
          if (state.getPendingRequests().size() > MAX_PENDING_PER_FILE) {
            callback.failed(new OSDException(ErrorCodes.IO_ERROR,""String_Node_Str"",""String_Node_Str""));
          }
 else {
            state.getPendingRequests().add(method);
          }
          return;
        }
    }
    boolean needsReset=state.getPolicy().onRemoteUpdate(objVersion,state.getState());
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,needsReset);
    }
    if (needsReset) {
      state.getPendingRequests().add(method);
      doReset(state,objVersion);
    }
 else {
      callback.success(0);
    }
  }
 else {
    state.setCredentials(credentials);
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
        state.getPendingRequests().add(method);
        return;
      }
case OPEN:
{
      state.getPendingRequests().add(method);
      doWaitingForLease(state);
      return;
    }
}
long newVersion=state.getPolicy().onClientOperation(op,objVersion,state.getState(),state.getLease());
callback.success(newVersion);
}
}
 catch (RedirectException ex) {
callback.redirect(ex);
}
catch (Exception ex) {
ex.printStackTrace();
callback.failed(ex);
}
}","private void processPrepareOp(StageRequest method){
  final RWReplicationCallback callback=(RWReplicationCallback)method.getCallback();
  try {
    final FileCredentials credentials=(FileCredentials)method.getArgs()[0];
    final XLocations loc=(XLocations)method.getArgs()[1];
    final Long objVersion=(Long)method.getArgs()[3];
    final Operation op=(Operation)method.getArgs()[4];
    final String fileId=credentials.getXcap().getFile_id();
    ReplicatedFileState state=getState(credentials,loc,false);
    if ((op == Operation.INTERNAL_UPDATE) || (op == Operation.INTERNAL_TRUNCATE)) {
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
case OPEN:
{
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,state.getState());
          }
          if (state.getPendingRequests().size() > MAX_PENDING_PER_FILE) {
            callback.failed(new OSDException(ErrorCodes.IO_ERROR,""String_Node_Str"",""String_Node_Str""));
          }
 else {
            state.getPendingRequests().add(method);
          }
          if (state.getState() == ReplicaState.OPEN) {
            doBackup(state);
          }
          return;
        }
    }
    boolean needsReset=state.getPolicy().onRemoteUpdate(objVersion,state.getState());
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileId,needsReset);
    }
    if (needsReset) {
      state.getPendingRequests().add(method);
      doReset(state,objVersion);
    }
 else {
      callback.success(0);
    }
  }
 else {
    state.setCredentials(credentials);
switch (state.getState()) {
case WAITING_FOR_LEASE:
case INITIALIZING:
case RESET:
{
        state.getPendingRequests().add(method);
        return;
      }
case OPEN:
{
      state.getPendingRequests().add(method);
      doWaitingForLease(state);
      return;
    }
}
long newVersion=state.getPolicy().onClientOperation(op,objVersion,state.getState(),state.getLease());
callback.success(newVersion);
}
}
 catch (RedirectException ex) {
callback.redirect(ex);
}
catch (Exception ex) {
ex.printStackTrace();
callback.failed(ex);
}
}",0.9751912821701832
113514,"/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS) && dbsReplicationManager != null) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      rq.sendRedirectException(this.master.getConfig().getAddress().getHostAddress(),this.master.getConfig().getPort());
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}","/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && dbsReplicationManager != null && ((error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS)) || (error instanceof ConcurrentModificationException && dbsReplicationManager.isMaster()))) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      rq.sendRedirectException(this.master.getConfig().getAddress().getHostAddress(),this.master.getConfig().getPort());
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}",0.972320080523402
113515,"/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && dbsReplicationManager != null && ((error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS)) || (error instanceof ConcurrentModificationException && dbsReplicationManager.isMaster()))) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      rq.sendRedirectException(this.master.getConfig().getAddress().getHostAddress(),this.master.getConfig().getPort());
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}","/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && dbsReplicationManager != null && ((error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS)) || (error instanceof ConcurrentModificationException && dbsReplicationManager.isMaster()))) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      InetAddress host=this.master.getConfig().getAddress();
      int port=this.master.getConfig().getPort();
      InetSocketAddress address=(host == null) ? new InetSocketAddress(port) : new InetSocketAddress(host,port);
      rq.sendRedirectException(address.getAddress().getHostAddress(),port);
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}",0.9314810454438428
113516,"@Override public boolean onRemoteUpdate(long objVersion,ReplicaState state) throws IOException {
  if (state == ReplicaState.PRIMARY) {
    throw new IOException(""String_Node_Str"");
  }
  if ((objVersion == 1) && (localObjVersion == -1))   return false;
  if (objVersion > localObjVersion + 1) {
    return true;
  }
  if (objVersion > localObjVersion)   localObjVersion=objVersion;
  return false;
}","@Override public boolean onRemoteUpdate(long objVersion,ReplicaState state) throws IOException {
  if (state == ReplicaState.PRIMARY) {
    throw new IOException(""String_Node_Str"");
  }
  if ((objVersion == 1) && (localObjVersion == -1)) {
    localObjVersion=1;
    return false;
  }
  if (objVersion > localObjVersion + 1) {
    return true;
  }
  if (objVersion > localObjVersion)   localObjVersion=objVersion;
  return false;
}",0.9626955475330926
113517,"@Override public void responseAvailable(RPCResponse r){
  try {
    Object res=r.get();
    ((Decoder)result.getDecoder()).setResult(res);
    if (update && depth != 0) {
      assert(address != null);
      root.updateDefaultServerAddress(address);
    }
  }
 catch (  RedirectException e) {
    if (e.getAddress() != null && depth < tries) {
      InetSocketAddress newAddress=new InetSocketAddress(e.getAddress(),e.getPort());
      Logging.logMessage(Logging.LEVEL_INFO,root,""String_Node_Str"",newAddress.toString());
      Request nextLevel=new Request(root,otherServers,update,(depth + 1),method,result,args);
      nextLevel.execute(newAddress);
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e.getAddress(),depth);
    }
  }
catch (  InvalidArgumentException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getMessage());
  }
catch (  Throwable t) {
    Logging.logMessage(Logging.LEVEL_WARN,root,""String_Node_Str"",((address != null) ? address : root.getDefaultServerAddress()));
    if (otherServers != null && otherServers.size() > 0) {
      long delay=(ReplicationConfig.LEASE_TIMEOUT + 1) / otherServers.size();
      try {
        Thread.sleep(delay);
      }
 catch (      InterruptedException e) {
      }
      InetSocketAddress newAddress=otherServers.get(0);
      Logging.logMessage(Logging.LEVEL_INFO,root,""String_Node_Str"",newAddress.toString());
      Request next=new Request(root,otherServers,true,1,method,result,args);
      next.execute(newAddress);
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  result.fill(r);
}","@Override public void responseAvailable(RPCResponse r){
  try {
    Object res=r.get();
    ((Decoder)result.getDecoder()).setResult(res);
    if (update && depth != 0) {
      assert(address != null);
      root.updateDefaultServerAddress(address);
    }
  }
 catch (  RedirectException e) {
    if (e.getAddress() != null && depth < tries) {
      InetSocketAddress newAddress=new InetSocketAddress(e.getAddress(),e.getPort());
      if (!newAddress.equals(this.address)) {
        redirect(newAddress);
      }
 else {
        Logging.logMessage(Logging.LEVEL_INFO,this.root,""String_Node_Str"" + ""String_Node_Str"",this.address.toString());
        reconnect();
      }
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e.getAddress(),depth);
    }
  }
catch (  InvalidArgumentException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getMessage());
    Logging.logError(Logging.LEVEL_INFO,this,e);
  }
catch (  ONCRPCException e) {
    Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + e.getMessage());
    Logging.logError(Logging.LEVEL_INFO,this,e);
  }
catch (  Exception e) {
    Logging.logMessage(Logging.LEVEL_WARN,root,""String_Node_Str"",((address != null) ? address : root.getDefaultServerAddress()),e.getMessage());
    if (otherServers != null && otherServers.size() > 0) {
      reconnect();
      if (r != null)       r.freeBuffers();
      return;
    }
 else {
      Logging.logMessage(Logging.LEVEL_ERROR,root,""String_Node_Str"" + ""String_Node_Str"");
      Logging.logError(Logging.LEVEL_INFO,this,e);
    }
  }
  result.fill(r);
}",0.6085730400451212
113518,"/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  InetSocketAddress master=null;
  if (error != null && error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS) && dbsReplicationManager != null && (master=dbsReplicationManager.getMaster()) != null) {
    String host=master.getAddress().getHostAddress();
    Integer port=this.master.getConfig().getMirrors().get(host);
    if (port == null) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
      rq.sendInternalServerError(error);
    }
 else {
      rq.sendRedirectException(host,port);
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}","/** 
 * Operation to give a failure back to the client. Will decide, if a   {@link RedirectException} should be returned.
 * @param error - Exception thrown.
 * @param rq - original {@link DIRRequest}.
 */
void requestFailed(Exception error,DIRRequest rq){
  if (error != null && error instanceof BabuDBException && ((BabuDBException)error).getErrorCode().equals(NO_ACCESS) && dbsReplicationManager != null) {
    InetSocketAddress altMaster=dbsReplicationManager.getMaster();
    if (altMaster != null) {
      String host=altMaster.getAddress().getHostAddress();
      Integer port=this.master.getConfig().getMirrors().get(host);
      if (port == null) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + ""String_Node_Str"",host);
        rq.sendInternalServerError(error);
      }
 else {
        rq.sendRedirectException(host,port);
      }
    }
 else {
      rq.sendRedirectException(this.master.getConfig().getAddress().getHostAddress(),this.master.getConfig().getPort());
    }
  }
 else   if (error != null && error instanceof ONCRPCException) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException((ONCRPCException)error);
  }
 else   if (error != null && error instanceof BabuDBException && (((BabuDBException)error).getErrorCode().equals(NO_SUCH_DB) || ((BabuDBException)error).getErrorCode().equals(DB_EXISTS) || ((BabuDBException)error).getErrorCode().equals(NO_SUCH_INDEX)|| ((BabuDBException)error).getErrorCode().equals(NO_SUCH_SNAPSHOT)|| ((BabuDBException)error).getErrorCode().equals(SNAP_EXISTS))) {
    Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendException(new InvalidArgumentException(error.getMessage()));
  }
 else {
    if (error != null && !(error instanceof BabuDBException))     Logging.logError(Logging.LEVEL_ERROR,this,error);
    if (error != null)     Logging.logError(Logging.LEVEL_ERROR,this,error);
    rq.sendInternalServerError(error);
  }
}",0.8618602091359384
113519,"public int write(ReusableBuffer data) throws IOException {
  if (readOnly) {
    throw new IOException(""String_Node_Str"");
  }
  if (closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (data.remaining() == 0) {
    return 0;
  }
  List<ObjectRequest> ors=oMapper.writeRequest(data,position,currentReplica);
  if (ors.size() == 0) {
    return 0;
  }
  int numTries=0;
  IOException cause=null;
  do {
    final AtomicInteger responseCnt=new AtomicInteger(ors.size());
    RPCResponse[] resps=new RPCResponse[ors.size()];
    try {
      final RPCResponseAvailableListener rl=new RPCResponseAvailableListener<OSDWriteResponse>(){
        @Override public void responseAvailable(        RPCResponse<OSDWriteResponse> r){
          if (responseCnt.decrementAndGet() == 0) {
synchronized (responseCnt) {
              responseCnt.notify();
            }
          }
        }
      }
;
      int bytesWritten=0;
      setXCap();
      for (int i=0; i < ors.size(); i++) {
        ObjectRequest or=ors.get(i);
        or.getData().position(0);
        bytesWritten+=or.getData().capacity();
        ServiceUUID osd=new ServiceUUID(or.getOsdUUID(),parentVolume.uuidResolver);
        RPCResponse<OSDWriteResponse> r=osdClient.write(osd.getAddress(),fileId,credentials,or.getObjNo(),-1,or.getOffset(),0l,new ObjectData(0,false,0,or.getData()));
        resps[i]=r;
        r.registerListener(rl);
      }
synchronized (responseCnt) {
        if (responseCnt.get() > 0) {
          responseCnt.wait();
        }
      }
      OSDWriteResponse owr=null;
      for (int i=0; i < ors.size(); i++) {
        owr=(OSDWriteResponse)resps[i].get();
      }
      setXCap();
      parentVolume.storeFileSizeUpdate(fileId,owr);
      if (syncMetadata) {
        parentVolume.pushFileSizeUpdate(fileId);
      }
      data.flip();
      position+=bytesWritten;
      return bytesWritten;
    }
 catch (    InterruptedException ex) {
      cause=new IOException(""String_Node_Str"",ex);
    }
catch (    RedirectException ex) {
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",ex.getTo_uuid());
      forceReplica(ex.getTo_uuid());
      continue;
    }
catch (    ONCRPCException ex) {
      cause=new IOException(""String_Node_Str"" + ex,ex);
    }
 finally {
      for (      RPCResponse r : resps) {
        if (r != null)         r.freeBuffers();
      }
    }
    numTries++;
    switchToNextReplica();
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cause,currentReplica);
  }
 while (numTries < numReplicas);
  throw cause;
}","public int write(ReusableBuffer data) throws IOException {
  if (readOnly) {
    throw new IOException(""String_Node_Str"");
  }
  if (closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (data.remaining() == 0) {
    return 0;
  }
  List<ObjectRequest> ors=oMapper.writeRequest(data,position,currentReplica);
  if (ors.size() == 0) {
    return 0;
  }
  int numTries=0;
  IOException cause=null;
  do {
    final AtomicInteger responseCnt=new AtomicInteger(ors.size());
    RPCResponse[] resps=new RPCResponse[ors.size()];
    try {
      final RPCResponseAvailableListener rl=new RPCResponseAvailableListener<OSDWriteResponse>(){
        @Override public void responseAvailable(        RPCResponse<OSDWriteResponse> r){
          if (responseCnt.decrementAndGet() == 0) {
synchronized (responseCnt) {
              responseCnt.notify();
            }
          }
        }
      }
;
      int bytesWritten=0;
      setXCap();
      for (int i=0; i < ors.size(); i++) {
        ObjectRequest or=ors.get(i);
        or.getData().position(0);
        bytesWritten+=or.getData().capacity();
        ServiceUUID osd=new ServiceUUID(or.getOsdUUID(),parentVolume.uuidResolver);
        RPCResponse<OSDWriteResponse> r=osdClient.write(osd.getAddress(),fileId,credentials,or.getObjNo(),-1,or.getOffset(),0l,new ObjectData(0,false,0,or.getData()));
        resps[i]=r;
        r.registerListener(rl);
      }
synchronized (responseCnt) {
        if (responseCnt.get() > 0) {
          responseCnt.wait();
        }
      }
      OSDWriteResponse owr=null;
      for (int i=0; i < ors.size(); i++) {
        owr=(OSDWriteResponse)resps[i].get();
      }
      setXCap();
      parentVolume.storeFileSizeUpdate(fileId,owr);
      if (syncMetadata) {
        parentVolume.pushFileSizeUpdate(fileId);
      }
      data.flip();
      position+=bytesWritten;
      return bytesWritten;
    }
 catch (    InterruptedException ex) {
      cause=new IOException(""String_Node_Str"",ex);
    }
catch (    RedirectException ex) {
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",ex.getTo_uuid());
      forceReplica(ex.getTo_uuid());
      continue;
    }
catch (    ONCRPCException ex) {
      cause=new IOException(""String_Node_Str"" + ex,ex);
    }
 finally {
      for (      RPCResponse r : resps) {
        if (r != null)         r.freeBuffers();
      }
    }
    numTries++;
    switchToNextReplica();
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cause,currentReplica);
    try {
      Thread.sleep(WAIT_MS_BETWEEN_WRITE_SWITCHOVER);
    }
 catch (    InterruptedException ex) {
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",ex.toString());
      throw new IOException(""String_Node_Str"",ex);
    }
  }
 while (numTries < numReplicas);
  throw cause;
}",0.9495570421261978
113520,"public void run(){
  do {
    List<CapEntry> renewList=new LinkedList();
synchronized (capabilities) {
      final long expTime=TimeSync.getLocalSystemTime() + Constants.XCAP_EXPIRE_TIMEOUT_S_MIN;
      for (      CapEntry e : capabilities.values()) {
        if (e.getLocalTimestamp() <= expTime) {
          renewList.add(e);
        }
      }
    }
    for (    CapEntry cap : renewList) {
      renewCap(cap);
    }
    try {
      sleep(Constants.XCAP_EXPIRE_TIMEOUT_S_MIN * 60 * 1000);
    }
 catch (    InterruptedException ex) {
      break;
    }
  }
 while (!quit);
}","public void run(){
  do {
    List<CapEntry> renewList=new LinkedList();
synchronized (capabilities) {
      final long expTime=TimeSync.getLocalSystemTime() + Constants.XCAP_EXPIRE_TIMEOUT_S_MIN;
      for (      CapEntry e : capabilities.values()) {
        if (e.getLocalTimestamp() <= expTime) {
          renewList.add(e);
        }
      }
    }
    for (    CapEntry cap : renewList) {
      renewCap(cap);
    }
    try {
      sleep(Constants.XCAP_EXPIRE_TIMEOUT_S_MIN * 60 * 1000 / 2);
    }
 catch (    InterruptedException ex) {
      break;
    }
  }
 while (!quit);
}",0.996545768566494
113521,"@Override public void executeReset(FileCredentials credentials,final long updateObjVer,final long localFileSize,final long localTruncateEpoch,final ExecuteResetCallback callback){
  final String fileId=credentials.getXcap().getFile_id();
  final int numAcksRequired=getNumRequiredAcks(Operation.INTERNAL_UPDATE);
  final int numRequests=remoteOSDs.size();
  final int maxErrors=numRequests - numAcksRequired;
  System.out.println(""String_Node_Str"" + maxErrors + ""String_Node_Str""+ numAcksRequired+ ""String_Node_Str""+ numRequests);
  final RPCResponse[] responses=new RPCResponse[remoteOSDs.size()];
  for (int i=0; i < responses.length; i++) {
    responses[i]=client.rwr_status(remoteOSDs.get(i),credentials,credentials.getXcap().getFile_id(),this.localObjVersion);
  }
  RPCResponseAvailableListener listener=new RPCResponseAvailableListener(){
    int numResponses=0;
    int numErrors=0;
    boolean exceptionSent=false;
    ReplicaStatus[] states=new ReplicaStatus[numAcksRequired];
    @Override public void responseAvailable(    RPCResponse r){
      if (numResponses < numAcksRequired) {
        int osdNum=-1;
        for (int i=0; i < numRequests; i++) {
          if (responses[i] == r) {
            osdNum=i;
            break;
          }
        }
        assert(osdNum > -1);
        try {
          states[osdNum]=(ReplicaStatus)r.get();
          numResponses++;
        }
 catch (        Exception ex) {
          numErrors++;
          if (numErrors > maxErrors) {
            if (!exceptionSent) {
              exceptionSent=true;
              if (Logging.isDebug()) {
                Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId);
              }
              callback.failed(ex);
            }
          }
          return;
        }
 finally {
          r.freeBuffers();
        }
      }
      if (numResponses == numAcksRequired) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId);
        }
        boolean needsReset=false;
        long maxObjVer=0;
        long maxFileSize=0;
        long maxTrEpoch=0;
        for (        ReplicaStatus state : states) {
          if (state.getMax_obj_version() > localObjVersion) {
            needsReset=true;
            maxObjVer=state.getMax_obj_version();
            maxFileSize=state.getFile_size();
            maxTrEpoch=state.getTruncate_epoch();
            break;
          }
        }
        if (needsReset) {
          Map<Long,ObjectFetchRecord> recs=new HashMap();
          LinkedList<ObjectFetchRecord> order=new LinkedList<ObjectFetchRecord>();
          if ((localTruncateEpoch < maxTrEpoch) && (localFileSize > maxFileSize)) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId,localTruncateEpoch,maxTrEpoch);
            }
            order.add(new ObjectFetchRecord(maxFileSize,maxTrEpoch));
          }
          for (int i=0; i < numAcksRequired; i++) {
            final ReplicaStatus state=states[i];
            for (            ObjectVersion over : state.getObjectVersions()) {
              if ((updateObjVer > -1) && (over.getObject_version() >= updateObjVer))               continue;
              ObjectFetchRecord ofr=recs.get(over.getObject_number());
              if (ofr == null) {
                List<InetSocketAddress> osds=new ArrayList(numAcksRequired);
                osds.add(getRemoteOSDs().get(i));
                ofr=new ObjectFetchRecord(over.getObject_number(),over.getObject_version(),osds);
                recs.put(over.getObject_number(),ofr);
                order.add(ofr);
              }
 else {
                if (ofr.getObjVersion() < over.getObject_version()) {
                  ofr.setObjVersion(over.getObject_version());
                  ofr.getOsds().clear();
                  ofr.getOsds().add(getRemoteOSDs().get(i));
                }
 else                 if (ofr.getObjVersion() == over.getObject_version()) {
                  ofr.getOsds().add(getRemoteOSDs().get(i));
                }
              }
            }
          }
          Collections.sort(order,new Comparator<ObjectFetchRecord>(){
            @Override public int compare(            ObjectFetchRecord o1,            ObjectFetchRecord o2){
              if (o1.isTruncate())               return -1;
              int verCmp=(int)(o1.getObjVersion() - o2.getObjVersion());
              if (verCmp == 0) {
                return (int)(o2.getObjNumber() - o2.getObjNumber());
              }
 else               return verCmp;
            }
          }
);
          callback.finished(order);
        }
 else {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId,maxObjVer);
          }
          callback.finished(null);
        }
      }
    }
  }
;
  for (int i=0; i < responses.length; i++) {
    responses[i].registerListener(listener);
  }
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cellId);
}","@Override public void executeReset(FileCredentials credentials,final long updateObjVer,final long localFileSize,final long localTruncateEpoch,final ExecuteResetCallback callback){
  final String fileId=credentials.getXcap().getFile_id();
  final int numAcksRequired=getNumRequiredAcks(Operation.INTERNAL_UPDATE);
  final int numRequests=remoteOSDs.size();
  final int maxErrors=numRequests - numAcksRequired;
  final RPCResponse[] responses=new RPCResponse[remoteOSDs.size()];
  for (int i=0; i < responses.length; i++) {
    responses[i]=client.rwr_status(remoteOSDs.get(i),credentials,credentials.getXcap().getFile_id(),this.localObjVersion);
  }
  RPCResponseAvailableListener listener=new RPCResponseAvailableListener(){
    int numResponses=0;
    int numErrors=0;
    boolean exceptionSent=false;
    ReplicaStatus[] states=new ReplicaStatus[numAcksRequired];
    @Override public void responseAvailable(    RPCResponse r){
      if (numResponses < numAcksRequired) {
        int osdNum=-1;
        for (int i=0; i < numRequests; i++) {
          if (responses[i] == r) {
            osdNum=i;
            break;
          }
        }
        assert(osdNum > -1);
        try {
          states[osdNum]=(ReplicaStatus)r.get();
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",osdNum,states[osdNum]);
          }
          numResponses++;
        }
 catch (        Exception ex) {
          numErrors++;
          if (numErrors > maxErrors) {
            if (!exceptionSent) {
              exceptionSent=true;
              if (Logging.isDebug()) {
                Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId);
              }
              callback.failed(ex);
            }
          }
          return;
        }
 finally {
          r.freeBuffers();
        }
      }
      if (numResponses == numAcksRequired) {
        if (Logging.isDebug()) {
          Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId);
        }
        boolean needsReset=false;
        long maxObjVer=0;
        long maxFileSize=0;
        long maxTrEpoch=0;
        for (        ReplicaStatus state : states) {
          if (state.getMax_obj_version() > localObjVersion) {
            needsReset=true;
            maxObjVer=state.getMax_obj_version();
            maxFileSize=state.getFile_size();
            maxTrEpoch=state.getTruncate_epoch();
            break;
          }
        }
        if (needsReset) {
          Map<Long,ObjectFetchRecord> recs=new HashMap();
          LinkedList<ObjectFetchRecord> order=new LinkedList<ObjectFetchRecord>();
          if ((localTruncateEpoch < maxTrEpoch) && (localFileSize > maxFileSize)) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId,localTruncateEpoch,maxTrEpoch);
            }
            order.add(new ObjectFetchRecord(maxFileSize,maxTrEpoch));
          }
          for (int i=0; i < numAcksRequired; i++) {
            final ReplicaStatus state=states[i];
            for (            ObjectVersion over : state.getObjectVersions()) {
              if ((updateObjVer > -1) && (over.getObject_version() >= updateObjVer))               continue;
              ObjectFetchRecord ofr=recs.get(over.getObject_number());
              if (ofr == null) {
                List<InetSocketAddress> osds=new ArrayList(numAcksRequired);
                osds.add(getRemoteOSDs().get(i));
                ofr=new ObjectFetchRecord(over.getObject_number(),over.getObject_version(),osds);
                recs.put(over.getObject_number(),ofr);
                order.add(ofr);
              }
 else {
                if (ofr.getObjVersion() < over.getObject_version()) {
                  ofr.setObjVersion(over.getObject_version());
                  ofr.getOsds().clear();
                  ofr.getOsds().add(getRemoteOSDs().get(i));
                }
 else                 if (ofr.getObjVersion() == over.getObject_version()) {
                  ofr.getOsds().add(getRemoteOSDs().get(i));
                }
              }
            }
          }
          Collections.sort(order,new Comparator<ObjectFetchRecord>(){
            @Override public int compare(            ObjectFetchRecord o1,            ObjectFetchRecord o2){
              if (o1.isTruncate())               return -1;
              int verCmp=(int)(o1.getObjVersion() - o2.getObjVersion());
              if (verCmp == 0) {
                return (int)(o2.getObjNumber() - o2.getObjNumber());
              }
 else               return verCmp;
            }
          }
);
          callback.finished(order);
        }
 else {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",fileId,maxObjVer);
          }
          callback.finished(null);
        }
      }
    }
  }
;
  for (int i=0; i < responses.length; i++) {
    responses[i].registerListener(listener);
  }
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + cellId);
}",0.373613428879945
113522,"private void processLeaseStateChanged(StageRequest method){
  try {
    final ASCIIString cellId=(ASCIIString)method.getArgs()[0];
    final Flease lease=(Flease)method.getArgs()[1];
    final FleaseException error=(FleaseException)method.getArgs()[2];
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cellId,lease.getLeaseHolder(),error);
    final String fileId=cellToFileId.get(cellId);
    if (fileId != null) {
      ReplicatedFileState state=files.get(fileId);
      assert(state != null);
      if (error == null) {
        boolean localIsPrimary=(lease.getLeaseHolder() != null) && (lease.getLeaseHolder().equals(localID));
        ReplicaState oldState=state.getState();
        state.setLocalIsPrimary(localIsPrimary);
        state.setLease(lease);
        if ((state.getState() == ReplicaState.BACKUP) || (state.getState() == ReplicaState.PRIMARY) || (state.getState() == ReplicaState.WAITING_FOR_LEASE)) {
          if (localIsPrimary) {
            if (oldState != ReplicaState.PRIMARY)             doPrimary(state);
          }
 else {
            if (oldState != ReplicaState.BACKUP)             doBackup(state);
          }
        }
      }
 else {
        if (state.getState() == ReplicaState.WAITING_FOR_LEASE) {
          failed(state,error);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","private void processLeaseStateChanged(StageRequest method){
  try {
    final ASCIIString cellId=(ASCIIString)method.getArgs()[0];
    final Flease lease=(Flease)method.getArgs()[1];
    final FleaseException error=(FleaseException)method.getArgs()[2];
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"",cellId,lease,error);
    final String fileId=cellToFileId.get(cellId);
    if (fileId != null) {
      ReplicatedFileState state=files.get(fileId);
      assert(state != null);
      if (error == null) {
        boolean localIsPrimary=(lease.getLeaseHolder() != null) && (lease.getLeaseHolder().equals(localID));
        ReplicaState oldState=state.getState();
        state.setLocalIsPrimary(localIsPrimary);
        state.setLease(lease);
        if ((state.getState() == ReplicaState.BACKUP) || (state.getState() == ReplicaState.PRIMARY) || (state.getState() == ReplicaState.WAITING_FOR_LEASE)) {
          if (localIsPrimary) {
            if (oldState != ReplicaState.PRIMARY)             doPrimary(state);
          }
 else {
            if (oldState != ReplicaState.BACKUP)             doBackup(state);
          }
        }
      }
 else {
        if (state.getState() == ReplicaState.WAITING_FOR_LEASE) {
          failed(state,error);
        }
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9938517179023508
113523,"@Override public FileStatus[] listStatus(Path hdPath) throws IOException {
  if (hdPath == null)   return null;
  final String path=hdPath.toUri().getPath();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + path);
  DirectoryEntry[] list=volume.listEntries(path);
  if (list == null)   return null;
  FileStatus[] fslist=new FileStatus[list.length];
  for (int i=0; i < list.length; i++) {
    final DirectoryEntry e=list[i];
    final Stat s=e.getStbuf();
    final boolean isDir=(s.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFDIR) > 0;
    fslist[i]=new FileStatus(s.getSize(),isDir,1,1,(long)(s.getMtime_ns() / 1e6),(long)(s.getAtime_ns() / 1e6),new FsPermission((short)s.getMode()),s.getUser_id(),s.getGroup_id(),new Path(hdPath,e.getName()));
  }
  return fslist;
}","@Override public FileStatus[] listStatus(Path hdPath) throws IOException {
  if (hdPath == null)   return null;
  final String path=hdPath.toUri().getPath();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + path);
  DirectoryEntry[] list=volume.listEntries(path);
  if (list == null)   return null;
  FileStatus[] fslist=new FileStatus[list.length];
  for (int i=0; i < list.length; i++) {
    final DirectoryEntry e=list[i];
    final Stat s=e.getStbuf().get(0);
    final boolean isDir=(s.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFDIR) > 0;
    fslist[i]=new FileStatus(s.getSize(),isDir,1,1,(long)(s.getMtime_ns() / 1e6),(long)(s.getAtime_ns() / 1e6),new FsPermission((short)s.getMode()),s.getUser_id(),s.getGroup_id(),new Path(hdPath,e.getName()));
  }
  return fslist;
}",0.9955668144395188
113524,"@Override public void createSnapshot(String snapName,long parentId,String dirName,boolean recursive) throws DatabaseException {
  try {
    byte[][][] prefixes=null;
    byte[][][] excludedKeys=null;
    FileMetadata snapDir=getMetadata(parentId,dirName);
    if (snapDir.getId() != 1 || !recursive) {
      List<FileMetadata> nestedFiles=new LinkedList<FileMetadata>();
      BabuDBStorageHelper.getNestedFiles(nestedFiles,database,snapDir.getId(),recursive);
      List<byte[]> dirEntryPrefixes=new ArrayList<byte[]>(nestedFiles.size());
      List<byte[]> filePrefixes=new ArrayList<byte[]>(nestedFiles.size());
      List<byte[]> exclPrefixes=new ArrayList<byte[]>(nestedFiles.size());
      if (snapDir.getId() != 1)       filePrefixes.add(ByteBuffer.wrap(new byte[8]).putLong(1).array());
      byte[] idxKey=BabuDBStorageHelper.createFileKey(parentId,dirName,(byte)-1);
      byte[] fileKey=BabuDBStorageHelper.createFilePrefixKey(snapDir.getId());
      dirEntryPrefixes.add(idxKey);
      filePrefixes.add(fileKey);
      idxKey=BabuDBStorageHelper.createFilePrefixKey(snapDir.getId());
      dirEntryPrefixes.add(idxKey);
      for (      FileMetadata file : nestedFiles) {
        BufferBackedFileMetadata f=(BufferBackedFileMetadata)file;
        byte[] key=BabuDBStorageHelper.createFilePrefixKey(file.getId());
        if (file.isDirectory()) {
          if (!recursive) {
            byte[] buf=f.getKeyBuffer(BufferBackedFileMetadata.RC_METADATA);
            byte[] exclKey=new byte[buf.length - 1];
            System.arraycopy(buf,0,exclKey,0,exclKey.length);
            exclPrefixes.add(exclKey);
          }
 else {
            filePrefixes.add(key);
            dirEntryPrefixes.add(key);
          }
        }
 else         filePrefixes.add(key);
      }
      byte[][] dirEntryPrefixesA=dirEntryPrefixes.toArray(new byte[dirEntryPrefixes.size()][]);
      byte[][] filePrefixesA=filePrefixes.toArray(new byte[filePrefixes.size()][]);
      byte[][] exclPrefixesA=exclPrefixes.toArray(new byte[exclPrefixes.size()][]);
      Arrays.sort(dirEntryPrefixesA,DefaultByteRangeComparator.getInstance());
      Arrays.sort(filePrefixesA,DefaultByteRangeComparator.getInstance());
      prefixes=new byte[][][]{dirEntryPrefixesA,filePrefixesA,filePrefixesA,filePrefixesA,null};
      if (!recursive)       excludedKeys=new byte[][][]{exclPrefixesA,exclPrefixesA,exclPrefixesA,exclPrefixesA,null};
    }
    SnapshotConfig snap=new DefaultSnapshotConfig(snapName,ALL_INDICES,prefixes,excludedKeys);
    snapMan.createPersistentSnapshot(database.getName(),snap);
  }
 catch (  BabuDBException exc) {
    if (exc.getErrorCode().equals(ErrorCode.NO_ACCESS))     throw new DatabaseException(ExceptionType.REDIRECT,this.replMan.getMaster());
 else     throw new DatabaseException(exc);
  }
}","@Override public void createSnapshot(String snapName,long parentId,String dirName,boolean recursive) throws DatabaseException {
  try {
    byte[][][] prefixes=null;
    FileMetadata snapDir=getMetadata(parentId,dirName);
    if (snapDir.getId() != 1 || !recursive) {
      List<FileMetadata> nestedFiles=new LinkedList<FileMetadata>();
      BabuDBStorageHelper.getNestedFiles(nestedFiles,database,snapDir.getId(),recursive);
      List<byte[]> dirEntryPrefixes=new ArrayList<byte[]>(nestedFiles.size());
      List<byte[]> filePrefixes=new ArrayList<byte[]>(nestedFiles.size());
      if (snapDir.getId() != 1)       filePrefixes.add(ByteBuffer.wrap(new byte[8]).putLong(1).array());
      byte[] idxKey=BabuDBStorageHelper.createFileKey(parentId,dirName,(byte)-1);
      byte[] fileKey=BabuDBStorageHelper.createFilePrefixKey(snapDir.getId());
      dirEntryPrefixes.add(idxKey);
      filePrefixes.add(fileKey);
      idxKey=BabuDBStorageHelper.createFilePrefixKey(snapDir.getId());
      dirEntryPrefixes.add(idxKey);
      for (      FileMetadata file : nestedFiles) {
        byte[] key=BabuDBStorageHelper.createFilePrefixKey(file.getId());
        if (file.isDirectory()) {
          filePrefixes.add(key);
          dirEntryPrefixes.add(key);
        }
 else         filePrefixes.add(key);
      }
      byte[][] dirEntryPrefixesA=dirEntryPrefixes.toArray(new byte[dirEntryPrefixes.size()][]);
      byte[][] filePrefixesA=filePrefixes.toArray(new byte[filePrefixes.size()][]);
      Arrays.sort(dirEntryPrefixesA,DefaultByteRangeComparator.getInstance());
      Arrays.sort(filePrefixesA,DefaultByteRangeComparator.getInstance());
      prefixes=new byte[][][]{dirEntryPrefixesA,filePrefixesA,filePrefixesA,filePrefixesA,null};
    }
    SnapshotConfig snap=new DefaultSnapshotConfig(snapName,ALL_INDICES,prefixes,null);
    snapMan.createPersistentSnapshot(database.getName(),snap);
  }
 catch (  BabuDBException exc) {
    if (exc.getErrorCode().equals(ErrorCode.NO_ACCESS))     throw new DatabaseException(ExceptionType.REDIRECT,this.replMan.getMaster());
 else     throw new DatabaseException(exc);
  }
}",0.358130081300813
113525,"public int compare(TreeEntry o1,TreeEntry o2){
  return o1.getName().compareTo(o2.getName());
}","public int compare(TreeEntry o1,TreeEntry o2){
  return o2.getName().length() - o1.getName().length();
}",0.7537688442211056
113526,"private void assertTree(SortedSet<TreeEntry> tree,String volume,String path,boolean recursive) throws Exception {
  SortedSet<TreeEntry> subtree=getSubtree(tree,path,recursive);
  int offs=0;
  for (  TreeEntry entry : subtree) {
    if (path.equals(entry.getName()))     offs=entry.getName().length();
    String relPath=entry.getName().substring(offs);
    if (relPath.startsWith(""String_Node_Str""))     relPath=relPath.substring(1);
    try {
      invokeSync(client.getattr(mrcAddress,uc,volume,relPath));
    }
 catch (    Exception exc) {
      System.out.println(""String_Node_Str"" + volume + ""String_Node_Str""+ relPath);
      System.out.println();
      printTree(tree);
      System.out.println();
      printTree(subtree);
      exc.printStackTrace();
      System.exit(1);
    }
  }
}","private void assertTree(SortedSet<TreeEntry> tree,String volume,String path,boolean recursive) throws Exception {
  SortedSet<TreeEntry> subtree=getSubtree(tree,path,recursive);
  int offs=0;
  for (  TreeEntry entry : subtree) {
    if (path.equals(entry.getName()))     offs=entry.getName().length();
    String relPath=entry.getName().substring(offs);
    if (relPath.startsWith(""String_Node_Str""))     relPath=relPath.substring(1);
    invokeSync(client.getattr(mrcAddress,uc,volume,relPath));
  }
  checkDir(volume,subtree,""String_Node_Str"",path,recursive);
}",0.7682119205298014
113527,"private static SortedSet<TreeEntry> createRandomTree(int numDirs,int maxFilesPerDir){
  SortedSet<TreeEntry> tree=new TreeSet<TreeEntry>(new Comparator<TreeEntry>(){
    public int compare(    TreeEntry o1,    TreeEntry o2){
      return o1.getName().compareTo(o2.getName());
    }
  }
);
  String currentPath=""String_Node_Str"";
  for (int i=0; i < numDirs; i++) {
    if (""String_Node_Str"".equals(currentPath) || rnd.nextBoolean())     currentPath=createRandomString(1,10);
 else     currentPath=currentPath + ""String_Node_Str"" + createRandomString(1,10);
    tree.add(new TreeEntry(currentPath,true));
  }
  List<TreeEntry> files=new LinkedList<TreeEntry>();
  for (  TreeEntry entry : tree)   for (int i=0; i < rnd.nextDouble() * (maxFilesPerDir + 1); i++)   files.add(new TreeEntry(entry.getName() + ""String_Node_Str"" + createRandomString(1,10)+ ""String_Node_Str"",false));
  tree.addAll(files);
  return tree;
}","private static SortedSet<TreeEntry> createRandomTree(int numDirs,int maxFilesPerDir){
  SortedSet<TreeEntry> tree=new TreeSet<TreeEntry>();
  String currentPath=""String_Node_Str"";
  for (int i=0; i < numDirs; i++) {
    if (""String_Node_Str"".equals(currentPath) || rnd.nextBoolean())     currentPath=createRandomString(1,10);
 else     currentPath=currentPath + ""String_Node_Str"" + createRandomString(1,10);
    tree.add(new TreeEntry(currentPath,true));
  }
  List<TreeEntry> files=new LinkedList<TreeEntry>();
  for (  TreeEntry entry : tree)   for (int i=0; i < rnd.nextDouble() * (maxFilesPerDir + 1); i++)   files.add(new TreeEntry(entry.getName() + ""String_Node_Str"" + createRandomString(1,10)+ ""String_Node_Str"",false));
  tree.addAll(files);
  return tree;
}",0.9113622843545508
113528,"private static SortedSet<TreeEntry> getSubtree(SortedSet<TreeEntry> tree,String path,boolean recursive){
  SortedSet<TreeEntry> subTree=new TreeSet<TreeEntry>(tree.comparator());
  for (  TreeEntry entry : tree)   if (entry.getName().startsWith(path) && (recursive || entry.getName().equals(path) || (!recursive && !entry.isDir() && entry.getName().substring(path.length() + 1).indexOf('/') == -1)))   subTree.add(entry);
  return subTree;
}","private static SortedSet<TreeEntry> getSubtree(SortedSet<TreeEntry> tree,String path,boolean recursive){
  String[] pathComps=path.equals(""String_Node_Str"") ? new String[0] : path.split(""String_Node_Str"");
  SortedSet<TreeEntry> subTree=new TreeSet<TreeEntry>(tree.comparator());
  for (  TreeEntry entry : tree) {
    String[] comps=entry.getName().split(""String_Node_Str"");
    if (equals(comps,pathComps)) {
      subTree.add(entry);
    }
 else     if (recursive) {
      if (startsWith(comps,pathComps))       subTree.add(entry);
    }
 else {
      if (startsWith(comps,pathComps) && comps.length - pathComps.length == 1)       subTree.add(entry);
    }
  }
  return subTree;
}",0.50355871886121
113529,"public void testSnapshots() throws Exception {
  final int maxFilesPerDir=4;
  final int numDirs=20;
  final String volumeName=""String_Node_Str"";
  final int numSnaps=100;
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,getDefaultStripingPolicy(),POSIXFileAccessPolicy.POLICY_ID,0775));
  invokeSync(client.setxattr(mrcAddress,uc,volumeName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0));
  SortedSet<TreeEntry> tree=createRandomTree(numDirs,maxFilesPerDir);
  for (  TreeEntry path : tree)   if (path.isDir())   invokeSync(client.mkdir(mrcAddress,uc,volumeName,path.getName(),0775));
 else   invokeSync(client.open(mrcAddress,uc,volumeName,path.getName(),FileAccessManager.O_CREAT,0775,0,new VivaldiCoordinates()));
  assertTree(tree,volumeName,""String_Node_Str"",true);
  invokeSync(createSnapshot(volumeName,""String_Node_Str"",""String_Node_Str"",true));
  assertTree(tree,volumeName + ""String_Node_Str"",""String_Node_Str"",true);
  invokeSync(createSnapshot(volumeName,""String_Node_Str"",""String_Node_Str"",false));
  assertTree(tree,volumeName + ""String_Node_Str"",""String_Node_Str"",false);
  Map<Integer,Object[]> snaps=new HashMap<Integer,Object[]>();
  for (int i=0; i < numSnaps; i++) {
    String dir=getRandomDir(tree);
    boolean recursive=rnd.nextBoolean();
    snaps.put(i,new Object[]{dir,recursive});
    invokeSync(createSnapshot(volumeName,dir,i + ""String_Node_Str"",recursive));
    assertTree(tree,volumeName + ""String_Node_Str"" + i,dir,recursive);
  }
  SortedSet<TreeEntry> newTree=modifyTree(tree,0.2,0.3,0.2,5);
  for (  TreeEntry path : tree)   if (!newTree.contains(path)) {
    if (path.isDir())     try {
      invokeSync(client.rmdir(mrcAddress,uc,volumeName,path.getName()));
    }
 catch (    Exception exc) {
    }
 else     invokeSync(client.unlink(mrcAddress,uc,volumeName,path.getName()));
  }
  for (  TreeEntry path : newTree)   if (!tree.contains(path)) {
    if (path.isDir())     invokeSync(client.mkdir(mrcAddress,uc,volumeName,path.getName(),0775));
 else     invokeSync(client.open(mrcAddress,uc,volumeName,path.getName(),FileAccessManager.O_CREAT,0775,0,new VivaldiCoordinates()));
  }
  assertTree(newTree,volumeName,""String_Node_Str"",true);
  for (  Entry<Integer,Object[]> snap : snaps.entrySet())   assertTree(tree,volumeName + ""String_Node_Str"" + snap.getKey(),(String)snap.getValue()[0],(Boolean)snap.getValue()[1]);
}","public void testSnapshots() throws Exception {
  final int maxFilesPerDir=4;
  final int numDirs=20;
  final String volumeName=""String_Node_Str"";
  final int numSnaps=50;
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,getDefaultStripingPolicy(),POSIXFileAccessPolicy.POLICY_ID,0775));
  invokeSync(client.setxattr(mrcAddress,uc,volumeName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0));
  SortedSet<TreeEntry> tree=createRandomTree(numDirs,maxFilesPerDir);
  for (  TreeEntry path : tree)   if (path.isDir())   invokeSync(client.mkdir(mrcAddress,uc,volumeName,path.getName(),0775));
 else   invokeSync(client.open(mrcAddress,uc,volumeName,path.getName(),FileAccessManager.O_CREAT,0775,0,new VivaldiCoordinates()));
  assertTree(tree,volumeName,""String_Node_Str"",true);
  invokeSync(createSnapshot(volumeName,""String_Node_Str"",""String_Node_Str"",true));
  assertTree(tree,volumeName + ""String_Node_Str"",""String_Node_Str"",true);
  invokeSync(createSnapshot(volumeName,""String_Node_Str"",""String_Node_Str"",false));
  assertTree(tree,volumeName + ""String_Node_Str"",""String_Node_Str"",false);
  Map<Integer,Object[]> snaps=new HashMap<Integer,Object[]>();
  for (int i=0; i < numSnaps; i++) {
    String dir=getRandomDir(tree);
    boolean recursive=rnd.nextBoolean();
    snaps.put(i,new Object[]{dir,recursive});
    invokeSync(createSnapshot(volumeName,dir,i + ""String_Node_Str"",recursive));
    assertTree(tree,volumeName + ""String_Node_Str"" + i,dir,recursive);
  }
  ArrayList<TreeEntry> entries=new ArrayList<TreeEntry>(tree);
  Collections.sort(entries,new Comparator<TreeEntry>(){
    public int compare(    TreeEntry o1,    TreeEntry o2){
      return o2.getName().length() - o1.getName().length();
    }
  }
);
  for (  TreeEntry path : entries)   if (path.isDir())   invokeSync(client.rmdir(mrcAddress,uc,volumeName,path.getName()));
 else   invokeSync(client.unlink(mrcAddress,uc,volumeName,path.getName()));
  TreeSet<TreeEntry> emptyTree=new TreeSet<TreeEntry>();
  assertTree(emptyTree,volumeName,""String_Node_Str"",true);
  for (  Entry<Integer,Object[]> snap : snaps.entrySet())   assertTree(tree,volumeName + ""String_Node_Str"" + snap.getKey(),(String)snap.getValue()[0],(Boolean)snap.getValue()[1]);
}",0.7559808612440191
113530,"public void testInterleavedWriteAndTruncate() throws Exception {
  final int numIterations=20;
  final int maxObject=20;
  final int maxSize=maxObject * SIZE;
  final int numWrittenObjs=5;
  final MRCDummy mrcDummy=new MRCDummy(capSecret);
  for (int k=0; k < 3; k++) {
    final FileCredentials fcred=new FileCredentials(getCap(FILE_ID).getXCap(),xloc);
    final List<RPCResponse> responses=new LinkedList<RPCResponse>();
    for (int l=0; l < numIterations; l++) {
      for (int i=0; i < numWrittenObjs; i++) {
        final int objId=(int)(Math.random() * maxObject);
        final int osdIndex=objId % osdIDs.size();
        final int size=(int)((SIZE - 1) * Math.random()) + 1;
        ObjectData objdata=new ObjectData(0,false,0,SetupUtils.generateData(size));
        RPCResponse<OSDWriteResponse> r=client.write(osdIDs.get(osdIndex).getAddress(),FILE_ID,fcred,objId,0,0,0,objdata);
        responses.add(r);
        r.registerListener(mrcDummy);
      }
      for (      RPCResponse r : responses) {
        r.waitForResult();
        r.freeBuffers();
      }
      responses.clear();
      fcred.setXcap(mrcDummy.open('t').getXCap());
      long newSize=(long)(Math.random() * maxSize);
      RPCResponse<OSDWriteResponse> rt=client.truncate(osdIDs.get(0).getAddress(),FILE_ID,fcred,newSize);
      rt.registerListener(mrcDummy);
      rt.waitForResult();
      rt.freeBuffers();
      long fileSize=mrcDummy.getFileSize();
      for (int i=0; i < maxObject; i++) {
        RPCResponse<ObjectData> r2=client.read(osdIDs.get(i % osdIDs.size()).getAddress(),FILE_ID,fcred,i,0,0,SIZE);
        ObjectData result=r2.get();
        r2.freeBuffers();
        if (i < fileSize / SIZE)         assertEquals(SIZE,result.getZero_padding() + result.getData().capacity());
 else         if (i == fileSize / SIZE) {
          if (fileSize % SIZE == 0)           assertEquals(0,result.getZero_padding() + result.getData().capacity());
 else           assertEquals(fileSize % SIZE,result.getZero_padding() + result.getData().capacity());
        }
 else         assertEquals(0,result.getZero_padding() + result.getData().capacity());
        BufferPool.free(result.getData());
      }
    }
    if (k != 2)     Thread.sleep(90000);
  }
}","public void testInterleavedWriteAndTruncate() throws Exception {
  final int numIterations=20;
  final int maxObject=20;
  final int maxSize=maxObject * SIZE;
  final int numWrittenObjs=5;
  final MRCDummy mrcDummy=new MRCDummy(capSecret);
  for (int k=0; k < 3; k++) {
    final FileCredentials fcred=new FileCredentials(getCap(FILE_ID).getXCap(),xloc);
    final List<RPCResponse> responses=new LinkedList<RPCResponse>();
    for (int l=0; l < numIterations; l++) {
      for (int i=0; i < numWrittenObjs; i++) {
        final int objId=(int)(Math.random() * maxObject);
        final int osdIndex=objId % osdIDs.size();
        final int size=(int)((SIZE - 1) * Math.random()) + 1;
        ObjectData objdata=new ObjectData(0,false,0,SetupUtils.generateData(size));
        RPCResponse<OSDWriteResponse> r=client.write(osdIDs.get(osdIndex).getAddress(),FILE_ID,fcred,objId,0,0,0,objdata);
        responses.add(r);
        r.registerListener(mrcDummy);
      }
      for (      RPCResponse r : responses) {
        r.waitForResult();
        r.freeBuffers();
      }
      responses.clear();
      fcred.setXcap(mrcDummy.open('t').getXCap());
      long newSize=(long)(Math.random() * maxSize);
      RPCResponse<OSDWriteResponse> rt=client.truncate(osdIDs.get(0).getAddress(),FILE_ID,fcred,newSize);
      rt.registerListener(mrcDummy);
      rt.waitForResult();
      rt.freeBuffers();
      long fileSize=mrcDummy.getFileSize();
      for (int i=0; i < maxObject; i++) {
        RPCResponse<ObjectData> r2=client.read(osdIDs.get(i % osdIDs.size()).getAddress(),FILE_ID,fcred,i,0,0,SIZE);
        ObjectData result=r2.get();
        r2.freeBuffers();
        if (i < fileSize / SIZE)         assertEquals(SIZE,result.getZero_padding() + result.getData().capacity());
 else         if (i == fileSize / SIZE) {
          if (fileSize % SIZE == 0)           assertEquals(0,result.getZero_padding() + result.getData().capacity());
 else           assertEquals(fileSize % SIZE,result.getZero_padding() + result.getData().capacity());
        }
 else         assertEquals(0,result.getZero_padding() + result.getData().capacity());
        BufferPool.free(result.getData());
      }
    }
    if (k != 2) {
      System.out.println(""String_Node_Str"");
      Thread.sleep(61000);
    }
  }
}",0.9856226498562264
113531,"public void testImplicitVersionCreation() throws Exception {
  final long timeoutSpan=61000;
  final long t0=System.currentTimeMillis();
  FileCredentials wCred=getFileCredentials(1,true);
  FileCredentials rCred=getFileCredentials(1,false);
  ObjectData objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'x'));
  RPCResponse<OSDWriteResponse> r=client.write(osdId.getAddress(),FILE_ID,wCred,0,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'y'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,1,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  Thread.sleep(timeoutSpan);
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'z'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,0,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  final long t1=System.currentTimeMillis();
  FileCredentials rCredV=getFileCredentials(0,t1);
  RPCResponse<ObjectData> r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  ObjectData result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'x');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'z');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t0 - 999999);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  FileCredentials tCred=getFileCredentials(1,true);
  r=client.truncate(osdId.getAddress(),FILE_ID,tCred,0);
  r.get();
  r.freeBuffers();
  Thread.sleep(timeoutSpan);
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'w'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,2,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  final long t2=System.currentTimeMillis();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'w');
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t1);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'x');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t2);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
}","public void testImplicitVersionCreation() throws Exception {
  final long timeoutSpan=61000;
  final long t0=System.currentTimeMillis();
  FileCredentials wCred=getFileCredentials(1,true);
  FileCredentials rCred=getFileCredentials(1,false);
  ObjectData objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'x'));
  RPCResponse<OSDWriteResponse> r=client.write(osdId.getAddress(),FILE_ID,wCred,0,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'y'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,1,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  System.out.println(""String_Node_Str"" + timeoutSpan / 1000 + ""String_Node_Str"");
  Thread.sleep(timeoutSpan);
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'z'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,0,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  final long t1=System.currentTimeMillis();
  FileCredentials rCredV=getFileCredentials(0,t1);
  RPCResponse<ObjectData> r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  ObjectData result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'x');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'z');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t0 - 999999);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  FileCredentials tCred=getFileCredentials(1,true);
  r=client.truncate(osdId.getAddress(),FILE_ID,tCred,0);
  r.get();
  r.freeBuffers();
  Thread.sleep(timeoutSpan);
  objdata=new ObjectData(0,false,0,SetupUtils.generateData(OBJ_SIZE,(byte)'w'));
  r=client.write(osdId.getAddress(),FILE_ID,wCred,2,0,0,0,objdata);
  r.get();
  r.freeBuffers();
  final long t2=System.currentTimeMillis();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCred,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'w');
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t1);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'x');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,OBJ_SIZE,(byte)'y');
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  rCredV=getFileCredentials(0,t2);
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,0,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,1,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
  r2=client.read(osdId.getAddress(),FILE_ID,rCredV,2,0,0,OBJ_SIZE);
  result=r2.get();
  checkData(result,0,(byte)0);
  r2.freeBuffers();
}",0.9888222464558344
113532,"/** 
 * toggels the written flag for an object if in COW_ONMCE mode
 * @param objectNumber the object which was modified
 */
public void objectChanged(int objectNumber){
  assert(cowFlags != null);
  if ((mode == cowMode.COW_ONCE) && (objectNumber < initialObjectCount)) {
    final int field=objectNumber / Byte.SIZE;
    final int bit=objectNumber % Byte.SIZE;
    cowFlags[field]=(byte)(cowFlags[field] | (0x01 << bit));
  }
}","/** 
 * toggels the written flag for an object if in COW_ONMCE mode
 * @param objectNumber the object which was modified
 */
public void objectChanged(int objectNumber){
  if ((mode == cowMode.COW_ONCE) && (objectNumber < initialObjectCount)) {
    assert(cowFlags != null);
    final int field=objectNumber / Byte.SIZE;
    final int bit=objectNumber % Byte.SIZE;
    cowFlags[field]=(byte)(cowFlags[field] | (0x01 << bit));
  }
}",0.9325581395348838
113533,"@SuppressWarnings(""String_Node_Str"") @Override public FSDataOutputStream create(Path file,FsPermission permissions,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable prog) throws IOException {
  final String path=file.toUri().getPath();
  File f=volume.getFile(path);
  String openMode=""String_Node_Str"";
  if (overwrite)   openMode+=""String_Node_Str"";
  f.createFile();
  final RandomAccessFile raf=f.open(openMode,permissions.toShort());
  return new FSDataOutputStream(new OutputStream(){
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      raf.write(b,off,len);
    }
    @Override public void write(    byte[] b) throws IOException {
      raf.write(b,0,b.length);
    }
    @Override public void write(    int b) throws IOException {
      raf.write(new byte[]{(byte)b},0,1);
    }
    @Override public void close() throws IOException {
      raf.close();
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") @Override public FSDataOutputStream create(Path file,FsPermission permissions,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable prog) throws IOException {
  final String path=file.toUri().getPath();
  File f=volume.getFile(path);
  String openMode=""String_Node_Str"";
  if (overwrite)   openMode+=""String_Node_Str"";
  final RandomAccessFile raf=f.open(openMode,permissions.toShort());
  return new FSDataOutputStream(new OutputStream(){
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      raf.write(b,off,len);
    }
    @Override public void write(    byte[] b) throws IOException {
      raf.write(b,0,b.length);
    }
    @Override public void write(    int b) throws IOException {
      raf.write(new byte[]{(byte)b},0,1);
    }
    @Override public void close() throws IOException {
      raf.close();
    }
  }
);
}",0.9904255319148936
113534,"@Override public void initialize(URI uri,Configuration conf) throws IOException {
  int logLevel=Logging.LEVEL_WARN;
  if (conf.getBoolean(""String_Node_Str"",false)) {
    logLevel=Logging.LEVEL_DEBUG;
  }
  String volumeName=conf.get(""String_Node_Str"");
  if (volumeName == null)   throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  Logging.start(logLevel,Category.all);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri);
  InetSocketAddress dir=new InetSocketAddress(uri.getHost(),uri.getPort());
  xtreemfsClient=new Client(new InetSocketAddress[]{dir},30 * 1000,15 * 60 * 1000,null);
  try {
    xtreemfsClient.start();
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
  UserCredentials uc=null;
  if ((conf.get(""String_Node_Str"") != null) && (conf.get(""String_Node_Str"") != null)) {
    StringSet grps=new StringSet();
    grps.add(conf.get(""String_Node_Str""));
    uc=new UserCredentials(conf.get(""String_Node_Str""),grps,""String_Node_Str"");
  }
  if (uc == null) {
    if (System.getenv(""String_Node_Str"") != null) {
      StringSet grps=new StringSet();
      grps.add(""String_Node_Str"");
      uc=new UserCredentials(System.getenv(""String_Node_Str""),grps,""String_Node_Str"");
    }
  }
  volume=xtreemfsClient.getVolume(volumeName,uc);
  fsURI=uri;
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri.getUserInfo());
}","@Override public void initialize(URI uri,Configuration conf) throws IOException {
  super.initialize(uri,conf);
  int logLevel=Logging.LEVEL_WARN;
  if (conf.getBoolean(""String_Node_Str"",false)) {
    logLevel=Logging.LEVEL_DEBUG;
  }
  String volumeName=conf.get(""String_Node_Str"");
  if (volumeName == null)   throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  Logging.start(logLevel,Category.all);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri);
  InetSocketAddress dir=new InetSocketAddress(uri.getHost(),uri.getPort());
  xtreemfsClient=new Client(new InetSocketAddress[]{dir},30 * 1000,15 * 60 * 1000,null);
  try {
    xtreemfsClient.start();
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
  UserCredentials uc=null;
  if ((conf.get(""String_Node_Str"") != null) && (conf.get(""String_Node_Str"") != null)) {
    StringSet grps=new StringSet();
    grps.add(conf.get(""String_Node_Str""));
    uc=new UserCredentials(conf.get(""String_Node_Str""),grps,""String_Node_Str"");
  }
  if (uc == null) {
    if (System.getenv(""String_Node_Str"") != null) {
      StringSet grps=new StringSet();
      grps.add(""String_Node_Str"");
      uc=new UserCredentials(System.getProperty(""String_Node_Str""),grps,""String_Node_Str"");
    }
  }
  fsURI=uri;
  workingDirectory=getHomeDirectory();
  volume=xtreemfsClient.getVolume(volumeName,uc);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri.getUserInfo());
}",0.9225984796129924
113535,"public RandomAccessFile open(String openMode,int permissions) throws IOException {
  int flags=0;
  if (openMode.equals(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_RDONLY;
  }
 else   if (openMode.equals(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_RDWR;
    flags|=Constants.SYSTEM_V_FCNTL_H_O_CREAT;
  }
  if (openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_TRUNC;
  }
  if (openMode.contains(""String_Node_Str"") || openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_SYNC;
  }
  return volume.openFile(this,flags,permissions);
}","public RandomAccessFile open(String openMode,int permissions) throws IOException {
  int flags=0;
  if (openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_RDWR;
    flags|=Constants.SYSTEM_V_FCNTL_H_O_CREAT;
  }
 else   if (openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_RDONLY;
  }
  if (openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_TRUNC;
  }
  if (openMode.contains(""String_Node_Str"") || openMode.contains(""String_Node_Str"")) {
    flags|=Constants.SYSTEM_V_FCNTL_H_O_SYNC;
  }
  return volume.openFile(this,flags,permissions);
}",0.8261562998405104
113536,"@Override public Path getWorkingDirectory(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public Path getWorkingDirectory(){
  return this.workingDirectory;
}",0.6451612903225806
113537,"@Override public FileStatus[] listStatus(Path hdPath) throws IOException {
  final String path=hdPath.toUri().getPath();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + path);
  DirectoryEntry[] list=volume.listEntries(path);
  FileStatus[] fslist=new FileStatus[list.length];
  for (int i=0; i < list.length; i++) {
    final DirectoryEntry e=list[i];
    final Stat s=e.getStbuf();
    final boolean isDir=(s.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFDIR) > 0;
    fslist[i]=new FileStatus(s.getSize(),isDir,1,1,(long)(s.getMtime_ns() / 1e6),(long)(s.getAtime_ns() / 1e6),new FsPermission((short)s.getMode()),s.getUser_id(),s.getGroup_id(),new Path(hdPath,e.getName()));
  }
  return fslist;
}","@Override public FileStatus[] listStatus(Path hdPath) throws IOException {
  if (hdPath == null)   return null;
  final String path=hdPath.toUri().getPath();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + path);
  DirectoryEntry[] list=volume.listEntries(path);
  if (list == null)   return null;
  FileStatus[] fslist=new FileStatus[list.length];
  for (int i=0; i < list.length; i++) {
    final DirectoryEntry e=list[i];
    final Stat s=e.getStbuf();
    final boolean isDir=(s.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFDIR) > 0;
    fslist[i]=new FileStatus(s.getSize(),isDir,1,1,(long)(s.getMtime_ns() / 1e6),(long)(s.getAtime_ns() / 1e6),new FsPermission((short)s.getMode()),s.getUser_id(),s.getGroup_id(),new Path(hdPath,e.getName()));
  }
  return fslist;
}",0.952
113538,"@Override public void setWorkingDirectory(Path arg0){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void setWorkingDirectory(Path arg0){
  this.workingDirectory=arg0;
}",0.6831683168316832
113539,"@Override public FSDataOutputStream create(Path file,FsPermission permissions,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable prog) throws IOException {
  final String path=file.toUri().getPath();
  File f=volume.getFile(path);
  String openMode=""String_Node_Str"";
  if (overwrite)   openMode+=""String_Node_Str"";
  final RandomAccessFile raf=f.open(openMode,permissions.toShort());
  return new FSDataOutputStream(new OutputStream(){
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      raf.write(b,off,len);
    }
    @Override public void write(    byte[] b) throws IOException {
      raf.write(b,0,b.length);
    }
    @Override public void write(    int b) throws IOException {
      raf.write(new byte[]{(byte)b},0,1);
    }
    @Override public void close() throws IOException {
      raf.close();
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") @Override public FSDataOutputStream create(Path file,FsPermission permissions,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable prog) throws IOException {
  final String path=file.toUri().getPath();
  File f=volume.getFile(path);
  String openMode=""String_Node_Str"";
  if (overwrite)   openMode+=""String_Node_Str"";
  f.createFile();
  final RandomAccessFile raf=f.open(openMode,permissions.toShort());
  return new FSDataOutputStream(new OutputStream(){
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      raf.write(b,off,len);
    }
    @Override public void write(    byte[] b) throws IOException {
      raf.write(b,0,b.length);
    }
    @Override public void write(    int b) throws IOException {
      raf.write(new byte[]{(byte)b},0,1);
    }
    @Override public void close() throws IOException {
      raf.close();
    }
  }
);
}",0.9701573521432448
113540,"@Override public void initialize(URI uri,Configuration conf) throws IOException {
  int logLevel=Logging.LEVEL_WARN;
  if (conf.getBoolean(""String_Node_Str"",false)) {
    logLevel=Logging.LEVEL_DEBUG;
  }
  Logging.start(logLevel,Category.all);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri);
  InetSocketAddress dir=new InetSocketAddress(uri.getHost(),uri.getPort());
  xtreemfsClient=new Client(new InetSocketAddress[]{dir},30 * 1000,15 * 60 * 1000,null);
  try {
    xtreemfsClient.start();
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
  UserCredentials uc=null;
  if ((conf.get(""String_Node_Str"") != null) && (conf.get(""String_Node_Str"") != null)) {
    StringSet grps=new StringSet();
    grps.add(conf.get(""String_Node_Str""));
    uc=new UserCredentials(conf.get(""String_Node_Str""),grps,""String_Node_Str"");
  }
  if (uc == null) {
    if (System.getenv(""String_Node_Str"") != null) {
      StringSet grps=new StringSet();
      grps.add(""String_Node_Str"");
      uc=new UserCredentials(System.getenv(""String_Node_Str""),grps,""String_Node_Str"");
    }
  }
  volume=xtreemfsClient.getVolume(uri.getUserInfo(),uc);
  fsURI=uri;
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri.getUserInfo());
}","@Override public void initialize(URI uri,Configuration conf) throws IOException {
  int logLevel=Logging.LEVEL_WARN;
  if (conf.getBoolean(""String_Node_Str"",false)) {
    logLevel=Logging.LEVEL_DEBUG;
  }
  String volumeName=conf.get(""String_Node_Str"");
  if (volumeName == null)   throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  Logging.start(logLevel,Category.all);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri);
  InetSocketAddress dir=new InetSocketAddress(uri.getHost(),uri.getPort());
  xtreemfsClient=new Client(new InetSocketAddress[]{dir},30 * 1000,15 * 60 * 1000,null);
  try {
    xtreemfsClient.start();
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
  UserCredentials uc=null;
  if ((conf.get(""String_Node_Str"") != null) && (conf.get(""String_Node_Str"") != null)) {
    StringSet grps=new StringSet();
    grps.add(conf.get(""String_Node_Str""));
    uc=new UserCredentials(conf.get(""String_Node_Str""),grps,""String_Node_Str"");
  }
  if (uc == null) {
    if (System.getenv(""String_Node_Str"") != null) {
      StringSet grps=new StringSet();
      grps.add(""String_Node_Str"");
      uc=new UserCredentials(System.getenv(""String_Node_Str""),grps,""String_Node_Str"");
    }
  }
  volume=xtreemfsClient.getVolume(volumeName,uc);
  fsURI=uri;
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + uri.getUserInfo());
}",0.9382440476190476
113541,"/** 
 * @param args
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
  System.out.println(""String_Node_Str"");
  Logging.start(Logging.LEVEL_ERROR);
  try {
    TimeSync.initialize(null,60000,50);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
  StringSet gids=new StringSet();
  gids.add(""String_Node_Str"");
  creds=new UserCredentials(""String_Node_Str"",gids,""String_Node_Str"");
  RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,2 * 60 * 1000,5 * 60 * 1000);
  rpcClient.start();
  if (args.length != 1)   usage();
  if (args[0].indexOf(""String_Node_Str"") == -1) {
    error(""String_Node_Str"");
  }
 else {
    for (    String adr : args[0].split(""String_Node_Str"")) {
      participants.add(new DIRClient(rpcClient,parseAddress(adr)));
    }
  }
  setupRandomMasterDIR();
  assert(LOOKUP_PERCENTAGE + DELETE_PERCENTAGE + INSERT_PERCENTAGE == 100);
  long start=System.currentTimeMillis();
  long operationCount=0;
  long s=start;
  System.out.println(""String_Node_Str"");
  try {
    while (true) {
      long now=System.currentTimeMillis();
      if ((start + CHECK_INTERVAL) < now) {
        long diff=(System.currentTimeMillis() - s) / 1000;
        System.out.println(""String_Node_Str"" + (diff - diff % 60 - ((diff - diff % 60) / 60) % 60) / 3600 + ""String_Node_Str"" + ((diff - diff % 60) / 60) % 60 + ""String_Node_Str"" + diff % 60 + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + ((double)(operationCount / (CHECK_INTERVAL / 1000))) + ""String_Node_Str"");
        operationCount=0;
        System.out.println(""String_Node_Str"" + masterChanges + ""String_Node_Str"");
        masterChanges=0;
        performConsistencyCheck();
        start=System.currentTimeMillis();
        setupRandomMasterDIR();
      }
 else {
        try {
          if (random.nextBoolean())           performAddressMappingOperation();
 else           performServiceOperation();
          operationCount++;
        }
 catch (        RedirectException e) {
          System.out.println(""String_Node_Str"" + viewID + ""String_Node_Str""+ actSeq+ ""String_Node_Str"");
          setupRandomMasterDIR();
        }
catch (        IOException e) {
          if (e.getMessage().equals(""String_Node_Str"")) {
            System.err.println(""String_Node_Str"" + kind + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
            for (            DIRClient c : participants) {
switch (kind) {
case 0:
                try {
                  performAddressMappingLookup(uuid,c);
                  System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
                }
 catch (                Exception e1) {
                  System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
                }
              break;
case 1:
            try {
              performServiceLookup(uuid,c);
              System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
            }
 catch (            Exception e1) {
              System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
            }
          break;
case 2:
        try {
          performAddressMappingLookup(uuid,c);
          System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
        }
 catch (        Exception e1) {
          System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
        }
      break;
case 3:
    try {
      performServiceLookup(uuid,c);
      System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
    }
 catch (    Exception e1) {
      System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
    }
  break;
default :
throw e;
}
}
}
 else throw e;
}
}
}
}
 catch (FailureException e) {
System.err.println(""String_Node_Str"" + e.kind + ""String_Node_Str""+ t.get(e.getMessage())+ ""String_Node_Str""+ (viewID - 1)+ ""String_Node_Str""+ (t.get(e.getMessage()) - (time - lastSeq))+ ""String_Node_Str""+ time+ ""String_Node_Str""+ e.getMessage());
String data=(e.kind == 0) ? availableAddressMappings.get(e.getMessage()).toString() : availableServices.get(e.getMessage()).toString();
System.err.println(""String_Node_Str"" + data);
for (DIRClient c : participants) {
try {
switch (e.kind) {
case 0:
performAddressMappingLookup(e.getMessage(),c);
break;
case 1:
performServiceLookup(e.getMessage(),c);
break;
default :
assert(false);
}
System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
}
 catch (Exception e2) {
System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
}
}
}
}","/** 
 * @param args
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
  System.out.println(""String_Node_Str"");
  Logging.start(Logging.LEVEL_ERROR);
  try {
    TimeSync.initializeLocal(60000,50);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
  StringSet gids=new StringSet();
  gids.add(""String_Node_Str"");
  creds=new UserCredentials(""String_Node_Str"",gids,""String_Node_Str"");
  RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,2 * 60 * 1000,5 * 60 * 1000);
  rpcClient.start();
  if (args.length != 1)   usage();
  if (args[0].indexOf(""String_Node_Str"") == -1) {
    error(""String_Node_Str"");
  }
 else {
    for (    String adr : args[0].split(""String_Node_Str"")) {
      participants.add(new DIRClient(rpcClient,parseAddress(adr)));
    }
  }
  setupRandomMasterDIR();
  assert(LOOKUP_PERCENTAGE + DELETE_PERCENTAGE + INSERT_PERCENTAGE == 100);
  long start=System.currentTimeMillis();
  long operationCount=0;
  long s=start;
  System.out.println(""String_Node_Str"");
  try {
    while (true) {
      long now=System.currentTimeMillis();
      if ((start + CHECK_INTERVAL) < now) {
        long diff=(System.currentTimeMillis() - s) / 1000;
        System.out.println(""String_Node_Str"" + (diff - diff % 60 - ((diff - diff % 60) / 60) % 60) / 3600 + ""String_Node_Str"" + ((diff - diff % 60) / 60) % 60 + ""String_Node_Str"" + diff % 60 + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + ((double)(operationCount / (CHECK_INTERVAL / 1000))) + ""String_Node_Str"");
        operationCount=0;
        System.out.println(""String_Node_Str"" + masterChanges + ""String_Node_Str"");
        masterChanges=0;
        performConsistencyCheck();
        start=System.currentTimeMillis();
        setupRandomMasterDIR();
      }
 else {
        try {
          if (random.nextBoolean())           performAddressMappingOperation();
 else           performServiceOperation();
          operationCount++;
        }
 catch (        RedirectException e) {
          System.out.println(""String_Node_Str"" + viewID + ""String_Node_Str""+ actSeq+ ""String_Node_Str"");
          setupRandomMasterDIR();
        }
catch (        IOException e) {
          if (e.getMessage().equals(""String_Node_Str"")) {
            System.err.println(""String_Node_Str"" + kind + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
            for (            DIRClient c : participants) {
switch (kind) {
case 0:
                try {
                  performAddressMappingLookup(uuid,c);
                  System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
                }
 catch (                Exception e1) {
                  System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
                }
              break;
case 1:
            try {
              performServiceLookup(uuid,c);
              System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
            }
 catch (            Exception e1) {
              System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
            }
          break;
case 2:
        try {
          performAddressMappingLookup(uuid,c);
          System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
        }
 catch (        Exception e1) {
          System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
        }
      break;
case 3:
    try {
      performServiceLookup(uuid,c);
      System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
    }
 catch (    Exception e1) {
      System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
    }
  break;
default :
throw e;
}
}
}
 else throw e;
}
}
}
}
 catch (FailureException e) {
System.err.println(""String_Node_Str"" + e.kind + ""String_Node_Str""+ t.get(e.getMessage())+ ""String_Node_Str""+ (viewID - 1)+ ""String_Node_Str""+ (t.get(e.getMessage()) - (time - lastSeq))+ ""String_Node_Str""+ time+ ""String_Node_Str""+ e.getMessage());
String data=(e.kind == 0) ? availableAddressMappings.get(e.getMessage()).toString() : availableServices.get(e.getMessage()).toString();
System.err.println(""String_Node_Str"" + data);
for (DIRClient c : participants) {
try {
switch (e.kind) {
case 0:
performAddressMappingLookup(e.getMessage(),c);
break;
case 1:
performServiceLookup(e.getMessage(),c);
break;
default :
assert(false);
}
System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
}
 catch (Exception e2) {
System.err.println(""String_Node_Str"" + c.getDefaultServerAddress());
}
}
}
}",0.9986801583809944
113542,"@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedRCMetadata tmp=isDirectory() ? new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount()) : new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly());
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
  if (!rcMetadata.isDirectory())   rcMetadata.setXLocList(rcMetadata.getXLocList());
}","@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedRCMetadata tmp=isDirectory() ? new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount()) : new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly());
  BufferBackedRCMetadata oldRCMetadata=rcMetadata;
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
  if (!rcMetadata.isDirectory())   rcMetadata.setXLocList(oldRCMetadata.getXLocList());
}",0.96
113543,"/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isInfo()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + knownOSDs.size() + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + exc);
    knownOSDs=new ServiceSet();
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}","/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + knownOSDs.size() + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + exc);
    knownOSDs=new ServiceSet();
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}",0.9955599407992106
113544,"@Override protected void processMethod(StageRequest method){
  if (method.getStageMethod() == STAGEOP_COORD_XCHG_REQUEST) {
    UDPMessage msg=(UDPMessage)method.getArgs()[0];
    final ReusableBuffer data=msg.getPayload();
    try {
      if (msg.isRequest()) {
        sendVivaldiResponse(msg,this.vNode.getCoordinates());
      }
 else       if (msg.isResponse()) {
        xtreemfs_pingResponse response=(xtreemfs_pingResponse)msg.getResponseData();
        VivaldiCoordinates coordinatesJ=response.getRemote_coordinates();
        SentRequest correspondingReq=sentRequests.remove(msg.getAddress());
        if (correspondingReq != null) {
          long now=System.currentTimeMillis();
          long estimatedRTT=now - correspondingReq.getSystemTime();
          if (estimatedRTT == 0) {
            estimatedRTT=1;
          }
          VivaldiRetry prevRetry=sentRetries.get(msg.getAddress());
          if (!vNode.recalculatePosition(coordinatesJ,estimatedRTT,false)) {
            if (prevRetry == null) {
              sentRetries.put(msg.getAddress(),new VivaldiRetry(estimatedRTT));
            }
 else {
              prevRetry.addRTT(estimatedRTT);
              prevRetry.setRetried(false);
              if (prevRetry.numberOfRetries() > MAX_RETRIES_FOR_A_REQUEST) {
                forceVivaldiRecalculation(coordinatesJ,prevRetry.getRTTs());
                sentRetries.remove(msg.getAddress());
              }
            }
          }
 else {
            if (Logging.isInfo()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,String.format(""String_Node_Str"",estimatedRTT,VivaldiNode.calculateDistance(vNode.getCoordinates(),coordinatesJ),vNode.getCoordinates().getX_coordinate(),vNode.getCoordinates().getY_coordinate(),vNode.getCoordinates().getLocal_error(),coordinatesJ.getX_coordinate(),coordinatesJ.getY_coordinate(),coordinatesJ.getLocal_error(),msg.getAddress().getHostName()));
            }
            if (prevRetry != null) {
              sentRetries.remove(msg.getAddress());
            }
          }
        }
      }
    }
  finally {
      if (data != null) {
        BufferPool.free(data);
      }
    }
  }
 else   if (method.getStageMethod() == STAGEOP_TCP_VIVALID_PING) {
    VivaldiPingCallback cb=(VivaldiPingCallback)method.getCallback();
    VivaldiCoordinates remoteCoordinates=(VivaldiCoordinates)method.getArgs()[0];
    cb.coordinatesCallback(remoteCoordinates,null);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override protected void processMethod(StageRequest method){
  if (method.getStageMethod() == STAGEOP_COORD_XCHG_REQUEST) {
    UDPMessage msg=(UDPMessage)method.getArgs()[0];
    final ReusableBuffer data=msg.getPayload();
    try {
      if (msg.isRequest()) {
        sendVivaldiResponse(msg,this.vNode.getCoordinates());
      }
 else       if (msg.isResponse()) {
        xtreemfs_pingResponse response=(xtreemfs_pingResponse)msg.getResponseData();
        VivaldiCoordinates coordinatesJ=response.getRemote_coordinates();
        SentRequest correspondingReq=sentRequests.remove(msg.getAddress());
        if (correspondingReq != null) {
          long now=System.currentTimeMillis();
          long estimatedRTT=now - correspondingReq.getSystemTime();
          if (estimatedRTT == 0) {
            estimatedRTT=1;
          }
          VivaldiRetry prevRetry=sentRetries.get(msg.getAddress());
          if (!vNode.recalculatePosition(coordinatesJ,estimatedRTT,false)) {
            if (prevRetry == null) {
              sentRetries.put(msg.getAddress(),new VivaldiRetry(estimatedRTT));
            }
 else {
              prevRetry.addRTT(estimatedRTT);
              prevRetry.setRetried(false);
              if (prevRetry.numberOfRetries() > MAX_RETRIES_FOR_A_REQUEST) {
                forceVivaldiRecalculation(coordinatesJ,prevRetry.getRTTs());
                sentRetries.remove(msg.getAddress());
              }
            }
          }
 else {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,String.format(""String_Node_Str"",estimatedRTT,VivaldiNode.calculateDistance(vNode.getCoordinates(),coordinatesJ),vNode.getCoordinates().getX_coordinate(),vNode.getCoordinates().getY_coordinate(),vNode.getCoordinates().getLocal_error(),coordinatesJ.getX_coordinate(),coordinatesJ.getY_coordinate(),coordinatesJ.getLocal_error(),msg.getAddress().getHostName()));
            }
            if (prevRetry != null) {
              sentRetries.remove(msg.getAddress());
            }
          }
        }
      }
    }
  finally {
      if (data != null) {
        BufferPool.free(data);
      }
    }
  }
 else   if (method.getStageMethod() == STAGEOP_TCP_VIVALID_PING) {
    VivaldiPingCallback cb=(VivaldiPingCallback)method.getCallback();
    VivaldiCoordinates remoteCoordinates=(VivaldiCoordinates)method.getArgs()[0];
    cb.coordinatesCallback(remoteCoordinates,null);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.998198919351611
113545,"public VivaldiStage(OSDRequestDispatcher master){
  super(""String_Node_Str"");
  this.master=master;
  this.dirClient=master.getDIRClient();
  this.sentRequests=new HashMap<InetSocketAddress,SentRequest>();
  this.sentRetries=new HashMap<InetSocketAddress,VivaldiRetry>();
  this.vNode=new VivaldiNode();
  if (Logging.isInfo()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,String.format(""String_Node_Str"",vNode.getCoordinates().getX_coordinate(),vNode.getCoordinates().getY_coordinate()));
  }
  this.knownOSDs=null;
  this.lastCheck=0;
}","public VivaldiStage(OSDRequestDispatcher master){
  super(""String_Node_Str"");
  this.master=master;
  this.dirClient=master.getDIRClient();
  this.sentRequests=new HashMap<InetSocketAddress,SentRequest>();
  this.sentRetries=new HashMap<InetSocketAddress,VivaldiRetry>();
  this.vNode=new VivaldiNode();
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,String.format(""String_Node_Str"",vNode.getCoordinates().getX_coordinate(),vNode.getCoordinates().getY_coordinate()));
  }
  this.knownOSDs=null;
  this.lastCheck=0;
}",0.9917203311867524
113546,"/** 
 * Executes one Vivaldi iteration. For each of these iterations, the algorithm chooses one random node from the list of known OSDs and sends it a Vivaldi request, to recalculate then the position of the OSD using the received information.
 */
private void iterateVivaldi(){
  if (vivaldiIterations % ITERATIONS_BEFORE_UPDATING == 1) {
    updateKnownOSDs();
  }
  if ((knownOSDs != null) && (!knownOSDs.isEmpty())) {
    if (sentRetries.size() > 0) {
      for (      InetSocketAddress addr : sentRetries.keySet()) {
        if (!sentRetries.get(addr).hasBeenRetried()) {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + addr.getHostName());
          sendVivaldiRequest(addr,vNode.getCoordinates());
          sentRetries.get(addr).setRetried(true);
        }
      }
    }
 else {
      int chosenIndex=(int)(Math.random() * knownOSDs.size());
      Service chosenService=knownOSDs.get(chosenIndex);
      try {
        ServiceUUID sUUID=new ServiceUUID(chosenService.getUuid());
        sUUID.resolve();
        if (Logging.isInfo())         Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + chosenService.getUuid());
        sendVivaldiRequest(sUUID.getAddress(),vNode.getCoordinates());
      }
 catch (      UnknownUUIDException unke) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + chosenService.getUuid());
      }
catch (      Exception e) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
      }
    }
  }
  vivaldiIterations=(vivaldiIterations + 1) % Long.MAX_VALUE;
}","/** 
 * Executes one Vivaldi iteration. For each of these iterations, the algorithm chooses one random node from the list of known OSDs and sends it a Vivaldi request, to recalculate then the position of the OSD using the received information.
 */
private void iterateVivaldi(){
  if (vivaldiIterations % ITERATIONS_BEFORE_UPDATING == 1) {
    updateKnownOSDs();
  }
  if ((knownOSDs != null) && (!knownOSDs.isEmpty())) {
    if (sentRetries.size() > 0) {
      for (      InetSocketAddress addr : sentRetries.keySet()) {
        if (!sentRetries.get(addr).hasBeenRetried()) {
          if (Logging.isDebug())           Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + addr.getHostName());
          sendVivaldiRequest(addr,vNode.getCoordinates());
          sentRetries.get(addr).setRetried(true);
        }
      }
    }
 else {
      int chosenIndex=(int)(Math.random() * knownOSDs.size());
      Service chosenService=knownOSDs.get(chosenIndex);
      try {
        ServiceUUID sUUID=new ServiceUUID(chosenService.getUuid());
        sUUID.resolve();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + chosenService.getUuid());
        sendVivaldiRequest(sUUID.getAddress(),vNode.getCoordinates());
      }
 catch (      UnknownUUIDException unke) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + chosenService.getUuid());
      }
catch (      Exception e) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
      }
    }
  }
  vivaldiIterations=(vivaldiIterations + 1) % Long.MAX_VALUE;
}",0.9943995021779714
113547,"/** 
 * Keeps the list of sent requests updated, by eliminating those whose timeout has expired.
 */
private void maintainSentRequests(){
  final long localNow=TimeSync.getLocalSystemTime();
  ArrayList<InetSocketAddress> removedRequests=new ArrayList<InetSocketAddress>();
  for (  InetSocketAddress reqKey : sentRequests.keySet()) {
    if (localNow >= sentRequests.get(reqKey).getLocalTime() + MAX_REQUEST_TIMEOUT_IN_MS) {
      if (Logging.isInfo())       Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + reqKey.getHostName());
      removedRequests.add(reqKey);
    }
  }
  for (  InetSocketAddress removed : removedRequests) {
    VivaldiRetry prevRetry=sentRetries.get(removed);
    if (prevRetry == null) {
      sentRetries.put(removed,new VivaldiRetry());
    }
 else {
      prevRetry.addTimeout();
      prevRetry.setRetried(false);
      if (prevRetry.numberOfRetries() > MAX_RETRIES_FOR_A_REQUEST) {
        forceVivaldiRecalculation(null,prevRetry.getRTTs());
        sentRetries.remove(removed);
      }
    }
    sentRequests.remove(removed);
  }
}","/** 
 * Keeps the list of sent requests updated, by eliminating those whose timeout has expired.
 */
private void maintainSentRequests(){
  final long localNow=TimeSync.getLocalSystemTime();
  ArrayList<InetSocketAddress> removedRequests=new ArrayList<InetSocketAddress>();
  for (  InetSocketAddress reqKey : sentRequests.keySet()) {
    if (localNow >= sentRequests.get(reqKey).getLocalTime() + MAX_REQUEST_TIMEOUT_IN_MS) {
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + reqKey.getHostName());
      removedRequests.add(reqKey);
    }
  }
  for (  InetSocketAddress removed : removedRequests) {
    VivaldiRetry prevRetry=sentRetries.get(removed);
    if (prevRetry == null) {
      sentRetries.put(removed,new VivaldiRetry());
    }
 else {
      prevRetry.addTimeout();
      prevRetry.setRetried(false);
      if (prevRetry.numberOfRetries() > MAX_RETRIES_FOR_A_REQUEST) {
        forceVivaldiRecalculation(null,prevRetry.getRTTs());
        sentRetries.remove(removed);
      }
    }
    sentRequests.remove(removed);
  }
}",0.995835261453031
113548,"public static String xLocListToJSON(XLocList xLocList) throws JSONException, UnknownUUIDException {
  Map<String,Object> list=new HashMap();
  list.put(""String_Node_Str"",xLocList.getReplUpdatePolicy());
  list.put(""String_Node_Str"",Long.valueOf(xLocList.getVersion()));
  List<Map<String,Object>> replicas=new ArrayList(xLocList.getReplicaCount());
  Iterator<XLoc> iter=xLocList.iterator();
  while (iter.hasNext()) {
    XLoc l=iter.next();
    Map<String,Object> replica=new HashMap();
    replica.put(""String_Node_Str"",getStripingPolicyAsJSON(l.getStripingPolicy()));
    replica.put(""String_Node_Str"",l.getReplicationFlags());
    List<Map<String,String>> osds=new ArrayList(l.getOSDCount());
    for (int i=0; i < l.getOSDCount(); i++) {
      Map<String,String> osd=new HashMap();
      final ServiceUUID uuid=new ServiceUUID(l.getOSD(i));
      osd.put(""String_Node_Str"",uuid.toString());
      osd.put(""String_Node_Str"",uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
      osds.add(osd);
    }
    replica.put(""String_Node_Str"",osds);
    replicas.add(replica);
  }
  list.put(""String_Node_Str"",replicas);
  return JSONParser.writeJSON(list);
}","public static String xLocListToJSON(XLocList xLocList,OSDStatusManager osdMan) throws JSONException, UnknownUUIDException {
  Map<String,Object> list=new HashMap();
  list.put(""String_Node_Str"",xLocList.getReplUpdatePolicy());
  list.put(""String_Node_Str"",Long.valueOf(xLocList.getVersion()));
  List<Map<String,Object>> replicas=new ArrayList(xLocList.getReplicaCount());
  Iterator<XLoc> iter=xLocList.iterator();
  while (iter.hasNext()) {
    XLoc l=iter.next();
    Map<String,Object> replica=new HashMap();
    replica.put(""String_Node_Str"",getStripingPolicyAsJSON(l.getStripingPolicy()));
    replica.put(""String_Node_Str"",l.getReplicationFlags());
    List<Map<String,String>> osds=new ArrayList(l.getOSDCount());
    for (int i=0; i < l.getOSDCount(); i++) {
      Map<String,String> osd=new HashMap();
      final ServiceUUID uuid=new ServiceUUID(l.getOSD(i));
      final Service osdData=osdMan.getOSDService(uuid.toString());
      final String coords=osdData == null ? ""String_Node_Str"" : osdData.getData().get(""String_Node_Str"");
      osd.put(""String_Node_Str"",uuid.toString());
      osd.put(""String_Node_Str"",coords);
      osd.put(""String_Node_Str"",uuid.getAddress().getHostName() + ""String_Node_Str"" + uuid.getAddress().getPort());
      osds.add(osd);
    }
    replica.put(""String_Node_Str"",osds);
    replicas.add(replica);
  }
  list.put(""String_Node_Str"",replicas);
  return JSONParser.writeJSON(list);
}",0.8777692895339955
113549,"public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException, UnknownUUIDException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList);
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
final String hostname=(config.getHostName().length() > 0) ? config.getHostName() : addr.getAddress().getCanonicalHostName();
return config.getURLScheme() + ""String_Node_Str"" + hostname+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
ServiceSet srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case repl_factor:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFactor()) : ""String_Node_Str"";
case repl_full:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFull()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
int i=0;
for (String snap : snaps) {
sb.append(snap);
if (i < snaps.length - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
}
}
return ""String_Node_Str"";
}","public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException, UnknownUUIDException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList,osdMan);
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
final String hostname=(config.getHostName().length() > 0) ? config.getHostName() : addr.getAddress().getCanonicalHostName();
return config.getURLScheme() + ""String_Node_Str"" + hostname+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
ServiceSet srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case repl_factor:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFactor()) : ""String_Node_Str"";
case repl_full:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFull()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
int i=0;
for (String snap : snaps) {
sb.append(snap);
if (i < snaps.length - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
}
}
return ""String_Node_Str"";
}",0.999046451437134
113550,"public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException, UnknownUUIDException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList);
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
return config.getURLScheme() + ""String_Node_Str"" + addr.getAddress().getCanonicalHostName()+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
ServiceSet srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case repl_factor:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFactor()) : ""String_Node_Str"";
case repl_full:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFull()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
int i=0;
for (String snap : snaps) {
sb.append(snap);
if (i < snaps.length - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
}
}
return ""String_Node_Str"";
}","public static String getSysAttrValue(MRCConfig config,StorageManager sMan,OSDStatusManager osdMan,String path,FileMetadata file,String keyString) throws DatabaseException, UserException, JSONException, UnknownUUIDException {
  if (keyString.startsWith(POLICY_ATTR_PREFIX.toString() + ""String_Node_Str""))   return getPolicyValue(sMan,keyString);
  SysAttrs key=null;
  try {
    key=SysAttrs.valueOf(keyString);
  }
 catch (  IllegalArgumentException exc) {
    throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + keyString + ""String_Node_Str"");
  }
  if (key != null) {
switch (key) {
case locations:
      if (file.isDirectory()) {
        return ""String_Node_Str"";
      }
 else {
        XLocList xLocList=file.getXLocList();
        return xLocList == null ? ""String_Node_Str"" : Converter.xLocListToJSON(xLocList);
      }
case file_id:
    return sMan.getVolumeInfo().getId() + ""String_Node_Str"" + file.getId();
case object_type:
  String ref=sMan.getSoftlinkTarget(file.getId());
return ref != null ? ""String_Node_Str"" : file.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"";
case url:
{
InetSocketAddress addr=config.getDirectoryService();
final String hostname=(config.getHostName().length() > 0) ? config.getHostName() : addr.getAddress().getCanonicalHostName();
return config.getURLScheme() + ""String_Node_Str"" + hostname+ ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str""+ path;
}
case owner:
return file.getOwnerId();
case group:
return file.getOwningGroupId();
case default_sp:
if (!file.isDirectory()) return ""String_Node_Str"";
StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
if (sp == null) return ""String_Node_Str"";
return Converter.stripingPolicyToJSONString(sp);
case ac_policy_id:
return file.getId() == 1 ? sMan.getVolumeInfo().getAcPolicyId() + ""String_Node_Str"" : ""String_Node_Str"";
case osel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getOsdPolicy()) : ""String_Node_Str"";
case rsel_policy:
return file.getId() == 1 ? Converter.shortArrayToString(sMan.getVolumeInfo().getReplicaPolicy()) : ""String_Node_Str"";
case read_only:
if (file.isDirectory()) return ""String_Node_Str"";
return String.valueOf(file.isReadOnly());
case usable_osds:
{
if (file.getId() != 1) return ""String_Node_Str"";
ServiceSet srvs=osdMan.getUsableOSDs(sMan.getVolumeInfo().getId());
Map<String,String> osds=new HashMap<String,String>();
for (Service srv : srvs) {
ServiceUUID uuid=new ServiceUUID(srv.getUuid());
InetAddress ia=uuid.getMappings()[0].resolvedAddr.getAddress();
osds.put(uuid.toString(),ia.getCanonicalHostName());
}
return JSONParser.writeJSON(osds);
}
case free_space:
return file.getId() == 1 ? String.valueOf(osdMan.getFreeSpace(sMan.getVolumeInfo().getId())) : ""String_Node_Str"";
case used_space:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getVolumeSize()) : ""String_Node_Str"";
case num_files:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumFiles()) : ""String_Node_Str"";
case num_dirs:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getNumDirs()) : ""String_Node_Str"";
case repl_factor:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFactor()) : ""String_Node_Str"";
case repl_full:
return file.getId() == 1 ? String.valueOf(sMan.getVolumeInfo().getAutoReplFull()) : ""String_Node_Str"";
case snapshots:
{
if (file.getId() != 1) return ""String_Node_Str"";
StringBuilder sb=new StringBuilder();
String[] snaps=sMan.getAllSnapshots();
int i=0;
for (String snap : snaps) {
sb.append(snap);
if (i < snaps.length - 1) sb.append(""String_Node_Str"");
i++;
}
return sb.toString();
}
}
}
return ""String_Node_Str"";
}",0.9769368871702804
113551,"public int getTag(){
  return 2009112044;
}","public int getTag(){
  return 2009120141;
}",0.9534883720930232
113552,"public int getTag(){
  return 2009112045;
}","public int getTag(){
  return 2009120142;
}",0.9534883720930232
113553,"public int getTag(){
  return 2009112134;
}","public int getTag(){
  return 2009120231;
}",0.9069767441860463
113554,"public int getTag(){
  return 2009112137;
}","public int getTag(){
  return 2009120234;
}",0.9302325581395348
113555,"public static int getVersion(){
  return 2009112114;
}","public static int getVersion(){
  return 2009120211;
}",0.9629629629629628
113556,"public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getProcedure()) {
case 2009112115:
    return new xtreemfs_address_mappings_getRequest();
case 2009112116:
  return new xtreemfs_address_mappings_removeRequest();
case 2009112117:
return new xtreemfs_address_mappings_setRequest();
case 2009112118:
return new xtreemfs_checkpointRequest();
case 2009112119:
return new xtreemfs_discover_dirRequest();
case 2009112120:
return new xtreemfs_global_time_s_getRequest();
case 2009112121:
return new xtreemfs_replication_to_masterRequest();
case 2009112126:
return new xtreemfs_service_deregisterRequest();
case 2009112124:
return new xtreemfs_service_get_by_nameRequest();
case 2009112122:
return new xtreemfs_service_get_by_typeRequest();
case 2009112123:
return new xtreemfs_service_get_by_uuidRequest();
case 2009112127:
return new xtreemfs_service_offlineRequest();
case 2009112125:
return new xtreemfs_service_registerRequest();
case 2009112128:
return new xtreemfs_shutdownRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getProcedure()));
}
}","public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getProcedure()) {
case 2009120212:
    return new xtreemfs_address_mappings_getRequest();
case 2009120213:
  return new xtreemfs_address_mappings_removeRequest();
case 2009120214:
return new xtreemfs_address_mappings_setRequest();
case 2009120215:
return new xtreemfs_checkpointRequest();
case 2009120216:
return new xtreemfs_discover_dirRequest();
case 2009120217:
return new xtreemfs_global_time_s_getRequest();
case 2009120218:
return new xtreemfs_replication_to_masterRequest();
case 2009120223:
return new xtreemfs_service_deregisterRequest();
case 2009120221:
return new xtreemfs_service_get_by_nameRequest();
case 2009120219:
return new xtreemfs_service_get_by_typeRequest();
case 2009120220:
return new xtreemfs_service_get_by_uuidRequest();
case 2009120224:
return new xtreemfs_service_offlineRequest();
case 2009120222:
return new xtreemfs_service_registerRequest();
case 2009120225:
return new xtreemfs_shutdownRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getProcedure()));
}
}",0.8872113676731794
113557,"public static ONCRPCException createException(int accept_stat) throws Exception {
switch (accept_stat) {
case 2009112134:
    return new ConcurrentModificationException();
case 2009112137:
  return new DIRException();
case 2009112135:
return new InvalidArgumentException();
case 2009112136:
return new ProtocolException();
case 2009112138:
return new RedirectException();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(accept_stat));
}
}","public static ONCRPCException createException(int accept_stat) throws Exception {
switch (accept_stat) {
case 2009120231:
    return new ConcurrentModificationException();
case 2009120234:
  return new DIRException();
case 2009120232:
return new InvalidArgumentException();
case 2009120233:
return new ProtocolException();
case 2009120235:
return new RedirectException();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(accept_stat));
}
}",0.8140043763676149
113558,"public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 2009112115:
    return new xtreemfs_address_mappings_getResponse();
case 2009112116:
  return new xtreemfs_address_mappings_removeResponse();
case 2009112117:
return new xtreemfs_address_mappings_setResponse();
case 2009112118:
return new xtreemfs_checkpointResponse();
case 2009112119:
return new xtreemfs_discover_dirResponse();
case 2009112120:
return new xtreemfs_global_time_s_getResponse();
case 2009112121:
return new xtreemfs_replication_to_masterResponse();
case 2009112126:
return new xtreemfs_service_deregisterResponse();
case 2009112124:
return new xtreemfs_service_get_by_nameResponse();
case 2009112122:
return new xtreemfs_service_get_by_typeResponse();
case 2009112123:
return new xtreemfs_service_get_by_uuidResponse();
case 2009112127:
return new xtreemfs_service_offlineResponse();
case 2009112125:
return new xtreemfs_service_registerResponse();
case 2009112128:
return new xtreemfs_shutdownResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}","public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 2009120212:
    return new xtreemfs_address_mappings_getResponse();
case 2009120213:
  return new xtreemfs_address_mappings_removeResponse();
case 2009120214:
return new xtreemfs_address_mappings_setResponse();
case 2009120215:
return new xtreemfs_checkpointResponse();
case 2009120216:
return new xtreemfs_discover_dirResponse();
case 2009120217:
return new xtreemfs_global_time_s_getResponse();
case 2009120218:
return new xtreemfs_replication_to_masterResponse();
case 2009120223:
return new xtreemfs_service_deregisterResponse();
case 2009120221:
return new xtreemfs_service_get_by_nameResponse();
case 2009120219:
return new xtreemfs_service_get_by_typeResponse();
case 2009120220:
return new xtreemfs_service_get_by_uuidResponse();
case 2009120224:
return new xtreemfs_service_offlineResponse();
case 2009120222:
return new xtreemfs_service_registerResponse();
case 2009120225:
return new xtreemfs_shutdownResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}",0.4986737400530504
113559,"public int getTag(){
  return 2009112135;
}","public int getTag(){
  return 2009120232;
}",0.9302325581395348
113560,"public int getTag(){
  return 2009112136;
}","public int getTag(){
  return 2009120233;
}",0.9302325581395348
113561,"public int getTag(){
  return 2009112138;
}","public int getTag(){
  return 2009120235;
}",0.9302325581395348
113562,"public int getTag(){
  return 2009112115;
}","public int getTag(){
  return 2009120212;
}",0.9302325581395348
113563,"public int getTag(){
  return 2009112115;
}","public int getTag(){
  return 2009120212;
}",0.9302325581395348
113564,"public int getTag(){
  return 2009112116;
}","public int getTag(){
  return 2009120213;
}",0.9302325581395348
113565,"public int getTag(){
  return 2009112116;
}","public int getTag(){
  return 2009120213;
}",0.9302325581395348
113566,"public int getTag(){
  return 2009112117;
}","public int getTag(){
  return 2009120214;
}",0.9302325581395348
113567,"public int getTag(){
  return 2009112117;
}","public int getTag(){
  return 2009120214;
}",0.9302325581395348
113568,"public int getTag(){
  return 2009112118;
}","public int getTag(){
  return 2009120215;
}",0.9302325581395348
113569,"public int getTag(){
  return 2009112118;
}","public int getTag(){
  return 2009120215;
}",0.9302325581395348
113570,"private void processGetGmax(StageRequest rq){
  final InternalGetGmaxCallback cback=(InternalGetGmaxCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[1];
    final FileInfo fi=layout.getFileInfo(sp,fileId);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId);
    }
    InternalGmax gmax=new InternalGmax(fi.getTruncateEpoch(),fi.getLastObjectNumber(),fi.getFilesize());
    cback.gmaxComplete(gmax,null);
  }
 catch (  IOException ex) {
    cback.gmaxComplete(null,ex);
  }
}","private void processGetGmax(StageRequest rq){
  final InternalGetGmaxCallback cback=(InternalGetGmaxCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[1];
    final FileInfo fi=layout.getFileInfo(sp,fileId);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",fileId);
    }
    InternalGmax gmax=new InternalGmax(fi.getTruncateEpoch(),fi.getFilesize(),fi.getLastObjectNumber());
    cback.gmaxComplete(gmax,null);
  }
 catch (  IOException ex) {
    cback.gmaxComplete(null,ex);
  }
}",0.973520249221184
113571,"private void assembleResponse(SelectionKey key,ServerConnection con){
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
  ONCRPCResponseHeader hdr=null;
  ReusableBuffer firstFragment=null;
  try {
    firstFragment=con.getResponseFragments().get(0);
    firstFragment.position(0);
    hdr=new ONCRPCResponseHeader();
    hdr.unmarshal(new XDRUnmarshaller(firstFragment));
  }
 catch (  Exception ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getChannel().socket().getRemoteSocketAddress().toString());
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,OutputUtils.stackTraceToString(ex));
    }
    closeConnection(key,new IOException(""String_Node_Str""));
    return;
  }
  final int xid=hdr.getXID();
  ONCRPCRequest rec=con.getRequest(xid);
  if (rec == null) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"",xid);
    con.clearResponseFragments();
    return;
  }
  if (ENABLE_STATISTICS) {
    rec.endT=System.nanoTime();
    con.bytesRX+=firstFragment.capacity();
  }
  rec.setResponseFragments(con.getResponseFragments());
  con.clearResponseFragments();
  final int accept_stat=hdr.getAcceptStat();
  if (accept_stat == ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS) {
    rec.getListener().responseAvailable(rec);
  }
 else {
    ONCRPCException exception=null;
    if (accept_stat <= ONCRPCResponseHeader.ACCEPT_STAT_SYSTEM_ERR) {
      exception=new ONCRPCError(accept_stat);
    }
 else {
      try {
        if (accept_stat >= DIRInterface.getVersion() && (accept_stat < DIRInterface.getVersion() + 100)) {
          exception=DIRInterface.createException(accept_stat);
        }
 else         if (accept_stat >= MRCInterface.getVersion() && (accept_stat < MRCInterface.getVersion() + 100)) {
          exception=MRCInterface.createException(accept_stat);
        }
 else         if (accept_stat >= OSDInterface.getVersion() && (accept_stat < OSDInterface.getVersion() + 100)) {
          exception=OSDInterface.createException(accept_stat);
        }
 else {
          throw new Exception();
        }
      }
 catch (      Exception ex) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",accept_stat);
        exception=new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_SYSTEM_ERR,0,""String_Node_Str"" + accept_stat);
      }
      assert(exception != null);
      try {
        exception.unmarshal(new XDRUnmarshaller(firstFragment));
      }
 catch (      Throwable ex) {
        rec.getListener().requestFailed(rec,new IOException(""String_Node_Str"" + ex));
        return;
      }
    }
    rec.getListener().remoteExceptionThrown(rec,exception);
  }
}","private void assembleResponse(SelectionKey key,ServerConnection con){
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"");
  ONCRPCResponseHeader hdr=null;
  ReusableBuffer firstFragment=null;
  try {
    firstFragment=con.getResponseFragments().get(0);
    firstFragment.position(0);
    hdr=new ONCRPCResponseHeader();
    hdr.unmarshal(new XDRUnmarshaller(firstFragment));
  }
 catch (  Exception ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,""String_Node_Str"",con.getChannel().socket().getRemoteSocketAddress().toString());
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.net,this,OutputUtils.stackTraceToString(ex));
    }
    closeConnection(key,new IOException(""String_Node_Str""));
    return;
  }
  final int xid=hdr.getXID();
  ONCRPCRequest rec=con.getRequest(xid);
  if (rec == null) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.net,this,""String_Node_Str"",xid);
    for (    ReusableBuffer frag : con.getResponseFragments()) {
      BufferPool.free(frag);
    }
    con.clearResponseFragments();
    return;
  }
  if (ENABLE_STATISTICS) {
    rec.endT=System.nanoTime();
    con.bytesRX+=firstFragment.capacity();
  }
  rec.setResponseFragments(con.getResponseFragments());
  con.clearResponseFragments();
  final int accept_stat=hdr.getAcceptStat();
  if (accept_stat == ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS) {
    rec.getListener().responseAvailable(rec);
  }
 else {
    ONCRPCException exception=null;
    if (accept_stat <= ONCRPCResponseHeader.ACCEPT_STAT_SYSTEM_ERR) {
      exception=new ONCRPCError(accept_stat);
    }
 else {
      try {
        if (accept_stat >= DIRInterface.getVersion() && (accept_stat < DIRInterface.getVersion() + 100)) {
          exception=DIRInterface.createException(accept_stat);
        }
 else         if (accept_stat >= MRCInterface.getVersion() && (accept_stat < MRCInterface.getVersion() + 100)) {
          exception=MRCInterface.createException(accept_stat);
        }
 else         if (accept_stat >= OSDInterface.getVersion() && (accept_stat < OSDInterface.getVersion() + 100)) {
          exception=OSDInterface.createException(accept_stat);
        }
 else {
          throw new Exception();
        }
      }
 catch (      Exception ex) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",accept_stat);
        exception=new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_SYSTEM_ERR,0,""String_Node_Str"" + accept_stat);
      }
      assert(exception != null);
      try {
        exception.unmarshal(new XDRUnmarshaller(firstFragment));
      }
 catch (      Throwable ex) {
        rec.getListener().requestFailed(rec,new IOException(""String_Node_Str"" + ex));
        return;
      }
    }
    rec.getListener().remoteExceptionThrown(rec,exception);
  }
}",0.9822190611664297
113572,"private void initializeDatabase(){
  final byte[] versionKey=""String_Node_Str"".getBytes();
  try {
    Database db=dbMan.createDatabase(""String_Node_Str"",1);
    ReusableBuffer rb=null;
    try {
      byte[] keyData=new byte[4];
      rb=ReusableBuffer.wrap(keyData);
      rb.putInt(DB_VERSION);
      db.singleInsert(0,versionKey,keyData,null).get();
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
 finally {
      if (rb != null)       BufferPool.free(rb);
    }
  }
 catch (  BabuDBException ex) {
    if (ex.getErrorCode() == BabuDBException.ErrorCode.DB_EXISTS) {
      ReusableBuffer rb=null;
      try {
        Database db=dbMan.getDatabase(""String_Node_Str"");
        byte[] value=db.lookup(0,versionKey,null).get();
        int ver=-1;
        if ((value != null) && (value.length == 4)) {
          rb=ReusableBuffer.wrap(value);
          ver=rb.getInt();
        }
        if (ver != DB_VERSION) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",ver,DIRInterface.getVersion());
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          System.exit(1);
        }
      }
 catch (      Exception ex2) {
        ex2.printStackTrace();
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
 finally {
        if (rb != null)         BufferPool.free(rb);
      }
    }
 else {
      ex.printStackTrace();
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  try {
    dbMan.createDatabase(""String_Node_Str"",3);
  }
 catch (  BabuDBException ex) {
  }
}","private void initializeDatabase(){
  final byte[] versionKey=""String_Node_Str"".getBytes();
  try {
    Database db=dbMan.createDatabase(""String_Node_Str"",1);
    ReusableBuffer rb=null;
    try {
      byte[] keyData=new byte[4];
      rb=ReusableBuffer.wrap(keyData);
      rb.putInt(DB_VERSION);
      db.singleInsert(0,versionKey,keyData,null).get();
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
 finally {
      if (rb != null)       BufferPool.free(rb);
    }
  }
 catch (  BabuDBException ex) {
    if (ex.getErrorCode() == BabuDBException.ErrorCode.DB_EXISTS) {
      ReusableBuffer rb=null;
      try {
        Database db=dbMan.getDatabase(""String_Node_Str"");
        byte[] value=db.lookup(0,versionKey,null).get();
        int ver=-1;
        if ((value != null) && (value.length == 4)) {
          rb=ReusableBuffer.wrap(value);
          ver=rb.getInt();
        }
        if (ver != DB_VERSION) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"",ver,DB_VERSION);
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          System.exit(1);
        }
      }
 catch (      Exception ex2) {
        ex2.printStackTrace();
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
 finally {
        if (rb != null)         BufferPool.free(rb);
      }
    }
 else {
      ex.printStackTrace();
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  try {
    dbMan.createDatabase(""String_Node_Str"",3);
  }
 catch (  BabuDBException ex) {
  }
}",0.9909752547307132
113573,"public static VivaldiCoordinates stringToCoordinates(String coordinates){
  VivaldiCoordinates vc=new VivaldiCoordinates();
  vc.setX_coordinate(OutputUtils.readHexLong(coordinates,0));
  vc.setY_coordinate(OutputUtils.readHexLong(coordinates,8));
  vc.setLocal_error(OutputUtils.readHexLong(coordinates,16));
  return vc;
}","public static VivaldiCoordinates stringToCoordinates(String coordinates){
  VivaldiCoordinates vc=new VivaldiCoordinates();
  vc.setX_coordinate(Double.longBitsToDouble(OutputUtils.readHexLong(coordinates,0)));
  vc.setY_coordinate(Double.longBitsToDouble(OutputUtils.readHexLong(coordinates,16)));
  vc.setLocal_error(Double.longBitsToDouble(OutputUtils.readHexLong(coordinates,32)));
  return vc;
}",0.7044198895027625
113574,"public DIROperation(DIRRequestDispatcher master){
  this.master=master;
}","public DIROperation(DIRRequestDispatcher master){
  this.master=master;
  dbsReplicationManager=master.getDBSReplicationService();
}",0.7121951219512195
113575,"public DeleteAddressMappingOperation(DIRRequestDispatcher master){
  super(master);
  operationNumber=xtreemfs_address_mappings_removeRequest.TAG;
  database=master.getDirDatabase();
  dbsReplicationManager=master.getDBSReplicationService();
}","public DeleteAddressMappingOperation(DIRRequestDispatcher master){
  super(master);
  operationNumber=xtreemfs_address_mappings_removeRequest.TAG;
  database=master.getDirDatabase();
}",0.8618266978922716
113576,"@Override public void startRequest(DIRRequest rq){
  final xtreemfs_address_mappings_removeRequest request=(xtreemfs_address_mappings_removeRequest)rq.getRequestMessage();
  BabuDBInsertGroup ig;
  try {
    ig=database.createInsertGroup();
  }
 catch (  BabuDBException e) {
    if (e.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)     rq.sendRedirectException(dbsReplicationManager.getMaster());
 else     rq.sendInternalServerError(e);
    return;
  }
  ig.addDelete(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
  database.insert(ig,rq).registerListener(new BabuDBRequestListener<Object>(){
    @Override public void finished(    Object arg0,    Object context){
      ((DIRRequest)context).sendSuccess(request.createDefaultResponse());
    }
    @Override public void failed(    BabuDBException ex,    Object context){
      Logging.logError(Logging.LEVEL_ERROR,this,ex);
      if (ex.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)       ((DIRRequest)context).sendRedirectException(dbsReplicationManager.getMaster());
 else       ((DIRRequest)context).sendInternalServerError(ex);
    }
  }
);
}","@Override public void startRequest(DIRRequest rq){
  xtreemfs_address_mappings_removeRequest request=(xtreemfs_address_mappings_removeRequest)rq.getRequestMessage();
  BabuDBInsertGroup ig;
  try {
    ig=database.createInsertGroup();
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    database.insert(ig,rq).registerListener(new DBRequestListener<Object,Object>(true){
      @Override Object execute(      Object result,      DIRRequest rq) throws Exception {
        return result;
      }
    }
);
  }
 catch (  BabuDBException e) {
    requestFailed(e,rq);
  }
}",0.5224719101123596
113577,"@Override public void startRequest(DIRRequest rq){
  final xtreemfs_service_deregisterRequest request=(xtreemfs_service_deregisterRequest)rq.getRequestMessage();
  BabuDBInsertGroup ig;
  try {
    ig=database.createInsertGroup();
  }
 catch (  BabuDBException ex) {
    if (ex.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)     rq.sendRedirectException(dbsReplicationManager.getMaster());
 else     rq.sendInternalServerError(ex);
    return;
  }
  ig.addDelete(DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
  database.insert(ig,rq).registerListener(new BabuDBRequestListener<Object>(){
    @Override public void finished(    Object arg0,    Object context){
      ((DIRRequest)context).sendSuccess(request.createDefaultResponse());
    }
    @Override public void failed(    BabuDBException e,    Object context){
      Logging.logError(Logging.LEVEL_ERROR,this,e);
      if (e.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)       ((DIRRequest)context).sendRedirectException(dbsReplicationManager.getMaster());
 else       ((DIRRequest)context).sendInternalServerError(e);
    }
  }
);
}","@Override public void startRequest(DIRRequest rq){
  xtreemfs_service_deregisterRequest request=(xtreemfs_service_deregisterRequest)rq.getRequestMessage();
  BabuDBInsertGroup ig;
  try {
    ig=database.createInsertGroup();
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
    database.insert(ig,rq).registerListener(new DBRequestListener<Object,Object>(true){
      @Override Object execute(      Object result,      DIRRequest rq) throws Exception {
        return result;
      }
    }
);
  }
 catch (  BabuDBException ex) {
    requestFailed(ex,rq);
    return;
  }
}",0.4833427442123094
113578,"public DeregisterServiceOperation(DIRRequestDispatcher master){
  super(master);
  operationNumber=xtreemfs_service_deregisterRequest.TAG;
  database=master.getDirDatabase();
  dbsReplicationManager=master.getDBSReplicationService();
}","public DeregisterServiceOperation(DIRRequestDispatcher master){
  super(master);
  operationNumber=xtreemfs_service_deregisterRequest.TAG;
  database=master.getDirDatabase();
}",0.8564476885644768
113579,"public void run(){
  List<RPCResponse> responses=new LinkedList<RPCResponse>();
  Map<String,Long> verMap=new HashMap<String,Long>();
  notifyStarted();
  while (!quit) {
synchronized (this) {
      responses.clear();
      try {
        for (        Service reg : serviceDataGen.getServiceData()) {
          RPCResponse<ServiceSet> r1=client.xtreemfs_service_get_by_uuid(null,reg.getUuid());
          long currentVersion=0;
          responses.add(r1);
          ServiceSet olset=r1.get();
          if (olset.size() > 0) {
            currentVersion=olset.get(0).getVersion();
          }
          reg.setVersion(currentVersion);
          RPCResponse<Long> r2=client.xtreemfs_service_register(null,reg);
          responses.add(r2);
          r2.get();
          if (Logging.isDebug())           Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",uuid);
        }
      }
 catch (      IOException ex) {
        Logging.logError(Logging.LEVEL_ERROR,this,ex);
      }
catch (      ONCRPCException ex) {
        Logging.logError(Logging.LEVEL_ERROR,this,ex);
      }
catch (      InterruptedException ex) {
        quit=true;
        break;
      }
 finally {
        for (        RPCResponse resp : responses)         resp.freeBuffers();
      }
      if (quit)       break;
    }
    try {
      Thread.sleep(UPDATE_INTERVAL);
    }
 catch (    InterruptedException e) {
    }
  }
  notifyStopped();
}","public void run(){
  List<RPCResponse> responses=new LinkedList<RPCResponse>();
  Map<String,Long> verMap=new HashMap<String,Long>();
  notifyStarted();
  while (!quit) {
synchronized (this) {
      responses.clear();
      try {
        for (        Service reg : serviceDataGen.getServiceData()) {
          RPCResponse<ServiceSet> r1=null;
          RPCResponse<Long> r2=null;
          try {
            r1=client.xtreemfs_service_get_by_uuid(null,reg.getUuid());
            long currentVersion=0;
            responses.add(r1);
            ServiceSet olset=r1.get();
            if (olset.size() > 0) {
              currentVersion=olset.get(0).getVersion();
            }
            reg.setVersion(currentVersion);
            r2=client.xtreemfs_service_register(null,reg);
            responses.add(r2);
            r2.get();
            if (Logging.isDebug())             Logging.logMessage(Logging.LEVEL_DEBUG,Category.misc,this,""String_Node_Str"",uuid);
          }
  finally {
            if (r1 != null) {
              r1.freeBuffers();
            }
            if (r2 != null) {
              r2.freeBuffers();
            }
          }
        }
      }
 catch (      IOException ex) {
        Logging.logError(Logging.LEVEL_ERROR,this,ex);
      }
catch (      ONCRPCException ex) {
        Logging.logError(Logging.LEVEL_ERROR,this,ex);
      }
catch (      InterruptedException ex) {
        quit=true;
        break;
      }
 finally {
        for (        RPCResponse resp : responses)         resp.freeBuffers();
      }
      if (quit)       break;
    }
    try {
      Thread.sleep(UPDATE_INTERVAL);
    }
 catch (    InterruptedException e) {
    }
  }
  notifyStopped();
}",0.9035759897828864
113580,"/** 
 * resynchronizes with the global time obtained from the DIR
 */
private void resync(){
  if (dir == null)   return;
  RPCResponse<Long> r=null;
  try {
    long tStart=localSysTime;
    long oldDrift=currentDrift;
    r=dir.xtreemfs_global_time_get(null);
    Long globalTime=r.get();
    r.freeBuffers();
    long tEnd=System.currentTimeMillis();
    syncRTT=(int)(tEnd - tStart);
    globalTime+=syncRTT / 2;
    syncSuccess=true;
    currentDrift=globalTime - tEnd;
    lastSync=tEnd;
    if (Math.abs(oldDrift - currentDrift) > 5000 && oldDrift != 0) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",oldDrift,currentDrift);
    }
  }
 catch (  Exception ex) {
    if (r != null) {
      r.freeBuffers();
    }
    syncSuccess=false;
    ex.printStackTrace();
    lastSync=System.currentTimeMillis();
  }
}","/** 
 * resynchronizes with the global time obtained from the DIR
 */
private void resync(){
  if (dir == null)   return;
  RPCResponse<Long> r=null;
  try {
    long tStart=localSysTime;
    long oldDrift=currentDrift;
    r=dir.xtreemfs_global_time_get(null);
    Long globalTime=r.get();
    long tEnd=System.currentTimeMillis();
    syncRTT=(int)(tEnd - tStart);
    globalTime+=syncRTT / 2;
    syncSuccess=true;
    currentDrift=globalTime - tEnd;
    lastSync=tEnd;
    if (Math.abs(oldDrift - currentDrift) > 5000 && oldDrift != 0) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",oldDrift,currentDrift);
    }
  }
 catch (  Exception ex) {
    syncSuccess=false;
    ex.printStackTrace();
    lastSync=System.currentTimeMillis();
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
  }
}",0.872491145218418
113581,"@Override public void startRequest(DIRRequest rq){
  final xtreemfs_service_get_by_nameRequest request=(xtreemfs_service_get_by_nameRequest)rq.getRequestMessage();
  database.prefixLookup(DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0],rq).registerListener(new BabuDBRequestListener<Iterator<Entry<byte[],byte[]>>>(){
    @Override public void finished(    Iterator<Entry<byte[],byte[]>> iter,    Object context){
      try {
        ServiceSet services=new ServiceSet();
        long now=System.currentTimeMillis() / 1000l;
        while (iter.hasNext()) {
          Entry<byte[],byte[]> e=iter.next();
          ServiceRecord servEntry=new ServiceRecord(ReusableBuffer.wrap(e.getValue()));
          if (servEntry.getName().equals(request.getName()))           services.add(servEntry.getService());
          long secondsSinceLastUpdate=now - servEntry.getLast_updated_s();
          servEntry.getData().put(""String_Node_Str"",Long.toString(secondsSinceLastUpdate));
        }
        ((DIRRequest)context).sendSuccess(request.createDefaultResponse());
      }
 catch (      IOException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
        ((DIRRequest)context).sendInternalServerError(e);
      }
    }
    @Override public void failed(    BabuDBException e,    Object context){
      Logging.logError(Logging.LEVEL_ERROR,this,e);
      if (e.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)       ((DIRRequest)context).sendRedirectException(dbsReplicationManager.getMaster());
 else       ((DIRRequest)context).sendInternalServerError(e);
    }
  }
);
}","@Override public void startRequest(DIRRequest rq){
  final xtreemfs_service_get_by_nameRequest request=(xtreemfs_service_get_by_nameRequest)rq.getRequestMessage();
  database.prefixLookup(DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0],rq).registerListener(new BabuDBRequestListener<Iterator<Entry<byte[],byte[]>>>(){
    @Override public void finished(    Iterator<Entry<byte[],byte[]>> iter,    Object context){
      try {
        ServiceSet services=new ServiceSet();
        long now=System.currentTimeMillis() / 1000l;
        while (iter.hasNext()) {
          Entry<byte[],byte[]> e=iter.next();
          ServiceRecord servEntry=new ServiceRecord(ReusableBuffer.wrap(e.getValue()));
          if (servEntry.getName().equals(request.getName()))           services.add(servEntry.getService());
          long secondsSinceLastUpdate=now - servEntry.getLast_updated_s();
          servEntry.getData().put(""String_Node_Str"",Long.toString(secondsSinceLastUpdate));
        }
        xtreemfs_service_get_by_nameResponse response=new xtreemfs_service_get_by_nameResponse(services);
        ((DIRRequest)context).sendSuccess(response);
      }
 catch (      IOException e) {
        Logging.logError(Logging.LEVEL_ERROR,this,e);
        ((DIRRequest)context).sendInternalServerError(e);
      }
    }
    @Override public void failed(    BabuDBException e,    Object context){
      Logging.logError(Logging.LEVEL_ERROR,this,e);
      if (e.getErrorCode() == ErrorCode.NO_ACCESS && dbsReplicationManager != null)       ((DIRRequest)context).sendRedirectException(dbsReplicationManager.getMaster());
 else       ((DIRRequest)context).sendInternalServerError(e);
    }
  }
);
}",0.9569202566452796
113582,"@Override public void finished(Iterator<Entry<byte[],byte[]>> iter,Object context){
  try {
    ServiceSet services=new ServiceSet();
    long now=System.currentTimeMillis() / 1000l;
    while (iter.hasNext()) {
      Entry<byte[],byte[]> e=iter.next();
      ServiceRecord servEntry=new ServiceRecord(ReusableBuffer.wrap(e.getValue()));
      if (servEntry.getName().equals(request.getName()))       services.add(servEntry.getService());
      long secondsSinceLastUpdate=now - servEntry.getLast_updated_s();
      servEntry.getData().put(""String_Node_Str"",Long.toString(secondsSinceLastUpdate));
    }
    ((DIRRequest)context).sendSuccess(request.createDefaultResponse());
  }
 catch (  IOException e) {
    Logging.logError(Logging.LEVEL_ERROR,this,e);
    ((DIRRequest)context).sendInternalServerError(e);
  }
}","@Override public void finished(Iterator<Entry<byte[],byte[]>> iter,Object context){
  try {
    ServiceSet services=new ServiceSet();
    long now=System.currentTimeMillis() / 1000l;
    while (iter.hasNext()) {
      Entry<byte[],byte[]> e=iter.next();
      ServiceRecord servEntry=new ServiceRecord(ReusableBuffer.wrap(e.getValue()));
      if (servEntry.getName().equals(request.getName()))       services.add(servEntry.getService());
      long secondsSinceLastUpdate=now - servEntry.getLast_updated_s();
      servEntry.getData().put(""String_Node_Str"",Long.toString(secondsSinceLastUpdate));
    }
    xtreemfs_service_get_by_nameResponse response=new xtreemfs_service_get_by_nameResponse(services);
    ((DIRRequest)context).sendSuccess(response);
  }
 catch (  IOException e) {
    Logging.logError(Logging.LEVEL_ERROR,this,e);
    ((DIRRequest)context).sendInternalServerError(e);
  }
}",0.9199298655756868
113583,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final chownRequest rqArgs=(chownRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  String target=sMan.getSoftlinkTarget(file.getId());
  if (target != null) {
    rqArgs.setPath(target);
    p=new Path(target);
    if (!vMan.hasVolume(p.getComp(0))) {
      finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
      return;
    }
    sMan=vMan.getStorageManagerByName(p.getComp(0));
    res=new PathResolver(sMan,p);
    file=res.getFile();
  }
  if (!rqArgs.getUser_id().equals(""String_Node_Str"")) {
    if (!rq.getDetails().superUser)     throw new UserException(ErrNo.EACCES,""String_Node_Str"");
  }
 else {
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (!(rq.getDetails().superUser || rq.getDetails().groupIds.contains(rqArgs.getGroup_id())))     throw new UserException(ErrNo.EACCES,""String_Node_Str"");
  }
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  file.setOwnerAndGroup(rqArgs.getUser_id().equals(""String_Node_Str"") ? file.getOwnerId() : rqArgs.getUser_id(),rqArgs.getGroup_id().equals(""String_Node_Str"") ? file.getOwningGroupId() : rqArgs.getGroup_id());
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
  rq.setResponse(new chownResponse());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final chownRequest rqArgs=(chownRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  validateContext(rq);
  Path p=new Path(rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  res.checkIfFileDoesNotExist();
  FileMetadata file=res.getFile();
  String target=sMan.getSoftlinkTarget(file.getId());
  if (target != null) {
    rqArgs.setPath(target);
    p=new Path(target);
    if (!vMan.hasVolume(p.getComp(0))) {
      finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
      return;
    }
    sMan=vMan.getStorageManagerByName(p.getComp(0));
    res=new PathResolver(sMan,p);
    file=res.getFile();
  }
  if (!rqArgs.getUser_id().equals(""String_Node_Str"")) {
    if (!rq.getDetails().superUser)     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
  }
 else {
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (!(rq.getDetails().superUser || rq.getDetails().groupIds.contains(rqArgs.getGroup_id())))     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
  }
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  file.setOwnerAndGroup(rqArgs.getUser_id().equals(""String_Node_Str"") ? file.getOwnerId() : rqArgs.getUser_id(),rqArgs.getGroup_id().equals(""String_Node_Str"") ? file.getOwningGroupId() : rqArgs.getGroup_id());
  sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
  rq.setResponse(new chownResponse());
  update.execute();
}",0.9964303926568078
113584,"@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  return file.getPerms();
}","@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  return file.isReadOnly() ? file.getPerms() & READ_ONLY_MASK : file.getPerms();
}",0.8578811369509044
113585,"@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  try {
    ACLEntry entry=sMan.getACLEntry(1,userId);
    if (entry == null)     entry=sMan.getACLEntry(1,DEFAULT_ENTRY_NAME);
    int rights=entry.getRights() & 3 | ((entry.getRights() & 1) << 2);
    return rights * (1 << 6);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  try {
    ACLEntry entry=sMan.getACLEntry(1,userId);
    if (entry == null)     entry=sMan.getACLEntry(1,DEFAULT_ENTRY_NAME);
    int rights=entry.getRights() & 3 | ((entry.getRights() & 1) << 2);
    rights=rights * (1 << 6);
    return file.isReadOnly() ? rights & READ_ONLY_MASK : rights;
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.9179978700745474
113586,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final closeRequest rqArgs=(closeRequest)rq.getRequestArgs();
  Capability cap=new Capability(rqArgs.getWrite_xcap(),master.getConfig().getCapabilitySecret());
  if (!cap.hasValidSignature())   throw new UserException(ErrNo.EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(ErrNo.EPERM,cap + ""String_Node_Str"");
  if (cap.getXCap().getReplicateOnClose()) {
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(cap.getFileId());
    StorageManager sMan=master.getVolumeManager().getStorageManager(idRes.getVolumeId());
    VolumeInfo vol=sMan.getVolumeInfo();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    file.setReadOnly(true);
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    int replFactor=vol.getAutoReplFactor();
    if (replFactor > xLocList.getReplicaCount()) {
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls.add(xLocList.getReplica(i));
      int newVer=xLocList.getVersion() + 1;
      XLoc firstRepl=repls.get(0);
      firstRepl.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(firstRepl.getReplicationFlags()));
      try {
        for (int i=0; i < replFactor - xLocList.getReplicaCount(); i++) {
          int replFlags=ReplicationFlags.setRandomStrategy(0);
          if (vol.getAutoReplFull())           replFlags=ReplicationFlags.setFullReplica(replFlags);
          Replica newRepl=MRCHelper.createReplica(firstRepl.getStripingPolicy(),sMan,master.getOSDStatusManager(),vol,-1,cap.getFileId(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList,replFlags);
          String[] osds=newRepl.getOsd_uuids().toArray(new String[newRepl.getOsd_uuids().size()]);
          repls.add(sMan.createXLoc(firstRepl.getStripingPolicy(),osds,newRepl.getReplication_flags()));
          xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),Constants.REPL_UPDATE_PC_RONLY,newVer);
        }
      }
 catch (      Exception exc) {
        Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",file.getId());
        Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,OutputUtils.stackTraceToString(exc));
      }
      file.setXLocList(xLocList);
    }
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",vol.getAutoReplFactor() - 1);
    XLocSet xLocSet=Converter.xLocListToXLocSet(xLocList);
    xLocSet.setRead_only_file_size(file.getSize());
    rq.getDetails().context=new HashMap<String,Object>();
    rq.getDetails().context.put(""String_Node_Str"",xLocSet);
    master.getOnCloseReplicationThread().enqueueRequest(rq);
    rq.setResponse(new closeResponse());
    update.execute();
  }
 else {
    rq.setResponse(new closeResponse());
    Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"",cap.toString());
    finishRequest(rq);
  }
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final closeRequest rqArgs=(closeRequest)rq.getRequestArgs();
  Capability cap=new Capability(rqArgs.getWrite_xcap(),master.getConfig().getCapabilitySecret());
  if (!cap.hasValidSignature())   throw new UserException(ErrNo.EPERM,cap + ""String_Node_Str"");
  if (cap.hasExpired())   throw new UserException(ErrNo.EPERM,cap + ""String_Node_Str"");
  if (cap.getXCap().getReplicateOnClose()) {
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(cap.getFileId());
    StorageManager sMan=master.getVolumeManager().getStorageManager(idRes.getVolumeId());
    VolumeInfo vol=sMan.getVolumeInfo();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    file.setReadOnly(true);
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    int replFactor=vol.getAutoReplFactor();
    if (replFactor > xLocList.getReplicaCount()) {
      List<XLoc> repls=new ArrayList<XLoc>();
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls.add(xLocList.getReplica(i));
      int newVer=xLocList.getVersion() + 1;
      int initialReplCount=xLocList.getReplicaCount();
      XLoc firstRepl=repls.get(0);
      firstRepl.setReplicationFlags(ReplicationFlags.setReplicaIsComplete(firstRepl.getReplicationFlags()));
      try {
        for (int i=0; i < replFactor - initialReplCount; i++) {
          int replFlags=ReplicationFlags.setRandomStrategy(0);
          if (vol.getAutoReplFull())           replFlags=ReplicationFlags.setFullReplica(replFlags);
          Replica newRepl=MRCHelper.createReplica(firstRepl.getStripingPolicy(),sMan,master.getOSDStatusManager(),vol,-1,cap.getFileId(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList,replFlags);
          String[] osds=newRepl.getOsd_uuids().toArray(new String[newRepl.getOsd_uuids().size()]);
          repls.add(sMan.createXLoc(firstRepl.getStripingPolicy(),osds,newRepl.getReplication_flags()));
          xLocList=sMan.createXLocList(repls.toArray(new XLoc[repls.size()]),Constants.REPL_UPDATE_PC_RONLY,newVer);
        }
      }
 catch (      Exception exc) {
        Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,""String_Node_Str"",file.getId());
        Logging.logMessage(Logging.LEVEL_WARN,Category.replication,this,OutputUtils.stackTraceToString(exc));
      }
      file.setXLocList(xLocList);
    }
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",vol.getAutoReplFactor() - 1);
    XLocSet xLocSet=Converter.xLocListToXLocSet(xLocList);
    xLocSet.setRead_only_file_size(file.getSize());
    rq.getDetails().context=new HashMap<String,Object>();
    rq.getDetails().context.put(""String_Node_Str"",xLocSet);
    master.getOnCloseReplicationThread().enqueueRequest(rq);
    rq.setResponse(new closeResponse());
    update.execute();
  }
 else {
    rq.setResponse(new closeResponse());
    Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"",cap.toString());
    finishRequest(rq);
  }
}",0.9872452719542588
113587,"/** 
 * resynchronizes with the global time obtained from the DIR
 */
private void resync(){
  if (dir == null)   return;
  try {
    long tStart=localSysTime;
    long oldDrift=currentDrift;
    RPCResponse<Long> r=dir.xtreemfs_global_time_get(null);
    Long globalTime=r.get();
    r.freeBuffers();
    long tEnd=System.currentTimeMillis();
    syncRTT=(int)(tEnd - tStart);
    globalTime+=syncRTT / 2;
    syncSuccess=true;
    currentDrift=globalTime - tEnd;
    lastSync=tEnd;
    if (Math.abs(oldDrift - currentDrift) > 5000 && oldDrift != 0) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",oldDrift,currentDrift);
    }
  }
 catch (  Exception ex) {
    syncSuccess=false;
    ex.printStackTrace();
    lastSync=System.currentTimeMillis();
  }
}","/** 
 * resynchronizes with the global time obtained from the DIR
 */
private void resync(){
  if (dir == null)   return;
  RPCResponse<Long> r=null;
  try {
    long tStart=localSysTime;
    long oldDrift=currentDrift;
    r=dir.xtreemfs_global_time_get(null);
    Long globalTime=r.get();
    r.freeBuffers();
    long tEnd=System.currentTimeMillis();
    syncRTT=(int)(tEnd - tStart);
    globalTime+=syncRTT / 2;
    syncSuccess=true;
    currentDrift=globalTime - tEnd;
    lastSync=tEnd;
    if (Math.abs(oldDrift - currentDrift) > 5000 && oldDrift != 0) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.misc,this,""String_Node_Str"",oldDrift,currentDrift);
    }
  }
 catch (  Exception ex) {
    if (r != null) {
      r.freeBuffers();
    }
    syncSuccess=false;
    ex.printStackTrace();
    lastSync=System.currentTimeMillis();
  }
}",0.875609756097561
113588,"public OSDRequestDispatcher(OSDConfig config) throws Exception {
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + VersionManagement.RELEASE_VERSION);
  this.config=config;
  assert(config.getUUID() != null);
  if (this.config.getDirectoryService().getHostName().equals(DiscoveryUtils.AUTODISCOVER_HOSTNAME)) {
    Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"");
    DirService dir=DiscoveryUtils.discoverDir(10);
    if (dir == null) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.net,this,""String_Node_Str"");
      throw new IOException(""String_Node_Str"");
    }
    Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"" + dir.getAddress() + ""String_Node_Str""+ dir.getPort());
    config.setDirectoryService(new InetSocketAddress(dir.getAddress(),dir.getPort()));
  }
  numBytesTX=new AtomicLong();
  numBytesRX=new AtomicLong();
  numObjsTX=new AtomicLong();
  numObjsRX=new AtomicLong();
  numReplBytesRX=new AtomicLong();
  numReplObjsRX=new AtomicLong();
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new HashMap();
  internalEvents=new HashMap<Class,OSDOperation>();
  initializeOperations();
  SSLOptions serverSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcServer=new RPCNIOSocketServer(config.getPort(),config.getAddress(),this,serverSSLopts);
  rpcServer.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  rpcClientForReplication=new RPCNIOSocketClient(clientSSLopts,30000,5 * 60 * 1000);
  rpcClientForReplication.setLifeCycleListener(this);
  this.serviceAvailability=new ServiceAvailability();
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  udpCom=new UDPCommunicator(config.getPort(),this);
  udpCom.setLifeCycleListener(this);
  preprocStage=new PreprocStage(this);
  preprocStage.setLifeCycleListener(this);
  stStage=new StorageStage(this,metadataCache,storageLayout,1);
  stStage.setLifeCycleListener(this);
  delStage=new DeletionStage(this,metadataCache,storageLayout);
  delStage.setLifeCycleListener(this);
  replStage=new ReplicationStage(this);
  replStage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  mrcClient=new MRCClient(rpcClient,null);
  osdClient=new OSDClient(rpcClient);
  osdClientForReplication=new OSDClient(rpcClientForReplication);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew());
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL() ? Constants.ONCRPCS_SCHEME : Constants.ONCRPC_SCHEME);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL() ? Constants.ONCRPCU_SCHEME : Constants.ONCRPC_SCHEME);
  myCoordinates=new AtomicReference<VivaldiCoordinates>();
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceSet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceSet data=new ServiceSet();
      ServiceDataMap dmap=new ServiceDataMap();
      dmap.put(""String_Node_Str"",load);
      dmap.put(""String_Node_Str"",totalSpace);
      dmap.put(""String_Node_Str"",freeSpace);
      dmap.put(""String_Node_Str"",Long.toString(totalRAM));
      dmap.put(""String_Node_Str"",Long.toString(usedRAM));
      dmap.put(""String_Node_Str"",config.getGeoCoordinates());
      dmap.put(""String_Node_Str"",Integer.toString(OSDInterface.getVersion()));
      VivaldiCoordinates coord=myCoordinates.get();
      if (coord != null) {
        dmap.put(""String_Node_Str"",VivaldiNode.coordinatesToString(coord));
      }
      dmap.putAll(config.getCustomParams());
      try {
        final String address=""String_Node_Str"".equals(config.getHostName()) ? config.getAddress() == null ? config.getUUID().getMappings()[0].resolvedAddr.getAddress().getHostAddress() : config.getAddress().getHostAddress() : config.getHostName();
        dmap.put(""String_Node_Str"",""String_Node_Str"" + address + ""String_Node_Str""+ config.getHttpPort());
      }
 catch (      UnknownUUIDException ex) {
      }
      Service me=new Service(ServiceType.SERVICE_TYPE_OSD,config.getUUID().toString(),0,""String_Node_Str"" + config.getUUID(),0,dmap);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,config,true);
  httpServ=HttpServer.create(new InetSocketAddress(config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(OSDRequestDispatcher.this).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      Throwable ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  startupTime=System.currentTimeMillis();
  cThread=new CleanupThread(this,(HashStorageLayout)storageLayout);
  cThread.setLifeCycleListener(this);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.lifecycle,this,""String_Node_Str"",this.getConfig().getUUID().toString());
}","public OSDRequestDispatcher(OSDConfig config) throws Exception {
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + VersionManagement.RELEASE_VERSION);
  this.config=config;
  assert(config.getUUID() != null);
  if (this.config.getDirectoryService().getHostName().equals(DiscoveryUtils.AUTODISCOVER_HOSTNAME)) {
    Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"");
    DirService dir=DiscoveryUtils.discoverDir(10);
    if (dir == null) {
      Logging.logMessage(Logging.LEVEL_ERROR,Category.net,this,""String_Node_Str"");
      throw new IOException(""String_Node_Str"");
    }
    Logging.logMessage(Logging.LEVEL_INFO,Category.net,this,""String_Node_Str"" + dir.getAddress() + ""String_Node_Str""+ dir.getPort());
    config.setDirectoryService(new InetSocketAddress(dir.getAddress(),dir.getPort()));
  }
  numBytesTX=new AtomicLong();
  numBytesRX=new AtomicLong();
  numObjsTX=new AtomicLong();
  numObjsRX=new AtomicLong();
  numReplBytesRX=new AtomicLong();
  numReplObjsRX=new AtomicLong();
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new HashMap();
  internalEvents=new HashMap<Class,OSDOperation>();
  initializeOperations();
  SSLOptions serverSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcServer=new RPCNIOSocketServer(config.getPort(),config.getAddress(),this,serverSSLopts);
  rpcServer.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  rpcClientForReplication=new RPCNIOSocketClient(clientSSLopts,30000,5 * 60 * 1000);
  rpcClientForReplication.setLifeCycleListener(this);
  this.serviceAvailability=new ServiceAvailability();
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  udpCom=new UDPCommunicator(config.getPort(),this);
  udpCom.setLifeCycleListener(this);
  preprocStage=new PreprocStage(this);
  preprocStage.setLifeCycleListener(this);
  stStage=new StorageStage(this,metadataCache,storageLayout,1);
  stStage.setLifeCycleListener(this);
  delStage=new DeletionStage(this,metadataCache,storageLayout);
  delStage.setLifeCycleListener(this);
  replStage=new ReplicationStage(this);
  replStage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  mrcClient=new MRCClient(rpcClient,null);
  osdClient=new OSDClient(rpcClient);
  osdClientForReplication=new OSDClient(rpcClientForReplication);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew());
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL() ? Constants.ONCRPCS_SCHEME : Constants.ONCRPC_SCHEME);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL() ? Constants.ONCRPCU_SCHEME : Constants.ONCRPC_SCHEME);
  myCoordinates=new AtomicReference<VivaldiCoordinates>();
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceSet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceSet data=new ServiceSet();
      ServiceDataMap dmap=new ServiceDataMap();
      dmap.put(""String_Node_Str"",load);
      dmap.put(""String_Node_Str"",totalSpace);
      dmap.put(""String_Node_Str"",freeSpace);
      dmap.put(""String_Node_Str"",Long.toString(totalRAM));
      dmap.put(""String_Node_Str"",Long.toString(usedRAM));
      dmap.put(""String_Node_Str"",config.getGeoCoordinates());
      dmap.put(""String_Node_Str"",Integer.toString(OSDInterface.getVersion()));
      VivaldiCoordinates coord=myCoordinates.get();
      if (coord != null) {
        dmap.put(""String_Node_Str"",VivaldiNode.coordinatesToString(coord));
      }
      dmap.putAll(config.getCustomParams());
      try {
        final String address=""String_Node_Str"".equals(config.getHostName()) ? config.getAddress() == null ? config.getUUID().getMappings()[0].resolvedAddr.getAddress().getHostAddress() : config.getAddress().getHostAddress() : config.getHostName();
        dmap.put(""String_Node_Str"",""String_Node_Str"" + address + ""String_Node_Str""+ config.getHttpPort());
      }
 catch (      UnknownUUIDException ex) {
      }
      Service me=new Service(ServiceType.SERVICE_TYPE_OSD,config.getUUID().toString(),0,""String_Node_Str"" + config.getUUID(),0,dmap);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,config,true);
  httpServ=HttpServer.create(new InetSocketAddress(config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(OSDRequestDispatcher.this).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      Throwable ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  startupTime=System.currentTimeMillis();
  vStage=new VivaldiStage(this);
  vStage.setLifeCycleListener(this);
  cThread=new CleanupThread(this,(HashStorageLayout)storageLayout);
  cThread.setLifeCycleListener(this);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.lifecycle,this,""String_Node_Str"",this.getConfig().getUUID().toString());
}",0.9948597444558672
113589,"public void asyncShutdown(){
  try {
    heartbeatThread.shutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcClientForReplication.shutdown();
    udpCom.shutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    cThread.cleanupStop();
    httpServ.stop(0);
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","public void asyncShutdown(){
  try {
    heartbeatThread.shutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcClientForReplication.shutdown();
    udpCom.shutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    vStage.shutdown();
    cThread.cleanupStop();
    httpServ.stop(0);
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9813765182186236
113590,"@Override public void receiveUDP(UDPMessage msg){
  assert(msg.isRequest() || msg.isResponse());
  try {
    if (msg.isRequest()) {
      if (msg.getRequestData() instanceof xtreemfs_broadcast_gmaxRequest) {
        xtreemfs_broadcast_gmaxRequest rq=(xtreemfs_broadcast_gmaxRequest)msg.getRequestData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",rq.getFile_id(),msg.getAddress());
        BufferPool.free(msg.getPayload());
        stStage.receivedGMAX_ASYNC(rq.getFile_id(),rq.getTruncateEpoch(),rq.getLastObject());
      }
 else       if (msg.getRequestData() instanceof xtreemfs_pingRequest) {
        xtreemfs_pingRequest rq=(xtreemfs_pingRequest)msg.getRequestData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",msg.getAddress());
      }
    }
 else {
      if (msg.getResponseData() instanceof xtreemfs_pingResponse) {
        xtreemfs_pingResponse resp=(xtreemfs_pingResponse)msg.getResponseData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",msg.getAddress());
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_DEBUG,this,ex);
  }
}","@Override public void receiveUDP(UDPMessage msg){
  assert(msg.isRequest() || msg.isResponse());
  try {
    if (msg.isRequest()) {
      if (msg.getRequestData() instanceof xtreemfs_broadcast_gmaxRequest) {
        xtreemfs_broadcast_gmaxRequest rq=(xtreemfs_broadcast_gmaxRequest)msg.getRequestData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",rq.getFile_id(),msg.getAddress());
        BufferPool.free(msg.getPayload());
        stStage.receivedGMAX_ASYNC(rq.getFile_id(),rq.getTruncateEpoch(),rq.getLastObject());
      }
 else       if (msg.getRequestData() instanceof xtreemfs_pingRequest) {
        xtreemfs_pingRequest rq=(xtreemfs_pingRequest)msg.getRequestData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",msg.getAddress());
        vStage.receiveVivaldiMessage(msg);
      }
    }
 else {
      if (msg.getResponseData() instanceof xtreemfs_pingResponse) {
        xtreemfs_pingResponse resp=(xtreemfs_pingResponse)msg.getResponseData();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Category.stage,this,""String_Node_Str"",msg.getAddress());
        vStage.receiveVivaldiMessage(msg);
      }
    }
  }
 catch (  Exception ex) {
    Logging.logError(Logging.LEVEL_DEBUG,this,ex);
  }
}",0.9677177177177178
113591,"public void start(){
  try {
    rpcServer.start();
    rpcClient.start();
    rpcClientForReplication.start();
    rpcServer.waitForStartup();
    rpcClient.waitForStartup();
    udpCom.start();
    preprocStage.start();
    delStage.start();
    stStage.start();
    replStage.start();
    cThread.start();
    udpCom.waitForStartup();
    preprocStage.waitForStartup();
    delStage.waitForStartup();
    stStage.waitForStartup();
    cThread.waitForStartup();
    heartbeatThread.initialize();
    heartbeatThread.start();
    heartbeatThread.waitForStartup();
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
    System.exit(1);
  }
}","public void start(){
  try {
    rpcServer.start();
    rpcClient.start();
    rpcClientForReplication.start();
    rpcServer.waitForStartup();
    rpcClient.waitForStartup();
    udpCom.start();
    preprocStage.start();
    delStage.start();
    stStage.start();
    replStage.start();
    vStage.start();
    cThread.start();
    udpCom.waitForStartup();
    preprocStage.waitForStartup();
    delStage.waitForStartup();
    stStage.waitForStartup();
    vStage.waitForStartup();
    cThread.waitForStartup();
    heartbeatThread.initialize();
    heartbeatThread.start();
    heartbeatThread.waitForStartup();
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
    System.exit(1);
  }
}",0.9720159908623645
113592,"public VivaldiStage getVivaldiStage(){
  return null;
}","public VivaldiStage getVivaldiStage(){
  return this.vStage;
}",0.8717948717948718
113593,"public void shutdown(){
  try {
    heartbeatThread.shutdown();
    heartbeatThread.waitForShutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcClientForReplication.shutdown();
    rpcServer.waitForShutdown();
    rpcClient.waitForShutdown();
    rpcClientForReplication.waitForShutdown();
    serviceAvailability.shutdown();
    udpCom.shutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    replStage.shutdown();
    cThread.shutdown();
    udpCom.waitForShutdown();
    preprocStage.waitForShutdown();
    delStage.waitForShutdown();
    stStage.waitForShutdown();
    replStage.waitForShutdown();
    cThread.waitForShutdown();
    httpServ.stop(0);
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}","public void shutdown(){
  try {
    heartbeatThread.shutdown();
    heartbeatThread.waitForShutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcClientForReplication.shutdown();
    rpcServer.waitForShutdown();
    rpcClient.waitForShutdown();
    rpcClientForReplication.waitForShutdown();
    serviceAvailability.shutdown();
    udpCom.shutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    replStage.shutdown();
    vStage.shutdown();
    cThread.shutdown();
    udpCom.waitForShutdown();
    preprocStage.waitForShutdown();
    delStage.waitForShutdown();
    stStage.waitForShutdown();
    replStage.waitForShutdown();
    vStage.waitForShutdown();
    cThread.waitForShutdown();
    httpServ.stop(0);
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_ERROR,this,ex);
  }
}",0.9743092583616092
113594,"/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + knownOSDs.size() + ""String_Node_Str"");
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + exc);
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}","/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + knownOSDs.size() + ""String_Node_Str"");
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + exc);
    knownOSDs=new ServiceSet();
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}",0.9837728194726166
113595,"@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  return file.isReadOnly() ? file.getPerms() & READ_ONLY_MASK : file.getPerms();
}","@Override public int getPosixAccessRights(StorageManager sMan,FileMetadata file,String userId,List<String> groupIds) throws MRCException {
  return !file.isDirectory() && file.isReadOnly() ? file.getPerms() & READ_ONLY_MASK : file.getPerms();
}",0.9505376344086022
113596,"/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
  }
 catch (  Exception exc) {
    Logging.logError(Logging.LEVEL_ERROR,this,exc);
    this.notifyCrashed(exc);
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}","/** 
 * Updates the list of known OSDs, from the data stored in the DS. This function is responsible of keeping a list of OSDs used by the algorithm.
 */
private void updateKnownOSDs(){
  RPCResponse<ServiceSet> r=null;
  try {
    r=dirClient.xtreemfs_service_get_by_type(null,ServiceType.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
    String ownUUID=master.getConfig().getUUID().toString();
    ServiceSet newOSDs=new ServiceSet();
    for (    Service osd : knownOSDs) {
      if (!ownUUID.equals(osd.getUuid()) && osd.getLast_updated_s() != 0) {
        newOSDs.add(osd);
      }
    }
    knownOSDs=newOSDs;
    if (Logging.isInfo())     Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + exc);
  }
 finally {
    if (r != null) {
      r.freeBuffers();
    }
    sentRequests.clear();
    sentRetries.clear();
  }
}",0.9576271186440678
113597,"public DIRRequestDispatcher(final DIRConfig config) throws IOException, BabuDBException {
  super(""String_Node_Str"");
  this.config=config;
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + VersionManagement.RELEASE_VERSION);
  registry=new HashMap();
  database=BabuDBFactory.createBabuDB(new BabuDBConfig(config.getDbDir(),config.getDbDir(),0,1024 * 1024 * 16,60 * 5,SyncMode.FSYNC,200,500));
  dbMan=database.getDatabaseManager();
  initializeDatabase();
  registerOperations();
  SSLOptions sslOptions=null;
  if (config.isUsingSSL()) {
    sslOptions=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  }
  queue=new LinkedBlockingQueue();
  quit=false;
  server=new RPCNIOSocketServer(config.getPort(),null,this,sslOptions);
  if (config.isAutodiscoverEnabled()) {
    discoveryThr=new DiscoveryMsgThread(InetAddress.getLocalHost().getCanonicalHostName(),config.getPort(),config.isUsingSSL() ? ""String_Node_Str"" : ""String_Node_Str"");
    discoveryThr.setLifeCycleListener(this);
  }
 else {
    discoveryThr=null;
  }
  httpServ=HttpServer.create(new InetSocketAddress(config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(DIRRequestDispatcher.this,config).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      BabuDBException ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  numRequests=0;
  if (config.isMonitoringEnabled()) {
    monThr=new MonitoringThread(config,this);
    monThr.setLifeCycleListener(this);
  }
 else {
    monThr=null;
  }
}","public DIRRequestDispatcher(final DIRConfig config) throws IOException, BabuDBException {
  super(""String_Node_Str"");
  this.config=config;
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + VersionManagement.RELEASE_VERSION);
  registry=new HashMap();
  database=BabuDBFactory.createBabuDB(new BabuDBConfig(config.getDbDir(),config.getDbDir(),0,1024 * 1024 * 16,60 * 5,SyncMode.FSYNC,200,500));
  dbMan=database.getDatabaseManager();
  initializeDatabase();
  registerOperations();
  SSLOptions sslOptions=null;
  if (config.isUsingSSL()) {
    sslOptions=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  }
  queue=new LinkedBlockingQueue();
  quit=false;
  server=new RPCNIOSocketServer(config.getPort(),config.getAddress(),this,sslOptions);
  if (config.isAutodiscoverEnabled()) {
    discoveryThr=new DiscoveryMsgThread(InetAddress.getLocalHost().getCanonicalHostName(),config.getPort(),config.isUsingSSL() ? ""String_Node_Str"" : ""String_Node_Str"");
    discoveryThr.setLifeCycleListener(this);
  }
 else {
    discoveryThr=null;
  }
  httpServ=HttpServer.create(new InetSocketAddress(config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(DIRRequestDispatcher.this,config).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      BabuDBException ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  numRequests=0;
  if (config.isMonitoringEnabled()) {
    monThr=new MonitoringThread(config,this);
    monThr.setLifeCycleListener(this);
  }
 else {
    monThr=null;
  }
}",0.9945562130177514
113598,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  try {
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      sMan=vMan.getStorageManagerByName(p.getComp(0));
      volume=sMan.getVolumeInfo();
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == ErrNo.ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      int time=(int)(TimeSync.getGlobalTime() / 1000);
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  XLocList xLocList=file.getXLocList();
  XLocSet xLocSet=null;
  if (xLocList == null || xLocList.getReplicaCount() == 0) {
    Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList,0);
    ReplicaSet replicas=new ReplicaSet();
    replicas.add(replica);
    xLocSet=new XLocSet(replicas,0,file.isReadOnly() ? Constants.REPL_UPDATE_PC_RONLY : Constants.REPL_UPDATE_PC_NONE,0);
    xLocList=Converter.xLocSetToXLocList(sMan,xLocSet);
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocSet.toString());
  }
 else {
    xLocSet=Converter.xLocListToXLocSet(xLocList);
    if (file.isReadOnly())     xLocSet.setRead_only_file_size(file.getSize());
  }
  boolean replicateOnClose=volume.getAutoReplFactor() > 1;
  xLocSet.setReplicas(master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList));
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,replicateOnClose,master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate)   MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,update);
 else   if (write)   MRCHelper.updateFileTimes(res.getParentsParentId(),file,false,true,true,sMan,update);
 else   if (!master.getConfig().isNoAtime())   MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,update);
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
  rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final openRequest rqArgs=(openRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  final FileAccessManager faMan=master.getFileAccessManager();
  Path p=new Path(rqArgs.getPath());
  StorageManager sMan=vMan.getStorageManagerByName(p.getComp(0));
  PathResolver res=new PathResolver(sMan,p);
  VolumeInfo volume=sMan.getVolumeInfo();
  faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  FileMetadata file=null;
  boolean create=(rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0;
  boolean excl=(rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0;
  boolean truncate=(rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0;
  boolean write=(rqArgs.getFlags() & (FileAccessManager.O_WRONLY | FileAccessManager.O_RDWR)) != 0;
  boolean createNew=false;
  try {
    res.checkIfFileDoesNotExist();
    if (create && excl)     res.checkIfFileExistsAlready();
    file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      sMan=vMan.getStorageManagerByName(p.getComp(0));
      volume=sMan.getVolumeInfo();
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
  }
 catch (  UserException exc) {
    if (exc.getErrno() == ErrNo.ENOENT && create) {
      faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      long fileId=sMan.getNextFileId();
      int time=(int)(TimeSync.getGlobalTime() / 1000);
      file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
      sMan.setLastFileId(fileId,update);
      createNew=true;
    }
 else     throw exc;
  }
  int trEpoch=file.getEpoch();
  if (truncate) {
    file.setIssuedEpoch(file.getIssuedEpoch() + 1);
    trEpoch=file.getIssuedEpoch();
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
  XLocList xLocList=file.getXLocList();
  XLocSet xLocSet=null;
  if ((xLocList == null || xLocList.getReplicaCount() == 0) && (create || write)) {
    Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList,0);
    ReplicaSet replicas=new ReplicaSet();
    replicas.add(replica);
    xLocSet=new XLocSet(replicas,0,file.isReadOnly() ? Constants.REPL_UPDATE_PC_RONLY : Constants.REPL_UPDATE_PC_NONE,0);
    xLocList=Converter.xLocSetToXLocList(sMan,xLocSet);
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),xLocSet.toString());
  }
 else {
    xLocSet=Converter.xLocListToXLocSet(xLocList);
    if (file.isReadOnly())     xLocSet.setRead_only_file_size(file.getSize());
  }
  boolean replicateOnClose=volume.getAutoReplFactor() > 1;
  xLocSet.setReplicas(master.getOSDStatusManager().getSortedReplicaList(volume.getId(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress(),xLocList));
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,replicateOnClose,master.getConfig().getCapabilitySecret());
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,Category.proc,this,""String_Node_Str"",volume.getId(),file.getId(),cap.toString());
  if (createNew || truncate)   MRCHelper.updateFileTimes(res.getParentsParentId(),file,createNew ? !master.getConfig().isNoAtime() : false,true,true,sMan,update);
 else   if (write)   MRCHelper.updateFileTimes(res.getParentsParentId(),file,false,true,true,sMan,update);
 else   if (!master.getConfig().isNoAtime())   MRCHelper.updateFileTimes(res.getParentsParentId(),file,true,false,false,sMan,update);
  if (createNew)   MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
  rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
  update.execute();
}",0.997807226618362
113599,"private void handleNestedElement(String qName,Attributes attributes,boolean openTag) throws UserException, DatabaseException {
  if (qName.equals(""String_Node_Str"")) {
    StorageManager sMan=vMan.getStorageManager(state.currentVolumeId);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
    sMan.setLastFileId(state.largestFileId,update);
    update.execute();
    state.largestFileId=0;
  }
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equals(""String_Node_Str""))   DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
}","private void handleNestedElement(String qName,Attributes attributes,boolean openTag) throws UserException, DatabaseException {
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    StorageManager sMan=vMan.getStorageManager(state.currentVolumeId);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
    sMan.setLastFileId(state.largestFileId,update);
    update.execute();
    state.largestFileId=0;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else   if (qName.equalsIgnoreCase(""String_Node_Str""))   DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
}",0.9721534653465348
113600,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  try {
    final xtreemfs_restore_databaseRequest rqArgs=(xtreemfs_restore_databaseRequest)rq.getRequestArgs();
    if (master.getConfig().getAdminPassword() != null && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    final VolumeManager vMan=master.getVolumeManager();
    if (vMan.getStorageManagers().size() != 0)     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    SAXParserFactory spf=SAXParserFactory.newInstance();
    SAXParser sp=spf.newSAXParser();
    sp.parse(new File(rqArgs.getDump_file()),new DefaultHandler(){
      private DBRestoreState state;
      private int dbVersion=1;
      public void startElement(      String uri,      String localName,      String qName,      Attributes attributes) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"")) {
            state=new DBRestoreState();
            state.currentVolumeId=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state.currentVolumeName=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state.currentVolumeACPolicy=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 else           if (qName.equals(""String_Node_Str""))           try {
            dbVersion=Integer.parseInt(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 catch (          Exception exc) {
            Logging.logMessage(Logging.LEVEL_WARN,Category.db,this,""String_Node_Str"");
          }
 else           handleNestedElement(qName,attributes,true);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.db,this,""String_Node_Str"");
          Logging.logUserError(Logging.LEVEL_ERROR,Category.db,this,exc);
          throw new SAXException(exc);
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"") || qName.equals(""String_Node_Str""))           return;
          handleNestedElement(qName,null,false);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.db,this,""String_Node_Str"");
          Logging.logUserError(Logging.LEVEL_ERROR,Category.db,this,exc);
          throw new SAXException(exc);
        }
      }
      private void handleNestedElement(      String qName,      Attributes attributes,      boolean openTag) throws UserException, DatabaseException {
        if (qName.equals(""String_Node_Str"")) {
          StorageManager sMan=vMan.getStorageManager(state.currentVolumeId);
          AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
          sMan.setLastFileId(state.largestFileId,update);
          update.execute();
          state.largestFileId=0;
        }
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
      }
    }
);
    rq.setResponse(new xtreemfs_restore_databaseResponse());
    finishRequest(rq);
  }
 catch (  SAXException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getException().getMessage() == null ? ""String_Node_Str"" : exc.getException().getMessage(),exc.getException()));
  }
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  try {
    final xtreemfs_restore_databaseRequest rqArgs=(xtreemfs_restore_databaseRequest)rq.getRequestArgs();
    if (master.getConfig().getAdminPassword() != null && !master.getConfig().getAdminPassword().equals(rq.getDetails().password))     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    final VolumeManager vMan=master.getVolumeManager();
    if (vMan.getStorageManagers().size() != 0)     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    SAXParserFactory spf=SAXParserFactory.newInstance();
    SAXParser sp=spf.newSAXParser();
    sp.parse(new File(rqArgs.getDump_file()),new DefaultHandler(){
      private DBRestoreState state;
      private int dbVersion=1;
      public void startElement(      String uri,      String localName,      String qName,      Attributes attributes) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"")) {
            state=new DBRestoreState();
            state.currentVolumeId=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state.currentVolumeName=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state.currentVolumeACPolicy=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 else           if (qName.equals(""String_Node_Str""))           try {
            dbVersion=Integer.parseInt(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 catch (          Exception exc) {
            Logging.logMessage(Logging.LEVEL_WARN,Category.db,this,""String_Node_Str"");
          }
 else           handleNestedElement(qName,attributes,true);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.db,this,""String_Node_Str"");
          Logging.logUserError(Logging.LEVEL_ERROR,Category.db,this,exc);
          throw new SAXException(exc);
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"") || qName.equals(""String_Node_Str""))           return;
          handleNestedElement(qName,null,false);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,Category.db,this,""String_Node_Str"");
          Logging.logUserError(Logging.LEVEL_ERROR,Category.db,this,exc);
          throw new SAXException(exc);
        }
      }
      private void handleNestedElement(      String qName,      Attributes attributes,      boolean openTag) throws UserException, DatabaseException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          StorageManager sMan=vMan.getStorageManager(state.currentVolumeId);
          AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
          sMan.setLastFileId(state.largestFileId,update);
          update.execute();
          state.largestFileId=0;
        }
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equalsIgnoreCase(""String_Node_Str""))         DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
      }
    }
);
    rq.setResponse(new xtreemfs_restore_databaseResponse());
    finishRequest(rq);
  }
 catch (  SAXException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getException().getMessage() == null ? ""String_Node_Str"" : exc.getException().getMessage(),exc.getException()));
  }
}",0.9902088772845952
113601,"/** 
 * @param args
 */
public static void main(String[] args){
  Logging.start(Logging.LEVEL_ERROR);
  try {
    TimeSync.initialize(null,60000,50);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(3);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  try {
    CLIParser.parseCLI(args,options,arguments);
  }
 catch (  Exception exc) {
    System.out.println(exc);
    usage();
    return;
  }
  CliOption h=options.get(""String_Node_Str"");
  if (h.switchValue) {
    usage();
    return;
  }
  CliOption mrc=options.get(""String_Node_Str"");
  if (mrc.urlValue == null) {
    System.out.println(""String_Node_Str"");
    usage();
    return;
  }
  if (arguments.size() < 2) {
    usage();
    return;
  }
  String op=arguments.get(0);
  if (!""String_Node_Str"".equals(op) && !""String_Node_Str"".equals(op)) {
    System.out.println(""String_Node_Str"" + op);
    usage();
    return;
  }
  String dumpFile=arguments.get(1);
  CliOption c=options.get(""String_Node_Str"");
  CliOption cp=options.get(""String_Node_Str"");
  CliOption t=options.get(""String_Node_Str"");
  CliOption tp=options.get(""String_Node_Str"");
  CliOption p=options.get(""String_Node_Str"");
  String host=mrc.urlValue.getHost();
  int port=mrc.urlValue.getPort();
  String protocol=mrc.urlValue.getProtocol();
  RPCNIOSocketClient rpcClient=null;
  try {
    SSLOptions sslOptions=protocol.startsWith(""String_Node_Str"") ? new SSLOptions(new FileInputStream(c.stringValue),cp.stringValue,new FileInputStream(t.stringValue),tp.stringValue) : null;
    rpcClient=new RPCNIOSocketClient(sslOptions,Integer.MAX_VALUE - 1000,Integer.MAX_VALUE);
    rpcClient.start();
    MRCClient client=new MRCClient(rpcClient,new InetSocketAddress(host,port));
    StringSet gids=new StringSet();
    gids.add(""String_Node_Str"");
    UserCredentials creds=new UserCredentials(""String_Node_Str"",gids,p == null ? ""String_Node_Str"" : p.stringValue);
    if (op.equals(""String_Node_Str"")) {
      RPCResponse<Object> r=null;
      try {
        r=client.xtreemfs_dump_database(null,creds,dumpFile);
        r.get();
      }
  finally {
        if (r != null)         r.freeBuffers();
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      RPCResponse<Object> r=null;
      try {
        r=client.xtreemfs_restore_database(null,creds,dumpFile);
        r.get();
      }
  finally {
        if (r != null)         r.freeBuffers();
      }
    }
 else     usage();
  }
 catch (  MRCException exc) {
    if (exc.getError_code() == ErrNo.EPERM)     System.out.println(""String_Node_Str"");
 else     exc.printStackTrace();
  }
catch (  Exception exc) {
    exc.printStackTrace();
  }
 finally {
    if (rpcClient != null)     rpcClient.shutdown();
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  Logging.start(Logging.LEVEL_ERROR);
  try {
    TimeSync.initialize(null,60000,50);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(3);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  try {
    CLIParser.parseCLI(args,options,arguments);
  }
 catch (  Exception exc) {
    System.out.println(exc);
    usage();
    return;
  }
  CliOption h=options.get(""String_Node_Str"");
  if (h.switchValue) {
    usage();
    return;
  }
  CliOption mrc=options.get(""String_Node_Str"");
  if (mrc.urlValue == null) {
    System.out.println(""String_Node_Str"");
    usage();
    return;
  }
  if (arguments.size() < 2) {
    usage();
    return;
  }
  String op=arguments.get(0);
  if (!""String_Node_Str"".equals(op) && !""String_Node_Str"".equals(op)) {
    System.out.println(""String_Node_Str"" + op);
    usage();
    return;
  }
  String dumpFile=arguments.get(1);
  CliOption c=options.get(""String_Node_Str"");
  CliOption cp=options.get(""String_Node_Str"");
  CliOption t=options.get(""String_Node_Str"");
  CliOption tp=options.get(""String_Node_Str"");
  CliOption p=options.get(""String_Node_Str"");
  String host=mrc.urlValue.getHost();
  int port=mrc.urlValue.getPort();
  String protocol=mrc.urlValue.getProtocol();
  RPCNIOSocketClient rpcClient=null;
  try {
    SSLOptions sslOptions=protocol.startsWith(""String_Node_Str"") ? new SSLOptions(new FileInputStream(c.stringValue),cp.stringValue,new FileInputStream(t.stringValue),tp.stringValue) : null;
    rpcClient=new RPCNIOSocketClient(sslOptions,Integer.MAX_VALUE - 1000,Integer.MAX_VALUE);
    rpcClient.start();
    MRCClient client=new MRCClient(rpcClient,new InetSocketAddress(host,port));
    StringSet gids=new StringSet();
    gids.add(""String_Node_Str"");
    UserCredentials creds=new UserCredentials(""String_Node_Str"",gids,p == null ? ""String_Node_Str"" : p.stringValue);
    if (op.equals(""String_Node_Str"")) {
      RPCResponse<Object> r=null;
      try {
        r=client.xtreemfs_dump_database(null,creds,dumpFile);
        r.get();
      }
  finally {
        if (r != null)         r.freeBuffers();
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      RPCResponse<Object> r=null;
      try {
        r=client.xtreemfs_restore_database(null,creds,dumpFile);
        r.get();
      }
  finally {
        if (r != null)         r.freeBuffers();
      }
    }
 else     usage();
  }
 catch (  MRCException exc) {
    if (exc.getError_code() == ErrNo.EPERM)     System.out.println(""String_Node_Str"");
 else     exc.printStackTrace();
  }
catch (  errnoException exc) {
    System.err.println(exc.getError_message() + ""String_Node_Str"" + exc.getError_code());
  }
catch (  Exception exc) {
    exc.printStackTrace();
  }
 finally {
    if (rpcClient != null)     rpcClient.shutdown();
  }
}",0.98195467013137
113602,"private void initializeOperations(){
  OSDOperation op=new ReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new WriteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new DeleteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new TruncateOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalGetGmaxOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalTruncateOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CheckObjectOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalGetFileSizeOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new ShutdownOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LocalReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupStartOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupIsRunningOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupStopOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupGetStatusOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupGetResultsOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new GetObjectSetOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockAcquireOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockCheckOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockReleaseOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new EventCloseFile(this);
  internalEvents.put(EventCloseFile.class,op);
  op=new EventWriteObject(this);
  internalEvents.put(EventWriteObject.class,op);
}","private void initializeOperations(){
  OSDOperation op=new ReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new WriteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new DeleteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new TruncateOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalGetGmaxOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalTruncateOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CheckObjectOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalGetFileSizeOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new ShutdownOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LocalReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupStartOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupIsRunningOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupStopOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupGetStatusOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new CleanupGetResultsOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new GetObjectSetOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockAcquireOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockCheckOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new LockReleaseOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new VivaldiPingOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new EventCloseFile(this);
  internalEvents.put(EventCloseFile.class,op);
  op=new EventWriteObject(this);
  internalEvents.put(EventWriteObject.class,op);
}",0.9775376741541086
113603,"@Override public Lock getResult(ReusableBuffer data){
  xtreemfs_lock_releaseResponse resp=new xtreemfs_lock_releaseResponse();
  resp.unmarshal(new XDRUnmarshaller(data));
  return null;
}","@Override public VivaldiCoordinates getResult(ReusableBuffer data){
  xtreemfs_pingResponse resp=new xtreemfs_pingResponse();
  resp.unmarshal(new XDRUnmarshaller(data));
  return resp.getRemote_coordinates();
}",0.655
113604,"@Override protected void processMethod(StageRequest method){
  if (method.getStageMethod() == STAGEOP_COORD_XCHG_REQUEST) {
    UDPMessage msg=(UDPMessage)method.getArgs()[0];
    final ReusableBuffer data=msg.getPayload();
    data.position(1);
    VivaldiCoordinates vc=new VivaldiCoordinates();
    vc.unmarshal(new XDRUnmarshaller(data));
    BufferPool.free(data);
    if (msg.isRequest()) {
      sendVivaldiCoordinates(msg,vc);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override protected void processMethod(StageRequest method){
  if (method.getStageMethod() == STAGEOP_COORD_XCHG_REQUEST) {
    UDPMessage msg=(UDPMessage)method.getArgs()[0];
    xtreemfs_pingRequest prq=(xtreemfs_pingRequest)msg.getRequestData();
    if (msg.isRequest()) {
      System.out.println(""String_Node_Str"" + prq.getCoordinates().getX_coordinate() + ""String_Node_Str""+ prq.getCoordinates().getY_coordinate());
      sendVivaldiCoordinates(msg,prq.getCoordinates());
    }
  }
 else   if (method.getStageMethod() == STAGEOP_TCP_VIVALID_PING) {
    VivaldiPingCallback cb=(VivaldiPingCallback)method.getCallback();
    VivaldiCoordinates remoteCoordinates=(VivaldiCoordinates)method.getArgs()[0];
    cb.coordinatesCallback(remoteCoordinates,null);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.4550898203592814
113605,"@Test public void testVivaldiPing() throws Exception {
  xtreemfs_pingRequest payload=new xtreemfs_pingRequest(new VivaldiCoordinates());
  ONCRPCRequestHeader rq=new ONCRPCRequestHeader(1,1,1,payload.getTag());
  final int fragHdr=ONCRPCRecordFragmentHeader.getFragmentHeader(rq.getXDRSize(),true);
  ONCRPCBufferWriter wr=new ONCRPCBufferWriter(ONCRPCBufferWriter.BUFF_SIZE);
  wr.writeInt32(null,fragHdr);
  rq.marshal(wr);
  payload.marshal(wr);
  wr.flip();
  DatagramSocket dsock=new DatagramSocket();
  byte[] data=wr.getBuffers().get(0).array();
  DatagramPacket dpack=new DatagramPacket(data,data.length,env.getOSDAddress());
  dsock.send(dpack);
  DatagramPacket answer=new DatagramPacket(new byte[1024],1024);
  dsock.setSoTimeout(250);
  dsock.receive(answer);
  ReusableBuffer rb=ReusableBuffer.wrap(answer.getData());
  rb.position(Integer.SIZE / 8);
  ONCRPCResponseHeader rhdr=new ONCRPCResponseHeader();
  rhdr.unmarshal(new XDRUnmarshaller(rb));
  xtreemfs_pingResponse resp=new xtreemfs_pingResponse();
  resp.unmarshal(new XDRUnmarshaller(rb));
  dsock.close();
}","@Test public void testVivaldiPing() throws Exception {
  xtreemfs_pingRequest payload=new xtreemfs_pingRequest(new VivaldiCoordinates(1.1,1.2,0.5));
  ONCRPCRequestHeader rq=new ONCRPCRequestHeader(1,1,1,payload.getTag());
  final int fragHdr=ONCRPCRecordFragmentHeader.getFragmentHeader(rq.getXDRSize(),true);
  ONCRPCBufferWriter wr=new ONCRPCBufferWriter(ONCRPCBufferWriter.BUFF_SIZE);
  wr.writeInt32(null,fragHdr);
  rq.marshal(wr);
  payload.marshal(wr);
  wr.flip();
  DatagramSocket dsock=new DatagramSocket();
  byte[] data=wr.getBuffers().get(0).array();
  DatagramPacket dpack=new DatagramPacket(data,data.length,env.getOSDAddress());
  dsock.send(dpack);
  DatagramPacket answer=new DatagramPacket(new byte[1024],1024);
  dsock.setSoTimeout(250);
  dsock.receive(answer);
  ReusableBuffer rb=ReusableBuffer.wrap(answer.getData());
  rb.position(Integer.SIZE / 8);
  ONCRPCResponseHeader rhdr=new ONCRPCResponseHeader();
  rhdr.unmarshal(new XDRUnmarshaller(rb));
  xtreemfs_pingResponse resp=new xtreemfs_pingResponse();
  resp.unmarshal(new XDRUnmarshaller(rb));
  dsock.close();
}",0.9949471750114836
113606,"@Before public void setUp() throws Exception {
  env=new TestEnvironment(new TestEnvironment.Services[]{Services.DIR_SERVICE,Services.OSD});
  env.start();
}","@Before public void setUp() throws Exception {
  env=new TestEnvironment(new TestEnvironment.Services[]{Services.DIR_SERVICE,Services.OSD,Services.OSD_CLIENT});
  env.start();
}",0.940119760479042
113607,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  String configFileName=""String_Node_Str"";
  String dbsConfigFileName=""String_Node_Str"";
  if (args.length < 1 || args.length > 2) {
    System.out.println(""String_Node_Str"" + configFileName);
    System.out.println(""String_Node_Str"" + dbsConfigFileName);
  }
 else {
    configFileName=args[0];
    if (args.length == 2)     dbsConfigFileName=args[1];
 else     System.out.println(""String_Node_Str"" + dbsConfigFileName);
  }
  DIRConfig config=null;
  try {
    config=new DIRConfig(configFileName);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
  BabuDBConfig dbsConfig=null;
  try {
    dbsConfig=new ReplicationConfig(dbsConfigFileName);
  }
 catch (  IOException e) {
    try {
      dbsConfig=new BabuDBConfig(dbsConfigFileName);
    }
 catch (    IOException ex) {
      ex.printStackTrace();
      return;
    }
  }
  Logging.start(config.getDebugLevel(),config.getDebugCategories());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",System.getProperty(""String_Node_Str""));
  try {
    final DIRRequestDispatcher rq=new DIRRequestDispatcher(config,dbsConfig);
    rq.startup();
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        try {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
          rq.shutdown();
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
);
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_CRIT,null,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_CRIT,null,ex);
    System.exit(1);
  }
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  String configFileName=""String_Node_Str"";
  String dbsConfigFileName=""String_Node_Str"";
  if (args.length < 1 || args.length > 2) {
    System.out.println(""String_Node_Str"" + configFileName);
    System.out.println(""String_Node_Str"" + dbsConfigFileName);
  }
 else {
    configFileName=args[0];
    if (args.length == 2)     dbsConfigFileName=args[1];
 else     System.out.println(""String_Node_Str"" + dbsConfigFileName);
  }
  DIRConfig config=null;
  try {
    config=new DIRConfig(configFileName);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
  BabuDBConfig dbsConfig=null;
  try {
    dbsConfig=new ReplicationConfig(dbsConfigFileName);
  }
 catch (  Throwable e) {
    try {
      dbsConfig=new BabuDBConfig(dbsConfigFileName);
    }
 catch (    IOException ex) {
      ex.printStackTrace();
      return;
    }
  }
  Logging.start(config.getDebugLevel(),config.getDebugCategories());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,Category.misc,(Object)null,""String_Node_Str"",System.getProperty(""String_Node_Str""));
  try {
    final DIRRequestDispatcher rq=new DIRRequestDispatcher(config,dbsConfig);
    rq.startup();
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        try {
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
          rq.shutdown();
          if (Logging.isInfo())           Logging.logMessage(Logging.LEVEL_INFO,Category.lifecycle,this,""String_Node_Str"");
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
);
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_CRIT,null,""String_Node_Str"");
    Logging.logError(Logging.LEVEL_CRIT,null,ex);
    System.exit(1);
  }
}",0.9493207941483804
113608,"private boolean hasTimedOut(Service osd){
  long updateTimestamp=osd.getLast_updated_s();
  long currentTime=TimeSync.getGlobalTime() / 1000;
  return currentTime - updateTimestamp > maxOfflineTime;
}","private boolean hasTimedOut(Service osd){
  long lastUpdate=Long.parseLong(osd.getData().get(""String_Node_Str""));
  return lastUpdate > maxOfflineTime;
}",0.623229461756374
113609,"public static Replica createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress,XLocList currentXLoc,int replFlags) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  org.xtreemfs.interfaces.StripingPolicy sp=new org.xtreemfs.interfaces.StripingPolicy(StripingPolicyType.valueOf(stripingPolicy.getPattern()),stripingPolicy.getStripeSize(),stripingPolicy.getWidth());
  StringSet osds=new StringSet();
  ServiceSet usableOSDs=osdMan.getUsableOSDs(volume.getId(),clientAddress,currentXLoc,stripingPolicy.getStripeSize());
  if (usableOSDs == null || usableOSDs.size() == 0)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  int width=Math.min((int)stripingPolicy.getWidth(),usableOSDs.size());
  stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  sp.setWidth(width);
  for (int i=0; i < width; i++)   osds.add(usableOSDs.get(i).getUuid());
  return new Replica(sp,replFlags,osds);
}","public static Replica createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress,XLocList currentXLoc,int replFlags) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  org.xtreemfs.interfaces.StripingPolicy sp=new org.xtreemfs.interfaces.StripingPolicy(StripingPolicyType.valueOf(stripingPolicy.getPattern()),stripingPolicy.getStripeSize(),stripingPolicy.getWidth());
  StringSet osds=new StringSet();
  ServiceSet usableOSDs=osdMan.getUsableOSDs(volume.getId(),clientAddress,currentXLoc,stripingPolicy.getStripeSize());
  if (usableOSDs == null || usableOSDs.size() == 0) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.all,(Object)null,""String_Node_Str"",path);
    throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  }
  int width=Math.min((int)stripingPolicy.getWidth(),usableOSDs.size());
  sp.setWidth(width);
  for (int i=0; i < width; i++)   osds.add(usableOSDs.get(i).getUuid());
  return new Replica(sp,replFlags,osds);
}",0.922682301209234
113610,"public int compare(Service o1,Service o2){
  try {
    final String host1=new ServiceUUID(o1.getUuid()).getAddress().getAddress().getCanonicalHostName();
    final String host2=new ServiceUUID(o2.getUuid()).getAddress().getAddress().getCanonicalHostName();
    return host1.compareTo(host2);
  }
 catch (  UnknownUUIDException exc) {
    Logging.logError(Logging.LEVEL_ERROR,this,exc);
    return 0;
  }
}","public int compare(Service o1,Service o2){
  try {
    final String host1=new ServiceUUID(o1.getUuid()).getAddress().getHostName();
    final String host2=new ServiceUUID(o2.getUuid()).getAddress().getHostName();
    return getMatch(host2,clientIP.getHostName()) - getMatch(host1,clientIP.getHostName());
  }
 catch (  UnknownUUIDException exc) {
    Logging.logError(Logging.LEVEL_ERROR,this,exc);
    return 0;
  }
}",0.8408262454434994
113611,"@Override public ServiceSet getOSDs(ServiceSet allOSDs){
  Collections.sort(allOSDs,new Comparator<Service>(){
    public int compare(    Service o1,    Service o2){
      try {
        final String host1=new ServiceUUID(o1.getUuid()).getAddress().getAddress().getCanonicalHostName();
        final String host2=new ServiceUUID(o2.getUuid()).getAddress().getAddress().getCanonicalHostName();
        return host1.compareTo(host2);
      }
 catch (      UnknownUUIDException exc) {
        Logging.logError(Logging.LEVEL_ERROR,this,exc);
        return 0;
      }
    }
  }
);
  return allOSDs;
}","@Override public ServiceSet getOSDs(ServiceSet allOSDs){
  return allOSDs;
}",0.2265275707898658
113612,"public int compare(Service o1,Service o2){
  try {
    return getMatch(new ServiceUUID(o1.getUuid()).getAddress().getHostName(),clientIP.getCanonicalHostName()) - getMatch(new ServiceUUID(o2.getUuid()).getAddress().getHostName(),clientIP.getCanonicalHostName());
  }
 catch (  UnknownUUIDException e) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.misc,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_WARN,this,OutputUtils.stackTraceToString(e));
    return 0;
  }
}","public int compare(Service o1,Service o2){
  try {
    return getMatch(new ServiceUUID(o2.getUuid()).getAddress().getHostName(),clientIP.getCanonicalHostName()) - getMatch(new ServiceUUID(o1.getUuid()).getAddress().getHostName(),clientIP.getCanonicalHostName());
  }
 catch (  UnknownUUIDException e) {
    Logging.logMessage(Logging.LEVEL_WARN,Category.misc,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_WARN,this,OutputUtils.stackTraceToString(e));
    return 0;
  }
}",0.9958847736625516
113613,"private ReusableBuffer checkAndGetBuffer(int requiredSpace){
  final ReusableBuffer currentBuf=buffers.get(currentBuffer);
  if (currentBuf.remaining() >= requiredSpace) {
    return currentBuf;
  }
 else {
    currentBuffer++;
    final ReusableBuffer buf=BufferPool.allocate(bufSize);
    buffers.add(buf);
    return buf;
  }
}","private ReusableBuffer checkAndGetBuffer(int requiredSpace){
  final ReusableBuffer currentBuf=buffers.get(currentBuffer);
  if (currentBuf.remaining() >= requiredSpace) {
    return currentBuf;
  }
 else {
    currentBuffer++;
    final int newBufSize=(bufSize >= requiredSpace) ? bufSize : requiredSpace;
    final ReusableBuffer buf=BufferPool.allocate(newBufSize);
    buffers.add(buf);
    return buf;
  }
}",0.8867924528301887
113614,"/** 
 * sends an error to all belonging clients (for all objects of the file)
 */
public void reportError(Exception error){
  Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,error.getMessage());
  for (  ReplicatingObject object : waitingRequests.values()) {
    object.sendError(error);
  }
  for (  ReplicatingObject object : objectsInProgress.values()) {
    object.sendError(error);
  }
}","/** 
 * sends an error to all belonging clients (for all objects of the file)
 */
public void reportError(Exception error){
  Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",error.getMessage());
  for (  ReplicatingObject object : waitingRequests.values()) {
    object.sendError(error);
  }
  for (  ReplicatingObject object : objectsInProgress.values()) {
    object.sendError(error);
  }
}",0.9784688995215312
113615,"public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,byte[] target,String fileName) throws BabuDBException {
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(target,1,fileIdBytes,0,fileIdBytes.length);
  byte[][] valBufs=new byte[BufferBackedFileMetadata.NUM_BUFFERS][];
  Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,BabuDBStorageManager.FILE_ID_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),BabuDBStorageManager.FILE_ID_INDEX);
    if (type == 3) {
      long fileId=ByteBuffer.wrap(fileIdBytes).getLong();
      Logging.logMessage(Logging.LEVEL_WARN,Category.db,(Object)null,""String_Node_Str"",fileId);
      continue;
    }
    valBufs[type]=curr.getValue();
  }
  if (valBufs[FileMetadata.RC_METADATA] == null)   return null;
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(null,valBufs[FileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp2=tmp.isDirectory() ? new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount()) : new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount(),tmp.getEpoch(),tmp.getIssuedEpoch(),tmp.isReadOnly());
  valBufs[FileMetadata.RC_METADATA]=tmp2.getValue();
  byte[][] keyBufs=new byte[][]{null,tmp2.getKey()};
  return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_ID_INDEX);
}","public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,byte[] target,String fileName) throws BabuDBException {
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(target,1,fileIdBytes,0,fileIdBytes.length);
  byte[][] valBufs=new byte[BufferBackedFileMetadata.NUM_BUFFERS][];
  Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,BabuDBStorageManager.FILE_ID_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),BabuDBStorageManager.FILE_ID_INDEX);
    if (type == 3) {
      long fileId=ByteBuffer.wrap(fileIdBytes).getLong();
      Logging.logMessage(Logging.LEVEL_WARN,Category.db,(Object)null,""String_Node_Str"",fileId);
      continue;
    }
    valBufs[type]=curr.getValue();
  }
  if (valBufs[FileMetadata.RC_METADATA] == null)   return null;
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(null,valBufs[FileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp2=tmp.isDirectory() ? new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount()) : new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount(),tmp.getEpoch(),tmp.getIssuedEpoch(),tmp.isReadOnly());
  tmp2.setXLocList(tmp.getXLocList());
  valBufs[FileMetadata.RC_METADATA]=tmp2.getValue();
  byte[][] keyBufs=new byte[][]{null,tmp2.getKey()};
  return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_ID_INDEX);
}",0.9875598086124402
113616,"public static Replica createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,PolicyContainer policyContainer,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  org.xtreemfs.interfaces.StripingPolicy sp=new org.xtreemfs.interfaces.StripingPolicy(StripingPolicyType.valueOf(stripingPolicy.getPattern()),stripingPolicy.getStripeSize(),stripingPolicy.getWidth());
  StringSet osds=new StringSet();
  ServiceSet osdMaps=osdMan.getUsableOSDs(volume.getId());
  if (osdMaps == null || osdMaps.size() == 0)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  int width=Math.min((int)stripingPolicy.getWidth(),osdMaps.size());
  stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  try {
    for (    String osd : policyContainer.getOSDSelectionPolicy(volume.getOsdPolicyId()).getOSDsForNewFile(osdMaps,clientAddress,width,volume.getOsdPolicyArgs()))     osds.add(osd);
  }
 catch (  MRCException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new MRCException(exc);
  }
  return new Replica(sp,0,osds);
}","public static Replica createReplica(StripingPolicy stripingPolicy,StorageManager sMan,OSDStatusManager osdMan,PolicyContainer policyContainer,VolumeInfo volume,long parentDirId,String path,InetAddress clientAddress) throws DatabaseException, UserException, MRCException {
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  org.xtreemfs.interfaces.StripingPolicy sp=new org.xtreemfs.interfaces.StripingPolicy(StripingPolicyType.valueOf(stripingPolicy.getPattern()),stripingPolicy.getStripeSize(),stripingPolicy.getWidth());
  StringSet osds=new StringSet();
  ServiceSet osdMaps=osdMan.getUsableOSDs(volume.getId());
  if (osdMaps == null || osdMaps.size() == 0)   throw new UserException(ErrNo.EIO,""String_Node_Str"" + path + ""String_Node_Str"");
  int width=Math.min((int)stripingPolicy.getWidth(),osdMaps.size());
  stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  sp.setWidth(width);
  try {
    for (    String osd : policyContainer.getOSDSelectionPolicy(volume.getOsdPolicyId()).getOSDsForNewFile(osdMaps,clientAddress,width,volume.getOsdPolicyArgs()))     osds.add(osd);
  }
 catch (  MRCException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new MRCException(exc);
  }
  return new Replica(sp,0,osds);
}",0.9927200529450696
113617,"public void run(){
  notifyStarted();
  try {
    final DatagramSocket dsock=new DatagramSocket(DIRInterface.DEFAULT_ONCRPC_PORT);
    final byte[] data=new byte[2048];
    Logging.logMessage(Logging.LEVEL_INFO,Logging.Category.lifecycle,me,""String_Node_Str"");
    do {
      DatagramPacket p=new DatagramPacket(data,data.length);
      dsock.receive(p);
      try {
        ReusableBuffer b=ReusableBuffer.wrap(p.getData(),0,p.getLength());
        b.position(Integer.SIZE / 8);
        ONCRPCRequestHeader hdr=new ONCRPCRequestHeader();
        hdr.deserialize(b);
        xtreemfs_discover_dirRequest rq=new xtreemfs_discover_dirRequest();
        rq.deserialize(b);
        xtreemfs_discover_dirResponse resp=new xtreemfs_discover_dirResponse(me);
        ONCRPCResponseHeader respHdr=new ONCRPCResponseHeader(hdr.getXID(),ONCRPCResponseHeader.REPLY_STAT_MSG_ACCEPTED,ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS);
        ONCRPCBufferWriter wr=new ONCRPCBufferWriter(2048);
        wr.putInt(ONCRPCRecordFragmentHeader.getFragmentHeader(respHdr.calculateSize() + resp.calculateSize(),true));
        respHdr.serialize(wr);
        resp.serialize(wr);
        wr.flip();
        byte[] rdata=wr.getBuffers().get(0).array();
        wr.freeBuffers();
        DatagramPacket rp=new DatagramPacket(rdata,0,rdata.length,p.getSocketAddress());
        dsock.send(rp);
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Logging.Category.net,this,""String_Node_Str"",p.getSocketAddress());
      }
 catch (      Exception ex) {
        continue;
      }
    }
 while (!quit);
    dsock.close();
  }
 catch (  Exception ex) {
    notifyCrashed(ex);
  }
  notifyStopped();
  Logging.logMessage(Logging.LEVEL_INFO,Logging.Category.lifecycle,me,""String_Node_Str"");
}","public void run(){
  notifyStarted();
  try {
    final DatagramChannel channel=DatagramChannel.open();
    channel.socket().bind(new InetSocketAddress(DIRInterface.DEFAULT_ONCRPC_PORT));
    channel.configureBlocking(true);
    Logging.logMessage(Logging.LEVEL_INFO,Logging.Category.lifecycle,me,""String_Node_Str"");
    final ReusableBuffer data=BufferPool.allocate(2048);
    do {
      data.position(0);
      data.limit(data.capacity());
      InetSocketAddress sender=(InetSocketAddress)channel.receive(data.getBuffer());
      try {
        data.position(Integer.SIZE / 8);
        ONCRPCRequestHeader hdr=new ONCRPCRequestHeader();
        hdr.deserialize(data);
        xtreemfs_discover_dirRequest rq=new xtreemfs_discover_dirRequest();
        rq.deserialize(data);
        xtreemfs_discover_dirResponse resp=new xtreemfs_discover_dirResponse(me);
        ONCRPCResponseHeader respHdr=new ONCRPCResponseHeader(hdr.getXID(),ONCRPCResponseHeader.REPLY_STAT_MSG_ACCEPTED,ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS);
        ONCRPCBufferWriter wr=new ONCRPCBufferWriter(2048);
        wr.putInt(ONCRPCRecordFragmentHeader.getFragmentHeader(respHdr.calculateSize() + resp.calculateSize(),true));
        respHdr.serialize(wr);
        resp.serialize(wr);
        wr.flip();
        channel.send(wr.getBuffers().get(0).getBuffer(),sender);
        wr.freeBuffers();
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,Logging.Category.net,this,""String_Node_Str"",sender);
      }
 catch (      Exception ex) {
        continue;
      }
    }
 while (!quit);
    channel.close();
  }
 catch (  Exception ex) {
    if (!quit)     notifyCrashed(ex);
  }
  notifyStopped();
  Logging.logMessage(Logging.LEVEL_INFO,Logging.Category.lifecycle,me,""String_Node_Str"");
}",0.8004484304932735
113618,"public static DirService discoverDir(int maxWaitSeconds){
  try {
    final DatagramSocket dsock=new DatagramSocket();
    dsock.setSoTimeout(1000);
    final byte[] data=new byte[2048];
    Enumeration<NetworkInterface> nifs=NetworkInterface.getNetworkInterfaces();
    List<InetAddress> broadcasts=new LinkedList();
    broadcasts.add(InetAddress.getLocalHost());
    while (nifs.hasMoreElements()) {
      NetworkInterface nif=nifs.nextElement();
      for (      InterfaceAddress ia : nif.getInterfaceAddresses()) {
        InetAddress bc=ia.getBroadcast();
        if (bc != null) {
          broadcasts.add(bc);
        }
      }
    }
    DatagramPacket pPack=new DatagramPacket(data,0,InetAddress.getByName(""String_Node_Str""),DIRInterface.DEFAULT_ONCRPC_PORT);
    dsock.send(pPack);
    for (int i=0; i < maxWaitSeconds; i++) {
      xtreemfs_discover_dirRequest rq=new xtreemfs_discover_dirRequest();
      ONCRPCRequestHeader rqHdr=new ONCRPCRequestHeader(1,1,DIRInterface.getVersion(),rq.TAG);
      ONCRPCBufferWriter wr=new ONCRPCBufferWriter(2048);
      wr.putInt(ONCRPCRecordFragmentHeader.getFragmentHeader(rqHdr.calculateSize() + rq.calculateSize(),true));
      rqHdr.serialize(wr);
      rq.serialize(wr);
      wr.flip();
      byte[] rdata=wr.getBuffers().get(0).array();
      wr.freeBuffers();
      for (      InetAddress bc : broadcasts) {
        DatagramPacket rp=new DatagramPacket(rdata,rdata.length,bc,DIRInterface.DEFAULT_ONCRPC_PORT);
        dsock.send(rp);
      }
      DatagramPacket p=new DatagramPacket(data,data.length);
      try {
        dsock.receive(p);
      }
 catch (      SocketTimeoutException ex) {
        continue;
      }
      ReusableBuffer b=ReusableBuffer.wrap(data,0,p.getLength());
      b.position(Integer.SIZE / 8);
      ONCRPCResponseHeader respHdr=new ONCRPCResponseHeader();
      respHdr.deserialize(b);
      xtreemfs_discover_dirResponse resp=new xtreemfs_discover_dirResponse();
      resp.deserialize(b);
      return resp.getDir_service();
    }
    dsock.close();
    return null;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
}","public static DirService discoverDir(int maxWaitSeconds){
  try {
    final DatagramSocket dsock=new DatagramSocket();
    dsock.setBroadcast(true);
    dsock.setSoTimeout(1000);
    final byte[] data=new byte[2048];
    Enumeration<NetworkInterface> nifs=NetworkInterface.getNetworkInterfaces();
    List<InetAddress> broadcasts=new LinkedList();
    broadcasts.add(InetAddress.getLocalHost());
    while (nifs.hasMoreElements()) {
      NetworkInterface nif=nifs.nextElement();
      for (      InterfaceAddress ia : nif.getInterfaceAddresses()) {
        InetAddress bc=ia.getBroadcast();
        if (bc != null) {
          broadcasts.add(bc);
        }
      }
    }
    for (int i=0; i < maxWaitSeconds; i++) {
      xtreemfs_discover_dirRequest rq=new xtreemfs_discover_dirRequest();
      ONCRPCRequestHeader rqHdr=new ONCRPCRequestHeader(1,1,DIRInterface.getVersion(),rq.TAG);
      ONCRPCBufferWriter wr=new ONCRPCBufferWriter(2048);
      wr.putInt(ONCRPCRecordFragmentHeader.getFragmentHeader(rqHdr.calculateSize() + rq.calculateSize(),true));
      rqHdr.serialize(wr);
      rq.serialize(wr);
      wr.flip();
      byte[] rdata=wr.getBuffers().get(0).array();
      wr.freeBuffers();
      for (      InetAddress bc : broadcasts) {
        DatagramPacket rp=new DatagramPacket(rdata,rdata.length,bc,DIRInterface.DEFAULT_ONCRPC_PORT);
        dsock.send(rp);
      }
      DatagramPacket p=new DatagramPacket(data,data.length);
      try {
        dsock.receive(p);
      }
 catch (      SocketTimeoutException ex) {
        continue;
      }
      ReusableBuffer b=ReusableBuffer.wrap(data,0,p.getLength());
      b.position(Integer.SIZE / 8);
      ONCRPCResponseHeader respHdr=new ONCRPCResponseHeader();
      respHdr.deserialize(b);
      xtreemfs_discover_dirResponse resp=new xtreemfs_discover_dirResponse();
      resp.deserialize(b);
      return resp.getDir_service();
    }
    dsock.close();
    return null;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
}",0.6690786300048239
113619,"public String getStatus(){
synchronized (this) {
    if (isRunning) {
      Date d=new Date(startTime);
      return String.format(STATUS_FORMAT,filesChecked,zombies.get(),DateFormat.getDateInstance().format(d));
    }
 else {
      Date d=new Date(startTime);
      return String.format(STOPPED_FORMAT,DateFormat.getDateInstance().format(d));
    }
  }
}","public String getStatus(){
synchronized (this) {
    String d=DateFormat.getDateInstance().format(new Date(startTime));
    assert(d != null);
    if (isRunning) {
      return String.format(STATUS_FORMAT,filesChecked,zombies.get(),d);
    }
 else {
      return String.format(STOPPED_FORMAT,d);
    }
  }
}",0.6374622356495468
113620,"public CleanupThread(OSDRequestDispatcher master,HashStorageLayout layout){
  super(""String_Node_Str"");
  this.zombies=new AtomicLong(0L);
  this.master=master;
  this.isRunning=false;
  this.quit=false;
  this.layout=layout;
  this.results=new StringSet();
  localUUID=master.getConfig().getUUID();
}","public CleanupThread(OSDRequestDispatcher master,HashStorageLayout layout){
  super(""String_Node_Str"");
  this.zombies=new AtomicLong(0L);
  this.master=master;
  this.isRunning=false;
  this.quit=false;
  this.layout=layout;
  this.results=new StringSet();
  this.localUUID=master.getConfig().getUUID();
  this.startTime=0L;
  this.filesChecked=0L;
}",0.9233128834355828
113621,"/** 
 * Performs a cleanUp-Operation.<br> Checks the status for errors.
 * @param restore
 * @param deleteVolumes
 * @param killZombies
 * @return the result of the cleanup operation.
 * @throws InterruptedException
 * @throws ONCRPCException
 * @throws IOException
 */
private StringSet makeCleanup(boolean restore,boolean deleteVolumes,boolean killZombies) throws InterruptedException, ONCRPCException, IOException {
  RPCResponse<?> r=null;
  r=env.getOSDClient().internal_cleanup_start(env.getOSDAddress(),killZombies,deleteVolumes,restore,""String_Node_Str"");
  r.get();
  r.freeBuffers();
  boolean isRunning=true;
  do {
    r=env.getOSDClient().internal_cleanup_status(env.getOSDAddress(),""String_Node_Str"");
    String stat=(String)r.get();
    r.freeBuffers();
    r=env.getOSDClient().internal_cleanup_is_running(env.getOSDAddress(),""String_Node_Str"");
    isRunning=(Boolean)r.get();
    r.freeBuffers();
    if (isRunning) {
      assertNotNull(stat);
      assertTrue(stat.matches(CleanupThread.getRegex(CleanupThread.STATUS_FORMAT)));
      Thread.sleep(250);
    }
 else {
      assertNotNull(stat);
      assertTrue(stat.matches(CleanupThread.getRegex(CleanupThread.STOPPED_FORMAT)));
    }
  }
 while (isRunning);
  r=env.getOSDClient().internal_cleanup_get_result(env.getOSDAddress(),""String_Node_Str"");
  StringSet results=(StringSet)r.get();
  r.freeBuffers();
  return results;
}","/** 
 * Performs a cleanUp-Operation.<br> Checks the status for errors.
 * @param restore
 * @param deleteVolumes
 * @param killZombies
 * @return the result of the cleanup operation.
 * @throws InterruptedException
 * @throws ONCRPCException
 * @throws IOException
 */
private StringSet makeCleanup(boolean restore,boolean deleteVolumes,boolean killZombies) throws InterruptedException, ONCRPCException, IOException {
  String statF=CleanupThread.getRegex(CleanupThread.STATUS_FORMAT);
  String stopF=CleanupThread.getRegex(CleanupThread.STOPPED_FORMAT);
  assertNotNull(statF);
  assertNotNull(stopF);
  RPCResponse<?> r=null;
  r=env.getOSDClient().internal_cleanup_start(env.getOSDAddress(),killZombies,deleteVolumes,restore,""String_Node_Str"");
  r.get();
  r.freeBuffers();
  boolean isRunning=true;
  do {
    r=env.getOSDClient().internal_cleanup_status(env.getOSDAddress(),""String_Node_Str"");
    String stat=(String)r.get();
    r.freeBuffers();
    assertNotNull(stat);
    try {
      if (stat.matches(statF))       assertTrue(true);
    }
 catch (    NullPointerException ne) {
      assertTrue(stat.matches(stopF));
    }
    r=env.getOSDClient().internal_cleanup_is_running(env.getOSDAddress(),""String_Node_Str"");
    isRunning=(Boolean)r.get();
    r.freeBuffers();
  }
 while (isRunning);
  r=env.getOSDClient().internal_cleanup_get_result(env.getOSDAddress(),""String_Node_Str"");
  StringSet results=(StringSet)r.get();
  r.freeBuffers();
  return results;
}",0.7717466945024356
113622,"/** 
 * @param objectNo - relative object number.
 * @param firstByteInObject - the first byte to be read.
 * @param bytesInObject - the maximal number of bytes to be read.
 * @return a ReusableBuffer containing the data which was read.
 */
@Override public ReusableBuffer readObject(long objectNo,int offset,int length) throws IOException {
  RPCResponse<ObjectData> response=null;
  Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId,xLoc.getOSDsForObject(objectNo).toString());
  List<ServiceUUID> osds=osdSelectionPolicy.getOSDorder(xLoc.getOSDsForObject(objectNo));
  int size=0;
  ObjectData data=null;
  ReusableBuffer buffer=null;
  for (  ServiceUUID osd : osds) {
    checkCap();
    try {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId,osd);
      response=osdClient.read(osd.getAddress(),fileId,fileCredentials,objectNo,0,offset,length);
      data=response.get();
      if (data.getInvalid_checksum_on_osd()) {
        throw new IOException(""String_Node_Str"" + objectNo + ""String_Node_Str"");
      }
      if (data.getZero_padding() == 0) {
        buffer=data.getData();
      }
 else {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId);
        final int dataSize=data.getData().capacity();
        if (data.getData().enlarge(dataSize + data.getZero_padding())) {
          data.getData().position(dataSize);
          while (data.getData().hasRemaining())           data.getData().put((byte)0);
          buffer=data.getData();
          buffer.position(0);
        }
 else {
          buffer=BufferPool.allocate(dataSize + data.getZero_padding());
          buffer.put(data.getData());
          while (buffer.hasRemaining())           buffer.put((byte)0);
          buffer.position(0);
          BufferPool.free(data.getData());
        }
      }
      break;
    }
 catch (    ONCRPCException ex) {
      System.out.println(ex.toString());
      if (buffer != null)       BufferPool.free(buffer);
      if (((OSDException)ex).getError_code() == ErrorCodes.IO_ERROR || osds.lastIndexOf(osd) == osds.size() - 1) {
        throw new IOException(""String_Node_Str"",ex);
      }
 else       continue;
    }
catch (    IOException ex) {
      System.out.println(ex.toString());
      if (buffer != null)       BufferPool.free(buffer);
      if (osds.lastIndexOf(osd) == osds.size() - 1) {
        throw new IOException(""String_Node_Str"",ex);
      }
 else       continue;
    }
catch (    InterruptedException ex) {
    }
 finally {
      if (response != null) {
        response.freeBuffers();
      }
    }
  }
  return buffer;
}","/** 
 * @param objectNo - relative object number.
 * @param firstByteInObject - the first byte to be read.
 * @param bytesInObject - the maximal number of bytes to be read.
 * @return a ReusableBuffer containing the data which was read.
 */
@Override public ReusableBuffer readObject(long objectNo,int offset,int length) throws IOException {
  RPCResponse<ObjectData> response=null;
  Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId,xLoc.getOSDsForObject(objectNo).toString());
  List<ServiceUUID> osds=osdSelectionPolicy.getOSDorder(xLoc.getOSDsForObject(objectNo));
  int size=0;
  ObjectData data=null;
  ReusableBuffer buffer=null;
  for (  ServiceUUID osd : osds) {
    checkCap();
    try {
      Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId,osd);
      response=osdClient.read(osd.getAddress(),fileId,fileCredentials,objectNo,0,offset,length);
      data=response.get();
      if (data.getInvalid_checksum_on_osd()) {
        throw new IOException(""String_Node_Str"" + objectNo + ""String_Node_Str"");
      }
      if (data.getZero_padding() == 0) {
        buffer=data.getData();
      }
 else {
        Logging.logMessage(Logging.LEVEL_DEBUG,Category.tool,this,""String_Node_Str"",objectNo,fileId);
        final int dataSize=data.getData().capacity();
        if (data.getData().enlarge(dataSize + data.getZero_padding())) {
          data.getData().position(dataSize);
          while (data.getData().hasRemaining())           data.getData().put((byte)0);
          buffer=data.getData();
          buffer.position(0);
        }
 else {
          buffer=BufferPool.allocate(dataSize + data.getZero_padding());
          buffer.put(data.getData());
          while (buffer.hasRemaining())           buffer.put((byte)0);
          buffer.position(0);
          BufferPool.free(data.getData());
        }
      }
      break;
    }
 catch (    ONCRPCException ex) {
      if (buffer != null)       BufferPool.free(buffer);
      if (osds.lastIndexOf(osd) == osds.size() - 1 || ((OSDException)ex).getError_code() == ErrorCodes.IO_ERROR) {
        throw new IOException(""String_Node_Str"",ex);
      }
 else       continue;
    }
catch (    IOException ex) {
      if (buffer != null)       BufferPool.free(buffer);
      if (osds.lastIndexOf(osd) == osds.size() - 1) {
        throw new IOException(""String_Node_Str"",ex);
      }
 else       continue;
    }
catch (    InterruptedException ex) {
    }
 finally {
      if (response != null) {
        response.freeBuffers();
      }
    }
  }
  return buffer;
}",0.9678638941398866
113623,"@Override public void startRequest(final OSDRequest rq){
  final xtreemfs_internal_get_file_sizeRequest args=(xtreemfs_internal_get_file_sizeRequest)rq.getRequestArgs();
  System.out.println(""String_Node_Str"" + args);
  final StripingPolicyImpl sp=rq.getLocationList().getLocalReplica().getStripingPolicy();
  master.getStorageStage().getFilesize(args.getFile_id(),sp,rq,new GetFileSizeCallback(){
    @Override public void getFileSizeComplete(    long fileSize,    Exception error){
      step2(rq,args,fileSize,error);
    }
  }
);
}","@Override public void startRequest(final OSDRequest rq){
  final xtreemfs_internal_get_file_sizeRequest args=(xtreemfs_internal_get_file_sizeRequest)rq.getRequestArgs();
  final StripingPolicyImpl sp=rq.getLocationList().getLocalReplica().getStripingPolicy();
  master.getStorageStage().getFilesize(args.getFile_id(),sp,rq,new GetFileSizeCallback(){
    @Override public void getFileSizeComplete(    long fileSize,    Exception error){
      step2(rq,args,fileSize,error);
    }
  }
);
}",0.9530332681017613
113624,"public void update(Capability cap,XLocations xLoc,CowPolicy cow){
  this.cap=cap;
  this.cow=cow;
  if (xLoc.getXLocSet().getVersion() > this.xLoc.getXLocSet().getVersion()) {
    this.xLoc=xLoc;
    this.strategy.updateXLoc(xLoc);
  }
}","public void update(Capability cap,XLocations xLoc,CowPolicy cow){
  this.cow=cow;
  if (cap.getExpires() > this.cap.getExpires() || cap.getEpochNo() > this.cap.getEpochNo()) {
    this.cap=cap;
  }
  if (xLoc.getXLocSet().getVersion() > this.xLoc.getXLocSet().getVersion()) {
    this.xLoc=xLoc;
    this.strategy.updateXLoc(xLoc);
  }
}",0.7700348432055749
113625,"public ObjectInfo(){
  this.waitingRequests=new ArrayList<StageRequest>();
}","public ObjectInfo(){
  this.waitingRequests=new ArrayList<StageRequest>(2);
}",0.9934640522875816
113626,"/** 
 * Prepares the request by using the associated TransferStrategy.
 */
private void prepareRequest(FileInfo fileInfo,long objectNo){
  TransferStrategy strategy=fileInfo.strategy;
  strategy.selectNextOSD(objectNo);
  NextRequest next=strategy.getNext();
  if (next != null) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileInfo.fileID,next.objectNo,next.osd);
    fileInfo.get(objectNo).lastOSD=next.osd;
    sendFetchObjectRequest(next.objectNo,next.osd,fileInfo.fileID,fileInfo.cap,fileInfo.xLoc);
  }
 else {
    sendError(fileInfo,objectNo,new OSDException(ErrorCodes.IO_ERROR,""String_Node_Str"",""String_Node_Str""));
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileInfo.fileID,next.objectNo);
    System.out.println(""String_Node_Str"" + objectNo + ""String_Node_Str""+ fileInfo.fileID+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + fileInfo.lastObject);
    System.out.println(""String_Node_Str"" + fileInfo.cap.toString());
    System.out.println(""String_Node_Str"" + fileInfo.xLoc.getReplicas().toString());
    System.out.println(""String_Node_Str"" + fileInfo.get(objectNo).lastOSD);
    System.out.println(""String_Node_Str"" + fileInfo.get(objectNo).waitingRequests.size());
    System.out.println(""String_Node_Str"" + fileInfo.strategy.getObjectsCount());
    System.out.println(""String_Node_Str"" + fileInfo.strategy.isHole(objectNo));
    objectCompleted(fileInfo,objectNo);
  }
}","/** 
 * Prepares the request by using the associated TransferStrategy.
 */
private void prepareRequest(FileInfo fileInfo,long objectNo){
  TransferStrategy strategy=fileInfo.strategy;
  strategy.selectNextOSD(objectNo);
  NextRequest next=strategy.getNext();
  if (next != null) {
    Logging.logMessage(Logging.LEVEL_DEBUG,Category.replication,this,""String_Node_Str"",fileInfo.fileID,next.objectNo,next.osd);
    fileInfo.get(objectNo).lastOSD=next.osd;
    sendFetchObjectRequest(next.objectNo,next.osd,fileInfo.fileID,fileInfo.cap,fileInfo.xLoc);
  }
 else {
    sendError(fileInfo,objectNo,new OSDException(ErrorCodes.IO_ERROR,""String_Node_Str"",""String_Node_Str""));
    Logging.logMessage(Logging.LEVEL_ERROR,Category.replication,this,""String_Node_Str"",fileInfo.fileID,objectNo);
    System.out.println(""String_Node_Str"" + objectNo + ""String_Node_Str""+ fileInfo.fileID+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + fileInfo.lastObject);
    System.out.println(""String_Node_Str"" + fileInfo.cap.toString());
    System.out.println(""String_Node_Str"" + fileInfo.xLoc.getReplicas().toString());
    System.out.println(""String_Node_Str"" + fileInfo.get(objectNo).lastOSD);
    System.out.println(""String_Node_Str"" + fileInfo.get(objectNo).waitingRequests.size());
    System.out.println(""String_Node_Str"" + fileInfo.strategy.getObjectsCount());
    System.out.println(""String_Node_Str"" + fileInfo.strategy.isHole(objectNo));
    objectCompleted(fileInfo,objectNo);
  }
}",0.9545913218970736
113627,"public RPCResponse<VolumeSet> lsvol(InetSocketAddress server,UserCredentials credentials){
  xtreemfs_lsvolRequest rq=new xtreemfs_lsvolRequest();
  RPCResponse<VolumeSet> r=sendRequest(server,rq.getTag(),rq,new RPCResponseDecoder<VolumeSet>(){
    @Override public VolumeSet getResult(    ReusableBuffer data){
      final xtreemfs_lsvolResponse resp=new xtreemfs_lsvolResponse();
      resp.deserialize(data);
      return null;
    }
  }
,credentials);
  return r;
}","public RPCResponse<VolumeSet> lsvol(InetSocketAddress server,UserCredentials credentials){
  xtreemfs_lsvolRequest rq=new xtreemfs_lsvolRequest();
  RPCResponse<VolumeSet> r=sendRequest(server,rq.getTag(),rq,new RPCResponseDecoder<VolumeSet>(){
    @Override public VolumeSet getResult(    ReusableBuffer data){
      final xtreemfs_lsvolResponse resp=new xtreemfs_lsvolResponse();
      resp.deserialize(data);
      return resp.getVolumes();
    }
  }
,credentials);
  return r;
}",0.9779179810725552
113628,"public static long readHexLong(final String str,int position){
  long value=OutputUtils.readHexInt(str,position);
  int tmp=OutputUtils.readHexInt(str,position + 8);
  value+=((long)tmp) << 32;
  return value;
}","public static long readHexLong(final String str,int position){
  int low=OutputUtils.readHexInt(str,position);
  int high=OutputUtils.readHexInt(str,position + 8);
  long value=((long)high) << 32 | (((long)low) & 4294967295L);
  return value;
}",0.8527472527472527
113629,"@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedXLocList xLocList=rcMetadata.getXLocList();
  BufferBackedRCMetadata tmp=isDirectory() ? new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount()) : new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly());
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
  rcMetadata.setXLocList(xLocList);
}","@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedXLocList xLocList=rcMetadata.getXLocList();
  BufferBackedRCMetadata tmp=isDirectory() ? new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount()) : new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly());
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
  if (!rcMetadata.isDirectory())   rcMetadata.setXLocList(xLocList);
}",0.9771941948859708
113630,"public void setXLocList(BufferBackedXLocList xLocList){
  int index=valBuf.getShort(RC_XLOC_OFFSET);
  byte[] bytes=this.valBuf.array();
  byte[] xLocBytes=xLocList == null ? new byte[0] : xLocList.getBuffer();
  byte[] tmp=new byte[index + xLocBytes.length];
  System.arraycopy(bytes,0,tmp,0,index);
  System.arraycopy(xLocBytes,0,tmp,index,xLocBytes.length);
  this.valBuf=ByteBuffer.wrap(tmp);
  cachedXLocList=xLocList;
}","public void setXLocList(BufferBackedXLocList xLocList){
}",0.2365145228215767
113631,"public static BufferBackedFileMetadata getMetadata(BabuDB database,String dbName,long parentId,String fileName) throws BabuDBException {
  byte[] rcKey=BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA);
  byte[] rcValue=database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,rcKey);
  if (rcValue != null) {
    if (rcValue[0] == 2)     return resolveLink(database,dbName,rcValue);
    byte[][] keyBufs=new byte[][]{BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),rcKey,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.XLOC_METADATA)};
    byte[][] valBufs=new byte[][]{database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,keyBufs[0]),rcValue,database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,keyBufs[2])};
    return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_INDEX);
  }
 else   return null;
}","public static BufferBackedFileMetadata getMetadata(BabuDB database,String dbName,long parentId,String fileName) throws BabuDBException {
  byte[] rcKey=BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.RC_METADATA);
  byte[] rcValue=database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,rcKey);
  if (rcValue != null) {
    if (rcValue[0] == 2)     return resolveLink(database,dbName,rcValue,fileName);
    byte[][] keyBufs=new byte[][]{BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.FC_METADATA),rcKey,BabuDBStorageHelper.createFileKey(parentId,fileName,FileMetadata.XLOC_METADATA)};
    byte[][] valBufs=new byte[][]{database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,keyBufs[0]),rcValue,database.directLookup(dbName,BabuDBStorageManager.FILE_INDEX,keyBufs[2])};
    return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_INDEX);
  }
 else   return null;
}",0.9951430113329736
113632,"public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,byte[] target) throws BabuDBException {
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(target,1,fileIdBytes,0,fileIdBytes.length);
  String fileName=new String(target,9,target.length - 9);
  byte[][] valBufs=new byte[BufferBackedFileMetadata.NUM_BUFFERS][];
  Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,BabuDBStorageManager.FILE_ID_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),BabuDBStorageManager.FILE_ID_INDEX);
    if (type == 3) {
      long fileId=ByteBuffer.wrap(fileIdBytes).getLong();
      Logging.logMessage(Logging.LEVEL_WARN,Category.db,(Object)null,""String_Node_Str"",fileId);
      continue;
    }
    valBufs[type]=curr.getValue();
  }
  if (valBufs[FileMetadata.RC_METADATA] == null)   return null;
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(null,valBufs[FileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp2=tmp.isDirectory() ? new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount()) : new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount(),tmp.getEpoch(),tmp.getIssuedEpoch(),tmp.isReadOnly());
  valBufs[FileMetadata.RC_METADATA]=tmp2.getValue();
  byte[][] keyBufs=new byte[][]{null,tmp2.getKey(),null};
  return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_ID_INDEX);
}","public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,byte[] target,String fileName) throws BabuDBException {
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(target,1,fileIdBytes,0,fileIdBytes.length);
  byte[][] valBufs=new byte[BufferBackedFileMetadata.NUM_BUFFERS][];
  Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,BabuDBStorageManager.FILE_ID_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),BabuDBStorageManager.FILE_ID_INDEX);
    if (type == 3) {
      long fileId=ByteBuffer.wrap(fileIdBytes).getLong();
      Logging.logMessage(Logging.LEVEL_WARN,Category.db,(Object)null,""String_Node_Str"",fileId);
      continue;
    }
    valBufs[type]=curr.getValue();
  }
  if (valBufs[FileMetadata.RC_METADATA] == null)   return null;
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(null,valBufs[FileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp2=tmp.isDirectory() ? new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount()) : new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getW32Attrs(),tmp.getLinkCount(),tmp.getEpoch(),tmp.getIssuedEpoch(),tmp.isReadOnly());
  valBufs[FileMetadata.RC_METADATA]=tmp2.getValue();
  byte[][] keyBufs=new byte[][]{null,tmp2.getKey(),null};
  return new BufferBackedFileMetadata(keyBufs,valBufs,BabuDBStorageManager.FILE_ID_INDEX);
}",0.9764930114358322
113633,"/** 
 * Recursively deletes all contents of the given directory.
 * @param file the directory to delete
 */
public static void delTree(File file){
  if (!file.exists())   return;
  for (  File f : file.listFiles()) {
    if (f.isDirectory())     delTree(f);
 else     f.delete();
  }
  file.delete();
}","/** 
 * Recursively deletes all contents of the given directory.
 * @param file the directory to delete
 */
public static void delTree(File file){
  if (!file.exists())   return;
  File[] fileList;
  if ((fileList=file.listFiles()) != null) {
    for (    File f : fileList) {
      if (f.isDirectory())       delTree(f);
 else       f.delete();
    }
  }
  file.delete();
}",0.757396449704142
113634,"public void startup() throws Exception {
  TimeSync.initializeLocal(config.getRemoteTimeSync(),config.getLocalClockRenew());
  clientStage.start();
  clientStage.waitForStartup();
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  TimeSync.getInstance().enableRemoteSynchronization(dirClient);
  osdMonitor.start();
  osdMonitor.waitForStartup();
  procStage.start();
  procStage.waitForStartup();
  volumeManager.init();
  volumeManager.addVolumeChangeListener(osdMonitor);
  heartbeatThread.start();
  serverStage.start();
  serverStage.waitForStartup();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
}","public void startup() throws Exception {
  TimeSync.initializeLocal(config.getRemoteTimeSync(),config.getLocalClockRenew());
  clientStage.start();
  clientStage.waitForStartup();
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  osdMonitor.start();
  osdMonitor.waitForStartup();
  procStage.start();
  procStage.waitForStartup();
  volumeManager.init();
  volumeManager.addVolumeChangeListener(osdMonitor);
  heartbeatThread.start();
  serverStage.start();
  serverStage.waitForStartup();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
}",0.9536707056307911
113635,"public RPCResponse xtreemfs_restore_file(InetSocketAddress server,String filePath,String fileId,long fileSizeInBytes,String osdUUID,int stripeSizeInKB){
  xtreemfs_restore_fileRequest rq=new xtreemfs_restore_fileRequest(filePath,fileId,fileSizeInBytes,osdUUID,stripeSizeInKB);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final xtreemfs_restore_fileResponse resp=new xtreemfs_restore_fileResponse();
      resp.deserialize(data);
      return null;
    }
  }
);
  return r;
}","public RPCResponse xtreemfs_restore_file(InetSocketAddress server,String filePath,String fileId,long fileSizeInBytes,String osdUUID,int stripeSizeInKB,UserCredentials credentials){
  xtreemfs_restore_fileRequest rq=new xtreemfs_restore_fileRequest(filePath,fileId,fileSizeInBytes,osdUUID,stripeSizeInKB);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final xtreemfs_restore_fileResponse resp=new xtreemfs_restore_fileResponse();
      resp.deserialize(data);
      return null;
    }
  }
,credentials);
  return r;
}",0.9671052631578948
113636,"@Override public void startRequest(MRCRequest rq) throws Throwable {
  if (!rq.getDetails().superUser)   throw new UserException(ErrNo.EACCES,""String_Node_Str"");
  final xtreemfs_restore_fileRequest rqArgs=(xtreemfs_restore_fileRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFile_id());
  final Path p=new Path(vMan.getVolumeById(idRes.getVolumeId()).getName() + ""String_Node_Str"" + rqArgs.getFile_path());
  final StorageManager sMan=vMan.getStorageManager(idRes.getVolumeId());
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  long nextFileId=sMan.getNextFileId();
  FileMetadata[] path=sMan.resolvePath(p);
  long parentId=1;
  for (int i=0; i < p.getCompCount(); i++)   try {
    if (path[i] != null)     parentId=path[i].getId();
 else {
      sMan.createDir(nextFileId,parentId,p.getComp(i),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),509,0,update);
      parentId=nextFileId;
      nextFileId++;
      sMan.setLastFileId(nextFileId,update);
    }
  }
 catch (  DatabaseException exc) {
    if (exc.getType() != ExceptionType.FILE_EXISTS)     throw exc;
  }
  FileMetadata file=sMan.createFile(idRes.getLocalFileId(),parentId,rqArgs.getFile_id(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),511,0,rqArgs.getFile_size(),false,0,0,update);
  int size=(rqArgs.getStripe_size() < 1024 ? 1 : (rqArgs.getStripe_size() % 1024 != 0) ? rqArgs.getStripe_size() / 1024 + 1 : rqArgs.getStripe_size() / 1024);
  StripingPolicy sp=sMan.createStripingPolicy(""String_Node_Str"",size,1);
  XLoc replica=sMan.createXLoc(sp,new String[]{rqArgs.getOsd_uuid()});
  XLocList xLocList=sMan.createXLocList(new XLoc[]{replica},Constants.REPL_UPDATE_PC_NONE,0);
  file.setXLocList(xLocList);
  sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
  rq.setResponse(new xtreemfs_restore_fileResponse());
  update.execute();
}","@Override public void startRequest(MRCRequest rq) throws Throwable {
  final xtreemfs_restore_fileRequest rqArgs=(xtreemfs_restore_fileRequest)rq.getRequestArgs();
  final VolumeManager vMan=master.getVolumeManager();
  GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFile_id());
  final Path p=new Path(vMan.getVolumeById(idRes.getVolumeId()).getName() + ""String_Node_Str"" + rqArgs.getFile_path());
  final StorageManager sMan=vMan.getStorageManager(idRes.getVolumeId());
  AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  long nextFileId=sMan.getNextFileId();
  FileMetadata[] path=sMan.resolvePath(p);
  long parentId=1;
  for (int i=0; i < p.getCompCount(); i++)   try {
    if (path[i] != null)     parentId=path[i].getId();
 else {
      sMan.createDir(nextFileId,parentId,p.getComp(i),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),509,0,update);
      parentId=nextFileId;
      nextFileId++;
      sMan.setLastFileId(nextFileId,update);
    }
  }
 catch (  DatabaseException exc) {
    if (exc.getType() != ExceptionType.FILE_EXISTS)     throw exc;
  }
  FileMetadata file=sMan.createFile(idRes.getLocalFileId(),parentId,rqArgs.getFile_id(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),511,0,rqArgs.getFile_size(),false,0,0,update);
  int size=(rqArgs.getStripe_size() < 1024 ? 1 : (rqArgs.getStripe_size() % 1024 != 0) ? rqArgs.getStripe_size() / 1024 + 1 : rqArgs.getStripe_size() / 1024);
  StripingPolicy sp=sMan.createStripingPolicy(""String_Node_Str"",size,1);
  XLoc replica=sMan.createXLoc(sp,new String[]{rqArgs.getOsd_uuid()});
  XLocList xLocList=sMan.createXLocList(new XLoc[]{replica},Constants.REPL_UPDATE_PC_NONE,0);
  file.setXLocList(xLocList);
  sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
  rq.setResponse(new xtreemfs_restore_fileResponse());
  update.execute();
}",0.9764854614412136
113637,"public RPCResponse<Boolean> internal_cleanup_is_running(InetSocketAddress server,String password){
  xtreemfs_cleanup_is_runningRequest rq=new xtreemfs_cleanup_is_runningRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_is_runningResponse resp=new xtreemfs_cleanup_is_runningResponse();
      resp.deserialize(data);
      return resp.getIs_running();
    }
  }
,creds);
  return r;
}","public RPCResponse<Boolean> internal_cleanup_is_running(InetSocketAddress server,String password){
  xtreemfs_cleanup_is_runningRequest rq=new xtreemfs_cleanup_is_runningRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(new String[]{""String_Node_Str""}),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_is_runningResponse resp=new xtreemfs_cleanup_is_runningResponse();
      resp.deserialize(data);
      return resp.getIs_running();
    }
  }
,creds);
  return r;
}",0.9751801441152922
113638,"public RPCResponse internal_cleanup_stop(InetSocketAddress server,String password){
  xtreemfs_cleanup_stopRequest rq=new xtreemfs_cleanup_stopRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_stopResponse resp=new xtreemfs_cleanup_stopResponse();
      resp.deserialize(data);
      return null;
    }
  }
,creds);
  return r;
}","public RPCResponse internal_cleanup_stop(InetSocketAddress server,String password){
  xtreemfs_cleanup_stopRequest rq=new xtreemfs_cleanup_stopRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(new String[]{""String_Node_Str""}),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_stopResponse resp=new xtreemfs_cleanup_stopResponse();
      resp.deserialize(data);
      return null;
    }
  }
,creds);
  return r;
}",0.9727831431079894
113639,"public RPCResponse internal_cleanup_start(InetSocketAddress server,boolean removeZombies,boolean removeDeadVolumes,boolean lostAndFound,String password){
  xtreemfs_cleanup_startRequest rq=new xtreemfs_cleanup_startRequest(removeZombies,removeDeadVolumes,lostAndFound);
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_startResponse resp=new xtreemfs_cleanup_startResponse();
      resp.deserialize(data);
      return null;
    }
  }
,creds);
  return r;
}","public RPCResponse internal_cleanup_start(InetSocketAddress server,boolean removeZombies,boolean removeDeadVolumes,boolean lostAndFound,String password){
  xtreemfs_cleanup_startRequest rq=new xtreemfs_cleanup_startRequest(removeZombies,removeDeadVolumes,lostAndFound);
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(new String[]{""String_Node_Str""}),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_startResponse resp=new xtreemfs_cleanup_startResponse();
      resp.deserialize(data);
      return null;
    }
  }
,creds);
  return r;
}",0.9774545454545456
113640,"public RPCResponse<String> internal_cleanup_status(InetSocketAddress server,String password){
  xtreemfs_cleanup_statusRequest rq=new xtreemfs_cleanup_statusRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_statusResponse resp=new xtreemfs_cleanup_statusResponse();
      resp.deserialize(data);
      return resp.getStatus();
    }
  }
,creds);
  return r;
}","public RPCResponse<String> internal_cleanup_status(InetSocketAddress server,String password){
  xtreemfs_cleanup_statusRequest rq=new xtreemfs_cleanup_statusRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(new String[]{""String_Node_Str""}),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_statusResponse resp=new xtreemfs_cleanup_statusResponse();
      resp.deserialize(data);
      return resp.getStatus();
    }
  }
,creds);
  return r;
}",0.9741451209341118
113641,"public RPCResponse<StringSet> internal_cleanup_get_result(InetSocketAddress server,String password){
  xtreemfs_cleanup_get_resultsRequest rq=new xtreemfs_cleanup_get_resultsRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_get_resultsResponse resp=new xtreemfs_cleanup_get_resultsResponse();
      resp.deserialize(data);
      return resp.getResults();
    }
  }
,creds);
  return r;
}","public RPCResponse<StringSet> internal_cleanup_get_result(InetSocketAddress server,String password){
  xtreemfs_cleanup_get_resultsRequest rq=new xtreemfs_cleanup_get_resultsRequest();
  UserCredentials creds=new UserCredentials(""String_Node_Str"",new StringSet(new String[]{""String_Node_Str""}),password);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      xtreemfs_cleanup_get_resultsResponse resp=new xtreemfs_cleanup_get_resultsResponse();
      resp.deserialize(data);
      return resp.getResults();
    }
  }
,creds);
  return r;
}",0.9752988047808764
113642,"@Override public void startRequest(final OSDRequest rq){
  UserCredentials uc=rq.getRPCRequest().getUserCredentials();
  if ((uc == null) || (!uc.getPassword().equals(master.getConfig().getAdminPassword()))) {
    rq.sendOSDException(ErrorCodes.AUTH_FAILED,""String_Node_Str"");
    return;
  }
  xtreemfs_cleanup_startRequest args=(xtreemfs_cleanup_startRequest)rq.getRequestArgs();
  master.getCleanupThread().cleanupStart(args.getRemove_zombies(),args.getRemove_unavail_volume(),args.getLost_and_found());
  xtreemfs_cleanup_startResponse response=new xtreemfs_cleanup_startResponse();
  rq.sendSuccess(response);
}","@Override public void startRequest(final OSDRequest rq){
  UserCredentials uc=rq.getRPCRequest().getUserCredentials();
  if ((uc == null) || (!uc.getPassword().equals(master.getConfig().getAdminPassword()))) {
    rq.sendOSDException(ErrorCodes.AUTH_FAILED,""String_Node_Str"");
    return;
  }
  xtreemfs_cleanup_startRequest args=(xtreemfs_cleanup_startRequest)rq.getRequestArgs();
  master.getCleanupThread().cleanupStart(args.getRemove_zombies(),args.getRemove_unavail_volume(),args.getLost_and_found(),uc);
  xtreemfs_cleanup_startResponse response=new xtreemfs_cleanup_startResponse();
  rq.sendSuccess(response);
}",0.9975708502024292
113643,"public int write(byte[] data,int offset,int length,long filePosition) throws Exception {
  final int firstObject=(int)(filePosition / this.stripeSize);
  int lastObject=(int)((filePosition + ((long)length)) / this.stripeSize);
  if (((filePosition + ((long)length)) % this.stripeSize) == 0)   lastObject--;
  final int offsetInFirstObject=(int)(filePosition % this.stripeSize);
  int bytesInLastObject=-1;
  if (firstObject == lastObject) {
    bytesInLastObject=length;
  }
 else {
    if (((filePosition + length) % this.stripeSize) == 0) {
      bytesInLastObject=this.stripeSize;
    }
 else {
      bytesInLastObject=(int)((filePosition + length) % this.stripeSize);
    }
  }
  int bytesWritten=0;
  for (int obj=firstObject; obj <= lastObject; obj++) {
    int bytesToWrite=this.stripeSize;
    int objOffset=0;
    if (obj == firstObject)     objOffset=offsetInFirstObject;
    if (obj == lastObject)     bytesToWrite=bytesInLastObject;
    ReusableBuffer view=ReusableBuffer.wrap(data,offset + bytesWritten,bytesToWrite);
    objectStore.writeObject(objOffset,obj,view);
    bytesWritten+=bytesToWrite;
  }
  return bytesWritten;
}","public int write(byte[] data,int offset,int length,long filePosition) throws Exception {
  final int firstObject=(int)(filePosition / this.stripeSize);
  int lastObject=(int)((filePosition + ((long)length)) / this.stripeSize);
  if (((filePosition + ((long)length)) % this.stripeSize) == 0)   lastObject--;
  final int offsetInFirstObject=(int)(filePosition % this.stripeSize);
  int bytesInLastObject=-1;
  if (firstObject == lastObject) {
    bytesInLastObject=length - offsetInFirstObject;
  }
 else {
    if (((filePosition + length) % this.stripeSize) == 0) {
      bytesInLastObject=this.stripeSize;
    }
 else {
      bytesInLastObject=(int)((filePosition + length) % this.stripeSize);
    }
  }
  int bytesWritten=0;
  for (int obj=firstObject; obj <= lastObject; obj++) {
    int bytesToWrite=this.stripeSize;
    int objOffset=0;
    if (obj == firstObject) {
      bytesToWrite=this.stripeSize - offsetInFirstObject;
      objOffset=offsetInFirstObject;
    }
    if (obj == lastObject)     bytesToWrite=bytesInLastObject;
    ReusableBuffer view=ReusableBuffer.wrap(data,offset + bytesWritten,bytesToWrite);
    objectStore.writeObject(objOffset,obj,view);
    bytesWritten+=bytesToWrite;
  }
  return bytesWritten;
}",0.950210970464135
113644,"private void processWrite(StageRequest rq){
  final WriteObjectCallback cback=(WriteObjectCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final long objNo=(Long)rq.getArgs()[1];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[2];
    int offset=(Integer)rq.getArgs()[3];
    final ReusableBuffer data=(ReusableBuffer)rq.getArgs()[4];
    final CowPolicy cow=(CowPolicy)rq.getArgs()[5];
    final XLocations xloc=(XLocations)rq.getArgs()[6];
    final boolean gMaxOff=(Boolean)rq.getArgs()[7];
    final int dataLength=data.remaining();
    final int stripeSize=sp.getStripeSizeForObject(objNo);
    final FileInfo fi=layout.getFileInfo(sp,fileId);
    final long oldChecksum=fi.getObjectChecksum(objNo);
    final boolean rangeRequested=(offset > 0) || (data.capacity() < stripeSize);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ objNo+ ""String_Node_Str""+ ""String_Node_Str""+ fi.getLastObjectNumber()+ ""String_Node_Str""+ dataLength+ ""String_Node_Str""+ offset);
    }
    if (offset + data.capacity() > stripeSize) {
      BufferPool.free(data);
      cback.writeComplete(null,new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
      return;
    }
    int currentV=fi.getObjectVersion(objNo);
    if (currentV == 0) {
      currentV++;
    }
    int nextV=currentV;
    assert(data != null);
    ReusableBuffer writeData=data;
    if (cow.isCOW((int)objNo)) {
      nextV++;
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ objNo+ ""String_Node_Str""+ nextV);
      }
      if (rangeRequested) {
        ObjectInformation obj=layout.readObject(fileId,objNo,currentV,oldChecksum,sp);
        ObjectData oldObject=obj.getObjectData(fi.getLastObjectNumber() == objNo,0,sp.getStripeSizeForObject(objNo));
        if (oldObject.getData() == null) {
          if (oldObject.getZero_padding() > 0) {
            writeData=BufferPool.allocate(stripeSize);
            for (int i=0; i < stripeSize; i++) {
              writeData.put((byte)0);
            }
            writeData.position(offset);
            writeData.put(data);
            writeData.position(0);
            BufferPool.free(data);
          }
 else {
            if (offset > 0) {
              writeData=BufferPool.allocate(offset + data.capacity());
              for (int i=0; i < offset; i++) {
                writeData.put((byte)0);
              }
              writeData.put(data);
              writeData.position(0);
              BufferPool.free(data);
            }
 else {
              writeData=data;
            }
          }
        }
 else {
          if (oldObject.getData().capacity() >= offset + data.capacity()) {
            writeData=oldObject.getData();
            writeData.position(offset);
            writeData.put(data);
            BufferPool.free(data);
          }
 else {
            writeData=BufferPool.allocate(offset + data.capacity());
            writeData.put(oldObject.getData());
            BufferPool.free(oldObject.getData());
            writeData.position(offset);
            writeData.put(data);
            BufferPool.free(data);
          }
        }
      }
      offset=0;
      cow.objectChanged((int)objNo);
    }
    writeData.position(0);
    layout.writeObject(fileId,objNo,writeData,nextV,offset,oldChecksum,sp);
    long newChecksum=layout.createChecksum(fileId,objNo,writeData.capacity() == sp.getStripeSizeForObject(objNo) ? writeData : null,nextV,oldChecksum);
    fi.getObjVersions().put(objNo,nextV);
    fi.getObjChecksums().put(objNo,newChecksum);
    OSDWriteResponse response=new OSDWriteResponse();
    if (objNo >= fi.getLastObjectNumber() && !gMaxOff) {
      long newObjSize=dataLength + offset;
      long newFS=0;
      if (objNo > 0) {
        newFS=sp.getObjectEndOffset(objNo - 1) + 1 + newObjSize;
      }
 else {
        newFS=newObjSize;
      }
      if (newFS > fi.getFilesize() && objNo >= fi.getLastObjectNumber() && objNo >= fi.getGlobalLastObjectNumber()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFS);
        response.getNew_file_size().add(new NewFileSize(newFS,(int)fi.getTruncateEpoch()));
      }
 else {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFS + ""String_Node_Str""+ fi.getFilesize()+ ""String_Node_Str""+ fi.getLastObjectNumber()+ ""String_Node_Str""+ objNo);
      }
      fi.setFilesize(newFS);
      if (objNo > fi.getLastObjectNumber()) {
        fi.setLastObjectNumber(objNo);
        if (objNo > fi.getGlobalLastObjectNumber()) {
          final List<ServiceUUID> osds=xloc.getLocalReplica().getOSDs();
          final ServiceUUID localUUID=master.getConfig().getUUID();
          if (osds.size() > 1) {
            for (            ServiceUUID osd : osds) {
              if (!osd.equals(localUUID)) {
                final GMAXMessage m=new GMAXMessage(fileId,fi.getTruncateEpoch(),objNo);
                master.getUdpComStage().send(m.getMessage(osd.getAddress()));
              }
            }
          }
        }
      }
    }
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fi.getLastObjectNumber() + ""String_Node_Str""+ fi.getGlobalLastObjectNumber());
    BufferPool.free(writeData);
    cback.writeComplete(response,null);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    cback.writeComplete(null,ex);
  }
}","private void processWrite(StageRequest rq){
  final WriteObjectCallback cback=(WriteObjectCallback)rq.getCallback();
  try {
    final String fileId=(String)rq.getArgs()[0];
    final long objNo=(Long)rq.getArgs()[1];
    final StripingPolicyImpl sp=(StripingPolicyImpl)rq.getArgs()[2];
    int offset=(Integer)rq.getArgs()[3];
    final ReusableBuffer data=(ReusableBuffer)rq.getArgs()[4];
    final CowPolicy cow=(CowPolicy)rq.getArgs()[5];
    final XLocations xloc=(XLocations)rq.getArgs()[6];
    final boolean gMaxOff=(Boolean)rq.getArgs()[7];
    final int dataLength=data.remaining();
    final int stripeSize=sp.getStripeSizeForObject(objNo);
    final FileInfo fi=layout.getFileInfo(sp,fileId);
    final long oldChecksum=fi.getObjectChecksum(objNo);
    final boolean rangeRequested=(offset > 0) || (data.capacity() < stripeSize);
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ objNo+ ""String_Node_Str""+ ""String_Node_Str""+ fi.getLastObjectNumber()+ ""String_Node_Str""+ dataLength+ ""String_Node_Str""+ offset);
    }
    final int dataCapacity=data.capacity();
    if (offset + dataCapacity > stripeSize) {
      BufferPool.free(data);
      cback.writeComplete(null,new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"" + offset + ""String_Node_Str""+ dataCapacity+ ""String_Node_Str""+ stripeSize+ ""String_Node_Str"",""String_Node_Str""));
      return;
    }
    int currentV=fi.getObjectVersion(objNo);
    if (currentV == 0) {
      currentV++;
    }
    int nextV=currentV;
    assert(data != null);
    ReusableBuffer writeData=data;
    if (cow.isCOW((int)objNo)) {
      nextV++;
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileId + ""String_Node_Str""+ objNo+ ""String_Node_Str""+ nextV);
      }
      if (rangeRequested) {
        ObjectInformation obj=layout.readObject(fileId,objNo,currentV,oldChecksum,sp);
        ObjectData oldObject=obj.getObjectData(fi.getLastObjectNumber() == objNo,0,sp.getStripeSizeForObject(objNo));
        if (oldObject.getData() == null) {
          if (oldObject.getZero_padding() > 0) {
            writeData=BufferPool.allocate(stripeSize);
            for (int i=0; i < stripeSize; i++) {
              writeData.put((byte)0);
            }
            writeData.position(offset);
            writeData.put(data);
            writeData.position(0);
            BufferPool.free(data);
          }
 else {
            if (offset > 0) {
              writeData=BufferPool.allocate(offset + data.capacity());
              for (int i=0; i < offset; i++) {
                writeData.put((byte)0);
              }
              writeData.put(data);
              writeData.position(0);
              BufferPool.free(data);
            }
 else {
              writeData=data;
            }
          }
        }
 else {
          if (oldObject.getData().capacity() >= offset + data.capacity()) {
            writeData=oldObject.getData();
            writeData.position(offset);
            writeData.put(data);
            BufferPool.free(data);
          }
 else {
            writeData=BufferPool.allocate(offset + data.capacity());
            writeData.put(oldObject.getData());
            BufferPool.free(oldObject.getData());
            writeData.position(offset);
            writeData.put(data);
            BufferPool.free(data);
          }
        }
      }
      offset=0;
      cow.objectChanged((int)objNo);
    }
    writeData.position(0);
    layout.writeObject(fileId,objNo,writeData,nextV,offset,oldChecksum,sp);
    long newChecksum=layout.createChecksum(fileId,objNo,writeData.capacity() == sp.getStripeSizeForObject(objNo) ? writeData : null,nextV,oldChecksum);
    fi.getObjVersions().put(objNo,nextV);
    fi.getObjChecksums().put(objNo,newChecksum);
    OSDWriteResponse response=new OSDWriteResponse();
    if (objNo >= fi.getLastObjectNumber() && !gMaxOff) {
      long newObjSize=dataLength + offset;
      long newFS=0;
      if (objNo > 0) {
        newFS=sp.getObjectEndOffset(objNo - 1) + 1 + newObjSize;
      }
 else {
        newFS=newObjSize;
      }
      if (newFS > fi.getFilesize() && objNo >= fi.getLastObjectNumber() && objNo >= fi.getGlobalLastObjectNumber()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFS);
        response.getNew_file_size().add(new NewFileSize(newFS,(int)fi.getTruncateEpoch()));
      }
 else {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFS + ""String_Node_Str""+ fi.getFilesize()+ ""String_Node_Str""+ fi.getLastObjectNumber()+ ""String_Node_Str""+ objNo);
      }
      fi.setFilesize(newFS);
      if (objNo > fi.getLastObjectNumber()) {
        fi.setLastObjectNumber(objNo);
        if (objNo > fi.getGlobalLastObjectNumber()) {
          final List<ServiceUUID> osds=xloc.getLocalReplica().getOSDs();
          final ServiceUUID localUUID=master.getConfig().getUUID();
          if (osds.size() > 1) {
            for (            ServiceUUID osd : osds) {
              if (!osd.equals(localUUID)) {
                final GMAXMessage m=new GMAXMessage(fileId,fi.getTruncateEpoch(),objNo);
                master.getUdpComStage().send(m.getMessage(osd.getAddress()));
              }
            }
          }
        }
      }
    }
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fi.getLastObjectNumber() + ""String_Node_Str""+ fi.getGlobalLastObjectNumber());
    BufferPool.free(writeData);
    cback.writeComplete(response,null);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    cback.writeComplete(null,ex);
  }
}",0.9873168988924615
113645,"public static void main(String[] args){
  try {
    Map<String,CliOption> options=new HashMap<String,CliOption>();
    List<String> arguments=new ArrayList<String>(2);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    CLIParser.parseCLI(args,options,arguments);
    Logging.start(Logging.LEVEL_WARN);
    TimeSync.initialize(null,10000,50);
    if (arguments.size() != 2) {
      usage();
      return;
    }
    final ONCRPCServiceURL mrcURL=new ONCRPCServiceURL(arguments.get(1));
    final String path=(options.get(""String_Node_Str"").stringValue != null) ? options.get(""String_Node_Str"").stringValue : ""String_Node_Str"";
    final String volname=(options.get(""String_Node_Str"").stringValue != null) ? options.get(""String_Node_Str"").stringValue : ""String_Node_Str"";
    final ONCRPCServiceURL dirURL=new ONCRPCServiceURL(arguments.get(0));
    boolean useSSL=false;
    final SSLOptions sslOptions;
    if (dirURL.getProtocol().equalsIgnoreCase(""String_Node_Str"")) {
      String serviceCredsFile=null;
      String serviceCredsPass=null;
      String trustedCAsFile=null;
      String trustedCAsPass=null;
      useSSL=true;
      serviceCredsFile=options.get(""String_Node_Str"").stringValue;
      serviceCredsPass=options.get(""String_Node_Str"").stringValue;
      trustedCAsFile=options.get(""String_Node_Str"").stringValue;
      trustedCAsPass=options.get(""String_Node_Str"").stringValue;
      sslOptions=new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false);
      System.out.println(""String_Node_Str"");
    }
 else {
      sslOptions=null;
    }
    RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(sslOptions,10000,5 * 60 * 1000);
    rpcClient.start();
    rpcClient.waitForStartup();
    DIRClient dir=new DIRClient(rpcClient,new InetSocketAddress(dirURL.getHost(),dirURL.getPort()));
    UUIDResolver.start(dir,10000,9999999);
    System.out.println(""String_Node_Str"");
    final int MIN_FS=64 * 1024;
    final int MAX_FS=512 * 1024 * 1024;
    final int MIN_REC=4 * 1024;
    final int MAX_REC=1024 * 1024;
    InetSocketAddress mrcAddr=new InetSocketAddress(mrcURL.getHost(),mrcURL.getPort());
    List<String> grs=new ArrayList(1);
    grs.add(""String_Node_Str"");
    final UserCredentials uc=MRCClient.getCredentials(""String_Node_Str"",grs);
    if (options.get(""String_Node_Str"").switchValue) {
      MRCClient mrcClient=new MRCClient(rpcClient,mrcAddr);
      StripingPolicy sp=new StripingPolicy(StripingPolicyType.STRIPING_POLICY_RAID0,128,1);
      RPCResponse r=mrcClient.mkvol(mrcAddr,uc,volname,OSDSelectionPolicyType.OSD_SELECTION_POLICY_SIMPLE.intValue(),sp,AccessControlPolicyType.ACCESS_CONTROL_POLICY_POSIX.intValue(),0775);
      r.get();
      r.freeBuffers();
    }
    RandomAccessFile tmp=new RandomAccessFile(""String_Node_Str"",mrcAddr,volname + path + ""String_Node_Str"",rpcClient,""String_Node_Str"",grs);
    System.out.println(""String_Node_Str"" + tmp.getStripingPolicyAsString());
    for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
      for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
        final int numRecs=fsize / recsize;
        if (numRecs == 0)         continue;
        byte[] sendBuffer=new byte[recsize];
        for (int i=0; i < recsize; i++) {
          sendBuffer[i]=(byte)((i % 26) + 65);
        }
        long tStart=System.currentTimeMillis();
        RandomAccessFile raf=new RandomAccessFile(""String_Node_Str"",mrcAddr,volname + path,rpcClient,""String_Node_Str"",grs);
        long tOpen=System.currentTimeMillis();
        long bytesWritten=0;
        for (int rec=0; rec < numRecs; rec++) {
          bytesWritten+=raf.write(sendBuffer,0,recsize);
        }
        final long tWrite=System.currentTimeMillis();
        assert(bytesWritten == numRecs * recsize);
        raf.flush();
        raf.seek(0);
        final long tFlush=System.currentTimeMillis();
        byte[] readBuffer=new byte[recsize];
        for (int rec=0; rec < numRecs; rec++) {
          final int bytesRead=raf.read(readBuffer,0,recsize);
          if (bytesRead != recsize) {
            System.out.println(""String_Node_Str"" + rec * recsize);
            System.out.println(""String_Node_Str"" + recsize + ""String_Node_Str"");
            System.out.println(""String_Node_Str"" + bytesRead + ""String_Node_Str"");
            System.exit(1);
          }
          for (int i=0; i < recsize; i++) {
            if (readBuffer[i] != (byte)((i % 26) + 65)) {
              System.out.println(""String_Node_Str"" + (rec * recsize + i));
              System.out.println(""String_Node_Str"" + (byte)((i % 26) + 65));
              System.out.println(""String_Node_Str"" + readBuffer[i]);
              System.exit(1);
            }
          }
        }
        final long tRead=System.currentTimeMillis();
        raf.delete();
        final long tDelete=System.currentTimeMillis();
        double writeRate=((double)fsize) / 1024.0 / (((double)(tWrite - tOpen + 1)) / 1000.0);
        double readRate=((double)fsize) / 1024.0 / (((double)(tRead - tFlush + 1)) / 1000.0);
        System.out.format(""String_Node_Str"",fsize / 1024,recsize,(tWrite - tOpen),writeRate,(tRead - tFlush),readRate);
      }
    }
    System.out.println(""String_Node_Str"");
    rpcClient.shutdown();
    UUIDResolver.shutdown();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}","public static void main(String[] args){
  try {
    Map<String,CliOption> options=new HashMap<String,CliOption>();
    List<String> arguments=new ArrayList<String>(2);
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    CLIParser.parseCLI(args,options,arguments);
    Logging.start(Logging.LEVEL_WARN);
    TimeSync.initialize(null,10000,50);
    if (arguments.size() != 2) {
      usage();
      return;
    }
    final ONCRPCServiceURL mrcURL=new ONCRPCServiceURL(arguments.get(1));
    final String path=(options.get(""String_Node_Str"").stringValue != null) ? options.get(""String_Node_Str"").stringValue : ""String_Node_Str"";
    final String volname=(options.get(""String_Node_Str"").stringValue != null) ? options.get(""String_Node_Str"").stringValue : ""String_Node_Str"";
    final ONCRPCServiceURL dirURL=new ONCRPCServiceURL(arguments.get(0));
    boolean useSSL=false;
    final SSLOptions sslOptions;
    if (dirURL.getProtocol().equalsIgnoreCase(""String_Node_Str"")) {
      String serviceCredsFile=null;
      String serviceCredsPass=null;
      String trustedCAsFile=null;
      String trustedCAsPass=null;
      useSSL=true;
      serviceCredsFile=options.get(""String_Node_Str"").stringValue;
      serviceCredsPass=options.get(""String_Node_Str"").stringValue;
      trustedCAsFile=options.get(""String_Node_Str"").stringValue;
      trustedCAsPass=options.get(""String_Node_Str"").stringValue;
      sslOptions=new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false);
      System.out.println(""String_Node_Str"");
    }
 else {
      sslOptions=null;
    }
    RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(sslOptions,10000,5 * 60 * 1000);
    rpcClient.start();
    rpcClient.waitForStartup();
    DIRClient dir=new DIRClient(rpcClient,new InetSocketAddress(dirURL.getHost(),dirURL.getPort()));
    UUIDResolver.start(dir,10000,9999999);
    System.out.println(""String_Node_Str"");
    final int MIN_FS=64 * 1024;
    final int MAX_FS=512 * 1024 * 1024;
    final int MIN_REC=4 * 1024;
    final int MAX_REC=1024 * 1024;
    InetSocketAddress mrcAddr=new InetSocketAddress(mrcURL.getHost(),mrcURL.getPort());
    List<String> grs=new ArrayList(1);
    grs.add(""String_Node_Str"");
    final UserCredentials uc=MRCClient.getCredentials(""String_Node_Str"",grs);
    if (options.get(""String_Node_Str"").switchValue) {
      MRCClient mrcClient=new MRCClient(rpcClient,mrcAddr);
      StripingPolicy sp=new StripingPolicy(StripingPolicyType.STRIPING_POLICY_RAID0,128,1);
      RPCResponse r=mrcClient.mkvol(mrcAddr,uc,volname,OSDSelectionPolicyType.OSD_SELECTION_POLICY_SIMPLE.intValue(),sp,AccessControlPolicyType.ACCESS_CONTROL_POLICY_POSIX.intValue(),0775);
      r.get();
      r.freeBuffers();
    }
    RandomAccessFile tmp=new RandomAccessFile(""String_Node_Str"",mrcAddr,volname + path + ""String_Node_Str"",rpcClient,""String_Node_Str"",grs);
    System.out.println(""String_Node_Str"" + tmp.getStripingPolicyAsString());
    for (int fsize=MIN_FS; fsize <= MAX_FS; fsize=fsize * 2) {
      for (int recsize=MIN_REC; recsize <= MAX_REC; recsize=recsize * 2) {
        if (testSequential(fsize,recsize,mrcAddr,volname,path,rpcClient,grs)) {
          continue;
        }
        if (testRandom(fsize,recsize,mrcAddr,volname,path,rpcClient,grs)) {
          continue;
        }
      }
    }
    System.out.println(""String_Node_Str"");
    rpcClient.shutdown();
    UUIDResolver.shutdown();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}",0.7808899483512117
113646,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      if ((rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0 && (rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)       res.checkIfFileExistsAlready();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,file.isReadOnly() ? Constants.REPL_UPDATE_PC_RONLY : Constants.REPL_UPDATE_PC_NONE,0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      if ((rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0 && (rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)       res.checkIfFileExistsAlready();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),rqArgs.getAttributes(),0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,file.isReadOnly() ? Constants.REPL_UPDATE_PC_RONLY : Constants.REPL_UPDATE_PC_NONE,0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else {
      xLocSet=Converter.xLocListToXLocSet(xLocList);
      if (file.isReadOnly())       xLocSet.setRead_only_file_size(file.getSize());
    }
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9901722498150692
113647,"public RPCResponse<FileCredentials> open(InetSocketAddress server,UserCredentials credentials,String path,int flags,int mode,int w32attrs){
  openRequest rq=new openRequest(path,flags,w32attrs,mode);
  RPCResponse<FileCredentials> r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder<FileCredentials>(){
    @Override public FileCredentials getResult(    ReusableBuffer data){
      final openResponse resp=new openResponse();
      resp.deserialize(data);
      return resp.getFile_credentials();
    }
  }
,credentials);
  return r;
}","public RPCResponse<FileCredentials> open(InetSocketAddress server,UserCredentials credentials,String path,int flags,int mode,int w32attrs){
  openRequest rq=new openRequest(path,flags,mode,w32attrs);
  RPCResponse<FileCredentials> r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder<FileCredentials>(){
    @Override public FileCredentials getResult(    ReusableBuffer data){
      final openResponse resp=new openResponse();
      resp.deserialize(data);
      return resp.getFile_credentials();
    }
  }
,credentials);
  return r;
}",0.9909747292418772
113648,"public RPCResponse utime(InetSocketAddress server,UserCredentials credentials,String path,long atime,long ctime,long mtime){
  utimeRequest rq=new utimeRequest(path,atime,ctime,mtime);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final utimeResponse resp=new utimeResponse();
      resp.deserialize(data);
      return null;
    }
  }
,credentials);
  return r;
}","public RPCResponse utime(InetSocketAddress server,UserCredentials credentials,String path,long atime,long ctime,long mtime){
  utimensRequest rq=new utimensRequest(path,atime,ctime,mtime);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final utimensResponse resp=new utimensResponse();
      resp.deserialize(data);
      return null;
    }
  }
,credentials);
  return r;
}",0.9916666666666668
113649,"public RPCResponse xtreemfs_replica_remove(InetSocketAddress server,UserCredentials credentials,String fileId,String osdUUID){
  xtreemfs_replica_removeRequest rq=new xtreemfs_replica_removeRequest(fileId,osdUUID);
  RPCResponse r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final xtreemfs_replica_addResponse resp=new xtreemfs_replica_addResponse();
      resp.deserialize(data);
      return null;
    }
  }
,credentials);
  return r;
}","public RPCResponse<XCap> xtreemfs_replica_remove(InetSocketAddress server,UserCredentials credentials,String fileId,String osdUUID){
  xtreemfs_replica_removeRequest rq=new xtreemfs_replica_removeRequest(fileId,osdUUID);
  RPCResponse<XCap> r=sendRequest(server,rq.getOperationNumber(),rq,new RPCResponseDecoder(){
    @Override public Object getResult(    ReusableBuffer data){
      final xtreemfs_replica_removeResponse resp=new xtreemfs_replica_removeResponse();
      resp.deserialize(data);
      return resp.getDelete_xcap();
    }
  }
,credentials);
  return r;
}",0.950316169828365
113650,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFile_id());
    StorageManager sMan=vMan.getStorageManager(idRes.getVolumeId());
    FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    XLocList xLocList=file.getXLocList();
    int i=0;
    for (; i < xLocList.getReplicaCount(); i++) {
      XLoc replica=xLocList.getReplica(i);
      if (replica.getOSD(0).equals(rqArgs.getOsd_uuid()))       break;
    }
    XLoc[] newReplList=new XLoc[xLocList.getReplicaCount() - 1];
    for (int j=0, count=0; j < xLocList.getReplicaCount(); j++)     if (j != i)     newReplList[count++]=xLocList.getReplica(j);
    xLocList=sMan.createXLocList(newReplList,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    Capability deleteCap=new Capability(idRes.getVolumeId() + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),file.getEpoch(),master.getConfig().getCapabilitySecret());
    rq.setResponse(new xtreemfs_replica_removeResponse(deleteCap));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    GlobalFileIdResolver idRes=new GlobalFileIdResolver(rqArgs.getFile_id());
    StorageManager sMan=vMan.getStorageManager(idRes.getVolumeId());
    FileMetadata file=sMan.getMetadata(idRes.getLocalFileId());
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    XLocList xLocList=file.getXLocList();
    int i=0;
    for (; i < xLocList.getReplicaCount(); i++) {
      XLoc replica=xLocList.getReplica(i);
      if (replica.getOSD(0).equals(rqArgs.getOsd_uuid()))       break;
    }
    XLoc[] newReplList=new XLoc[xLocList.getReplicaCount() - 1];
    for (int j=0, count=0; j < xLocList.getReplicaCount(); j++)     if (j != i)     newReplList[count++]=xLocList.getReplica(j);
    xLocList=sMan.createXLocList(newReplList,xLocList.getReplUpdatePolicy(),xLocList.getVersion() + 1);
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    Capability deleteCap=new Capability(idRes.getVolumeId() + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),file.getEpoch(),master.getConfig().getCapabilitySecret());
    rq.setResponse(new xtreemfs_replica_removeResponse(deleteCap.getXCap()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.998196898665705
113651,"public void run(){
  try {
    do {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
      final String fileID=files.take();
      try {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileID);
        layout.deleteFile(fileID);
      }
 catch (      IOException ex) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
      }
    }
 while (!quit);
  }
 catch (  InterruptedException ex) {
  }
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
}","public void run(){
  try {
    do {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
      final String fileID=files.take();
      try {
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fileID);
        layout.deleteFile(fileID);
      }
 catch (      IOException ex) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
      }
    }
 while (!quit);
  }
 catch (  InterruptedException ex) {
  }
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
}",0.9706717123935666
113652,"private void doCheckDeleteOnClose(StageRequest m){
  final String fileId=(String)m.getArgs()[0];
  final DeleteOnCloseCallback callback=(DeleteOnCloseCallback)m.getCallback();
  final boolean deleteOnClose=oft.contains(fileId);
  callback.deleteOnCloseResult(deleteOnClose,null);
}","private void doCheckDeleteOnClose(StageRequest m){
  final String fileId=(String)m.getArgs()[0];
  final DeleteOnCloseCallback callback=(DeleteOnCloseCallback)m.getCallback();
  final boolean deleteOnClose=oft.contains(fileId);
  if (deleteOnClose)   oft.setDeleteOnClose(fileId);
  callback.deleteOnCloseResult(deleteOnClose,null);
}",0.913821138211382
113653,"public boolean isStriped(){
  return stripingPolicy.getWidth() > 1;
}","public boolean isStriped(){
  return getStripingPolicy().getWidth() > 1;
}",0.951048951048951
113654,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      if ((rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0 && (rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)       res.checkIfFileExistsAlready();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,Constants.REPL_UPDATE_PC_NONE,0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      if ((rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0 && (rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)       res.checkIfFileExistsAlready();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,file.isReadOnly() ? Constants.REPL_UPDATE_PC_RONLY : Constants.REPL_UPDATE_PC_NONE,0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9942857142857144
113655,"@Override public void startRequest(MRCRequest rq){
  try {
    final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new mkdirResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    if (res.getParentDir() == null)     throw new UserException(ErrNo.EEXIST,""String_Node_Str"" + res.getFileName() + ""String_Node_Str"");
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new mkdirResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9607787002576582
113656,"@Override public void startRequest(MRCRequest rq){
  try {
    final createRequest rqArgs=(createRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    rq.setResponse(new createResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final createRequest rqArgs=(createRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    if (res.getParentDir() == null)     throw new UserException(ErrNo.EEXIST,""String_Node_Str"" + res.getFileName() + ""String_Node_Str"");
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    rq.setResponse(new createResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.958697618329816
113657,"public void testCreateDelete() throws Exception {
  final String uid=""String_Node_Str"";
  final List<String> gids=createGIDs(""String_Node_Str"");
  final String volumeName=""String_Node_Str"";
  final UserCredentials uc=MRCClient.getCredentials(uid,gids);
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,1,getDefaultStripingPolicy(),YesToAnyoneFileAccessPolicy.POLICY_ID,0));
  invokeSync(client.rmvol(mrcAddress,uc,volumeName));
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,1,getDefaultStripingPolicy(),YesToAnyoneFileAccessPolicy.POLICY_ID,0));
  invokeSync(client.mkdir(mrcAddress,uc,volumeName + ""String_Node_Str"",0));
  invokeSync(client.mkdir(mrcAddress,uc,volumeName + ""String_Node_Str"",0));
  for (int i=0; i < 10; i++)   invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"" + i+ ""String_Node_Str"",0));
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName,0));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"",0));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"",0));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  DirectoryEntrySet entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName));
  assertEquals(2,entrySet.size());
  entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(10,entrySet.size());
  Stat stat=invokeSync(client.getattr(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(uid,stat.getUser_id());
  assertTrue(""String_Node_Str"",(stat.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFREG) != 0);
  assertEquals(0,stat.getSize());
  assertTrue(stat.getAtime_ns() > 0);
  assertTrue(stat.getCtime_ns() > 0);
  assertTrue(stat.getMtime_ns() > 0);
  assertTrue((stat.getMode() & 511) > 0);
  assertEquals(1,stat.getNlink());
  invokeSync(client.unlink(mrcAddress,uc,volumeName + ""String_Node_Str""));
  entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(9,entrySet.size());
  invokeSync(client.rmdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
}","public void testCreateDelete() throws Exception {
  final String uid=""String_Node_Str"";
  final List<String> gids=createGIDs(""String_Node_Str"");
  final String volumeName=""String_Node_Str"";
  final UserCredentials uc=MRCClient.getCredentials(uid,gids);
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,1,getDefaultStripingPolicy(),POSIXFileAccessPolicy.POLICY_ID,0775));
  invokeSync(client.rmvol(mrcAddress,uc,volumeName));
  invokeSync(client.mkvol(mrcAddress,uc,volumeName,1,getDefaultStripingPolicy(),POSIXFileAccessPolicy.POLICY_ID,0775));
  invokeSync(client.mkdir(mrcAddress,uc,volumeName + ""String_Node_Str"",0775));
  invokeSync(client.mkdir(mrcAddress,uc,volumeName + ""String_Node_Str"",0775));
  for (int i=0; i < 10; i++)   invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"" + i+ ""String_Node_Str"",0775));
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName,0775));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"",0775));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  try {
    invokeSync(client.create(mrcAddress,uc,volumeName + ""String_Node_Str"",0775));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  try {
    invokeSync(client.mkdir(mrcAddress,uc,volumeName + ""String_Node_Str"",0));
    fail(""String_Node_Str"");
  }
 catch (  MRCException exc) {
  }
  DirectoryEntrySet entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName));
  assertEquals(2,entrySet.size());
  entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(10,entrySet.size());
  Stat stat=invokeSync(client.getattr(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(uid,stat.getUser_id());
  assertTrue(""String_Node_Str"",(stat.getMode() & Constants.SYSTEM_V_FCNTL_H_S_IFREG) != 0);
  assertEquals(0,stat.getSize());
  assertTrue(stat.getAtime_ns() > 0);
  assertTrue(stat.getCtime_ns() > 0);
  assertTrue(stat.getMtime_ns() > 0);
  assertTrue((stat.getMode() & 511) > 0);
  assertEquals(1,stat.getNlink());
  invokeSync(client.unlink(mrcAddress,uc,volumeName + ""String_Node_Str""));
  entrySet=invokeSync(client.readdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
  assertEquals(9,entrySet.size());
  invokeSync(client.rmdir(mrcAddress,uc,volumeName + ""String_Node_Str""));
}",0.9547521108465036
113658,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      if ((rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0 && (rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)       res.checkIfFileExistsAlready();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.971353597200962
113659,"@Override public String getXAttr(long fileId,String uid,String key) throws DatabaseException {
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,XATTRS_INDEX,prefix);
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public String getXAttr(long fileId,String uid,String key) throws DatabaseException {
  try {
    byte[] prefix=BabuDBStorageHelper.createXAttrPrefixKey(fileId,uid,key);
    Iterator<Entry<byte[],byte[]>> it=database.directPrefixLookup(dbName,XATTRS_INDEX,prefix);
    while (it.hasNext()) {
      Entry<byte[],byte[]> curr=it.next();
      BufferBackedXAttr xattr=new BufferBackedXAttr(curr.getKey(),curr.getValue());
      if (uid.equals(xattr.getOwner()) && key.equals(xattr.getKey()))       return xattr.getValue();
    }
    it=database.directPrefixLookup(dbName,XATTRS_INDEX,new byte[0]);
    while (it.hasNext())     System.out.println(Arrays.toString(it.next().getKey()));
    return null;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}",0.8907681465821
113660,"@Override public void startRequest(MRCRequest rq){
  try {
    final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path sp=new Path(rqArgs.getSource_path());
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.getTarget_path());
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    FileCredentialsSet creds=new FileCredentialsSet();
    if (sp.equals(tp)) {
      rq.setResponse(new renameResponse(creds));
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
if (target.getLinkCount() == 1) {
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + target.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),target.getEpoch(),master.getConfig().getCapabilitySecret());
  creds.add(new FileCredentials(Converter.xLocListToXLocSet(target.getXLocList()),cap.getXCap()));
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setResponse(new renameResponse(creds));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Throwable exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}","@Override public void startRequest(MRCRequest rq){
  try {
    final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path sp=new Path(rqArgs.getSource_path());
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.getTarget_path());
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    FileCredentialsSet creds=new FileCredentialsSet();
    if (sp.equals(tp)) {
      rq.setResponse(new renameResponse(creds));
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.unlink(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.unlink(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.unlink(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
if (target.getLinkCount() == 1) {
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + target.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),target.getEpoch(),master.getConfig().getCapabilitySecret());
  creds.add(new FileCredentials(Converter.xLocListToXLocSet(target.getXLocList()),cap.getXCap()));
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.unlink(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setResponse(new renameResponse(creds));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Throwable exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}",0.9956966110812264
113661,"public void removeReplica(ServiceUUID osd) throws Exception {
  mrcClient.xtreemfs_replica_remove(mrcAddress,credentials,fileId,osd.toString());
  forceXCapUpdate();
}","public void removeReplica(ServiceUUID osd) throws Exception {
  RPCResponse r=mrcClient.xtreemfs_replica_remove(mrcAddress,credentials,fileId,osd.toString());
  r.get();
  r.freeBuffers();
  forceFileCredentialsUpdate(translateMode(""String_Node_Str""));
}",0.7410926365795725
113662,"public void addReplica(List<ServiceUUID> osds,StripingPolicy spPolicy) throws Exception {
  if (isReadOnly) {
    StringSet osdSet=new StringSet();
    for (    ServiceUUID osd : osds) {
      osdSet.add(osd.toString());
    }
    org.xtreemfs.interfaces.Replica newReplica=new org.xtreemfs.interfaces.Replica(spPolicy,0,osdSet);
    mrcClient.xtreemfs_replica_add(mrcAddress,credentials,fileId,newReplica);
    forceXCapUpdate();
  }
 else   throw new IOException(""String_Node_Str"");
}","public void addReplica(List<ServiceUUID> osds,StripingPolicy spPolicy) throws Exception {
  XLocations xLoc=new XLocations(fileCredentials.getXlocs());
  if (osds.size() != spPolicy.getWidth())   throw new IllegalArgumentException(""String_Node_Str"");
  for (  ServiceUUID osd : osds) {
    if (xLoc.containsOSD(osd))     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (isReadOnly) {
    StringSet osdSet=new StringSet();
    for (    ServiceUUID osd : osds) {
      osdSet.add(osd.toString());
    }
    org.xtreemfs.interfaces.Replica newReplica=new org.xtreemfs.interfaces.Replica(spPolicy,0,osdSet);
    RPCResponse r=mrcClient.xtreemfs_replica_add(mrcAddress,credentials,fileId,newReplica);
    r.get();
    r.freeBuffers();
    forceFileCredentialsUpdate(translateMode(""String_Node_Str""));
  }
 else   throw new IOException(""String_Node_Str"");
}",0.6090169992609017
113663,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_get_suitable_osdsRequest rqArgs=(xtreemfs_get_suitable_osdsRequest)rq.getRequestArgs();
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    ServiceSet usableOSDs=master.getOSDStatusManager().getUsableOSDs(volumeId);
    StringSet uuids=new StringSet();
    for (int i=0; i < usableOSDs.calculateSize(); i++)     uuids.add(usableOSDs.get(i).getUuid());
    rq.setResponse(new xtreemfs_get_suitable_osdsResponse(uuids));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_get_suitable_osdsRequest rqArgs=(xtreemfs_get_suitable_osdsRequest)rq.getRequestArgs();
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    ServiceSet usableOSDs=master.getOSDStatusManager().getUsableOSDs(volumeId);
    StringSet uuids=new StringSet();
    for (int i=0; i < usableOSDs.size(); i++)     uuids.add(usableOSDs.get(i).getUuid());
    rq.setResponse(new xtreemfs_get_suitable_osdsResponse(uuids));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9949425287356322
113664,"public void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_CLIENT,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.DIR_SERVICE});
  testEnv.start();
  dsCfg=SetupUtils.createDIRConfig();
  mrcCfg1=SetupUtils.createMRC1Config();
  mrc1Address=SetupUtils.getMRC1Addr();
  osdConfig1=SetupUtils.createOSD1Config();
  osdConfig2=SetupUtils.createOSD2Config();
  File testDir=new File(SetupUtils.TEST_DIR);
  FSUtils.delTree(testDir);
  testDir.mkdirs();
  osd1=new OSD(osdConfig1);
  osd2=new OSD(osdConfig2);
  mrc1=new MRCRequestDispatcher(mrcCfg1);
  mrc1.startup();
  volumeName=""String_Node_Str"";
  RPCResponse r=testEnv.getMrcClient().mkvol(mrc1Address,uc,volumeName,Constants.OSD_SELECTION_POLICY_SIMPLE,new StripingPolicy(Constants.STRIPING_POLICY_RAID0,64,1),Constants.ACCESS_CONTROL_POLICY_NULL,0);
  r.get();
  r=testEnv.getMrcClient().mkdir(mrc1Address,uc,volumeName + ""String_Node_Str"",0);
  r.get();
  for (int i=0; i < 10; i++) {
    r=testEnv.getMrcClient().create(mrc1Address,uc,volumeName + ""String_Node_Str"" + i+ ""String_Node_Str"",0);
    r.get();
  }
}","public void setUp() throws Exception {
  System.out.println(""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ getName());
  testEnv=new TestEnvironment(new TestEnvironment.Services[]{TestEnvironment.Services.DIR_CLIENT,TestEnvironment.Services.MRC_CLIENT,TestEnvironment.Services.TIME_SYNC,TestEnvironment.Services.UUID_RESOLVER,TestEnvironment.Services.DIR_SERVICE});
  testEnv.start();
  dsCfg=SetupUtils.createDIRConfig();
  mrcCfg1=SetupUtils.createMRC1Config();
  mrc1Address=SetupUtils.getMRC1Addr();
  osdConfig1=SetupUtils.createOSD1Config();
  osdConfig2=SetupUtils.createOSD2Config();
  osdConfig3=SetupUtils.createOSD3Config();
  osdConfig4=SetupUtils.createOSD4Config();
  File testDir=new File(SetupUtils.TEST_DIR);
  FSUtils.delTree(testDir);
  testDir.mkdirs();
  osd1=new OSD(osdConfig1);
  osd2=new OSD(osdConfig2);
  osd3=new OSD(osdConfig3);
  osd4=new OSD(osdConfig4);
  mrc1=new MRCRequestDispatcher(mrcCfg1);
  mrc1.startup();
  volumeName=""String_Node_Str"";
  RPCResponse r=testEnv.getMrcClient().mkvol(mrc1Address,uc,volumeName,Constants.OSD_SELECTION_POLICY_SIMPLE,new StripingPolicy(Constants.STRIPING_POLICY_RAID0,64,1),Constants.ACCESS_CONTROL_POLICY_NULL,0);
  r.get();
  r=testEnv.getMrcClient().mkdir(mrc1Address,uc,volumeName + ""String_Node_Str"",0);
  r.get();
  for (int i=0; i < 10; i++) {
    r=testEnv.getMrcClient().create(mrc1Address,uc,volumeName + ""String_Node_Str"" + i+ ""String_Node_Str"",0);
    r.get();
  }
}",0.9484609878310666
113665,"public void testReplicaCreationAndRemoval() throws Exception {
  randomAccessFile=new RandomAccessFile(""String_Node_Str"",mrc1Address,volumeName + ""String_Node_Str"",testEnv.getRpcClient(),userID,groupIDs);
  byte[] bytesIn=new String(""String_Node_Str"").getBytes();
  int length=bytesIn.length;
  ReusableBuffer data=ReusableBuffer.wrap(bytesIn);
  randomAccessFile.writeObject(0,0,data);
  randomAccessFile.setReadOnly(true);
  assertEquals(Constants.REPL_UPDATE_PC_RONLY,randomAccessFile.getCredentials().getXlocs().getRepUpdatePolicy());
  List<ServiceUUID> replica1=randomAccessFile.getSuitableOSDs();
  for (int i=0; i < replica1.size(); i++) {
    if (i >= randomAccessFile.getStripingPolicy().getWidth())     replica1.remove(i);
  }
  randomAccessFile.addReplica(replica1,randomAccessFile.getStripingPolicy());
  assertEquals(2,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  List<ServiceUUID> replica2=randomAccessFile.getSuitableOSDs();
  for (int i=0; i < replica1.size(); i++) {
    if (i >= randomAccessFile.getStripingPolicy().getWidth())     replica1.remove(i);
  }
  randomAccessFile.addReplica(replica2,randomAccessFile.getStripingPolicy());
  assertEquals(3,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  randomAccessFile.removeReplica(replica1.get(0));
  assertEquals(2,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  try {
    randomAccessFile.setReadOnly(false);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  randomAccessFile.removeReplica(replica2.get(0));
  assertEquals(1,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  try {
    randomAccessFile.setReadOnly(false);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
}","public void testReplicaCreationAndRemoval() throws Exception {
  randomAccessFile=new RandomAccessFile(""String_Node_Str"",mrc1Address,volumeName + ""String_Node_Str"",testEnv.getRpcClient(),userID,groupIDs);
  byte[] bytesIn=new String(""String_Node_Str"").getBytes();
  int length=bytesIn.length;
  ReusableBuffer data=ReusableBuffer.wrap(bytesIn);
  randomAccessFile.writeObject(0,0,data);
  randomAccessFile.setReadOnly(true);
  assertEquals(Constants.REPL_UPDATE_PC_RONLY,randomAccessFile.getCredentials().getXlocs().getRepUpdatePolicy());
  List<ServiceUUID> replica1=randomAccessFile.getSuitableOSDsForAReplica();
  replica1=replica1.subList(0,randomAccessFile.getStripingPolicy().getWidth());
  randomAccessFile.addReplica(replica1,randomAccessFile.getStripingPolicy());
  assertEquals(2,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  List<ServiceUUID> replica2=randomAccessFile.getSuitableOSDsForAReplica();
  replica2=replica2.subList(0,randomAccessFile.getStripingPolicy().getWidth());
  randomAccessFile.addReplica(replica2,randomAccessFile.getStripingPolicy());
  assertEquals(3,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  randomAccessFile.removeReplica(replica1.get(0));
  assertEquals(2,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  try {
    randomAccessFile.setReadOnly(false);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  randomAccessFile.removeReplica(replica2.get(0));
  assertEquals(1,randomAccessFile.getCredentials().getXlocs().getReplicas().size());
  try {
    randomAccessFile.setReadOnly(false);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
}",0.9236151603498542
113666,"public void tearDown() throws Exception {
  mrc1.shutdown();
  osd1.shutdown();
  osd2.shutdown();
  testEnv.shutdown();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,BufferPool.getStatus());
}","public void tearDown() throws Exception {
  mrc1.shutdown();
  osd1.shutdown();
  osd2.shutdown();
  osd3.shutdown();
  osd4.shutdown();
  testEnv.shutdown();
  Logging.logMessage(Logging.LEVEL_DEBUG,this,BufferPool.getStatus());
}",0.910377358490566
113667,"public ChannelIO(SocketChannel channel){
  super();
  this.channel=channel;
  this.certs=null;
  attachment=null;
}","public ChannelIO(SocketChannel channel){
  this.channel=channel;
  this.certs=null;
  attachment=null;
}",0.9497716894977168
113668,"/** 
 * creates a SSLChannelIO
 * @param channel channel, which should be protected by SSL
 * @param sslOptions the Options for the SSL-Connection
 * @param clientMode true, if you are a client; false, if you are a server
 * @throws SSLException
 */
public SSLChannelIO(SocketChannel channel,SSLOptions sslOptions,boolean clientMode) throws SSLException {
  super(channel);
  sslEngine=sslOptions.getSSLContext().createSSLEngine();
  sslEngine.setUseClientMode(clientMode);
  sslEngine.setNeedClientAuth(true);
  if (clientMode) {
    sslEngine.beginHandshake();
    handshakeStatus=HandshakeStatus.NEED_WRAP;
  }
 else {
    sslEngine.beginHandshake();
    handshakeStatus=HandshakeStatus.NEED_UNWRAP;
  }
  handshakeComplete=false;
  shutdownInProgress=false;
  int netBufSize=sslEngine.getSession().getPacketBufferSize();
  inNetBuffer=BufferPool.allocate(netBufSize);
  inReadBuffer=BufferPool.allocate(sslEngine.getSession().getApplicationBufferSize());
  outNetBuffer=BufferPool.allocate(netBufSize);
  dummyBuffer=BufferPool.allocate(netBufSize);
  sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
  if (sslOptions.isAuthenticationWithoutEncryption()) {
    if (supportedCipherSuitesWithoutEncryption == null) {
      ArrayList<String> cipherSuites=new ArrayList<String>();
      for (      String cipherSuite : sslEngine.getSupportedCipherSuites()) {
        if (cipherSuite.contains(""String_Node_Str"")) {
          cipherSuites.add(cipherSuite);
        }
      }
      supportedCipherSuitesWithoutEncryption=new String[cipherSuites.size()];
      supportedCipherSuitesWithoutEncryption=cipherSuites.toArray(supportedCipherSuitesWithoutEncryption);
    }
    sslEngine.setEnabledCipherSuites(supportedCipherSuitesWithoutEncryption);
  }
 else {
    sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
  }
}","/** 
 * creates a SSLChannelIO
 * @param channel channel, which should be protected by SSL
 * @param sslOptions the Options for the SSL-Connection
 * @param clientMode true, if you are a client; false, if you are a server
 * @throws SSLException
 */
public SSLChannelIO(SocketChannel channel,SSLOptions sslOptions,boolean clientMode) throws SSLException {
  super(channel);
  sslEngine=sslOptions.getSSLContext().createSSLEngine();
  sslEngine.setUseClientMode(clientMode);
  sslEngine.setNeedClientAuth(true);
  if (clientMode) {
    sslEngine.beginHandshake();
    handshakeStatus=HandshakeStatus.NEED_WRAP;
  }
 else {
    sslEngine.beginHandshake();
    handshakeStatus=HandshakeStatus.NEED_UNWRAP;
  }
  handshakeComplete=false;
  shutdownInProgress=false;
  int netBufSize=sslEngine.getSession().getPacketBufferSize();
  inNetBuffer=BufferPool.allocate(netBufSize);
  inReadBuffer=BufferPool.allocate(sslEngine.getSession().getApplicationBufferSize() * 2);
  outNetBuffer=BufferPool.allocate(netBufSize);
  dummyBuffer=BufferPool.allocate(netBufSize);
  sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
  if (sslOptions.isAuthenticationWithoutEncryption()) {
    if (supportedCipherSuitesWithoutEncryption == null) {
      ArrayList<String> cipherSuites=new ArrayList<String>();
      for (      String cipherSuite : sslEngine.getSupportedCipherSuites()) {
        if (cipherSuite.contains(""String_Node_Str"")) {
          cipherSuites.add(cipherSuite);
        }
      }
      supportedCipherSuitesWithoutEncryption=new String[cipherSuites.size()];
      supportedCipherSuitesWithoutEncryption=cipherSuites.toArray(supportedCipherSuitesWithoutEncryption);
    }
    sslEngine.setEnabledCipherSuites(supportedCipherSuitesWithoutEncryption);
  }
 else {
    sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
  }
}",0.9989212513484358
113669,"/** 
 * {@inheritDoc}
 */
@Override public int read(ByteBuffer dst) throws IOException {
  int returnValue=0;
  if (!shutdownInProgress) {
    if (handshakeComplete) {
      if (inReadBuffer.remaining() == inReadBuffer.capacity()) {
        if (channel.read(inNetBuffer.getBuffer()) == -1) {
          throw new IOException(""String_Node_Str"");
        }
        inNetBuffer.flip();
        inDataAvail:         while (inNetBuffer.hasRemaining()) {
          SSLEngineResult result=sslEngine.unwrap(inNetBuffer.getBuffer(),inReadBuffer.getBuffer());
switch (result.getStatus()) {
case OK:
{
              if (sslEngine.isInboundDone()) {
                close();
              }
              break;
            }
case BUFFER_UNDERFLOW:
{
            inNetBuffer.compact();
            break inDataAvail;
          }
case BUFFER_OVERFLOW:
{
          throw new IOException(""String_Node_Str"");
        }
case CLOSED:
{
        throw new IOException(""String_Node_Str"");
      }
default :
{
      throw new IOException(""String_Node_Str"");
    }
}
}
inNetBuffer.compact();
}
inReadBuffer.flip();
while (inReadBuffer.hasRemaining() && dst.hasRemaining()) {
dst.put(inReadBuffer.get());
returnValue++;
}
inReadBuffer.compact();
}
}
return returnValue;
}","/** 
 * {@inheritDoc}
 */
@Override public int read(ByteBuffer dst) throws IOException {
  int returnValue=0;
  if (!shutdownInProgress) {
    if (handshakeComplete) {
      if (inReadBuffer.remaining() == inReadBuffer.capacity()) {
        if (channel.read(inNetBuffer.getBuffer()) == -1) {
          return -1;
        }
        inNetBuffer.flip();
        inDataAvail:         while (inNetBuffer.hasRemaining()) {
          SSLEngineResult result=sslEngine.unwrap(inNetBuffer.getBuffer(),inReadBuffer.getBuffer());
switch (result.getStatus()) {
case OK:
{
              if (sslEngine.isInboundDone()) {
                close();
              }
              break;
            }
case BUFFER_UNDERFLOW:
{
            break inDataAvail;
          }
case BUFFER_OVERFLOW:
{
          throw new IOException(""String_Node_Str"");
        }
case CLOSED:
{
        throw new IOException(""String_Node_Str"");
      }
default :
{
      throw new IOException(""String_Node_Str"");
    }
}
}
inNetBuffer.compact();
}
inReadBuffer.flip();
while (inReadBuffer.hasRemaining() && dst.hasRemaining()) {
dst.put(inReadBuffer.get());
returnValue++;
}
inReadBuffer.compact();
}
}
return returnValue;
}",0.9653751030502884
113670,"public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getOperationNumber()) {
case 1:
    return new accessRequest();
case 2:
  return new chmodRequest();
case 3:
return new chownRequest();
case 4:
return new createRequest();
case 5:
return new getattrRequest();
case 6:
return new getxattrRequest();
case 7:
return new linkRequest();
case 8:
return new listxattrRequest();
case 9:
return new mkdirRequest();
case 11:
return new openRequest();
case 12:
return new readdirRequest();
case 13:
return new removexattrRequest();
case 14:
return new renameRequest();
case 15:
return new rmdirRequest();
case 17:
return new setattrRequest();
case 18:
return new setxattrRequest();
case 19:
return new statfsRequest();
case 20:
return new symlinkRequest();
case 21:
return new unlinkRequest();
case 22:
return new utimeRequest();
case 30:
return new ftruncateRequest();
case 51:
return new xtreemfs_checkpointRequest();
case 23:
return new xtreemfs_check_file_existsRequest();
case 52:
return new xtreemfs_dump_databaseRequest();
case 24:
return new xtreemfs_get_suitable_osdsRequest();
case 10:
return new xtreemfs_mkvolRequest();
case 25:
return new xtreemfs_renew_capabilityRequest();
case 26:
return new xtreemfs_replica_addRequest();
case 27:
return new xtreemfs_replica_removeRequest();
case 53:
return new xtreemfs_restore_databaseRequest();
case 28:
return new xtreemfs_restore_fileRequest();
case 16:
return new xtreemfs_rmvolRequest();
case 50:
return new xtreemfs_shutdownRequest();
case 29:
return new xtreemfs_update_file_sizeRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getOperationNumber()));
}
}","public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getOperationNumber()) {
case 1:
    return new accessRequest();
case 2:
  return new chmodRequest();
case 3:
return new chownRequest();
case 4:
return new createRequest();
case 30:
return new ftruncateRequest();
case 5:
return new getattrRequest();
case 6:
return new getxattrRequest();
case 7:
return new linkRequest();
case 8:
return new listxattrRequest();
case 9:
return new mkdirRequest();
case 11:
return new openRequest();
case 12:
return new readdirRequest();
case 13:
return new removexattrRequest();
case 14:
return new renameRequest();
case 15:
return new rmdirRequest();
case 17:
return new setattrRequest();
case 18:
return new setxattrRequest();
case 19:
return new statfsRequest();
case 20:
return new symlinkRequest();
case 21:
return new unlinkRequest();
case 22:
return new utimeRequest();
case 51:
return new xtreemfs_checkpointRequest();
case 23:
return new xtreemfs_check_file_existsRequest();
case 52:
return new xtreemfs_dump_databaseRequest();
case 24:
return new xtreemfs_get_suitable_osdsRequest();
case 10:
return new xtreemfs_mkvolRequest();
case 25:
return new xtreemfs_renew_capabilityRequest();
case 26:
return new xtreemfs_replica_addRequest();
case 27:
return new xtreemfs_replica_removeRequest();
case 53:
return new xtreemfs_restore_databaseRequest();
case 28:
return new xtreemfs_restore_fileRequest();
case 16:
return new xtreemfs_rmvolRequest();
case 50:
return new xtreemfs_shutdownRequest();
case 29:
return new xtreemfs_update_file_sizeRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getOperationNumber()));
}
}",0.97628927089508
113671,"public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 1:
    return new accessResponse();
case 2:
  return new chmodResponse();
case 3:
return new chownResponse();
case 4:
return new createResponse();
case 5:
return new getattrResponse();
case 6:
return new getxattrResponse();
case 7:
return new linkResponse();
case 8:
return new listxattrResponse();
case 9:
return new mkdirResponse();
case 11:
return new openResponse();
case 12:
return new readdirResponse();
case 13:
return new removexattrResponse();
case 14:
return new renameResponse();
case 15:
return new rmdirResponse();
case 17:
return new setattrResponse();
case 18:
return new setxattrResponse();
case 19:
return new statfsResponse();
case 20:
return new symlinkResponse();
case 21:
return new unlinkResponse();
case 22:
return new utimeResponse();
case 30:
return new ftruncateResponse();
case 51:
return new xtreemfs_checkpointResponse();
case 23:
return new xtreemfs_check_file_existsResponse();
case 52:
return new xtreemfs_dump_databaseResponse();
case 24:
return new xtreemfs_get_suitable_osdsResponse();
case 10:
return new xtreemfs_mkvolResponse();
case 25:
return new xtreemfs_renew_capabilityResponse();
case 26:
return new xtreemfs_replica_addResponse();
case 27:
return new xtreemfs_replica_removeResponse();
case 53:
return new xtreemfs_restore_databaseResponse();
case 28:
return new xtreemfs_restore_fileResponse();
case 16:
return new xtreemfs_rmvolResponse();
case 50:
return new xtreemfs_shutdownResponse();
case 29:
return new xtreemfs_update_file_sizeResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}","public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 1:
    return new accessResponse();
case 2:
  return new chmodResponse();
case 3:
return new chownResponse();
case 4:
return new createResponse();
case 30:
return new ftruncateResponse();
case 5:
return new getattrResponse();
case 6:
return new getxattrResponse();
case 7:
return new linkResponse();
case 8:
return new listxattrResponse();
case 9:
return new mkdirResponse();
case 11:
return new openResponse();
case 12:
return new readdirResponse();
case 13:
return new removexattrResponse();
case 14:
return new renameResponse();
case 15:
return new rmdirResponse();
case 17:
return new setattrResponse();
case 18:
return new setxattrResponse();
case 19:
return new statfsResponse();
case 20:
return new symlinkResponse();
case 21:
return new unlinkResponse();
case 22:
return new utimeResponse();
case 51:
return new xtreemfs_checkpointResponse();
case 23:
return new xtreemfs_check_file_existsResponse();
case 52:
return new xtreemfs_dump_databaseResponse();
case 24:
return new xtreemfs_get_suitable_osdsResponse();
case 10:
return new xtreemfs_mkvolResponse();
case 25:
return new xtreemfs_renew_capabilityResponse();
case 26:
return new xtreemfs_replica_addResponse();
case 27:
return new xtreemfs_replica_removeResponse();
case 53:
return new xtreemfs_restore_databaseResponse();
case 28:
return new xtreemfs_restore_fileResponse();
case 16:
return new xtreemfs_rmvolResponse();
case 50:
return new xtreemfs_shutdownResponse();
case 29:
return new xtreemfs_update_file_sizeResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}",0.9758823529411764
113672,"public void serialize(ONCRPCBufferWriter writer){
  write_cap.serialize(writer);
}","public void serialize(ONCRPCBufferWriter writer){
  write_xcap.serialize(writer);
}",0.993939393939394
113673,"public ftruncateRequest(Object[] from_array){
  write_cap=new XCap();
  this.deserialize(from_array);
}","public ftruncateRequest(Object[] from_array){
  write_xcap=new XCap();
  this.deserialize(from_array);
}",0.9951690821256038
113674,"public String toString(){
  return ""String_Node_Str"" + write_cap.toString() + ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + write_xcap.toString() + ""String_Node_Str"";
}",0.9949238578680204
113675,"public void deserialize(ReusableBuffer buf){
  write_cap=new XCap();
  write_cap.deserialize(buf);
}","public void deserialize(ReusableBuffer buf){
  write_xcap=new XCap();
  write_xcap.deserialize(buf);
}",0.99009900990099
113676,"public int calculateSize(){
  int my_size=0;
  my_size+=write_cap.calculateSize();
  return my_size;
}","public int calculateSize(){
  int my_size=0;
  my_size+=write_xcap.calculateSize();
  return my_size;
}",0.9951219512195122
113677,"public void serialize(ONCRPCBufferWriter writer){
  truncate_cap.serialize(writer);
}","public void serialize(ONCRPCBufferWriter writer){
  truncate_xcap.serialize(writer);
}",0.9941520467836256
113678,"public ftruncateResponse(Object[] from_array){
  truncate_cap=new XCap();
  this.deserialize(from_array);
}","public ftruncateResponse(Object[] from_array){
  truncate_xcap=new XCap();
  this.deserialize(from_array);
}",0.9953488372093025
113679,"public String toString(){
  return ""String_Node_Str"" + truncate_cap.toString() + ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + truncate_xcap.toString() + ""String_Node_Str"";
}",0.9950738916256158
113680,"public void deserialize(ReusableBuffer buf){
  truncate_cap=new XCap();
  truncate_cap.deserialize(buf);
}","public void deserialize(ReusableBuffer buf){
  truncate_xcap=new XCap();
  truncate_xcap.deserialize(buf);
}",0.9906542056074766
113681,"public int calculateSize(){
  int my_size=0;
  my_size+=truncate_cap.calculateSize();
  return my_size;
}","public int calculateSize(){
  int my_size=0;
  my_size+=truncate_xcap.calculateSize();
  return my_size;
}",0.995260663507109
113682,"public void serialize(ONCRPCBufferWriter writer){
  org.xtreemfs.interfaces.utils.XDRUtils.serializeString(returnValue,writer);
}","public void serialize(ONCRPCBufferWriter writer){
  org.xtreemfs.interfaces.utils.XDRUtils.serializeString(value,writer);
}",0.9682539682539684
113683,"public getxattrResponse(Object[] from_array){
  returnValue=""String_Node_Str"";
  this.deserialize(from_array);
}","public getxattrResponse(Object[] from_array){
  value=""String_Node_Str"";
  this.deserialize(from_array);
}",0.963302752293578
113684,"public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + returnValue + ""String_Node_Str""+ ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str"";
}",0.968
113685,"public void deserialize(ReusableBuffer buf){
  returnValue=org.xtreemfs.interfaces.utils.XDRUtils.deserializeString(buf);
}","public void deserialize(ReusableBuffer buf){
  value=org.xtreemfs.interfaces.utils.XDRUtils.deserializeString(buf);
}",0.9666666666666668
113686,"public int calculateSize(){
  int my_size=0;
  my_size+=org.xtreemfs.interfaces.utils.XDRUtils.stringLengthPadded(returnValue);
  return my_size;
}","public int calculateSize(){
  int my_size=0;
  my_size+=org.xtreemfs.interfaces.utils.XDRUtils.stringLengthPadded(value);
  return my_size;
}",0.9722222222222222
113687,"public readResponse(Object[] from_array){
  returnValue=new ObjectData();
  this.deserialize(from_array);
}","public readResponse(Object[] from_array){
  object_data=new ObjectData();
  this.deserialize(from_array);
}",0.9252336448598132
113688,"public void serialize(ONCRPCBufferWriter writer){
  returnValue.serialize(writer);
}","public void serialize(ONCRPCBufferWriter writer){
  object_data.serialize(writer);
}",0.9047619047619048
113689,"public String toString(){
  return ""String_Node_Str"" + returnValue.toString() + ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + object_data.toString() + ""String_Node_Str"";
}",0.92
113690,"public void deserialize(ReusableBuffer buf){
  returnValue=new ObjectData();
  returnValue.deserialize(buf);
}","public void deserialize(ReusableBuffer buf){
  object_data=new ObjectData();
  object_data.deserialize(buf);
}",0.8545454545454545
113691,"public int calculateSize(){
  int my_size=0;
  my_size+=returnValue.calculateSize();
  return my_size;
}","public int calculateSize(){
  int my_size=0;
  my_size+=object_data.calculateSize();
  return my_size;
}",0.9230769230769232
113692,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_addRequest rqArgs=(xtreemfs_replica_addRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    Replica newRepl=rqArgs.getNew_replica();
    org.xtreemfs.interfaces.StripingPolicy sp=newRepl.getStriping_policy();
    StringSet osds=newRepl.getOsd_uuids();
    StripingPolicy sPol=sMan.createStripingPolicy(Converter.intToPolicyName(sp.getPolicy()),sp.getStripe_size(),sp.getWidth());
    if (!file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    if (!MRCHelper.isAddable(xLocList,newRepl.getOsd_uuids()))     throw new UserException(""String_Node_Str"" + Converter.xLocListToXLocSet(xLocList).toString() + ""String_Node_Str"");
    XLoc replica=sMan.createXLoc(sPol,osds.toArray(new String[osds.size()]));
    if (xLocList == null)     xLocList=sMan.createXLocList(new XLoc[]{replica},1);
 else {
      XLoc[] repls=new XLoc[xLocList.getReplicaCount() + 1];
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls[i]=xLocList.getReplica(i);
      repls[repls.length - 1]=replica;
      xLocList=sMan.createXLocList(repls,xLocList.getVersion() + 1);
    }
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_replica_addResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_addRequest rqArgs=(xtreemfs_replica_addRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    Replica newRepl=rqArgs.getNew_replica();
    org.xtreemfs.interfaces.StripingPolicy sp=newRepl.getStriping_policy();
    StringSet osds=newRepl.getOsd_uuids();
    StripingPolicy sPol=sMan.createStripingPolicy(Converter.intToPolicyName(sp.getPolicy()),sp.getStripe_size(),sp.getWidth());
    if (!file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    if (!MRCHelper.isAddable(xLocList,newRepl.getOsd_uuids()))     throw new UserException(""String_Node_Str"" + Converter.xLocListToXLocSet(xLocList).toString() + ""String_Node_Str"");
    XLoc replica=sMan.createXLoc(sPol,osds.toArray(new String[osds.size()]));
    if (xLocList == null)     xLocList=sMan.createXLocList(new XLoc[]{replica},1);
 else {
      XLoc[] repls=new XLoc[xLocList.getReplicaCount() + 1];
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls[i]=xLocList.getReplica(i);
      repls[repls.length - 1]=replica;
      xLocList=sMan.createXLocList(repls,xLocList.getVersion() + 1);
    }
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_replica_addResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9972290640394088
113693,"@Override public void startRequest(MRCRequest rq){
  try {
    final chmodRequest rqArgs=(chmodRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    faMan.setPosixAccessMode(sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().groupIds,rqArgs.getMode(),update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new chmodResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final chmodRequest rqArgs=(chmodRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    faMan.setPosixAccessMode(sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().groupIds,rqArgs.getMode(),update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new chmodResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9954128440366972
113694,"@Override public void startRequest(MRCRequest rq){
  try {
    final chownRequest rqArgs=(chownRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (rqArgs.getUser_id() != null) {
      if (!rq.getDetails().superUser)       throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    }
 else     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.getUser_id() == null ? file.getOwnerId() : rqArgs.getUser_id(),rqArgs.getGroup_id() == null ? file.getOwningGroupId() : rqArgs.getGroup_id());
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new chownResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final chownRequest rqArgs=(chownRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (rqArgs.getUser_id() != null) {
      if (!rq.getDetails().superUser)       throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    }
 else     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.getUser_id() == null ? file.getOwnerId() : rqArgs.getUser_id(),rqArgs.getGroup_id() == null ? file.getOwningGroupId() : rqArgs.getGroup_id());
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new chownResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9959386281588448
113695,"@Override public void startRequest(MRCRequest rq){
  try {
    final accessRequest rqArgs=(accessRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    boolean success=false;
    try {
      faMan.checkPermission(rqArgs.getMode(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      success=true;
    }
 catch (    UserException exc) {
    }
    rq.setResponse(new accessResponse(success));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final accessRequest rqArgs=(accessRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    boolean success=false;
    try {
      faMan.checkPermission(rqArgs.getMode(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      success=true;
    }
 catch (    UserException exc) {
    }
    rq.setResponse(new accessResponse(success));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9932835820895524
113696,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_check_file_existsRequest rqArgs=(xtreemfs_check_file_existsRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    StorageManager sMan=vMan.getStorageManager(rqArgs.getVolume_id());
    String response=sMan == null ? ""String_Node_Str"" : ""String_Node_Str"";
    if (sMan != null)     try {
      if (rqArgs.getFile_ids().size() == 0)       throw new UserException(""String_Node_Str"");
      for (      String fileId : rqArgs.getFile_ids()) {
        if (fileId == null)         throw new MRCException(""String_Node_Str"");
        response+=sMan.getMetadata(Long.parseLong(fileId)) != null ? ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
 catch (    UserException ue) {
      response=""String_Node_Str"";
    }
catch (    MRCException be) {
      throw new MRCException(""String_Node_Str"" + be.getMessage());
    }
    rq.setResponse(new xtreemfs_check_file_existsResponse(response));
    finishRequest(rq);
  }
 catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_check_file_existsRequest rqArgs=(xtreemfs_check_file_existsRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    StorageManager sMan=vMan.getStorageManager(rqArgs.getVolume_id());
    String response=sMan == null ? ""String_Node_Str"" : ""String_Node_Str"";
    if (sMan != null)     try {
      if (rqArgs.getFile_ids().size() == 0)       throw new UserException(""String_Node_Str"");
      for (      String fileId : rqArgs.getFile_ids()) {
        if (fileId == null)         throw new MRCException(""String_Node_Str"");
        response+=sMan.getMetadata(Long.parseLong(fileId)) != null ? ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
 catch (    UserException ue) {
      response=""String_Node_Str"";
    }
catch (    MRCException be) {
      throw new MRCException(""String_Node_Str"" + be.getMessage());
    }
    rq.setResponse(new xtreemfs_check_file_existsResponse(response));
    finishRequest(rq);
  }
 catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9921739130434782
113697,"@Override public void startRequest(MRCRequest rq){
  try {
    master.getVolumeManager().checkpointDB();
    rq.setResponse(new xtreemfs_checkpointResponse());
    finishRequest(rq);
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    master.requestFailed(rq,ex);
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    master.getVolumeManager().checkpointDB();
    rq.setResponse(new xtreemfs_checkpointResponse());
    finishRequest(rq);
  }
 catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.6763754045307443
113698,"@Override public void startRequest(MRCRequest rq){
  try {
    final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new mkdirResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final mkdirRequest rqArgs=(mkdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new mkdirResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9946364719904648
113699,"@Override public void startRequest(MRCRequest rq){
  try {
    final createRequest rqArgs=(createRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    rq.setResponse(new createResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final createRequest rqArgs=(createRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    rq.setResponse(new createResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9943396226415094
113700,"@Override public void startRequest(MRCRequest rq){
  try {
    final linkRequest rqArgs=(linkRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path lp=new Path(rqArgs.getLink_path());
    final Path tp=new Path(rqArgs.getTarget_path());
    if (!lp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.EXDEV,""String_Node_Str"");
    final VolumeInfo volume=vMan.getVolumeByName(lp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver lRes=new PathResolver(sMan,lp);
    final PathResolver tRes=new PathResolver(sMan,tp);
    faMan.checkSearchPermission(sMan,lRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,lRes.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    lRes.checkIfFileExistsAlready();
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    tRes.checkIfFileDoesNotExist();
    FileMetadata target=tRes.getFile();
    if (target.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.link(target,lRes.getParentDirId(),lRes.getFileName(),update);
    MRCHelper.updateFileTimes(lRes.getParentsParentId(),lRes.getParentDir(),false,true,true,sMan,update);
    MRCHelper.updateFileTimes(tRes.getParentDirId(),target,false,true,false,sMan,update);
    rq.setResponse(new linkResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final linkRequest rqArgs=(linkRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path lp=new Path(rqArgs.getLink_path());
    final Path tp=new Path(rqArgs.getTarget_path());
    if (!lp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.EXDEV,""String_Node_Str"");
    final VolumeInfo volume=vMan.getVolumeByName(lp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver lRes=new PathResolver(sMan,lp);
    final PathResolver tRes=new PathResolver(sMan,tp);
    faMan.checkSearchPermission(sMan,lRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,lRes.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    lRes.checkIfFileExistsAlready();
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    tRes.checkIfFileDoesNotExist();
    FileMetadata target=tRes.getFile();
    if (target.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.link(target,lRes.getParentDirId(),lRes.getFileName(),update);
    MRCHelper.updateFileTimes(lRes.getParentsParentId(),lRes.getParentDir(),false,true,true,sMan,update);
    MRCHelper.updateFileTimes(tRes.getParentDirId(),target,false,true,false,sMan,update);
    rq.setResponse(new linkResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9958997722095672
113701,"@Override public void startRequest(MRCRequest rq){
  try {
    final symlinkRequest rqArgs=(symlinkRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getLink_path());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long fileId=sMan.getNextFileId();
    sMan.createSymLink(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getTarget_path(),update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new symlinkResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final symlinkRequest rqArgs=(symlinkRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getLink_path());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long fileId=sMan.getNextFileId();
    sMan.createSymLink(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getTarget_path(),update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setResponse(new symlinkResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9946268656716418
113702,"private void processStep2(final xtreemfs_mkvolRequest rqArgs,final String volumeId,final MRCRequest rq,RPCResponse<ServiceSet> rpcResponse){
  try {
    ServiceSet response=rpcResponse.get();
    for (    Service reg : response)     if (rqArgs.getVolume_name().equals(reg.getName())) {
      String uuid=reg.getUuid();
      throw new UserException(ErrNo.EEXIST,""String_Node_Str"" + rqArgs.getVolume_name() + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
    }
    ServiceDataMap dmap=new ServiceDataMap();
    dmap.put(""String_Node_Str"",master.getConfig().getUUID().toString());
    dmap.put(""String_Node_Str"",""String_Node_Str"");
    Service vol=new Service(volumeId,0,Constants.SERVICE_TYPE_VOLUME,rqArgs.getVolume_name(),0,dmap);
    RPCResponse<Long> rpcResponse2=master.getDirClient().xtreemfs_service_register(null,vol);
    rpcResponse2.registerListener(new RPCResponseAvailableListener<Long>(){
      @Override public void responseAvailable(      RPCResponse<Long> r){
        processStep3(rqArgs,volumeId,rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}","private void processStep2(final xtreemfs_mkvolRequest rqArgs,final String volumeId,final MRCRequest rq,RPCResponse<ServiceSet> rpcResponse){
  try {
    ServiceSet response=rpcResponse.get();
    for (    Service reg : response)     if (rqArgs.getVolume_name().equals(reg.getName())) {
      String uuid=reg.getUuid();
      throw new UserException(ErrNo.EEXIST,""String_Node_Str"" + rqArgs.getVolume_name() + ""String_Node_Str""+ uuid+ ""String_Node_Str"");
    }
    ServiceDataMap dmap=new ServiceDataMap();
    dmap.put(""String_Node_Str"",master.getConfig().getUUID().toString());
    dmap.put(""String_Node_Str"",""String_Node_Str"");
    Service vol=new Service(volumeId,0,Constants.SERVICE_TYPE_VOLUME,rqArgs.getVolume_name(),0,dmap);
    RPCResponse<Long> rpcResponse2=master.getDirClient().xtreemfs_service_register(null,vol);
    rpcResponse2.registerListener(new RPCResponseAvailableListener<Long>(){
      @Override public void responseAvailable(      RPCResponse<Long> r){
        processStep3(rqArgs,volumeId,rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}",0.993585174625802
113703,"@Override public void startRequest(final MRCRequest rq){
  try {
    final xtreemfs_mkvolRequest rqArgs=(xtreemfs_mkvolRequest)rq.getRequestArgs();
    validateContext(rq);
    if (master.getOSDStatusManager().getOSDSelectionPolicy((short)rqArgs.getOsd_selection_policy()) == null)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.getOsd_selection_policy());
    if (master.getFileAccessManager().getFileAccessPolicy((short)rqArgs.getAccess_control_policy()) == null)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.getAccess_control_policy());
    final String volumeId=master.getVolumeManager().newVolumeId();
    Map<String,Object> queryMap=new HashMap<String,Object>();
    queryMap.put(""String_Node_Str"",rqArgs.getVolume_name());
    List<String> attrs=new LinkedList<String>();
    attrs.add(""String_Node_Str"");
    RPCResponse<ServiceSet> response=master.getDirClient().xtreemfs_service_get_by_type(null,Constants.SERVICE_TYPE_VOLUME);
    response.registerListener(new RPCResponseAvailableListener<ServiceSet>(){
      @Override public void responseAvailable(      RPCResponse<ServiceSet> r){
        processStep2(rqArgs,volumeId,rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(final MRCRequest rq){
  try {
    final xtreemfs_mkvolRequest rqArgs=(xtreemfs_mkvolRequest)rq.getRequestArgs();
    validateContext(rq);
    if (master.getOSDStatusManager().getOSDSelectionPolicy((short)rqArgs.getOsd_selection_policy()) == null)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.getOsd_selection_policy());
    if (master.getFileAccessManager().getFileAccessPolicy((short)rqArgs.getAccess_control_policy()) == null)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.getAccess_control_policy());
    final String volumeId=master.getVolumeManager().newVolumeId();
    Map<String,Object> queryMap=new HashMap<String,Object>();
    queryMap.put(""String_Node_Str"",rqArgs.getVolume_name());
    List<String> attrs=new LinkedList<String>();
    attrs.add(""String_Node_Str"");
    RPCResponse<ServiceSet> response=master.getDirClient().xtreemfs_service_get_by_type(null,Constants.SERVICE_TYPE_VOLUME);
    response.registerListener(new RPCResponseAvailableListener<ServiceSet>(){
      @Override public void responseAvailable(      RPCResponse<ServiceSet> r){
        processStep2(rqArgs,volumeId,rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9940867279894876
113704,"public void processStep3(final xtreemfs_mkvolRequest rqArgs,final String volumeId,final MRCRequest rq,RPCResponse<Long> rpcResponse){
  try {
    rpcResponse.get();
    master.getVolumeManager().createVolume(master.getFileAccessManager(),volumeId,rqArgs.getVolume_name(),(short)rqArgs.getAccess_control_policy(),(short)rqArgs.getOsd_selection_policy(),null,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getDefault_striping_policy());
    rq.setResponse(new xtreemfs_mkvolResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}","public void processStep3(final xtreemfs_mkvolRequest rqArgs,final String volumeId,final MRCRequest rq,RPCResponse<Long> rpcResponse){
  try {
    rpcResponse.get();
    master.getVolumeManager().createVolume(master.getFileAccessManager(),volumeId,rqArgs.getVolume_name(),(short)rqArgs.getAccess_control_policy(),(short)rqArgs.getOsd_selection_policy(),null,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getDefault_striping_policy());
    rq.setResponse(new xtreemfs_mkvolResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}",0.9898876404494382
113705,"@Override public void startRequest(MRCRequest rq){
  try {
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rq.getRequestArgs() instanceof unlinkRequest ? ((unlinkRequest)rq.getRequestArgs()).getPath() : ((rmdirRequest)rq.getRequestArgs()).getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    FileCredentialsSet creds=new FileCredentialsSet();
    if (!file.isDirectory()) {
      Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),file.getEpoch(),master.getConfig().getCapabilitySecret());
      XLocList xloc=file.getXLocList();
      if (xloc != null && xloc.getReplicaCount() > 0)       creds.add(new FileCredentials(Converter.xLocListToXLocSet(xloc),cap.getXCap()));
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     creds.clear();
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (file.getLinkCount() > 1)     MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new unlinkResponse(creds));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rq.getRequestArgs() instanceof unlinkRequest ? ((unlinkRequest)rq.getRequestArgs()).getPath() : ((rmdirRequest)rq.getRequestArgs()).getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    FileCredentialsSet creds=new FileCredentialsSet();
    if (!file.isDirectory()) {
      Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),file.getEpoch(),master.getConfig().getCapabilitySecret());
      XLocList xloc=file.getXLocList();
      if (xloc != null && xloc.getReplicaCount() > 0)       creds.add(new FileCredentials(Converter.xLocListToXLocSet(xloc),cap.getXCap()));
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     creds.clear();
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (file.getLinkCount() > 1)     MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new unlinkResponse(creds));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9965317919075144
113706,"private void processStep2(xtreemfs_rmvolRequest rqArgs,final String volumeId,final MRCRequest rq,final RPCResponse rpcResponse){
  try {
    rpcResponse.get();
    master.getVolumeManager().deleteVolume(volumeId,master,rq);
    rq.setResponse(new xtreemfs_rmvolResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}","private void processStep2(xtreemfs_rmvolRequest rqArgs,final String volumeId,final MRCRequest rq,final RPCResponse rpcResponse){
  try {
    rpcResponse.get();
    master.getVolumeManager().deleteVolume(volumeId,master,rq);
    rq.setResponse(new xtreemfs_rmvolResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
 finally {
    rpcResponse.freeBuffers();
  }
}",0.9864457831325302
113707,"@Override public void startRequest(final MRCRequest rq){
  try {
    final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
    final VolumeInfo volume=master.getVolumeManager().getVolumeByName(rqArgs.getVolume_name());
    final StorageManager sMan=master.getVolumeManager().getStorageManager(volume.getId());
    FileMetadata file=sMan.getMetadata(0,volume.getName());
    master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    RPCResponse response=master.getDirClient().xtreemfs_service_deregister(null,volume.getId());
    response.registerListener(new RPCResponseAvailableListener(){
      @Override public void responseAvailable(      RPCResponse r){
        processStep2(rqArgs,volume.getId(),rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(final MRCRequest rq){
  try {
    final xtreemfs_rmvolRequest rqArgs=(xtreemfs_rmvolRequest)rq.getRequestArgs();
    final VolumeInfo volume=master.getVolumeManager().getVolumeByName(rqArgs.getVolume_name());
    final StorageManager sMan=master.getVolumeManager().getStorageManager(volume.getId());
    FileMetadata file=sMan.getMetadata(0,volume.getName());
    master.getFileAccessManager().checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    RPCResponse response=master.getDirClient().xtreemfs_service_deregister(null,volume.getId());
    response.registerListener(new RPCResponseAvailableListener(){
      @Override public void responseAvailable(      RPCResponse r){
        processStep2(rqArgs,volume.getId(),rq,r);
      }
    }
);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.992248062015504
113708,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_dump_databaseRequest rqArgs=(xtreemfs_dump_databaseRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    BufferedWriter xmlWriter=new BufferedWriter(new FileWriter(rqArgs.getDump_file()));
    xmlWriter.write(""String_Node_Str"");
    xmlWriter.write(""String_Node_Str"" + VersionManagement.getMrcDataVersion() + ""String_Node_Str"");
    for (    VolumeInfo volume : vMan.getVolumes()) {
      xmlWriter.write(""String_Node_Str"" + volume.getId() + ""String_Node_Str""+ volume.getName()+ ""String_Node_Str""+ volume.getAcPolicyId()+ ""String_Node_Str""+ volume.getOsdPolicyId()+ (volume.getOsdPolicyArgs() != null ? ""String_Node_Str"" + volume.getOsdPolicyArgs() : ""String_Node_Str"")+ ""String_Node_Str"");
      StorageManager sMan=vMan.getStorageManager(volume.getId());
      sMan.dumpDB(xmlWriter);
      xmlWriter.write(""String_Node_Str"");
    }
    xmlWriter.write(""String_Node_Str"");
    xmlWriter.close();
    rq.setResponse(new xtreemfs_dump_databaseResponse());
    finishRequest(rq);
  }
 catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_dump_databaseRequest rqArgs=(xtreemfs_dump_databaseRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    BufferedWriter xmlWriter=new BufferedWriter(new FileWriter(rqArgs.getDump_file()));
    xmlWriter.write(""String_Node_Str"");
    xmlWriter.write(""String_Node_Str"" + VersionManagement.getMrcDataVersion() + ""String_Node_Str"");
    for (    VolumeInfo volume : vMan.getVolumes()) {
      xmlWriter.write(""String_Node_Str"" + volume.getId() + ""String_Node_Str""+ volume.getName()+ ""String_Node_Str""+ volume.getAcPolicyId()+ ""String_Node_Str""+ volume.getOsdPolicyId()+ (volume.getOsdPolicyArgs() != null ? ""String_Node_Str"" + volume.getOsdPolicyArgs() : ""String_Node_Str"")+ ""String_Node_Str"");
      StorageManager sMan=vMan.getStorageManager(volume.getId());
      sMan.dumpDB(xmlWriter);
      xmlWriter.write(""String_Node_Str"");
    }
    xmlWriter.write(""String_Node_Str"");
    xmlWriter.close();
    rq.setResponse(new xtreemfs_dump_databaseResponse());
    finishRequest(rq);
  }
 catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9157808667211774
113709,"@Override public void startRequest(MRCRequest rq){
  try {
    Collection<VolumeInfo> volumes=master.getVolumeManager().getVolumes();
    Map<String,String> map=new HashMap<String,String>();
    for (    VolumeInfo data : volumes)     map.put(data.getId(),data.getName());
    finishRequest(rq);
  }
 catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Collection<VolumeInfo> volumes=master.getVolumeManager().getVolumes();
    Map<String,String> map=new HashMap<String,String>();
    for (    VolumeInfo data : volumes)     map.put(data.getId(),data.getName());
    finishRequest(rq);
  }
 catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9789227166276346
113710,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_get_suitable_osdsRequest rqArgs=(xtreemfs_get_suitable_osdsRequest)rq.getRequestArgs();
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    ServiceSet usableOSDs=master.getOSDStatusManager().getUsableOSDs(volumeId);
    StringSet uuids=new StringSet();
    for (int i=0; i < usableOSDs.calculateSize(); i++)     uuids.add(usableOSDs.get(i).getUuid());
    rq.setResponse(new xtreemfs_get_suitable_osdsResponse(uuids));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_get_suitable_osdsRequest rqArgs=(xtreemfs_get_suitable_osdsRequest)rq.getRequestArgs();
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    ServiceSet usableOSDs=master.getOSDStatusManager().getUsableOSDs(volumeId);
    StringSet uuids=new StringSet();
    for (int i=0; i < usableOSDs.calculateSize(); i++)     uuids.add(usableOSDs.get(i).getUuid());
    rq.setResponse(new xtreemfs_get_suitable_osdsResponse(uuids));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9917582417582418
113711,"@Override public void startRequest(MRCRequest rq){
  try {
    final getxattrRequest rqArgs=(getxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    String value=null;
    if (rqArgs.getName().startsWith(""String_Node_Str""))     value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,rqArgs.getName().substring(9));
 else {
      value=sMan.getXAttr(file.getId(),rq.getDetails().userId,rqArgs.getName());
      if (value == null)       value=sMan.getXAttr(file.getId(),StorageManager.GLOBAL_ID,rqArgs.getName());
      if (value == null)       value=""String_Node_Str"";
    }
    rq.setResponse(new getxattrResponse(value));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final getxattrRequest rqArgs=(getxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    String value=null;
    if (rqArgs.getName().startsWith(""String_Node_Str""))     value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,rqArgs.getName().substring(9));
 else {
      value=sMan.getXAttr(file.getId(),rq.getDetails().userId,rqArgs.getName());
      if (value == null)       value=sMan.getXAttr(file.getId(),StorageManager.GLOBAL_ID,rqArgs.getName());
      if (value == null)       value=""String_Node_Str"";
    }
    rq.setResponse(new getxattrResponse(value));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9956204379562044
113712,"@Override public void startRequest(MRCRequest rq){
  try {
    final listxattrRequest rqArgs=(listxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    HashSet<String> attrNames=new HashSet<String>();
    Iterator<XAttr> myAttrs=sMan.getXAttrs(file.getId(),rq.getDetails().userId);
    Iterator<XAttr> globalAttrs=sMan.getXAttrs(file.getId(),StorageManager.GLOBAL_ID);
    while (globalAttrs.hasNext())     attrNames.add(globalAttrs.next().getKey());
    while (myAttrs.hasNext())     attrNames.add(myAttrs.next().getKey());
    for (    SysAttrs attr : SysAttrs.values()) {
      String key=""String_Node_Str"" + attr.toString();
      Object value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,attr.toString());
      if (!value.equals(""String_Node_Str""))       attrNames.add(key);
    }
    StringSet names=new StringSet();
    Iterator<String> it=attrNames.iterator();
    while (it.hasNext())     names.add(it.next());
    rq.setResponse(new listxattrResponse(names));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final listxattrRequest rqArgs=(listxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    HashSet<String> attrNames=new HashSet<String>();
    Iterator<XAttr> myAttrs=sMan.getXAttrs(file.getId(),rq.getDetails().userId);
    Iterator<XAttr> globalAttrs=sMan.getXAttrs(file.getId(),StorageManager.GLOBAL_ID);
    while (globalAttrs.hasNext())     attrNames.add(globalAttrs.next().getKey());
    while (myAttrs.hasNext())     attrNames.add(myAttrs.next().getKey());
    for (    SysAttrs attr : SysAttrs.values()) {
      String key=""String_Node_Str"" + attr.toString();
      Object value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,attr.toString());
      if (!value.equals(""String_Node_Str""))       attrNames.add(key);
    }
    StringSet names=new StringSet();
    Iterator<String> it=attrNames.iterator();
    while (it.hasNext())     names.add(it.next());
    rq.setResponse(new listxattrResponse(names));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9953295277633628
113713,"@Override public void startRequest(MRCRequest rq){
  try {
    final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path sp=new Path(rqArgs.getSource_path());
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.getTarget_path());
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    FileCredentialsSet creds=new FileCredentialsSet();
    if (sp.equals(tp)) {
      rq.setResponse(new renameResponse(creds));
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
if (target.getLinkCount() == 1) {
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + target.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),target.getEpoch(),master.getConfig().getCapabilitySecret());
  creds.add(new FileCredentials(Converter.xLocListToXLocSet(target.getXLocList()),cap.getXCap()));
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setResponse(new renameResponse(creds));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Exception exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}","@Override public void startRequest(MRCRequest rq){
  try {
    final renameRequest rqArgs=(renameRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path sp=new Path(rqArgs.getSource_path());
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.getTarget_path());
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.NON_POSIX_RM_MV_IN_DIR,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    FileCredentialsSet creds=new FileCredentialsSet();
    if (sp.equals(tp)) {
      rq.setResponse(new renameResponse(creds));
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.NON_POSIX_DELETE,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
if (target.getLinkCount() == 1) {
  Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + target.getId(),FileAccessManager.NON_POSIX_DELETE,Integer.MAX_VALUE,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),target.getEpoch(),master.getConfig().getCapabilitySecret());
  creds.add(new FileCredentials(Converter.xLocListToXLocSet(target.getXLocList()),cap.getXCap()));
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setResponse(new renameResponse(creds));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Throwable exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}",0.99838622915546
113714,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9980206729711898
113715,"@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_H_S_IFLNK : child.isDirectory() ? Constants.SYSTEM_V_FCNTL_H_S_IFDIR : Constants.SYSTEM_V_FCNTL_H_S_IFREG;
      long size=linkTarget != null ? linkTarget.length() : child.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_H_S_IFLNK : child.isDirectory() ? Constants.SYSTEM_V_FCNTL_H_S_IFDIR : Constants.SYSTEM_V_FCNTL_H_S_IFREG;
      long size=linkTarget != null ? linkTarget.length() : child.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9969522519471724
113716,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    XLocList xLocList=file.getXLocList();
    int i=0;
    for (; i < xLocList.getReplicaCount(); i++) {
      XLoc replica=xLocList.getReplica(i);
      if (replica.getOSD(0).equals(rqArgs.getOsd_uuid()))       break;
    }
    XLoc[] newReplList=new XLoc[xLocList.getReplicaCount() - 1];
    for (int j=0, count=0; j < xLocList.getReplicaCount(); j++)     if (j != i)     newReplList[count++]=xLocList.getReplica(j);
    xLocList=sMan.createXLocList(newReplList,xLocList.getVersion() + 1);
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_replica_removeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_replica_removeRequest rqArgs=(xtreemfs_replica_removeRequest)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    validateContext(rq);
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    XLocList xLocList=file.getXLocList();
    int i=0;
    for (; i < xLocList.getReplicaCount(); i++) {
      XLoc replica=xLocList.getReplica(i);
      if (replica.getOSD(0).equals(rqArgs.getOsd_uuid()))       break;
    }
    XLoc[] newReplList=new XLoc[xLocList.getReplicaCount() - 1];
    for (int j=0, count=0; j < xLocList.getReplicaCount(); j++)     if (j != i)     newReplList[count++]=xLocList.getReplica(j);
    xLocList=sMan.createXLocList(newReplList,xLocList.getVersion() + 1);
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_replica_removeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9966728280961183
113717,"@Override public void startRequest(MRCRequest rq){
  try {
    final removexattrRequest rqArgs=(removexattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    validateContext(rq);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    final String attrKey=rqArgs.getName();
    if (attrKey.startsWith(""String_Node_Str"")) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      MRCHelper.setSysAttrValue(sMan,vMan,volume,res.getParentDirId(),file,attrKey.substring(9),""String_Node_Str"",update);
    }
 else {
      sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,null,update);
    }
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new removexattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final removexattrRequest rqArgs=(removexattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    validateContext(rq);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    final String attrKey=rqArgs.getName();
    if (attrKey.startsWith(""String_Node_Str"")) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      MRCHelper.setSysAttrValue(sMan,vMan,volume,res.getParentDirId(),file,attrKey.substring(9),""String_Node_Str"",update);
    }
 else {
      sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,null,update);
    }
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new removexattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.995835261453031
113718,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_renew_capabilityRequest rqArgs=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
    Capability cap=new Capability(rqArgs.getOld_xcap(),master.getConfig().getCapabilitySecret());
    if (!cap.hasValidSignature())     throw new UserException(cap + ""String_Node_Str"");
    if (cap.hasExpired())     throw new UserException(cap + ""String_Node_Str"");
    Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,cap.getClientIdentity(),cap.getEpochNo(),master.getConfig().getCapabilitySecret());
    rq.setResponse(new xtreemfs_renew_capabilityResponse(newCap.getXCap()));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_renew_capabilityRequest rqArgs=(xtreemfs_renew_capabilityRequest)rq.getRequestArgs();
    Capability cap=new Capability(rqArgs.getOld_xcap(),master.getConfig().getCapabilitySecret());
    if (!cap.hasValidSignature())     throw new UserException(cap + ""String_Node_Str"");
    if (cap.hasExpired())     throw new UserException(cap + ""String_Node_Str"");
    Capability newCap=new Capability(cap.getFileId(),cap.getAccessMode(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,cap.getClientIdentity(),cap.getEpochNo(),master.getConfig().getCapabilitySecret());
    rq.setResponse(new xtreemfs_renew_capabilityResponse(newCap.getXCap()));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.991588785046729
113719,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_restore_databaseRequest rqArgs=(xtreemfs_restore_databaseRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    if (vMan.getVolumes().size() != 0)     throw new UserException(""String_Node_Str"");
    SAXParserFactory spf=SAXParserFactory.newInstance();
    SAXParser sp=spf.newSAXParser();
    sp.parse(new File(rqArgs.getDump_file()),new DefaultHandler(){
      private DBRestoreState state;
      private int dbVersion=1;
      public void startElement(      String uri,      String localName,      String qName,      Attributes attributes) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"")) {
            final String id=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            final String name=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            final short acPol=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
            final short osdPol=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
            final String osdPolArgs=attributes.getIndex(""String_Node_Str"") == -1 ? null : attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state=new DBRestoreState();
            state.currentVolume=new VolumeInfo(){
              public short getAcPolicyId(){
                return acPol;
              }
              public String getId(){
                return id;
              }
              public String getName(){
                return name;
              }
              public String getOsdPolicyArgs(){
                return osdPolArgs;
              }
              public short getOsdPolicyId(){
                return osdPol;
              }
              public void setOsdPolicyArgs(              String osdPolicyArgs){
              }
              public void setOsdPolicyId(              short osdPolicyId){
              }
            }
;
          }
 else           if (qName.equals(""String_Node_Str""))           try {
            dbVersion=Integer.parseInt(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 catch (          Exception exc) {
            Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"");
          }
 else           handleNestedElement(qName,attributes,true);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
          throw new SAXException(exc);
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"") || qName.equals(""String_Node_Str""))           return;
          handleNestedElement(qName,null,false);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
          throw new SAXException(exc);
        }
      }
      private void handleNestedElement(      String qName,      Attributes attributes,      boolean openTag) throws UserException, DatabaseException {
        if (qName.equals(""String_Node_Str"")) {
          StorageManager sMan=vMan.getStorageManager(state.currentVolume.getId());
          AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
          sMan.setLastFileId(state.largestFileId,update);
          update.execute();
          state.largestFileId=0;
        }
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
      }
    }
);
    rq.setResponse(new xtreemfs_restore_databaseResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getMessage(),exc));
  }
catch (  SAXException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getException().getMessage() == null ? ""String_Node_Str"" : exc.getException().getMessage(),exc.getException()));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,exc.getMessage() == null ? ""String_Node_Str"" : exc.getMessage(),exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_restore_databaseRequest rqArgs=(xtreemfs_restore_databaseRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    if (vMan.getVolumes().size() != 0)     throw new UserException(""String_Node_Str"");
    SAXParserFactory spf=SAXParserFactory.newInstance();
    SAXParser sp=spf.newSAXParser();
    sp.parse(new File(rqArgs.getDump_file()),new DefaultHandler(){
      private DBRestoreState state;
      private int dbVersion=1;
      public void startElement(      String uri,      String localName,      String qName,      Attributes attributes) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"")) {
            final String id=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            final String name=attributes.getValue(attributes.getIndex(""String_Node_Str""));
            final short acPol=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
            final short osdPol=Short.parseShort(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
            final String osdPolArgs=attributes.getIndex(""String_Node_Str"") == -1 ? null : attributes.getValue(attributes.getIndex(""String_Node_Str""));
            state=new DBRestoreState();
            state.currentVolume=new VolumeInfo(){
              public short getAcPolicyId(){
                return acPol;
              }
              public String getId(){
                return id;
              }
              public String getName(){
                return name;
              }
              public String getOsdPolicyArgs(){
                return osdPolArgs;
              }
              public short getOsdPolicyId(){
                return osdPol;
              }
              public void setOsdPolicyArgs(              String osdPolicyArgs){
              }
              public void setOsdPolicyId(              short osdPolicyId){
              }
            }
;
          }
 else           if (qName.equals(""String_Node_Str""))           try {
            dbVersion=Integer.parseInt(attributes.getValue(attributes.getIndex(""String_Node_Str"")));
          }
 catch (          Exception exc) {
            Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"");
          }
 else           handleNestedElement(qName,attributes,true);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
          throw new SAXException(exc);
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        try {
          if (qName.equals(""String_Node_Str"") || qName.equals(""String_Node_Str""))           return;
          handleNestedElement(qName,null,false);
        }
 catch (        Exception exc) {
          Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
          Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
          throw new SAXException(exc);
        }
      }
      private void handleNestedElement(      String qName,      Attributes attributes,      boolean openTag) throws UserException, DatabaseException {
        if (qName.equals(""String_Node_Str"")) {
          StorageManager sMan=vMan.getStorageManager(state.currentVolume.getId());
          AtomicDBUpdate update=sMan.createAtomicDBUpdate(null,null);
          sMan.setLastFileId(state.largestFileId,update);
          update.execute();
          state.largestFileId=0;
        }
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreDir(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreFile(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLocList(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreXLoc(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreOSD(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreACL(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreEntry(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
 else         if (qName.equals(""String_Node_Str""))         DBAdminHelper.restoreAttr(vMan,master.getFileAccessManager(),attributes,state,dbVersion,openTag);
      }
    }
);
    rq.setResponse(new xtreemfs_restore_databaseResponse());
    finishRequest(rq);
  }
 catch (  UserException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getMessage(),exc));
  }
catch (  SAXException exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getException().getMessage() == null ? ""String_Node_Str"" : exc.getException().getMessage(),exc.getException()));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,exc.getMessage() == null ? ""String_Node_Str"" : exc.getMessage(),exc));
  }
}",0.9983618492901348
113720,"@Override public void startRequest(MRCRequest rq){
  try {
    if (!rq.getDetails().superUser)     throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    final xtreemfs_restore_fileRequest rqArgs=(xtreemfs_restore_fileRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    final Path p=new Path(vMan.getVolumeById(volumeId).getName() + ""String_Node_Str"" + rqArgs.getFile_path());
    final StorageManager sMan=vMan.getStorageManager(volumeId);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long nextFileId=sMan.getNextFileId();
    FileMetadata[] path=sMan.resolvePath(p);
    long parentId=1;
    for (int i=0; i < p.getCompCount(); i++)     try {
      if (path[i] != null)       parentId=path[i].getId();
 else {
        sMan.createDir(nextFileId,parentId,p.getComp(i),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),509,0,update);
        parentId=nextFileId;
        nextFileId++;
        sMan.setLastFileId(nextFileId,update);
      }
    }
 catch (    DatabaseException exc) {
      if (exc.getType() != ExceptionType.FILE_EXISTS)       throw exc;
    }
    FileMetadata file=sMan.createFile(fileId,parentId,rqArgs.getFile_id(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),511,0,rqArgs.getFile_size(),false,0,0,update);
    int size=(rqArgs.getStripe_size() < 1024 ? 1 : (rqArgs.getStripe_size() % 1024 != 0) ? rqArgs.getStripe_size() / 1024 + 1 : rqArgs.getStripe_size() / 1024);
    StripingPolicy sp=sMan.createStripingPolicy(""String_Node_Str"",size,1);
    XLoc replica=sMan.createXLoc(sp,new String[]{rqArgs.getOsd_uuid()});
    XLocList xLocList=sMan.createXLocList(new XLoc[]{replica},0);
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_restore_fileResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    if (!rq.getDetails().superUser)     throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    final xtreemfs_restore_fileRequest rqArgs=(xtreemfs_restore_fileRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.getFile_id();
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.getFile_id().substring(0,i);
      fileId=Long.parseLong(rqArgs.getFile_id().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.getFile_id() + ""String_Node_Str"");
    }
    final Path p=new Path(vMan.getVolumeById(volumeId).getName() + ""String_Node_Str"" + rqArgs.getFile_path());
    final StorageManager sMan=vMan.getStorageManager(volumeId);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long nextFileId=sMan.getNextFileId();
    FileMetadata[] path=sMan.resolvePath(p);
    long parentId=1;
    for (int i=0; i < p.getCompCount(); i++)     try {
      if (path[i] != null)       parentId=path[i].getId();
 else {
        sMan.createDir(nextFileId,parentId,p.getComp(i),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),509,0,update);
        parentId=nextFileId;
        nextFileId++;
        sMan.setLastFileId(nextFileId,update);
      }
    }
 catch (    DatabaseException exc) {
      if (exc.getType() != ExceptionType.FILE_EXISTS)       throw exc;
    }
    FileMetadata file=sMan.createFile(fileId,parentId,rqArgs.getFile_id(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),511,0,rqArgs.getFile_size(),false,0,0,update);
    int size=(rqArgs.getStripe_size() < 1024 ? 1 : (rqArgs.getStripe_size() % 1024 != 0) ? rqArgs.getStripe_size() / 1024 + 1 : rqArgs.getStripe_size() / 1024);
    StripingPolicy sp=sMan.createStripingPolicy(""String_Node_Str"",size,1);
    XLoc replica=sMan.createXLoc(sp,new String[]{rqArgs.getOsd_uuid()});
    XLocList xLocList=sMan.createXLocList(new XLoc[]{replica},0);
    file.setXLocList(xLocList);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setResponse(new xtreemfs_restore_fileResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9966037735849056
113721,"@Override public void startRequest(MRCRequest rq){
  try {
    final setxattrRequest rqArgs=(setxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    final String attrKey=rqArgs.getName();
    final String attrVal=rqArgs.getValue();
    if (attrKey.startsWith(""String_Node_Str"")) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      MRCHelper.setSysAttrValue(sMan,vMan,volume,res.getParentDirId(),file,attrKey.substring(9),attrVal,update);
    }
 else {
      sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,attrVal.length() == 0 ? null : attrVal,update);
    }
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new setxattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final setxattrRequest rqArgs=(setxattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    final String attrKey=rqArgs.getName();
    final String attrVal=rqArgs.getValue();
    if (attrKey.startsWith(""String_Node_Str"")) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      MRCHelper.setSysAttrValue(sMan,vMan,volume,res.getParentDirId(),file,attrKey.substring(9),attrVal,update);
    }
 else {
      sMan.setXAttr(file.getId(),rq.getDetails().userId,attrKey,attrVal.length() == 0 ? null : attrVal,update);
    }
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setResponse(new setxattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.995945945945946
113722,"@Override public void startRequest(MRCRequest rq){
  try {
    final setattrRequest rqArgs=(setattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(""String_Node_Str"",sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setW32Attrs(rqArgs.getStbuf().getAttributes());
    sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
    rq.setResponse(new setattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final setattrRequest rqArgs=(setattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(""String_Node_Str"",sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setW32Attrs(rqArgs.getStbuf().getAttributes());
    sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
    rq.setResponse(new setattrResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9952431289640592
113723,"@Override public void startRequest(MRCRequest rq){
  try {
    final statfsRequest rqArgs=(statfsRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final VolumeInfo volume=vMan.getVolumeByName(rqArgs.getVolume_name());
    long blocks=master.getOSDStatusManager().getFreeSpace(volume.getId()) / 1024L;
    statfs_ statfs=new statfs_(1024,blocks,volume.getId(),1024);
    rq.setResponse(new statfsResponse(statfs));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final statfsRequest rqArgs=(statfsRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final VolumeInfo volume=vMan.getVolumeByName(rqArgs.getVolume_name());
    long blocks=master.getOSDStatusManager().getFreeSpace(volume.getId()) / 1024L;
    statfs_ statfs=new statfs_(1024,blocks,volume.getId(),1024);
    rq.setResponse(new statfsResponse(statfs));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.98870765370138
113724,"@Override public void startRequest(MRCRequest rq){
  try {
    final getattrRequest rqArgs=(getattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String linkTarget=sMan.getSoftlinkTarget(file.getId());
    int mode=faMan.getPosixAccessMode(sMan,file,rq.getDetails().userId,rq.getDetails().groupIds);
    mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_H_S_IFLNK : file.isDirectory() ? Constants.SYSTEM_V_FCNTL_H_S_IFDIR : Constants.SYSTEM_V_FCNTL_H_S_IFREG;
    long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : file.getSize();
    int type=linkTarget != null ? 3 : file.isDirectory() ? 2 : 1;
    stat_ stat=new stat_(mode,file.getLinkCount(),1,1,0,size,file.getAtime(),file.getMtime(),file.getCtime(),file.getOwnerId(),file.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + file.getId(),linkTarget,file.getEpoch(),(int)file.getW32Attrs());
    rq.setResponse(new getattrResponse(stat));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final getattrRequest rqArgs=(getattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String linkTarget=sMan.getSoftlinkTarget(file.getId());
    int mode=faMan.getPosixAccessMode(sMan,file,rq.getDetails().userId,rq.getDetails().groupIds);
    mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_H_S_IFLNK : file.isDirectory() ? Constants.SYSTEM_V_FCNTL_H_S_IFDIR : Constants.SYSTEM_V_FCNTL_H_S_IFREG;
    long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : file.getSize();
    int type=linkTarget != null ? 3 : file.isDirectory() ? 2 : 1;
    stat_ stat=new stat_(mode,file.getLinkCount(),1,1,0,size,file.getAtime(),file.getMtime(),file.getCtime(),file.getOwnerId(),file.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + file.getId(),linkTarget,file.getEpoch(),(int)file.getW32Attrs());
    rq.setResponse(new getattrResponse(stat));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9950657894736842
113725,"@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_update_file_sizeRequest rqArgs=(xtreemfs_update_file_sizeRequest)rq.getRequestArgs();
    Capability cap=new Capability(rqArgs.getXcap(),master.getConfig().getCapabilitySecret());
    if (!cap.hasValidSignature())     throw new UserException(cap + ""String_Node_Str"");
    if (cap.hasExpired())     throw new UserException(cap + ""String_Node_Str"");
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=cap.getFileId();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
      fileId=Long.parseLong(globalFileId.substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    }
    StorageManager sMan=master.getVolumeManager().getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    NewFileSizeSet newFSSet=rqArgs.getOsd_write_response().getNew_file_size();
    if (newFSSet.isEmpty())     throw new UserException(ErrNo.EINVAL,""String_Node_Str"");
    NewFileSize newFS=newFSSet.get(0);
    long newFileSize=newFS.getSize_in_bytes();
    int epochNo=newFS.getTruncate_epoch();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (epochNo >= file.getEpoch()) {
      if (epochNo > file.getEpoch() || newFileSize > file.getSize()) {
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file.setSize(newFileSize);
        file.setEpoch(epochNo);
        file.setCtime(time);
        file.setMtime(time);
        sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
        sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
      }
    }
 else {
      if (epochNo < file.getEpoch())       if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + epochNo + ""String_Node_Str""+ file.getEpoch());
      }
 else       if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFileSize + ""String_Node_Str""+ file.getSize());
      }
    }
    rq.setResponse(new xtreemfs_update_file_sizeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final xtreemfs_update_file_sizeRequest rqArgs=(xtreemfs_update_file_sizeRequest)rq.getRequestArgs();
    Capability cap=new Capability(rqArgs.getXcap(),master.getConfig().getCapabilitySecret());
    if (!cap.hasValidSignature())     throw new UserException(cap + ""String_Node_Str"");
    if (cap.hasExpired())     throw new UserException(cap + ""String_Node_Str"");
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=cap.getFileId();
      int i=globalFileId.indexOf(':');
      volumeId=globalFileId.substring(0,i);
      fileId=Long.parseLong(globalFileId.substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    }
    StorageManager sMan=master.getVolumeManager().getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    NewFileSizeSet newFSSet=rqArgs.getOsd_write_response().getNew_file_size();
    if (newFSSet.isEmpty())     throw new UserException(ErrNo.EINVAL,""String_Node_Str"");
    NewFileSize newFS=newFSSet.get(0);
    long newFileSize=newFS.getSize_in_bytes();
    int epochNo=newFS.getTruncate_epoch();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (epochNo >= file.getEpoch()) {
      if (epochNo > file.getEpoch() || newFileSize > file.getSize()) {
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file.setSize(newFileSize);
        file.setEpoch(epochNo);
        file.setCtime(time);
        file.setMtime(time);
        sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
        sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
      }
    }
 else {
      if (epochNo < file.getEpoch())       if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + epochNo + ""String_Node_Str""+ file.getEpoch());
      }
 else       if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + newFileSize + ""String_Node_Str""+ file.getSize());
      }
    }
    rq.setResponse(new xtreemfs_update_file_sizeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9965504024530472
113726,"@Override public void startRequest(MRCRequest rq){
  try {
    final utimeRequest rqArgs=(utimeRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(""String_Node_Str"",sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (false) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      file.setAtime((int)(TimeSync.getGlobalTime() / 1000L));
      file.setCtime((int)(TimeSync.getGlobalTime() / 1000L));
      file.setMtime((int)(TimeSync.getGlobalTime() / 1000L));
    }
 else {
      file.setAtime((int)rqArgs.getAtime());
      file.setCtime((int)rqArgs.getCtime());
      file.setMtime((int)rqArgs.getMtime());
    }
    sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
    rq.setResponse(new utimeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final utimeRequest rqArgs=(utimeRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(""String_Node_Str"",sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (false) {
      faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
      file.setAtime((int)(TimeSync.getGlobalTime() / 1000L));
      file.setCtime((int)(TimeSync.getGlobalTime() / 1000L));
      file.setMtime((int)(TimeSync.getGlobalTime() / 1000L));
    }
 else {
      file.setAtime((int)rqArgs.getAtime());
      file.setCtime((int)rqArgs.getCtime());
      file.setMtime((int)rqArgs.getMtime());
    }
    sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
    rq.setResponse(new utimeResponse());
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Throwable exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.996107266435986
113727,"public Long getObjectChecksum(long objId){
  Long c=objChecksums.get(objId);
  return (c == null) ? -1 : c;
}","public Long getObjectChecksum(long objId){
  Long c=objChecksums.get(objId);
  return (c == null) ? 0 : c;
}",0.9861751152073732
113728,"/** 
 * Returns checksum value (as Hex-String) and resets the Algorithm.
 * @return checksum
 */
public String getValue();","/** 
 * Returns checksum value (as Hex-String) and resets the Algorithm.
 * @return checksum
 */
public long getValue();",0.975206611570248
113729,"@Override public String getValue(){
  String value=Long.toHexString(realAlgorithm.getValue());
  realAlgorithm.reset();
  return value;
}","@Override public long getValue(){
  final long tmp=realAlgorithm.getValue();
  realAlgorithm.reset();
  return tmp;
}",0.8031496062992126
113730,"@Override public String getValue(){
  String value;
  if (this.hash != null)   value=this.hash;
 else   value=""String_Node_Str"";
  reset();
  return value;
}","@Override public long getValue(){
  long value;
  if (this.hash != null)   value=this.hash;
 else   value=0;
  reset();
  return value;
}",0.8979591836734694
113731,"/** 
 * Updates checksum with specified data.
 * @param data
 */
public void digest(String data){
  this.hash=Integer.toHexString(data.hashCode());
}","/** 
 * Updates checksum with specified data.
 * @param data
 */
public void digest(String data){
  this.hash=Long.valueOf(data.hashCode());
}",0.9140893470790378
113732,"@Override public void update(ByteBuffer data){
  byte[] array;
  if (data.hasArray()) {
    array=data.array();
  }
 else {
    array=new byte[data.capacity()];
    final int oldPos=data.position();
    data.position(0);
    data.get(array);
    data.position(oldPos);
  }
  this.hash=Integer.toHexString(new String(array).hashCode());
}","@Override public void update(ByteBuffer data){
  byte[] array;
  if (data.hasArray()) {
    array=data.array();
  }
 else {
    array=new byte[data.capacity()];
    final int oldPos=data.position();
    data.position(0);
    data.get(array);
    data.position(oldPos);
  }
  this.hash=(long)new String(array).hashCode();
}",0.9499241274658572
113733,"@Override public String getValue(){
  String value;
  if (this.hash != null)   value=this.hash;
 else   value=""String_Node_Str"";
  reset();
  return value;
}","@Override public long getValue(){
  long value;
  if (this.hash != null)   value=this.hash;
 else   value=0;
  reset();
  return value;
}",0.8979591836734694
113734,"/** 
 * SDBM algorithm
 * @param str
 * @return
 */
protected static String sdbmHash(String str){
  long hash=0;
  for (  int c : str.toCharArray()) {
    hash=c + (hash << 6) + (hash << 16) - hash;
  }
  return Long.toHexString(hash);
}","/** 
 * SDBM algorithm
 * @param str
 * @return
 */
protected static long sdbmHash(String str){
  long hash=0;
  for (  int c : str.toCharArray()) {
    hash=c + (hash << 6) + (hash << 16) - hash;
  }
  return hash;
}",0.9295154185022028
113735,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
        rq.setResponse(new createResponse());
      }
 else       throw exc;
    }
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),file.getEpoch(),master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
        rq.setResponse(new createResponse());
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.991112074571862
113736,"@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_S_IFLNK : child.isDirectory() ? Constants.SYSTEM_V_FCNTL_S_IFDIR : Constants.SYSTEM_V_FCNTL_S_IFREG;
      long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,type,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat,linkTarget));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_S_IFLNK : child.isDirectory() ? Constants.SYSTEM_V_FCNTL_S_IFDIR : Constants.SYSTEM_V_FCNTL_S_IFREG;
      long size=linkTarget != null ? linkTarget.length() : child.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,type,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat,linkTarget));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.998481012658228
113737,"@Override public void startRequest(final OSDRequest rq){
  final readRequest args=(readRequest)rq.getRequestArgs();
  if (args.getObject_number() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getOffset() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getLength() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  master.getStorageStage().readObject(args.getFile_id(),args.getObject_number(),rq.getLocationList().getLocalReplica().getStripingPolicy(),rq,new ReadObjectCallback(){
    @Override public void readComplete(    ObjectInformation result,    Exception error){
      step2(rq,args,result,error);
    }
  }
);
}","@Override public void startRequest(final OSDRequest rq){
  final readRequest args=(readRequest)rq.getRequestArgs();
  System.out.println(""String_Node_Str"" + args);
  if (args.getObject_number() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getOffset() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getLength() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  final StripingPolicyImpl sp=rq.getLocationList().getLocalReplica().getStripingPolicy();
  if (args.getLength() + args.getOffset() > sp.getStripeSizeForObject(0)) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"" + sp.getStripeSizeForObject(0) + ""String_Node_Str"",""String_Node_Str""));
    return;
  }
  master.getStorageStage().readObject(args.getFile_id(),args.getObject_number(),sp,rq,new ReadObjectCallback(){
    @Override public void readComplete(    ObjectInformation result,    Exception error){
      step2(rq,args,result,error);
    }
  }
);
}",0.7358309317963496
113738,"private void readFinish(OSDRequest rq,readRequest args,ObjectInformation result,boolean isLastObjectOrEOF){
  final boolean isRangeRequested=(args.getOffset() > 0) || (args.getLength() < result.getStripeSize());
  ObjectData data;
  if (isRangeRequested) {
    data=result.getObjectData(isLastObjectOrEOF,args.getOffset(),args.getLength());
  }
 else {
    data=result.getObjectData(isLastObjectOrEOF);
  }
  master.objectSent();
  if (data.getData() != null)   master.dataSent(data.getData().capacity());
  sendResponse(rq,data);
}","private void readFinish(OSDRequest rq,readRequest args,ObjectInformation result,boolean isLastObjectOrEOF){
  final boolean isRangeRequested=(args.getOffset() > 0) || (args.getLength() < result.getStripeSize());
  ObjectData data;
  if (isRangeRequested) {
    data=result.getObjectData(isLastObjectOrEOF,args.getOffset(),args.getLength());
  }
 else {
    data=result.getObjectData(isLastObjectOrEOF);
  }
  master.objectSent();
  if (data.getData() != null)   master.dataSent(data.getData().capacity());
  System.out.println(""String_Node_Str"" + data);
  sendResponse(rq,data);
}",0.9568345323741008
113739,"@Override public void startRequest(final OSDRequest rq){
  final truncateRequest args=(truncateRequest)rq.getRequestArgs();
  if (args.getNew_file_size() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (!rq.getLocationList().getLocalReplica().isHeadOsd(localUUID)) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  master.getStorageStage().truncate(args.getFile_id(),args.getNew_file_size(),rq.getLocationList().getLocalReplica().getStripingPolicy(),rq.getLocationList().getLocalReplica(),rq.getCapability().getEpochNo(),rq,new TruncateCallback(){
    @Override public void truncateComplete(    OSDWriteResponse result,    Exception error){
      step2(rq,args,result,error);
    }
  }
);
}","@Override public void startRequest(final OSDRequest rq){
  final truncateRequest args=(truncateRequest)rq.getRequestArgs();
  System.out.println(""String_Node_Str"" + args);
  if (args.getNew_file_size() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (!rq.getLocationList().getLocalReplica().isHeadOsd(localUUID)) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  master.getStorageStage().truncate(args.getFile_id(),args.getNew_file_size(),rq.getLocationList().getLocalReplica().getStripingPolicy(),rq.getLocationList().getLocalReplica(),rq.getCapability().getEpochNo(),rq,new TruncateCallback(){
    @Override public void truncateComplete(    OSDWriteResponse result,    Exception error){
      step2(rq,args,result,error);
    }
  }
);
}",0.9724137931034482
113740,"@Override public void startRequest(final OSDRequest rq){
  final writeRequest args=(writeRequest)rq.getRequestArgs();
  if (args.getObject_number() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getOffset() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  final StripingPolicyImpl sp=rq.getLocationList().getLocalReplica().getStripingPolicy();
  if (args.getOffset() >= sp.getStripeSizeForObject(args.getObject_number())) {
    rq.sendOSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"");
    return;
  }
  master.objectReceived();
  master.dataReceived(args.getObject_data().getData().capacity());
  master.getStorageStage().writeObject(args.getFile_id(),args.getObject_number(),sp,args.getOffset(),args.getObject_data().getData(),rq.getCowPolicy(),rq.getLocationList(),rq,new WriteObjectCallback(){
    @Override public void writeComplete(    OSDWriteResponse result,    Exception error){
      step2(rq,result,error);
    }
  }
);
}","@Override public void startRequest(final OSDRequest rq){
  final writeRequest args=(writeRequest)rq.getRequestArgs();
  System.out.println(""String_Node_Str"" + args);
  if (args.getObject_number() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  if (args.getOffset() < 0) {
    rq.sendException(new OSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"",""String_Node_Str""));
    return;
  }
  final StripingPolicyImpl sp=rq.getLocationList().getLocalReplica().getStripingPolicy();
  if (args.getOffset() >= sp.getStripeSizeForObject(args.getObject_number())) {
    rq.sendOSDException(ErrorCodes.INVALID_PARAMS,""String_Node_Str"");
    return;
  }
  master.objectReceived();
  master.dataReceived(args.getObject_data().getData().capacity());
  master.getStorageStage().writeObject(args.getFile_id(),args.getObject_number(),sp,args.getOffset(),args.getObject_data().getData(),rq.getCowPolicy(),rq.getLocationList(),rq,new WriteObjectCallback(){
    @Override public void writeComplete(    OSDWriteResponse result,    Exception error){
      step2(rq,result,error);
    }
  }
);
}",0.9788172992056487
113741,"public void sendResponse(OSDRequest rq,OSDWriteResponse result){
  writeResponse response=new writeResponse(result);
  rq.sendSuccess(response);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
}","public void sendResponse(OSDRequest rq,OSDWriteResponse result){
  System.out.println(""String_Node_Str"" + result);
  writeResponse response=new writeResponse(result);
  rq.sendSuccess(response);
}",0.7156862745098039
113742,"public static void main(String[] args){
  try {
    Map<String,CliOption> options=new HashMap<String,CliOption>();
    List<String> arguments=new ArrayList<String>(1);
    CLIParser.parseCLI(args,options,arguments);
    if (arguments.size() != 2) {
      return;
    }
    TimeSync.initialize(null,60 * 1000,50);
    Logging.start(Logging.LEVEL_WARN);
    ONCRPCServiceURL mrcUrl=new ONCRPCServiceURL(arguments.get(0));
    String path=arguments.get(1);
    RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,15 * 1000,5 * 60 * 1000);
    rpcClient.start();
    rpcClient.waitForStartup();
    MRCClient c=new MRCClient(rpcClient,new InetSocketAddress(mrcUrl.getHost(),mrcUrl.getPort()));
    final String user=""String_Node_Str"";
    final List<String> groups=new ArrayList(1);
    groups.add(""String_Node_Str"");
    RPCResponse<DirectoryEntrySet> r=c.readdir(null,user,groups,path);
    DirectoryEntrySet entries=r.get();
    r.freeBuffers();
    for (    DirectoryEntry e : entries) {
      System.out.println(e.getEntry_name() + ""String_Node_Str"" + e.getStbuf().getMode());
    }
    rpcClient.shutdown();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}","public static void main(String[] args){
  try {
    Map<String,CliOption> options=new HashMap<String,CliOption>();
    List<String> arguments=new ArrayList<String>(1);
    CLIParser.parseCLI(args,options,arguments);
    if (arguments.size() != 2) {
      return;
    }
    TimeSync.initialize(null,60 * 1000,50);
    Logging.start(Logging.LEVEL_WARN);
    ONCRPCServiceURL mrcUrl=new ONCRPCServiceURL(arguments.get(0));
    String path=arguments.get(1);
    RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,15 * 1000,5 * 60 * 1000);
    rpcClient.start();
    rpcClient.waitForStartup();
    MRCClient c=new MRCClient(rpcClient,new InetSocketAddress(mrcUrl.getHost(),mrcUrl.getPort()));
    final String user=""String_Node_Str"";
    final List<String> groups=new ArrayList(1);
    groups.add(""String_Node_Str"");
    RPCResponse<DirectoryEntrySet> r=c.readdir(null,user,groups,path);
    DirectoryEntrySet entries=r.get();
    r.freeBuffers();
    for (    DirectoryEntry e : entries) {
      System.out.println(e.getEntry_name() + ""String_Node_Str"" + e.getStbuf().getMode()+ ""String_Node_Str""+ OutputUtils.formatBytes(e.getStbuf().getSize())+ ""String_Node_Str""+ e.getStbuf().getAttributes());
    }
    rpcClient.shutdown();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
}",0.9533678756476685
113743,"@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
        rq.setResponse(new createResponse());
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final openRequest rqArgs=(openRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=null;
    try {
      res.checkIfFileDoesNotExist();
      file=res.getFile();
      String target=sMan.getSoftlinkTarget(file.getId());
      if (target != null) {
        rqArgs.setPath(target);
        p=new Path(target);
        if (!vMan.hasVolume(p.getComp(0))) {
          finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
          return;
        }
        volume=vMan.getVolumeByName(p.getComp(0));
        sMan=vMan.getStorageManager(volume.getId());
        res=new PathResolver(sMan,p);
        file=res.getFile();
      }
      if (file.isDirectory())       throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
      if (file.isReadOnly() && ((rqArgs.getFlags() & (FileAccessManager.O_RDWR | FileAccessManager.O_WRONLY | FileAccessManager.O_TRUNC| FileAccessManager.O_APPEND)) != 0))       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      faMan.checkPermission(rqArgs.getFlags(),sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    }
 catch (    UserException exc) {
      if (exc.getErrno() == ErrNo.ENOENT && (rqArgs.getFlags() & FileAccessManager.O_CREAT) != 0) {
        faMan.checkPermission(FileAccessManager.O_WRONLY,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
        if ((rqArgs.getFlags() & FileAccessManager.O_EXCL) != 0)         res.checkIfFileExistsAlready();
        long fileId=sMan.getNextFileId();
        int time=(int)(TimeSync.getGlobalTime() / 1000);
        file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.getMode(),0,0,false,0,0,update);
        sMan.setLastFileId(fileId,update);
      }
 else       throw exc;
    }
    int trEpoch=file.getEpoch();
    if ((rqArgs.getFlags() & FileAccessManager.O_TRUNC) != 0) {
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      trEpoch=file.getIssuedEpoch();
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    XLocList xLocList=file.getXLocList();
    XLocSet xLocSet=null;
    if (xLocList == null || xLocList.getReplicaCount() == 0) {
      Replica replica=MRCHelper.createReplica(null,sMan,master.getOSDStatusManager(),volume,res.getParentDirId(),rqArgs.getPath(),((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress());
      ReplicaSet replicas=new ReplicaSet();
      replicas.add(replica);
      xLocSet=new XLocSet(replicas,0,""String_Node_Str"",0);
      file.setXLocList(Converter.xLocSetToXLocList(sMan,xLocSet));
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
 else     xLocSet=Converter.xLocListToXLocSet(xLocList);
    Capability cap=new Capability(volume.getId() + ""String_Node_Str"" + file.getId(),rqArgs.getFlags(),TimeSync.getGlobalTime() / 1000 + Capability.DEFAULT_VALIDITY,((InetSocketAddress)rq.getRPCRequest().getClientIdentity()).getAddress().getHostAddress(),trEpoch,master.getConfig().getCapabilitySecret());
    MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    rq.setResponse(new openResponse(new FileCredentials(xLocSet,cap.getXCap())));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9894461973669896
113744,"public static void main(String[] args) throws Exception {
  Logging.start(Logging.LEVEL_WARN);
  System.out.println(""String_Node_Str"" + OSDRequestDispatcher.VERSION + ""String_Node_Str"");
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(1);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  CLIParser.parseCLI(args,options,arguments);
  if (arguments.size() != 1 || options.get(""String_Node_Str"").switchValue == true) {
    usage();
    return;
  }
  InetSocketAddress dirAddr=null;
  boolean useSSL=false;
  String serviceCredsFile=null;
  String serviceCredsPass=null;
  String trustedCAsFile=null;
  String trustedCAsPass=null;
  ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
  if (dirURL != null && ""String_Node_Str"".equals(dirURL.getProtocol())) {
    useSSL=true;
    serviceCredsFile=options.get(""String_Node_Str"").stringValue;
    serviceCredsPass=options.get(""String_Node_Str"").stringValue;
    trustedCAsFile=options.get(""String_Node_Str"").stringValue;
    trustedCAsPass=options.get(""String_Node_Str"").stringValue;
  }
  if (dirURL == null) {
    DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
    cfg.read();
    dirAddr=cfg.getDirectoryService();
    useSSL=cfg.isSslEnabled();
    serviceCredsFile=cfg.getServiceCredsFile();
    serviceCredsPass=cfg.getServiceCredsPassphrase();
    trustedCAsFile=cfg.getTrustedCertsFile();
    trustedCAsPass=cfg.getTrustedCertsPassphrase();
  }
 else   dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
  boolean checkOnly=options.get(""String_Node_Str"").switchValue;
  int numThreads=DEFAULT_NUM_THREADS;
  if (options.get(""String_Node_Str"").numValue != null)   numThreads=options.get(""String_Node_Str"").numValue.intValue();
  String volume=arguments.get(0);
  boolean isVolUUID=false;
  if (volume.startsWith(""String_Node_Str"")) {
    volume=volume.substring(""String_Node_Str"".length());
    isVolUUID=true;
  }
  SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false) : null;
  RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(sslOptions,30000,5 * 60000);
  rpcClient.start();
  rpcClient.waitForStartup();
  DIRClient dirClient=new DIRClient(rpcClient,dirAddr);
  TimeSync.initialize(dirClient,100000,50).waitForStartup();
  RPCResponse<ServiceRegistrySet> resp=dirClient.service_get_by_type(null,Constants.SERVICE_TYPE_VOLUME);
  ServiceRegistrySet result=resp.get();
  resp.freeBuffers();
  ServiceRegistry volReg=null;
  if (isVolUUID) {
    for (    ServiceRegistry reg : result) {
      if (reg.getUuid().equals(volume))       volReg=reg;
    }
  }
 else {
    for (    ServiceRegistry reg : result) {
      if (reg.getService_name().equals(volume))       volReg=reg;
    }
  }
  if (volReg == null) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str""+ dirURL+ ""String_Node_Str"");
    System.exit(3);
  }
  volume=volReg.getService_name();
  String mrc=null;
  for (  KeyValuePair kv : volReg.getData()) {
    if (kv.getKey().equals(""String_Node_Str""))     mrc=kv.getValue();
  }
  if (mrc == null) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str"");
    System.exit(3);
  }
  UUIDResolver.start(dirClient,60 * 60,10 * 60 * 60);
  ServiceUUID mrcUUID=new ServiceUUID(mrc);
  InetSocketAddress mrcAddress=mrcUUID.getAddress();
  int exitCode=1;
  try {
    Scrubber scrubber=new Scrubber(rpcClient,dirClient,new MRCClient(rpcClient,mrcAddress),volume,checkOnly,numThreads);
    exitCode=scrubber.scrub();
    if (exitCode == 0)     System.out.println(""String_Node_Str"" + volume + ""String_Node_Str"");
 else     System.out.println(""String_Node_Str"" + volume + ""String_Node_Str"");
    System.exit(exitCode);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  TimeSync.close();
  UUIDResolver.shutdown();
  rpcClient.shutdown();
}","public static void main(String[] args) throws Exception {
  Logging.start(Logging.LEVEL_WARN);
  System.out.println(""String_Node_Str"" + OSDRequestDispatcher.VERSION + ""String_Node_Str"");
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(1);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  CLIParser.parseCLI(args,options,arguments);
  if (arguments.size() != 1 || options.get(""String_Node_Str"").switchValue == true) {
    usage();
    return;
  }
  InetSocketAddress dirAddr=null;
  boolean useSSL=false;
  String serviceCredsFile=null;
  String serviceCredsPass=null;
  String trustedCAsFile=null;
  String trustedCAsPass=null;
  ONCRPCServiceURL dirURL=options.get(""String_Node_Str"").urlValue;
  if (dirURL != null && ""String_Node_Str"".equals(dirURL.getProtocol())) {
    useSSL=true;
    serviceCredsFile=options.get(""String_Node_Str"").stringValue;
    serviceCredsPass=options.get(""String_Node_Str"").stringValue;
    trustedCAsFile=options.get(""String_Node_Str"").stringValue;
    trustedCAsPass=options.get(""String_Node_Str"").stringValue;
  }
  if (dirURL == null) {
    DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
    cfg.read();
    dirAddr=cfg.getDirectoryService();
    useSSL=cfg.isSslEnabled();
    serviceCredsFile=cfg.getServiceCredsFile();
    serviceCredsPass=cfg.getServiceCredsPassphrase();
    trustedCAsFile=cfg.getTrustedCertsFile();
    trustedCAsPass=cfg.getTrustedCertsPassphrase();
  }
 else   dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
  boolean checkOnly=options.get(""String_Node_Str"").switchValue;
  int numThreads=DEFAULT_NUM_THREADS;
  if (options.get(""String_Node_Str"").numValue != null)   numThreads=options.get(""String_Node_Str"").numValue.intValue();
  String volume=arguments.get(0);
  boolean isVolUUID=false;
  if (volume.startsWith(""String_Node_Str"")) {
    volume=volume.substring(""String_Node_Str"".length());
    isVolUUID=true;
  }
  SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false) : null;
  RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(sslOptions,30000,5 * 60000);
  rpcClient.start();
  rpcClient.waitForStartup();
  DIRClient dirClient=new DIRClient(rpcClient,dirAddr);
  TimeSync.initialize(dirClient,100000,50).waitForStartup();
  RPCResponse<ServiceRegistrySet> resp=dirClient.service_get_by_type(null,Constants.SERVICE_TYPE_VOLUME);
  ServiceRegistrySet result=resp.get();
  resp.freeBuffers();
  ServiceRegistry volReg=null;
  if (isVolUUID) {
    for (    ServiceRegistry reg : result) {
      if (reg.getUuid().equals(volume))       volReg=reg;
    }
  }
 else {
    for (    ServiceRegistry reg : result) {
      if (reg.getService_name().equals(volume))       volReg=reg;
    }
  }
  if (volReg == null) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str""+ dirURL+ ""String_Node_Str"");
    System.exit(3);
  }
  volume=volReg.getService_name();
  String mrc=volReg.getData().get(""String_Node_Str"");
  if (mrc == null) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str"");
    System.exit(3);
  }
  UUIDResolver.start(dirClient,60 * 60,10 * 60 * 60);
  ServiceUUID mrcUUID=new ServiceUUID(mrc);
  InetSocketAddress mrcAddress=mrcUUID.getAddress();
  int exitCode=1;
  try {
    Scrubber scrubber=new Scrubber(rpcClient,dirClient,new MRCClient(rpcClient,mrcAddress),volume,checkOnly,numThreads);
    exitCode=scrubber.scrub();
    if (exitCode == 0)     System.out.println(""String_Node_Str"" + volume + ""String_Node_Str"");
 else     System.out.println(""String_Node_Str"" + volume + ""String_Node_Str"");
    System.exit(exitCode);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  TimeSync.close();
  UUIDResolver.shutdown();
  rpcClient.shutdown();
}",0.985516645049719
113745,"public void read() throws IOException {
  this.debugLevel=this.readRequiredInt(""String_Node_Str"");
  this.port=this.readRequiredInt(""String_Node_Str"");
  this.httpPort=this.readRequiredInt(""String_Node_Str"");
  this.address=this.readOptionalInetAddr(""String_Node_Str"",null);
  if (this.useSSL=this.readRequiredBoolean(""String_Node_Str"")) {
    this.serviceCredsFile=this.readRequiredString(""String_Node_Str"");
    this.serviceCredsPassphrase=this.readRequiredString(""String_Node_Str"");
    this.serviceCredsContainer=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsFile=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsPassphrase=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsContainer=this.readRequiredString(""String_Node_Str"");
  }
  this.geoCoordinates=this.readOptionalString(""String_Node_Str"",""String_Node_Str"");
}","public void read() throws IOException {
  this.debugLevel=this.readRequiredInt(""String_Node_Str"");
  this.port=this.readRequiredInt(""String_Node_Str"");
  this.httpPort=this.readRequiredInt(""String_Node_Str"");
  this.address=this.readOptionalInetAddr(""String_Node_Str"",null);
  if (this.useSSL=this.readRequiredBoolean(""String_Node_Str"")) {
    this.serviceCredsFile=this.readRequiredString(""String_Node_Str"");
    this.serviceCredsPassphrase=this.readRequiredString(""String_Node_Str"");
    this.serviceCredsContainer=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsFile=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsPassphrase=this.readRequiredString(""String_Node_Str"");
    this.trustedCertsContainer=this.readRequiredString(""String_Node_Str"");
  }
  this.geoCoordinates=this.readOptionalString(""String_Node_Str"",""String_Node_Str"");
  this.adminPassword=this.readOptionalString(""String_Node_Str"",""String_Node_Str"");
}",0.9545205479452056
113746,"private void registerOperations(){
  DIROperation op;
  op=new GetGlobalTimeOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new SetAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new DeleteAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new RegisterServiceOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new DeregisterServiceOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetServiceByUuidOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetServicesByTypeOperation(this);
  registry.put(op.getProcedureId(),op);
}","private void registerOperations(){
  DIROperation op;
  op=new GetGlobalTimeOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new SetAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new DeleteAddressMappingOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new RegisterServiceOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new DeregisterServiceOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetServiceByUuidOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetServicesByTypeOperation(this);
  registry.put(op.getProcedureId(),op);
  op=new GetServiceByNameOperation(this);
  registry.put(op.getProcedureId(),op);
}",0.9457671957671958
113747,"public DIRRequestDispatcher(final DIRConfig config) throws IOException, BabuDBException {
  super(""String_Node_Str"");
  registry=new HashMap();
  database=BabuDBFactory.getBabuDB(config.getDbDir(),config.getDbDir(),0,1024 * 1024 * 16,60 * 5,SyncMode.FSYNC,200,500);
  initializeDatabase();
  registerOperations();
  SSLOptions sslOptions=null;
  if (config.isUsingSSL()) {
    sslOptions=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  }
  queue=new LinkedBlockingQueue();
  quit=false;
  server=new RPCNIOSocketServer(config.getPort(),null,this,sslOptions);
  httpServ=HttpServer.create(new InetSocketAddress(""String_Node_Str"",config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(DIRRequestDispatcher.this,config).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      BabuDBException ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  numRequests=0;
}","public DIRRequestDispatcher(final DIRConfig config) throws IOException, BabuDBException {
  super(""String_Node_Str"");
  registry=new HashMap();
  database=BabuDBFactory.getBabuDB(config.getDbDir(),config.getDbDir(),0,1024 * 1024 * 16,60 * 5,SyncMode.FSYNC,200,500);
  initializeDatabase();
  registerOperations();
  SSLOptions sslOptions=null;
  if (config.isUsingSSL()) {
    sslOptions=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  }
  queue=new LinkedBlockingQueue();
  quit=false;
  server=new RPCNIOSocketServer(config.getPort(),null,this,sslOptions);
  httpServ=HttpServer.create(new InetSocketAddress(config.getHttpPort()),0);
  httpServ.createContext(""String_Node_Str"",new HttpHandler(){
    public void handle(    HttpExchange httpExchange) throws IOException {
      byte[] content;
      try {
        content=StatusPage.getStatusPage(DIRRequestDispatcher.this,config).getBytes(""String_Node_Str"");
        httpExchange.sendResponseHeaders(200,content.length);
        httpExchange.getResponseBody().write(content);
        httpExchange.getResponseBody().close();
      }
 catch (      BabuDBException ex) {
        ex.printStackTrace();
        httpExchange.sendResponseHeaders(500,0);
      }
    }
  }
);
  httpServ.start();
  numRequests=0;
}",0.9939271255060728
113748,"public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(ex.toString());
    return;
  }
  try {
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendInternalServerError(ex);
    return;
  }
}","public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,ErrNo.EINVAL,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,ErrNo.EINVAL,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(ex.toString());
    return;
  }
  try {
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendInternalServerError(ex);
    return;
  }
}",0.9852272727272728
113749,"public static String getStatusPage(DIRRequestDispatcher master,DIRConfig config) throws BabuDBException {
  final BabuDB database=master.getDatabase();
  assert(statusPageTemplate != null);
  long time=System.currentTimeMillis();
  Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,new byte[0]);
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    AddressMappingSet ams=new AddressMappingSet();
    ams.deserialize(ReusableBuffer.wrap(e.getValue()));
    final String uuid=new String(e.getKey());
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    long version=0;
    for (    AddressMapping am : ams) {
      dump.append(""String_Node_Str"");
      String endpoint=am.getProtocol() + ""String_Node_Str"" + am.getAddress()+ ""String_Node_Str""+ am.getPort();
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(am.getMatch_network());
      dump.append(""String_Node_Str"");
      dump.append(am.getTtl());
      dump.append(""String_Node_Str"");
      version=am.getVersion();
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(version);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    final String uuid=new String(e.getKey());
    final ServiceRegistry sreg=new ServiceRegistry();
    sreg.deserialize(ReusableBuffer.wrap(e.getValue()));
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_type());
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_name());
    dump.append(""String_Node_Str"");
    for (    KeyValuePair kv : sreg.getData()) {
      dump.append(""String_Node_Str"");
      dump.append(kv.getKey());
      dump.append(""String_Node_Str"");
      dump.append(kv.getValue());
      if (kv.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(new Date(Long.parseLong(kv.getValue()) * 1000));
        dump.append(""String_Node_Str"");
      }
 else       if (kv.getKey().equals(""String_Node_Str"") || kv.getKey().equals(""String_Node_Str"") || kv.getKey().endsWith(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(OutputUtils.formatBytes(Long.parseLong(kv.getValue())));
        dump.append(""String_Node_Str"");
      }
 else       if (kv.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
      }
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(sreg.getVersion());
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(master.getNumConnections()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Long.toString(master.getNumRequests()));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  tmp=tmp.replace(Vars.VERSION.toString(),DIRRequestDispatcher.VERSION);
  tmp=tmp.replace(Vars.PROTOVERSION.toString(),Integer.toString(DIRInterface.getVersion()));
  return tmp;
}","public static String getStatusPage(DIRRequestDispatcher master,DIRConfig config) throws BabuDBException {
  final BabuDB database=master.getDatabase();
  assert(statusPageTemplate != null);
  long time=System.currentTimeMillis();
  Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,new byte[0]);
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    AddressMappingSet ams=new AddressMappingSet();
    ams.deserialize(ReusableBuffer.wrap(e.getValue()));
    final String uuid=new String(e.getKey());
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    long version=0;
    for (    AddressMapping am : ams) {
      dump.append(""String_Node_Str"");
      String endpoint=am.getProtocol() + ""String_Node_Str"" + am.getAddress()+ ""String_Node_Str""+ am.getPort();
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(am.getMatch_network());
      dump.append(""String_Node_Str"");
      dump.append(am.getTtl());
      dump.append(""String_Node_Str"");
      version=am.getVersion();
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(version);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    final String uuid=new String(e.getKey());
    final ServiceRegistry sreg=new ServiceRegistry();
    sreg.deserialize(ReusableBuffer.wrap(e.getValue()));
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_type());
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_name());
    dump.append(""String_Node_Str"");
    for (    Entry<String,String> dataEntry : sreg.getData().entrySet()) {
      dump.append(""String_Node_Str"");
      dump.append(dataEntry.getKey());
      dump.append(""String_Node_Str"");
      dump.append(dataEntry.getValue());
      if (dataEntry.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(new Date(Long.parseLong(dataEntry.getValue()) * 1000));
        dump.append(""String_Node_Str"");
      }
 else       if (dataEntry.getKey().equals(""String_Node_Str"") || dataEntry.getKey().equals(""String_Node_Str"") || dataEntry.getKey().endsWith(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(OutputUtils.formatBytes(Long.parseLong(dataEntry.getValue())));
        dump.append(""String_Node_Str"");
      }
 else       if (dataEntry.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
      }
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(sreg.getVersion());
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(master.getNumConnections()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Long.toString(master.getNumRequests()));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  tmp=tmp.replace(Vars.VERSION.toString(),DIRRequestDispatcher.VERSION);
  tmp=tmp.replace(Vars.PROTOVERSION.toString(),Integer.toString(DIRInterface.getVersion()));
  return tmp;
}",0.9226608977825852
113750,"@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_getRequest request=(address_mappings_getRequest)rq.getRequestMessage();
    byte[] result=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    if (result == null) {
      address_mappings_getResponse response=new address_mappings_getResponse();
      rq.sendSuccess(response);
    }
 else {
      AddressMappingSet set=new AddressMappingSet();
      set.deserialize(ReusableBuffer.wrap(result));
      address_mappings_getResponse response=new address_mappings_getResponse(set);
      rq.sendSuccess(response);
    }
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_getRequest request=(address_mappings_getRequest)rq.getRequestMessage();
    if (request.getUuid().length() > 0) {
      byte[] result=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
      if (result == null) {
        address_mappings_getResponse response=new address_mappings_getResponse();
        rq.sendSuccess(response);
      }
 else {
        AddressMappingSet set=new AddressMappingSet();
        set.deserialize(ReusableBuffer.wrap(result));
        address_mappings_getResponse response=new address_mappings_getResponse(set);
        rq.sendSuccess(response);
      }
    }
 else {
      AddressMappingSet list=new AddressMappingSet();
      Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,new byte[0]);
      while (iter.hasNext()) {
        Entry<byte[],byte[]> e=iter.next();
        AddressMappingSet set=new AddressMappingSet();
        set.deserialize(ReusableBuffer.wrap(e.getValue()));
        for (        AddressMapping m : set)         list.add(m);
      }
      address_mappings_getResponse response=new address_mappings_getResponse(list);
      rq.sendSuccess(response);
    }
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.7067603160667252
113751,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_typeRequest request=(service_get_by_typeRequest)rq.getRequestMessage();
    Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
    ServiceRegistrySet services=new ServiceRegistrySet();
    while (iter.hasNext()) {
      final Entry<byte[],byte[]> e=iter.next();
      final ServiceRegistry servEntry=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(e.getValue());
      servEntry.deserialize(buf);
      if (servEntry.getService_type() == request.getType())       services.add(servEntry);
    }
    service_get_by_typeResponse response=new service_get_by_typeResponse(services);
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + response);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_typeRequest request=(service_get_by_typeRequest)rq.getRequestMessage();
    Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
    ServiceRegistrySet services=new ServiceRegistrySet();
    long now=System.currentTimeMillis() / 1000l;
    while (iter.hasNext()) {
      final Entry<byte[],byte[]> e=iter.next();
      final ServiceRegistry servEntry=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(e.getValue());
      servEntry.deserialize(buf);
      if ((request.getType() == 0) || (servEntry.getService_type() == request.getType()))       services.add(servEntry);
      long secondsSinceLastUpdate=now - servEntry.getLast_updated();
      servEntry.getData().put(""String_Node_Str"",Long.toString(secondsSinceLastUpdate));
    }
    service_get_by_typeResponse response=new service_get_by_typeResponse(services);
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + response);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.8508384819064431
113752,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    final int dataSize=reg.calculateSize();
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(dataSize);
    reg.serialize(writer);
    writer.flip();
    assert(writer.getBuffers().size() == 1);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError(th);
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.setLast_updated(System.currentTimeMillis() / 1000l);
    final int dataSize=reg.calculateSize();
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(dataSize);
    reg.serialize(writer);
    writer.flip();
    assert(writer.getBuffers().size() == 1);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError(th);
  }
}",0.9771716572783872
113753,"public RPCNIOSocketClient(SSLOptions sslOptions,int requestTimeout,int connectionTimeout) throws IOException {
  super(""String_Node_Str"");
  if (requestTimeout >= connectionTimeout - TIMEOUT_GRANULARITY * 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + TIMEOUT_GRANULARITY * 2 + ""String_Node_Str"");
  }
  this.requestTimeout=requestTimeout;
  this.connectionTimeout=connectionTimeout;
  connections=new HashMap();
  selector=Selector.open();
  this.sslOptions=sslOptions;
  quit=false;
  transactionId=new AtomicInteger(1);
  toBeEstablished=new ConcurrentLinkedQueue<ServerConnection>();
}","public RPCNIOSocketClient(SSLOptions sslOptions,int requestTimeout,int connectionTimeout) throws IOException {
  super(""String_Node_Str"");
  if (requestTimeout >= connectionTimeout - TIMEOUT_GRANULARITY * 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + TIMEOUT_GRANULARITY * 2 + ""String_Node_Str"");
  }
  this.requestTimeout=requestTimeout;
  this.connectionTimeout=connectionTimeout;
  connections=new HashMap();
  selector=Selector.open();
  this.sslOptions=sslOptions;
  quit=false;
  transactionId=new AtomicInteger((int)(Math.random() * 1e6 + 1.0));
  toBeEstablished=new ConcurrentLinkedQueue<ServerConnection>();
}",0.9750603378921964
113754,"private void assembleResponse(SelectionKey key,ServerConnection con){
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
  ONCRPCResponseHeader hdr=null;
  ReusableBuffer firstFragment=null;
  try {
    firstFragment=con.getResponseFragments().get(0);
    firstFragment.position(0);
    hdr=new ONCRPCResponseHeader();
    hdr.deserialize(firstFragment);
  }
 catch (  Exception ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress());
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key,new IOException(""String_Node_Str""));
    return;
  }
  final int xid=hdr.getXID();
  ONCRPCRequest rec=con.getRequest(xid);
  if (rec == null) {
    Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + xid);
    return;
  }
  rec.setResponseFragments(con.getResponseFragments());
  con.clearResponseFragments();
  if (hdr.getAcceptStat() == ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS) {
    rec.getListener().responseAvailable(rec);
  }
 else {
    ONCRPCException exception=null;
    String exName=null;
    if (firstFragment.hasRemaining()) {
      try {
        final int exNameLen=firstFragment.getInt();
        final byte[] exBytes=new byte[exNameLen];
        firstFragment.get(exBytes);
        exName=new String(exBytes);
        if (exNameLen % 4 > 0) {
          for (int i=0; i < (4 - exNameLen % 4); i++) {
            firstFragment.get();
          }
        }
        exception=Exceptions.createException(exName);
        Serializable exAsSer=(Serializable)exception;
        exAsSer.deserialize(firstFragment);
      }
 catch (      IOException ex) {
        exName=""String_Node_Str"";
        rec.getListener().requestFailed(rec,new IOException(""String_Node_Str""));
        return;
      }
    }
    if (exName == null) {
      exception=new ProtocolException(hdr.getAcceptStat(),0,""String_Node_Str"");
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + exName + ""String_Node_Str""+ exception);
    }
    rec.getListener().remoteExceptionThrown(rec,exception);
  }
}","private void assembleResponse(SelectionKey key,ServerConnection con){
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
  ONCRPCResponseHeader hdr=null;
  ReusableBuffer firstFragment=null;
  try {
    firstFragment=con.getResponseFragments().get(0);
    firstFragment.position(0);
    hdr=new ONCRPCResponseHeader();
    hdr.deserialize(firstFragment);
  }
 catch (  Exception ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress());
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key,new IOException(""String_Node_Str""));
    return;
  }
  final int xid=hdr.getXID();
  ONCRPCRequest rec=con.getRequest(xid);
  if (rec == null) {
    Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + xid);
    con.clearResponseFragments();
    return;
  }
  rec.setResponseFragments(con.getResponseFragments());
  con.clearResponseFragments();
  if (hdr.getAcceptStat() == ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS) {
    rec.getListener().responseAvailable(rec);
  }
 else {
    ONCRPCException exception=null;
    String exName=null;
    if (firstFragment.hasRemaining()) {
      try {
        final int exNameLen=firstFragment.getInt();
        final byte[] exBytes=new byte[exNameLen];
        firstFragment.get(exBytes);
        exName=new String(exBytes);
        if (exNameLen % 4 > 0) {
          for (int i=0; i < (4 - exNameLen % 4); i++) {
            firstFragment.get();
          }
        }
        exception=Exceptions.createException(exName);
        Serializable exAsSer=(Serializable)exception;
        exAsSer.deserialize(firstFragment);
      }
 catch (      IOException ex) {
        exName=""String_Node_Str"";
        rec.getListener().requestFailed(rec,new IOException(""String_Node_Str""));
        return;
      }
    }
    if (exName == null) {
      exception=new ProtocolException(hdr.getAcceptStat(),ErrNo.EINVAL,""String_Node_Str"");
    }
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + exName + ""String_Node_Str""+ exception);
    }
    rec.getListener().remoteExceptionThrown(rec,exception);
  }
}",0.9893254599136952
113755,"@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,type,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat,linkTarget));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final readdirRequest rqArgs=(readdirRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    Path p=new Path(rqArgs.getPath());
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.setPath(target);
      p=new Path(target);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrNo.ENOENT,""String_Node_Str"" + target + ""String_Node_Str""));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.O_RDONLY,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    DirectoryEntrySet dirContent=new DirectoryEntrySet();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      String linkTarget=sMan.getSoftlinkTarget(child.getId());
      int mode=faMan.getPosixAccessMode(sMan,child,rq.getDetails().userId,rq.getDetails().groupIds);
      mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_S_IFLNK : child.isDirectory() ? Constants.SYSTEM_V_FCNTL_S_IFDIR : Constants.SYSTEM_V_FCNTL_S_IFREG;
      long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : child.getSize();
      int type=linkTarget != null ? 3 : child.isDirectory() ? 2 : 1;
      stat_ stat=new stat_(mode,child.getLinkCount(),1,1,0,size,child.getAtime(),child.getMtime(),child.getCtime(),child.getOwnerId(),child.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + child.getId(),linkTarget,type,child.getEpoch(),(int)child.getW32Attrs());
      dirContent.add(new DirectoryEntry(child.getFileName(),stat,linkTarget));
    }
    rq.setResponse(new readdirResponse(dirContent));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9724197745013008
113756,"@Override public void startRequest(MRCRequest rq){
  try {
    final getattrRequest rqArgs=(getattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String linkTarget=sMan.getSoftlinkTarget(file.getId());
    int mode=faMan.getPosixAccessMode(sMan,file,rq.getDetails().userId,rq.getDetails().groupIds);
    long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : file.getSize();
    int type=linkTarget != null ? 3 : file.isDirectory() ? 2 : 1;
    stat_ stat=new stat_(mode,file.getLinkCount(),1,1,0,size,file.getAtime(),file.getMtime(),file.getCtime(),file.getOwnerId(),file.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + file.getId(),linkTarget,type,file.getEpoch(),(int)file.getW32Attrs());
    rq.setResponse(new getattrResponse(stat));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    final getattrRequest rqArgs=(getattrRequest)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    validateContext(rq);
    final Path p=new Path(rqArgs.getPath());
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String linkTarget=sMan.getSoftlinkTarget(file.getId());
    int mode=faMan.getPosixAccessMode(sMan,file,rq.getDetails().userId,rq.getDetails().groupIds);
    mode|=linkTarget != null ? Constants.SYSTEM_V_FCNTL_S_IFLNK : file.isDirectory() ? Constants.SYSTEM_V_FCNTL_S_IFDIR : Constants.SYSTEM_V_FCNTL_S_IFREG;
    long size=linkTarget != null ? linkTarget.length() : file.isDirectory() ? 0 : file.getSize();
    int type=linkTarget != null ? 3 : file.isDirectory() ? 2 : 1;
    stat_ stat=new stat_(mode,file.getLinkCount(),1,1,0,size,file.getAtime(),file.getMtime(),file.getCtime(),file.getOwnerId(),file.getOwningGroupId(),volume.getId() + ""String_Node_Str"" + file.getId(),linkTarget,type,file.getEpoch(),(int)file.getW32Attrs());
    rq.setResponse(new getattrResponse(stat));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.955300859598854
113757,"public void sendInternalServerError(){
}","public void sendInternalServerError(Throwable rootCause){
  rpcRequest.sendInternalServerError(rootCause);
}",0.5405405405405406
113758,"public void sendException(Serializable exception){
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + exception);
  }
  rpcRequest.sendGenericException(exception);
}","public void sendException(ONCRPCException exception){
  if (Logging.isDebug()) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + exception);
  }
  rpcRequest.sendGenericException(exception);
}",0.9358669833729216
113759,"public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(new errnoException(ErrNo.EINVAL,ex.toString(),""String_Node_Str""));
    return;
  }
}","public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(ex.toString());
    return;
  }
  try {
    op.parseRPCMessage(dirRq);
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendInternalServerError(ex);
    return;
  }
}",0.8568075117370892
113760,"@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_deleteRequest request=(address_mappings_deleteRequest)rq.getRequestMessage();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    database.directInsert(ig);
    address_mappings_deleteResponse response=new address_mappings_deleteResponse();
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_deleteRequest request=(address_mappings_deleteRequest)rq.getRequestMessage();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    database.directInsert(ig);
    address_mappings_deleteResponse response=new address_mappings_deleteResponse();
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.9983552631578948
113761,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_deregisterRequest request=(service_deregisterRequest)rq.getRequestMessage();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
    database.directInsert(ig);
    service_deregisterResponse response=new service_deregisterResponse();
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_deregisterRequest request=(service_deregisterRequest)rq.getRequestMessage();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addDelete(DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
    database.directInsert(ig);
    service_deregisterResponse response=new service_deregisterResponse();
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.9982964224872232
113762,"@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_getRequest request=(address_mappings_getRequest)rq.getRequestMessage();
    byte[] result=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    if (result == null) {
      address_mappings_getResponse response=new address_mappings_getResponse();
      rq.sendSuccess(response);
    }
 else {
      AddressMappingSet set=new AddressMappingSet();
      set.deserialize(ReusableBuffer.wrap(result));
      address_mappings_getResponse response=new address_mappings_getResponse(set);
      rq.sendSuccess(response);
    }
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_getRequest request=(address_mappings_getRequest)rq.getRequestMessage();
    byte[] result=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,request.getUuid().getBytes());
    if (result == null) {
      address_mappings_getResponse response=new address_mappings_getResponse();
      rq.sendSuccess(response);
    }
 else {
      AddressMappingSet set=new AddressMappingSet();
      set.deserialize(ReusableBuffer.wrap(result));
      address_mappings_getResponse response=new address_mappings_getResponse(set);
      rq.sendSuccess(response);
    }
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.9987562189054726
113763,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_uuidRequest request=(service_get_by_uuidRequest)rq.getRequestMessage();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
    ServiceRegistrySet services=new ServiceRegistrySet();
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      services.add(dbData);
    }
    service_get_by_uuidResponse response=new service_get_by_uuidResponse(services);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_uuidRequest request=(service_get_by_uuidRequest)rq.getRequestMessage();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,request.getUuid().getBytes());
    ServiceRegistrySet services=new ServiceRegistrySet();
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      services.add(dbData);
    }
    service_get_by_uuidResponse response=new service_get_by_uuidResponse(services);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.9987277353689568
113764,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_typeRequest request=(service_get_by_typeRequest)rq.getRequestMessage();
    Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
    ServiceRegistrySet services=new ServiceRegistrySet();
    while (iter.hasNext()) {
      final Entry<byte[],byte[]> e=iter.next();
      final ServiceRegistry servEntry=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(e.getValue());
      servEntry.deserialize(buf);
      if (servEntry.getService_type() == request.getType())       services.add(servEntry);
    }
    service_get_by_typeResponse response=new service_get_by_typeResponse(services);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_get_by_typeRequest request=(service_get_by_typeRequest)rq.getRequestMessage();
    Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
    ServiceRegistrySet services=new ServiceRegistrySet();
    while (iter.hasNext()) {
      final Entry<byte[],byte[]> e=iter.next();
      final ServiceRegistry servEntry=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(e.getValue());
      servEntry.deserialize(buf);
      if (servEntry.getService_type() == request.getType())       services.add(servEntry);
    }
    service_get_by_typeResponse response=new service_get_by_typeResponse(services);
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + response);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.9584402257567984
113765,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(reg.calculateSize());
    reg.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(reg.calculateSize());
    reg.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError(th);
  }
}",0.9906191369606004
113766,"@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_setRequest request=(address_mappings_setRequest)rq.getRequestMessage();
    final AddressMappingSet mappings=request.getAddress_mappings();
    String uuid=null;
    if (mappings.size() == 0) {
      rq.sendException(new InvalidArgumentException(""String_Node_Str""));
      return;
    }
    for (    AddressMapping am : mappings) {
      if (uuid == null)       uuid=am.getUuid();
      if (!am.getUuid().equals(uuid)) {
        rq.sendException(new InvalidArgumentException(""String_Node_Str""));
        return;
      }
    }
    assert(uuid != null);
    assert(database != null);
    AddressMappingSet dbData=new AddressMappingSet();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,uuid.getBytes());
    long currentVersion=0;
    if (data != null) {
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      if (dbData.size() > 0) {
        currentVersion=dbData.get(0).getVersion();
      }
    }
    if (mappings.get(0).getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    mappings.get(0).setVersion(currentVersion);
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(mappings.calculateSize());
    mappings.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,uuid.getBytes(),newData);
    database.directInsert(ig);
    address_mappings_setResponse response=new address_mappings_setResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final address_mappings_setRequest request=(address_mappings_setRequest)rq.getRequestMessage();
    final AddressMappingSet mappings=request.getAddress_mappings();
    String uuid=null;
    if (mappings.size() == 0) {
      rq.sendException(new InvalidArgumentException(""String_Node_Str""));
      return;
    }
    for (    AddressMapping am : mappings) {
      if (uuid == null)       uuid=am.getUuid();
      if (!am.getUuid().equals(uuid)) {
        rq.sendException(new InvalidArgumentException(""String_Node_Str""));
        return;
      }
    }
    assert(uuid != null);
    assert(database != null);
    AddressMappingSet dbData=new AddressMappingSet();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,uuid.getBytes());
    long currentVersion=0;
    if (data != null) {
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      if (dbData.size() > 0) {
        currentVersion=dbData.get(0).getVersion();
      }
    }
    if (mappings.get(0).getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    mappings.get(0).setVersion(currentVersion);
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(mappings.calculateSize());
    mappings.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_ADDRMAPS,uuid.getBytes(),newData);
    database.directInsert(ig);
    address_mappings_setResponse response=new address_mappings_setResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
}",0.992685475444096
113767,"public void run(){
  notifyStarted();
  lastCheck=System.currentTimeMillis();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  while (!quit) {
    int numKeys=0;
    try {
      numKeys=selector.select(TIMEOUT_GRANULARITY);
    }
 catch (    CancelledKeyException ex) {
    }
catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ex);
      continue;
    }
    if (!toBeEstablished.isEmpty()) {
      while (true) {
        ServerConnection con=toBeEstablished.poll();
        if (con == null)         break;
        try {
          con.getChannel().register(selector,SelectionKey.OP_CONNECT | SelectionKey.OP_WRITE | SelectionKey.OP_READ,con);
        }
 catch (        ClosedChannelException ex) {
          closeConnection(con.getChannel().keyFor(selector),ex);
        }
      }
      toBeEstablished.clear();
    }
    if (numKeys > 0) {
      Set<SelectionKey> keys=selector.selectedKeys();
      Iterator<SelectionKey> iter=keys.iterator();
      while (iter.hasNext()) {
        try {
          SelectionKey key=iter.next();
          iter.remove();
          if (key.isConnectable()) {
            connectConnection(key);
          }
          if (key.isReadable()) {
            readConnection(key);
          }
          if (key.isWritable()) {
            writeConnection(key);
          }
        }
 catch (        CancelledKeyException ex) {
          continue;
        }
      }
    }
    checkForTimers();
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}","public void run(){
  notifyStarted();
  lastCheck=System.currentTimeMillis();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  while (!quit) {
    int numKeys=0;
    try {
      numKeys=selector.select(TIMEOUT_GRANULARITY);
    }
 catch (    CancelledKeyException ex) {
    }
catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ex);
      continue;
    }
    if (!toBeEstablished.isEmpty()) {
      while (true) {
        ServerConnection con=toBeEstablished.poll();
        if (con == null)         break;
        try {
          con.getChannel().register(selector,SelectionKey.OP_CONNECT | SelectionKey.OP_WRITE | SelectionKey.OP_READ,con);
        }
 catch (        ClosedChannelException ex) {
          closeConnection(con.getChannel().keyFor(selector),ex);
        }
      }
      toBeEstablished.clear();
    }
    if (numKeys > 0) {
      Set<SelectionKey> keys=selector.selectedKeys();
      Iterator<SelectionKey> iter=keys.iterator();
      while (iter.hasNext()) {
        try {
          SelectionKey key=iter.next();
          iter.remove();
          if (key.isConnectable()) {
            connectConnection(key);
          }
          if (key.isReadable()) {
            readConnection(key);
          }
          if (key.isWritable()) {
            writeConnection(key);
          }
        }
 catch (        CancelledKeyException ex) {
          continue;
        }
      }
    }
    checkForTimers();
  }
synchronized (connections) {
    for (    ServerConnection con : connections.values()) {
      for (      ONCRPCRequest rq : con.getSendQueue()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
      }
      for (      ONCRPCRequest rq : con.getRequests().values()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
      }
    }
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}",0.8879480666102173
113768,"public void sendInternalServerError(errnoException exception){
}","public void sendInternalServerError(Throwable rootCause){
}",0.7154471544715447
113769,"public void sendGarbageArgs(errnoException exception){
}","public void sendGarbageArgs(String message){
}",0.6666666666666666
113770,"public void sendGenericException(Serializable exception){
}","public void sendGenericException(ONCRPCException exception){
}",0.8099173553719008
113771,"public static ONCRPCException createException(String exception_type_name) throws java.io.IOException {
  if (exception_type_name.equals(""String_Node_Str""))   return new ProtocolException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new errnoException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new RedirectException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new ConcurrentModificationException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new InvalidArgumentException();
 else   throw new java.io.IOException(""String_Node_Str"" + exception_type_name);
}","public static ONCRPCException createException(String exception_type_name) throws java.io.IOException {
  if (exception_type_name.equals(""String_Node_Str""))   return new ProtocolException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new errnoException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new RedirectException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new MRCException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new OSDException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new ConcurrentModificationException();
 else   if (exception_type_name.equals(""String_Node_Str""))   return new InvalidArgumentException();
 else   throw new java.io.IOException(""String_Node_Str"" + exception_type_name);
}",0.8825100133511349
113772,"public XLocations(XLocSet xloc,ServiceUUID localOSD){
  this(xloc);
  System.out.println(""String_Node_Str"" + localOSD);
  for (  Replica r : replicas) {
    System.out.println(""String_Node_Str"" + r.getOSDs());
    if (r.getOSDs().contains(localOSD)) {
      localReplica=r;
      break;
    }
  }
  if (localReplica == null)   throw new IllegalArgumentException(""String_Node_Str"");
}","public XLocations(XLocSet xloc,ServiceUUID localOSD){
  this(xloc);
  for (  Replica r : replicas) {
    if (r.getOSDs().contains(localOSD)) {
      localReplica=r;
      break;
    }
  }
  if (localReplica == null)   throw new IllegalArgumentException(""String_Node_Str"");
}",0.2770167427701674
113773,"public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getOperationNumber()) {
case 1:
    return new readRequest();
case 2:
  return new truncateRequest();
case 3:
return new unlinkRequest();
case 4:
return new writeRequest();
case 100:
return new internal_get_gmaxRequest();
case 101:
return new internal_truncateRequest();
case 102:
return new internal_read_localRequest();
case 103:
return new check_objectRequest();
case 50:
return new admin_shutdownRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getOperationNumber()));
}
}","public static Request createRequest(ONCRPCRequestHeader header) throws Exception {
switch (header.getOperationNumber()) {
case 1:
    return new readRequest();
case 2:
  return new truncateRequest();
case 3:
return new unlinkRequest();
case 4:
return new writeRequest();
case 5:
return new keep_file_openRequest();
case 100:
return new internal_get_gmaxRequest();
case 101:
return new internal_truncateRequest();
case 102:
return new internal_read_localRequest();
case 103:
return new check_objectRequest();
case 50:
return new admin_shutdownRequest();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getOperationNumber()));
}
}",0.9651898734177216
113774,"public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 1:
    return new readResponse();
case 2:
  return new truncateResponse();
case 3:
return new unlinkResponse();
case 4:
return new writeResponse();
case 100:
return new internal_get_gmaxResponse();
case 101:
return new internal_truncateResponse();
case 102:
return new internal_read_localResponse();
case 103:
return new check_objectResponse();
case 50:
return new admin_shutdownResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}","public static Response createResponse(ONCRPCResponseHeader header) throws Exception {
switch (header.getXID()) {
case 1:
    return new readResponse();
case 2:
  return new truncateResponse();
case 3:
return new unlinkResponse();
case 4:
return new writeResponse();
case 5:
return new keep_file_openResponse();
case 100:
return new internal_get_gmaxResponse();
case 101:
return new internal_truncateResponse();
case 102:
return new internal_read_localResponse();
case 103:
return new check_objectResponse();
case 50:
return new admin_shutdownResponse();
default :
throw new Exception(""String_Node_Str"" + Integer.toString(header.getXID()));
}
}",0.9637389202256244
113775,"public void start(){
  try {
    rpcServer.start();
    rpcClient.start();
    rpcServer.waitForStartup();
    rpcClient.waitForStartup();
    preprocStage.start();
    delStage.start();
    stStage.start();
    preprocStage.waitForStartup();
    delStage.waitForStartup();
    stStage.waitForStartup();
    heartbeatThread.start();
    heartbeatThread.waitForStartup();
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    System.exit(1);
  }
}","public void start(){
  try {
    rpcServer.start();
    rpcClient.start();
    rpcServer.waitForStartup();
    rpcClient.waitForStartup();
    udpCom.start();
    preprocStage.start();
    delStage.start();
    stStage.start();
    udpCom.waitForStartup();
    preprocStage.waitForStartup();
    delStage.waitForStartup();
    stStage.waitForStartup();
    heartbeatThread.start();
    heartbeatThread.waitForStartup();
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    System.exit(1);
  }
}",0.8660924040720438
113776,"public OSDRequestDispatcher(OSDConfig config) throws IOException {
  this.config=config;
  assert(config.getUUID() != null);
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new HashMap();
  internalEvents=new HashMap<Class,OSDOperation>();
  initializeOperations();
  SSLOptions serverSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcServer=new RPCNIOSocketServer(config.getPort(),config.getAddress(),this,serverSSLopts);
  rpcServer.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  Striping striping=new Striping(config.getUUID(),metadataCache);
  preprocStage=new PreprocStage(this);
  preprocStage.setLifeCycleListener(this);
  stStage=new StorageStage(this,striping,metadataCache,storageLayout,1);
  stStage.setLifeCycleListener(this);
  delStage=new DeletionStage(this,metadataCache,storageLayout);
  delStage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  osdClient=new OSDClient(rpcClient);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew());
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet data=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",totalSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",freeSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(OSDInterface.getVersion())));
      ServiceRegistry me=new ServiceRegistry(config.getUUID().toString(),0,Constants.SERVICE_TYPE_OSD,""String_Node_Str"" + config.getUUID(),kvset);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,config);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + this.config.getUUID() + ""String_Node_Str"");
}","public OSDRequestDispatcher(OSDConfig config) throws IOException {
  this.config=config;
  assert(config.getUUID() != null);
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new HashMap();
  internalEvents=new HashMap<Class,OSDOperation>();
  initializeOperations();
  SSLOptions serverSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcServer=new RPCNIOSocketServer(config.getPort(),config.getAddress(),this,serverSSLopts);
  rpcServer.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  udpCom=new UDPCommunicator(config.getPort(),this);
  udpCom.setLifeCycleListener(this);
  preprocStage=new PreprocStage(this);
  preprocStage.setLifeCycleListener(this);
  stStage=new StorageStage(this,metadataCache,storageLayout,1);
  stStage.setLifeCycleListener(this);
  delStage=new DeletionStage(this,metadataCache,storageLayout);
  delStage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  osdClient=new OSDClient(rpcClient);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew());
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet data=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",totalSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",freeSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(OSDInterface.getVersion())));
      ServiceRegistry me=new ServiceRegistry(config.getUUID().toString(),0,Constants.SERVICE_TYPE_OSD,""String_Node_Str"" + config.getUUID(),kvset);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,config);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + this.config.getUUID() + ""String_Node_Str"");
}",0.9823111684958038
113777,"private void initializeOperations(){
  OSDOperation op=new ReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new WriteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new DeleteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new TruncateOperation(this);
  operations.put(op.getProcedureId(),op);
}","private void initializeOperations(){
  OSDOperation op=new ReadOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new WriteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new DeleteOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new TruncateOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new KeepFileOpenOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new InternalGetGmaxOperation(this);
  operations.put(op.getProcedureId(),op);
  op=new EventCloseFile(this);
  internalEvents.put(EventCloseFile.class,op);
}",0.7416934619506966
113778,"public void shutdown(){
  try {
    heartbeatThread.shutdown();
    heartbeatThread.waitForShutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcServer.waitForShutdown();
    rpcClient.waitForShutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    preprocStage.waitForShutdown();
    delStage.waitForShutdown();
    stStage.waitForShutdown();
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
  }
}","public void shutdown(){
  try {
    heartbeatThread.shutdown();
    heartbeatThread.waitForShutdown();
    UUIDResolver.shutdown();
    rpcServer.shutdown();
    rpcClient.shutdown();
    rpcServer.waitForShutdown();
    rpcClient.waitForShutdown();
    udpCom.shutdown();
    preprocStage.shutdown();
    delStage.shutdown();
    stStage.shutdown();
    udpCom.waitForStartup();
    preprocStage.waitForShutdown();
    delStage.waitForShutdown();
    stStage.waitForShutdown();
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"");
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
  }
}",0.8579881656804734
113779,"public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(ex.toString());
    return;
  }
  try {
    op.parseRPCMessage(dirRq);
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendInternalServerError(ex);
    return;
  }
}","public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(ex.toString());
    return;
  }
  try {
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendInternalServerError(ex);
    return;
  }
}",0.9824759751271904
113780,"public static void main(String[] args){
  try {
    Logging.start(Logging.LEVEL_ERROR);
    TimeSync.initialize(null,60000,50,""String_Node_Str"");
    Map<String,CLIParser.CliOption> options=new HashMap();
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    CLIParser.parseCLI(args,options,new ArrayList(1));
    final String hostname=options.get(""String_Node_Str"").stringValue;
    final Long port=options.get(""String_Node_Str"").numValue;
    if ((hostname == null) || (port == null)) {
      System.out.println(""String_Node_Str"");
      System.exit(1);
    }
    final RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,10000,60000);
    rpcClient.start();
    rpcClient.waitForStartup();
    final DIRClient client=new DIRClient(rpcClient,new InetSocketAddress(hostname,port.intValue()));
    if (options.get(""String_Node_Str"").switchValue && (options.get(""String_Node_Str"").stringValue != null)) {
      RPCResponse<AddressMappingSet> response=client.address_mappings_get(null,options.get(""String_Node_Str"").stringValue);
      AddressMappingSet ams=response.get();
      printAddressMappings(ams);
    }
    if (options.get(""String_Node_Str"").switchValue && (options.get(""String_Node_Str"").stringValue != null)) {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(options.get(""String_Node_Str"").stringValue);
      if (m.matches()) {
        RPCResponse<AddressMappingSet> response=client.address_mappings_get(null,options.get(""String_Node_Str"").stringValue);
        AddressMappingSet ams=response.get();
        long version=0;
        if (ams.size() > 0) {
          version=ams.get(0).getVersion();
        }
        AddressMapping am=new AddressMapping(options.get(""String_Node_Str"").stringValue,version,m.group(2),m.group(3),Integer.valueOf(m.group(4)),m.group(1),3600);
        ams.clear();
        ams.add(am);
        RPCResponse<Long> r=client.address_mappings_set(null,ams);
        r.get();
      }
 else       System.out.println(""String_Node_Str"" + options.get(""String_Node_Str"").stringValue);
    }
    rpcClient.shutdown();
    rpcClient.waitForShutdown();
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"");
    ex.printStackTrace();
    System.exit(2);
  }
catch (  Throwable ex) {
    ex.printStackTrace();
    System.exit(3);
  }
}","public static void main(String[] args){
  try {
    Logging.start(Logging.LEVEL_ERROR);
    TimeSync.initialize(null,60000,50);
    Map<String,CLIParser.CliOption> options=new HashMap();
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
    options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
    CLIParser.parseCLI(args,options,new ArrayList(1));
    final String hostname=options.get(""String_Node_Str"").stringValue;
    final Long port=options.get(""String_Node_Str"").numValue;
    if ((hostname == null) || (port == null)) {
      System.out.println(""String_Node_Str"");
      System.exit(1);
    }
    final RPCNIOSocketClient rpcClient=new RPCNIOSocketClient(null,10000,60000);
    rpcClient.start();
    rpcClient.waitForStartup();
    final DIRClient client=new DIRClient(rpcClient,new InetSocketAddress(hostname,port.intValue()));
    if (options.get(""String_Node_Str"").switchValue && (options.get(""String_Node_Str"").stringValue != null)) {
      RPCResponse<AddressMappingSet> response=client.address_mappings_get(null,options.get(""String_Node_Str"").stringValue);
      AddressMappingSet ams=response.get();
      printAddressMappings(ams);
    }
    if (options.get(""String_Node_Str"").switchValue && (options.get(""String_Node_Str"").stringValue != null)) {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(options.get(""String_Node_Str"").stringValue);
      if (m.matches()) {
        RPCResponse<AddressMappingSet> response=client.address_mappings_get(null,options.get(""String_Node_Str"").stringValue);
        AddressMappingSet ams=response.get();
        long version=0;
        if (ams.size() > 0) {
          version=ams.get(0).getVersion();
        }
        AddressMapping am=new AddressMapping(options.get(""String_Node_Str"").stringValue,version,m.group(2),m.group(3),Integer.valueOf(m.group(4)),m.group(1),3600);
        ams.clear();
        ams.add(am);
        RPCResponse<Long> r=client.address_mappings_set(null,ams);
        r.get();
      }
 else       System.out.println(""String_Node_Str"" + options.get(""String_Node_Str"").stringValue);
    }
    rpcClient.shutdown();
    rpcClient.waitForShutdown();
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"");
    ex.printStackTrace();
    System.exit(2);
  }
catch (  Throwable ex) {
    ex.printStackTrace();
    System.exit(3);
  }
}",0.996700879765396
113781,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(reg.calculateSize());
    reg.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError(th);
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    final int dataSize=reg.calculateSize();
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(dataSize);
    reg.serialize(writer);
    writer.flip();
    assert(writer.getBuffers().size() == 1);
    byte[] newData=writer.getBuffers().get(0).array();
    writer.freeBuffers();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError(ex);
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError(th);
  }
}",0.9618045112781954
113782,"boolean isLastRequestBuffer(){
  return requestBuffers.size() == requestBufSendCount - 1;
}","boolean isLastRequestBuffer(){
  return requestBuffers.size() == requestBufSendCount + 1;
}",0.989010989010989
113783,"private void writeConnection(SelectionKey key){
  final ServerConnection con=(ServerConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    while (true) {
      ONCRPCRequest send=con.getSendRequest();
      if (send == null) {
synchronized (con) {
          send=con.getSendQueue().poll();
          if (send == null) {
            key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);
            break;
          }
          con.setSendRequest(send);
        }
        final ByteBuffer fragHdrBuffer=con.getRequestFragHdr();
        final int fragmentSize=send.getRequestSize();
        final int fragHdrInt=ONCRPCRecordFragmentHeader.getFragmentHeader(fragmentSize,true);
        fragHdrBuffer.position(0);
        fragHdrBuffer.putInt(fragHdrInt);
        fragHdrBuffer.position(0);
      }
      final ByteBuffer fragHdrBuffer=con.getRequestFragHdr();
      if (fragHdrBuffer.hasRemaining()) {
        final int numBytesWritten=RPCNIOSocketServer.writeData(key,channel,fragHdrBuffer);
        if (numBytesWritten == -1) {
          closeConnection(key,new IOException(""String_Node_Str""));
          return;
        }
        if (fragHdrBuffer.hasRemaining()) {
          break;
        }
      }
 else {
        final ReusableBuffer buf=send.getCurrentRequestBuffer();
        final int numBytesWritten=RPCNIOSocketServer.writeData(key,channel,buf.getBuffer());
        if (numBytesWritten == -1) {
          closeConnection(key,new IOException(""String_Node_Str""));
          return;
        }
        if (buf.hasRemaining()) {
          break;
        }
 else {
          if (!send.isLastRequestBuffer()) {
            send.nextRequestBuffer();
          }
          con.addRequest(send.getXID(),send);
          con.setSendRequest(null);
        }
      }
    }
  }
 catch (  IOException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key,new IOException(""String_Node_Str"",ex));
  }
}","private void writeConnection(SelectionKey key){
  final ServerConnection con=(ServerConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    while (true) {
      ONCRPCRequest send=con.getSendRequest();
      if (send == null) {
synchronized (con) {
          send=con.getSendQueue().poll();
          if (send == null) {
            key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);
            break;
          }
          con.setSendRequest(send);
        }
        final ByteBuffer fragHdrBuffer=con.getRequestFragHdr();
        final int fragmentSize=send.getRequestSize();
        final int fragHdrInt=ONCRPCRecordFragmentHeader.getFragmentHeader(fragmentSize,true);
        fragHdrBuffer.position(0);
        fragHdrBuffer.putInt(fragHdrInt);
        fragHdrBuffer.position(0);
      }
      final ByteBuffer fragHdrBuffer=con.getRequestFragHdr();
      if (fragHdrBuffer.hasRemaining()) {
        final int numBytesWritten=RPCNIOSocketServer.writeData(key,channel,fragHdrBuffer);
        if (numBytesWritten == -1) {
          closeConnection(key,new IOException(""String_Node_Str""));
          return;
        }
        if (fragHdrBuffer.hasRemaining()) {
          break;
        }
      }
 else {
        final ReusableBuffer buf=send.getCurrentRequestBuffer();
        final int numBytesWritten=RPCNIOSocketServer.writeData(key,channel,buf.getBuffer());
        if (numBytesWritten == -1) {
          closeConnection(key,new IOException(""String_Node_Str""));
          return;
        }
        if (buf.hasRemaining()) {
          break;
        }
 else {
          if (!send.isLastRequestBuffer()) {
            send.nextRequestBuffer();
          }
 else {
            con.addRequest(send.getXID(),send);
            con.setSendRequest(null);
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getEndpoint());
          }
        }
      }
    }
  }
 catch (  IOException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key,new IOException(""String_Node_Str"",ex));
  }
}",0.9188138065143412
113784,"public Object getAttachment() throws InterruptedException {
  if (request != null)   return request.getAttachment();
 else   return null;
}","public Object getAttachment(){
  return this.attachment;
}",0.5482233502538071
113785,"public V get() throws ONCRPCException, IOException, InterruptedException {
  waitForResult();
  if ((ioError == null) && (remoteEx == null)) {
    V responseObject=decoder.getResult(request.getResponseFragments().get(0));
    return responseObject;
  }
 else {
    if (ioError != null)     throw ioError;
    throw remoteEx;
  }
}","public V get() throws ONCRPCException, IOException, InterruptedException {
  waitForResult();
  if ((ioError == null) && (remoteEx == null)) {
    V responseObject=decoder.getResult(request.getResponseFragments().get(0));
    return responseObject;
  }
 else {
    if (ioError != null) {
      ioError.fillInStackTrace();
      throw ioError;
    }
    remoteEx.fillInStackTrace();
    throw remoteEx;
  }
}",0.8955223880597015
113786,"public void sendResponse(ReusableBuffer serializedResponse){
  ONCRPCBufferWriter writer=new ONCRPCBufferWriter(ONCRPCBufferWriter.BUFF_SIZE);
  responseHeader=new ONCRPCResponseHeader(requestHeader.getXID(),ONCRPCResponseHeader.REPLY_STAT_MSG_ACCEPTED,ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS);
  responseHeader.serialize(writer);
  writer.put(serializedResponse);
  writer.flip();
  System.out.println(writer);
  record.setResponseBuffers(writer.getBuffers());
  record.sendResponse();
}","public void sendResponse(ReusableBuffer serializedResponse){
  ONCRPCBufferWriter writer=new ONCRPCBufferWriter(ONCRPCBufferWriter.BUFF_SIZE);
  responseHeader=new ONCRPCResponseHeader(requestHeader.getXID(),ONCRPCResponseHeader.REPLY_STAT_MSG_ACCEPTED,ONCRPCResponseHeader.ACCEPT_STAT_SUCCESS);
  responseHeader.serialize(writer);
  writer.put(serializedResponse);
  writer.flip();
  record.setResponseBuffers(writer.getBuffers());
  record.sendResponse();
}",0.9683544303797468
113787,"public void put(ReusableBuffer otherBuffer){
  currentBuffer++;
  final ReusableBuffer vb=otherBuffer.createViewBuffer();
  vb.position(otherBuffer.limit());
  buffers.add(vb);
}","public void put(ReusableBuffer otherBuffer){
  currentBuffer++;
  otherBuffer.position(otherBuffer.limit());
  buffers.add(otherBuffer);
}",0.8037974683544303
113788,"public static ReusableBuffer deserializeSerializableBuffer(ReusableBuffer data){
  final int dataSize=data.getInt();
  if (dataSize == 0)   return BufferPool.allocate(0);
  final ReusableBuffer viewbuf=data.createViewBuffer();
  viewbuf.range(viewbuf.position(),dataSize);
  if (dataSize % 4 > 0) {
    for (int k=0; k < (4 - (dataSize % 4)); k++) {
      data.get();
    }
  }
  return viewbuf;
}","public static ReusableBuffer deserializeSerializableBuffer(ReusableBuffer data){
  final int dataSize=data.getInt();
  if (dataSize == 0)   return BufferPool.allocate(0);
  final ReusableBuffer viewbuf=data.createViewBuffer();
  viewbuf.range(data.position(),dataSize);
  if (dataSize % 4 > 0) {
    for (int k=0; k < (4 - (dataSize % 4)); k++) {
      data.get();
    }
  }
  return viewbuf;
}",0.986093552465234
113789,"public static int serializableBufferLength(ReusableBuffer data){
  int len=data.capacity() + Integer.SIZE / 8;
  if (len % 4 > 0)   len+=4 - (len % 4);
  return len;
}","public static int serializableBufferLength(ReusableBuffer data){
  int len=data.remaining() + Integer.SIZE / 8;
  if (len % 4 > 0)   len+=4 - (len % 4);
  return len;
}",0.9611940298507464
113790,"public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(new errnoException(ErrNo.EINVAL,ex.toString()));
    return;
  }
}","public void processRequest(ONCRPCRequest rq){
  final ONCRPCRequestHeader hdr=rq.getRequestHeader();
  if (hdr.getInterfaceVersion() != DIRInterface.getVersion()) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROG_MISMATCH,0,""String_Node_Str""));
    return;
  }
  DIROperation op=registry.get(hdr.getOperationNumber());
  if (op == null) {
    rq.sendProtocolException(new ProtocolException(ONCRPCResponseHeader.ACCEPT_STAT_PROC_UNAVAIL,0,""String_Node_Str""));
    return;
  }
  DIRRequest dirRq=new DIRRequest(rq);
  try {
    op.parseRPCMessage(dirRq);
    numRequests++;
    op.startRequest(dirRq);
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    rq.sendGarbageArgs(new errnoException(ErrNo.EINVAL,ex.toString(),""String_Node_Str""));
    return;
  }
}",0.9886792452830188
113791,"public static String getStatusPage(DIRRequestDispatcher master,DIRConfig config) throws BabuDBException {
  final BabuDB database=master.getDatabase();
  assert(statusPageTemplate != null);
  long time=System.currentTimeMillis();
  Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,new byte[0]);
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    AddressMappingSet ams=new AddressMappingSet();
    ams.deserialize(ReusableBuffer.wrap(e.getValue()));
    final String uuid=new String(e.getKey());
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    long version=0;
    for (    AddressMapping am : ams) {
      dump.append(""String_Node_Str"");
      String endpoint=am.getProtocol() + ""String_Node_Str"" + am.getAddress()+ ""String_Node_Str""+ am.getPort();
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(am.getMatch_network());
      dump.append(""String_Node_Str"");
      dump.append(am.getTtl());
      dump.append(""String_Node_Str"");
      version=am.getVersion();
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(version);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(master.getNumConnections()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Integer.toString(master.getNumRequests()));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  return tmp;
}","public static String getStatusPage(DIRRequestDispatcher master,DIRConfig config) throws BabuDBException {
  final BabuDB database=master.getDatabase();
  assert(statusPageTemplate != null);
  long time=System.currentTimeMillis();
  Iterator<Entry<byte[],byte[]>> iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_ADDRMAPS,new byte[0]);
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    AddressMappingSet ams=new AddressMappingSet();
    ams.deserialize(ReusableBuffer.wrap(e.getValue()));
    final String uuid=new String(e.getKey());
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    long version=0;
    for (    AddressMapping am : ams) {
      dump.append(""String_Node_Str"");
      String endpoint=am.getProtocol() + ""String_Node_Str"" + am.getAddress()+ ""String_Node_Str""+ am.getPort();
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(am.getMatch_network());
      dump.append(""String_Node_Str"");
      dump.append(am.getTtl());
      dump.append(""String_Node_Str"");
      version=am.getVersion();
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(version);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  iter=database.directPrefixLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,new byte[0]);
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  while (iter.hasNext()) {
    Entry<byte[],byte[]> e=iter.next();
    final String uuid=new String(e.getKey());
    final ServiceRegistry sreg=new ServiceRegistry();
    sreg.deserialize(ReusableBuffer.wrap(e.getValue()));
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_type());
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(sreg.getService_name());
    dump.append(""String_Node_Str"");
    for (    KeyValuePair kv : sreg.getData()) {
      dump.append(""String_Node_Str"");
      dump.append(kv.getKey());
      dump.append(""String_Node_Str"");
      dump.append(kv.getValue());
      if (kv.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(new Date(Long.parseLong(kv.getValue()) * 1000));
        dump.append(""String_Node_Str"");
      }
 else       if (kv.getKey().equals(""String_Node_Str"") || kv.getKey().equals(""String_Node_Str"") || kv.getKey().endsWith(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(OutputUtils.formatBytes(Long.parseLong(kv.getValue())));
        dump.append(""String_Node_Str"");
      }
 else       if (kv.getKey().equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
      }
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(sreg.getVersion());
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(master.getNumConnections()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Integer.toString(master.getNumRequests()));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  return tmp;
}",0.7307747592353026
113792,"public SimpleRPCServerTest(){
}","public SimpleRPCServerTest(){
  Logging.start(Logging.LEVEL_DEBUG);
  TimeSync.initialize(null,100000,50,""String_Node_Str"");
}",0.3949044585987261
113793,"public DIRTest() throws IOException {
  config=SetupUtils.createNewDIRConfig();
}","public DIRTest() throws IOException {
  config=SetupUtils.createNewDIRConfig();
  Logging.start(Logging.LEVEL_DEBUG);
  TimeSync.initialize(null,100000,50,""String_Node_Str"");
}",0.6303501945525292
113794,"public Map<String,Map<String,Object>> getServiceData(){
  String uuid=config.getUUID().toString();
  OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
  String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
  long totalRAM=Runtime.getRuntime().maxMemory();
  long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
  Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
  map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
  try {
    for (    VolumeInfo vol : volumeManager.getVolumes()) {
      Map<String,Object> dsVolumeInfo=MRCOpHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
      map.put(vol.getId(),dsVolumeInfo);
    }
  }
 catch (  DatabaseException exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
  }
  return map;
}","public Map<String,Map<String,Object>> getServiceData(){
  String uuid=config.getUUID().toString();
  OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
  String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
  long totalRAM=Runtime.getRuntime().maxMemory();
  long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
  Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
  map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
  try {
    for (    VolumeInfo vol : volumeManager.getVolumes()) {
      Map<String,Object> dsVolumeInfo=MRCHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
      map.put(vol.getId(),dsVolumeInfo);
    }
  }
 catch (  DatabaseException exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
  }
  return map;
}",0.999092558983666
113795,"public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  dirClient=new DIRClient(speedyStage,config.getDirectoryService());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public Map<String,Map<String,Object>> getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
      map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
      try {
        for (        VolumeInfo vol : volumeManager.getVolumes()) {
          Map<String,Object> dsVolumeInfo=MRCOpHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
          map.put(vol.getId(),dsVolumeInfo);
        }
      }
 catch (      DatabaseException exc) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      }
      return map;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
}","public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  dirClient=new DIRClient(speedyStage,config.getDirectoryService());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public Map<String,Map<String,Object>> getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
      map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
      try {
        for (        VolumeInfo vol : volumeManager.getVolumes()) {
          Map<String,Object> dsVolumeInfo=MRCHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
          map.put(vol.getId(),dsVolumeInfo);
        }
      }
 catch (      DatabaseException exc) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      }
      return map;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
}",0.999682640431609
113796,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.fileId;
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.fileId.substring(0,i);
      fileId=Long.parseLong(rqArgs.fileId.substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.fileId + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    StripingPolicy sPol=Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy);
    if (sPol == null)     sPol=sMan.getDefaultStripingPolicy(file.getId());
    if (sPol == null)     sPol=sMan.getDefaultStripingPolicy(1);
    if (sPol == null)     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    if (!file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    if (!MRCOpHelper.isAddable(xLocList,rqArgs.osdList))     throw new UserException(""String_Node_Str"" + JSONParser.writeJSON(Converter.xLocListToList(xLocList)) + ""String_Node_Str"");
    XLoc replica=sMan.createXLoc(sPol,rqArgs.osdList.toArray(new String[rqArgs.osdList.size()]));
    if (xLocList == null)     xLocList=sMan.createXLocList(new XLoc[]{replica},1);
 else {
      XLoc[] repls=new XLoc[xLocList.getReplicaCount() + 1];
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls[i]=xLocList.getReplica(i);
      repls[repls.length - 1]=replica;
      xLocList=sMan.createXLocList(repls,xLocList.getVersion() + 1);
    }
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final FileAccessManager faMan=master.getFileAccessManager();
    final VolumeManager vMan=master.getVolumeManager();
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=rqArgs.fileId;
      int i=globalFileId.indexOf(':');
      volumeId=rqArgs.fileId.substring(0,i);
      fileId=Long.parseLong(rqArgs.fileId.substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + rqArgs.fileId + ""String_Node_Str"");
    }
    StorageManager sMan=vMan.getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      String path=target;
      Path p=new Path(path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      PathResolver res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    StripingPolicy sPol=Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy);
    if (sPol == null)     sPol=sMan.getDefaultStripingPolicy(file.getId());
    if (sPol == null)     sPol=sMan.getDefaultStripingPolicy(1);
    if (sPol == null)     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    if (!file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    XLocList xLocList=file.getXLocList();
    if (!MRCHelper.isAddable(xLocList,rqArgs.osdList))     throw new UserException(""String_Node_Str"" + JSONParser.writeJSON(Converter.xLocListToList(xLocList)) + ""String_Node_Str"");
    XLoc replica=sMan.createXLoc(sPol,rqArgs.osdList.toArray(new String[rqArgs.osdList.size()]));
    if (xLocList == null)     xLocList=sMan.createXLocList(new XLoc[]{replica},1);
 else {
      XLoc[] repls=new XLoc[xLocList.getReplicaCount() + 1];
      for (int i=0; i < xLocList.getReplicaCount(); i++)       repls[i]=xLocList.getReplica(i);
      repls[repls.length - 1]=replica;
      xLocList=sMan.createXLocList(repls,xLocList.getVersion() + 1);
    }
    file.setXLocList(xLocList);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9996818326439708
113797,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    faMan.setPosixAccessMode(sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().groupIds,rqArgs.mode,update);
    MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    faMan.setPosixAccessMode(sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().groupIds,rqArgs.mode,update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9994689325544344
113798,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (rqArgs.userId != null) {
      if (!rq.getDetails().superUser)       throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    }
 else     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.userId == null ? file.getOwnerId() : rqArgs.userId,rqArgs.groupId == null ? file.getOwningGroupId() : rqArgs.groupId);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (rqArgs.userId != null) {
      if (!rq.getDetails().superUser)       throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    }
 else     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.userId == null ? file.getOwnerId() : rqArgs.userId,rqArgs.groupId == null ? file.getOwningGroupId() : rqArgs.groupId);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9995265151515152
113799,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    FileMetadata file=sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.mode,0,update);
    sMan.setLastFileId(fileId,update);
    if (rqArgs.xAttrs != null)     for (    Entry<String,Object> attr : rqArgs.xAttrs.entrySet())     sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    FileMetadata file=sMan.createDir(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.mode,0,update);
    sMan.setLastFileId(fileId,update);
    if (rqArgs.xAttrs != null)     for (    Entry<String,Object> attr : rqArgs.xAttrs.entrySet())     sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.99946949602122
113800,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    FileMetadata file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.mode,0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    if (rqArgs.stripingPolicy != null && !rqArgs.stripingPolicy.isEmpty())     sMan.setDefaultStripingPolicy(fileId,Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy),update);
    if (rqArgs.xAttrs != null) {
      for (      Entry<String,Object> attr : rqArgs.xAttrs.entrySet())       sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    }
    if (rqArgs.open) {
      String capability=MRCOpHelper.createCapability(AccessMode.w.toString(),volume.getId(),file.getId(),0,master.getConfig().getCapabilitySecret()).toString();
      XLocList xLocList=file.getXLocList();
      if (xLocList == null || !xLocList.iterator().hasNext()) {
        xLocList=MRCOpHelper.createXLocList(Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy),xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
        file.setXLocList(xLocList);
        sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
      }
      HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
      rq.setAdditionalResponseHeaders(headers);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    long fileId=sMan.getNextFileId();
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    FileMetadata file=sMan.createFile(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.mode,0,0,false,0,0,update);
    sMan.setLastFileId(fileId,update);
    if (rqArgs.stripingPolicy != null && !rqArgs.stripingPolicy.isEmpty())     sMan.setDefaultStripingPolicy(fileId,Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy),update);
    if (rqArgs.xAttrs != null) {
      for (      Entry<String,Object> attr : rqArgs.xAttrs.entrySet())       sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    }
    if (rqArgs.open) {
      String capability=MRCHelper.createCapability(AccessMode.w.toString(),volume.getId(),file.getId(),0,master.getConfig().getCapabilitySecret()).toString();
      XLocList xLocList=file.getXLocList();
      if (xLocList == null || !xLocList.iterator().hasNext()) {
        xLocList=MRCHelper.createXLocList(Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy),xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
        file.setXLocList(xLocList);
        sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
      }
      HTTPHeaders headers=MRCHelper.createXCapHeaders(capability,xLocList);
      rq.setAdditionalResponseHeaders(headers);
      MRCHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
      MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9983277591973244
113801,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path lp=new Path(rqArgs.linkPath);
    final Path tp=new Path(rqArgs.targetPath);
    if (!lp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.EXDEV,""String_Node_Str"");
    final VolumeInfo volume=vMan.getVolumeByName(lp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver lRes=new PathResolver(sMan,lp);
    final PathResolver tRes=new PathResolver(sMan,tp);
    faMan.checkSearchPermission(sMan,lRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,lRes.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    lRes.checkIfFileExistsAlready();
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    tRes.checkIfFileDoesNotExist();
    FileMetadata target=tRes.getFile();
    if (target.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.link(target,lRes.getParentDirId(),lRes.getFileName(),update);
    MRCOpHelper.updateFileTimes(lRes.getParentsParentId(),lRes.getParentDir(),false,true,true,sMan,update);
    MRCOpHelper.updateFileTimes(tRes.getParentDirId(),target,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path lp=new Path(rqArgs.linkPath);
    final Path tp=new Path(rqArgs.targetPath);
    if (!lp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.EXDEV,""String_Node_Str"");
    final VolumeInfo volume=vMan.getVolumeByName(lp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver lRes=new PathResolver(sMan,lp);
    final PathResolver tRes=new PathResolver(sMan,tp);
    faMan.checkSearchPermission(sMan,lRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,lRes.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    lRes.checkIfFileExistsAlready();
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    tRes.checkIfFileDoesNotExist();
    FileMetadata target=tRes.getFile();
    if (target.isDirectory())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.link(target,lRes.getParentDirId(),lRes.getFileName(),update);
    MRCHelper.updateFileTimes(lRes.getParentsParentId(),lRes.getParentDir(),false,true,true,sMan,update);
    MRCHelper.updateFileTimes(tRes.getParentDirId(),target,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9990842490842492
113802,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.linkPath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long fileId=sMan.getNextFileId();
    sMan.createSymLink(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.targetPath,update);
    sMan.setLastFileId(fileId,update);
    MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.linkPath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    long fileId=sMan.getNextFileId();
    sMan.createSymLink(fileId,res.getParentDirId(),res.getFileName(),time,time,time,rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.targetPath,update);
    sMan.setLastFileId(fileId,update);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9993939393939394
113803,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.path);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    HTTPHeaders xCapHeaders=null;
    if (!file.isDirectory()) {
      String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
      String capability=MRCOpHelper.createCapability(aMode,volume.getId(),file.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
      xCapHeaders=MRCOpHelper.createXCapHeaders(capability,file.getXLocList());
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     xCapHeaders=null;
    rq.setAdditionalResponseHeaders(xCapHeaders);
    MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (file.getLinkCount() > 1)     MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.path);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    HTTPHeaders xCapHeaders=null;
    if (!file.isDirectory()) {
      String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
      String capability=MRCHelper.createCapability(aMode,volume.getId(),file.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
      xCapHeaders=MRCHelper.createXCapHeaders(capability,file.getXLocList());
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     xCapHeaders=null;
    rq.setAdditionalResponseHeaders(xCapHeaders);
    MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (file.getLinkCount() > 1)     MRCHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9983395599833956
113804,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    String value=null;
    if (rqArgs.attrKey.startsWith(""String_Node_Str""))     value=MRCOpHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,rqArgs.attrKey.substring(9));
 else {
      value=sMan.getXAttr(file.getId(),rq.getDetails().userId,rqArgs.attrKey);
      if (value == null)       value=sMan.getXAttr(file.getId(),StorageManager.GLOBAL_ID,rqArgs.attrKey);
      if (value == null)       value=""String_Node_Str"";
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(value).getBytes()));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    String value=null;
    if (rqArgs.attrKey.startsWith(""String_Node_Str""))     value=MRCHelper.getSysAttrValue(master.getConfig(),sMan,master.getOSDStatusManager(),volume,res.toString(),file,rqArgs.attrKey.substring(9));
 else {
      value=sMan.getXAttr(file.getId(),rq.getDetails().userId,rqArgs.attrKey);
      if (value == null)       value=sMan.getXAttr(file.getId(),StorageManager.GLOBAL_ID,rqArgs.attrKey);
      if (value == null)       value=""String_Node_Str"";
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(value).getBytes()));
    finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9994897959183674
113805,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path sp=new Path(rqArgs.sourcePath);
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.targetPath);
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    if (sp.equals(tp)) {
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.DELETE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
if (target.getLinkCount() == 1) {
  String capability=MRCOpHelper.createCapability(aMode,volume.getId(),target.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
  HTTPHeaders xCapHeaders=MRCOpHelper.createXCapHeaders(capability,target.getXLocList());
  rq.setAdditionalResponseHeaders(xCapHeaders);
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCOpHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCOpHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Exception exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path sp=new Path(rqArgs.sourcePath);
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.targetPath);
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    if (sp.equals(tp)) {
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.DELETE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
if (target.getLinkCount() == 1) {
  String capability=MRCHelper.createCapability(aMode,volume.getId(),target.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
  HTTPHeaders xCapHeaders=MRCHelper.createXCapHeaders(capability,target.getXLocList());
  rq.setAdditionalResponseHeaders(xCapHeaders);
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Exception exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}",0.999264570693142
113806,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    AccessMode mode=null;
    try {
      mode=AccessMode.valueOf(rqArgs.accessMode);
    }
 catch (    IllegalArgumentException exc) {
      throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.accessMode);
    }
    if ((mode == AccessMode.w || mode == AccessMode.a || mode == AccessMode.ga || mode == AccessMode.t) && file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.accessMode,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (mode == AccessMode.t) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    String capability=MRCOpHelper.createCapability(rqArgs.accessMode,volume.getId(),file.getId(),file.getIssuedEpoch(),master.getConfig().getCapabilitySecret()).toString();
    XLocList xLocList=file.getXLocList();
    if (xLocList == null || !xLocList.iterator().hasNext()) {
      StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
      xLocList=MRCOpHelper.createXLocList(sp,xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
      file.setXLocList(xLocList);
      if (update == null)       update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
    HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
    rq.setAdditionalResponseHeaders(headers);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (update == null)     update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    AccessMode mode=null;
    try {
      mode=AccessMode.valueOf(rqArgs.accessMode);
    }
 catch (    IllegalArgumentException exc) {
      throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.accessMode);
    }
    if ((mode == AccessMode.w || mode == AccessMode.a || mode == AccessMode.ga || mode == AccessMode.t) && file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.accessMode,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (mode == AccessMode.t) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    String capability=MRCHelper.createCapability(rqArgs.accessMode,volume.getId(),file.getId(),file.getIssuedEpoch(),master.getConfig().getCapabilitySecret()).toString();
    XLocList xLocList=file.getXLocList();
    if (xLocList == null || !xLocList.iterator().hasNext()) {
      StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
      xLocList=MRCHelper.createXLocList(sp,xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
      file.setXLocList(xLocList);
      if (update == null)       update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
    HTTPHeaders headers=MRCHelper.createXCapHeaders(capability,xLocList);
    rq.setAdditionalResponseHeaders(headers);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (update == null)     update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9988479262672812
113807,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.READ_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (!master.getConfig().isNoAtime()) {
      update=sMan.createAtomicDBUpdate(master,rq);
      MRCOpHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    }
    Map<String,Map<String,Object>> result=new HashMap<String,Map<String,Object>>();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      Map<String,Object> statInfo=MRCOpHelper.createStatInfo(sMan,faMan,child,sMan.getSoftlinkTarget(child.getId()),rq.getDetails().userId,rq.getDetails().groupIds,null,null,null);
      result.put(child.getFileName(),statInfo);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(result).getBytes()));
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.READ_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (!master.getConfig().isNoAtime()) {
      update=sMan.createAtomicDBUpdate(master,rq);
      MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    }
    Map<String,Map<String,Object>> result=new HashMap<String,Map<String,Object>>();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext()) {
      FileMetadata child=it.next();
      Map<String,Object> statInfo=MRCHelper.createStatInfo(sMan,faMan,child,sMan.getSoftlinkTarget(child.getId()),rq.getDetails().userId,rq.getDetails().groupIds,null,null,null);
      result.put(child.getFileName(),statInfo);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(result).getBytes()));
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9991564740615774
113808,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.READ_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (!master.getConfig().isNoAtime()) {
      update=sMan.createAtomicDBUpdate(master,rq);
      MRCOpHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    }
    List<Object> dirList=new LinkedList<Object>();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext())     dirList.add(it.next().getFileName());
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(dirList).getBytes()));
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPermission(FileAccessManager.READ_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (!master.getConfig().isNoAtime()) {
      update=sMan.createAtomicDBUpdate(master,rq);
      MRCHelper.updateFileTimes(res.getParentDirId(),file,true,false,false,sMan,update);
    }
    List<Object> dirList=new LinkedList<Object>();
    Iterator<FileMetadata> it=sMan.getChildren(res.getFile().getId());
    while (it.hasNext())     dirList.add(it.next().getFileName());
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(dirList).getBytes()));
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9995258416311048
113809,"@Override public void run(){
  try {
    notifyStarted();
    while (!quit) {
      final ONCRPCRequest rq=queue.take();
      processRequest(rq);
    }
  }
 catch (  InterruptedException ex) {
    quit=true;
  }
catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    notifyCrashed(ex);
  }
  notifyStopped();
}","@Override public void run(){
  try {
    notifyStarted();
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
    while (!quit) {
      final ONCRPCRequest rq=queue.take();
      processRequest(rq);
    }
  }
 catch (  InterruptedException ex) {
    quit=true;
  }
catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    notifyCrashed(ex);
  }
  notifyStopped();
}",0.9086021505376344
113810,"@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(reg.calculateSize());
    reg.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
}","@Override public void startRequest(DIRRequest rq){
  try {
    final service_registerRequest request=(service_registerRequest)rq.getRequestMessage();
    final ServiceRegistry reg=request.getService();
    byte[] data=database.directLookup(DIRRequestDispatcher.DB_NAME,DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes());
    long currentVersion=0;
    if (data != null) {
      ServiceRegistry dbData=new ServiceRegistry();
      ReusableBuffer buf=ReusableBuffer.wrap(data);
      dbData.deserialize(buf);
      currentVersion=dbData.getVersion();
    }
    if (reg.getVersion() != currentVersion) {
      rq.sendException(new ConcurrentModificationException());
      return;
    }
    currentVersion++;
    reg.setVersion(currentVersion);
    reg.getData().add(new KeyValuePair(""String_Node_Str"",Long.toString(System.currentTimeMillis() / 1000l)));
    ONCRPCBufferWriter writer=new ONCRPCBufferWriter(reg.calculateSize());
    reg.serialize(writer);
    byte[] newData=writer.getBuffers().get(0).array();
    BabuDBInsertGroup ig=database.createInsertGroup(DIRRequestDispatcher.DB_NAME);
    ig.addInsert(DIRRequestDispatcher.INDEX_ID_SERVREG,reg.getUuid().getBytes(),newData);
    database.directInsert(ig);
    service_registerResponse response=new service_registerResponse(currentVersion);
    rq.sendSuccess(response);
  }
 catch (  BabuDBException ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    rq.sendInternalServerError();
  }
catch (  Throwable th) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,th);
    rq.sendInternalServerError();
  }
}",0.9231815091774304
113811,"public RPCNIOSocketClient(SSLOptions sslOptions,int requestTimeout,int connectionTimeout) throws IOException {
  super(""String_Node_Str"");
  if (requestTimeout >= connectionTimeout - TIMEOUT_GRANULARITY * 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + TIMEOUT_GRANULARITY * 2 + ""String_Node_Str"");
  }
  this.requestTimeout=requestTimeout;
  this.connectionTimeout=connectionTimeout;
  connections=new HashMap();
  selector=Selector.open();
  this.sslOptions=sslOptions;
  quit=false;
  transactionId=new AtomicInteger(1);
}","public RPCNIOSocketClient(SSLOptions sslOptions,int requestTimeout,int connectionTimeout) throws IOException {
  super(""String_Node_Str"");
  if (requestTimeout >= connectionTimeout - TIMEOUT_GRANULARITY * 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + TIMEOUT_GRANULARITY * 2 + ""String_Node_Str"");
  }
  this.requestTimeout=requestTimeout;
  this.connectionTimeout=connectionTimeout;
  connections=new HashMap();
  selector=Selector.open();
  this.sslOptions=sslOptions;
  quit=false;
  transactionId=new AtomicInteger(1);
  toBeEstablished=new ConcurrentLinkedQueue<ServerConnection>();
}",0.9433304272013948
113812,"private void checkForTimers(){
  long now=TimeSync.getLocalSystemTime();
  if (now >= lastCheck + TIMEOUT_GRANULARITY) {
synchronized (connections) {
      Iterator<ServerConnection> conIter=connections.values().iterator();
      while (conIter.hasNext()) {
        final ServerConnection con=conIter.next();
        if (con.getLastUsed() < (TimeSync.getLocalSystemTime() - connectionTimeout)) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
          }
          try {
            conIter.remove();
            closeConnection(con.getChannel().keyFor(selector),null);
          }
 catch (          Exception ex) {
          }
        }
 else {
          List<ONCRPCRequest> cancelRq=new LinkedList();
synchronized (con) {
            Iterator<ONCRPCRequest> iter=con.getRequests().values().iterator();
            while (iter.hasNext()) {
              final ONCRPCRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < TimeSync.getLocalSystemTime()) {
                cancelRq.add(rq);
                iter.remove();
              }
            }
            iter=con.getSendQueue().iterator();
            while (iter.hasNext()) {
              final ONCRPCRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < TimeSync.getLocalSystemTime()) {
                cancelRq.add(rq);
                iter.remove();
              }
 else {
                break;
              }
            }
          }
          for (          ONCRPCRequest rq : cancelRq) {
            rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
          }
        }
      }
      lastCheck=now;
    }
  }
}","private void checkForTimers(){
  long now=System.currentTimeMillis();
  if (now >= lastCheck + TIMEOUT_GRANULARITY) {
synchronized (connections) {
      Iterator<ServerConnection> conIter=connections.values().iterator();
      while (conIter.hasNext()) {
        final ServerConnection con=conIter.next();
        if (con.getLastUsed() < (now - connectionTimeout)) {
          if (Logging.isDebug()) {
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
          }
          try {
            conIter.remove();
            closeConnection(con.getChannel().keyFor(selector),null);
          }
 catch (          Exception ex) {
          }
        }
 else {
          List<ONCRPCRequest> cancelRq=new LinkedList();
synchronized (con) {
            Iterator<ONCRPCRequest> iter=con.getRequests().values().iterator();
            while (iter.hasNext()) {
              final ONCRPCRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
            }
            iter=con.getSendQueue().iterator();
            while (iter.hasNext()) {
              final ONCRPCRequest rq=iter.next();
              if (rq.getTimeQueued() + requestTimeout < now) {
                cancelRq.add(rq);
                iter.remove();
              }
 else {
                break;
              }
            }
          }
          for (          ONCRPCRequest rq : cancelRq) {
            rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
          }
        }
      }
      lastCheck=now;
    }
  }
}",0.9621460506706409
113813,"private void connectConnection(SelectionKey key){
  final ServerConnection con=(ServerConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    if (channel.isConnectionPending()) {
      channel.finishConnect();
    }
synchronized (con) {
      if (!con.getSendQueue().isEmpty()) {
        key.interestOps(SelectionKey.OP_WRITE | SelectionKey.OP_READ);
      }
    }
    con.connected();
  }
 catch (  IOException ex) {
    con.connectFailed();
    closeConnection(key,new IOException(""String_Node_Str"",ex));
  }
}","private void connectConnection(SelectionKey key){
  final ServerConnection con=(ServerConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    if (channel.isConnectionPending()) {
      channel.finishConnect();
    }
synchronized (con) {
      if (!con.getSendQueue().isEmpty()) {
        key.interestOps(SelectionKey.OP_WRITE | SelectionKey.OP_READ);
      }
    }
    con.connected();
    if (Logging.isDebug())     Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getChannel().socket().getLocalSocketAddress() + ""String_Node_Str""+ con.getEndpoint());
  }
 catch (  IOException ex) {
    con.connectFailed();
    closeConnection(key,new IOException(""String_Node_Str"",ex));
  }
}",0.8533123028391167
113814,"public void run(){
  notifyStarted();
  lastCheck=System.currentTimeMillis();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  while (!quit) {
    int numKeys=0;
    try {
      numKeys=selector.select(TIMEOUT_GRANULARITY);
    }
 catch (    CancelledKeyException ex) {
    }
catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ex);
      continue;
    }
    if (numKeys > 0) {
      Set<SelectionKey> keys=selector.selectedKeys();
      Iterator<SelectionKey> iter=keys.iterator();
      while (iter.hasNext()) {
        try {
          SelectionKey key=iter.next();
          iter.remove();
          if (key.isConnectable()) {
            connectConnection(key);
          }
          if (key.isReadable()) {
            readConnection(key);
          }
          if (key.isWritable()) {
            writeConnection(key);
          }
        }
 catch (        CancelledKeyException ex) {
          continue;
        }
      }
    }
    checkForTimers();
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}","public void run(){
  notifyStarted();
  lastCheck=System.currentTimeMillis();
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  while (!quit) {
    int numKeys=0;
    try {
      numKeys=selector.select(TIMEOUT_GRANULARITY);
    }
 catch (    CancelledKeyException ex) {
    }
catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + ex);
      continue;
    }
    if (!toBeEstablished.isEmpty()) {
      while (true) {
        ServerConnection con=toBeEstablished.poll();
        if (con == null)         break;
        try {
          con.getChannel().register(selector,SelectionKey.OP_CONNECT | SelectionKey.OP_WRITE | SelectionKey.OP_READ,con);
        }
 catch (        ClosedChannelException ex) {
          closeConnection(con.getChannel().keyFor(selector),ex);
        }
      }
      toBeEstablished.clear();
    }
    if (numKeys > 0) {
      Set<SelectionKey> keys=selector.selectedKeys();
      Iterator<SelectionKey> iter=keys.iterator();
      while (iter.hasNext()) {
        try {
          SelectionKey key=iter.next();
          iter.remove();
          if (key.isConnectable()) {
            connectConnection(key);
          }
          if (key.isReadable()) {
            readConnection(key);
          }
          if (key.isWritable()) {
            writeConnection(key);
          }
        }
 catch (        CancelledKeyException ex) {
          continue;
        }
      }
    }
    checkForTimers();
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}",0.8274319791278419
113815,"private void sendRequest(InetSocketAddress server,ONCRPCRequest request){
  ServerConnection con=null;
synchronized (connections) {
    con=connections.get(server);
    if (con == null) {
      con=new ServerConnection(server);
      connections.put(server,con);
    }
  }
synchronized (con) {
    boolean isEmpty=con.getSendQueue().isEmpty();
    request.queued();
    con.useConnection();
    con.getSendQueue().add(request);
    if (!con.isConnected()) {
      establishConnection(server,con);
    }
 else {
      if (isEmpty) {
        final SelectionKey key=con.getChannel().keyFor(selector);
        key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
      }
    }
  }
}","private void sendRequest(InetSocketAddress server,ONCRPCRequest request){
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + request + ""String_Node_Str""+ transactionId.get());
  ServerConnection con=null;
synchronized (connections) {
    con=connections.get(server);
    if (con == null) {
      con=new ServerConnection(server);
      connections.put(server,con);
    }
  }
synchronized (con) {
    boolean isEmpty=con.getSendQueue().isEmpty();
    request.queued();
    con.useConnection();
    con.getSendQueue().add(request);
    if (!con.isConnected()) {
      establishConnection(server,con);
    }
 else {
      if (isEmpty) {
        final SelectionKey key=con.getChannel().keyFor(selector);
        key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
      }
    }
  }
}",0.9213180901143242
113816,"private void establishConnection(InetSocketAddress server,ServerConnection con){
  if (con.canReconnect()) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + server);
    }
    ChannelIO channel;
    try {
      if (sslOptions == null) {
        channel=new ChannelIO(SocketChannel.open());
      }
 else {
        channel=new SSLChannelIO(SocketChannel.open(),sslOptions,true);
      }
      channel.configureBlocking(false);
      channel.socket().setTcpNoDelay(true);
      channel.socket().setReceiveBufferSize(256 * 1024);
      channel.connect(server);
      con.setChannel(channel);
      channel.register(selector,SelectionKey.OP_CONNECT | SelectionKey.OP_WRITE | SelectionKey.OP_READ,con);
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getEndpoint());
      }
      con.connectFailed();
      for (      ONCRPCRequest rq : con.getSendQueue()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str"",ex));
      }
      con.getSendQueue().clear();
    }
  }
 else {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getEndpoint());
    }
synchronized (con) {
      for (      ONCRPCRequest rq : con.getSendQueue()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
      }
      con.getSendQueue().clear();
    }
  }
}","private void establishConnection(InetSocketAddress server,ServerConnection con){
  if (con.canReconnect()) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + server);
    }
    ChannelIO channel;
    try {
      if (sslOptions == null) {
        channel=new ChannelIO(SocketChannel.open());
      }
 else {
        channel=new SSLChannelIO(SocketChannel.open(),sslOptions,true);
      }
      channel.configureBlocking(false);
      channel.socket().setTcpNoDelay(true);
      channel.socket().setReceiveBufferSize(256 * 1024);
      channel.connect(server);
      con.setChannel(channel);
      toBeEstablished.add(con);
      selector.wakeup();
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
    }
 catch (    IOException ex) {
      if (Logging.isDebug()) {
        Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getEndpoint());
      }
      con.connectFailed();
      for (      ONCRPCRequest rq : con.getSendQueue()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str"",ex));
      }
      con.getSendQueue().clear();
    }
  }
 else {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getEndpoint());
    }
synchronized (con) {
      for (      ONCRPCRequest rq : con.getSendQueue()) {
        rq.getListener().requestFailed(rq,new IOException(""String_Node_Str""));
      }
      con.getSendQueue().clear();
    }
  }
}",0.9280913978494624
113817,"public void freeBuffers(){
  request.freeBuffers();
}","public void freeBuffers(){
  if (request != null)   request.freeBuffers();
}",0.8217054263565892
113818,"public ClientConnection(ChannelIO channel){
  this.channel=channel;
  this.openRequests=new AtomicInteger(0);
  this.pendingResponses=new ConcurrentLinkedQueue();
  this.connectionClosed=false;
  this.receiveFragHdr=ByteBuffer.allocate(ONCRPCRecordFragmentHeader.getFragmentHeaderSize());
  this.sendFragHdr=ByteBuffer.allocate(ONCRPCRecordFragmentHeader.getFragmentHeaderSize());
  this.sendFragHdr.position(sendFragHdr.capacity());
  this.sendingFragmentHeader=true;
}","public ClientConnection(ChannelIO channel){
  this.channel=channel;
  this.openRequests=new AtomicInteger(0);
  this.pendingResponses=new ConcurrentLinkedQueue();
  this.connectionClosed=false;
  this.receiveFragHdr=ByteBuffer.allocate(ONCRPCRecordFragmentHeader.getFragmentHeaderSize());
  this.sendFragHdr=ByteBuffer.allocate(ONCRPCRecordFragmentHeader.getFragmentHeaderSize());
  this.sendFragHdr.position(sendFragHdr.capacity());
  this.sendingFragmentHeader=true;
  try {
    this.clientAddress=channel.socket().getRemoteSocketAddress();
  }
 catch (  Exception ex) {
  }
}",0.8969465648854962
113819,"/** 
 * read data from a readable connection
 * @param key a readable key
 */
private void readConnection(SelectionKey key){
  final ClientConnection con=(ClientConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    if (con.getOpenRequests().get() > MAX_CLIENT_QUEUE) {
      key.interestOps(key.interestOps() & ~SelectionKey.OP_READ);
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress());
      return;
    }
    while (true) {
      final ByteBuffer fragmentHeader=con.getReceiveFragHdr();
      if (fragmentHeader.hasRemaining()) {
        final int numBytesRead=readData(key,channel,fragmentHeader);
        if (numBytesRead == -1) {
          closeConnection(key);
          return;
        }
        if (fragmentHeader.hasRemaining()) {
          break;
        }
 else {
          fragmentHeader.position(0);
          final int fragmentHeaderInt=fragmentHeader.getInt();
          final int fragmentSize=ONCRPCRecordFragmentHeader.getFragmentLength(fragmentHeaderInt);
          final boolean lastFragment=ONCRPCRecordFragmentHeader.isLastFragment(fragmentHeaderInt);
          if ((fragmentSize <= 0) || (fragmentSize >= MAX_FRAGMENT_SIZE)) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fragmentSize + ""String_Node_Str"");
            }
            closeConnection(key);
            break;
          }
          final ReusableBuffer fragment=BufferPool.allocate(fragmentSize);
          ONCRPCRecord rq=con.getReceive();
          if (rq == null) {
            rq=new ONCRPCRecord(this,con);
            con.setReceive(rq);
          }
          rq.addNewRequestFragment(fragment);
          rq.setAllFragmentsReceived(lastFragment);
        }
      }
 else {
        final ONCRPCRecord rq=con.getReceive();
        final ReusableBuffer fragment=rq.getLastRequestFragment();
        final int numBytesRead=readData(key,channel,fragment.getBuffer());
        if (numBytesRead == -1) {
          closeConnection(key);
          return;
        }
        if (fragment.hasRemaining()) {
          break;
        }
 else {
          fragmentHeader.position(0);
          if (rq.isAllFragmentsReceived()) {
            con.setReceive(null);
            if (Logging.tracingEnabled()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,rq.toString());
            }
            con.getOpenRequests().incrementAndGet();
            receiveRequest(key,rq);
          }
        }
      }
    }
  }
 catch (  ClosedByInterruptException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress() + ""String_Node_Str"");
    }
    closeConnection(key);
  }
catch (  IOException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key);
  }
}","/** 
 * read data from a readable connection
 * @param key a readable key
 */
private void readConnection(SelectionKey key){
  final ClientConnection con=(ClientConnection)key.attachment();
  final ChannelIO channel=con.getChannel();
  try {
    if (con.getOpenRequests().get() > MAX_CLIENT_QUEUE) {
      key.interestOps(key.interestOps() & ~SelectionKey.OP_READ);
      Logging.logMessage(Logging.LEVEL_WARN,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress());
      return;
    }
    while (true) {
      final ByteBuffer fragmentHeader=con.getReceiveFragHdr();
      if (fragmentHeader.hasRemaining()) {
        final int numBytesRead=readData(key,channel,fragmentHeader);
        if (numBytesRead == -1) {
          closeConnection(key);
          return;
        }
        if (fragmentHeader.hasRemaining()) {
          break;
        }
 else {
          fragmentHeader.position(0);
          final int fragmentHeaderInt=fragmentHeader.getInt();
          final int fragmentSize=ONCRPCRecordFragmentHeader.getFragmentLength(fragmentHeaderInt);
          final boolean lastFragment=ONCRPCRecordFragmentHeader.isLastFragment(fragmentHeaderInt);
          if ((fragmentSize <= 0) || (fragmentSize >= MAX_FRAGMENT_SIZE)) {
            if (Logging.isDebug()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + fragmentSize + ""String_Node_Str"");
            }
            closeConnection(key);
            break;
          }
          final ReusableBuffer fragment=BufferPool.allocate(fragmentSize);
          ONCRPCRecord rq=con.getReceive();
          if (rq == null) {
            rq=new ONCRPCRecord(this,con);
            con.setReceive(rq);
          }
          rq.addNewRequestFragment(fragment);
          rq.setAllFragmentsReceived(lastFragment);
        }
      }
 else {
        final ONCRPCRecord rq=con.getReceive();
        final ReusableBuffer fragment=rq.getLastRequestFragment();
        final int numBytesRead=readData(key,channel,fragment.getBuffer());
        if (numBytesRead == -1) {
          closeConnection(key);
          return;
        }
        if (fragment.hasRemaining()) {
          break;
        }
 else {
          fragmentHeader.position(0);
          if (rq.isAllFragmentsReceived()) {
            con.setReceive(null);
            if (Logging.tracingEnabled()) {
              Logging.logMessage(Logging.LEVEL_DEBUG,this,rq.toString());
            }
            con.getOpenRequests().incrementAndGet();
            Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
            receiveRequest(key,rq);
          }
        }
      }
    }
  }
 catch (  ClosedByInterruptException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + con.getChannel().socket().getRemoteSocketAddress() + ""String_Node_Str"");
    }
    closeConnection(key);
  }
catch (  IOException ex) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    closeConnection(key);
  }
}",0.9
113820,"/** 
 * sends a response.
 * @param request the request
 */
public void sendResponse(ONCRPCRecord request){
  assert(request.getResponseBuffers() != null);
  final ClientConnection connection=request.getConnection();
  if (!connection.isConnectionClosed()) {
synchronized (connection) {
      boolean isEmpty=connection.getPendingResponses().isEmpty();
      connection.addPendingResponse(request);
      if (isEmpty) {
        SelectionKey key=connection.getChannel().keyFor(selector);
        key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
      }
    }
    selector.wakeup();
  }
 else {
    request.freeBuffers();
  }
}","/** 
 * sends a response.
 * @param request the request
 */
public void sendResponse(ONCRPCRecord request){
  assert(request.getResponseBuffers() != null);
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
  final ClientConnection connection=request.getConnection();
  if (!connection.isConnectionClosed()) {
synchronized (connection) {
      boolean isEmpty=connection.getPendingResponses().isEmpty();
      connection.addPendingResponse(request);
      if (isEmpty) {
        SelectionKey key=connection.getChannel().keyFor(selector);
        key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
      }
    }
    selector.wakeup();
  }
 else {
    request.freeBuffers();
  }
}",0.9506726457399104
113821,"public void shutdown() throws Exception {
  pinkyStage.shutdown();
  pinkyStage.waitForShutdown();
  heartbeatThread.shutdown();
  osdMonitor.shutdown();
  osdMonitor.waitForShutdown();
  procStage.shutdown();
  procStage.waitForShutdown();
  UUIDResolver.shutdown();
  speedyStage.shutdown();
  speedyStage.waitForShutdown();
  volumeManager.shutdown();
  TimeSync.getInstance().shutdown();
  rpcClient.shutdown();
  rpcClient.waitForShutdown();
}","public void shutdown() throws Exception {
  pinkyStage.shutdown();
  pinkyStage.waitForShutdown();
  rpcClient.shutdown();
  rpcClient.waitForShutdown();
  heartbeatThread.shutdown();
  osdMonitor.shutdown();
  osdMonitor.waitForShutdown();
  procStage.shutdown();
  procStage.waitForShutdown();
  UUIDResolver.shutdown();
  speedyStage.shutdown();
  speedyStage.waitForShutdown();
  volumeManager.shutdown();
  TimeSync.getInstance().shutdown();
}",0.8772321428571429
113822,"public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  SSLOptions sslOptions=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(sslOptions) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  rpcClient=new RPCNIOSocketClient(sslOptions,RPC_TIMEOUT,CONNECTION_TIMEOUT);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet sregs=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(MRCInterface.getVersion())));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      ServiceRegistry mrcReg=new ServiceRegistry(uuid,0,Constants.SERVICE_TYPE_MRC,""String_Node_Str"" + uuid,kvset);
      sregs.add(mrcReg);
      try {
        for (        VolumeInfo vol : volumeManager.getVolumes()) {
          ServiceRegistry dsVolumeInfo=MRCHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
          sregs.add(dsVolumeInfo);
        }
      }
 catch (      DatabaseException exc) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      }
      return sregs;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
}","public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  SSLOptions sslOptions=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(sslOptions) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  rpcClient=new RPCNIOSocketClient(sslOptions,RPC_TIMEOUT,CONNECTION_TIMEOUT);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet sregs=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(MRCInterface.getVersion())));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      ServiceRegistry mrcReg=new ServiceRegistry(uuid,0,Constants.SERVICE_TYPE_MRC,""String_Node_Str"" + uuid,kvset);
      sregs.add(mrcReg);
      try {
        for (        VolumeInfo vol : volumeManager.getVolumes()) {
          ServiceRegistry dsVolumeInfo=MRCHelper.createDSVolumeInfo(vol,osdMonitor,uuid);
          sregs.add(dsVolumeInfo);
        }
      }
 catch (      DatabaseException exc) {
        Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      }
      return sregs;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
}",0.9959045332580144
113823,"/** 
 * Main loop.
 */
public void run(){
  RPCResponse<ServiceRegistrySet> r=null;
  try {
    r=client.service_get_by_type(null,Constants.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    this.notifyCrashed(exc);
  }
 finally {
    if (r != null)     r.freeBuffers();
  }
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getDirectoryService());
  notifyStarted();
  while (!quit) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
    r=null;
    try {
      r=client.service_get_by_type(null,Constants.SERVICE_TYPE_OSD);
      knownOSDs=r.get();
      evaluateResponse(knownOSDs);
    }
 catch (    Exception exc) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    }
 finally {
      if (r != null)       r.freeBuffers();
    }
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
synchronized (this) {
      try {
        this.wait(checkIntervalMillis);
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}","/** 
 * Main loop.
 */
public void run(){
  RPCResponse<ServiceRegistrySet> r=null;
  try {
    r=client.service_get_by_type(null,Constants.SERVICE_TYPE_OSD);
    knownOSDs=r.get();
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    this.notifyCrashed(exc);
  }
 finally {
    if (r != null)     r.freeBuffers();
  }
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getDirectoryService());
  notifyStarted();
  while (!quit) {
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
    r=null;
    try {
      r=client.service_get_by_type(null,Constants.SERVICE_TYPE_OSD);
      knownOSDs=r.get();
      evaluateResponse(knownOSDs);
    }
 catch (    InterruptedException ex) {
      break;
    }
catch (    Exception exc) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    }
 finally {
      if (r != null)       r.freeBuffers();
    }
    Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"");
synchronized (this) {
      try {
        this.wait(checkIntervalMillis);
      }
 catch (      InterruptedException ex) {
        break;
      }
    }
  }
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"");
  notifyStopped();
}",0.970467596390484
113824,"/** 
 * Shuts down the thread.
 */
public void shutdown(){
synchronized (this) {
    quit=true;
    this.notifyAll();
  }
}","/** 
 * Shuts down the thread.
 */
public void shutdown(){
synchronized (this) {
    quit=true;
    this.interrupt();
    this.notifyAll();
  }
}",0.917910447761194
113825,"private long distance(ServiceRegistry osd) throws UnknownHostException {
  return 1;
}","private long distance(ServiceRegistry osd) throws UnknownHostException {
  String osduri=null;
  for (  KeyValuePair kv : osd.getData()) {
    if (kv.getKey().equals(""String_Node_Str"")) {
      osduri=kv.getValue();
      break;
    }
  }
  if (osduri == null)   return 10000000;
  byte[] osdAddress=InetAddress.getByName((URI.create(osduri).getHost())).getAddress();
  if (osdAddress[0] == clientAddress[0] && osdAddress[1] == clientAddress[1] && osdAddress[2] == clientAddress[2])   return 0;
  return Math.abs(inetAddressToLong(osdAddress) - clientAddressLong);
}",0.263803680981595
113826,"public OSDRequestDispatcher(OSDConfig config) throws IOException, JSONException {
  this.config=config;
  assert(config.getUUID() != null);
  if (Tracer.COLLECT_TRACES) {
    Tracer.initialize(""String_Node_Str"" + config.getUUID() + ""String_Node_Str"");
  }
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new Operation[]{new ReadOperation(this),new WriteOperation(this),new StatusPageOperation(this),new FetchGmaxRPC(this),new TruncateRPC(this),new TruncateLocalRPC(this),new DeleteOperation(this),new DeleteOFTRPC(this),new DeleteLocalRPC(this),new GetProtocolVersionOperation(this),new ShutdownOperation(this),new CheckObjectRPC(this),new GmaxEvent(this),new CloseFileEvent(this),new GetStatistics(this),new StatisticsConfig(this),new AcquireLease(this),new ReturnLease(this),new CleanUpOperation(this),new FetchAndWriteReplica(this),new ReadLocalRPC(this)};
  pinky=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinky.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false);
  speedy=config.isUsingSSL() ? new MultiSpeedy(clientSSLopts) : new MultiSpeedy();
  speedy.setLifeCycleListener(this);
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  udpCom=new UDPCommunicator(config.getPort(),this);
  udpCom.setLifeCycleListener(this);
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  Striping striping=new Striping(config.getUUID(),metadataCache);
  statistics=new StageStatistics();
  stages=new Stage[]{new ParserStage(this),new AuthenticationStage(this),new StorageStage(this,striping,metadataCache,storageLayout,1),new DeletionStage(this,striping,metadataCache,storageLayout),new StatisticsStage(this,statistics,60 * 10),new ReplicationStage(this)};
  for (  Stage stage : stages)   stage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  osdClient=new OSDClient(speedy);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew(),authString);
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet data=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",totalSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",freeSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(OSDInterface.getVersion())));
      ServiceRegistry me=new ServiceRegistry(config.getUUID().toString(),0,Constants.SERVICE_TYPE_OSD,""String_Node_Str"" + config.getUUID(),kvset);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + this.config.getUUID() + ""String_Node_Str"");
}","public OSDRequestDispatcher(OSDConfig config) throws IOException, JSONException {
  this.config=config;
  assert(config.getUUID() != null);
  if (Tracer.COLLECT_TRACES) {
    Tracer.initialize(""String_Node_Str"" + config.getUUID() + ""String_Node_Str"");
  }
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  ChecksumFactory.getInstance().addProvider(new JavaChecksumProvider());
  operations=new Operation[]{new ReadOperation(this),new WriteOperation(this),new StatusPageOperation(this),new FetchGmaxRPC(this),new TruncateRPC(this),new TruncateLocalRPC(this),new DeleteOperation(this),new DeleteOFTRPC(this),new DeleteLocalRPC(this),new GetProtocolVersionOperation(this),new ShutdownOperation(this),new CheckObjectRPC(this),new GmaxEvent(this),new CloseFileEvent(this),new GetStatistics(this),new StatisticsConfig(this),new AcquireLease(this),new ReturnLease(this),new CleanUpOperation(this),new FetchAndWriteReplica(this),new ReadLocalRPC(this)};
  pinky=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinky.setLifeCycleListener(this);
  final SSLOptions clientSSLopts=config.isUsingSSL() ? new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false) : null;
  speedy=config.isUsingSSL() ? new MultiSpeedy(clientSSLopts) : new MultiSpeedy();
  speedy.setLifeCycleListener(this);
  rpcClient=new RPCNIOSocketClient(clientSSLopts,5000,5 * 60 * 1000);
  rpcClient.setLifeCycleListener(this);
  udpCom=new UDPCommunicator(config.getPort(),this);
  udpCom.setLifeCycleListener(this);
  MetadataCache metadataCache=new MetadataCache();
  StorageLayout storageLayout=new HashStorageLayout(config,metadataCache);
  Striping striping=new Striping(config.getUUID(),metadataCache);
  statistics=new StageStatistics();
  stages=new Stage[]{new ParserStage(this),new AuthenticationStage(this),new StorageStage(this,striping,metadataCache,storageLayout,1),new DeletionStage(this,striping,metadataCache,storageLayout),new StatisticsStage(this,statistics,60 * 10),new ReplicationStage(this)};
  for (  Stage stage : stages)   stage.setLifeCycleListener(this);
  dirClient=new DIRClient(rpcClient,config.getDirectoryService());
  osdClient=new OSDClient(speedy);
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew(),authString);
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public ServiceRegistrySet getServiceData(){
      OSDConfig config=OSDRequestDispatcher.this.config;
      String freeSpace=""String_Node_Str"";
      if (config.isReportFreeSpace()) {
        freeSpace=String.valueOf(FSUtils.getFreeSpace(config.getObjDir()));
      }
      String totalSpace=""String_Node_Str"";
      try {
        File f=new File(config.getObjDir());
        totalSpace=String.valueOf(f.getTotalSpace());
      }
 catch (      Exception ex) {
      }
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      ServiceRegistrySet data=new ServiceRegistrySet();
      KeyValuePairSet kvset=new KeyValuePairSet();
      kvset.add(new KeyValuePair(""String_Node_Str"",totalSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",freeSpace));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(totalRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",Long.toString(usedRAM)));
      kvset.add(new KeyValuePair(""String_Node_Str"",config.getGeoCoordinates()));
      kvset.add(new KeyValuePair(""String_Node_Str"",Integer.toString(OSDInterface.getVersion())));
      ServiceRegistry me=new ServiceRegistry(config.getUUID().toString(),0,Constants.SERVICE_TYPE_OSD,""String_Node_Str"" + config.getUUID(),kvset);
      data.add(me);
      return data;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
  if (Logging.isDebug())   Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + this.config.getUUID() + ""String_Node_Str"");
}",0.9970155397756508
113827,"public void run(){
}","@Override public void run(){
  try {
    for (    String fileName : fileList) {
      replicateFile(fileName);
    }
    shutdown();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.1886792452830188
113828,"public static void main(String[] args) throws Exception {
  Logging.start(Logging.LEVEL_WARN);
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(1);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  CLIParser.parseCLI(args,options,arguments);
  if (arguments.size() != 1 || options.get(""String_Node_Str"").switchValue != null) {
    usage();
    return;
  }
  InetSocketAddress dirAddr=null;
  boolean useSSL=false;
  String serviceCredsFile=null;
  String serviceCredsPass=null;
  String trustedCAsFile=null;
  String trustedCAsPass=null;
  URL dirURL=options.get(""String_Node_Str"").urlValue;
  if (dirURL != null && ""String_Node_Str"".equals(dirURL.getProtocol())) {
    useSSL=true;
    serviceCredsFile=options.get(""String_Node_Str"").stringValue;
    serviceCredsPass=options.get(""String_Node_Str"").stringValue;
    trustedCAsFile=options.get(""String_Node_Str"").stringValue;
    trustedCAsPass=options.get(""String_Node_Str"").stringValue;
  }
  if (dirURL == null) {
    DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
    cfg.read();
    dirAddr=cfg.getDirectoryService();
    useSSL=cfg.isSslEnabled();
    serviceCredsFile=cfg.getServiceCredsFile();
    serviceCredsPass=cfg.getServiceCredsPassphrase();
    trustedCAsFile=cfg.getTrustedCertsFile();
    trustedCAsPass=cfg.getTrustedCertsPassphrase();
  }
 else   dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
  boolean checkOnly=options.get(""String_Node_Str"").switchValue != null;
  int noConnectionsPerOSD=DEFAULT_NUM_CONS;
  if (options.get(""String_Node_Str"").numValue != null)   noConnectionsPerOSD=options.get(""String_Node_Str"").numValue.intValue();
  int noFilesToFetch=DEFAULT_NUM_FILES;
  if (options.get(""String_Node_Str"").numValue != null)   noFilesToFetch=options.get(""String_Node_Str"").numValue.intValue();
  String volume=arguments.get(0);
  boolean isVolUUID=false;
  if (volume.startsWith(""String_Node_Str"")) {
    volume=volume.substring(""String_Node_Str"".length());
    isVolUUID=true;
  }
  SSLOptions sslOptions=useSSL ? new SSLOptions(serviceCredsFile,serviceCredsPass,SSLOptions.PKCS12_CONTAINER,trustedCAsFile,trustedCAsPass,SSLOptions.JKS_CONTAINER,false) : null;
  Map<String,Object> query=RPCClient.generateMap(isVolUUID ? ""String_Node_Str"" : ""String_Node_Str"",volume);
  DIRClient dirClient=new DIRClient(dirAddr,sslOptions,RPCClient.DEFAULT_TIMEOUT);
  TimeSync.initialize(dirClient,100000,50,authString);
  RPCResponse<Map<String,Map<String,Object>>> resp=dirClient.getEntities(query,RPCClient.generateStringList(""String_Node_Str"",""String_Node_Str""),authString);
  Map<String,Map<String,Object>> result=resp.get();
  resp.freeBuffers();
  if (result.isEmpty()) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str""+ dirURL+ ""String_Node_Str"");
    System.exit(3);
  }
  Map<String,Object> volMap=result.values().iterator().next();
  String mrc=(String)volMap.get(""String_Node_Str"");
  volume=(String)volMap.get(""String_Node_Str"");
  UUIDResolver.start(dirClient,60 * 60,10 * 60 * 60);
  ServiceUUID mrcUUID=new ServiceUUID(mrc);
  InetSocketAddress mrcAddress=mrcUUID.getAddress();
  try {
    MultiSpeedy speedy=new MultiSpeedy(sslOptions);
    speedy.start();
    AsyncScrubber scrubber=new AsyncScrubber(speedy,dirAddr,mrcAddress,volume,!checkOnly,noConnectionsPerOSD,noFilesToFetch,sslOptions);
    scrubber.start();
    scrubber.shutdown();
    System.exit(scrubber.getReturnCode());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  TimeSync.close();
  UUIDResolver.shutdown();
  dirClient.shutdown();
}","public static void main(String[] args) throws Exception {
  Logging.start(Logging.LEVEL_WARN);
  Map<String,CliOption> options=new HashMap<String,CliOption>();
  List<String> arguments=new ArrayList<String>(1);
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.URL));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.NUMBER));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.STRING));
  options.put(""String_Node_Str"",new CliOption(CliOption.OPTIONTYPE.SWITCH));
  CLIParser.parseCLI(args,options,arguments);
  if (arguments.size() != 1 || options.get(""String_Node_Str"").switchValue != null) {
    usage();
    return;
  }
  InetSocketAddress dirAddr=null;
  boolean useSSL=false;
  String serviceCredsFile=null;
  String serviceCredsPass=null;
  String trustedCAsFile=null;
  String trustedCAsPass=null;
  URL dirURL=options.get(""String_Node_Str"").urlValue;
  if (dirURL != null && ""String_Node_Str"".equals(dirURL.getProtocol())) {
    useSSL=true;
    serviceCredsFile=options.get(""String_Node_Str"").stringValue;
    serviceCredsPass=options.get(""String_Node_Str"").stringValue;
    trustedCAsFile=options.get(""String_Node_Str"").stringValue;
    trustedCAsPass=options.get(""String_Node_Str"").stringValue;
  }
  if (dirURL == null) {
    DefaultDirConfig cfg=new DefaultDirConfig(DEFAULT_DIR_CONFIG);
    cfg.read();
    dirAddr=cfg.getDirectoryService();
    useSSL=cfg.isSslEnabled();
    serviceCredsFile=cfg.getServiceCredsFile();
    serviceCredsPass=cfg.getServiceCredsPassphrase();
    trustedCAsFile=cfg.getTrustedCertsFile();
    trustedCAsPass=cfg.getTrustedCertsPassphrase();
  }
 else   dirAddr=new InetSocketAddress(dirURL.getHost(),dirURL.getPort());
  boolean checkOnly=options.get(""String_Node_Str"").switchValue != null;
  int noConnectionsPerOSD=DEFAULT_NUM_CONS;
  if (options.get(""String_Node_Str"").numValue != null)   noConnectionsPerOSD=options.get(""String_Node_Str"").numValue.intValue();
  int noFilesToFetch=DEFAULT_NUM_FILES;
  if (options.get(""String_Node_Str"").numValue != null)   noFilesToFetch=options.get(""String_Node_Str"").numValue.intValue();
  String volume=arguments.get(0);
  boolean isVolUUID=false;
  if (volume.startsWith(""String_Node_Str"")) {
    volume=volume.substring(""String_Node_Str"".length());
    isVolUUID=true;
  }
  SSLOptions sslOptions=useSSL ? new SSLOptions(new FileInputStream(serviceCredsFile),serviceCredsPass,SSLOptions.PKCS12_CONTAINER,new FileInputStream(trustedCAsFile),trustedCAsPass,SSLOptions.JKS_CONTAINER,false) : null;
  Map<String,Object> query=RPCClient.generateMap(isVolUUID ? ""String_Node_Str"" : ""String_Node_Str"",volume);
  DIRClient dirClient=new DIRClient(dirAddr,sslOptions,RPCClient.DEFAULT_TIMEOUT);
  TimeSync.initialize(dirClient,100000,50,authString);
  RPCResponse<Map<String,Map<String,Object>>> resp=dirClient.getEntities(query,RPCClient.generateStringList(""String_Node_Str"",""String_Node_Str""),authString);
  Map<String,Map<String,Object>> result=resp.get();
  resp.freeBuffers();
  if (result.isEmpty()) {
    System.err.println(""String_Node_Str"" + arguments.get(0) + ""String_Node_Str""+ dirURL+ ""String_Node_Str"");
    System.exit(3);
  }
  Map<String,Object> volMap=result.values().iterator().next();
  String mrc=(String)volMap.get(""String_Node_Str"");
  volume=(String)volMap.get(""String_Node_Str"");
  UUIDResolver.start(dirClient,60 * 60,10 * 60 * 60);
  ServiceUUID mrcUUID=new ServiceUUID(mrc);
  InetSocketAddress mrcAddress=mrcUUID.getAddress();
  try {
    MultiSpeedy speedy=new MultiSpeedy(sslOptions);
    speedy.start();
    AsyncScrubber scrubber=new AsyncScrubber(speedy,dirAddr,mrcAddress,volume,!checkOnly,noConnectionsPerOSD,noFilesToFetch,sslOptions);
    scrubber.start();
    scrubber.shutdown();
    System.exit(scrubber.getReturnCode());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  TimeSync.close();
  UUIDResolver.shutdown();
  dirClient.shutdown();
}",0.9951901053595968
113829,"/** 
 * Creates a new instance of RequestController 
 */
public RequestController(DIRConfig config) throws Exception {
  try {
    this.config=config;
    final AuthenticationProvider auth=(AuthenticationProvider)Class.forName(config.getAuthenticationProvider()).newInstance();
    auth.initialize(config.isUsingSSL());
    dirServiceStage=new DirServiceStage(config.getDbDir(),auth);
    dirServiceStage.setRequestListener(this);
    dirServiceStage.setLifeCycleListener(this);
    pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
    pinkyStage.setLifeCycleListener(this);
    StringBuffer sb=null;
    try {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (is == null)       is=this.getClass().getResourceAsStream(""String_Node_Str"");
      BufferedReader br=new BufferedReader(new InputStreamReader(is));
      sb=new StringBuffer();
      String line=br.readLine();
      while (line != null) {
        sb.append(line + ""String_Node_Str"");
        line=br.readLine();
      }
      br.close();
    }
 catch (    Exception ex) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    if (sb == null) {
      statusPageTemplate=""String_Node_Str"";
    }
 else {
      statusPageTemplate=sb.toString();
    }
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    shutdown();
    throw exc;
  }
}","/** 
 * Creates a new instance of RequestController 
 */
public RequestController(DIRConfig config) throws Exception {
  try {
    this.config=config;
    final AuthenticationProvider auth=(AuthenticationProvider)Class.forName(config.getAuthenticationProvider()).newInstance();
    auth.initialize(config.isUsingSSL());
    dirServiceStage=new DirServiceStage(config.getDbDir(),auth);
    dirServiceStage.setRequestListener(this);
    dirServiceStage.setLifeCycleListener(this);
    pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(new FileInputStream(config.getServiceCredsFile()),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),new FileInputStream(config.getTrustedCertsFile()),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
    pinkyStage.setLifeCycleListener(this);
    StringBuffer sb=null;
    try {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (is == null)       is=this.getClass().getResourceAsStream(""String_Node_Str"");
      BufferedReader br=new BufferedReader(new InputStreamReader(is));
      sb=new StringBuffer();
      String line=br.readLine();
      while (line != null) {
        sb.append(line + ""String_Node_Str"");
        line=br.readLine();
      }
      br.close();
    }
 catch (    Exception ex) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    if (sb == null) {
      statusPageTemplate=""String_Node_Str"";
    }
 else {
      statusPageTemplate=sb.toString();
    }
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    shutdown();
    throw exc;
  }
}",0.9885308574549426
113830,"public void installOperations(){
  operations.put(ShutdownOperation.RPC_NAME,new ShutdownOperation(master));
  operations.put(StatusPageOperation.RPC_NAME,new StatusPageOperation(master));
  operations.put(GetProtocolVersionOperation.RPC_NAME,new GetProtocolVersionOperation(master));
  operations.put(CreateVolumeOperation.RPC_NAME,new CreateVolumeOperation(master));
  operations.put(DeleteVolumeOperation.RPC_NAME,new DeleteVolumeOperation(master));
  operations.put(GetLocalVolumesOperation.RPC_NAME,new GetLocalVolumesOperation(master));
  operations.put(StatOperation.RPC_NAME,new StatOperation(master));
  operations.put(CheckAccessOperation.RPC_NAME,new CheckAccessOperation(master));
  operations.put(ReadDirOperation.RPC_NAME,new ReadDirOperation(master));
  operations.put(ReadDirAndStatOperation.RPC_NAME,new ReadDirAndStatOperation(master));
  operations.put(CreateFileOperation.RPC_NAME,new CreateFileOperation(master));
  operations.put(CreateDirOperation.RPC_NAME,new CreateDirOperation(master));
  operations.put(CreateSymLinkOperation.RPC_NAME,new CreateSymLinkOperation(master));
  operations.put(DeleteOperation.RPC_NAME,new DeleteOperation(master));
  operations.put(GetXAttrOperation.RPC_NAME,new GetXAttrOperation(master));
  operations.put(SetXAttrsOperation.RPC_NAME,new SetXAttrsOperation(master));
  operations.put(OpenOperation.RPC_NAME,new OpenOperation(master));
  operations.put(UpdateFileSizeOperation.RPC_NAME,new UpdateFileSizeOperation(master));
  operations.put(RenewOperation.RPC_NAME,new RenewOperation(master));
  operations.put(ChangeOwnerOperation.RPC_NAME,new ChangeOwnerOperation(master));
  operations.put(ChangeAccessModeOperation.RPC_NAME,new ChangeAccessModeOperation(master));
  operations.put(AddReplicaOperation.RPC_NAME,new AddReplicaOperation(master));
  operations.put(RemoveReplicaOperation.RPC_NAME,new RemoveReplicaOperation(master));
  operations.put(MoveOperation.RPC_NAME,new MoveOperation(master));
  operations.put(CreateLinkOperation.RPC_NAME,new CreateLinkOperation(master));
  operations.put(StatFSOperation.RPC_NAME,new StatFSOperation(master));
  operations.put(UtimeOperation.RPC_NAME,new UtimeOperation(master));
  operations.put(SetW32AttrsOperation.RPC_NAME,new SetW32AttrsOperation(master));
  operations.put(GetW32AttrsOperation.RPC_NAME,new GetW32AttrsOperation(master));
  operations.put(SetACLEntriesOperation.RPC_NAME,new SetACLEntriesOperation(master));
  operations.put(RemoveACLEntriesOperation.RPC_NAME,new RemoveACLEntriesOperation(master));
  operations.put(DumpDBOperation.RPC_NAME,new DumpDBOperation(master));
  operations.put(RestoreDBOperation.RPC_NAME,new RestoreDBOperation(master));
  operations.put(CheckAccessOperation.RPC_NAME,new CheckFileListOperation(master));
}","public void installOperations(){
  operations.put(ShutdownOperation.RPC_NAME,new ShutdownOperation(master));
  operations.put(StatusPageOperation.RPC_NAME,new StatusPageOperation(master));
  operations.put(GetProtocolVersionOperation.RPC_NAME,new GetProtocolVersionOperation(master));
  operations.put(CreateVolumeOperation.RPC_NAME,new CreateVolumeOperation(master));
  operations.put(DeleteVolumeOperation.RPC_NAME,new DeleteVolumeOperation(master));
  operations.put(GetLocalVolumesOperation.RPC_NAME,new GetLocalVolumesOperation(master));
  operations.put(StatOperation.RPC_NAME,new StatOperation(master));
  operations.put(CheckAccessOperation.RPC_NAME,new CheckAccessOperation(master));
  operations.put(ReadDirOperation.RPC_NAME,new ReadDirOperation(master));
  operations.put(ReadDirAndStatOperation.RPC_NAME,new ReadDirAndStatOperation(master));
  operations.put(CreateFileOperation.RPC_NAME,new CreateFileOperation(master));
  operations.put(CreateDirOperation.RPC_NAME,new CreateDirOperation(master));
  operations.put(CreateSymLinkOperation.RPC_NAME,new CreateSymLinkOperation(master));
  operations.put(DeleteOperation.RPC_NAME,new DeleteOperation(master));
  operations.put(GetXAttrOperation.RPC_NAME,new GetXAttrOperation(master));
  operations.put(SetXAttrsOperation.RPC_NAME,new SetXAttrsOperation(master));
  operations.put(OpenOperation.RPC_NAME,new OpenOperation(master));
  operations.put(UpdateFileSizeOperation.RPC_NAME,new UpdateFileSizeOperation(master));
  operations.put(RenewOperation.RPC_NAME,new RenewOperation(master));
  operations.put(ChangeOwnerOperation.RPC_NAME,new ChangeOwnerOperation(master));
  operations.put(ChangeAccessModeOperation.RPC_NAME,new ChangeAccessModeOperation(master));
  operations.put(AddReplicaOperation.RPC_NAME,new AddReplicaOperation(master));
  operations.put(RemoveReplicaOperation.RPC_NAME,new RemoveReplicaOperation(master));
  operations.put(MoveOperation.RPC_NAME,new MoveOperation(master));
  operations.put(CreateLinkOperation.RPC_NAME,new CreateLinkOperation(master));
  operations.put(StatFSOperation.RPC_NAME,new StatFSOperation(master));
  operations.put(UtimeOperation.RPC_NAME,new UtimeOperation(master));
  operations.put(SetW32AttrsOperation.RPC_NAME,new SetW32AttrsOperation(master));
  operations.put(GetW32AttrsOperation.RPC_NAME,new GetW32AttrsOperation(master));
  operations.put(SetACLEntriesOperation.RPC_NAME,new SetACLEntriesOperation(master));
  operations.put(RemoveACLEntriesOperation.RPC_NAME,new RemoveACLEntriesOperation(master));
  operations.put(DumpDBOperation.RPC_NAME,new DumpDBOperation(master));
  operations.put(RestoreDBOperation.RPC_NAME,new RestoreDBOperation(master));
  operations.put(CheckFileListOperation.RPC_NAME,new CheckFileListOperation(master));
}",0.997462848858282
113831,"@Override public FileMetadata createSymLink(long fileId,long parentId,String fileName,int atime,int ctime,int mtime,String userId,String groupId,String ref,AtomicDBUpdate update) throws DatabaseException {
  try {
    short collCount=BabuDBStorageHelper.findNextFreeFileCollisionNumber(database,dbName,parentId,fileName);
    if (collCount == -1)     throw new DatabaseException(ExceptionType.FILE_EXISTS);
    BufferBackedFileMetadata fileMetadata=new BufferBackedFileMetadata(parentId,fileName,userId,groupId,fileId,atime,ctime,mtime,ref.length(),(short)0xFFFF,0,(short)1,0,0,false,collCount);
    BufferBackedXAttr lt=new BufferBackedXAttr(fileId,SYSTEM_UID,LINK_TARGET_ATTR_NAME,ref,(short)0);
    update.addUpdate(XATTRS_INDEX,lt.getKeyBuf(),lt.getValBuf());
    update.addUpdate(FILE_INDEX,fileMetadata.getFCMetadataKey(),fileMetadata.getFCMetadataValue());
    update.addUpdate(FILE_INDEX,fileMetadata.getRCMetadata().getKey(),fileMetadata.getRCMetadata().getValue());
    update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(fileId,(byte)3),BabuDBStorageHelper.createFileIdIndexValue(parentId,fileName));
    return fileMetadata;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public FileMetadata createSymLink(long fileId,long parentId,String fileName,int atime,int ctime,int mtime,String userId,String groupId,String ref,AtomicDBUpdate update) throws DatabaseException {
  try {
    short collCount=BabuDBStorageHelper.findNextFreeFileCollisionNumber(database,dbName,parentId,fileName);
    if (collCount == -1)     throw new DatabaseException(ExceptionType.FILE_EXISTS);
    BufferBackedFileMetadata fileMetadata=new BufferBackedFileMetadata(parentId,fileName,userId,groupId,fileId,atime,ctime,mtime,ref.length(),0777,0,(short)1,0,0,false,collCount);
    BufferBackedXAttr lt=new BufferBackedXAttr(fileId,SYSTEM_UID,LINK_TARGET_ATTR_NAME,ref,(short)0);
    update.addUpdate(XATTRS_INDEX,lt.getKeyBuf(),lt.getValBuf());
    update.addUpdate(FILE_INDEX,fileMetadata.getFCMetadataKey(),fileMetadata.getFCMetadataValue());
    update.addUpdate(FILE_INDEX,fileMetadata.getRCMetadata().getKey(),fileMetadata.getRCMetadata().getValue());
    update.addUpdate(FILE_ID_INDEX,BabuDBStorageHelper.createFileIdIndexKey(fileId,(byte)3),BabuDBStorageHelper.createFileIdIndexValue(parentId,fileName));
    return fileMetadata;
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}",0.9939148073022313
113832,"@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly(),(short)0);
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
}","@Override public void setOwnerAndGroup(String owner,String group){
  BufferBackedRCMetadata tmp=isDirectory() ? new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),(short)0) : new BufferBackedRCMetadata(0,rcMetadata.getFileName(),owner,group,rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getW32Attrs(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly(),(short)0);
  rcMetadata=new BufferBackedRCMetadata(rcMetadata == null ? null : rcMetadata.getKey(),tmp.getValue());
}",0.8271375464684015
113833,"public void testAccessControl() throws Exception {
  final String authString1=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String authString2=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String authString3=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String noACVolumeName=""String_Node_Str"";
  final String volACVolumeName=""String_Node_Str"";
  final String posixVolName=""String_Node_Str"";
  Map<String,Object> acl=new HashMap<String,Object>();
  acl.put(""String_Node_Str"",0);
  acl.put(""String_Node_Str"",(1 << 0) | (1 << 1));
  acl.put(""String_Node_Str"",1);
  client.createVolume(mrc1Address,noACVolumeName,RandomSelectionPolicy.POLICY_ID,null,YesToAnyoneFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.createFile(mrc1Address,noACVolumeName + ""String_Node_Str"",authString1);
  client.changeOwner(mrc1Address,noACVolumeName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",authString1);
  Map<String,Object> stat=client.stat(mrc1Address,noACVolumeName + ""String_Node_Str"",false,false,false,authString3);
  assertEquals(""String_Node_Str"",stat.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",stat.get(""String_Node_Str""));
  client.delete(mrc1Address,noACVolumeName + ""String_Node_Str"",authString3);
  client.createDir(mrc1Address,noACVolumeName + ""String_Node_Str"",null,0,authString1);
  client.createFile(mrc1Address,noACVolumeName + ""String_Node_Str"",authString2);
  final String someone=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  assertTrue(client.checkAccess(mrc1Address,noACVolumeName + ""String_Node_Str"",""String_Node_Str"",someone));
  client.createVolume(mrc1Address,volACVolumeName,RandomSelectionPolicy.POLICY_ID,null,VolumeACLFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.setACLEntries(mrc1Address,volACVolumeName,acl,authString1);
  client.createDir(mrc1Address,volACVolumeName + ""String_Node_Str"",null,0,authString1);
  try {
    client.createDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  Exception exc) {
  }
  assertEquals(0,client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString1).size());
  assertEquals(0,client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString2).size());
  try {
    client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString3);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.createFile(mrc1Address,volACVolumeName + ""String_Node_Str"",authString1);
  client.createVolume(mrc1Address,posixVolName,RandomSelectionPolicy.POLICY_ID,null,POSIXFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.changeAccessMode(mrc1Address,posixVolName,0700,authString1);
  client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
  assertTrue(client.checkAccess(mrc1Address,posixVolName + ""String_Node_Str"",""String_Node_Str"",authString1));
  try {
    client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  Map<String,Object> statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(0,acl.size());
  Map<String,Object> newEntries=new HashMap<String,Object>();
  newEntries.put(""String_Node_Str"",5);
  try {
    client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  newEntries.clear();
  newEntries.put(""String_Node_Str"",2);
  newEntries.put(""String_Node_Str"",3);
  client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(4,acl.size());
  assertEquals(511L,acl.get(""String_Node_Str""));
  assertEquals(2L,acl.get(""String_Node_Str""));
  assertEquals(511L,acl.get(""String_Node_Str""));
  assertEquals(3L,acl.get(""String_Node_Str""));
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",0,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(4,acl.size());
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  newEntries.clear();
  newEntries.put(""String_Node_Str"",511);
  newEntries.put(""String_Node_Str"",511);
  client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString1);
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.setACLEntries(mrc1Address,posixVolName,newEntries,authString1);
  assertTrue(client.checkAccess(mrc1Address,posixVolName + ""String_Node_Str"",""String_Node_Str"",authString2));
  assertEquals(0,client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2).size());
  client.removeACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",new ArrayList<Object>(newEntries.keySet()),authString1);
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.changeAccessMode(mrc1Address,posixVolName,0005,authString1);
  assertEquals(1,client.readDir(mrc1Address,posixVolName,authString3).size());
  assertFalse(client.checkAccess(mrc1Address,posixVolName,""String_Node_Str"",authString3));
  client.deleteVolume(mrc1Address,posixVolName,authString1);
  client.createVolume(mrc1Address,posixVolName,RandomSelectionPolicy.POLICY_ID,null,POSIXFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",null,null,224,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,false,authString1);
  long accessMode=(Long)statInfo.get(""String_Node_Str"");
  assertEquals(224,accessMode);
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",accessMode & 192,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,false,authString1);
  accessMode=(Long)statInfo.get(""String_Node_Str"");
  assertEquals(192,accessMode);
  client.changeAccessMode(mrc1Address,posixVolName,511,authString1);
  client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",null,511,authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",512 | 511,authString1);
  try {
    client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  try {
    client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString2);
  client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
}","public void testAccessControl() throws Exception {
  final String authString1=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String authString2=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String authString3=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  final String authString4=NullAuthProvider.createAuthString(""String_Node_Str"",""String_Node_Str"");
  final String noACVolumeName=""String_Node_Str"";
  final String volACVolumeName=""String_Node_Str"";
  final String posixVolName=""String_Node_Str"";
  Map<String,Object> acl=new HashMap<String,Object>();
  acl.put(""String_Node_Str"",0);
  acl.put(""String_Node_Str"",(1 << 0) | (1 << 1));
  acl.put(""String_Node_Str"",1);
  client.createVolume(mrc1Address,noACVolumeName,RandomSelectionPolicy.POLICY_ID,null,YesToAnyoneFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.createFile(mrc1Address,noACVolumeName + ""String_Node_Str"",authString1);
  client.changeOwner(mrc1Address,noACVolumeName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",authString4);
  Map<String,Object> stat=client.stat(mrc1Address,noACVolumeName + ""String_Node_Str"",false,false,false,authString3);
  assertEquals(""String_Node_Str"",stat.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",stat.get(""String_Node_Str""));
  client.delete(mrc1Address,noACVolumeName + ""String_Node_Str"",authString3);
  client.createDir(mrc1Address,noACVolumeName + ""String_Node_Str"",null,0,authString1);
  client.createFile(mrc1Address,noACVolumeName + ""String_Node_Str"",authString2);
  final String someone=NullAuthProvider.createAuthString(""String_Node_Str"",MRCClient.generateStringList(""String_Node_Str""));
  assertTrue(client.checkAccess(mrc1Address,noACVolumeName + ""String_Node_Str"",""String_Node_Str"",someone));
  client.createVolume(mrc1Address,volACVolumeName,RandomSelectionPolicy.POLICY_ID,null,VolumeACLFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.setACLEntries(mrc1Address,volACVolumeName,acl,authString1);
  client.createDir(mrc1Address,volACVolumeName + ""String_Node_Str"",null,0,authString1);
  try {
    client.createDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  Exception exc) {
  }
  assertEquals(0,client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString1).size());
  assertEquals(0,client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString2).size());
  try {
    client.readDir(mrc1Address,volACVolumeName + ""String_Node_Str"",authString3);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.createFile(mrc1Address,volACVolumeName + ""String_Node_Str"",authString1);
  client.createVolume(mrc1Address,posixVolName,RandomSelectionPolicy.POLICY_ID,null,POSIXFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.changeAccessMode(mrc1Address,posixVolName,0700,authString1);
  client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
  assertTrue(client.checkAccess(mrc1Address,posixVolName + ""String_Node_Str"",""String_Node_Str"",authString1));
  try {
    client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  Map<String,Object> statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(0,acl.size());
  Map<String,Object> newEntries=new HashMap<String,Object>();
  newEntries.put(""String_Node_Str"",5);
  try {
    client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  newEntries.clear();
  newEntries.put(""String_Node_Str"",2);
  newEntries.put(""String_Node_Str"",3);
  client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(4,acl.size());
  assertEquals(511L,acl.get(""String_Node_Str""));
  assertEquals(2L,acl.get(""String_Node_Str""));
  assertEquals(511L,acl.get(""String_Node_Str""));
  assertEquals(3L,acl.get(""String_Node_Str""));
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",0,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,true,authString1);
  acl=(Map<String,Object>)statInfo.get(""String_Node_Str"");
  assertEquals(4,acl.size());
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  assertEquals(0L,acl.get(""String_Node_Str""));
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  newEntries.clear();
  newEntries.put(""String_Node_Str"",511);
  newEntries.put(""String_Node_Str"",511);
  client.setACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",newEntries,authString1);
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.setACLEntries(mrc1Address,posixVolName,newEntries,authString1);
  assertTrue(client.checkAccess(mrc1Address,posixVolName + ""String_Node_Str"",""String_Node_Str"",authString2));
  assertEquals(0,client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2).size());
  client.removeACLEntries(mrc1Address,posixVolName + ""String_Node_Str"",new ArrayList<Object>(newEntries.keySet()),authString1);
  try {
    client.readDir(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.changeAccessMode(mrc1Address,posixVolName,0005,authString1);
  assertEquals(1,client.readDir(mrc1Address,posixVolName,authString3).size());
  assertFalse(client.checkAccess(mrc1Address,posixVolName,""String_Node_Str"",authString3));
  client.deleteVolume(mrc1Address,posixVolName,authString1);
  client.createVolume(mrc1Address,posixVolName,RandomSelectionPolicy.POLICY_ID,null,POSIXFileAccessPolicy.POLICY_ID,DefaultPartitioningPolicy.POLICY_ID,null,authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",null,null,224,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,false,authString1);
  long accessMode=(Long)statInfo.get(""String_Node_Str"");
  assertEquals(224,accessMode);
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",accessMode & 192,authString1);
  statInfo=client.stat(mrc1Address,posixVolName + ""String_Node_Str"",false,false,false,authString1);
  accessMode=(Long)statInfo.get(""String_Node_Str"");
  assertEquals(192,accessMode);
  client.changeAccessMode(mrc1Address,posixVolName,511,authString1);
  client.createDir(mrc1Address,posixVolName + ""String_Node_Str"",null,511,authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString1);
  client.createFile(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
  client.changeAccessMode(mrc1Address,posixVolName + ""String_Node_Str"",512 | 511,authString1);
  try {
    client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  try {
    client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString1);
    fail(""String_Node_Str"");
  }
 catch (  HttpErrorException exc) {
  }
  client.move(mrc1Address,posixVolName + ""String_Node_Str"",posixVolName + ""String_Node_Str"",authString2);
  client.delete(mrc1Address,posixVolName + ""String_Node_Str"",authString2);
}",0.9940098452049108
113834,"public void enqueueFileForDeletion(String fileID){
  assert(this.isAlive());
  files.add(fileID);
}","public void enqueueFileForDeletion(String fileID){
  assert(this.isAlive());
  assert(fileID != null);
  files.add(fileID);
}",0.8839285714285714
113835,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.userId == null ? file.getOwnerId() : rqArgs.userId,rqArgs.groupId == null ? file.getOwningGroupId() : rqArgs.groupId);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (rqArgs.userId != null) {
      if (!rq.getDetails().superUser)       throw new UserException(ErrNo.EACCES,""String_Node_Str"");
    }
 else     faMan.checkPrivilegedPermissions(sMan,file,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    file.setOwnerAndGroup(rqArgs.userId == null ? file.getOwnerId() : rqArgs.userId,rqArgs.groupId == null ? file.getOwningGroupId() : rqArgs.groupId);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9642156862745098
113836,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    StorageManager sMan=vMan.getStorageManager(rqArgs.volumeID);
    String response=sMan == null ? ""String_Node_Str"" : ""String_Node_Str"";
    if (sMan != null)     try {
      if (rqArgs.fileIDs == null || rqArgs.fileIDs.size() == 0)       throw new UserException(""String_Node_Str"");
      for (      String fileId : rqArgs.fileIDs) {
        if (fileId == null)         throw new BackendException(""String_Node_Str"");
        response+=sMan.getMetadata(Long.parseLong(fileId)) != null ? ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
 catch (    UserException ue) {
      response=""String_Node_Str"";
    }
catch (    BackendException be) {
      throw new BrainException(""String_Node_Str"" + be.getMessage());
    }
    rq.setData(ReusableBuffer.wrap(response.getBytes()));
    finishRequest(rq);
  }
 catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    StorageManager sMan=vMan.getStorageManager(rqArgs.volumeID);
    String response=sMan == null ? ""String_Node_Str"" : ""String_Node_Str"";
    if (sMan != null)     try {
      if (rqArgs.fileIDs == null || rqArgs.fileIDs.size() == 0)       throw new UserException(""String_Node_Str"");
      for (      String fileId : rqArgs.fileIDs) {
        if (fileId == null)         throw new BackendException(""String_Node_Str"");
        response+=sMan.getMetadata(Long.parseLong(fileId)) != null ? ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
 catch (    UserException ue) {
      response=""String_Node_Str"";
    }
catch (    BackendException be) {
      throw new BrainException(""String_Node_Str"" + be.getMessage());
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(response).getBytes()));
    finishRequest(rq);
  }
 catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9827742520398912
113837,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.path);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    HTTPHeaders xCapHeaders=null;
    if (!file.isDirectory()) {
      String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
      String capability=MRCOpHelper.createCapability(aMode,volume.getId(),file.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
      xCapHeaders=MRCOpHelper.createXCapHeaders(capability,file.getXLocList());
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     xCapHeaders=null;
    rq.setAdditionalResponseHeaders(xCapHeaders);
    MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.path);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),0,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    if (file.isDirectory() && sMan.getChildren(file.getId()).hasNext())     throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + p + ""String_Node_Str"");
    HTTPHeaders xCapHeaders=null;
    if (!file.isDirectory()) {
      String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
      String capability=MRCOpHelper.createCapability(aMode,volume.getId(),file.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
      xCapHeaders=MRCOpHelper.createXCapHeaders(capability,file.getXLocList());
    }
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    sMan.delete(res.getParentDirId(),res.getFileName(),update);
    if (file.getLinkCount() > 1)     xCapHeaders=null;
    rq.setAdditionalResponseHeaders(xCapHeaders);
    MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    if (file.getLinkCount() > 1)     MRCOpHelper.updateFileTimes(res.getParentDirId(),file,false,true,false,sMan,update);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.97406462585034
113838,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path sp=new Path(rqArgs.sourcePath);
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.targetPath);
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    if (sp.equals(tp)) {
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.DELETE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
if (target.getLinkCount() == 1) {
  String capability=MRCOpHelper.createCapability(aMode,volume.getId(),target.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
  HTTPHeaders xCapHeaders=MRCOpHelper.createXCapHeaders(capability,target.getXLocList());
  rq.setAdditionalResponseHeaders(xCapHeaders);
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCOpHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCOpHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Exception exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path sp=new Path(rqArgs.sourcePath);
    final VolumeInfo volume=vMan.getVolumeByName(sp.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver sRes=new PathResolver(sMan,sp);
    faMan.checkSearchPermission(sMan,sRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,sRes.getParentDir(),sRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    final Path tp=new Path(rqArgs.targetPath);
    if (sp.getCompCount() == 1)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    if (!sp.getComp(0).equals(tp.getComp(0)))     throw new UserException(ErrNo.ENOENT,""String_Node_Str"");
    sRes.checkIfFileDoesNotExist();
    faMan.checkPermission(FileAccessManager.RM_MV_IN_DIR_ACCESS,sMan,sRes.getFile(),sRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    FileMetadata source=sRes.getFile();
    FileType sourceType=source.isDirectory() ? FileType.dir : FileType.file;
    final PathResolver tRes=new PathResolver(sMan,tp);
    FileMetadata targetParentDir=tRes.getParentDir();
    if (targetParentDir == null || !targetParentDir.isDirectory())     throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + tp.getComps(0,tp.getCompCount() - 2) + ""String_Node_Str"");
    FileMetadata target=tRes.getFile();
    FileType targetType=tp.getCompCount() == 1 ? FileType.dir : target == null ? FileType.nexists : target.isDirectory() ? FileType.dir : FileType.file;
    if (sp.equals(tp)) {
      finishRequest(rq);
      return;
    }
    faMan.checkSearchPermission(sMan,tRes,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,tRes.getParentDir(),tRes.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
switch (sourceType) {
case dir:
{
        if (tp.isSubDirOf(sp))         throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + sp + ""String_Node_Str"");
switch (targetType) {
case nexists:
{
            short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
            source.setLinkCount(newLinkCount);
            source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
            sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
            break;
          }
case dir:
{
          faMan.checkPermission(FileAccessManager.DELETE_ACCESS,sMan,target,tRes.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
          if (sMan.getChildren(target.getId()).hasNext())           throw new UserException(ErrNo.ENOTEMPTY,""String_Node_Str"" + tRes + ""String_Node_Str"");
 else           sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
          short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
          source.setLinkCount(newLinkCount);
          source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
          sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
          break;
        }
case file:
      throw new UserException(ErrNo.ENOTDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
  }
  break;
}
case file:
{
switch (targetType) {
case nexists:
{
    short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
    source.setLinkCount(newLinkCount);
    source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
    sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
    break;
  }
case dir:
{
  throw new UserException(ErrNo.EISDIR,""String_Node_Str"" + sRes + ""String_Node_Str""+ tRes+ ""String_Node_Str"");
}
case file:
{
String aMode=faMan.translateAccessMode(volume.getId(),FileAccessManager.DELETE_ACCESS);
if (target.getLinkCount() == 1) {
  String capability=MRCOpHelper.createCapability(aMode,volume.getId(),target.getId(),Integer.MAX_VALUE,master.getConfig().getCapabilitySecret()).toString();
  HTTPHeaders xCapHeaders=MRCOpHelper.createXCapHeaders(capability,target.getXLocList());
  rq.setAdditionalResponseHeaders(xCapHeaders);
}
sMan.delete(tRes.getParentDirId(),tRes.getFileName(),update);
short newLinkCount=sMan.delete(sRes.getParentDirId(),sRes.getFileName(),update);
source.setLinkCount(newLinkCount);
source.setCtime((int)(TimeSync.getGlobalTime() / 1000));
sMan.link(source,tRes.getParentDirId(),tRes.getFileName(),update);
break;
}
}
}
}
MRCOpHelper.updateFileTimes(sRes.getParentsParentId(),sRes.getParentDir(),false,true,true,sMan,update);
MRCOpHelper.updateFileTimes(tRes.getParentsParentId(),tRes.getParentDir(),false,true,true,sMan,update);
rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
update.execute();
}
 catch (UserException exc) {
Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
}
catch (Exception exc) {
finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
}
}",0.9761098570353648
113839,"@Override public void startRequest(MRCRequest rq){
  try {
    String capString=rq.getPinkyRequest().requestHeaders.getHeader(HTTPHeaders.HDR_XCAPABILITY);
    String newSizeString=rq.getPinkyRequest().requestHeaders.getHeader(HTTPHeaders.HDR_XNEWFILESIZE);
    if (capString == null)     throw new UserException(""String_Node_Str"" + HTTPHeaders.HDR_XCAPABILITY + ""String_Node_Str"");
    if (newSizeString == null)     throw new UserException(""String_Node_Str"" + HTTPHeaders.HDR_XNEWFILESIZE + ""String_Node_Str"");
    Capability cap=new Capability(capString,master.getConfig().getCapabilitySecret());
    if (!cap.isValid())     throw new UserException(capString + ""String_Node_Str"");
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=cap.getFileId();
      int i=globalFileId.indexOf(':');
      volumeId=cap.getFileId().substring(0,i);
      fileId=Long.parseLong(cap.getFileId().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    }
    StorageManager sMan=master.getVolumeManager().getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    int index=newSizeString.indexOf(',');
    if (index == -1)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + HTTPHeaders.HDR_XNEWFILESIZE + ""String_Node_Str"");
    long newFileSize=0;
    int epochNo=0;
    try {
      newFileSize=Long.parseLong(newSizeString.substring(1,index));
      epochNo=Integer.parseInt(newSizeString.substring(index + 1,newSizeString.length() - 1));
    }
 catch (    NumberFormatException exc) {
      throw new UserException(""String_Node_Str"" + newSizeString);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (epochNo < file.getEpoch()) {
      finishRequest(rq);
      return;
    }
    if (epochNo > file.getEpoch() || newFileSize > file.getSize()) {
      file.setSize(newFileSize);
      file.setEpoch(epochNo);
      AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
      update.execute();
    }
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    String capString=rq.getPinkyRequest().requestHeaders.getHeader(HTTPHeaders.HDR_XCAPABILITY);
    String newSizeString=rq.getPinkyRequest().requestHeaders.getHeader(HTTPHeaders.HDR_XNEWFILESIZE);
    if (capString == null)     throw new UserException(""String_Node_Str"" + HTTPHeaders.HDR_XCAPABILITY + ""String_Node_Str"");
    if (newSizeString == null)     throw new UserException(""String_Node_Str"" + HTTPHeaders.HDR_XNEWFILESIZE + ""String_Node_Str"");
    Capability cap=new Capability(capString,master.getConfig().getCapabilitySecret());
    if (!cap.isValid())     throw new UserException(capString + ""String_Node_Str"");
    long fileId=0;
    String volumeId=null;
    try {
      String globalFileId=cap.getFileId();
      int i=globalFileId.indexOf(':');
      volumeId=cap.getFileId().substring(0,i);
      fileId=Long.parseLong(cap.getFileId().substring(i + 1));
    }
 catch (    Exception exc) {
      throw new UserException(""String_Node_Str"" + cap.getFileId() + ""String_Node_Str"");
    }
    StorageManager sMan=master.getVolumeManager().getStorageManager(volumeId);
    FileMetadata file=sMan.getMetadata(fileId);
    if (file == null)     throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + fileId + ""String_Node_Str"");
    int index=newSizeString.indexOf(',');
    if (index == -1)     throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + HTTPHeaders.HDR_XNEWFILESIZE + ""String_Node_Str"");
    long newFileSize=0;
    int epochNo=0;
    try {
      newFileSize=Long.parseLong(newSizeString.substring(1,index));
      epochNo=Integer.parseInt(newSizeString.substring(index + 1,newSizeString.length() - 1));
    }
 catch (    NumberFormatException exc) {
      throw new UserException(""String_Node_Str"" + newSizeString);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (epochNo < file.getEpoch()) {
      finishRequest(rq);
      return;
    }
    if (epochNo > file.getEpoch() || newFileSize > file.getSize()) {
      int time=(int)(TimeSync.getGlobalTime() / 1000);
      file.setSize(newFileSize);
      file.setEpoch(epochNo);
      file.setCtime(time);
      file.setMtime(time);
      AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.FC_METADATA,update);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
      update.execute();
    }
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9682451253481894
113840,"/** 
 * Converts an <code>XLocationsList</code> object to a list containing X-Locations data.
 * @param xLocList
 * @return
 */
public static List<Object> xLocListToList(XLocList xLocList){
  if (xLocList == null)   return null;
  List<Object> replicaList=new LinkedList<Object>();
  List<Object> list=new LinkedList<Object>();
  for (int i=0; i < xLocList.getReplicaCount(); i++) {
    XLoc replica=xLocList.getReplica(i);
    List<Object> replicaAsList=new ArrayList<Object>(2);
    Map<String,Object> policyMap=stripingPolicyToMap(replica.getStripingPolicy());
    List<String> osdList=new ArrayList<String>(replica.getOSDCount());
    for (int j=0; j < replica.getOSDCount(); j++)     osdList.add(replica.getOSD(i));
    replicaAsList.add(policyMap);
    replicaAsList.add(osdList);
    replicaList.add(replicaAsList);
  }
  list.add(replicaList);
  list.add(xLocList.getVersion());
  return list;
}","/** 
 * Converts an <code>XLocationsList</code> object to a list containing X-Locations data.
 * @param xLocList
 * @return
 */
public static List<Object> xLocListToList(XLocList xLocList){
  if (xLocList == null)   return null;
  List<Object> replicaList=new LinkedList<Object>();
  List<Object> list=new LinkedList<Object>();
  for (int i=0; i < xLocList.getReplicaCount(); i++) {
    XLoc replica=xLocList.getReplica(i);
    List<Object> replicaAsList=new ArrayList<Object>(2);
    Map<String,Object> policyMap=stripingPolicyToMap(replica.getStripingPolicy());
    List<String> osdList=new ArrayList<String>(replica.getOSDCount());
    for (int j=0; j < replica.getOSDCount(); j++)     osdList.add(replica.getOSD(j));
    replicaAsList.add(policyMap);
    replicaAsList.add(osdList);
    replicaList.add(replicaAsList);
  }
  list.add(replicaList);
  list.add(xLocList.getVersion());
  return list;
}",0.9988925802879292
113841,"@Override public StripingPolicy getDefaultStripingPolicy(long fileId) throws DatabaseException {
  try {
    String spString=getXAttr(fileId,SYSTEM_UID,DEFAULT_SP_ATTR_NAME);
    if (spString == null)     return null;
    return Converter.stringToStripingPolicy(this,spString);
  }
 catch (  DatabaseException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new DatabaseException(exc);
  }
}","@Override public StripingPolicy getDefaultStripingPolicy(long fileId) throws DatabaseException {
  try {
    String spString=getXAttr(fileId,SYSTEM_UID,DEFAULT_SP_ATTR_NAME);
    if (spString == null)     return null;
    return Converter.mapToStripingPolicy(this,(Map<String,Object>)JSONParser.parseJSON(new JSONString(spString)));
  }
 catch (  DatabaseException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new DatabaseException(exc);
  }
}",0.9040462427745664
113842,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=sMan.create(res.getParentDirId(),res.getFileName(),rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.stripingPolicy,rqArgs.mode,null,false,update);
    if (rqArgs.xAttrs != null) {
      for (      Entry<String,Object> attr : rqArgs.xAttrs.entrySet())       sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    }
    if (rqArgs.open) {
      String capability=MRCOpHelper.createCapability(AccessMode.w.toString(),volume.getId(),file.getId(),0,master.getConfig().getCapabilitySecret()).toString();
      XLocList xLocList=file.getXLocList();
      if (xLocList == null || !xLocList.iterator().hasNext()) {
        xLocList=MRCOpHelper.createXLocList(xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
        file.setXLocList(xLocList);
        sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
      }
      HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
      rq.setAdditionalResponseHeaders(headers);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    final Path p=new Path(rqArgs.filePath);
    final VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    final StorageManager sMan=vMan.getStorageManager(volume.getId());
    final PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    faMan.checkPermission(FileAccessManager.WRITE_ACCESS,sMan,res.getParentDir(),res.getParentsParentId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileExistsAlready();
    AtomicDBUpdate update=sMan.createAtomicDBUpdate(master,rq);
    FileMetadata file=sMan.create(res.getParentDirId(),res.getFileName(),rq.getDetails().userId,rq.getDetails().groupIds.get(0),rqArgs.stripingPolicy,rqArgs.mode,null,false,update);
    if (rqArgs.xAttrs != null) {
      for (      Entry<String,Object> attr : rqArgs.xAttrs.entrySet())       sMan.setXAttr(file.getId(),rq.getDetails().userId,attr.getKey(),attr.getValue().toString(),update);
    }
    if (rqArgs.open) {
      String capability=MRCOpHelper.createCapability(AccessMode.w.toString(),volume.getId(),file.getId(),0,master.getConfig().getCapabilitySecret()).toString();
      XLocList xLocList=file.getXLocList();
      if (xLocList == null || !xLocList.iterator().hasNext()) {
        xLocList=MRCOpHelper.createXLocList(Converter.mapToStripingPolicy(sMan,rqArgs.stripingPolicy),xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
        file.setXLocList(xLocList);
        sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
      }
      HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
      rq.setAdditionalResponseHeaders(headers);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),file,!master.getConfig().isNoAtime(),true,true,sMan,update);
      MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),false,true,true,sMan,update);
    }
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    update.execute();
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.989040060468632
113843,"/** 
 * Creates a new X-Locations list
 * @param xLocList an existing X-Locations list containing a version number (may be <tt>null</tt>)
 * @param sMan the Storage Manager responsible for the file
 * @param osdMan the OSD Status Manager that periodically reports a list of usable OSDs
 * @param res the path resolver the ID of the parent directory
 * @param volume information about the volume of the file
 * @return an X-Locations list
 * @throws UserException
 * @throws BackendException
 * @throws BrainException
 */
public static XLocList createXLocList(XLocList xLocList,StorageManager sMan,OSDStatusManager osdMan,String path,long fileId,long parentDirId,VolumeInfo volume,InetSocketAddress clientAddress) throws DatabaseException, MRCException {
  assert(xLocList == null || xLocList.getReplicaCount() == 0);
  StripingPolicy stripingPolicy=sMan.getDefaultStripingPolicy(fileId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new MRCException(""String_Node_Str"" + path + ""String_Node_Str"");
  Map<String,Map<String,Object>> osdMaps=(Map<String,Map<String,Object>>)osdMan.getUsableOSDs(volume.getId());
  if (osdMaps == null || osdMaps.size() == 0)   throw new MRCException(""String_Node_Str"" + path + ""String_Node_Str"");
  int width=Math.min((int)stripingPolicy.getWidth(),osdMaps.size());
  stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  String[] osds=osdMan.getOSDSelectionPolicy(volume.getOsdPolicyId()).getOSDsForNewFile(osdMaps,clientAddress.getAddress(),width,volume.getOsdPolicyArgs());
  XLoc[] replicas=new XLoc[]{sMan.createXLoc(stripingPolicy,osds)};
  xLocList=sMan.createXLocList(replicas,xLocList == null ? 1 : (xLocList.getVersion() + 1));
  return xLocList;
}","/** 
 * Creates a new X-Locations list
 * @param xLocList an existing X-Locations list containing a version number (may be <tt>null</tt>)
 * @param sMan the Storage Manager responsible for the file
 * @param osdMan the OSD Status Manager that periodically reports a list of usable OSDs
 * @param res the path resolver the ID of the parent directory
 * @param volume information about the volume of the file
 * @return an X-Locations list
 * @throws UserException
 * @throws BackendException
 * @throws BrainException
 */
public static XLocList createXLocList(StripingPolicy stripingPolicy,XLocList xLocList,StorageManager sMan,OSDStatusManager osdMan,String path,long fileId,long parentDirId,VolumeInfo volume,InetSocketAddress clientAddress) throws DatabaseException, MRCException {
  assert(xLocList == null || xLocList.getReplicaCount() == 0);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(parentDirId);
  if (stripingPolicy == null)   stripingPolicy=sMan.getDefaultStripingPolicy(1);
  if (stripingPolicy == null)   throw new MRCException(""String_Node_Str"" + path + ""String_Node_Str"");
  Map<String,Map<String,Object>> osdMaps=(Map<String,Map<String,Object>>)osdMan.getUsableOSDs(volume.getId());
  if (osdMaps == null || osdMaps.size() == 0)   throw new MRCException(""String_Node_Str"" + path + ""String_Node_Str"");
  int width=Math.min((int)stripingPolicy.getWidth(),osdMaps.size());
  stripingPolicy=sMan.createStripingPolicy(stripingPolicy.getPattern(),stripingPolicy.getStripeSize(),width);
  String[] osds=osdMan.getOSDSelectionPolicy(volume.getOsdPolicyId()).getOSDsForNewFile(osdMaps,clientAddress.getAddress(),width,volume.getOsdPolicyArgs());
  XLoc[] replicas=new XLoc[]{sMan.createXLoc(stripingPolicy,osds)};
  xLocList=sMan.createXLocList(replicas,xLocList == null ? 1 : (xLocList.getVersion() + 1));
  return xLocList;
}",0.9732450331125828
113844,"@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    AccessMode mode=null;
    try {
      mode=AccessMode.valueOf(rqArgs.accessMode);
    }
 catch (    IllegalArgumentException exc) {
      throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.accessMode);
    }
    if ((mode == AccessMode.w || mode == AccessMode.a || mode == AccessMode.ga || mode == AccessMode.t) && file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    AtomicDBUpdate update=null;
    if (mode == AccessMode.t) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    faMan.checkPermission(rqArgs.accessMode,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    String capability=MRCOpHelper.createCapability(rqArgs.accessMode,volume.getId(),file.getId(),file.getIssuedEpoch(),master.getConfig().getCapabilitySecret()).toString();
    XLocList xLocList=file.getXLocList();
    if (xLocList == null || !xLocList.iterator().hasNext()) {
      xLocList=MRCOpHelper.createXLocList(xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
      file.setXLocList(xLocList);
      if (update == null)       update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
    HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
    rq.setAdditionalResponseHeaders(headers);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (update == null)     update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}","@Override public void startRequest(MRCRequest rq){
  try {
    Args rqArgs=(Args)rq.getRequestArgs();
    final VolumeManager vMan=master.getVolumeManager();
    final FileAccessManager faMan=master.getFileAccessManager();
    Path p=new Path(rqArgs.path);
    VolumeInfo volume=vMan.getVolumeByName(p.getComp(0));
    StorageManager sMan=vMan.getStorageManager(volume.getId());
    PathResolver res=new PathResolver(sMan,p);
    faMan.checkSearchPermission(sMan,res,rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    res.checkIfFileDoesNotExist();
    FileMetadata file=res.getFile();
    String target=sMan.getSoftlinkTarget(file.getId());
    if (target != null) {
      rqArgs.path=target;
      p=new Path(rqArgs.path);
      if (!vMan.hasVolume(p.getComp(0))) {
        finishRequest(rq,new ErrorRecord(ErrorClass.REDIRECT,target));
        return;
      }
      volume=vMan.getVolumeByName(p.getComp(0));
      sMan=vMan.getStorageManager(volume.getId());
      res=new PathResolver(sMan,p);
      file=res.getFile();
    }
    if (file.isDirectory())     throw new UserException(ErrNo.EISDIR,""String_Node_Str"");
    AccessMode mode=null;
    try {
      mode=AccessMode.valueOf(rqArgs.accessMode);
    }
 catch (    IllegalArgumentException exc) {
      throw new UserException(ErrNo.EINVAL,""String_Node_Str"" + rqArgs.accessMode);
    }
    if ((mode == AccessMode.w || mode == AccessMode.a || mode == AccessMode.ga || mode == AccessMode.t) && file.isReadOnly())     throw new UserException(ErrNo.EPERM,""String_Node_Str"");
    faMan.checkPermission(rqArgs.accessMode,sMan,file,res.getParentDirId(),rq.getDetails().userId,rq.getDetails().superUser,rq.getDetails().groupIds);
    AtomicDBUpdate update=null;
    if (mode == AccessMode.t) {
      update=sMan.createAtomicDBUpdate(master,rq);
      file.setIssuedEpoch(file.getIssuedEpoch() + 1);
      sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    }
    String capability=MRCOpHelper.createCapability(rqArgs.accessMode,volume.getId(),file.getId(),file.getIssuedEpoch(),master.getConfig().getCapabilitySecret()).toString();
    XLocList xLocList=file.getXLocList();
    if (xLocList == null || !xLocList.iterator().hasNext()) {
      StripingPolicy sp=sMan.getDefaultStripingPolicy(file.getId());
      xLocList=MRCOpHelper.createXLocList(sp,xLocList,sMan,master.getOSDStatusManager(),res.toString(),file.getId(),res.getParentDirId(),volume,rq.getPinkyRequest().getClientAddress());
      file.setXLocList(xLocList);
      if (update == null)       update=sMan.createAtomicDBUpdate(master,rq);
      sMan.setMetadata(file,FileMetadata.XLOC_METADATA,update);
    }
    HTTPHeaders headers=MRCOpHelper.createXCapHeaders(capability,xLocList);
    rq.setAdditionalResponseHeaders(headers);
    rq.setData(ReusableBuffer.wrap(JSONParser.writeJSON(null).getBytes()));
    if (update == null)     update=sMan.createAtomicDBUpdate(master,rq);
    if (!master.getConfig().isNoAtime())     MRCOpHelper.updateFileTimes(res.getParentsParentId(),res.getParentDir(),true,false,false,sMan,update);
    if (update != null)     update.execute();
 else     finishRequest(rq);
  }
 catch (  UserException exc) {
    Logging.logMessage(Logging.LEVEL_TRACE,this,exc);
    finishRequest(rq,new ErrorRecord(ErrorClass.USER_EXCEPTION,exc.getErrno(),exc.getMessage(),exc));
  }
catch (  Exception exc) {
    finishRequest(rq,new ErrorRecord(ErrorClass.INTERNAL_SERVER_ERROR,""String_Node_Str"",exc));
  }
}",0.9456395348837208
113845,"/** 
 * Converts a map containing striping policy information to a <code>StripingPolicy</code> object.
 * @param policyMap
 * @return
 */
public static StripingPolicy mapToStripingPolicy(StorageManager sMan,Map<String,Object> policyMap){
  if (policyMap == null || policyMap.isEmpty())   return null;
  StripingPolicy policy=sMan.createStripingPolicy((String)policyMap.get(""String_Node_Str""),((Long)policyMap.get(""String_Node_Str"")).intValue(),((Long)policyMap.get(""String_Node_Str"")).intValue());
  return policy;
}","/** 
 * Converts a map containing striping policy information to a <code>StripingPolicy</code> object.
 * @param policyMap
 * @return
 */
public static StripingPolicy mapToStripingPolicy(StorageManager sMan,Map<String,Object> policyMap){
  if (policyMap == null || policyMap.isEmpty() || ((String)policyMap.get(""String_Node_Str"")).isEmpty())   return null;
  StripingPolicy policy=sMan.createStripingPolicy((String)policyMap.get(""String_Node_Str""),((Long)policyMap.get(""String_Node_Str"")).intValue(),((Long)policyMap.get(""String_Node_Str"")).intValue());
  return policy;
}",0.9485294117647058
113846,"/** 
 * Parse the Locations header
 * @param rq the request
 * @param loc the locations header string
 * @return an error, null if successfull
 */
protected ErrorRecord parseLocations(OSDRequest rq,String loc){
  int locVer=-1;
  try {
    int lastComma=loc.lastIndexOf(',');
    String lastArg=loc.substring(lastComma + 1,loc.length() - 1);
    if (lastArg.indexOf('""') >= 0) {
      int sndLastComma=loc.substring(0,lastComma).lastIndexOf(',');
      String tmp=loc.substring(sndLastComma + 1,lastComma);
      tmp=tmp.trim();
      locVer=Integer.parseInt(tmp);
    }
 else {
      lastArg=lastArg.trim();
      locVer=Integer.parseInt(lastArg);
    }
  }
 catch (  Exception e) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,null,e);
    }
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,HTTPHeaders.HDR_XLOCATIONS + ""String_Node_Str"",e);
  }
  Locations cachedLoc=xLocCache.getLocations(rq.getDetails().getFileId());
  if ((cachedLoc != null) && (cachedLoc.getVersion() == locVer)) {
    rq.getDetails().setLocationList(cachedLoc);
  }
 else {
    try {
      Locations receivedLoc=new Locations(new JSONString(loc));
      if ((receivedLoc.getNumberOfReplicas() == 0) && (cachedLoc == null)) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.NEED_FULL_XLOC,""String_Node_Str"");
      }
      if ((cachedLoc != null) && (cachedLoc.getVersion() > locVer)) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.XLOC_OUTDATED,""String_Node_Str"" + cachedLoc.getVersion() + ""String_Node_Str""+ locVer);
      }
      xLocCache.update(rq.getDetails().getFileId(),receivedLoc);
      rq.getDetails().setLocationList(receivedLoc);
    }
 catch (    JSONException ex) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,""String_Node_Str"",ex);
    }
  }
  try {
    rq.getDetails().getLocationList().resolveAll();
  }
 catch (  UnknownUUIDException ex) {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,""String_Node_Str"" + ex);
  }
  final Location currentReplica=rq.getDetails().getLocationList().getLocation(master.getConfig().getUUID());
  if (currentReplica == null) {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.NOT_IN_XLOC,""String_Node_Str"" + master.getConfig().getUUID() + ""String_Node_Str"");
  }
  rq.getDetails().setCurrentReplica(currentReplica);
  return null;
}","/** 
 * Parse the Locations header
 * @param rq the request
 * @param loc the locations header string
 * @return an error, null if successfull
 */
protected ErrorRecord parseLocations(OSDRequest rq,String loc){
  int locVer=-1;
  try {
    int lastComma=loc.lastIndexOf(',');
    String lastArg=loc.substring(lastComma + 1,loc.length() - 1);
    if (lastArg.indexOf('""') >= 0) {
      int sndLastComma=loc.substring(0,lastComma).lastIndexOf(',');
      String tmp=loc.substring(sndLastComma + 1,lastComma);
      tmp=tmp.trim();
      locVer=Integer.parseInt(tmp);
    }
 else {
      lastArg=lastArg.trim();
      locVer=Integer.parseInt(lastArg);
    }
  }
 catch (  Exception e) {
    if (Logging.isDebug()) {
      Logging.logMessage(Logging.LEVEL_DEBUG,null,e);
    }
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,HTTPHeaders.HDR_XLOCATIONS + ""String_Node_Str"",e);
  }
  Locations cachedLoc=xLocCache.getLocations(rq.getDetails().getFileId());
  if ((cachedLoc != null) && (cachedLoc.getVersion() == locVer)) {
    rq.getDetails().setLocationList(cachedLoc);
  }
 else {
    try {
      Locations receivedLoc=new Locations(new JSONString(loc));
      if ((receivedLoc.getNumberOfReplicas() == 0) && (cachedLoc == null)) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.NEED_FULL_XLOC,""String_Node_Str"");
      }
      if ((cachedLoc != null) && (cachedLoc.getVersion() > locVer)) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.XLOC_OUTDATED,""String_Node_Str"" + cachedLoc.getVersion() + ""String_Node_Str""+ locVer);
      }
      xLocCache.update(rq.getDetails().getFileId(),receivedLoc);
      rq.getDetails().setLocationList(receivedLoc);
    }
 catch (    JSONException ex) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,""String_Node_Str"",ex);
    }
catch (    ClassCastException ex) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,""String_Node_Str"",ex);
    }
  }
  try {
    rq.getDetails().getLocationList().resolveAll();
  }
 catch (  UnknownUUIDException ex) {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_HEADER,""String_Node_Str"" + ex);
  }
  final Location currentReplica=rq.getDetails().getLocationList().getLocation(master.getConfig().getUUID());
  if (currentReplica == null) {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.NOT_IN_XLOC,""String_Node_Str"" + master.getConfig().getUUID() + ""String_Node_Str"");
  }
  rq.getDetails().setCurrentReplica(currentReplica);
  return null;
}",0.9709856915739268
113847,"@Override public void execute() throws DatabaseException {
  try {
    if (listener != null)     database.asyncInsert(ig,listener,context);
 else     database.syncInsert(ig);
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}","@Override public void execute() throws DatabaseException {
  try {
    if (listener != null) {
      database.syncInsert(ig);
      listener.insertFinished(context);
    }
 else     database.syncInsert(ig);
  }
 catch (  BabuDBException exc) {
    throw new DatabaseException(exc);
  }
}",0.8671586715867159
113848,"public VolumeInfo getVolumeById(String volumeId) throws DatabaseException, UserException {
  return volIdMap.get(volumeId);
}","public VolumeInfo getVolumeById(String volumeId) throws DatabaseException, UserException {
  VolumeInfo volume=volIdMap.get(volumeId);
  if (volume == null)   throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + volumeId + ""String_Node_Str"");
  return volume;
}",0.6051282051282051
113849,"public VolumeInfo getVolumeByName(String volumeName) throws DatabaseException, UserException {
  return volNameMap.get(volumeName);
}","public VolumeInfo getVolumeByName(String volumeName) throws DatabaseException, UserException {
  VolumeInfo info=volNameMap.get(volumeName);
  if (info == null)   throw new UserException(ErrNo.ENOENT,""String_Node_Str"" + volumeName + ""String_Node_Str"");
  return info;
}",0.6268656716417911
113850,"public void run(){
  List<RPCResponse> responses=new LinkedList<RPCResponse>();
  Map<String,Long> verMap=new HashMap<String,Long>();
  try {
    for (    Entry<String,Map<String,Object>> mapEntry : serviceDataGen.getServiceData().entrySet()) {
      if (!""String_Node_Str"".equals(mapEntry.getValue().get(""String_Node_Str""))) {
        RPCResponse r=client.deregisterEntity(mapEntry.getKey(),authString);
        r.waitForResponse();
        responses.add(r);
      }
      registerEntity(mapEntry.getKey(),mapEntry.getValue(),verMap,authString,responses);
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,uuid + ""String_Node_Str"");
    }
    List<Map<String,Object>> endpoints=null;
    if (config.getAddress() == null) {
      endpoints=NetUtils.getReachableEndpoints(uuid.getAddress().getPort(),uuid.getProtocol());
    }
 else {
      endpoints=new ArrayList(1);
      Map<String,Object> m=RPCClient.generateMap(""String_Node_Str"",config.getAddress().toString(),""String_Node_Str"",uuid.getAddress().getPort(),""String_Node_Str"",uuid.getProtocol(),""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str"");
      endpoints.add(m);
    }
    long version=0;
    RPCResponse r2=client.getAddressMapping(uuid.toString(),authString);
    try {
      Map<String,List<Object>> result=(Map<String,List<Object>>)r2.get();
      Collection<Entry<String,List<Object>>> entries=result.entrySet();
      if (entries.size() != 0) {
        List<Object> valueList=entries.iterator().next().getValue();
        version=(Long)valueList.get(0);
      }
    }
  finally {
      responses.add(r2);
    }
    RPCResponse r3=client.registerAddressMapping(uuid.toString(),endpoints,version,authString);
    try {
      r3.waitForResponse();
    }
  finally {
      responses.add(r3);
    }
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + OutputUtils.stackTraceToString(ex));
    notifyCrashed(ex);
  }
 finally {
    for (    RPCResponse resp : responses)     resp.freeBuffers();
  }
  notifyStarted();
  while (!quit) {
    responses.clear();
    try {
      for (      Entry<String,Map<String,Object>> mapEntry : serviceDataGen.getServiceData().entrySet()) {
        registerEntity(mapEntry.getKey(),mapEntry.getValue(),verMap,authString,responses);
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,this,uuid + ""String_Node_Str"");
      }
    }
 catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    }
catch (    JSONException ex) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    }
catch (    InterruptedException ex) {
      quit=true;
      break;
    }
 finally {
      for (      RPCResponse resp : responses)       resp.freeBuffers();
    }
    if (quit)     break;
    try {
      Thread.sleep(UPDATE_INTERVAL);
    }
 catch (    InterruptedException e) {
    }
  }
  notifyStopped();
}","public void run(){
  List<RPCResponse> responses=new LinkedList<RPCResponse>();
  Map<String,Long> verMap=new HashMap<String,Long>();
  try {
    for (    Entry<String,Map<String,Object>> mapEntry : serviceDataGen.getServiceData().entrySet()) {
      if (!""String_Node_Str"".equals(mapEntry.getValue().get(""String_Node_Str""))) {
        RPCResponse r=client.deregisterEntity(mapEntry.getKey(),authString);
        r.waitForResponse();
        responses.add(r);
      }
      registerEntity(mapEntry.getKey(),mapEntry.getValue(),verMap,authString,responses);
      if (Logging.isDebug())       Logging.logMessage(Logging.LEVEL_DEBUG,this,uuid + ""String_Node_Str"");
    }
    List<Map<String,Object>> endpoints=null;
    if (config.getAddress() == null) {
      endpoints=NetUtils.getReachableEndpoints(uuid.getAddress().getPort(),uuid.getProtocol());
    }
 else {
      endpoints=new ArrayList(1);
      String dottedQuad=config.getAddress().toString();
      if (dottedQuad.startsWith(""String_Node_Str""))       dottedQuad=dottedQuad.substring(1);
      Map<String,Object> m=RPCClient.generateMap(""String_Node_Str"",dottedQuad,""String_Node_Str"",uuid.getAddress().getPort(),""String_Node_Str"",uuid.getProtocol(),""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str"");
      endpoints.add(m);
    }
    long version=0;
    RPCResponse r2=client.getAddressMapping(uuid.toString(),authString);
    try {
      Map<String,List<Object>> result=(Map<String,List<Object>>)r2.get();
      Collection<Entry<String,List<Object>>> entries=result.entrySet();
      if (entries.size() != 0) {
        List<Object> valueList=entries.iterator().next().getValue();
        version=(Long)valueList.get(0);
      }
    }
  finally {
      responses.add(r2);
    }
    RPCResponse r3=client.registerAddressMapping(uuid.toString(),endpoints,version,authString);
    try {
      r3.waitForResponse();
    }
  finally {
      responses.add(r3);
    }
  }
 catch (  Exception ex) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,""String_Node_Str"" + OutputUtils.stackTraceToString(ex));
    notifyCrashed(ex);
  }
 finally {
    for (    RPCResponse resp : responses)     resp.freeBuffers();
  }
  notifyStarted();
  while (!quit) {
    responses.clear();
    try {
      for (      Entry<String,Map<String,Object>> mapEntry : serviceDataGen.getServiceData().entrySet()) {
        registerEntity(mapEntry.getKey(),mapEntry.getValue(),verMap,authString,responses);
        if (Logging.isDebug())         Logging.logMessage(Logging.LEVEL_DEBUG,this,uuid + ""String_Node_Str"");
      }
    }
 catch (    IOException ex) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    }
catch (    JSONException ex) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,ex);
    }
catch (    InterruptedException ex) {
      quit=true;
      break;
    }
 finally {
      for (      RPCResponse resp : responses)       resp.freeBuffers();
    }
    if (quit)     break;
    try {
      Thread.sleep(UPDATE_INTERVAL);
    }
 catch (    InterruptedException e) {
    }
  }
  notifyStopped();
}",0.9682698730794924
113851,"@Override public void init(String ownerId,String owningGroupId,int perms,ACLEntry[] acl,Map<String,Object> rootDirDefSp,AtomicDBUpdate update) throws DatabaseException {
  int time=(int)(TimeSync.getGlobalTime() / 1000);
  createDir(1,0,volumeName,time,time,time,ownerId,owningGroupId,perms,0,update);
  setLastFileId(1,update);
  if (rootDirDefSp != null)   setDefaultStripingPolicy(1,Converter.mapToStripingPolicy(this,rootDirDefSp),update);
  if (acl != null)   for (  ACLEntry entry : acl)   setACLEntry(1L,entry.getEntity(),entry.getRights(),update);
}","@Override public void init(String ownerId,String owningGroupId,int perms,ACLEntry[] acl,Map<String,Object> rootDirDefSp,AtomicDBUpdate update) throws DatabaseException {
  try {
    int time=(int)(TimeSync.getGlobalTime() / 1000);
    createDir(1,0,volumeName,time,time,time,ownerId,owningGroupId,perms,0,update);
    setLastFileId(1,update);
    if (rootDirDefSp != null)     setDefaultStripingPolicy(1,Converter.mapToStripingPolicy(this,rootDirDefSp),update);
    if (acl != null)     for (    ACLEntry entry : acl)     setACLEntry(1L,entry.getEntity(),entry.getRights(),update);
  }
 catch (  UserException exc) {
    throw new DatabaseException(exc);
  }
}",0.915365653245686
113852,"/** 
 * Parse request and execute method
 * @param method stagemethod to execute
 */
private void parseAndExecute(StageMethod method){
  final MRCRequest rq=method.getRq();
  final PinkyRequest theRequest=rq.getPinkyRequest();
  final String URI=theRequest.requestURI.startsWith(""String_Node_Str"") ? theRequest.requestURI.substring(1) : theRequest.requestURI;
  final MRCOperation op=operations.get(URI);
  if (op == null) {
    rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + URI + ""String_Node_Str""));
    master.requestFinished(rq);
    return;
  }
  if (op.hasArguments()) {
    if ((theRequest.requestBody == null) || (theRequest.requestBody.capacity() == 0)) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + URI + ""String_Node_Str""));
      master.requestFinished(rq);
      return;
    }
    List<Object> args=null;
    try {
      final JSONString jst=new JSONString(new String(theRequest.getBody(),HTTPUtils.ENC_UTF8));
      Object o=JSONParser.parseJSON(jst);
      args=(List<Object>)o;
    }
 catch (    ClassCastException ex) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str""));
      master.requestFinished(rq);
      return;
    }
catch (    JSONException ex) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + ex));
      master.requestFinished(rq);
      return;
    }
    op.parseRPCBody(rq,args);
  }
  if (op.isAuthRequired()) {
    try {
      String authHeader=theRequest.requestHeaders.getHeader(HTTPHeaders.HDR_AUTHORIZATION);
      if (authHeader == null)       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      UserCredentials cred=null;
      try {
        cred=master.getAuthProvider().getEffectiveCredentials(authHeader,theRequest.getChannelIO());
        rq.getDetails().superUser=cred.isSuperUser();
        rq.getDetails().groupIds=cred.getGroupIDs();
        rq.getDetails().userId=cred.getUserID();
      }
 catch (      AuthenticationException ex) {
        throw new UserException(ErrNo.EPERM,ex.getMessage());
      }
    }
 catch (    Exception exc) {
      method.getRq().setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"",exc));
      master.requestFinished(method.getRq());
      return;
    }
  }
  op.startRequest(rq);
}","/** 
 * Parse request and execute method
 * @param method stagemethod to execute
 */
private void parseAndExecute(StageMethod method){
  final MRCRequest rq=method.getRq();
  final PinkyRequest theRequest=rq.getPinkyRequest();
  final String URI=theRequest.requestURI.startsWith(""String_Node_Str"") ? theRequest.requestURI.substring(1) : theRequest.requestURI;
  final MRCOperation op=operations.get(URI);
  if (op == null) {
    rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + URI + ""String_Node_Str""));
    master.requestFinished(rq);
    return;
  }
  if (op.hasArguments()) {
    if ((theRequest.requestBody == null) || (theRequest.requestBody.capacity() == 0)) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + URI + ""String_Node_Str""));
      master.requestFinished(rq);
      return;
    }
    List<Object> args=null;
    try {
      final JSONString jst=new JSONString(new String(theRequest.getBody(),HTTPUtils.ENC_UTF8));
      Object o=JSONParser.parseJSON(jst);
      args=(List<Object>)o;
    }
 catch (    ClassCastException ex) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str""));
      master.requestFinished(rq);
      return;
    }
catch (    JSONException ex) {
      rq.setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"" + ex));
      master.requestFinished(rq);
      return;
    }
    ErrorRecord error=op.parseRPCBody(rq,args);
    if (error != null) {
      rq.setError(error);
      master.requestFinished(rq);
      return;
    }
  }
  if (op.isAuthRequired()) {
    try {
      String authHeader=theRequest.requestHeaders.getHeader(HTTPHeaders.HDR_AUTHORIZATION);
      if (authHeader == null)       throw new UserException(ErrNo.EPERM,""String_Node_Str"");
      UserCredentials cred=null;
      try {
        cred=master.getAuthProvider().getEffectiveCredentials(authHeader,theRequest.getChannelIO());
        rq.getDetails().superUser=cred.isSuperUser();
        rq.getDetails().groupIds=cred.getGroupIDs();
        rq.getDetails().userId=cred.getUserID();
      }
 catch (      AuthenticationException ex) {
        throw new UserException(ErrNo.EPERM,ex.getMessage());
      }
    }
 catch (    Exception exc) {
      method.getRq().setError(new ErrorRecord(ErrorRecord.ErrorClass.BAD_REQUEST,""String_Node_Str"",exc));
      master.requestFinished(method.getRq());
      return;
    }
  }
  op.startRequest(rq);
}",0.974592026440818
113853,"private String getStatusPage() throws SQLException, JSONException {
  long time=System.currentTimeMillis();
  Object[] dbDump=getDBDump();
  Map<String,Map<String,String>> entities=(Map<String,Map<String,String>>)dbDump[0];
  Map<String,Object[]> mappings=(Map<String,Object[]>)dbDump[1];
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  for (  String uuid : mappings.keySet()) {
    Object[] entry=mappings.get(uuid);
    List<Map<String,Object>> mapping=(List<Map<String,Object>>)entry[1];
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    for (int i=0; i < mapping.size(); i++) {
      dump.append(""String_Node_Str"");
      Map<String,Object> map=mapping.get(i);
      String endpoint=map.get(""String_Node_Str"") + ""String_Node_Str"" + map.get(""String_Node_Str"")+ ""String_Node_Str""+ map.get(""String_Node_Str"");
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(map.get(""String_Node_Str""));
      dump.append(""String_Node_Str"");
      dump.append(map.get(""String_Node_Str""));
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(entry[2]);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  for (  String uuid : entities.keySet()) {
    Map<String,String> entry=entities.get(uuid);
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    List<String> keys=new LinkedList<String>(entry.keySet());
    Collections.sort(keys);
    for (    String key : keys) {
      if (key.equals(""String_Node_Str""))       continue;
      dump.append(""String_Node_Str"");
      dump.append(key);
      dump.append(""String_Node_Str"");
      dump.append(entry.get(key));
      if (key.equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(new Date(Long.parseLong(entry.get(key)) * 1000));
        dump.append(""String_Node_Str"");
      }
 else       if (key.equals(""String_Node_Str"") || key.equals(""String_Node_Str"") || key.endsWith(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(OutputUtils.formatBytes(Long.parseLong(entry.get(key))));
        dump.append(""String_Node_Str"");
      }
 else       if (key.equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
      }
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(entry.get(""String_Node_Str""));
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(pinkyStage.getNumConnections()));
  tmp=tmp.replace(Vars.PINKYQ.toString(),Integer.toString(pinkyStage.getTotalQLength()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Integer.toString(_stat_numRequests));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  return tmp;
}","private String getStatusPage() throws SQLException, JSONException {
  assert(statusPageTemplate != null);
  long time=System.currentTimeMillis();
  Object[] dbDump=getDBDump();
  Map<String,Map<String,String>> entities=(Map<String,Map<String,String>>)dbDump[0];
  Map<String,Object[]> mappings=(Map<String,Object[]>)dbDump[1];
  StringBuilder dump=new StringBuilder();
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  for (  String uuid : mappings.keySet()) {
    Object[] entry=mappings.get(uuid);
    List<Map<String,Object>> mapping=(List<Map<String,Object>>)entry[1];
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    for (int i=0; i < mapping.size(); i++) {
      dump.append(""String_Node_Str"");
      Map<String,Object> map=mapping.get(i);
      String endpoint=map.get(""String_Node_Str"") + ""String_Node_Str"" + map.get(""String_Node_Str"")+ ""String_Node_Str""+ map.get(""String_Node_Str"");
      dump.append(""String_Node_Str"" + endpoint + ""String_Node_Str"");
      dump.append(endpoint);
      dump.append(""String_Node_Str"");
      dump.append(map.get(""String_Node_Str""));
      dump.append(""String_Node_Str"");
      dump.append(map.get(""String_Node_Str""));
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(""String_Node_Str"");
    dump.append(entry[2]);
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  dump.append(""String_Node_Str"");
  for (  String uuid : entities.keySet()) {
    Map<String,String> entry=entities.get(uuid);
    dump.append(""String_Node_Str"");
    dump.append(uuid);
    dump.append(""String_Node_Str"");
    List<String> keys=new LinkedList<String>(entry.keySet());
    Collections.sort(keys);
    for (    String key : keys) {
      if (key.equals(""String_Node_Str""))       continue;
      dump.append(""String_Node_Str"");
      dump.append(key);
      dump.append(""String_Node_Str"");
      dump.append(entry.get(key));
      if (key.equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(new Date(Long.parseLong(entry.get(key)) * 1000));
        dump.append(""String_Node_Str"");
      }
 else       if (key.equals(""String_Node_Str"") || key.equals(""String_Node_Str"") || key.endsWith(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
        dump.append(OutputUtils.formatBytes(Long.parseLong(entry.get(key))));
        dump.append(""String_Node_Str"");
      }
 else       if (key.equals(""String_Node_Str"")) {
        dump.append(""String_Node_Str"");
      }
      dump.append(""String_Node_Str"");
    }
    dump.append(""String_Node_Str"");
    dump.append(entry.get(""String_Node_Str""));
    dump.append(""String_Node_Str"");
  }
  dump.append(""String_Node_Str"");
  String tmp=null;
  try {
    tmp=statusPageTemplate.replace(Vars.AVAILPROCS.toString(),Runtime.getRuntime().availableProcessors() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    tmp=statusPageTemplate;
  }
  tmp=tmp.replace(Vars.FREEMEM.toString(),Runtime.getRuntime().freeMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.MAXMEM.toString(),Runtime.getRuntime().maxMemory() + ""String_Node_Str"");
  tmp=tmp.replace(Vars.BPSTATS.toString(),BufferPool.getStatus());
  tmp=tmp.replace(Vars.PORT.toString(),Integer.toString(config.getPort()));
  tmp=tmp.replace(Vars.DEBUG.toString(),Integer.toString(config.getDebugLevel()));
  tmp=tmp.replace(Vars.NUMCON.toString(),Integer.toString(pinkyStage.getNumConnections()));
  tmp=tmp.replace(Vars.PINKYQ.toString(),Integer.toString(pinkyStage.getTotalQLength()));
  tmp=tmp.replace(Vars.NUMREQS.toString(),Integer.toString(_stat_numRequests));
  tmp=tmp.replace(Vars.TIME.toString(),new Date(time).toString() + ""String_Node_Str"" + time+ ""String_Node_Str"");
  tmp=tmp.replace(Vars.TABLEDUMP.toString(),dump.toString());
  return tmp;
}",0.995134443021767
113854,"/** 
 * Creates a new instance of RequestController 
 */
public RequestController(DIRConfig config) throws Exception {
  try {
    this.config=config;
    final AuthenticationProvider auth=(AuthenticationProvider)Class.forName(config.getAuthenticationProvider()).newInstance();
    auth.initialize(config.isUsingSSL());
    dirServiceStage=new DirServiceStage(config.getDbDir(),auth);
    dirServiceStage.setRequestListener(this);
    dirServiceStage.setLifeCycleListener(this);
    pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
    pinkyStage.setLifeCycleListener(this);
    StringBuffer sb=null;
    try {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (is == null)       is=this.getClass().getResourceAsStream(""String_Node_Str"");
      BufferedReader br=new BufferedReader(new InputStreamReader(is));
      sb=new StringBuffer();
      String line=br.readLine();
      while (line != null) {
        sb.append(line + ""String_Node_Str"");
        line=br.readLine();
      }
      br.close();
    }
 catch (    Exception ex) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    if (sb == null) {
      statusPageTemplate=""String_Node_Str"";
    }
 else {
      statusPageTemplate=sb.toString();
    }
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
  }
 catch (  Exception exc) {
    shutdown();
    throw exc;
  }
}","/** 
 * Creates a new instance of RequestController 
 */
public RequestController(DIRConfig config) throws Exception {
  try {
    this.config=config;
    final AuthenticationProvider auth=(AuthenticationProvider)Class.forName(config.getAuthenticationProvider()).newInstance();
    auth.initialize(config.isUsingSSL());
    dirServiceStage=new DirServiceStage(config.getDbDir(),auth);
    dirServiceStage.setRequestListener(this);
    dirServiceStage.setLifeCycleListener(this);
    pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
    pinkyStage.setLifeCycleListener(this);
    StringBuffer sb=null;
    try {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (is == null)       is=this.getClass().getResourceAsStream(""String_Node_Str"");
      BufferedReader br=new BufferedReader(new InputStreamReader(is));
      sb=new StringBuffer();
      String line=br.readLine();
      while (line != null) {
        sb.append(line + ""String_Node_Str"");
        line=br.readLine();
      }
      br.close();
    }
 catch (    Exception ex) {
      Logging.logMessage(Logging.LEVEL_DEBUG,this,ex);
    }
    if (sb == null) {
      statusPageTemplate=""String_Node_Str"";
    }
 else {
      statusPageTemplate=sb.toString();
    }
    Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
  }
 catch (  Exception exc) {
    Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
    shutdown();
    throw exc;
  }
}",0.9848569826135728
113855,"public void shutdown() throws Exception {
  try {
    String statusPageSnapshot=getStatusPage();
    BufferedWriter writer=new BufferedWriter(new FileWriter(config.getDbDir() + ""String_Node_Str""));
    writer.write(statusPageSnapshot);
    writer.close();
  }
 catch (  Exception exc) {
  }
  if (pinkyStage != null)   pinkyStage.shutdown();
  if (dirServiceStage != null)   dirServiceStage.shutdown();
  if (pinkyStage != null)   pinkyStage.waitForShutdown();
  if (dirServiceStage != null)   dirServiceStage.waitForShutdown();
}","public void shutdown() throws Exception {
  if (pinkyStage != null)   pinkyStage.shutdown();
  if (dirServiceStage != null)   dirServiceStage.shutdown();
  if (pinkyStage != null)   pinkyStage.waitForShutdown();
  if (dirServiceStage != null)   dirServiceStage.waitForShutdown();
}",0.1134401972872996
113856,"public void requestFinished(MRCRequest request){
  assert(request != null);
  final PinkyRequest pr=request.getPinkyRequest();
  assert(pr != null);
  if (request.getError() != null) {
    final ErrorRecord error=request.getError();
switch (error.getErrorClass()) {
case REDIRECT:
{
        Logging.logMessage(Logging.LEVEL_ERROR,this,error.getErrorMessage() + ""String_Node_Str"" + request);
        HTTPHeaders headers=new HTTPHeaders();
        headers.addHeader(HTTPHeaders.HDR_LOCATION + ""String_Node_Str"" + error.getErrorMessage());
        pr.setResponse(HTTPUtils.SC_SEE_OTHER,null,DATA_TYPE.JSON,headers);
      }
case INTERNAL_SERVER_ERROR:
{
      Logging.logMessage(Logging.LEVEL_ERROR,this,error.getErrorMessage() + ""String_Node_Str"" + request);
      pr.setResponse(HTTPUtils.SC_SERVER_ERROR,error.getErrorMessage() + ""String_Node_Str"");
      break;
    }
case USER_EXCEPTION:
{
    pr.setResponse(HTTPUtils.SC_USER_EXCEPTION,error.toJSON());
    break;
  }
case BAD_REQUEST:
{
  pr.setResponse(HTTPUtils.SC_BAD_REQUEST,error.getErrorMessage());
  break;
}
default :
{
pr.setResponse(HTTPUtils.SC_SERVER_ERROR,""String_Node_Str"" + error);
break;
}
}
if (request.getData() != null) BufferPool.free(request.getData());
}
 else {
if (request.getDataType() == null) request.setDataType(DATA_TYPE.JSON);
pr.setResponse(HTTPUtils.SC_OKAY,request.getData(),request.getDataType(),request.getAdditionalResponseHeaders());
}
pinkyStage.sendResponse(pr);
}","public void requestFinished(MRCRequest request){
  assert(request != null);
  final PinkyRequest pr=request.getPinkyRequest();
  assert(pr != null);
  if (request.getError() != null) {
    final ErrorRecord error=request.getError();
switch (error.getErrorClass()) {
case REDIRECT:
{
        Logging.logMessage(Logging.LEVEL_ERROR,this,error.getErrorMessage() + ""String_Node_Str"" + request);
        HTTPHeaders headers=new HTTPHeaders();
        headers.addHeader(HTTPHeaders.HDR_LOCATION + ""String_Node_Str"" + error.getErrorMessage());
        pr.setResponse(HTTPUtils.SC_SEE_OTHER,null,DATA_TYPE.JSON,headers);
        break;
      }
case INTERNAL_SERVER_ERROR:
{
      Logging.logMessage(Logging.LEVEL_ERROR,this,error.getErrorMessage() + ""String_Node_Str"" + request);
      pr.setResponse(HTTPUtils.SC_SERVER_ERROR,error.getErrorMessage() + ""String_Node_Str"");
      break;
    }
case USER_EXCEPTION:
{
    pr.setResponse(HTTPUtils.SC_USER_EXCEPTION,error.toJSON());
    break;
  }
case BAD_REQUEST:
{
  pr.setResponse(HTTPUtils.SC_BAD_REQUEST,error.getErrorMessage());
  break;
}
default :
{
pr.setResponse(HTTPUtils.SC_SERVER_ERROR,""String_Node_Str"" + error);
break;
}
}
if (request.getData() != null) BufferPool.free(request.getData());
}
 else {
if (request.getDataType() == null) request.setDataType(DATA_TYPE.JSON);
pr.setResponse(HTTPUtils.SC_OKAY,request.getData(),request.getDataType(),request.getAdditionalResponseHeaders());
}
pinkyStage.sendResponse(pr);
}",0.99487879822465
113857,"public void startup() throws Exception {
  speedyStage.start();
  speedyStage.waitForStartup();
  osdMonitor.start();
  osdMonitor.waitForStartup();
  procStage.start();
  procStage.waitForStartup();
  heartbeatThread.start();
  pinkyStage.start();
  pinkyStage.waitForStartup();
  volumeManager.init();
  volumeManager.addVolumeChangeListener(osdMonitor);
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
}","public void startup() throws Exception {
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew(),authString);
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  speedyStage.start();
  speedyStage.waitForStartup();
  osdMonitor.start();
  osdMonitor.waitForStartup();
  procStage.start();
  procStage.waitForStartup();
  heartbeatThread.start();
  pinkyStage.start();
  pinkyStage.waitForStartup();
  volumeManager.init();
  volumeManager.addVolumeChangeListener(osdMonitor);
  Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + config.getPort());
}",0.7857777777777778
113858,"public void shutdown() throws Exception {
  pinkyStage.shutdown();
  pinkyStage.waitForShutdown();
  heartbeatThread.shutdown();
  osdMonitor.shutdown();
  osdMonitor.waitForShutdown();
  procStage.shutdown();
  procStage.waitForShutdown();
  UUIDResolver.shutdown();
  TimeSync.getInstance().shutdown();
  speedyStage.shutdown();
  speedyStage.waitForShutdown();
  volumeManager.shutdown();
}","public void shutdown() throws Exception {
  pinkyStage.shutdown();
  pinkyStage.waitForShutdown();
  heartbeatThread.shutdown();
  osdMonitor.shutdown();
  osdMonitor.waitForShutdown();
  procStage.shutdown();
  procStage.waitForShutdown();
  UUIDResolver.shutdown();
  speedyStage.shutdown();
  speedyStage.waitForShutdown();
  volumeManager.shutdown();
  TimeSync.getInstance().shutdown();
}",0.7786259541984732
113859,"public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  dirClient=new DIRClient(speedyStage,config.getDirectoryService());
  TimeSync.initialize(dirClient,config.getRemoteTimeSync(),config.getLocalClockRenew(),authString);
  UUIDResolver.start(dirClient,10 * 1000,600 * 1000);
  UUIDResolver.addLocalMapping(config.getUUID(),config.getPort(),config.isUsingSSL());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public Map<String,Map<String,Object>> getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
      map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
      return map;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
}","public MRCRequestDispatcher(final MRCConfig config) throws IOException, JSONException, ClassNotFoundException, IllegalAccessException, InstantiationException, DatabaseException {
  this.config=config;
  authString=NullAuthProvider.createAuthString(config.getUUID().toString(),config.getUUID().toString());
  Logging.logMessage(Logging.LEVEL_DEBUG,this,""String_Node_Str"" + config.isUsingSSL());
  speedyStage=config.isUsingSSL() ? new MultiSpeedy(new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new MultiSpeedy();
  speedyStage.setLifeCycleListener(this);
  pinkyStage=config.isUsingSSL() ? new PipelinedPinky(config.getPort(),config.getAddress(),this,new SSLOptions(config.getServiceCredsFile(),config.getServiceCredsPassphrase(),config.getServiceCredsContainer(),config.getTrustedCertsFile(),config.getTrustedCertsPassphrase(),config.getTrustedCertsContainer(),false)) : new PipelinedPinky(config.getPort(),config.getAddress(),this);
  pinkyStage.setLifeCycleListener(this);
  dirClient=new DIRClient(speedyStage,config.getDirectoryService());
  policyContainer=new PolicyContainer(config);
  authProvider=policyContainer.getAuthenticationProvider();
  authProvider.initialize(config.isUsingSSL());
  if (Logging.isInfo())   Logging.logMessage(Logging.LEVEL_INFO,this,""String_Node_Str"" + authProvider.getClass().getName() + ""String_Node_Str"");
  osdMonitor=new OSDStatusManager(config,dirClient,policyContainer,authString);
  osdMonitor.setLifeCycleListener(this);
  procStage=new ProcessingStage(this);
  ServiceDataGenerator gen=new ServiceDataGenerator(){
    public Map<String,Map<String,Object>> getServiceData(){
      String uuid=config.getUUID().toString();
      OperatingSystemMXBean osb=ManagementFactory.getOperatingSystemMXBean();
      String load=String.valueOf((int)(osb.getSystemLoadAverage() * 100 / osb.getAvailableProcessors()));
      long totalRAM=Runtime.getRuntime().maxMemory();
      long usedRAM=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      Map<String,Map<String,Object>> map=new HashMap<String,Map<String,Object>>();
      map.put(uuid,RPCClient.generateMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",load,""String_Node_Str"",VersionManagement.getSupportedProtVersAsString(),""String_Node_Str"",Long.toString(totalRAM),""String_Node_Str"",Long.toString(usedRAM),""String_Node_Str"",config.getGeoCoordinates()));
      return map;
    }
  }
;
  heartbeatThread=new HeartbeatThread(""String_Node_Str"",dirClient,config.getUUID(),gen,authString,config);
  volumeManager=new BabuDBVolumeManager(this);
  fileAccessManager=new FileAccessManager(volumeManager,policyContainer);
}",0.9588667008021848
113860,"@Override public void removeACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,List<Object> entities,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    Map<String,Object> entries=new HashMap<String,Object>();
    for (    Object entity : entities)     entries.put((String)entity,null);
    setACLEntries(sMan,file,parentId,userId,groupIds,entries,update);
  }
 catch (  UserException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","@Override public void removeACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,List<Object> entities,AtomicDBUpdate update) throws MRCException, UserException {
  Map<String,Object> entries=new HashMap<String,Object>();
  for (  Object entity : entities)   entries.put((String)entity,null);
  setACLEntries(sMan,file,parentId,userId,groupIds,entries,update);
}",0.8580441640378549
113861,"@Override public void checkPermission(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,String accessMode) throws UserException, MRCException {
  assert(file != null);
  try {
    if (checkIfAllowed(sMan,accessMode,toRelativeACLRights(file.getPerms(),file,parentId,userId,groupIds),file,parentId,userId))     return;
 else     accessDenied(sMan.getVolumeId(),file,accessMode);
  }
 catch (  UserException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","@Override public void checkPermission(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,String accessMode) throws UserException, MRCException {
  assert(file != null);
  try {
    if (sMan.getACL(file.getId()).hasNext()) {
      ACLEntry entry=getRelevantACLEntry(sMan,file,parentId,userId,groupIds,accessMode);
      assert(entry != null);
      if (OTHER.equals(entry.getEntity()) || OWNER.equals(entry.getEntity())) {
        if (checkIfAllowed(sMan,accessMode,entry.getRights(),file,parentId,userId)) {
          return;
        }
 else         accessDenied(sMan.getVolumeId(),file,accessMode);
      }
      ACLEntry maskEntry=sMan.getACLEntry(file.getId(),MASK);
      if (checkIfAllowed(sMan,accessMode,entry.getRights(),file,parentId,userId) && (maskEntry == null || checkIfAllowed(sMan,accessMode,maskEntry.getRights(),file,parentId,userId)))       return;
 else       accessDenied(sMan.getVolumeId(),file,accessMode);
    }
 else {
      if (checkIfAllowed(sMan,accessMode,toRelativeACLRights(file.getPerms(),file,parentId,userId,groupIds),file,parentId,userId))       return;
 else       accessDenied(sMan.getVolumeId(),file,accessMode);
    }
  }
 catch (  UserException exc) {
    throw exc;
  }
catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.5780911062906724
113862,"@Override public void setACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    if (!sMan.getACL(file.getId()).hasNext()) {
      Map<String,Object> tmp=convertToACL(file.getPerms());
      entries.putAll(tmp);
    }
    for (    Entry<String,Object> entry : entries.entrySet())     sMan.setACLEntry(file.getId(),entry.getKey(),(Short)entry.getValue(),update);
    ACLEntry owner=sMan.getACLEntry(file.getId(),OWNER);
    ACLEntry group=sMan.getACLEntry(file.getId(),MASK);
    if (group == null)     group=sMan.getACLEntry(file.getId(),OWNER_GROUP);
    ACLEntry other=sMan.getACLEntry(file.getId(),OTHER);
    assert(group != null);
    assert(other != null);
    ACLEntry sticky=sMan.getACLEntry(file.getId(),STICKY_BIT);
    file.setPerms((short)((short)((owner.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | ((sticky != null && sticky.getRights() == 1) ? POSIX_STICKY : 0)| ((owner.getRights() & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner.getRights() & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner.getRights() & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group.getRights() & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group.getRights() & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group.getRights() & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other.getRights() & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other.getRights() & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other.getRights() & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0)));
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","@Override public void setACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    Map<String,Object> aclMap=null;
    Iterator<ACLEntry> acl=sMan.getACL(file.getId());
    if (!acl.hasNext())     aclMap=convertToACL(file.getPerms());
 else {
      aclMap=new HashMap<String,Object>();
      while (acl.hasNext()) {
        ACLEntry next=acl.next();
        aclMap.put(next.getEntity(),next.getRights());
      }
    }
    aclMap.putAll(entries);
    for (    Entry<String,Object> entry : aclMap.entrySet()) {
      Number rights=(Number)entry.getValue();
      sMan.setACLEntry(file.getId(),entry.getKey(),rights == null ? null : rights.shortValue(),update);
    }
    short owner=((Number)aclMap.get(OWNER)).shortValue();
    Short group=aclMap.get(MASK) != null ? ((Number)aclMap.get(MASK)).shortValue() : null;
    if (group == null)     group=((Number)aclMap.get(OWNER_GROUP)).shortValue();
    short other=((Number)aclMap.get(OTHER)).shortValue();
    file.setPerms((short)((short)((owner & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | (file.getPerms() & POSIX_STICKY)| ((owner & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0)));
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.5487404162102957
113863,"@Override public ErrorRecord parseRPCBody(MRCRequest rq,List<Object> arguments){
  Args args=new Args();
  try {
    args.filePath=(String)arguments.get(0);
    if (arguments.size() == 1) {
      args.mode=511;
      return null;
    }
    args.xAttrs=(Map<String,Object>)arguments.get(1);
    args.mode=((Long)arguments.get(2)).shortValue();
    if (arguments.size() == 3)     return null;
    throw new Exception();
  }
 catch (  Exception exc) {
    try {
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ JSONParser.writeJSON(arguments));
    }
 catch (    JSONException je) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str"");
    }
  }
 finally {
    rq.setRequestArgs(args);
  }
}","@Override public ErrorRecord parseRPCBody(MRCRequest rq,List<Object> arguments){
  Args args=new Args();
  try {
    args.filePath=(String)arguments.get(0);
    if (arguments.size() == 1) {
      args.mode=511;
      return null;
    }
    args.xAttrs=(Map<String,Object>)arguments.get(1);
    args.mode=((Long)arguments.get(2)).intValue();
    if (arguments.size() == 3)     return null;
    throw new Exception();
  }
 catch (  Exception exc) {
    try {
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ JSONParser.writeJSON(arguments));
    }
 catch (    JSONException je) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str"");
    }
  }
 finally {
    rq.setRequestArgs(args);
  }
}",0.9965986394557824
113864,"@Override public ErrorRecord parseRPCBody(MRCRequest rq,List<Object> arguments){
  Args args=new Args();
  try {
    args.filePath=(String)arguments.get(0);
    if (arguments.size() == 1) {
      args.mode=511;
      return null;
    }
    args.xAttrs=(Map<String,Object>)arguments.get(1);
    args.stripingPolicy=(Map<String,Object>)arguments.get(2);
    args.mode=((Long)arguments.get(3)).shortValue();
    if (arguments.size() == 4)     return null;
    args.open=(Boolean)arguments.get(4);
    if (arguments.size() == 5)     return null;
    args.assignedXLocList=(List<Object>)arguments.get(5);
    if (arguments.size() == 6)     return null;
    throw new Exception();
  }
 catch (  Exception exc) {
    try {
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ JSONParser.writeJSON(arguments));
    }
 catch (    JSONException je) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str"");
    }
  }
 finally {
    rq.setRequestArgs(args);
  }
}","@Override public ErrorRecord parseRPCBody(MRCRequest rq,List<Object> arguments){
  Args args=new Args();
  try {
    args.filePath=(String)arguments.get(0);
    if (arguments.size() == 1) {
      args.mode=511;
      return null;
    }
    args.xAttrs=(Map<String,Object>)arguments.get(1);
    args.stripingPolicy=(Map<String,Object>)arguments.get(2);
    args.mode=((Long)arguments.get(3)).intValue();
    if (arguments.size() == 4)     return null;
    args.open=(Boolean)arguments.get(4);
    if (arguments.size() == 5)     return null;
    args.assignedXLocList=(List<Object>)arguments.get(5);
    if (arguments.size() == 6)     return null;
    throw new Exception();
  }
 catch (  Exception exc) {
    try {
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ JSONParser.writeJSON(arguments));
    }
 catch (    JSONException je) {
      Logging.logMessage(Logging.LEVEL_ERROR,this,exc);
      return new ErrorRecord(ErrorClass.BAD_REQUEST,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str"");
    }
  }
 finally {
    rq.setRequestArgs(args);
  }
}",0.9973661106233538
113865,"/** 
 * Returns a list of mappings for all reachable network endpoints.
 * @param port the port to assign to the mappings
 * @param protocol the protocol for the endpoint
 * @return a list of mappings
 * @throws IOException
 */
public static List<Map<String,Object>> getReachableEndpoints(int port,String protocol) throws IOException {
  List<Map<String,Object>> endpoints=new LinkedList<Map<String,Object>>();
  Enumeration<NetworkInterface> ifcs=NetworkInterface.getNetworkInterfaces();
  while (ifcs.hasMoreElements()) {
    NetworkInterface ifc=ifcs.nextElement();
    List<InterfaceAddress> addrs=ifc.getInterfaceAddresses();
    for (    InterfaceAddress addr : addrs) {
      InetAddress inetAddr=addr.getAddress();
      if (inetAddr.isLoopbackAddress() || inetAddr.isLinkLocalAddress())       continue;
      if (!(inetAddr.isLinkLocalAddress() || inetAddr.isSiteLocalAddress())) {
        endpoints.add(RPCClient.generateMap(""String_Node_Str"",inetAddr.getHostAddress(),""String_Node_Str"",port,""String_Node_Str"",protocol,""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str""));
        break;
      }
    }
    if (!endpoints.isEmpty())     break;
  }
  if (endpoints.isEmpty()) {
    ifcs=NetworkInterface.getNetworkInterfaces();
    NetworkInterface ifc=ifcs.nextElement();
    List<InterfaceAddress> addrs=ifc.getInterfaceAddresses();
    ifcs=NetworkInterface.getNetworkInterfaces();
    while (ifcs.hasMoreElements()) {
      for (      InterfaceAddress addr : addrs) {
        InetAddress inetAddr=addr.getAddress();
        if (inetAddr.isSiteLocalAddress()) {
          endpoints.add(RPCClient.generateMap(""String_Node_Str"",inetAddr.getHostAddress(),""String_Node_Str"",port,""String_Node_Str"",protocol,""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str""));
          break;
        }
      }
      if (!endpoints.isEmpty())       break;
    }
  }
  return endpoints;
}","/** 
 * Returns a list of mappings for all reachable network endpoints.
 * @param port the port to assign to the mappings
 * @param protocol the protocol for the endpoint
 * @return a list of mappings
 * @throws IOException
 */
public static List<Map<String,Object>> getReachableEndpoints(int port,String protocol) throws IOException {
  List<Map<String,Object>> endpoints=new LinkedList<Map<String,Object>>();
  Enumeration<NetworkInterface> ifcs=NetworkInterface.getNetworkInterfaces();
  while (ifcs.hasMoreElements()) {
    NetworkInterface ifc=ifcs.nextElement();
    List<InterfaceAddress> addrs=ifc.getInterfaceAddresses();
    for (    InterfaceAddress addr : addrs) {
      InetAddress inetAddr=addr.getAddress();
      if (inetAddr.isLoopbackAddress() || inetAddr.isLinkLocalAddress())       continue;
      if (!(inetAddr.isLinkLocalAddress() || inetAddr.isSiteLocalAddress())) {
        endpoints.add(RPCClient.generateMap(""String_Node_Str"",inetAddr.getHostAddress(),""String_Node_Str"",port,""String_Node_Str"",protocol,""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str""));
        break;
      }
    }
    if (!endpoints.isEmpty())     break;
  }
  if (endpoints.isEmpty()) {
    ifcs=NetworkInterface.getNetworkInterfaces();
    while (ifcs.hasMoreElements()) {
      NetworkInterface ifc=ifcs.nextElement();
      List<InterfaceAddress> addrs=ifc.getInterfaceAddresses();
      for (      InterfaceAddress addr : addrs) {
        InetAddress inetAddr=addr.getAddress();
        if (inetAddr.isSiteLocalAddress()) {
          endpoints.add(RPCClient.generateMap(""String_Node_Str"",inetAddr.getHostAddress(),""String_Node_Str"",port,""String_Node_Str"",protocol,""String_Node_Str"",3600,""String_Node_Str"",""String_Node_Str""));
          break;
        }
      }
      if (!endpoints.isEmpty())       break;
    }
  }
  return endpoints;
}",0.965793693212186
113866,"protected ErrorRecord parseMethod(OSDRequest rq){
  final PinkyRequest pr=rq.getPinkyRequest();
  if (pr.requestMethod.equals(HTTPUtils.GET_TOKEN)) {
    if (pr.requestURI == null)     return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    if (pr.requestURI.equals(""String_Node_Str"")) {
      rq.setType(OSDRequest.Type.STATUS_PAGE);
      rq.setOperation(master.getOperation(RequestDispatcher.Operations.STATUS_PAGE));
    }
 else {
      rq.setType(OSDRequest.Type.READ);
      final String fileId=parseFileIdFromURI(pr);
      if (fileId == null) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
      }
      rq.getDetails().setFileId(fileId);
      rq.setOperation(master.getOperation(RequestDispatcher.Operations.READ));
    }
  }
 else   if (pr.requestMethod.equals(HTTPUtils.PUT_TOKEN)) {
    rq.setType(OSDRequest.Type.WRITE);
    final String fileId=parseFileIdFromURI(pr);
    if (fileId == null) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    }
    if (rq.getData() == null) {
      return new ErrorRecord(ErrorClass.BAD_REQUEST,ErrorCodes.INVALID_PARAMS,""String_Node_Str"");
    }
    rq.getDetails().setFileId(fileId);
    rq.setOperation(master.getOperation(RequestDispatcher.Operations.WRITE));
  }
 else   if (pr.requestMethod.equals(HTTPUtils.DELETE_TOKEN)) {
    rq.setType(OSDRequest.Type.DELETE);
    final String fileId=parseFileIdFromURI(pr);
    if (fileId == null) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    }
    rq.getDetails().setFileId(fileId);
    rq.setOperation(master.getOperation(RequestDispatcher.Operations.DELETE));
  }
 else   if (pr.requestMethod.equals(HTTPUtils.POST_TOKEN)) {
    rq.setType(OSDRequest.Type.RPC);
    assert(pr.requestURI != null);
    if (pr.requestURI.length() == 0) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.METHOD_NOT_IMPLEMENTED,""String_Node_Str"");
    }
    ErrorRecord result=parseRPC(rq);
    if (result != null)     return result;
  }
 else {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.METHOD_NOT_IMPLEMENTED,pr.requestMethod + ""String_Node_Str"");
  }
  final ErrorRecord hdrResult=parseHeaders(rq);
  if (hdrResult != null) {
    return hdrResult;
  }
  return null;
}","protected ErrorRecord parseMethod(OSDRequest rq){
  final PinkyRequest pr=rq.getPinkyRequest();
  if (pr.requestMethod.equals(HTTPUtils.GET_TOKEN)) {
    if (pr.requestURI == null)     return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    if (pr.requestURI.equals(""String_Node_Str"")) {
      rq.setType(OSDRequest.Type.STATUS_PAGE);
      rq.setOperation(master.getOperation(RequestDispatcher.Operations.STATUS_PAGE));
    }
 else {
      rq.setType(OSDRequest.Type.READ);
      final String fileId=parseFileIdFromURI(pr);
      if (fileId == null) {
        return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
      }
      rq.getDetails().setFileId(fileId);
      rq.setOperation(master.getOperation(RequestDispatcher.Operations.READ));
    }
  }
 else   if (pr.requestMethod.equals(HTTPUtils.PUT_TOKEN)) {
    rq.setType(OSDRequest.Type.WRITE);
    final String fileId=parseFileIdFromURI(pr);
    if (fileId == null) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    }
    if (pr.requestBody == null) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_PARAMS,""String_Node_Str"");
    }
    rq.getDetails().setFileId(fileId);
    rq.setOperation(master.getOperation(RequestDispatcher.Operations.WRITE));
  }
 else   if (pr.requestMethod.equals(HTTPUtils.DELETE_TOKEN)) {
    rq.setType(OSDRequest.Type.DELETE);
    final String fileId=parseFileIdFromURI(pr);
    if (fileId == null) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.INVALID_FILEID,""String_Node_Str"");
    }
    rq.getDetails().setFileId(fileId);
    rq.setOperation(master.getOperation(RequestDispatcher.Operations.DELETE));
  }
 else   if (pr.requestMethod.equals(HTTPUtils.POST_TOKEN)) {
    rq.setType(OSDRequest.Type.RPC);
    assert(pr.requestURI != null);
    if (pr.requestURI.length() == 0) {
      return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.METHOD_NOT_IMPLEMENTED,""String_Node_Str"");
    }
    ErrorRecord result=parseRPC(rq);
    if (result != null)     return result;
  }
 else {
    return new ErrorRecord(ErrorClass.USER_EXCEPTION,ErrorCodes.METHOD_NOT_IMPLEMENTED,pr.requestMethod + ""String_Node_Str"");
  }
  final ErrorRecord hdrResult=parseHeaders(rq);
  if (hdrResult != null) {
    return hdrResult;
  }
  return null;
}",0.989827693585219
113867,"public void setPosixAccessRights(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,short posixAccessRights,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    file.setPerms(posixAccessRights);
    sMan.setMetadata(parentId,file.getFileName(),file,FileMetadata.RC_METADATA,update);
    if (!sMan.getACL(file.getId()).hasNext())     return;
    short owr=(posixAccessRights & POSIX_OWNER_EXEC) > 0 ? EXEC_MASK : 0;
    owr|=(posixAccessRights & POSIX_OWNER_WRITE) > 0 ? WRITE_MASK : 0;
    owr|=(posixAccessRights & POSIX_OWNER_READ) > 0 ? READ_MASK : 0;
    owr|=(posixAccessRights & POSIX_SUID) > 0 ? PERM_SUID_SGID : 0;
    short grr=(posixAccessRights & POSIX_GROUP_EXEC) > 0 ? EXEC_MASK : 0;
    grr|=(posixAccessRights & POSIX_GROUP_WRITE) > 0 ? WRITE_MASK : 0;
    grr|=(posixAccessRights & POSIX_GROUP_READ) > 0 ? READ_MASK : 0;
    grr|=(posixAccessRights & POSIX_SGID) > 0 ? PERM_SUID_SGID : 0;
    short otr=(posixAccessRights & POSIX_OTHER_EXEC) > 0 ? EXEC_MASK : 0;
    otr|=(posixAccessRights & POSIX_OTHER_WRITE) > 0 ? WRITE_MASK : 0;
    otr|=(posixAccessRights & POSIX_OTHER_READ) > 0 ? READ_MASK : 0;
    sMan.setACLEntry(file.getId(),OWNER,owr,update);
    sMan.setACLEntry(file.getId(),OWNER_GROUP,grr,update);
    sMan.setACLEntry(file.getId(),MASK,grr,update);
    sMan.setACLEntry(file.getId(),OTHER,otr,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","public void setPosixAccessRights(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,short posixAccessRights,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    file.setPerms(posixAccessRights);
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
    if (!sMan.getACL(file.getId()).hasNext())     return;
    short owr=(posixAccessRights & POSIX_OWNER_EXEC) > 0 ? EXEC_MASK : 0;
    owr|=(posixAccessRights & POSIX_OWNER_WRITE) > 0 ? WRITE_MASK : 0;
    owr|=(posixAccessRights & POSIX_OWNER_READ) > 0 ? READ_MASK : 0;
    owr|=(posixAccessRights & POSIX_SUID) > 0 ? PERM_SUID_SGID : 0;
    short grr=(posixAccessRights & POSIX_GROUP_EXEC) > 0 ? EXEC_MASK : 0;
    grr|=(posixAccessRights & POSIX_GROUP_WRITE) > 0 ? WRITE_MASK : 0;
    grr|=(posixAccessRights & POSIX_GROUP_READ) > 0 ? READ_MASK : 0;
    grr|=(posixAccessRights & POSIX_SGID) > 0 ? PERM_SUID_SGID : 0;
    short otr=(posixAccessRights & POSIX_OTHER_EXEC) > 0 ? EXEC_MASK : 0;
    otr|=(posixAccessRights & POSIX_OTHER_WRITE) > 0 ? WRITE_MASK : 0;
    otr|=(posixAccessRights & POSIX_OTHER_READ) > 0 ? READ_MASK : 0;
    sMan.setACLEntry(file.getId(),OWNER,owr,update);
    sMan.setACLEntry(file.getId(),OWNER_GROUP,grr,update);
    sMan.setACLEntry(file.getId(),MASK,grr,update);
    sMan.setACLEntry(file.getId(),OTHER,otr,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.990324809951624
113868,"private static boolean checkIfAllowed(StorageManager sMan,String accessMode,short aclRights,FileMetadata file,long parentId,String userId) throws DatabaseException {
  if (accessMode.length() == 1) {
switch (accessMode.charAt(0)) {
case 'r':
      return (aclRights & PERM_READ) != 0;
case 'w':
    return (aclRights & PERM_WRITE) != 0;
case 'x':
  return (aclRights & PERM_EXECUTE) != 0;
case 'a':
return (aclRights & PERM_APPEND) != 0;
case 'c':
return (aclRights & PERM_CREATE) != 0;
case 't':
return (aclRights & PERM_TRUNCATE) != 0;
case 'd':
return (aclRights & PERM_DELETE) != 0;
case 'm':
assert(parentId != 0);
Object[] parentsParentIdAndName=sMan.getParentIdAndFileName(parentId);
FileMetadata parent=sMan.getMetadata((Long)parentsParentIdAndName[0],(String)parentsParentIdAndName[1]);
if ((parent.getPerms() & POSIX_STICKY) != 0) return file.getOwnerId().equals(userId);
 else return true;
}
}
 else if (accessMode.length() == 2) {
if (accessMode.equals(""String_Node_Str"") && (aclRights & PERM_GFS_APPEND) != 0) return true;
 else if (accessMode.equals(""String_Node_Str"") && (aclRights & PERM_STRICT_READ) != 0) return true;
}
return false;
}","private static boolean checkIfAllowed(StorageManager sMan,String accessMode,short aclRights,FileMetadata file,long parentId,String userId) throws DatabaseException {
  if (accessMode.length() == 1) {
switch (accessMode.charAt(0)) {
case 'r':
      return (aclRights & PERM_READ) != 0;
case 'w':
    return (aclRights & PERM_WRITE) != 0;
case 'x':
  return (aclRights & PERM_EXECUTE) != 0;
case 'a':
return (aclRights & PERM_APPEND) != 0;
case 'c':
return (aclRights & PERM_CREATE) != 0;
case 't':
return (aclRights & PERM_TRUNCATE) != 0;
case 'd':
return (aclRights & PERM_DELETE) != 0;
case 'm':
assert(parentId != 0);
FileMetadata parent=sMan.getMetadata(parentId);
if ((parent.getPerms() & POSIX_STICKY) != 0) return file.getOwnerId().equals(userId);
 else return true;
}
}
 else if (accessMode.length() == 2) {
if (accessMode.equals(""String_Node_Str"") && (aclRights & PERM_GFS_APPEND) != 0) return true;
 else if (accessMode.equals(""String_Node_Str"") && (aclRights & PERM_STRICT_READ) != 0) return true;
}
return false;
}",0.9127640036730946
113869,"public void setACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    if (!sMan.getACL(file.getId()).hasNext()) {
      Map<String,Object> tmp=convertToACL(file.getPerms());
      entries.putAll(tmp);
    }
    for (    Entry<String,Object> entry : entries.entrySet())     sMan.setACLEntry(file.getId(),entry.getKey(),(Short)entry.getValue(),update);
    ACLEntry owner=sMan.getACLEntry(file.getId(),OWNER);
    ACLEntry group=sMan.getACLEntry(file.getId(),MASK);
    if (group == null)     group=sMan.getACLEntry(file.getId(),OWNER_GROUP);
    ACLEntry other=sMan.getACLEntry(file.getId(),OTHER);
    assert(group != null);
    assert(other != null);
    ACLEntry sticky=sMan.getACLEntry(file.getId(),STICKY_BIT);
    file.setPerms((short)((short)((owner.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | ((sticky != null && sticky.getRights() == 1) ? POSIX_STICKY : 0)| ((owner.getRights() & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner.getRights() & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner.getRights() & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group.getRights() & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group.getRights() & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group.getRights() & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other.getRights() & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other.getRights() & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other.getRights() & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0)));
    sMan.setMetadata(parentId,file.getFileName(),file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}","public void setACLEntries(StorageManager sMan,FileMetadata file,long parentId,String userId,List<String> groupIds,Map<String,Object> entries,AtomicDBUpdate update) throws MRCException, UserException {
  try {
    if (!sMan.getACL(file.getId()).hasNext()) {
      Map<String,Object> tmp=convertToACL(file.getPerms());
      entries.putAll(tmp);
    }
    for (    Entry<String,Object> entry : entries.entrySet())     sMan.setACLEntry(file.getId(),entry.getKey(),(Short)entry.getValue(),update);
    ACLEntry owner=sMan.getACLEntry(file.getId(),OWNER);
    ACLEntry group=sMan.getACLEntry(file.getId(),MASK);
    if (group == null)     group=sMan.getACLEntry(file.getId(),OWNER_GROUP);
    ACLEntry other=sMan.getACLEntry(file.getId(),OTHER);
    assert(group != null);
    assert(other != null);
    ACLEntry sticky=sMan.getACLEntry(file.getId(),STICKY_BIT);
    file.setPerms((short)((short)((owner.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SUID : 0) | ((group.getRights() & PERM_SUID_SGID) > 0 ? POSIX_SGID : 0) | ((sticky != null && sticky.getRights() == 1) ? POSIX_STICKY : 0)| ((owner.getRights() & PERM_READ) > 0 ? POSIX_OWNER_READ : 0)| ((owner.getRights() & PERM_WRITE) > 0 ? POSIX_OWNER_WRITE : 0)| ((owner.getRights() & PERM_EXECUTE) > 0 ? POSIX_OWNER_EXEC : 0)| ((group.getRights() & PERM_READ) > 0 ? POSIX_GROUP_READ : 0)| ((group.getRights() & PERM_WRITE) > 0 ? POSIX_GROUP_WRITE : 0)| ((group.getRights() & PERM_EXECUTE) > 0 ? POSIX_GROUP_EXEC : 0)| ((other.getRights() & PERM_READ) > 0 ? POSIX_OTHER_READ : 0)| ((other.getRights() & PERM_WRITE) > 0 ? POSIX_OTHER_WRITE : 0)| ((other.getRights() & PERM_EXECUTE) > 0 ? POSIX_OTHER_EXEC : 0)));
    sMan.setMetadata(file,FileMetadata.RC_METADATA,update);
  }
 catch (  Exception exc) {
    throw new MRCException(exc);
  }
}",0.9922178988326849
113870,"public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,long linkParentId,byte[][] keyBufs,byte[][] valBufs) throws BabuDBException {
  String linkName=new String(valBufs[FileMetadata.RC_METADATA],9,valBufs[FileMetadata.RC_METADATA].length - 9);
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(valBufs[FileMetadata.RC_METADATA],1,fileIdBytes,0,fileIdBytes.length);
  Iterator<Entry<byte[],byte[]>> it=database.syncPrefixLookup(dbName,BabuDBStorageManager.LINK_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),true);
    valBufs[type]=curr.getValue();
  }
  BufferBackedRCMetadata rcMetadata=new BufferBackedRCMetadata(keyBufs[BufferBackedFileMetadata.RC_METADATA],valBufs[BufferBackedFileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(linkParentId,linkName,rcMetadata.getOwnerId(),rcMetadata.getOwningGroupId(),rcMetadata.getId(),rcMetadata.getPerms(),rcMetadata.getLinkCount(),rcMetadata.getEpoch(),rcMetadata.getIssuedEpoch(),rcMetadata.isReadOnly(),rcMetadata.getCollisionCount());
  keyBufs[BufferBackedFileMetadata.FC_METADATA]=new byte[tmp.getKey().length];
  System.arraycopy(tmp.getKey(),0,keyBufs[BufferBackedFileMetadata.FC_METADATA],0,tmp.getKey().length);
  keyBufs[BufferBackedFileMetadata.FC_METADATA][12]=0;
  keyBufs[BufferBackedFileMetadata.XLOC_METADATA]=new byte[tmp.getKey().length];
  System.arraycopy(tmp.getKey(),0,keyBufs[BufferBackedFileMetadata.XLOC_METADATA],0,tmp.getKey().length);
  keyBufs[BufferBackedFileMetadata.XLOC_METADATA][12]=2;
  keyBufs[BufferBackedFileMetadata.RC_METADATA]=tmp.getKey();
  valBufs[BufferBackedFileMetadata.RC_METADATA]=tmp.getValue();
  return new BufferBackedFileMetadata(keyBufs,valBufs,true);
}","public static BufferBackedFileMetadata resolveLink(BabuDB database,String dbName,byte[] target) throws BabuDBException {
  byte[] fileIdBytes=new byte[8];
  System.arraycopy(target,1,fileIdBytes,0,fileIdBytes.length);
  String fileName=new String(target,9,target.length - 9);
  byte[][] valBufs=new byte[BufferBackedFileMetadata.NUM_BUFFERS][];
  Iterator<Entry<byte[],byte[]>> it=database.syncPrefixLookup(dbName,BabuDBStorageManager.FILE_ID_INDEX,fileIdBytes);
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    int type=getType(curr.getKey(),BabuDBStorageManager.FILE_ID_INDEX);
    if (type == 3) {
      long fileId=ByteBuffer.wrap(fileIdBytes).getLong();
      Logging.logMessage(Logging.LEVEL_WARN,null,""String_Node_Str"" + fileId);
      continue;
    }
    valBufs[type]=curr.getValue();
  }
  if (valBufs[FileMetadata.RC_METADATA] == null)   return null;
  BufferBackedRCMetadata tmp=new BufferBackedRCMetadata(null,valBufs[FileMetadata.RC_METADATA]);
  BufferBackedRCMetadata tmp2=tmp.isDirectory() ? new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getLinkCount(),tmp.getCollisionCount()) : new BufferBackedRCMetadata(0,fileName,tmp.getOwnerId(),tmp.getOwningGroupId(),tmp.getId(),tmp.getPerms(),tmp.getLinkCount(),tmp.getEpoch(),tmp.getIssuedEpoch(),tmp.isReadOnly(),tmp.getCollisionCount());
  valBufs[FileMetadata.RC_METADATA]=tmp2.getValue();
  return new BufferBackedFileMetadata(null,valBufs,BabuDBStorageManager.FILE_ID_INDEX);
}",0.132086851628468
113871,"public static long getId(BabuDB database,String dbName,long parentId,String fileName) throws BabuDBException {
  byte[] prefix=createFilePrefixKey(parentId,fileName,BufferBackedFileMetadata.RC_METADATA);
  Iterator<Entry<byte[],byte[]>> it=database.syncPrefixLookup(dbName,BabuDBStorageManager.FILE_INDEX,prefix);
  long id=-1;
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    String entryFileName=null;
    long entryId=-1;
    if (curr.getValue()[0] == 2) {
      entryId=ByteBuffer.wrap(curr.getValue()).getLong();
      entryFileName=new String(curr.getValue(),8,curr.getValue().length - 8);
    }
 else {
      BufferBackedRCMetadata md=new BufferBackedRCMetadata(curr.getKey(),curr.getValue());
      entryFileName=md.getFileName();
      entryId=md.getId();
    }
    if (entryFileName.equals(fileName)) {
      id=entryId;
      break;
    }
  }
  return id;
}","public static long getId(BabuDB database,String dbName,long parentId,String fileName) throws BabuDBException {
  byte[] prefix=createFilePrefixKey(parentId,fileName,BufferBackedFileMetadata.RC_METADATA);
  Iterator<Entry<byte[],byte[]>> it=database.syncPrefixLookup(dbName,BabuDBStorageManager.FILE_INDEX,prefix);
  long id=-1;
  while (it.hasNext()) {
    Entry<byte[],byte[]> curr=it.next();
    String entryFileName=null;
    long entryId=-1;
    if (curr.getValue()[0] == 2) {
      entryId=ByteBuffer.wrap(curr.getValue()).getLong();
      entryFileName=new String(curr.getValue(),9,curr.getValue().length - 9);
    }
 else {
      BufferBackedRCMetadata md=new BufferBackedRCMetadata(curr.getKey(),curr.getValue());
      entryFileName=md.getFileName();
      entryId=md.getId();
    }
    if (entryFileName.equals(fileName)) {
      id=entryId;
      break;
    }
  }
  return id;
}",0.997750281214848
113872,"public ChildrenIterator(BabuDB database,String dbName,long parentId,Iterator<Entry<byte[],byte[]>> it){
  this.database=database;
  this.dbName=dbName;
  this.parentId=parentId;
  this.it=it;
  this.keyMap=new HashMap<Short,byte[][]>();
  this.valMap=new HashMap<Short,byte[][]>();
}","public ChildrenIterator(BabuDB database,String dbName,Iterator<Entry<byte[],byte[]>> it){
  this.database=database;
  this.dbName=dbName;
  this.it=it;
  this.keyMap=new HashMap<Short,byte[][]>();
  this.valMap=new HashMap<Short,byte[][]>();
}",0.9239543726235742
113873,"public static byte getType(byte[] key,boolean link){
  return key[link ? 8 : 12];
}","public static byte getType(byte[] key,int index){
  return key[index == BabuDBStorageManager.FILE_ID_INDEX ? 8 : 12];
}",0.7029702970297029
113874,"public SymbolScope buildSymbolScope(IResource resource){
  IFile file=(IFile)resource;
  String body=""String_Node_Str"";
  try {
    body=CharStreams.toString(new InputStreamReader(file.getContents()));
  }
 catch (  CoreException|IOException e) {
  }
  SourceFile virtualSourceFile=SourceFile.builder().setBody(body).setNamespace(Namespaces.EMPTY).build();
  ApexCompiler compiler=ApexCompiler.builder().setInput(new CompilationInput(Collections.singleton(virtualSourceFile),EmptySymbolProvider.get(),null,null,null)).build();
  SymbolScope scope=new SymbolScope(new StandardSymbolResolver(compiler),new Errors());
  return scope;
}","public SymbolScope buildSymbolScope(IResource resource){
  IFile file=(IFile)resource;
  String body=""String_Node_Str"";
  try {
    body=CharStreams.toString(new InputStreamReader(file.getContents()));
  }
 catch (  CoreException|IOException e) {
  }
  SourceFile virtualSourceFile=SourceFile.builder().setBody(body).setNamespace(Namespaces.EMPTY).build();
  return buildSymbolScope(virtualSourceFile);
}",0.7355212355212355
113875,"public AllUnitTests(){
  addTest(new com.salesforce.ide.ui.actions.AllUnitTests());
  addTest(new com.salesforce.ide.ui.packagemanifest.AllUnitTests());
  addTest(new com.salesforce.ide.ui.views.log.AllUnitTests());
  addTest(new com.salesforce.ide.ui.views.runtest.AllUnitTests());
}","public AllUnitTests(){
  addTest(new com.salesforce.ide.ui.actions.AllUnitTests());
  addTest(new com.salesforce.ide.ui.packagemanifest.AllUnitTests());
  addTest(new com.salesforce.ide.ui.views.log.AllUnitTests());
  addTest(new com.salesforce.ide.ui.views.runtest.test.AllUnitTests());
}",0.9912739965095986
113876,"public void setActiveProject(IProject project){
  if (project == null) {
    project=getFirstProject();
  }
  setSelectedProjectCombo(project);
  executeAnonymousController.setProject(project);
  if (loggingComposite != null) {
    loggingComposite.setProject(project);
  }
  if (project != null && project.getName().equals(projectCombo.getText())) {
    enableComposite(true);
  }
 else {
    enableComposite(false);
  }
}","/** 
 * Update the combo box and ExecuteAnonymousController with the selected project
 * @param project
 */
public void setActiveProject(IProject project){
  if (project == null) {
    project=getFirstProject();
  }
  setSelectedProjectCombo(project);
  executeAnonymousController.setProject(project);
  if (loggingComposite != null) {
    loggingComposite.setProject(project);
  }
  if (project != null && project.getName().equals(projectCombo.getText())) {
    enableComposite(true);
  }
 else {
    enableComposite(false);
  }
}",0.8867924528301887
113877,"private void updateProjectComboProjectedAdded(){
  UIJob job=new UIJob(""String_Node_Str""){
    @Override public IStatus runInUIThread(    IProgressMonitor monitor){
      List<IProject> projects=executeAnonymousController.getForceProjects();
      loadProjects(projects);
      return new Status(Status.OK,ForceIdeCorePlugin.PLUGIN_ID,""String_Node_Str"");
    }
  }
;
  job.setSystem(true);
  job.schedule();
}","/** 
 * Refresh the list of active projects, update the combo box, and stay on the already selected project
 */
private void updateProjectComboProjectedAdded(){
  UIJob job=new UIJob(""String_Node_Str""){
    @Override public IStatus runInUIThread(    IProgressMonitor monitor){
      List<IProject> projects=executeAnonymousController.getForceProjects();
      loadProjects(projects);
      return new Status(Status.OK,ForceIdeCorePlugin.PLUGIN_ID,""String_Node_Str"");
    }
  }
;
  job.setSystem(true);
  job.schedule();
}",0.8795698924731182
113878,"@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(org.eclipse.swt.events.SelectionEvent e){
  Combo tmpCboProject=(Combo)e.widget;
  if (tmpCboProject.getData() != null && tmpCboProject.getData() instanceof List) {
    List<IProject> projects=(List<IProject>)tmpCboProject.getData();
    if (Utils.isNotEmpty(projects)) {
      int selectionIndex=((Combo)e.widget).getSelectionIndex();
      IProject selectedProject=projects.get(selectionIndex);
      if (selectedProject != null) {
        setActiveProject(selectedProject);
      }
    }
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(org.eclipse.swt.events.SelectionEvent e){
  Combo tmpCboProject=(Combo)e.widget;
  if (tmpCboProject.getData() != null && tmpCboProject.getData() instanceof List) {
    List<IProject> projects=(List<IProject>)tmpCboProject.getData();
    if (Utils.isNotEmpty(projects)) {
      int selectionIndex=((Combo)e.widget).getSelectionIndex();
      selectedProject=projects.get(selectionIndex);
      if (selectedProject != null) {
        setActiveProject(selectedProject);
      }
    }
  }
}",0.9920424403183024
113879,"protected void createProjectComposite(Composite cmpSource){
  projectComposite=new Composite(cmpSource,SWT.NONE);
  projectComposite.setLayoutData(new GridData(SWT.BEGINNING));
  GridLayout gridLayout=new GridLayout();
  gridLayout.numColumns=3;
  projectComposite.setLayout(gridLayout);
  CLabel lblProject=new CLabel(projectComposite,SWT.NONE);
  lblProject.setLayoutData(new GridData(SWT.BEGINNING));
  lblProject.setText(""String_Node_Str"");
  projectCombo=new Combo(projectComposite,SWT.DROP_DOWN | SWT.READ_ONLY);
  projectCombo.addSelectionListener(new org.eclipse.swt.events.SelectionListener(){
    @Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(    org.eclipse.swt.events.SelectionEvent e){
      Combo tmpCboProject=(Combo)e.widget;
      if (tmpCboProject.getData() != null && tmpCboProject.getData() instanceof List) {
        List<IProject> projects=(List<IProject>)tmpCboProject.getData();
        if (Utils.isNotEmpty(projects)) {
          int selectionIndex=((Combo)e.widget).getSelectionIndex();
          IProject selectedProject=projects.get(selectionIndex);
          if (selectedProject != null) {
            setActiveProject(selectedProject);
          }
        }
      }
    }
    @Override public void widgetDefaultSelected(    org.eclipse.swt.events.SelectionEvent e){
      widgetSelected(e);
    }
  }
);
}","protected void createProjectComposite(Composite cmpSource){
  projectComposite=new Composite(cmpSource,SWT.NONE);
  projectComposite.setLayoutData(new GridData(SWT.BEGINNING));
  GridLayout gridLayout=new GridLayout();
  gridLayout.numColumns=3;
  projectComposite.setLayout(gridLayout);
  CLabel lblProject=new CLabel(projectComposite,SWT.NONE);
  lblProject.setLayoutData(new GridData(SWT.BEGINNING));
  lblProject.setText(""String_Node_Str"");
  projectCombo=new Combo(projectComposite,SWT.DROP_DOWN | SWT.READ_ONLY);
  projectCombo.addSelectionListener(new org.eclipse.swt.events.SelectionListener(){
    @Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(    org.eclipse.swt.events.SelectionEvent e){
      Combo tmpCboProject=(Combo)e.widget;
      if (tmpCboProject.getData() != null && tmpCboProject.getData() instanceof List) {
        List<IProject> projects=(List<IProject>)tmpCboProject.getData();
        if (Utils.isNotEmpty(projects)) {
          int selectionIndex=((Combo)e.widget).getSelectionIndex();
          selectedProject=projects.get(selectionIndex);
          if (selectedProject != null) {
            setActiveProject(selectedProject);
          }
        }
      }
    }
    @Override public void widgetDefaultSelected(    org.eclipse.swt.events.SelectionEvent e){
      widgetSelected(e);
    }
  }
);
}",0.9966875230033124
113880,"private void updateProjectComboProjectRemoved(final IProject project){
  UIJob job=new UIJob(""String_Node_Str""){
    @Override public IStatus runInUIThread(    IProgressMonitor monitor){
      if (projectCombo.getItemCount() > 0 && ArrayUtils.contains(projectCombo.getItems(),project.getName())) {
        projectCombo.remove(project.getName());
        if (projectCombo.getItemCount() > 0) {
          projectCombo.select(DEFAULT_PROJ_SELECTION);
        }
 else {
          projectCombo.setData(null);
          projectCombo.setEnabled(false);
          enableComposite(false);
        }
      }
      return new Status(Status.OK,ForceIdeCorePlugin.PLUGIN_ID,""String_Node_Str"");
    }
  }
;
  job.setSystem(true);
  job.schedule();
}","/** 
 * Remove the project from the combo box and  select first item in project list.
 */
private void updateProjectComboProjectRemoved(final IProject project){
  UIJob job=new UIJob(""String_Node_Str""){
    @Override public IStatus runInUIThread(    IProgressMonitor monitor){
      if (projectCombo.getItemCount() > 0 && ArrayUtils.contains(projectCombo.getItems(),project.getName())) {
        projectCombo.remove(project.getName());
        if (projectCombo.getItemCount() > 0) {
          projectCombo.select(DEFAULT_PROJ_SELECTION);
        }
 else {
          projectCombo.setData(null);
          projectCombo.setEnabled(false);
          enableComposite(false);
        }
      }
      return new Status(Status.OK,ForceIdeCorePlugin.PLUGIN_ID,""String_Node_Str"");
    }
  }
;
  job.setSystem(true);
  job.schedule();
}",0.9423076923076924
113881,"private void loadProjects(List<IProject> projects){
  if (projectCombo.getItemCount() > 0)   projectCombo.removeAll();
  projectCombo.setData(projects);
  Collections.sort(projects,new Comparator<IProject>(){
    @Override public int compare(    IProject o1,    IProject o2){
      return String.CASE_INSENSITIVE_ORDER.compare(o1.getName(),o2.getName());
    }
  }
);
  for (  IProject project : projects) {
    projectCombo.add(project.getName());
  }
  projectCombo.select(DEFAULT_PROJ_SELECTION);
  projectCombo.setEnabled(true);
  projectAndLoggingContainerComposite.pack();
  projectAndLoggingContainerComposite.layout(true,true);
  enableComposite(true);
}","private void loadProjects(List<IProject> projects){
  if (projectCombo.getItemCount() > 0)   projectCombo.removeAll();
  projectCombo.setData(projects);
  Collections.sort(projects,new Comparator<IProject>(){
    @Override public int compare(    IProject o1,    IProject o2){
      return String.CASE_INSENSITIVE_ORDER.compare(o1.getName(),o2.getName());
    }
  }
);
  for (  IProject project : projects) {
    projectCombo.add(project.getName());
  }
  setActiveProject(selectedProject);
  projectCombo.setEnabled(true);
  projectAndLoggingContainerComposite.pack();
  projectAndLoggingContainerComposite.layout(true,true);
}",0.7509697439875873
113882,"@VisibleForTesting protected String getProjectName(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_PROJECT_NAME,""String_Node_Str"");
}","@VisibleForTesting public String getProjectName(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_PROJECT_NAME,""String_Node_Str"");
}",0.967741935483871
113883,"@VisibleForTesting protected int getTotalTests(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TESTS_TOTAL,0);
}","@VisibleForTesting public int getTotalTests(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TESTS_TOTAL,0);
}",0.969529085872576
113884,"@VisibleForTesting protected Map<IResource,List<String>> findTestClasses(IProject project){
  return ApexTestsUtils.INSTANCE.findTestClassesInProject(project);
}","@VisibleForTesting public Map<IResource,List<String>> findTestClasses(IProject project){
  return ApexTestsUtils.INSTANCE.findTestClassesInProject(project);
}",0.9655172413793104
113885,"@VisibleForTesting protected IProject materializeForceProject(ILaunchConfiguration configuration) throws CoreException {
  String forceProjectName=getProjectName(configuration);
  IProject project=getProjectFromName(forceProjectName);
  if (Utils.isEmpty(project)) {
    throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchInvalidForceProject);
  }
  return project;
}","@VisibleForTesting public IProject materializeForceProject(ILaunchConfiguration configuration) throws CoreException {
  String forceProjectName=getProjectName(configuration);
  IProject project=getProjectFromName(forceProjectName);
  if (Utils.isEmpty(project)) {
    throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchInvalidForceProject);
  }
  return project;
}",0.9831387808041504
113886,"@VisibleForTesting protected void throwErrorMsg(String msg) throws CoreException {
  if (Utils.isNotEmpty(msg)) {
    throw new CoreException(new Status(IStatus.ERROR,ForceIdeCorePlugin.PLUGIN_ID,0,msg,null));
  }
}","@VisibleForTesting public void throwErrorMsg(String msg) throws CoreException {
  if (Utils.isNotEmpty(msg)) {
    throw new CoreException(new Status(IStatus.ERROR,ForceIdeCorePlugin.PLUGIN_ID,0,msg,null));
  }
}",0.9695550351288056
113887,"@VisibleForTesting protected String getTestsArray(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TESTS_ARRAY,""String_Node_Str"");
}","@VisibleForTesting public String getTestsArray(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TESTS_ARRAY,""String_Node_Str"");
}",0.9724310776942356
113888,"/** 
 * Inform user there is an existing Trace Flag.
 * @return False if abort, true if continue
 */
@VisibleForTesting protected boolean confirmExistingTraceFlag(){
  Display display=getDisplay();
  final AtomicInteger choice=new AtomicInteger(0);
  display.syncExec(new Runnable(){
    @Override public void run(){
      choice.set(DialogUtils.getInstance().abortContinueMessage(Messages.RunTestsLaunchConfigurationDelegate_ConfirmDialogTitle,Messages.RunTestsLaunchConfigurationDelegate_ExistingTraceFlag,MessageDialog.INFORMATION));
    }
  }
);
  return choice.get() == 1;
}","/** 
 * Inform user there is an existing Trace Flag.
 * @return False if abort, true if continue
 */
@VisibleForTesting public boolean confirmExistingTraceFlag(){
  Display display=getDisplay();
  final AtomicInteger choice=new AtomicInteger(0);
  display.syncExec(new Runnable(){
    @Override public void run(){
      choice.set(DialogUtils.getInstance().abortContinueMessage(Messages.RunTestsLaunchConfigurationDelegate_ConfirmDialogTitle,Messages.RunTestsLaunchConfigurationDelegate_ExistingTraceFlag,MessageDialog.INFORMATION));
    }
  }
);
  return choice.get() == 1;
}",0.9887445887445888
113889,"@VisibleForTesting protected RunTestsView getRunTestView(){
  return RunTestsView.getInstance();
}","@VisibleForTesting public RunTestsView getRunTestView(){
  return RunTestsView.getInstance();
}",0.9430051813471504
113890,"@VisibleForTesting protected boolean isProjectDebugging(IProject project){
  return DebugListener.isDebugging(project);
}","@VisibleForTesting public boolean isProjectDebugging(IProject project){
  return DebugListener.isDebugging(project);
}",0.9539748953974896
113891,"@VisibleForTesting protected void disableLogging(ILaunchConfiguration configuration) throws CoreException {
  ILaunchConfigurationWorkingCopy realConfig=configuration.getWorkingCopy();
  realConfig.setAttribute(RunTestsConstants.ATTR_ENABLE_LOGGING,false);
  realConfig.doSave();
}","@VisibleForTesting public void disableLogging(ILaunchConfiguration configuration) throws CoreException {
  ILaunchConfigurationWorkingCopy realConfig=configuration.getWorkingCopy();
  realConfig.setAttribute(RunTestsConstants.ATTR_ENABLE_LOGGING,false);
  realConfig.doSave();
}",0.9767441860465116
113892,"@VisibleForTesting protected void removeLaunch(ILaunch launch){
  DebugPlugin.getDefault().getLaunchManager().removeLaunch(launch);
}","@VisibleForTesting public void removeLaunch(ILaunch launch){
  DebugPlugin.getDefault().getLaunchManager().removeLaunch(launch);
}",0.9581749049429658
113893,"@VisibleForTesting protected void checkMode(String mode) throws CoreException {
  if (!mode.equals(ILaunchManager.RUN_MODE)) {
    throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchDebugModeErrorMessage);
  }
}","@VisibleForTesting public void checkMode(String mode) throws CoreException {
  if (!mode.equals(ILaunchManager.RUN_MODE)) {
    throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchDebugModeErrorMessage);
  }
}",0.971677559912854
113894,"@VisibleForTesting protected IProject getProjectFromName(String name){
  return ResourcesPlugin.getWorkspace().getRoot().getProject(name);
}","@VisibleForTesting public IProject getProjectFromName(String name){
  return ResourcesPlugin.getWorkspace().getRoot().getProject(name);
}",0.96028880866426
113895,"/** 
 * Re-open config window with the specified launch config
 * @param configuration
 * @param mode
 */
@VisibleForTesting protected void reopenLaunchConfig(final ILaunchConfiguration configuration,final String mode){
  if (Utils.isNotEmpty(configuration) && Utils.isNotEmpty(mode)) {
    Display display=getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        IWorkbenchWindow aww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        ILaunchGroup launchGroup=DebugUITools.getLaunchGroup(configuration,mode);
        DebugUITools.openLaunchConfigurationDialog(aww.getShell(),configuration,launchGroup.getIdentifier(),null);
      }
    }
);
  }
}","/** 
 * Re-open config window with the specified launch config
 * @param configuration
 * @param mode
 */
@VisibleForTesting public void reopenLaunchConfig(final ILaunchConfiguration configuration,final String mode){
  if (Utils.isNotEmpty(configuration) && Utils.isNotEmpty(mode)) {
    Display display=getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        IWorkbenchWindow aww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        ILaunchGroup launchGroup=DebugUITools.getLaunchGroup(configuration,mode);
        DebugUITools.openLaunchConfigurationDialog(aww.getShell(),configuration,launchGroup.getIdentifier(),null);
      }
    }
);
  }
}",0.9906407487401008
113896,"@VisibleForTesting protected boolean getTestMode(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TEST_MODE,true);
}","@VisibleForTesting public boolean getTestMode(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_TEST_MODE,true);
}",0.9700272479564032
113897,"/** 
 * Pop up a confirmation dialog regarding asynchronous test run while debugging
 * @return False if abort, true if continue
 */
@VisibleForTesting protected boolean confirmAsyncTestRunWhileDebugging(){
  Display display=getDisplay();
  final AtomicInteger choice=new AtomicInteger(0);
  display.syncExec(new Runnable(){
    @Override public void run(){
      choice.set(DialogUtils.getInstance().abortContinueMessage(Messages.RunTestsLaunchConfigurationDelegate_ConfirmDialogTitle,Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchAsyncWhileDebugging,MessageDialog.WARNING));
    }
  }
);
  return choice.get() == 1;
}","/** 
 * Pop up a confirmation dialog regarding asynchronous test run while debugging
 * @return False if abort, true if continue
 */
@VisibleForTesting public boolean confirmAsyncTestRunWhileDebugging(){
  Display display=getDisplay();
  final AtomicInteger choice=new AtomicInteger(0);
  display.syncExec(new Runnable(){
    @Override public void run(){
      choice.set(DialogUtils.getInstance().abortContinueMessage(Messages.RunTestsLaunchConfigurationDelegate_ConfirmDialogTitle,Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchAsyncWhileDebugging,MessageDialog.WARNING));
    }
  }
);
  return choice.get() == 1;
}",0.9896579156722356
113898,"@VisibleForTesting protected boolean secondPhasePreLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor) throws CoreException {
  return super.preLaunchCheck(configuration,mode,monitor);
}","@VisibleForTesting public boolean secondPhasePreLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor) throws CoreException {
  return super.preLaunchCheck(configuration,mode,monitor);
}",0.9701149425287356
113899,"@VisibleForTesting protected Map<LogCategory,ApexLogLevel> getLogLevels(ILaunchConfiguration configuration) throws CoreException {
  Map<LogCategory,ApexLogLevel> finalLogLevels=new LinkedHashMap<LogCategory,ApexLogLevel>();
  if (Utils.isEmpty(configuration)) {
    return finalLogLevels;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> savedLogLevels=(Map<String,String>)configuration.getAttribute(RunTestsConstants.ATTR_LOG_LEVELS,Collections.emptyMap());
  for (  String categoryName : savedLogLevels.keySet()) {
    ApexLogLevel logLevel=ApexLogLevel.valueOf(savedLogLevels.get(categoryName));
    if (categoryName.equals(Messages.RunTestsTab_LogCategoryDatabase)) {
      finalLogLevels.put(LogCategory.Db,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryWorkflow)) {
      finalLogLevels.put(LogCategory.Workflow,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryValidation)) {
      finalLogLevels.put(LogCategory.Validation,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryCallout)) {
      finalLogLevels.put(LogCategory.Callout,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryApexCode)) {
      finalLogLevels.put(LogCategory.Apex_code,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryApexProfiling)) {
      finalLogLevels.put(LogCategory.Apex_profiling,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryVisualforce)) {
      finalLogLevels.put(LogCategory.Visualforce,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategorySystem)) {
      finalLogLevels.put(LogCategory.System,logLevel);
    }
  }
  return finalLogLevels;
}","@VisibleForTesting public Map<LogCategory,ApexLogLevel> getLogLevels(ILaunchConfiguration configuration) throws CoreException {
  Map<LogCategory,ApexLogLevel> finalLogLevels=new LinkedHashMap<LogCategory,ApexLogLevel>();
  if (Utils.isEmpty(configuration)) {
    return finalLogLevels;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> savedLogLevels=(Map<String,String>)configuration.getAttribute(RunTestsConstants.ATTR_LOG_LEVELS,Collections.emptyMap());
  for (  String categoryName : savedLogLevels.keySet()) {
    ApexLogLevel logLevel=ApexLogLevel.valueOf(savedLogLevels.get(categoryName));
    if (categoryName.equals(Messages.RunTestsTab_LogCategoryDatabase)) {
      finalLogLevels.put(LogCategory.Db,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryWorkflow)) {
      finalLogLevels.put(LogCategory.Workflow,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryValidation)) {
      finalLogLevels.put(LogCategory.Validation,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryCallout)) {
      finalLogLevels.put(LogCategory.Callout,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryApexCode)) {
      finalLogLevels.put(LogCategory.Apex_code,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryApexProfiling)) {
      finalLogLevels.put(LogCategory.Apex_profiling,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategoryVisualforce)) {
      finalLogLevels.put(LogCategory.Visualforce,logLevel);
    }
 else     if (categoryName.equals(Messages.RunTestsTab_LogCategorySystem)) {
      finalLogLevels.put(LogCategory.System,logLevel);
    }
  }
  return finalLogLevels;
}",0.9963513892786976
113900,"@VisibleForTesting protected boolean shouldEnableLogging(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_ENABLE_LOGGING,false);
}","@VisibleForTesting public boolean shouldEnableLogging(ILaunchConfiguration configuration) throws CoreException {
  return configuration.getAttribute(RunTestsConstants.ATTR_ENABLE_LOGGING,false);
}",0.9721518987341772
113901,"@VisibleForTesting protected Display getDisplay(){
  return PlatformUI.getWorkbench().getDisplay();
}","@VisibleForTesting public Display getDisplay(){
  return PlatformUI.getWorkbench().getDisplay();
}",0.9447236180904522
113902,"@Override public void _case(MethodMember x){
  if (hasTestModifier(x.methodDecl.modifiers)) {
    methodNames.add(x.methodDecl.name.value);
  }
}","@Override public void _case(MethodMember x){
  if (hasTestModifier(x.methodDecl.modifiers)) {
    RealLoc realLoc=(RealLoc)x.methodDecl.name.loc;
    ApexCodeLocation loc=new ApexCodeLocation(file,realLoc.line,realLoc.column);
    testMethods.put(x.methodDecl.name.value,loc);
  }
}",0.6042154566744731
113903,"/** 
 * Find test classes in a given project. Test classes are annotated with @IsTest.
 * @param project
 * @return Map of test resources whose key is the resource ID
 */
public Map<String,IResource> findTestClassesInProject(IProject project){
  final Map<String,IResource> testClasses=Maps.newHashMap();
  List<IResource> projectResources=findSourcesInProject(project);
  List<IResource> projectClasses=filterSourcesByClass(projectResources);
  try {
    for (    final IResource projectResource : projectClasses) {
      IFile projectClass=(IFile)projectResource;
      CompilationUnit compilationUnit=ApexModelManager.INSTANCE.getCompilationUnit(projectClass);
      compilationUnit._switch(new CompilationUnit.SwitchBlockWithDefault(){
        @Override public void _case(        ClassDeclUnit classDeclUnit){
          if (classDeclUnit.body != null) {
            if (hasTestModifier(classDeclUnit.body.modifiers)) {
              String resourceId=ResourceProperties.getProperty(projectResource,QualifiedNames.QN_ID);
              testClasses.put(resourceId,projectResource);
            }
          }
        }
        @Override protected void _default(        CompilationUnit x){
        }
      }
);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return testClasses;
}","/** 
 * Find test classes in a given project. Test classes are annotated with @IsTest.
 * @param project
 * @return Map of test resources whose key is the resource ID
 */
public Map<IResource,List<String>> findTestClassesInProject(IProject project){
  final Map<IResource,List<String>> allTests=Maps.newHashMap();
  List<IResource> projectResources=findSourcesInProject(project);
  List<IResource> projectClasses=filterSourcesByClass(projectResources);
  try {
    for (    final IResource projectResource : projectClasses) {
      List<String> methodNames=findTestMethodNamesInFile(projectResource);
      if (methodNames != null && methodNames.size() > 0) {
        allTests.put(projectResource,methodNames);
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return allTests;
}",0.5580084546735556
113904,"@Test public void testPreLaunchSyncWithDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(false);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}","@Test public void testPreLaunchSyncWithDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(false);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}",0.9993011879804332
113905,"@Test public void testPreLaunchAsyncWithDebugUserContinues() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(runTestsView.confirmAsyncTestRunWhileDebugging()).thenReturn(true);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,times(1)).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}","@Test public void testPreLaunchAsyncWithDebugUserContinues() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(runTestsView.confirmAsyncTestRunWhileDebugging()).thenReturn(true);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,times(1)).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}",0.999342105263158
113906,"@Test public void testPreLaunchSyncWithoutDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(false);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(false);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}","@Test public void testPreLaunchSyncWithoutDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(false);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(false);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}",0.9993031358885016
113907,"@Test public void testPreLaunchWithExistingRun() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(false);
  doNothing().when(mockedDelegate).throwErrorMsg(any(String.class));
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchAnotherConfig);
  assertTrue(prelaunchResult);
}","@Test public void testPreLaunchWithExistingRun() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(false);
  doNothing().when(mockedDelegate).throwErrorMsg(any(String.class));
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).throwErrorMsg(Messages.RunTestsLaunchConfigurationDelegate_CannotLaunchAnotherConfig);
  assertTrue(prelaunchResult);
}",0.9990458015267176
113908,"@Test public void testLaunchWithValidRunTestView() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  ILaunch launch=mock(ILaunch.class);
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  Map<String,IResource> testResources=Collections.<String,IResource>emptyMap();
  String tests=""String_Node_Str"";
  int totalTests=0;
  boolean isAsync=false;
  doCallRealMethod().when(mockedDelegate).launch(configuration,mode,launch,monitor);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestsArray(configuration)).thenReturn(tests);
  when(mockedDelegate.getTotalTests(configuration)).thenReturn(totalTests);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(isAsync);
  when(mockedDelegate.findTestClasses(project)).thenReturn(testResources);
  doNothing().when(mockedDelegate).removeLaunch(launch);
  doNothing().when(runTestsView).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  mockedDelegate.launch(configuration,mode,launch,monitor);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestsArray(configuration);
  verify(mockedDelegate,times(1)).getTotalTests(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).findTestClasses(project);
  verify(mockedDelegate,times(1)).removeLaunch(launch);
  verify(runTestsView,times(1)).runTests(project,testResources,tests,totalTests,isAsync,monitor);
}","@Test public void testLaunchWithValidRunTestView() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  ILaunch launch=mock(ILaunch.class);
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  Map<IResource,List<String>> testResources=Collections.<IResource,List<String>>emptyMap();
  String tests=""String_Node_Str"";
  int totalTests=0;
  boolean isAsync=false;
  DebugPlugin.getDefault().getLaunchManager().addLaunch(launch);
  doCallRealMethod().when(mockedDelegate).launch(configuration,mode,launch,monitor);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestsArray(configuration)).thenReturn(tests);
  when(mockedDelegate.getTotalTests(configuration)).thenReturn(totalTests);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(isAsync);
  when(mockedDelegate.findTestClasses(project)).thenReturn(testResources);
  doCallRealMethod().when(mockedDelegate).removeLaunch(launch);
  doNothing().when(runTestsView).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  mockedDelegate.launch(configuration,mode,launch,monitor);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestsArray(configuration);
  verify(mockedDelegate,times(1)).getTotalTests(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).findTestClasses(project);
  verify(mockedDelegate,times(1)).removeLaunch(launch);
  verify(runTestsView,times(1)).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  ILaunch[] launches=DebugPlugin.getDefault().getLaunchManager().getLaunches();
  assertNotNull(launches);
  assertEquals(0,launches.length);
}",0.5744125326370757
113909,"@Test public void testLaunchWithNullRunTestView() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  ILaunch launch=mock(ILaunch.class);
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  Map<String,IResource> testResources=Collections.<String,IResource>emptyMap();
  String tests=""String_Node_Str"";
  int totalTests=0;
  boolean isAsync=false;
  doCallRealMethod().when(mockedDelegate).launch(configuration,mode,launch,monitor);
  when(mockedDelegate.getRunTestView()).thenReturn(null);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestsArray(configuration)).thenReturn(tests);
  when(mockedDelegate.getTotalTests(configuration)).thenReturn(totalTests);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(isAsync);
  when(mockedDelegate.findTestClasses(project)).thenReturn(testResources);
  doNothing().when(mockedDelegate).removeLaunch(launch);
  doNothing().when(runTestsView).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  mockedDelegate.launch(configuration,mode,launch,monitor);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestsArray(configuration);
  verify(mockedDelegate,times(1)).getTotalTests(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).findTestClasses(project);
  verify(mockedDelegate,times(1)).removeLaunch(launch);
  verify(runTestsView,never()).runTests(project,testResources,tests,totalTests,isAsync,monitor);
}","@Test public void testLaunchWithNullRunTestView() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  ILaunch launch=mock(ILaunch.class);
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  Map<IResource,List<String>> testResources=Collections.<IResource,List<String>>emptyMap();
  String tests=""String_Node_Str"";
  int totalTests=0;
  boolean isAsync=false;
  DebugPlugin.getDefault().getLaunchManager().addLaunch(launch);
  doCallRealMethod().when(mockedDelegate).launch(configuration,mode,launch,monitor);
  when(mockedDelegate.getRunTestView()).thenReturn(null);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestsArray(configuration)).thenReturn(tests);
  when(mockedDelegate.getTotalTests(configuration)).thenReturn(totalTests);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(isAsync);
  when(mockedDelegate.findTestClasses(project)).thenReturn(testResources);
  doCallRealMethod().when(mockedDelegate).removeLaunch(launch);
  doNothing().when(runTestsView).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  mockedDelegate.launch(configuration,mode,launch,monitor);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestsArray(configuration);
  verify(mockedDelegate,times(1)).getTotalTests(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).findTestClasses(project);
  verify(mockedDelegate,times(1)).removeLaunch(launch);
  verify(runTestsView,never()).runTests(project,testResources,tests,totalTests,isAsync,monitor);
  ILaunch[] launches=DebugPlugin.getDefault().getLaunchManager().getLaunches();
  assertNotNull(launches);
  assertEquals(0,launches.length);
}",0.5727034120734908
113910,"@Test public void testPreLaunchAsyncWithDebugUserAborts() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  Display display=mock(Display.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(runTestsView.confirmAsyncTestRunWhileDebugging()).thenReturn(false);
  when(mockedDelegate.getDisplay()).thenReturn(display);
  doNothing().when(display).asyncExec(any(Runnable.class));
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,times(1)).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,times(1)).getDisplay();
  verify(display,times(1)).asyncExec(any(Runnable.class));
  assertFalse(prelaunchResult);
}","@Test public void testPreLaunchAsyncWithDebugUserAborts() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  Display display=mock(Display.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(true);
  when(runTestsView.confirmAsyncTestRunWhileDebugging()).thenReturn(false);
  when(mockedDelegate.getDisplay()).thenReturn(display);
  doNothing().when(display).asyncExec(any(Runnable.class));
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,times(1)).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,times(1)).getDisplay();
  verify(display,times(1)).asyncExec(any(Runnable.class));
  assertFalse(prelaunchResult);
}",0.999390243902439
113911,"@Test public void testPreLaunchAsyncWithoutDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestView runTestsView=mock(RunTestView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(false);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}","@Test public void testPreLaunchAsyncWithoutDebug() throws Exception {
  ILaunchConfiguration configuration=mock(ILaunchConfiguration.class);
  String mode=ILaunchManager.RUN_MODE;
  IProgressMonitor monitor=mock(IProgressMonitor.class);
  RunTestsView runTestsView=mock(RunTestsView.class);
  IProject project=mock(IProject.class);
  when(mockedDelegate.preLaunchCheck(configuration,mode,monitor)).thenCallRealMethod();
  doNothing().when(mockedDelegate).checkMode(mode);
  when(mockedDelegate.getRunTestView()).thenReturn(runTestsView);
  when(runTestsView.canRun()).thenReturn(true);
  when(mockedDelegate.materializeForceProject(configuration)).thenReturn(project);
  when(mockedDelegate.getTestMode(configuration)).thenReturn(true);
  when(mockedDelegate.isProjectDebugging(project)).thenReturn(false);
  when(mockedDelegate.secondPhasePreLaunchCheck(configuration,mode,monitor)).thenReturn(true);
  boolean prelaunchResult=mockedDelegate.preLaunchCheck(configuration,mode,monitor);
  verify(mockedDelegate,times(1)).checkMode(mode);
  verify(mockedDelegate,times(1)).getRunTestView();
  verify(mockedDelegate,times(1)).materializeForceProject(configuration);
  verify(mockedDelegate,times(1)).getTestMode(configuration);
  verify(mockedDelegate,times(1)).isProjectDebugging(project);
  verify(runTestsView,never()).confirmAsyncTestRunWhileDebugging();
  verify(mockedDelegate,never()).getDisplay();
  assertTrue(prelaunchResult);
}",0.9993031358885016
113912,"@Test public void testCreateTabs(){
  RunTestsLaunchConfigurationTabGroup tabGroup=new RunTestsLaunchConfigurationTabGroup();
  ILaunchConfigurationDialog mockDialog=mock(ILaunchConfigurationDialog.class);
  String mockMode=""String_Node_Str"";
  tabGroup.createTabs(mockDialog,mockMode);
  ILaunchConfigurationTab[] tabs=tabGroup.getTabs();
  assertNotNull(tabs);
  assertEquals(2,tabs.length);
  assertTrue(tabs[0] instanceof RunTestsTab);
  assertTrue(tabs[1] instanceof CommonTab);
}","@Test public void testCreateTabs(){
  RunTestsLaunchConfigurationTabGroup tabGroup=new RunTestsLaunchConfigurationTabGroup();
  ILaunchConfigurationDialog mockDialog=mock(ILaunchConfigurationDialog.class);
  String mockMode=""String_Node_Str"";
  tabGroup.createTabs(mockDialog,mockMode);
  ILaunchConfigurationTab[] tabs=tabGroup.getTabs();
  assertNotNull(tabs);
  assertEquals(2,tabs.length);
  assertTrue(tabs[0] instanceof RunTestsLaunchConfigurationTab);
  assertTrue(tabs[1] instanceof CommonTab);
}",0.980788675429727
113913,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.fragment_multi_slider_single,container,false);
  final TextView min1=(TextView)v.findViewById(R.id.minValue1);
  final TextView min2=(TextView)v.findViewById(R.id.minValue2);
  final TextView min3=(TextView)v.findViewById(R.id.minValue3);
  final TextView min4=(TextView)v.findViewById(R.id.minValue4);
  final TextView min5=(TextView)v.findViewById(R.id.minValue5);
  final TextView min6=(TextView)v.findViewById(R.id.minValue6);
  final TextView min7=(TextView)v.findViewById(R.id.minValue7);
  MultiSlider multiSlider1=(MultiSlider)v.findViewById(R.id.multiSlider1);
  MultiSlider multiSlider2=(MultiSlider)v.findViewById(R.id.multiSlider2);
  MultiSlider multiSlider3=(MultiSlider)v.findViewById(R.id.multiSlider3);
  MultiSlider multiSlider4=(MultiSlider)v.findViewById(R.id.multiSlider4);
  multiSlider4.getThumb(1).setInvisibleThumb(true);
  MultiSlider multiSlider5=(MultiSlider)v.findViewById(R.id.multiSlider5);
  MultiSlider multiSlider6=(MultiSlider)v.findViewById(R.id.multiSlider6);
  MultiSlider multiSlider7=(MultiSlider)v.findViewById(R.id.multiSlider7);
  min1.setText(String.valueOf(multiSlider1.getThumb(0).getValue()));
  min2.setText(String.valueOf(multiSlider2.getThumb(0).getValue()));
  min3.setText(String.valueOf(multiSlider3.getThumb(0).getValue()));
  min4.setText(String.valueOf(multiSlider4.getThumb(0).getValue()));
  min5.setText(String.valueOf(multiSlider5.getThumb(0).getValue()));
  min6.setText(String.valueOf(multiSlider6.getThumb(0).getValue()));
  min6.setText(String.valueOf(multiSlider7.getThumb(0).getValue()));
  multiSlider1.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min1.setText(String.valueOf(value));
    }
  }
);
  multiSlider2.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min2.setText(String.valueOf(value));
    }
  }
);
  multiSlider3.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min3.setText(String.valueOf(value));
    }
  }
);
  multiSlider4.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min4.setText(String.valueOf(value));
    }
  }
);
  multiSlider5.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min5.setText(String.valueOf(value));
    }
  }
);
  multiSlider6.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min6.setText(String.valueOf(value));
    }
  }
);
  multiSlider7.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min7.setText(String.valueOf(value));
    }
  }
);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.fragment_multi_slider_single,container,false);
  final TextView min1=(TextView)v.findViewById(R.id.minValue1);
  final TextView min2=(TextView)v.findViewById(R.id.minValue2);
  final TextView min3=(TextView)v.findViewById(R.id.minValue3);
  final TextView min4=(TextView)v.findViewById(R.id.minValue4);
  final TextView min5=(TextView)v.findViewById(R.id.minValue5);
  final TextView min6=(TextView)v.findViewById(R.id.minValue6);
  final TextView min7=(TextView)v.findViewById(R.id.minValue7);
  MultiSlider multiSlider1=(MultiSlider)v.findViewById(R.id.multiSlider1);
  MultiSlider multiSlider2=(MultiSlider)v.findViewById(R.id.multiSlider2);
  MultiSlider multiSlider3=(MultiSlider)v.findViewById(R.id.multiSlider3);
  MultiSlider multiSlider4=(MultiSlider)v.findViewById(R.id.multiSlider4);
  multiSlider4.getThumb(1).setInvisibleThumb(true);
  MultiSlider multiSlider5=(MultiSlider)v.findViewById(R.id.multiSlider5);
  MultiSlider multiSlider6=(MultiSlider)v.findViewById(R.id.multiSlider6);
  MultiSlider multiSlider7=(MultiSlider)v.findViewById(R.id.multiSlider7);
  min1.setText(String.valueOf(multiSlider1.getThumb(0).getValue()));
  min2.setText(String.valueOf(multiSlider2.getThumb(0).getValue()));
  min3.setText(String.valueOf(multiSlider3.getThumb(0).getValue()));
  min4.setText(String.valueOf(multiSlider4.getThumb(0).getValue()));
  min5.setText(String.valueOf(multiSlider5.getThumb(0).getValue()));
  min6.setText(String.valueOf(multiSlider6.getThumb(0).getValue()));
  min7.setText(String.valueOf(multiSlider7.getThumb(0).getValue()));
  multiSlider1.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min1.setText(String.valueOf(value));
    }
  }
);
  multiSlider2.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min2.setText(String.valueOf(value));
    }
  }
);
  multiSlider3.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min3.setText(String.valueOf(value));
    }
  }
);
  multiSlider4.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min4.setText(String.valueOf(value));
    }
  }
);
  multiSlider5.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min5.setText(String.valueOf(value));
    }
  }
);
  multiSlider6.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min6.setText(String.valueOf(value));
    }
  }
);
  multiSlider7.setOnThumbValueChangeListener(new MultiSlider.SimpleChangeListener(){
    @Override public void onValueChanged(    MultiSlider multiSlider,    MultiSlider.Thumb thumb,    int thumbIndex,    int value){
      min7.setText(String.valueOf(value));
    }
  }
);
  return v;
}",0.99972383319525
113914,"@Override public void onCreate(){
  super.onCreate();
  Log.i(TAG,""String_Node_Str"");
  initFabric();
  initFirebase();
  initApplication();
  registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(TAG,""String_Node_Str"");
  initFabric();
  initApplication();
  registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());
}",0.955665024630542
113915,"private void initQb(){
  QBSettings.getInstance().init(getApplicationContext(),StringObfuscator.getApplicationId(),StringObfuscator.getAuthKey(),StringObfuscator.getAuthSecret());
  QBSettings.getInstance().setAccountKey(StringObfuscator.getAccountKey());
  initDomains();
  initHTTPConfig();
  QBChatService.setDebugEnabled(StringObfuscator.getDebugEnabled());
}","private void initQb(){
  QBSettings.getInstance().init(getApplicationContext(),StringObfuscator.getApplicationId(),StringObfuscator.getAuthKey(),StringObfuscator.getAuthSecret());
  QBSettings.getInstance().setAccountKey(StringObfuscator.getAccountKey());
  initDomains();
  initHTTPConfig();
  QBChatService.setDebugEnabled(true);
}",0.9454022988505748
113916,"@Override public void onProviderSessionExpired(String provider){
  Log.d(TAG,""String_Node_Str"" + provider);
  if (!QBProvider.FIREBASE_PHONE.equals(provider)) {
    return;
  }
  FirebaseAuthHelper.getIdTokenForCurrentUser(new FirebaseAuthHelper.RequestFirebaseIdTokenCallback(){
    @Override public void onSuccess(    String authToken){
      Log.d(TAG,""String_Node_Str"" + authToken);
      Bundle bundle=new Bundle();
      bundle.putString(FirebaseAuthHelper.EXTRA_FIREBASE_ACCESS_TOKEN,authToken);
      SessionJobService.startSignInSocial(App.getInstance(),bundle);
    }
    @Override public void onError(    Exception e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      LandingActivity.start(App.getInstance());
    }
  }
);
}","@Override public void onProviderSessionExpired(String provider){
  Log.d(TAG,""String_Node_Str"" + provider);
  if (QBProvider.FIREBASE_PHONE.equals(provider) || QBProvider.TWITTER_DIGITS.equals(provider)) {
    FirebaseAuthHelper.getIdTokenForCurrentUser(new FirebaseAuthHelper.RequestFirebaseIdTokenCallback(){
      @Override public void onSuccess(      String authToken){
        Log.d(TAG,""String_Node_Str"" + authToken);
        Bundle bundle=new Bundle();
        bundle.putString(FirebaseAuthHelper.EXTRA_FIREBASE_ACCESS_TOKEN,authToken);
        SessionJobService.startSignInSocial(App.getInstance(),bundle);
      }
      @Override public void onError(      Exception e){
        Log.d(TAG,""String_Node_Str"" + e.getMessage());
        LandingActivity.start(App.getInstance());
      }
    }
);
  }
}",0.9413281753707284
113917,"@Override public void onError(Exception e){
  hideProgress();
}","@Override public void onError(Exception e){
  Log.d(TAG,""String_Node_Str"");
  hideProgress();
}",0.7974683544303798
113918,"@Override public void onSuccess(String authToken){
  showProgress();
  serviceManager.login(QBProvider.FIREBASE_PHONE,authToken,StringObfuscator.getFirebaseAuthProjectId()).subscribe(socialLoginObserver);
}","@Override public void onSuccess(String authToken){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  serviceManager.login(QBProvider.FIREBASE_PHONE,authToken,StringObfuscator.getFirebaseAuthProjectId()).subscribe(socialLoginObserver);
}",0.927927927927928
113919,"protected void initDataLoader(int id){
  getLoaderManager().initLoader(id,null,this);
}","protected void initDataLoader(int id){
  getLoaderManager().initLoader(id,null,this).forceLoad();
}",0.935483870967742
113920,"protected void loginChat(){
  isDialogLoading=true;
  showSnackbar(R.string.dialog_loading_dialogs,Snackbar.LENGTH_INDEFINITE);
  QBLoginChatCompositeCommand.start(this);
}","protected void loginChat(){
  isDialogLoading=true;
  showSnackbar(R.string.dialog_loading_dialogs,Snackbar.LENGTH_INDEFINITE,Priority.MAX);
  QBLoginChatCompositeCommand.start(this);
}",0.9635854341736696
113921,"@Override public void onLoadFinished(Loader<List<DialogWrapper>> loader,List<DialogWrapper> dialogsList){
  updateDialogsProcess=State.started;
  Log.d(TAG,""String_Node_Str"" + dialogsListLoader.isLoadCacheFinished());
  updateDialogsListFromQueue();
  updateDialogsAdapter(dialogsList);
  checkEmptyList(dialogsListAdapter.getCount());
  if (!baseActivity.isDialogLoading()) {
    baseActivity.hideSnackBar();
  }
  if (dialogsListLoader.isLoadCacheFinished()) {
    QBLoadDialogsCommand.start(getContext(),true);
  }
}","@Override public void onLoadFinished(Loader<List<DialogWrapper>> loader,List<DialogWrapper> dialogsList){
  updateDialogsProcess=State.started;
  Log.d(TAG,""String_Node_Str"" + dialogsListLoader.isLoadCacheFinished());
  updateDialogsListFromQueue();
  updateDialogsAdapter(dialogsList);
  checkEmptyList(dialogsListAdapter.getCount());
  if (!baseActivity.isDialogLoading()) {
    baseActivity.hideSnackBar(R.string.dialog_loading_dialogs);
  }
  if (dialogsListLoader.isLoadCacheFinished()) {
    QBLoadDialogsCommand.start(getContext(),true);
  }
}",0.971000935453695
113922,"@Override public BaseClickListenerViewHolder<QBChatDialog> onCreateViewHolder(ViewGroup parent,int viewType){
  return new ViewHolder(this,layoutInflater.inflate(R.layout.item_local_search,parent,false));
}","@Override public BaseClickListenerViewHolder<DialogSearchWrapper> onCreateViewHolder(ViewGroup parent,int viewType){
  return new ViewHolder(this,layoutInflater.inflate(R.layout.item_local_search,parent,false));
}",0.9307875894988068
113923,"public LocalSearchAdapter(BaseActivity baseActivity,List<QBChatDialog> list){
  super(baseActivity,list);
  dataManager=DataManager.getInstance();
}","public LocalSearchAdapter(BaseActivity baseActivity,List<DialogSearchWrapper> list){
  super(baseActivity,list);
}",0.7709923664122137
113924,"@Override protected boolean isMatch(QBChatDialog item,String query){
  String chatTitle=ChatDialogUtils.getTitleForChatDialog(item,dataManager);
  return chatTitle != null && chatTitle.toLowerCase().contains(query);
}","@Override protected boolean isMatch(DialogSearchWrapper item,String query){
  String chatTitle=ChatDialogUtils.getTitleForChatDialog(item.getChatDialog(),dataManager);
  return chatTitle != null && chatTitle.toLowerCase().contains(query);
}",0.8971553610503282
113925,"@Override public void onBindViewHolder(BaseClickListenerViewHolder<QBChatDialog> baseClickListenerViewHolder,int position){
  QBChatDialog chatDialog=getItem(position);
  ViewHolder viewHolder=(ViewHolder)baseClickListenerViewHolder;
  List<DialogOccupant> dialogOccupantsList=dataManager.getDialogOccupantDataManager().getDialogOccupantsListByDialogId(chatDialog.getDialogId());
  String label;
  if (QBDialogType.PRIVATE.equals(chatDialog.getType())) {
    QMUser currentUser=UserFriendUtils.createLocalUser(AppSession.getSession().getUser());
    QMUser opponentUser=ChatUtils.getOpponentFromPrivateDialog(currentUser,dialogOccupantsList);
    setOnlineStatus(viewHolder,opponentUser);
    displayAvatarImage(opponentUser.getAvatar(),viewHolder.avatarImageView);
    viewHolder.titleTextView.setText(opponentUser.getFullName());
  }
 else {
    List<Long> dialogOccupantsIdsList=ChatUtils.getIdsFromDialogOccupantsList(dialogOccupantsList);
    Message message=dataManager.getMessageDataManager().getLastMessageWithTempByDialogId(dialogOccupantsIdsList);
    DialogNotification dialogNotification=dataManager.getDialogNotificationDataManager().getLastDialogNotificationByDialogId(dialogOccupantsIdsList);
    label=ChatUtils.getDialogLastMessage(resources.getString(R.string.cht_notification_message),message,dialogNotification);
    viewHolder.labelTextView.setText(label);
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.dark_gray));
    displayGroupPhotoImage(chatDialog.getPhoto(),viewHolder.avatarImageView);
    viewHolder.titleTextView.setText(chatDialog.getName());
  }
  if (!TextUtils.isEmpty(query)) {
    TextViewHelper.changeTextColorView(baseActivity,viewHolder.titleTextView,query);
  }
}","@Override public void onBindViewHolder(BaseClickListenerViewHolder<DialogSearchWrapper> baseClickListenerViewHolder,int position){
  DialogSearchWrapper dialogWrapper=getItem(position);
  ViewHolder viewHolder=(ViewHolder)baseClickListenerViewHolder;
  String label;
  if (QBDialogType.PRIVATE.equals(dialogWrapper.getChatDialog().getType())) {
    QMUser opponentUser=dialogWrapper.getOpponentUser();
    setOnlineStatus(viewHolder,opponentUser);
    displayAvatarImage(opponentUser.getAvatar(),viewHolder.avatarImageView);
    viewHolder.titleTextView.setText(opponentUser.getFullName());
  }
 else {
    label=dialogWrapper.getLabel();
    viewHolder.labelTextView.setText(label);
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.dark_gray));
    displayGroupPhotoImage(dialogWrapper.getChatDialog().getPhoto(),viewHolder.avatarImageView);
    viewHolder.titleTextView.setText(dialogWrapper.getChatDialog().getName());
  }
  if (!TextUtils.isEmpty(query)) {
    TextViewHelper.changeTextColorView(baseActivity,viewHolder.titleTextView,query);
  }
}",0.3309506790564689
113926,"@Override protected List<QBChatDialog> getItems(){
  return dataManager.getQBChatDialogDataManager().getAllSorted();
}","@Override protected List<DialogSearchWrapper> getItems(){
  List<QBChatDialog> dialogsList=dataManager.getQBChatDialogDataManager().getAllSorted();
  List<DialogSearchWrapper> wrappedList=new ArrayList<>(dialogsList.size());
  for (  QBChatDialog dialog : dialogsList) {
    wrappedList.add(new DialogSearchWrapper(getContext(),dataManager,dialog));
  }
  return wrappedList;
}",0.3919191919191919
113927,"@Override protected Loader<List<QBChatDialog>> createDataLoader(){
  return new DialogsListLoader(getActivity(),dataManager);
}","@Override protected Loader<List<DialogSearchWrapper>> createDataLoader(){
  return new DialogsListLoader(getActivity(),dataManager);
}",0.9272030651340996
113928,"@Override public void onLoadFinished(Loader<List<QBChatDialog>> loader,List<QBChatDialog> dialogsList){
  this.dialogsList=dialogsList;
  updateLocal();
}","@Override public void onLoadFinished(Loader<List<DialogSearchWrapper>> loader,List<DialogSearchWrapper> dialogsList){
  this.dialogsList=dialogsList;
  updateLocal();
}",0.8819875776397516
113929,"private void initCustomListeners(){
  localSearchAdapter.setOnRecycleItemClickListener(new SimpleOnRecycleItemClickListener<QBChatDialog>(){
    @Override public void onItemClicked(    View view,    QBChatDialog chatDialog,    int position){
      if (QBDialogType.PRIVATE.equals(chatDialog.getType())) {
        startPrivateChatActivity(chatDialog);
      }
 else {
        startGroupChatActivity(chatDialog);
      }
    }
  }
);
}","private void initCustomListeners(){
  localSearchAdapter.setOnRecycleItemClickListener(new SimpleOnRecycleItemClickListener<DialogSearchWrapper>(){
    @Override public void onItemClicked(    View view,    DialogSearchWrapper dialogSearchWrapper,    int position){
      if (QBDialogType.PRIVATE.equals(dialogSearchWrapper.getChatDialog().getType())) {
        startPrivateChatActivity(dialogSearchWrapper.getChatDialog());
      }
 else {
        startGroupChatActivity(dialogSearchWrapper.getChatDialog());
      }
    }
  }
);
}",0.8443983402489627
113930,"@Override public void onItemClicked(View view,QBChatDialog chatDialog,int position){
  if (QBDialogType.PRIVATE.equals(chatDialog.getType())) {
    startPrivateChatActivity(chatDialog);
  }
 else {
    startGroupChatActivity(chatDialog);
  }
}","@Override public void onItemClicked(View view,DialogSearchWrapper dialogSearchWrapper,int position){
  if (QBDialogType.PRIVATE.equals(dialogSearchWrapper.getChatDialog().getType())) {
    startPrivateChatActivity(dialogSearchWrapper.getChatDialog());
  }
 else {
    startGroupChatActivity(dialogSearchWrapper.getChatDialog());
  }
}",0.658578856152513
113931,"private void performLoadChatsSuccessAction(Bundle bundle){
  hideSnackBar();
  isDialogLoading=false;
}","private void performLoadChatsSuccessAction(Bundle bundle){
  isDialogLoading=false;
}",0.9042553191489362
113932,"@Override public void onResult(Boolean aBoolean){
  if (isLoadedOldMessages) {
    messagesAdapter.setList(combinationMessagesList,false);
    messagesAdapter.notifyItemRangeInserted(0,totalEntries);
  }
 else {
    messagesAdapter.setList(combinationMessagesList,true);
    scrollMessagesToBottom();
  }
  messageSwipeRefreshLayout.setRefreshing(false);
  hideActionBarProgress();
  isLoadingMessages=false;
}","@Override public void onResult(Boolean aBoolean){
  if (isLoadedOldMessages) {
    messagesAdapter.addAllInBegin(combinationMessagesList);
  }
 else {
    messagesAdapter.addAllInEnd(combinationMessagesList);
    scrollMessagesToBottom();
  }
  messageSwipeRefreshLayout.setRefreshing(false);
  hideActionBarProgress();
  isLoadingMessages=false;
}",0.8258575197889182
113933,"@Override public Boolean performInBackground(Void... params) throws Exception {
  combinationMessagesList=createCombinationMessagesList();
  additionalActionsAfterLoadMessages();
  return true;
}","@Override public Boolean performInBackground(Void... params) throws Exception {
  combinationMessagesList=buildCombinationMessagesListByDate(lastMessageDate,isLoadedOldMessages);
  additionalActionsAfterLoadMessages();
  return true;
}",0.641860465116279
113934,"public void setList(List<CombinationMessage> collection,boolean notifyDataChanged){
  if (notifyDataChanged) {
    addList(collection);
  }
 else {
    chatMessages.clear();
    chatMessages.addAll(collection);
  }
}","public void setList(List<CombinationMessage> collection,boolean notifyDataChanged){
  chatMessages=collection;
  if (notifyDataChanged) {
    this.notifyDataSetChanged();
  }
}",0.6836734693877551
113935,"private List<QBChatDialog> loadAllDialogs(Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder) throws QBResponseException {
  List<QBChatDialog> allDialogsList=null;
  List<QBChatDialog> allDialogsListPrivate=new ArrayList<>();
  List<QBChatDialog> allDialogsListGroup=new ArrayList<>();
  boolean needToLoadMorePrivate=true;
  boolean needToLoadMoreGroup=true;
  int pageNumber=0;
  final QBRequestGetBuilder qbRequestGetBuilderPrivate=new QBRequestGetBuilder();
  qbRequestGetBuilderPrivate.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderPrivate.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderPrivate.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.PRIVATE.getCode());
  final QBRequestGetBuilder qbRequestGetBuilderGroup=new QBRequestGetBuilder();
  qbRequestGetBuilderGroup.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderGroup.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderGroup.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.GROUP.getCode());
  do {
    if (needToLoadMorePrivate) {
      needToLoadMorePrivate=loadAllDialogsByType(QBDialogType.PRIVATE,returnedBundle,qbRequestGetBuilderPrivate,allDialogsListPrivate,pageNumber);
    }
    if (needToLoadMoreGroup) {
      needToLoadMoreGroup=loadAllDialogsByType(QBDialogType.GROUP,returnedBundle,qbRequestGetBuilderGroup,allDialogsListGroup,pageNumber);
    }
    List<QBChatDialog> dialogsList=new ArrayList<>(dialogsListPrivate.size() + dialogsListGroup.size());
    dialogsList.addAll(dialogsListPrivate);
    dialogsList.addAll(dialogsListGroup);
    chatHelper.saveDialogsToCache(dialogsList);
    dialogsListPrivate=null;
    dialogsListGroup=null;
    pageNumber++;
    if (pageNumber == FIRST_PAGE_NUMBER) {
      sendLoadPageSuccess(new Bundle());
    }
  }
 while (needToLoadMorePrivate || needToLoadMoreGroup);
  allDialogsList=new ArrayList<>(allDialogsListPrivate.size() + allDialogsListGroup.size());
  allDialogsList.addAll(allDialogsListPrivate);
  allDialogsList.addAll(allDialogsListGroup);
  return allDialogsList;
}","private List<QBChatDialog> loadAllDialogs(Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder) throws QBResponseException {
  List<QBChatDialog> allDialogsList=null;
  List<QBChatDialog> allDialogsListPrivate=new ArrayList<>();
  List<QBChatDialog> allDialogsListGroup=new ArrayList<>();
  boolean needToLoadMorePrivate=true;
  boolean needToLoadMoreGroup=true;
  int pageNumber=0;
  final QBRequestGetBuilder qbRequestGetBuilderPrivate=new QBRequestGetBuilder();
  qbRequestGetBuilderPrivate.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderPrivate.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderPrivate.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.PRIVATE.getCode());
  final QBRequestGetBuilder qbRequestGetBuilderGroup=new QBRequestGetBuilder();
  qbRequestGetBuilderGroup.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderGroup.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderGroup.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.GROUP.getCode());
  do {
    if (needToLoadMorePrivate) {
      needToLoadMorePrivate=loadAllDialogsByType(QBDialogType.PRIVATE,returnedBundle,qbRequestGetBuilderPrivate,allDialogsListPrivate,pageNumber);
    }
    if (needToLoadMoreGroup) {
      needToLoadMoreGroup=loadAllDialogsByType(QBDialogType.GROUP,returnedBundle,qbRequestGetBuilderGroup,allDialogsListGroup,pageNumber);
    }
    int sizeListPrivate=dialogsListPrivate == null ? 0 : dialogsListPrivate.size();
    int sizeListGroup=dialogsListGroup == null ? 0 : dialogsListGroup.size();
    List<QBChatDialog> dialogsList=new ArrayList<>(sizeListPrivate + sizeListGroup);
    if (dialogsListPrivate != null)     dialogsList.addAll(dialogsListPrivate);
    if (dialogsListGroup != null)     dialogsList.addAll(dialogsListGroup);
    chatHelper.saveDialogsToCache(dialogsList);
    dialogsListPrivate=null;
    dialogsListGroup=null;
    pageNumber++;
    if (pageNumber == FIRST_PAGE_NUMBER) {
      sendLoadPageSuccess(new Bundle());
    }
  }
 while (needToLoadMorePrivate || needToLoadMoreGroup);
  allDialogsList=new ArrayList<>(allDialogsListPrivate.size() + allDialogsListGroup.size());
  allDialogsList.addAll(allDialogsListPrivate);
  allDialogsList.addAll(allDialogsListGroup);
  return allDialogsList;
}",0.9232158988256548
113936,"protected void startLoadDialogMessages(boolean isLoadOldMessages){
  if (currentChatDialog == null) {
    return;
  }
  showActionBarProgress();
  List<DialogOccupant> dialogOccupantsList=dataManager.getDialogOccupantDataManager().getDialogOccupantsListByDialogId(currentChatDialog.getDialogId());
  List<Long> dialogOccupantsIdsList=ChatUtils.getIdsFromDialogOccupantsList(dialogOccupantsList);
  Message message;
  DialogNotification dialogNotification;
  message=dataManager.getMessageDataManager().getMessageByDialogId(isLoadOldMessages,dialogOccupantsIdsList);
  dialogNotification=dataManager.getDialogNotificationDataManager().getDialogNotificationByDialogId(isLoadOldMessages,dialogOccupantsIdsList);
  long messageDateSent=ChatUtils.getDialogMessageCreatedDate(!isLoadOldMessages,message,dialogNotification);
  startLoadDialogMessages(currentChatDialog,messageDateSent,isLoadOldMessages);
}","protected void startLoadDialogMessages(final boolean isLoadOldMessages){
  if (currentChatDialog == null) {
    return;
  }
  showActionBarProgress();
  (new BaseAsyncTask<Void,Void,Boolean>(){
    private long messageDateSent;
    @Override public Boolean performInBackground(    Void... params) throws Exception {
      List<DialogOccupant> dialogOccupantsList=dataManager.getDialogOccupantDataManager().getDialogOccupantsListByDialogId(currentChatDialog.getDialogId());
      List<Long> dialogOccupantsIdsList=ChatUtils.getIdsFromDialogOccupantsList(dialogOccupantsList);
      Message message;
      DialogNotification dialogNotification;
      message=dataManager.getMessageDataManager().getMessageByDialogId(isLoadOldMessages,dialogOccupantsIdsList);
      dialogNotification=dataManager.getDialogNotificationDataManager().getDialogNotificationByDialogId(isLoadOldMessages,dialogOccupantsIdsList);
      messageDateSent=ChatUtils.getDialogMessageCreatedDate(!isLoadOldMessages,message,dialogNotification);
      return true;
    }
    @Override public void onResult(    Boolean aBoolean){
      startLoadDialogMessages(currentChatDialog,messageDateSent,isLoadOldMessages);
    }
    @Override public void onException(    Exception e){
      hideActionBarProgress();
      ErrorUtils.showError(BaseDialogActivity.this,e);
    }
  }
).execute();
}",0.7955555555555556
113937,"protected void initFields(){
  mainThreadHandler=new Handler(Looper.getMainLooper());
  resources=getResources();
  dataManager=DataManager.getInstance();
  imageUtils=new ImageUtils(this);
  loadAttachFileSuccessAction=new LoadAttachFileSuccessAction();
  loadDialogMessagesSuccessAction=new LoadDialogMessagesSuccessAction();
  loadDialogMessagesFailAction=new LoadDialogMessagesFailAction();
  typingTimer=new Timer();
  dialogObserver=new DialogObserver();
  messageObserver=new MessageObserver();
  dialogNotificationObserver=new DialogNotificationObserver();
  updatingDialogBroadcastReceiver=new UpdatingDialogBroadcastReceiver();
  appSharedHelper.saveNeedToOpenDialog(false);
  imagePickHelper=new ImagePickHelper();
  systemPermissionHelper=new SystemPermissionHelper(this);
  messagesTextViewLinkClickListener=new MessagesTextViewLinkClickListener();
  locationAttachClickListener=new LocationAttachClickListener();
  imageAttachClickListener=new ImageAttachClickListener();
  currentChatDialog=(QBChatDialog)getIntent().getExtras().getSerializable(QBServiceConsts.EXTRA_DIALOG);
  combinationMessagesList=createCombinationMessagesList();
}","protected void initFields(){
  mainThreadHandler=new Handler(Looper.getMainLooper());
  resources=getResources();
  dataManager=DataManager.getInstance();
  imageUtils=new ImageUtils(this);
  loadAttachFileSuccessAction=new LoadAttachFileSuccessAction();
  loadDialogMessagesSuccessAction=new LoadDialogMessagesSuccessAction();
  loadDialogMessagesFailAction=new LoadDialogMessagesFailAction();
  typingTimer=new Timer();
  dialogObserver=new DialogObserver();
  messageObserver=new MessageObserver();
  dialogNotificationObserver=new DialogNotificationObserver();
  updatingDialogBroadcastReceiver=new UpdatingDialogBroadcastReceiver();
  appSharedHelper.saveNeedToOpenDialog(false);
  imagePickHelper=new ImagePickHelper();
  systemPermissionHelper=new SystemPermissionHelper(this);
  messagesTextViewLinkClickListener=new MessagesTextViewLinkClickListener();
  locationAttachClickListener=new LocationAttachClickListener();
  imageAttachClickListener=new ImageAttachClickListener();
  currentChatDialog=(QBChatDialog)getIntent().getExtras().getSerializable(QBServiceConsts.EXTRA_DIALOG);
  combinationMessagesList=new ArrayList<>();
}",0.9807692307692308
113938,"public List<DialogNotification> getDialogNotificationsByDialogIdAndDate(String dialogId,long createdDate,boolean moreDate){
  List<DialogNotification> dialogNotificationsList=new ArrayList<>();
  try {
    QueryBuilder<DialogNotification,Long> messageQueryBuilder=dao.queryBuilder();
    if (moreDate) {
      messageQueryBuilder.where().gt(DialogNotification.Column.CREATED_DATE,createdDate);
    }
 else {
      messageQueryBuilder.where().lt(DialogNotification.Column.CREATED_DATE,createdDate);
    }
    Where<DialogNotification,Long> where=messageQueryBuilder.where();
    where.and(where.ne(DialogNotification.Column.STATE,State.TEMP_LOCAL),where.ne(DialogNotification.Column.STATE,State.TEMP_LOCAL_UNREAD));
    QueryBuilder<DialogOccupant,Long> dialogOccupantQueryBuilder=dialogOccupantDao.queryBuilder();
    QueryBuilder<Dialog,Long> dialogQueryBuilder=dialogDao.queryBuilder();
    dialogQueryBuilder.where().eq(Dialog.Column.ID,dialogId);
    dialogOccupantQueryBuilder.join(dialogQueryBuilder);
    messageQueryBuilder.join(dialogOccupantQueryBuilder);
    PreparedQuery<DialogNotification> preparedQuery=messageQueryBuilder.prepare();
    dialogNotificationsList=dao.query(preparedQuery);
  }
 catch (  SQLException e) {
    ErrorUtils.logError(e);
  }
  return dialogNotificationsList;
}","public List<DialogNotification> getDialogNotificationsByDialogIdAndDate(String dialogId,long createdDate,boolean moreDate){
  List<DialogNotification> dialogNotificationsList=new ArrayList<>();
  try {
    QueryBuilder<DialogNotification,Long> messageQueryBuilder=dao.queryBuilder();
    Where<DialogNotification,Long> where=messageQueryBuilder.where();
    where.and(where.ne(DialogNotification.Column.STATE,State.TEMP_LOCAL),where.ne(DialogNotification.Column.STATE,State.TEMP_LOCAL_UNREAD),moreDate ? where.gt(DialogNotification.Column.CREATED_DATE,createdDate) : where.lt(DialogNotification.Column.CREATED_DATE,createdDate));
    QueryBuilder<DialogOccupant,Long> dialogOccupantQueryBuilder=dialogOccupantDao.queryBuilder();
    QueryBuilder<Dialog,Long> dialogQueryBuilder=dialogDao.queryBuilder();
    dialogQueryBuilder.where().eq(Dialog.Column.ID,dialogId);
    dialogOccupantQueryBuilder.join(dialogQueryBuilder);
    messageQueryBuilder.join(dialogOccupantQueryBuilder);
    PreparedQuery<DialogNotification> preparedQuery=messageQueryBuilder.prepare();
    dialogNotificationsList=dao.query(preparedQuery);
  }
 catch (  SQLException e) {
    ErrorUtils.logError(e);
  }
  return dialogNotificationsList;
}",0.7010718539102818
113939,"public List<Message> getMessagesByDialogIdAndDate(String dialogId,long createdDate,boolean moreDate){
  List<Message> messagesList=new ArrayList<>();
  try {
    QueryBuilder<Message,Long> messageQueryBuilder=dao.queryBuilder();
    if (moreDate) {
      messageQueryBuilder.where().gt(Message.Column.CREATED_DATE,createdDate);
    }
 else {
      messageQueryBuilder.where().lt(Message.Column.CREATED_DATE,createdDate);
    }
    Where<Message,Long> where=messageQueryBuilder.where();
    where.and(where.ne(Message.Column.STATE,State.TEMP_LOCAL),where.ne(Message.Column.STATE,State.TEMP_LOCAL_UNREAD));
    QueryBuilder<DialogOccupant,Long> dialogOccupantQueryBuilder=dialogOccupantDao.queryBuilder();
    QueryBuilder<Dialog,Long> dialogQueryBuilder=dialogDao.queryBuilder();
    dialogQueryBuilder.where().eq(Dialog.Column.ID,dialogId);
    dialogOccupantQueryBuilder.join(dialogQueryBuilder);
    messageQueryBuilder.join(dialogOccupantQueryBuilder);
    PreparedQuery<Message> preparedQuery=messageQueryBuilder.prepare();
    messagesList=dao.query(preparedQuery);
  }
 catch (  SQLException e) {
    ErrorUtils.logError(e);
  }
  return messagesList;
}","public List<Message> getMessagesByDialogIdAndDate(String dialogId,long createdDate,boolean moreDate){
  List<Message> messagesList=new ArrayList<>();
  try {
    QueryBuilder<Message,Long> messageQueryBuilder=dao.queryBuilder();
    Where<Message,Long> where=messageQueryBuilder.where();
    where.and(where.ne(Message.Column.STATE,State.TEMP_LOCAL),where.ne(Message.Column.STATE,State.TEMP_LOCAL_UNREAD),moreDate ? where.gt(Message.Column.CREATED_DATE,createdDate) : where.lt(Message.Column.CREATED_DATE,createdDate));
    QueryBuilder<DialogOccupant,Long> dialogOccupantQueryBuilder=dialogOccupantDao.queryBuilder();
    QueryBuilder<Dialog,Long> dialogQueryBuilder=dialogDao.queryBuilder();
    dialogQueryBuilder.where().eq(Dialog.Column.ID,dialogId);
    dialogOccupantQueryBuilder.join(dialogQueryBuilder);
    messageQueryBuilder.join(dialogOccupantQueryBuilder);
    PreparedQuery<Message> preparedQuery=messageQueryBuilder.prepare();
    messagesList=dao.query(preparedQuery);
  }
 catch (  SQLException e) {
    ErrorUtils.logError(e);
  }
  return messagesList;
}",0.6780116435288849
113940,"private boolean loadAllDialogsByType(QBDialogType dialogsType,Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder,List<QBChatDialog> allDialogsList,int pageNumber) throws QBResponseException {
  boolean needToLoadMore=false;
  qbRequestGetBuilder.setSkip(allDialogsList.size());
  qbRequestGetBuilder.eq(FIELD_DIALOG_TYPE,dialogsType.getCode());
  List<QBChatDialog> newDialogsList=getDialogs(qbRequestGetBuilder,returnedBundle);
  allDialogsList.addAll(newDialogsList);
  needToLoadMore=newDialogsList.size() == ConstsCore.CHATS_DIALOGS_PER_PAGE;
  Log.d(""String_Node_Str"",""String_Node_Str"" + needToLoadMore + ""String_Node_Str""+ newDialogsList.size());
  if (dialogsType == QBDialogType.GROUP) {
    boolean needClean=(pageNumber == 0);
    tryJoinRoomChatsPage(newDialogsList,needClean);
  }
  return needToLoadMore;
}","private boolean loadAllDialogsByType(QBDialogType dialogsType,Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder,List<QBChatDialog> allDialogsList,int pageNumber) throws QBResponseException {
  boolean needToLoadMore=false;
  qbRequestGetBuilder.setSkip(allDialogsList.size());
  qbRequestGetBuilder.eq(FIELD_DIALOG_TYPE,dialogsType.getCode());
  List<QBChatDialog> newDialogsList=getDialogs(qbRequestGetBuilder,returnedBundle);
  if (dialogsType == QBDialogType.GROUP) {
    dialogsListGroup=newDialogsList;
  }
 else {
    dialogsListPrivate=newDialogsList;
  }
  allDialogsList.addAll(newDialogsList);
  needToLoadMore=newDialogsList.size() == ConstsCore.CHATS_DIALOGS_PER_PAGE;
  Log.d(""String_Node_Str"",""String_Node_Str"" + needToLoadMore + ""String_Node_Str""+ newDialogsList.size());
  if (dialogsType == QBDialogType.GROUP) {
    boolean needClean=(pageNumber == 0);
    tryJoinRoomChatsPage(newDialogsList,needClean);
  }
  return needToLoadMore;
}",0.924791086350975
113941,"private List<QBChatDialog> loadAllDialogs(Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder) throws QBResponseException {
  List<QBChatDialog> allDialogsList=null;
  List<QBChatDialog> allDialogsListPrivate=new ArrayList<>();
  List<QBChatDialog> allDialogsListGroup=new ArrayList<>();
  boolean needToLoadMorePrivate=true;
  boolean needToLoadMoreGroup=true;
  int pageNumber=0;
  final QBRequestGetBuilder qbRequestGetBuilderPrivate=new QBRequestGetBuilder();
  qbRequestGetBuilderPrivate.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderPrivate.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderPrivate.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.PRIVATE.getCode());
  final QBRequestGetBuilder qbRequestGetBuilderGroup=new QBRequestGetBuilder();
  qbRequestGetBuilderGroup.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderGroup.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderGroup.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.GROUP.getCode());
  do {
    if (needToLoadMorePrivate) {
      needToLoadMorePrivate=loadAllDialogsByType(QBDialogType.PRIVATE,returnedBundle,qbRequestGetBuilderPrivate,allDialogsListPrivate,pageNumber);
    }
    if (needToLoadMoreGroup) {
      needToLoadMoreGroup=loadAllDialogsByType(QBDialogType.GROUP,returnedBundle,qbRequestGetBuilderGroup,allDialogsListGroup,pageNumber);
    }
    pageNumber++;
    if (pageNumber == FIRST_PAGE_NUMBER) {
      sendLoadPageSuccess(new Bundle());
    }
  }
 while (needToLoadMorePrivate || needToLoadMoreGroup);
  allDialogsList=new ArrayList<>(allDialogsListPrivate.size() + allDialogsListGroup.size());
  allDialogsList.addAll(allDialogsListPrivate);
  allDialogsList.addAll(allDialogsListGroup);
  return allDialogsList;
}","private List<QBChatDialog> loadAllDialogs(Bundle returnedBundle,QBRequestGetBuilder qbRequestGetBuilder) throws QBResponseException {
  List<QBChatDialog> allDialogsList=null;
  List<QBChatDialog> allDialogsListPrivate=new ArrayList<>();
  List<QBChatDialog> allDialogsListGroup=new ArrayList<>();
  boolean needToLoadMorePrivate=true;
  boolean needToLoadMoreGroup=true;
  int pageNumber=0;
  final QBRequestGetBuilder qbRequestGetBuilderPrivate=new QBRequestGetBuilder();
  qbRequestGetBuilderPrivate.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderPrivate.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderPrivate.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.PRIVATE.getCode());
  final QBRequestGetBuilder qbRequestGetBuilderGroup=new QBRequestGetBuilder();
  qbRequestGetBuilderGroup.setLimit(ConstsCore.CHATS_DIALOGS_PER_PAGE);
  qbRequestGetBuilderGroup.sortDesc(QBServiceConsts.EXTRA_LAST_MESSAGE_DATE_SENT);
  qbRequestGetBuilderGroup.addRule(FIELD_DIALOG_TYPE,OPERATOR_EQ,QBDialogType.GROUP.getCode());
  do {
    if (needToLoadMorePrivate) {
      needToLoadMorePrivate=loadAllDialogsByType(QBDialogType.PRIVATE,returnedBundle,qbRequestGetBuilderPrivate,allDialogsListPrivate,pageNumber);
    }
    if (needToLoadMoreGroup) {
      needToLoadMoreGroup=loadAllDialogsByType(QBDialogType.GROUP,returnedBundle,qbRequestGetBuilderGroup,allDialogsListGroup,pageNumber);
    }
    List<QBChatDialog> dialogsList=new ArrayList<>(dialogsListPrivate.size() + dialogsListGroup.size());
    dialogsList.addAll(dialogsListPrivate);
    dialogsList.addAll(dialogsListGroup);
    chatHelper.saveDialogsToCache(dialogsList);
    dialogsListPrivate=null;
    dialogsListGroup=null;
    pageNumber++;
    if (pageNumber == FIRST_PAGE_NUMBER) {
      sendLoadPageSuccess(new Bundle());
    }
  }
 while (needToLoadMorePrivate || needToLoadMoreGroup);
  allDialogsList=new ArrayList<>(allDialogsListPrivate.size() + allDialogsListGroup.size());
  allDialogsList.addAll(allDialogsListPrivate);
  allDialogsList.addAll(allDialogsListGroup);
  return allDialogsList;
}",0.924764090793165
113942,"public List<QBChatDialog> getDialogs(QBRequestGetBuilder qbRequestGetBuilder,Bundle returnedBundle) throws QBResponseException {
  List<QBChatDialog> qbDialogsList=QBRestChatService.getChatDialogs(null,qbRequestGetBuilder).perform();
  if (qbDialogsList != null && !qbDialogsList.isEmpty()) {
    FinderUnknownUsers finderUnknownUsers=new FinderUnknownUsers(context,AppSession.getSession().getUser(),qbDialogsList);
    finderUnknownUsers.find();
    DbUtils.saveDialogsToCache(dataManager,qbDialogsList,currentDialog);
    DbUtils.updateDialogsOccupantsStatusesIfNeeded(dataManager,qbDialogsList);
  }
  return qbDialogsList;
}","public List<QBChatDialog> getDialogs(QBRequestGetBuilder qbRequestGetBuilder,Bundle returnedBundle) throws QBResponseException {
  List<QBChatDialog> qbDialogsList=QBRestChatService.getChatDialogs(null,qbRequestGetBuilder).perform();
  return qbDialogsList;
}",0.5839909808342728
113943,"private void setCurrentFragment(Fragment fragment,String tag){
  currentFragment=fragment;
  getSupportFragmentManager().popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  FragmentTransaction transaction=buildTransaction();
  transaction.replace(R.id.container_fragment,fragment,tag);
  transaction.commit();
}","private void setCurrentFragment(Fragment fragment,String tag,boolean needAddToBackStack){
  currentFragment=fragment;
  FragmentTransaction transaction=buildTransaction();
  if (needAddToBackStack) {
    transaction.addToBackStack(null);
  }
  transaction.replace(R.id.container_fragment,fragment,tag);
  transaction.commit();
}",0.7107692307692308
113944,"private void launchDialogsListFragment(){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  setCurrentFragment(DialogsListFragment.newInstance());
}","private void launchDialogsListFragment(){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  setCurrentFragment(DialogsListFragment.newInstance(),true);
}",0.9831649831649832
113945,"private void launchContactsFragment(){
  baseActivity.setCurrentFragment(SearchFragment.newInstance());
}","private void launchContactsFragment(){
  baseActivity.setCurrentFragment(SearchFragment.newInstance(),true);
}",0.9767441860465116
113946,"@Override public boolean onMenuItemActionCollapse(MenuItem item){
  cancelSearch();
  launchDialogsListFragment();
  return true;
}","@Override public boolean onMenuItemActionCollapse(MenuItem item){
  cancelSearch();
  baseActivity.getSupportFragmentManager().popBackStack();
  return true;
}",0.8137931034482758
113947,"protected void loginChat(){
  QBLoginChatCompositeCommand.start(this);
}","protected void loginChat(){
  isDialogLoading=true;
  showSnackbar(R.string.dialog_loading_dialogs,Snackbar.LENGTH_INDEFINITE);
  QBLoginChatCompositeCommand.start(this);
}",0.5901639344262295
113948,"private void showSnackbarUpdatingDialogs(){
  showSnackbar(R.string.dialog_loading_dialogs,Snackbar.LENGTH_INDEFINITE);
  loadDialogs();
}","private void showSnackbarUpdatingDialogs(){
  loadDialogs();
}",0.62
113949,"private void performLoadChatsSuccessAction(Bundle bundle){
  hideSnackBar();
}","private void performLoadChatsSuccessAction(Bundle bundle){
  hideSnackBar();
  isDialogLoading=false;
}",0.861878453038674
113950,"@Override public void onLoadFinished(Loader<List<DialogWrapper>> loader,List<DialogWrapper> dialogsList){
  dialogsListAdapter.setNewData(dialogsList);
  checkEmptyList(dialogsList.size());
}","@Override public void onLoadFinished(Loader<List<DialogWrapper>> loader,List<DialogWrapper> dialogsList){
  dialogsListAdapter.setNewData(dialogsList);
  checkEmptyList(dialogsList.size());
  if (!baseActivity.isDialogLoading()) {
    baseActivity.hideSnackBar();
  }
}",0.8304347826086956
113951,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  Log.d(TAG,""String_Node_Str"");
  initDataLoader(LOADER_ID);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  Log.d(TAG,""String_Node_Str"");
  baseActivity.showSnackbar(R.string.dialog_loading_dialogs,Snackbar.LENGTH_INDEFINITE);
  initDataLoader(LOADER_ID);
}",0.8052516411378556
113952,"public static QBChatDialog parseDialogFromQBMessage(Context context,QBChatMessage qbChatMessage,String lastMessage,QBDialogType qbDialogType){
  QBChatDialog qbDialog=parseDialogFromQBMessage(context,qbChatMessage,qbDialogType);
  if (!qbChatMessage.getAttachments().isEmpty()) {
    qbDialog.setLastMessage(context.getString(R.string.dlg_attached_last_message));
  }
 else   if (!TextUtils.isEmpty(lastMessage)) {
    qbDialog.setLastMessage(lastMessage);
  }
  return qbDialog;
}","public static QBChatDialog parseDialogFromQBMessage(Context context,QBChatMessage qbChatMessage,String lastMessage,QBDialogType qbDialogType){
  QBChatDialog qbDialog=parseDialogFromQBMessage(context,qbChatMessage,qbDialogType);
  if (!CollectionUtils.isEmpty(qbChatMessage.getAttachments())) {
    qbDialog.setLastMessage(context.getString(R.string.dlg_attached_last_message));
  }
 else   if (!TextUtils.isEmpty(lastMessage)) {
    qbDialog.setLastMessage(lastMessage);
  }
  return qbDialog;
}",0.9662231320368476
113953,"private void updateFriends(Collection<Integer> friendIdsList) throws QBResponseException {
  List<QMUser> qmUsers=QMUserService.getInstance().getUsersByIDsSync(friendIdsList,new QBPagedRequestBuilder());
  saveUsersAndFriends(qmUsers);
}","private void updateFriends(Collection<Integer> friendIdsList) throws QBResponseException {
  QBPagedRequestBuilder requestBuilder=new QBPagedRequestBuilder();
  requestBuilder.setPage(ConstsCore.USERS_PAGE_NUM);
  requestBuilder.setPerPage(ConstsCore.USERS_PER_PAGE);
  List<QMUser> qmUsers=QMUserService.getInstance().getUsersByIDsSync(friendIdsList,requestBuilder);
  saveUsersAndFriends(qmUsers);
}",0.658307210031348
113954,"@Override public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if ((keyCode == android.view.KeyEvent.KEYCODE_BACK)) {
    getFragmentManager().popBackStack();
  }
  return false;
}","@Override public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if ((keyCode == android.view.KeyEvent.KEYCODE_BACK)) {
    if (getFragmentManager() != null) {
      getFragmentManager().popBackStack();
    }
  }
  return false;
}",0.8938053097345132
113955,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  MaterialDialog.Builder builder=new MaterialDialog.Builder(getActivity());
  builder.title(R.string.dlg_choose_image_from);
  String[] imagePickArray=getResources().getStringArray(R.array.dlg_image_pick);
  ArrayList<String> imagePickList=new ArrayList<>(Arrays.asList(imagePickArray));
  if (getArguments().getInt(""String_Node_Str"") != ImageUtils.IMAGE_LOCATION_REQUEST_CODE) {
    imagePickList.remove(2);
  }
  builder.items(imagePickList.toArray(new String[imagePickList.size()]));
  builder.itemsCallback(new MaterialDialog.ListCallback(){
    @Override public void onSelection(    MaterialDialog materialDialog,    View view,    int i,    CharSequence charSequence){
switch (i) {
case POSITION_GALLERY:
        if (systemPermissionHelper.isAllPermissionsGrantedForSaveFile()) {
          onImageSourcePickedListener.onImageSourcePicked(ImageSource.GALLERY);
        }
 else {
          systemPermissionHelper.requestPermissionsForSaveFile();
        }
      break;
case POSITION_CAMERA:
    if (systemPermissionHelper.isCameraPermissionGranted()) {
      onImageSourcePickedListener.onImageSourcePicked(ImageSource.CAMERA);
    }
 else {
      systemPermissionHelper.requestPermissionsTakePhoto();
    }
  break;
case POSITION_LOCATION:
onImageSourcePickedListener.onImageSourcePicked(ImageSource.LOCATION);
break;
}
}
}
);
MaterialDialog dialog=builder.build();
dialog.setCanceledOnTouchOutside(false);
dialog.setOnKeyListener(new DialogInterface.OnKeyListener(){
@Override public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
if ((keyCode == android.view.KeyEvent.KEYCODE_BACK)) {
getFragmentManager().popBackStack();
}
return false;
}
}
);
return dialog;
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  MaterialDialog.Builder builder=new MaterialDialog.Builder(getActivity());
  builder.title(R.string.dlg_choose_image_from);
  String[] imagePickArray=getResources().getStringArray(R.array.dlg_image_pick);
  ArrayList<String> imagePickList=new ArrayList<>(Arrays.asList(imagePickArray));
  if (getArguments().getInt(""String_Node_Str"") != ImageUtils.IMAGE_LOCATION_REQUEST_CODE) {
    imagePickList.remove(2);
  }
  builder.items(imagePickList.toArray(new String[imagePickList.size()]));
  builder.itemsCallback(new MaterialDialog.ListCallback(){
    @Override public void onSelection(    MaterialDialog materialDialog,    View view,    int i,    CharSequence charSequence){
switch (i) {
case POSITION_GALLERY:
        if (systemPermissionHelper.isAllPermissionsGrantedForSaveFile()) {
          onImageSourcePickedListener.onImageSourcePicked(ImageSource.GALLERY);
        }
 else {
          systemPermissionHelper.requestPermissionsForSaveFile();
        }
      break;
case POSITION_CAMERA:
    if (systemPermissionHelper.isCameraPermissionGranted()) {
      onImageSourcePickedListener.onImageSourcePicked(ImageSource.CAMERA);
    }
 else {
      systemPermissionHelper.requestPermissionsTakePhoto();
    }
  break;
case POSITION_LOCATION:
onImageSourcePickedListener.onImageSourcePicked(ImageSource.LOCATION);
break;
}
}
}
);
MaterialDialog dialog=builder.build();
dialog.setCanceledOnTouchOutside(false);
dialog.setOnKeyListener(new DialogInterface.OnKeyListener(){
@Override public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
if ((keyCode == android.view.KeyEvent.KEYCODE_BACK)) {
if (getFragmentManager() != null) {
getFragmentManager().popBackStack();
}
}
return false;
}
}
);
return dialog;
}",0.9892776523702032
113956,"public static String getFullNameById(DataManager dataManager,int userId){
  QMUser user=null;
  try {
    user=QMUserService.getInstance().getUserSync(userId,false);
  }
 catch (  QBResponseException e) {
    user=null;
  }
  return user != null ? user.getFullName() : ""String_Node_Str"";
}","public static String getFullNameById(DataManager dataManager,int userId){
  QMUser user=QMUserService.getInstance().getUserCache().get((long)userId);
  return user != null ? user.getFullName() : ""String_Node_Str"";
}",0.6150793650793651
113957,"private void setOnlineStatus(ViewHolder viewHolder,QMUser user){
  boolean online=qbFriendListHelper != null && qbFriendListHelper.isUserOnline(user.getId());
  if (online) {
    viewHolder.labelTextView.setText(OnlineStatusUtils.getOnlineStatus(online));
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.green));
  }
 else {
    viewHolder.labelTextView.setText(resources.getString(R.string.last_seen,DateUtils.toTodayYesterdayShortDateWithoutYear2(user.getLastRequestAt().getTime()),DateUtils.formatDateSimpleTime(user.getLastRequestAt().getTime())));
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.dark_gray));
  }
}","private void setOnlineStatus(ViewHolder viewHolder,QMUser user){
  boolean online=qbFriendListHelper != null && user.getId() != null && qbFriendListHelper.isUserOnline(user.getId());
  if (online) {
    viewHolder.labelTextView.setText(OnlineStatusUtils.getOnlineStatus(online));
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.green));
  }
 else {
    viewHolder.labelTextView.setText(resources.getString(R.string.last_seen,DateUtils.toTodayYesterdayShortDateWithoutYear2(user.getLastRequestAt().getTime()),DateUtils.formatDateSimpleTime(user.getLastRequestAt().getTime())));
    viewHolder.labelTextView.setTextColor(resources.getColor(R.color.dark_gray));
  }
}",0.9821693907875184
113958,"public static String getFullNameById(DataManager dataManager,int userId){
  QMUser user=null;
  try {
    user=QMUserService.getInstance().getUserSync(userId,true);
  }
 catch (  QBResponseException e) {
    user=null;
  }
  return user != null ? user.getFullName() : ""String_Node_Str"";
}","public static String getFullNameById(DataManager dataManager,int userId){
  QMUser user=null;
  try {
    user=QMUserService.getInstance().getUserSync(userId,false);
  }
 catch (  QBResponseException e) {
    user=null;
  }
  return user != null ? user.getFullName() : ""String_Node_Str"";
}",0.9878682842287696
113959,"@Override public Observable<QBUser> call(final QBUser user){
  UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
  CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
  getTDUserWithFullName(user);
  return updateUserObservable(user);
}","@Override public Observable<QBUser> call(final QBUser user){
  if (TextUtils.isEmpty(user.getFullName())) {
    CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
    getTDUserWithFullName(user);
  }
  return updateUserObservable(user);
}",0.7909604519774012
113960,"@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getTDUserWithFullName(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      if (TextUtils.isEmpty(user.getFullName())) {
        CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
        getTDUserWithFullName(user);
      }
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.9497859089139744
113961,"@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getFBUserWithAvatar(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
      if (TextUtils.isEmpty(userCustomData.getAvatarUrl())) {
        CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
        getFBUserWithAvatar(user);
      }
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.9130913091309132
113962,"@Override public void onError(Throwable e){
  Log.d(TAG,""String_Node_Str"" + e.getMessage());
}","@Override public void onError(Throwable e){
  Log.d(TAG,""String_Node_Str"" + e.getMessage());
  authActivity.hideProgress();
  parseExceptionMessage(e.getMessage());
}",0.7230769230769231
113963,"public void login(QBUser user){
  final String userPassword=user.getPassword();
  authService.login(user).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).map(new Func1<QBUser,QMUser>(){
    @Override public QMUser call(    QBUser qbUser){
      QMUser result=QMUser.convert(qbUser);
      userCache.createOrUpdate(result);
      return result;
    }
  }
).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      String password=userPassword;
      if (!hasUserCustomData(qbUser)) {
        qbUser.setOldPassword(password);
        try {
          updateUser(qbUser);
        }
 catch (        QBResponseException e) {
          e.printStackTrace();
        }
      }
      String token=QBSessionManager.getInstance().getToken();
      qbUser.setPassword(password);
      saveOwnerUser(qbUser);
      AppSession.startSession(qbUser);
      authActivity.startMainActivity(qbUser);
      GoogleAnalyticsHelper.pushAnalyticsData(authActivity,qbUser,""String_Node_Str"");
      FlurryAnalyticsHelper.pushAnalyticsData(authActivity);
    }
  }
);
}","public void login(QBUser user){
  final String userPassword=user.getPassword();
  authService.login(user).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).map(new Func1<QBUser,QMUser>(){
    @Override public QMUser call(    QBUser qbUser){
      QMUser result=QMUser.convert(qbUser);
      userCache.createOrUpdate(result);
      return result;
    }
  }
).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      authActivity.hideProgress();
      parseExceptionMessage(e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      String password=userPassword;
      if (!hasUserCustomData(qbUser)) {
        qbUser.setOldPassword(password);
        try {
          updateUser(qbUser);
        }
 catch (        QBResponseException e) {
          e.printStackTrace();
        }
      }
      String token=QBSessionManager.getInstance().getToken();
      qbUser.setPassword(password);
      saveOwnerUser(qbUser);
      AppSession.startSession(qbUser);
      authActivity.startMainActivity(qbUser);
      GoogleAnalyticsHelper.pushAnalyticsData(authActivity,qbUser,""String_Node_Str"");
      FlurryAnalyticsHelper.pushAnalyticsData(authActivity);
    }
  }
);
}",0.9691833590138677
113964,"public List<QMUser> getUsersForGroupChat(String dialogId,List<Integer> idsList){
  List<QMUser> usersList=Collections.emptyList();
  List<QMUser> qmUsers=QMUserService.getInstance().getUserCache().getUsersByIDs(idsList);
  List<DialogOccupant> dialogOccupants=dataManager.getDialogOccupantDataManager().getActualDialogOccupantsByDialog(dialogId);
  Set<Integer> dialogOccupantIdsSet=new HashSet<>();
  for (  DialogOccupant dialogOccupant : dialogOccupants) {
    dialogOccupantIdsSet.add(dialogOccupant.getUser().getId());
  }
  for (  QMUser qmUser : qmUsers) {
    if (dialogOccupantIdsSet.contains(qmUser.getId())) {
      usersList.add(qmUser);
    }
  }
  return usersList;
}","public List<QMUser> getUsersForGroupChat(String dialogId,List<Integer> idsList){
  List<QMUser> usersList=new ArrayList<>();
  List<QMUser> qmUsers=QMUserService.getInstance().getUserCache().getUsersByIDs(idsList);
  List<DialogOccupant> dialogOccupants=dataManager.getDialogOccupantDataManager().getActualDialogOccupantsByDialog(dialogId);
  Set<Integer> dialogOccupantIdsSet=new HashSet<>();
  for (  DialogOccupant dialogOccupant : dialogOccupants) {
    dialogOccupantIdsSet.add(dialogOccupant.getUser().getId());
  }
  for (  QMUser qmUser : qmUsers) {
    if (dialogOccupantIdsSet.contains(qmUser.getId())) {
      usersList.add(qmUser);
    }
  }
  return usersList;
}",0.9808259587020648
113965,"private void updateDialog(){
  QBChatDialog qbDialog=ChatUtils.createQBDialogFromLocalDialog(dataManager,dataManager.getDialogDataManager().getByDialogId(dialogId));
  occupantsList=getUsersForGroupChat(qbDialog.getDialogId(),qbDialog.getOccupants());
  qbDialog.setOccupantsIds(ChatUtils.createOccupantsIdsFromUsersList(occupantsList));
  groupDialogOccupantsAdapter.setNewData(occupantsList);
}","private void updateDialog(){
  qbDialog=ChatUtils.createQBDialogFromLocalDialog(dataManager,dataManager.getDialogDataManager().getByDialogId(dialogId));
  occupantsList=getUsersForGroupChat(qbDialog.getDialogId(),qbDialog.getOccupants());
  qbDialog.setOccupantsIds(ChatUtils.createOccupantsIdsFromUsersList(occupantsList));
  groupDialogOccupantsAdapter.setNewData(occupantsList);
}",0.9833119383825416
113966,"@Override public void execute(Bundle bundle){
  Exception exception=(Exception)bundle.getSerializable(QBServiceConsts.EXTRA_ERROR);
  if (exception != null) {
    emailEditText.setError(exception.getMessage());
  }
  hideProgress();
}","@Override public void execute(Bundle bundle){
  QBResponseException exception=(QBResponseException)bundle.getSerializable(QBServiceConsts.EXTRA_ERROR);
  if (exception != null) {
    String errorMesasge=exception.getHttpStatusCode() == HttpStatus.SC_NOT_FOUND ? getString(R.string.forgot_password_email_not_found_error) : exception.getMessage();
    emailEditText.setError(errorMesasge);
  }
  hideProgress();
}",0.5023255813953489
113967,"private void startFriendProfile(QMUser selectedFriend){
  QBUser currentUser=AppSession.getSession().getUser();
  if (currentUser.getId() == selectedFriend.getId()) {
    MyProfileActivity.start(GroupDialogDetailsActivity.this);
  }
 else {
    UserProfileActivity.start(GroupDialogDetailsActivity.this,selectedFriend.getId());
  }
}","private void startFriendProfile(QMUser selectedFriend){
  QBUser currentUser=AppSession.getSession().getUser();
  if (currentUser.getId().intValue() == selectedFriend.getId().intValue()) {
    MyProfileActivity.start(GroupDialogDetailsActivity.this);
  }
 else {
    UserProfileActivity.start(GroupDialogDetailsActivity.this,selectedFriend.getId());
  }
}",0.9680232558139537
113968,"private boolean isMe(QMUser inputUser){
  QBUser currentUser=AppSession.getSession().getUser();
  return currentUser.getId() == inputUser.getId();
}","private boolean isMe(QMUser inputUser){
  QBUser currentUser=AppSession.getSession().getUser();
  return currentUser.getId().intValue() == inputUser.getId().intValue();
}",0.9308176100628932
113969,"private boolean isMe(QMUser inputUser){
  QBUser currentUser=AppSession.getSession().getUser();
  return currentUser.getId() == inputUser.getId();
}","private boolean isMe(QMUser inputUser){
  QBUser currentUser=AppSession.getSession().getUser();
  return currentUser.getId().intValue() == inputUser.getId().intValue();
}",0.9308176100628932
113970,"public boolean isIncoming(int currentUserId){
  return dialogOccupant != null && dialogOccupant.getUser() != null && currentUserId != dialogOccupant.getUser().getId();
}","public boolean isIncoming(int currentUserId){
  return dialogOccupant != null && dialogOccupant.getUser() != null && currentUserId != dialogOccupant.getUser().getId().intValue();
}",0.968481375358166
113971,"private void findUserInDialog(QBChatDialog dialog){
  List<Integer> occupantsList=dialog.getOccupants();
  for (  int occupantId : occupantsList) {
    boolean isUserInBase=QMUserService.getInstance().getUserCache().exists((long)occupantId);
    if (!isUserInBase && currentUser.getId() != occupantId) {
      loadIdsSet.add(occupantId);
    }
  }
}","private void findUserInDialog(QBChatDialog dialog){
  List<Integer> occupantsList=dialog.getOccupants();
  for (  int occupantId : occupantsList) {
    boolean isUserInBase=QMUserService.getInstance().getUserCache().exists((long)occupantId);
    if (!isUserInBase && currentUser.getId().intValue() != occupantId) {
      loadIdsSet.add(occupantId);
    }
  }
}",0.9844851904090268
113972,"protected List<CombinationMessage> buildCombinationMessagesListByDate(long createDate,boolean moreDate){
  if (dialog == null) {
    Log.d(""String_Node_Str"",""String_Node_Str"" + dialog);
    return null;
  }
  List<Message> messagesList=dataManager.getMessageDataManager().getMessagesByDialogIdAndDate(dialog.getDialogId(),createDate,moreDate);
  List<DialogNotification> dialogNotificationsList=dataManager.getDialogNotificationDataManager().getDialogNotificationsByDialogIdAndDate(dialog.getDialogId(),createDate,moreDate);
  return ChatUtils.createCombinationMessagesList(messagesList,dialogNotificationsList);
}","protected List<CombinationMessage> buildCombinationMessagesListByDate(long createDate,boolean moreDate){
  if (dialog == null) {
    Log.d(""String_Node_Str"",""String_Node_Str"" + dialog);
    return new ArrayList<>();
  }
  List<Message> messagesList=dataManager.getMessageDataManager().getMessagesByDialogIdAndDate(dialog.getDialogId(),createDate,moreDate);
  List<DialogNotification> dialogNotificationsList=dataManager.getDialogNotificationDataManager().getDialogNotificationsByDialogIdAndDate(dialog.getDialogId(),createDate,moreDate);
  return ChatUtils.createCombinationMessagesList(messagesList,dialogNotificationsList);
}",0.984689766317486
113973,"private void processCombinationMessages(){
  QBUser currentUser=AppSession.getSession().getUser();
  for (  CombinationMessage cm : combinationMessagesList) {
    boolean ownMessage=!cm.isIncoming(currentUser.getId());
    if (!State.READ.equals(cm.getState()) && !ownMessage && isNetworkAvailable()) {
      cm.setState(State.READ);
      QBUpdateStatusMessageCommand.start(this,ChatUtils.createQBDialogFromLocalDialog(dataManager,dialog),cm,false);
    }
 else     if (ownMessage) {
      cm.setState(State.READ);
      dataManager.getMessageDataManager().update(cm.toMessage(),false);
    }
  }
}","private void processCombinationMessages(){
  if (combinationMessagesList == null) {
    return;
  }
  QBUser currentUser=AppSession.getSession().getUser();
  for (  CombinationMessage cm : combinationMessagesList) {
    boolean ownMessage=!cm.isIncoming(currentUser.getId());
    if (!State.READ.equals(cm.getState()) && !ownMessage && isNetworkAvailable()) {
      cm.setState(State.READ);
      QBUpdateStatusMessageCommand.start(this,ChatUtils.createQBDialogFromLocalDialog(dataManager,dialog),cm,false);
    }
 else     if (ownMessage) {
      cm.setState(State.READ);
      dataManager.getMessageDataManager().update(cm.toMessage(),false);
    }
  }
}",0.9545816733067728
113974,"private UserCustomData getUserCustomData(QBUser user){
  if (TextUtils.isEmpty(user.getCustomData())) {
    return new UserCustomData();
  }
  UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
  if (userCustomData != null) {
    return userCustomData;
  }
 else {
    return new UserCustomData();
  }
}","private UserCustomData getUserCustomData(String avatarUrl){
  String isImport=""String_Node_Str"";
  return new UserCustomData(avatarUrl,ConstsCore.EMPTY_STRING,isImport);
}",0.3592814371257485
113975,"@Override public void onNext(QBUser qbUser){
  QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
  performLoginSuccessAction(qbUser);
}","@Override public void onNext(QBUser qbUser){
  UserCustomData userCustomData=Utils.customDataToObject(qbUser.getCustomData());
  CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
  getTDUserWithFullName(qbUser);
  QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
  performLoginSuccessAction(qbUser);
}",0.6163522012578616
113976,"@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      UserCustomData userCustomData=Utils.customDataToObject(qbUser.getCustomData());
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getTDUserWithFullName(qbUser);
      QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.9121225777377197
113977,"@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getFBUserWithAvatar(qbUser);
      QBUpdateUserCommand.start(BaseAuthActivity.this,qbUser,null);
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.922068463219228
113978,"@Override public Observable<Void> call(Void qbVoid){
  authorized=true;
  notifyLogout(QMAuthService.this);
  return observable;
}","@Override public Observable<Void> call(Void qbVoid){
  authorized=false;
  notifyLogout(QMAuthService.this);
  return observable;
}",0.9731800766283524
113979,"private void saveChanges(){
  if (new ValidationUtils(this).isFullNameValid(fullNameTextInputLayout,oldFullName,currentFullName)) {
    showProgress();
    if (isNeedUpdateImage && imageUri != null) {
      QBUser newUser=createUserForUpdating();
      QBUpdateUserCommand.start(this,newUser,ImageUtils.getCreatedFileFromUri(imageUri));
    }
 else {
      QBUser newUser=createUserForUpdating();
      QBUpdateUserCommand.start(this,newUser,null);
    }
  }
}","private void saveChanges(){
  if (new ValidationUtils(this).isFullNameValid(fullNameTextInputLayout,oldFullName.trim(),currentFullName.trim())) {
    showProgress();
    if (isNeedUpdateImage && imageUri != null) {
      QBUser newUser=createUserForUpdating();
      QBUpdateUserCommand.start(this,newUser,ImageUtils.getCreatedFileFromUri(imageUri));
    }
 else {
      QBUser newUser=createUserForUpdating();
      QBUpdateUserCommand.start(this,newUser,null);
    }
  }
}",0.9850107066381156
113980,"protected void parseExceptionMessage(Exception exception){
  hideProgress();
  String errorMessage=exception.getMessage();
  if (errorMessage != null) {
    if (errorMessage.equals(getString(R.string.error_bad_timestamp))) {
      errorMessage=getString(R.string.error_bad_timestamp_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_login_or_email_required))) {
      errorMessage=getString(R.string.error_login_or_email_required_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_email_already_taken)) && loginType.equals(LoginType.FACEBOOK)) {
      errorMessage=getString(R.string.error_email_already_taken_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_unauthorized))) {
      errorMessage=getString(R.string.error_unauthorized_from_app);
    }
    ErrorUtils.showError(this,errorMessage);
  }
}","protected void parseExceptionMessage(Throwable exception){
  hideProgress();
  String errorMessage=exception.getMessage();
  if (errorMessage != null) {
    if (errorMessage.equals(getString(R.string.error_bad_timestamp))) {
      errorMessage=getString(R.string.error_bad_timestamp_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_login_or_email_required))) {
      errorMessage=getString(R.string.error_login_or_email_required_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_email_already_taken)) && loginType.equals(LoginType.FACEBOOK)) {
      errorMessage=getString(R.string.error_email_already_taken_from_app);
    }
 else     if (errorMessage.equals(getString(R.string.error_unauthorized))) {
      errorMessage=getString(R.string.error_unauthorized_from_app);
    }
    ErrorUtils.showError(this,errorMessage);
  }
}",0.9897610921501706
113981,"@Override public void onError(Throwable e){
  Log.d(TAG,""String_Node_Str"" + e.getMessage());
}","@Override public void onError(Throwable e){
  Log.d(TAG,""String_Node_Str"" + e.getMessage());
  parseExceptionMessage(e);
}",0.8703703703703703
113982,"@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getTDUserWithFullName(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void success(DigitsSession session,String phoneNumber){
  Log.d(TAG,""String_Node_Str"" + phoneNumber);
  showProgress();
  TwitterAuthConfig authConfig=TwitterCore.getInstance().getAuthConfig();
  TwitterAuthToken authToken=session.getAuthToken();
  DigitsOAuthSigning authSigning=new DigitsOAuthSigning(authConfig,authToken);
  Map<String,String> authHeaders=authSigning.getOAuthEchoHeadersForVerifyCredentials();
  authService.login(QBProvider.TWITTER_DIGITS,authHeaders.get(TwitterDigitsHelper.PROVIDER),authHeaders.get(TwitterDigitsHelper.CREDENTIALS)).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      UserCustomData userCustomData=Utils.customDataToObject(user.getCustomData());
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getTDUserWithFullName(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.9874902267396404
113983,"@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getFBUserWithAvatar(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}","@Override public void onSuccess(LoginResult loginResult){
  Log.d(TAG,""String_Node_Str"");
  showProgress();
  authService.login(QBProvider.FACEBOOK,loginResult.getAccessToken().getToken(),null).flatMap(new Func1<QBUser,Observable<QBUser>>(){
    @Override public Observable<QBUser> call(    final QBUser user){
      CoreSharedHelper.getInstance().saveUsersImportInitialized(false);
      getFBUserWithAvatar(user);
      return updateUserObservable(user);
    }
  }
).subscribeOn(Schedulers.io()).subscribe(new Observer<QBUser>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      Log.d(TAG,""String_Node_Str"" + e.getMessage());
      parseExceptionMessage(e);
    }
    @Override public void onNext(    QBUser qbUser){
      performLoginSuccessAction(qbUser);
    }
  }
);
}",0.9803439803439804
113984,"@Override public void onResult(Boolean aBoolean){
  if (isLoadedOldMessages) {
    messagesAdapter.addAllInBegin(sortedLoadedCombinationMessagesList);
  }
 else {
    messagesAdapter.addList(combinationMessagesList);
    scrollMessagesToBottom();
  }
  messageSwipeRefreshLayout.setRefreshing(false);
  hideActionBarProgress();
  isLoadingMessages=false;
}","@Override public void onResult(Boolean aBoolean){
  if (isLoadedOldMessages) {
    messagesAdapter.setList(combinationMessagesList,false);
    messagesAdapter.notifyItemRangeInserted(0,totalEntries);
  }
 else {
    messagesAdapter.setList(combinationMessagesList,true);
    scrollMessagesToBottom();
  }
  messageSwipeRefreshLayout.setRefreshing(false);
  hideActionBarProgress();
  isLoadingMessages=false;
}",0.6919060052219321
113985,"@Override public Boolean performInBackground(Void... params) throws Exception {
  boolean isFirstLoadingMessages=lastMessageDate == ConstsCore.ZERO_INT_VALUE;
  if (isFirstLoadingMessages) {
    combinationMessagesList=createCombinationMessagesList();
  }
 else   if (isLoadedOldMessages) {
    combinationMessagesList.addAll(0,sortedLoadedCombinationMessagesList);
  }
 else {
    combinationMessagesList.addAll(sortedLoadedCombinationMessagesList);
  }
  additionalActionsAfterLoadMessages();
  return isFirstLoadingMessages;
}","@Override public Boolean performInBackground(Void... params) throws Exception {
  combinationMessagesList=createCombinationMessagesList();
  additionalActionsAfterLoadMessages();
  return true;
}",0.5331491712707183
113986,"@Override public Bundle perform(Bundle extras) throws Exception {
  QBChatDialog dialog=(QBChatDialog)extras.getSerializable(QBServiceConsts.EXTRA_DIALOG);
  long lastDateLoad=extras.getLong(QBServiceConsts.EXTRA_DATE_LAST_UPDATE_HISTORY);
  boolean isLoadOldMessages=extras.getBoolean(QBServiceConsts.EXTRA_LOAD_MORE);
  Bundle returnedBundle=new Bundle();
  QBRequestGetBuilder customObjectRequestBuilder=new QBRequestGetBuilder();
  customObjectRequestBuilder.setLimit(ConstsCore.DIALOG_MESSAGES_PER_PAGE);
  if (isLoadOldMessages) {
    customObjectRequestBuilder.lt(Consts.MESSAGE_DATE_SENT,lastDateLoad);
    customObjectRequestBuilder.sortDesc(QBServiceConsts.EXTRA_DATE_SENT);
  }
 else {
    customObjectRequestBuilder.gt(Consts.MESSAGE_DATE_SENT,lastDateLoad);
    if (lastDateLoad > 0) {
      customObjectRequestBuilder.sortAsc(QBServiceConsts.EXTRA_DATE_SENT);
    }
 else {
      customObjectRequestBuilder.sortDesc(QBServiceConsts.EXTRA_DATE_SENT);
    }
  }
  List<QBChatMessage> dialogMessagesList=baseChatHelper.getDialogMessages(customObjectRequestBuilder,returnedBundle,dialog,lastDateLoad);
  Bundle bundleResult=new Bundle();
  bundleResult.putBoolean(QBServiceConsts.EXTRA_IS_LOAD_NEW_MESSAGES,isLoadOldMessages);
  bundleResult.putLong(QBServiceConsts.EXTRA_LAST_DATE_LOAD_MESSAGES,lastDateLoad);
  bundleResult.putSerializable(QBServiceConsts.EXTRA_DIALOG_MESSAGES,(java.io.Serializable)dialogMessagesList);
  bundleResult.putInt(QBServiceConsts.EXTRA_TOTAL_ENTRIES,dialogMessagesList != null ? dialogMessagesList.size() : ConstsCore.ZERO_INT_VALUE);
  return bundleResult;
}","@Override public Bundle perform(Bundle extras) throws Exception {
  QBChatDialog dialog=(QBChatDialog)extras.getSerializable(QBServiceConsts.EXTRA_DIALOG);
  long lastDateLoad=extras.getLong(QBServiceConsts.EXTRA_DATE_LAST_UPDATE_HISTORY);
  boolean isLoadOldMessages=extras.getBoolean(QBServiceConsts.EXTRA_LOAD_MORE);
  Bundle returnedBundle=new Bundle();
  QBRequestGetBuilder customObjectRequestBuilder=new QBRequestGetBuilder();
  customObjectRequestBuilder.setLimit(ConstsCore.DIALOG_MESSAGES_PER_PAGE);
  if (isLoadOldMessages) {
    customObjectRequestBuilder.lt(Consts.MESSAGE_DATE_SENT,lastDateLoad);
    customObjectRequestBuilder.sortDesc(QBServiceConsts.EXTRA_DATE_SENT);
  }
 else {
    customObjectRequestBuilder.gt(Consts.MESSAGE_DATE_SENT,lastDateLoad);
    if (lastDateLoad > 0) {
      customObjectRequestBuilder.sortAsc(QBServiceConsts.EXTRA_DATE_SENT);
    }
 else {
      customObjectRequestBuilder.sortDesc(QBServiceConsts.EXTRA_DATE_SENT);
    }
  }
  List<QBChatMessage> dialogMessagesList=baseChatHelper.getDialogMessages(customObjectRequestBuilder,returnedBundle,dialog,lastDateLoad);
  Bundle bundleResult=new Bundle();
  bundleResult.putBoolean(QBServiceConsts.EXTRA_IS_LOAD_OLD_MESSAGES,isLoadOldMessages);
  bundleResult.putLong(QBServiceConsts.EXTRA_LAST_DATE_LOAD_MESSAGES,lastDateLoad);
  bundleResult.putSerializable(QBServiceConsts.EXTRA_DIALOG_MESSAGES,(java.io.Serializable)dialogMessagesList);
  bundleResult.putInt(QBServiceConsts.EXTRA_TOTAL_ENTRIES,dialogMessagesList != null ? dialogMessagesList.size() : ConstsCore.ZERO_INT_VALUE);
  return bundleResult;
}",0.998125
113987,"@Override protected void updateMessagesList(){
  initActualExtras();
  checkForCorrectChat();
  int oldMessagesCount=messagesAdapter.getAllItems().size();
  this.combinationMessagesList=createCombinationMessagesList();
  Log.d(TAG,""String_Node_Str"" + combinationMessagesList);
  messagesAdapter.setList(combinationMessagesList);
  findLastFriendsRequest();
  checkForScrolling(oldMessagesCount);
}","@Override protected void updateMessagesList(){
  initActualExtras();
  checkForCorrectChat();
  final int oldMessagesCount=messagesAdapter.getAllItems().size();
  (new BaseAsyncTask<Void,Void,Boolean>(){
    @Override public Boolean performInBackground(    Void... params) throws Exception {
      combinationMessagesList=createCombinationMessagesList();
      return true;
    }
    @Override public void onResult(    Boolean aBoolean){
      messagesAdapter.setList(combinationMessagesList);
      findLastFriendsRequest();
      checkForScrolling(oldMessagesCount);
    }
    @Override public void onException(    Exception e){
      ErrorUtils.showError(PrivateDialogActivity.this,e);
    }
  }
).execute();
}",0.5567567567567567
113988,"@Override protected void updateMessagesList(){
  int oldMessagesCount=messagesAdapter.getAllItems().size();
  this.combinationMessagesList=createCombinationMessagesList();
  processCombinationMessages();
  messagesAdapter.setList(combinationMessagesList);
  checkForScrolling(oldMessagesCount);
}","@Override protected void updateMessagesList(){
  final int oldMessagesCount=messagesAdapter.getAllItems().size();
  (new BaseAsyncTask<Void,Void,Boolean>(){
    @Override public Boolean performInBackground(    Void... params) throws Exception {
      combinationMessagesList=createCombinationMessagesList();
      processCombinationMessages();
      return true;
    }
    @Override public void onResult(    Boolean aBoolean){
      messagesAdapter.setList(combinationMessagesList);
      checkForScrolling(oldMessagesCount);
    }
    @Override public void onException(    Exception e){
      ErrorUtils.showError(GroupDialogActivity.this,e);
    }
  }
).execute();
}",0.6078838174273858
113989,"private void initCrashlytics(){
  Crashlytics crashlyticsKit=new Crashlytics.Builder().core(new CrashlyticsCore.Builder().disabled(BuildConfig.DEBUG).build()).build();
  Fabric.with(this,crashlyticsKit);
}","private void initCrashlytics(){
  Crashlytics crashlyticsKit=new Crashlytics.Builder().core(new CrashlyticsCore.Builder().disabled(BuildConfig.DEBUG).build()).build();
  TwitterAuthConfig authConfig=new TwitterAuthConfig(StringObfuscator.getTwitterConsumerKey(),StringObfuscator.getTwitterConsumerSecret());
  Fabric.with(this,crashlyticsKit,new TwitterCore(authConfig),new Digits.Builder().withTheme(R.style.AppTheme).build());
}",0.6456692913385826
113990,"private void initFields(Bundle savedInstanceState){
  resources=getResources();
  if (savedInstanceState != null && savedInstanceState.containsKey(STARTED_LOGIN_TYPE)) {
    loginType=(LoginType)savedInstanceState.getSerializable(STARTED_LOGIN_TYPE);
  }
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper(this);
  twitterDigitsAuthCallback=new TwitterDigitsAuthCallback();
  loginSuccessAction=new LoginSuccessAction();
  socialLoginSuccessAction=new SocialLoginSuccessAction();
  failAction=new FailAction();
}","private void initFields(Bundle savedInstanceState){
  resources=getResources();
  if (savedInstanceState != null && savedInstanceState.containsKey(STARTED_LOGIN_TYPE)) {
    loginType=(LoginType)savedInstanceState.getSerializable(STARTED_LOGIN_TYPE);
  }
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper();
  twitterDigitsAuthCallback=new TwitterDigitsAuthCallback();
  loginSuccessAction=new LoginSuccessAction();
  socialLoginSuccessAction=new SocialLoginSuccessAction();
  failAction=new FailAction();
}",0.9963503649635036
113991,"private QBUser createUserForUpdating(){
  QBUser newUser=new QBUser();
  newUser.setId(qbUser.getId());
  newUser.setPassword(qbUser.getPassword());
  newUser.setOldPassword(qbUser.getOldPassword());
  qbUser.setFullName(currentFullName);
  newUser.setFullName(currentFullName);
  newUser.setCustomData(Utils.customDataToString(userCustomData));
  return newUser;
}","private QBUser createUserForUpdating(){
  QBUser newUser=new QBUser();
  newUser.setId(qbUser.getId());
  newUser.setPassword(qbUser.getPassword());
  newUser.setOldPassword(qbUser.getOldPassword());
  qbUser.setFullName(currentFullName);
  newUser.setFullName(currentFullName);
  newUser.setFacebookId(qbUser.getFacebookId());
  newUser.setTwitterId(qbUser.getTwitterId());
  newUser.setTwitterDigitsId(qbUser.getTwitterDigitsId());
  newUser.setCustomData(Utils.customDataToString(userCustomData));
  return newUser;
}",0.8248587570621468
113992,"private void initFields(){
  title=getString(R.string.settings_title);
  user=UserFriendUtils.createLocalUser(AppSession.getSession().getUser());
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper(this);
}","private void initFields(){
  title=getString(R.string.settings_title);
  user=UserFriendUtils.createLocalUser(AppSession.getSession().getUser());
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper();
}",0.991701244813278
113993,"public TwitterDigitsHelper(Context context){
  this.context=context;
  initTwitterDigits();
}","public TwitterDigitsHelper(){
}",0.5
113994,"public static AppSession load(){
  String loginTypeRaw=CoreSharedHelper.getInstance().getLoginType();
  String qbToken=CoreSharedHelper.getInstance().getQBToken();
  int userId=CoreSharedHelper.getInstance().getUserId();
  String userFullName=CoreSharedHelper.getInstance().getUserFullName();
  QBUser qbUser=new QBUser();
  qbUser.setId(userId);
  qbUser.setEmail(CoreSharedHelper.getInstance().getUserEmail());
  qbUser.setPassword(CoreSharedHelper.getInstance().getUserPassword());
  qbUser.setFullName(userFullName);
  LoginType loginType=LoginType.valueOf(loginTypeRaw);
  return new AppSession(loginType,qbUser,qbToken);
}","public static AppSession load(){
  String loginTypeRaw=CoreSharedHelper.getInstance().getLoginType();
  String qbToken=CoreSharedHelper.getInstance().getQBToken();
  int userId=CoreSharedHelper.getInstance().getUserId();
  String userFullName=CoreSharedHelper.getInstance().getUserFullName();
  QBUser qbUser=new QBUser();
  qbUser.setId(userId);
  qbUser.setEmail(CoreSharedHelper.getInstance().getUserEmail());
  qbUser.setPassword(CoreSharedHelper.getInstance().getUserPassword());
  qbUser.setFullName(userFullName);
  qbUser.setFacebookId(CoreSharedHelper.getInstance().getFBId());
  qbUser.setTwitterId(CoreSharedHelper.getInstance().getTwitterId());
  qbUser.setTwitterDigitsId(CoreSharedHelper.getInstance().getTwitterDigitsId());
  LoginType loginType=LoginType.valueOf(loginTypeRaw);
  return new AppSession(loginType,qbUser,qbToken);
}",0.8521031207598372
113995,"private void saveUser(QBUser user){
  coreSharedHelper.saveUserId(user.getId());
  coreSharedHelper.saveUserEmail(user.getEmail());
  coreSharedHelper.saveUserPassword(user.getPassword());
  coreSharedHelper.saveUserFullName(user.getFullName());
}","private void saveUser(QBUser user){
  coreSharedHelper.saveUserId(user.getId());
  coreSharedHelper.saveUserEmail(user.getEmail());
  coreSharedHelper.saveUserPassword(user.getPassword());
  coreSharedHelper.saveUserFullName(user.getFullName());
  coreSharedHelper.saveFBId(user.getFacebookId());
  coreSharedHelper.saveTwitterId(user.getTwitterId());
  coreSharedHelper.saveTwitterDigitsId(user.getTwitterDigitsId());
}",0.7406296851574213
113996,"@Override protected Bundle perform(Bundle extras) throws Exception {
  QBUser user=(QBUser)extras.getSerializable(QBServiceConsts.EXTRA_USER);
  File file=(File)extras.getSerializable(QBServiceConsts.EXTRA_FILE);
  int authorizationType=extras.getInt(QBServiceConsts.AUTH_ACTION_TYPE,ConstsCore.NOT_INITIALIZED_VALUE);
  Bundle result=new Bundle();
  if (isLoggedViaSocial(user,authorizationType)) {
    result.putSerializable(QBServiceConsts.EXTRA_USER,user);
    return result;
  }
  QBUser newUser=updateUser(user,file);
  result.putSerializable(QBServiceConsts.EXTRA_USER,newUser);
  return result;
}","@Override protected Bundle perform(Bundle extras) throws Exception {
  QBUser user=(QBUser)extras.getSerializable(QBServiceConsts.EXTRA_USER);
  File file=(File)extras.getSerializable(QBServiceConsts.EXTRA_FILE);
  Bundle result=new Bundle();
  QBUser newUser=updateUser(user,file);
  result.putSerializable(QBServiceConsts.EXTRA_USER,newUser);
  return result;
}",0.5604963805584281
113997,"public void clearUserData(){
  saveUserId(0);
  saveUserEmail(null);
  saveUserPassword(null);
  saveUserFullName(null);
}","public void clearUserData(){
  saveUserId(0);
  saveUserEmail(null);
  saveUserPassword(null);
  saveUserFullName(null);
  saveFBId(null);
  saveTwitterId(null);
  saveTwitterDigitsId(null);
}",0.7770700636942676
113998,"@Override public void onCreate(){
  super.onCreate();
  initCrashlytics();
  initApplication();
  registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());
}","@Override public void onCreate(){
  super.onCreate();
  initFabric();
  initApplication();
  registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());
}",0.9665653495440728
113999,"private void initFields(Bundle savedInstanceState){
  resources=getResources();
  if (savedInstanceState != null && savedInstanceState.containsKey(STARTED_LOGIN_TYPE)) {
    loginType=(LoginType)savedInstanceState.getSerializable(STARTED_LOGIN_TYPE);
  }
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper(this);
  twitterDigitsAuthCallback=new TwitterDigitsAuthCallback();
  loginSuccessAction=new LoginSuccessAction();
  socialLoginSuccessAction=new SocialLoginSuccessAction();
  failAction=new FailAction();
}","private void initFields(Bundle savedInstanceState){
  resources=getResources();
  if (savedInstanceState != null && savedInstanceState.containsKey(STARTED_LOGIN_TYPE)) {
    loginType=(LoginType)savedInstanceState.getSerializable(STARTED_LOGIN_TYPE);
  }
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper();
  twitterDigitsAuthCallback=new TwitterDigitsAuthCallback();
  loginSuccessAction=new LoginSuccessAction();
  socialLoginSuccessAction=new SocialLoginSuccessAction();
  failAction=new FailAction();
}",0.9963503649635036
114000,"private void initFields(){
  title=getString(R.string.settings_title);
  user=UserFriendUtils.createLocalUser(AppSession.getSession().getUser());
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper(this);
}","private void initFields(){
  title=getString(R.string.settings_title);
  user=UserFriendUtils.createLocalUser(AppSession.getSession().getUser());
  facebookHelper=new FacebookHelper(this);
  twitterDigitsHelper=new TwitterDigitsHelper();
}",0.991701244813278
