record_number,buggy_code,fixed_code,code_similarity
60001,"public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(ImmutableList.of(""String_Node_Str""));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
  create().addFirst(""String_Node_Str"");
  create().addLast(""String_Node_Str"");
  create().offerFirst(""String_Node_Str"");
  create().offerLast(""String_Node_Str"");
  create().removeFirst();
  create().removeLast();
  create().pollFirst();
  create().pollLast();
  create().getFirst();
  create().getLast();
  create().peekFirst();
  create().peekLast();
  create().removeFirstOccurrence(""String_Node_Str"");
  create().removeLastOccurrence(""String_Node_Str"");
  create().push(""String_Node_Str"");
  create().pop();
  create().descendingIterator();
}","public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(new ArrayDeque<>(ImmutableList.of(""String_Node_Str"")));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
  create().addFirst(""String_Node_Str"");
  create().addLast(""String_Node_Str"");
  create().offerFirst(""String_Node_Str"");
  create().offerLast(""String_Node_Str"");
  create().removeFirst();
  create().removeLast();
  create().pollFirst();
  create().pollLast();
  create().getFirst();
  create().getLast();
  create().peekFirst();
  create().peekLast();
  create().removeFirstOccurrence(""String_Node_Str"");
  create().removeLastOccurrence(""String_Node_Str"");
  create().push(""String_Node_Str"");
  create().pop();
  create().descendingIterator();
}",0.9930875576036866
60002,"public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(ImmutableList.of(""String_Node_Str""));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
}","public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(new ArrayDeque<>(ImmutableList.of(""String_Node_Str"")));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
}",0.9881266490765171
60003,"public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(ImmutableList.of(""String_Node_Str""));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
  create().addFirst(""String_Node_Str"");
  create().addLast(""String_Node_Str"");
  create().offerFirst(""String_Node_Str"");
  create().offerLast(""String_Node_Str"");
  create().removeFirst();
  create().removeLast();
  create().pollFirst();
  create().pollLast();
  create().getFirst();
  create().getLast();
  create().peekFirst();
  create().peekLast();
  create().removeFirstOccurrence(""String_Node_Str"");
  create().removeLastOccurrence(""String_Node_Str"");
  create().push(""String_Node_Str"");
  create().pop();
  create().descendingIterator();
}","public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(new ArrayDeque<>(ImmutableList.of(""String_Node_Str"")));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
  create().addFirst(""String_Node_Str"");
  create().addLast(""String_Node_Str"");
  create().offerFirst(""String_Node_Str"");
  create().offerLast(""String_Node_Str"");
  create().removeFirst();
  create().removeLast();
  create().pollFirst();
  create().pollLast();
  create().getFirst();
  create().getLast();
  create().peekFirst();
  create().peekLast();
  create().removeFirstOccurrence(""String_Node_Str"");
  create().removeLastOccurrence(""String_Node_Str"");
  create().push(""String_Node_Str"");
  create().pop();
  create().descendingIterator();
}",0.9930875576036866
60004,"public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(ImmutableList.of(""String_Node_Str""));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
}","public void testHoldsLockOnAllOperations(){
  create().element();
  create().offer(""String_Node_Str"");
  create().peek();
  create().poll();
  create().remove();
  create().add(""String_Node_Str"");
  create().addAll(ImmutableList.of(""String_Node_Str""));
  create().clear();
  create().contains(""String_Node_Str"");
  create().containsAll(ImmutableList.of(""String_Node_Str""));
  create().equals(new ArrayDeque<>(ImmutableList.of(""String_Node_Str"")));
  create().hashCode();
  create().isEmpty();
  create().iterator();
  create().remove(""String_Node_Str"");
  create().removeAll(ImmutableList.of(""String_Node_Str""));
  create().retainAll(ImmutableList.of(""String_Node_Str""));
  create().size();
  create().toArray();
  create().toArray(new String[]{""String_Node_Str""});
}",0.9881266490765171
60005,"private static <K,V>ImmutableSortedMap<K,V> fromEntries(final Comparator<? super K> comparator,boolean sameComparator,Entry<K,V>[] entryArray,int size){
switch (size) {
case 0:
    return emptyMap(comparator);
case 1:
  return ImmutableSortedMap.<K,V>of(comparator,entryArray[0].getKey(),entryArray[0].getValue());
default :
Object[] keys=new Object[size];
Object[] values=new Object[size];
if (sameComparator) {
for (int i=0; i < size; i++) {
Object key=entryArray[i].getKey();
Object value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
}
}
 else {
Arrays.sort(entryArray,0,size,new Comparator<Entry<K,V>>(){
@Override public int compare(Entry<K,V> e1,Entry<K,V> e2){
  return comparator.compare(e1.getKey(),e2.getKey());
}
}
);
K prevKey=entryArray[0].getKey();
keys[0]=prevKey;
values[0]=entryArray[0].getValue();
for (int i=1; i < size; i++) {
K key=entryArray[i].getKey();
V value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
checkNoConflict(comparator.compare(prevKey,key) != 0,""String_Node_Str"",entryArray[i - 1],entryArray[i]);
prevKey=key;
}
}
return new ImmutableSortedMap<>(new RegularImmutableSortedSet<K>(ImmutableList.<K>asImmutableList(keys),comparator),ImmutableList.<V>asImmutableList(values));
}
}","private static <K,V>ImmutableSortedMap<K,V> fromEntries(final Comparator<? super K> comparator,boolean sameComparator,Entry<K,V>[] entryArray,int size){
switch (size) {
case 0:
    return emptyMap(comparator);
case 1:
  return ImmutableSortedMap.<K,V>of(comparator,entryArray[0].getKey(),entryArray[0].getValue());
default :
Object[] keys=new Object[size];
Object[] values=new Object[size];
if (sameComparator) {
for (int i=0; i < size; i++) {
Object key=entryArray[i].getKey();
Object value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
}
}
 else {
Arrays.sort(entryArray,0,size,new Comparator<Entry<K,V>>(){
@Override public int compare(Entry<K,V> e1,Entry<K,V> e2){
  return comparator.compare(e1.getKey(),e2.getKey());
}
}
);
K prevKey=entryArray[0].getKey();
keys[0]=prevKey;
values[0]=entryArray[0].getValue();
checkEntryNotNull(keys[0],values[0]);
for (int i=1; i < size; i++) {
K key=entryArray[i].getKey();
V value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
checkNoConflict(comparator.compare(prevKey,key) != 0,""String_Node_Str"",entryArray[i - 1],entryArray[i]);
prevKey=key;
}
}
return new ImmutableSortedMap<>(new RegularImmutableSortedSet<K>(ImmutableList.<K>asImmutableList(keys),comparator),ImmutableList.<V>asImmutableList(values));
}
}",0.9855513307984792
60006,"private static <K,V>ImmutableSortedMap<K,V> fromEntries(final Comparator<? super K> comparator,boolean sameComparator,Entry<K,V>[] entryArray,int size){
switch (size) {
case 0:
    return emptyMap(comparator);
case 1:
  return ImmutableSortedMap.<K,V>of(comparator,entryArray[0].getKey(),entryArray[0].getValue());
default :
Object[] keys=new Object[size];
Object[] values=new Object[size];
if (sameComparator) {
for (int i=0; i < size; i++) {
Object key=entryArray[i].getKey();
Object value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
}
}
 else {
Arrays.sort(entryArray,0,size,new Comparator<Entry<K,V>>(){
@Override public int compare(Entry<K,V> e1,Entry<K,V> e2){
  return comparator.compare(e1.getKey(),e2.getKey());
}
}
);
K prevKey=entryArray[0].getKey();
keys[0]=prevKey;
values[0]=entryArray[0].getValue();
for (int i=1; i < size; i++) {
K key=entryArray[i].getKey();
V value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
checkNoConflict(comparator.compare(prevKey,key) != 0,""String_Node_Str"",entryArray[i - 1],entryArray[i]);
prevKey=key;
}
}
return new ImmutableSortedMap<>(new RegularImmutableSortedSet<K>(new RegularImmutableList<K>(keys),comparator),new RegularImmutableList<V>(values));
}
}","private static <K,V>ImmutableSortedMap<K,V> fromEntries(final Comparator<? super K> comparator,boolean sameComparator,Entry<K,V>[] entryArray,int size){
switch (size) {
case 0:
    return emptyMap(comparator);
case 1:
  return ImmutableSortedMap.<K,V>of(comparator,entryArray[0].getKey(),entryArray[0].getValue());
default :
Object[] keys=new Object[size];
Object[] values=new Object[size];
if (sameComparator) {
for (int i=0; i < size; i++) {
Object key=entryArray[i].getKey();
Object value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
}
}
 else {
Arrays.sort(entryArray,0,size,new Comparator<Entry<K,V>>(){
@Override public int compare(Entry<K,V> e1,Entry<K,V> e2){
  return comparator.compare(e1.getKey(),e2.getKey());
}
}
);
K prevKey=entryArray[0].getKey();
keys[0]=prevKey;
values[0]=entryArray[0].getValue();
checkEntryNotNull(keys[0],values[0]);
for (int i=1; i < size; i++) {
K key=entryArray[i].getKey();
V value=entryArray[i].getValue();
checkEntryNotNull(key,value);
keys[i]=key;
values[i]=value;
checkNoConflict(comparator.compare(prevKey,key) != 0,""String_Node_Str"",entryArray[i - 1],entryArray[i]);
prevKey=key;
}
}
return new ImmutableSortedMap<>(new RegularImmutableSortedSet<K>(new RegularImmutableList<K>(keys),comparator),new RegularImmutableList<V>(values));
}
}",0.98544061302682
60007,"@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRemoveAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.removeAll(null);
  }
 catch (  NullPointerException expected) {
  }
}","@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRemoveAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.removeAll(null);
  }
 catch (  NullPointerException tolerated) {
  }
}",0.976241900647948
60008,"@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRetainAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.retainAll(null);
  }
 catch (  NullPointerException expected) {
  }
}","@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRetainAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.retainAll(null);
  }
 catch (  NullPointerException tolerated) {
  }
}",0.976241900647948
60009,"@Override public <E>E[] toArray(E[] a){
  return toArrayList(this).toArray(a);
}","@Override public <T>T[] toArray(T[] a){
  return toArrayList(this).toArray(a);
}",0.9625
60010,"private static long hashLength65Plus(byte[] bytes,int offset,int length){
  final int seed=81;
  long x=seed;
  @SuppressWarnings(""String_Node_Str"") long y=seed * K1 + 113;
  long z=shiftMix(y * K2 + 113) * K2;
  long[] v=new long[2], w=new long[2];
  x=x * K2 + load64(bytes,offset);
  int end=offset + ((length - 1) / 64) * 64;
  int last64offset=end + ((length - 1) & 63) - 63;
  do {
    x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * K1;
    y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * K1;
    x^=w[1];
    y+=v[0] + load64(bytes,offset + 40);
    z=rotateRight(z + w[0],33) * K1;
    weakHashLength32WithSeeds(bytes,offset,v[1] * K1,x + w[0],v);
    weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
    long tmp=x;
    x=z;
    z=tmp;
    offset+=64;
  }
 while (offset != end);
  long mul=K1 + ((z & 0xFF) << 1);
  offset=last64offset;
  w[0]+=((length - 1) & 63);
  v[0]+=w[0];
  w[0]+=v[0];
  x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * mul;
  y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * mul;
  x^=w[1] * 9;
  y+=v[0] * 9 + load64(bytes,offset + 40);
  z=rotateRight(z + w[0],33) * mul;
  weakHashLength32WithSeeds(bytes,offset,v[1] * mul,x + w[0],v);
  weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
  return hashLength16(hashLength16(v[0],w[0],mul) + shiftMix(y) * K0 + x,hashLength16(v[1],w[1],mul) + z,mul);
}","private static long hashLength65Plus(byte[] bytes,int offset,int length){
  final int seed=81;
  long x=seed;
  @SuppressWarnings(""String_Node_Str"") long y=seed * K1 + 113;
  long z=shiftMix(y * K2 + 113) * K2;
  long[] v=new long[2];
  long[] w=new long[2];
  x=x * K2 + load64(bytes,offset);
  int end=offset + ((length - 1) / 64) * 64;
  int last64offset=end + ((length - 1) & 63) - 63;
  do {
    x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * K1;
    y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * K1;
    x^=w[1];
    y+=v[0] + load64(bytes,offset + 40);
    z=rotateRight(z + w[0],33) * K1;
    weakHashLength32WithSeeds(bytes,offset,v[1] * K1,x + w[0],v);
    weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
    long tmp=x;
    x=z;
    z=tmp;
    offset+=64;
  }
 while (offset != end);
  long mul=K1 + ((z & 0xFF) << 1);
  offset=last64offset;
  w[0]+=((length - 1) & 63);
  v[0]+=w[0];
  w[0]+=v[0];
  x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * mul;
  y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * mul;
  x^=w[1] * 9;
  y+=v[0] * 9 + load64(bytes,offset + 40);
  z=rotateRight(z + w[0],33) * mul;
  weakHashLength32WithSeeds(bytes,offset,v[1] * mul,x + w[0],v);
  weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
  return hashLength16(hashLength16(v[0],w[0],mul) + shiftMix(y) * K0 + x,hashLength16(v[1],w[1],mul) + z,mul);
}",0.9962264150943396
60011,"private static ThreadFactory build(ThreadFactoryBuilder builder){
  final String nameFormat=builder.nameFormat;
  final Boolean daemon=builder.daemon;
  final Integer priority=builder.priority;
  final UncaughtExceptionHandler uncaughtExceptionHandler=builder.uncaughtExceptionHandler;
  final ThreadFactory backingThreadFactory=(builder.backingThreadFactory != null) ? builder.backingThreadFactory : Executors.defaultThreadFactory();
  final AtomicLong count=(nameFormat != null) ? new AtomicLong(0) : null;
  return new ThreadFactory(){
    @Override public Thread newThread(    Runnable runnable){
      Thread thread=backingThreadFactory.newThread(runnable);
      if (nameFormat != null) {
        thread.setName(format(nameFormat,count.getAndIncrement()));
      }
      if (daemon != null) {
        thread.setDaemon(daemon);
      }
      if (priority != null) {
        thread.setPriority(priority);
      }
      if (uncaughtExceptionHandler != null) {
        thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      return thread;
    }
  }
;
}","/** 
 * Returns a new thread factory using the options supplied during the building process. After building, it is still possible to change the options used to build the ThreadFactory and/or build again. State is not shared amongst built instances.
 * @return the fully constructed {@link ThreadFactory}
 */
@CheckReturnValue public ThreadFactory build(){
  return doBuild(this);
}",0.0563186813186813
60012,"@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRemoveAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.removeAll(null);
  }
 catch (  NullPointerException expected) {
  }
}","@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRemoveAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.removeAll(null);
  }
 catch (  NullPointerException tolerated) {
  }
}",0.976241900647948
60013,"@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRetainAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.retainAll(null);
  }
 catch (  NullPointerException expected) {
  }
}","@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRetainAll_nullCollectionReferenceEmptySubject(){
  try {
    collection.retainAll(null);
  }
 catch (  NullPointerException tolerated) {
  }
}",0.976241900647948
60014,"@Override public <E>E[] toArray(E[] a){
  return toArrayList(this).toArray(a);
}","@Override public <T>T[] toArray(T[] a){
  return toArrayList(this).toArray(a);
}",0.9625
60015,"private static long hashLength65Plus(byte[] bytes,int offset,int length){
  final int seed=81;
  long x=seed;
  @SuppressWarnings(""String_Node_Str"") long y=seed * K1 + 113;
  long z=shiftMix(y * K2 + 113) * K2;
  long[] v=new long[2], w=new long[2];
  x=x * K2 + load64(bytes,offset);
  int end=offset + ((length - 1) / 64) * 64;
  int last64offset=end + ((length - 1) & 63) - 63;
  do {
    x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * K1;
    y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * K1;
    x^=w[1];
    y+=v[0] + load64(bytes,offset + 40);
    z=rotateRight(z + w[0],33) * K1;
    weakHashLength32WithSeeds(bytes,offset,v[1] * K1,x + w[0],v);
    weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
    long tmp=x;
    x=z;
    z=tmp;
    offset+=64;
  }
 while (offset != end);
  long mul=K1 + ((z & 0xFF) << 1);
  offset=last64offset;
  w[0]+=((length - 1) & 63);
  v[0]+=w[0];
  w[0]+=v[0];
  x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * mul;
  y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * mul;
  x^=w[1] * 9;
  y+=v[0] * 9 + load64(bytes,offset + 40);
  z=rotateRight(z + w[0],33) * mul;
  weakHashLength32WithSeeds(bytes,offset,v[1] * mul,x + w[0],v);
  weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
  return hashLength16(hashLength16(v[0],w[0],mul) + shiftMix(y) * K0 + x,hashLength16(v[1],w[1],mul) + z,mul);
}","private static long hashLength65Plus(byte[] bytes,int offset,int length){
  final int seed=81;
  long x=seed;
  @SuppressWarnings(""String_Node_Str"") long y=seed * K1 + 113;
  long z=shiftMix(y * K2 + 113) * K2;
  long[] v=new long[2];
  long[] w=new long[2];
  x=x * K2 + load64(bytes,offset);
  int end=offset + ((length - 1) / 64) * 64;
  int last64offset=end + ((length - 1) & 63) - 63;
  do {
    x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * K1;
    y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * K1;
    x^=w[1];
    y+=v[0] + load64(bytes,offset + 40);
    z=rotateRight(z + w[0],33) * K1;
    weakHashLength32WithSeeds(bytes,offset,v[1] * K1,x + w[0],v);
    weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
    long tmp=x;
    x=z;
    z=tmp;
    offset+=64;
  }
 while (offset != end);
  long mul=K1 + ((z & 0xFF) << 1);
  offset=last64offset;
  w[0]+=((length - 1) & 63);
  v[0]+=w[0];
  w[0]+=v[0];
  x=rotateRight(x + y + v[0]+ load64(bytes,offset + 8),37) * mul;
  y=rotateRight(y + v[1] + load64(bytes,offset + 48),42) * mul;
  x^=w[1] * 9;
  y+=v[0] * 9 + load64(bytes,offset + 40);
  z=rotateRight(z + w[0],33) * mul;
  weakHashLength32WithSeeds(bytes,offset,v[1] * mul,x + w[0],v);
  weakHashLength32WithSeeds(bytes,offset + 32,z + w[1],y + load64(bytes,offset + 16),w);
  return hashLength16(hashLength16(v[0],w[0],mul) + shiftMix(y) * K0 + x,hashLength16(v[1],w[1],mul) + z,mul);
}",0.9962264150943396
60016,"private static ThreadFactory build(ThreadFactoryBuilder builder){
  final String nameFormat=builder.nameFormat;
  final Boolean daemon=builder.daemon;
  final Integer priority=builder.priority;
  final UncaughtExceptionHandler uncaughtExceptionHandler=builder.uncaughtExceptionHandler;
  final ThreadFactory backingThreadFactory=(builder.backingThreadFactory != null) ? builder.backingThreadFactory : Executors.defaultThreadFactory();
  final AtomicLong count=(nameFormat != null) ? new AtomicLong(0) : null;
  return new ThreadFactory(){
    @Override public Thread newThread(    Runnable runnable){
      Thread thread=backingThreadFactory.newThread(runnable);
      if (nameFormat != null) {
        thread.setName(format(nameFormat,count.getAndIncrement()));
      }
      if (daemon != null) {
        thread.setDaemon(daemon);
      }
      if (priority != null) {
        thread.setPriority(priority);
      }
      if (uncaughtExceptionHandler != null) {
        thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      return thread;
    }
  }
;
}","/** 
 * Returns a new thread factory using the options supplied during the building process. After building, it is still possible to change the options used to build the ThreadFactory and/or build again. State is not shared amongst built instances.
 * @return the fully constructed {@link ThreadFactory}
 */
@CheckReturnValue public ThreadFactory build(){
  return doBuild(this);
}",0.0563186813186813
60017,"@Override public final void run(){
  if (isDone()) {
    return;
  }
  Thread currentThread=Thread.currentThread();
  if (!compareAndSet(null,currentThread)) {
    return;
  }
  T result=null;
  Throwable error=null;
  try {
    result=runInterruptibly();
  }
 catch (  Throwable t) {
    error=t;
  }
 finally {
    if (!compareAndSet(currentThread,DONE)) {
      while (get() == INTERRUPTING) {
        Thread.yield();
      }
    }
    afterRanInterruptibly(result,error);
  }
}","@Override public final void run(){
  Thread currentThread=Thread.currentThread();
  if (!compareAndSet(null,currentThread)) {
    return;
  }
  boolean run=!isDone();
  T result=null;
  Throwable error=null;
  try {
    if (run) {
      result=runInterruptibly();
    }
  }
 catch (  Throwable t) {
    error=t;
  }
 finally {
    if (!compareAndSet(currentThread,DONE)) {
      while (get() == INTERRUPTING) {
        Thread.yield();
      }
    }
    if (run) {
      afterRanInterruptibly(result,error);
    }
  }
}",0.5445445445445446
60018,"@Override public final void run(){
  if (isDone()) {
    return;
  }
  Thread currentThread=Thread.currentThread();
  if (!compareAndSet(null,currentThread)) {
    return;
  }
  T result=null;
  Throwable error=null;
  try {
    result=runInterruptibly();
  }
 catch (  Throwable t) {
    error=t;
  }
 finally {
    if (!compareAndSet(currentThread,DONE)) {
      while (get() == INTERRUPTING) {
        Thread.yield();
      }
    }
    afterRanInterruptibly(result,error);
  }
}","@Override public final void run(){
  Thread currentThread=Thread.currentThread();
  if (!compareAndSet(null,currentThread)) {
    return;
  }
  boolean run=!isDone();
  T result=null;
  Throwable error=null;
  try {
    if (run) {
      result=runInterruptibly();
    }
  }
 catch (  Throwable t) {
    error=t;
  }
 finally {
    if (!compareAndSet(currentThread,DONE)) {
      while (get() == INTERRUPTING) {
        Thread.yield();
      }
    }
    if (run) {
      afterRanInterruptibly(result,error);
    }
  }
}",0.5445445445445446
60019,"@GwtIncompatible public void testSetFutureDelegateLaterInterrupted() throws Exception {
  assertThat(future.setFuture(delegate)).isTrue();
  delegate.cancel(true);
  assertCancelled(future,delegate instanceof TrustedFuture);
}","public void testSetFutureDelegateLaterInterrupted() throws Exception {
  assertThat(future.setFuture(delegate)).isTrue();
  delegate.cancel(true);
  assertCancelled(future,false);
}",0.8796068796068796
60020,"@GwtIncompatible public void testSetFutureDelegateAlreadyInterrupted() throws Exception {
  delegate.cancel(true);
  assertThat(future.setFuture(delegate)).isTrue();
  assertCancelled(future,delegate instanceof TrustedFuture);
}","public void testSetFutureDelegateAlreadyInterrupted() throws Exception {
  delegate.cancel(true);
  assertThat(future.setFuture(delegate)).isTrue();
  assertCancelled(future,false);
}",0.8807785888077859
60021,"/** 
 * {@inheritDoc}<p>If a cancellation attempt succeeds on a   {@code Future} that had previously been {@linkplain #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate  {@code Future} that was supplied in the {@code setFuture} call.<p>Rather than override this method to perform additional cancellation work or cleanup, subclasses should override  {@link #afterDone}, consulting   {@link #isCancelled} and {@link #wasInterrupted} as necessary. This ensures that the work is done even if the future iscancelled without a call to  {@code cancel}, such as by calling   {@code setFuture(cancelledFuture)}.
 */
@CanIgnoreReturnValue @Override public boolean cancel(boolean mayInterruptIfRunning){
  Object localValue=value;
  boolean rValue=false;
  if (localValue == null | localValue instanceof SetFuture) {
    Throwable cause=GENERATE_CANCELLATION_CAUSES ? new CancellationException(""String_Node_Str"") : null;
    Object valueToSet=new Cancellation(mayInterruptIfRunning,cause);
    AbstractFuture<?> abstractFuture=this;
    while (true) {
      if (ATOMIC_HELPER.casValue(abstractFuture,localValue,valueToSet)) {
        rValue=true;
        if (mayInterruptIfRunning) {
          abstractFuture.interruptTask();
        }
        complete(abstractFuture);
        if (localValue instanceof SetFuture) {
          ListenableFuture<?> futureToPropagateTo=((SetFuture)localValue).future;
          if (futureToPropagateTo instanceof TrustedFuture) {
            AbstractFuture<?> trusted=(AbstractFuture<?>)futureToPropagateTo;
            localValue=trusted.value;
            if (localValue == null | localValue instanceof SetFuture) {
              abstractFuture=trusted;
              continue;
            }
          }
 else {
            futureToPropagateTo.cancel(mayInterruptIfRunning);
          }
        }
        break;
      }
      localValue=abstractFuture.value;
      if (!(localValue instanceof SetFuture)) {
        break;
      }
    }
  }
  return rValue;
}","/** 
 * {@inheritDoc}<p>If a cancellation attempt succeeds on a   {@code Future} that had previously been {@linkplain #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate  {@code Future} that was supplied in the {@code setFuture} call.<p>Rather than override this method to perform additional cancellation work or cleanup, subclasses should override  {@link #afterDone}, consulting   {@link #isCancelled} and {@link #wasInterrupted} as necessary. This ensures that the work is done even if the future iscancelled without a call to  {@code cancel}, such as by calling   {@code setFuture(cancelledFuture)}.
 */
@CanIgnoreReturnValue @Override public boolean cancel(boolean mayInterruptIfRunning){
  Object localValue=value;
  boolean rValue=false;
  if (localValue == null | localValue instanceof SetFuture) {
    Object valueToSet=GENERATE_CANCELLATION_CAUSES ? new Cancellation(mayInterruptIfRunning,new CancellationException(""String_Node_Str"")) : (mayInterruptIfRunning ? Cancellation.CAUSELESS_INTERRUPTED : Cancellation.CAUSELESS_CANCELLED);
    AbstractFuture<?> abstractFuture=this;
    while (true) {
      if (ATOMIC_HELPER.casValue(abstractFuture,localValue,valueToSet)) {
        rValue=true;
        if (mayInterruptIfRunning) {
          abstractFuture.interruptTask();
        }
        complete(abstractFuture);
        if (localValue instanceof SetFuture) {
          ListenableFuture<?> futureToPropagateTo=((SetFuture)localValue).future;
          if (futureToPropagateTo instanceof TrustedFuture) {
            AbstractFuture<?> trusted=(AbstractFuture<?>)futureToPropagateTo;
            localValue=trusted.value;
            if (localValue == null | localValue instanceof SetFuture) {
              abstractFuture=trusted;
              continue;
            }
          }
 else {
            futureToPropagateTo.cancel(mayInterruptIfRunning);
          }
        }
        break;
      }
      localValue=abstractFuture.value;
      if (!(localValue instanceof SetFuture)) {
        break;
      }
    }
  }
  return rValue;
}",0.9532846715328468
60022,"/** 
 * Returns a value, suitable for storing in the   {@link #value} field. From the given future,which is assumed to be done. <p>This is approximately the inverse of  {@link #getDoneValue(Object)}
 */
private static Object getFutureValue(ListenableFuture<?> future){
  Object valueToSet;
  if (future instanceof TrustedFuture) {
    return ((AbstractFuture<?>)future).value;
  }
 else {
    try {
      Object v=getDone(future);
      valueToSet=v == null ? NULL : v;
    }
 catch (    ExecutionException exception) {
      valueToSet=new Failure(exception.getCause());
    }
catch (    CancellationException cancellation) {
      valueToSet=new Cancellation(false,cancellation);
    }
catch (    Throwable t) {
      valueToSet=new Failure(t);
    }
  }
  return valueToSet;
}","/** 
 * Returns a value that satisfies the contract of the   {@link #value} field based on the state ofgiven future. <p>This is approximately the inverse of  {@link #getDoneValue(Object)}
 */
private static Object getFutureValue(ListenableFuture<?> future){
  Object valueToSet;
  if (future instanceof TrustedFuture) {
    Object v=((AbstractFuture<?>)future).value;
    if (v instanceof Cancellation) {
      Cancellation c=(Cancellation)v;
      if (c.wasInterrupted) {
        v=c.cause != null ? new Cancellation(false,c.cause) : Cancellation.CAUSELESS_CANCELLED;
      }
    }
    return v;
  }
 else {
    try {
      Object v=getDone(future);
      valueToSet=v == null ? NULL : v;
    }
 catch (    ExecutionException exception) {
      valueToSet=new Failure(exception.getCause());
    }
catch (    CancellationException cancellation) {
      valueToSet=new Cancellation(false,cancellation);
    }
catch (    Throwable t) {
      valueToSet=new Failure(t);
    }
  }
  return valueToSet;
}",0.7559055118110236
60023,"/** 
 * Sets the result of this   {@code Future} to match the supplied input {@code Future} once thesupplied  {@code Future} is done, unless this {@code Future} has already been cancelled or set(including ""set asynchronously,"" defined below). <p>If the supplied future is  {@linkplain #isDone done} when this method is called and the callis accepted, then this future is guaranteed to have been completed with the supplied future by the time this method returns. If the supplied future is not done and the call is accepted, then the future will be <i>set asynchronously</i>. Note that such a result, though not yet known, cannot be overridden by a call to a  {@code set*} method, only by a call to {@link #cancel}. <p>If the call   {@code setFuture(delegate)} is accepted and this {@code Future} is latercancelled, cancellation will be propagated to  {@code delegate}. Additionally, any call to  {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code Future}.
 * @param future the future to delegate to
 * @return true if the attempt was accepted, indicating that the {@code Future} was not previouslycancelled or set.
 * @since 19.0
 */
@Beta @CanIgnoreReturnValue protected boolean setFuture(ListenableFuture<? extends V> future){
  checkNotNull(future);
  Object localValue=value;
  if (localValue == null) {
    if (future.isDone()) {
      Object value=getFutureValue(future);
      if (ATOMIC_HELPER.casValue(this,null,value)) {
        complete(this);
        return true;
      }
      return false;
    }
    SetFuture valueToSet=new SetFuture<V>(this,future);
    if (ATOMIC_HELPER.casValue(this,null,valueToSet)) {
      try {
        future.addListener(valueToSet,directExecutor());
      }
 catch (      Throwable t) {
        Failure failure;
        try {
          failure=new Failure(t);
        }
 catch (        Throwable oomMostLikely) {
          failure=Failure.FALLBACK_INSTANCE;
        }
        boolean unused=ATOMIC_HELPER.casValue(this,valueToSet,failure);
      }
      return true;
    }
    localValue=value;
  }
  if (localValue instanceof Cancellation) {
    future.cancel(((Cancellation)localValue).wasInterrupted);
  }
  return false;
}","/** 
 * Sets the result of this   {@code Future} to match the supplied input {@code Future} once thesupplied  {@code Future} is done, unless this {@code Future} has already been cancelled or set(including ""set asynchronously,"" defined below). <p>If the supplied future is  {@linkplain #isDone done} when this method is called and the callis accepted, then this future is guaranteed to have been completed with the supplied future by the time this method returns. If the supplied future is not done and the call is accepted, then the future will be <i>set asynchronously</i>. Note that such a result, though not yet known, cannot be overridden by a call to a  {@code set*} method, only by a call to {@link #cancel}. <p>If the call   {@code setFuture(delegate)} is accepted and this {@code Future} is latercancelled, cancellation will be propagated to  {@code delegate}. Additionally, any call to  {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code Future}. <p>Note that, even if the supplied future is cancelled and it causes this future to complete, it will never trigger interruption behavior. In particular, it will not cause this future to invoke the   {@link #interruptTask} method, and the {@link #wasInterrupted} method will notreturn  {@code true}.
 * @param future the future to delegate to
 * @return true if the attempt was accepted, indicating that the {@code Future} was not previouslycancelled or set.
 * @since 19.0
 */
@Beta @CanIgnoreReturnValue protected boolean setFuture(ListenableFuture<? extends V> future){
  checkNotNull(future);
  Object localValue=value;
  if (localValue == null) {
    if (future.isDone()) {
      Object value=getFutureValue(future);
      if (ATOMIC_HELPER.casValue(this,null,value)) {
        complete(this);
        return true;
      }
      return false;
    }
    SetFuture valueToSet=new SetFuture<V>(this,future);
    if (ATOMIC_HELPER.casValue(this,null,valueToSet)) {
      try {
        future.addListener(valueToSet,directExecutor());
      }
 catch (      Throwable t) {
        Failure failure;
        try {
          failure=new Failure(t);
        }
 catch (        Throwable oomMostLikely) {
          failure=Failure.FALLBACK_INSTANCE;
        }
        boolean unused=ATOMIC_HELPER.casValue(this,valueToSet,failure);
      }
      return true;
    }
    localValue=value;
  }
  if (localValue instanceof Cancellation) {
    future.cancel(((Cancellation)localValue).wasInterrupted);
  }
  return false;
}",0.9363867684478372
60024,"@Override public void run(){
  if (isCancelled()) {
    return;
  }
  if (delegate instanceof AbstractFuture) {
    AbstractFuture<? extends V> other=(AbstractFuture<? extends V>)delegate;
    value=other.value;
    throwable=other.throwable;
    mayInterruptIfRunning=other.mayInterruptIfRunning;
    state=other.state;
    notifyAndClearListeners();
    return;
  }
  try {
    forceSet(getDone(delegate));
  }
 catch (  ExecutionException exception) {
    forceSetException(exception.getCause());
  }
catch (  CancellationException cancellation) {
    cancel(false);
  }
catch (  Throwable t) {
    forceSetException(t);
  }
}","@Override public void run(){
  if (isCancelled()) {
    return;
  }
  if (delegate instanceof AbstractFuture) {
    AbstractFuture<? extends V> other=(AbstractFuture<? extends V>)delegate;
    value=other.value;
    throwable=other.throwable;
    state=other.state;
    notifyAndClearListeners();
    return;
  }
  try {
    forceSet(getDone(delegate));
  }
 catch (  ExecutionException exception) {
    forceSetException(exception.getCause());
  }
catch (  CancellationException cancellation) {
    cancel(false);
  }
catch (  Throwable t) {
    forceSetException(t);
  }
}",0.9542809642560266
60025,"@GwtIncompatible public void testSetFutureDelegateLaterInterrupted() throws Exception {
  assertThat(future.setFuture(delegate)).isTrue();
  delegate.cancel(true);
  assertCancelled(future,delegate instanceof TrustedFuture);
}","public void testSetFutureDelegateLaterInterrupted() throws Exception {
  assertThat(future.setFuture(delegate)).isTrue();
  delegate.cancel(true);
  assertCancelled(future,false);
}",0.8796068796068796
60026,"@GwtIncompatible public void testSetFutureDelegateAlreadyInterrupted() throws Exception {
  delegate.cancel(true);
  assertThat(future.setFuture(delegate)).isTrue();
  assertCancelled(future,delegate instanceof TrustedFuture);
}","public void testSetFutureDelegateAlreadyInterrupted() throws Exception {
  delegate.cancel(true);
  assertThat(future.setFuture(delegate)).isTrue();
  assertCancelled(future,false);
}",0.8807785888077859
60027,"/** 
 * {@inheritDoc}<p>If a cancellation attempt succeeds on a   {@code Future} that had previously been {@linkplain #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate  {@code Future} that was supplied in the {@code setFuture} call.<p>Rather than override this method to perform additional cancellation work or cleanup, subclasses should override  {@link #afterDone}, consulting   {@link #isCancelled} and {@link #wasInterrupted} as necessary. This ensures that the work is done even if the future iscancelled without a call to  {@code cancel}, such as by calling   {@code setFuture(cancelledFuture)}.
 */
@CanIgnoreReturnValue @Override public boolean cancel(boolean mayInterruptIfRunning){
  Object localValue=value;
  boolean rValue=false;
  if (localValue == null | localValue instanceof SetFuture) {
    Throwable cause=GENERATE_CANCELLATION_CAUSES ? new CancellationException(""String_Node_Str"") : null;
    Object valueToSet=new Cancellation(mayInterruptIfRunning,cause);
    AbstractFuture<?> abstractFuture=this;
    while (true) {
      if (ATOMIC_HELPER.casValue(abstractFuture,localValue,valueToSet)) {
        rValue=true;
        if (mayInterruptIfRunning) {
          abstractFuture.interruptTask();
        }
        complete(abstractFuture);
        if (localValue instanceof SetFuture) {
          ListenableFuture<?> futureToPropagateTo=((SetFuture)localValue).future;
          if (futureToPropagateTo instanceof TrustedFuture) {
            AbstractFuture<?> trusted=(AbstractFuture<?>)futureToPropagateTo;
            localValue=trusted.value;
            if (localValue == null | localValue instanceof SetFuture) {
              abstractFuture=trusted;
              continue;
            }
          }
 else {
            futureToPropagateTo.cancel(mayInterruptIfRunning);
          }
        }
        break;
      }
      localValue=abstractFuture.value;
      if (!(localValue instanceof SetFuture)) {
        break;
      }
    }
  }
  return rValue;
}","/** 
 * {@inheritDoc}<p>If a cancellation attempt succeeds on a   {@code Future} that had previously been {@linkplain #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate  {@code Future} that was supplied in the {@code setFuture} call.<p>Rather than override this method to perform additional cancellation work or cleanup, subclasses should override  {@link #afterDone}, consulting   {@link #isCancelled} and {@link #wasInterrupted} as necessary. This ensures that the work is done even if the future iscancelled without a call to  {@code cancel}, such as by calling   {@code setFuture(cancelledFuture)}.
 */
@CanIgnoreReturnValue @Override public boolean cancel(boolean mayInterruptIfRunning){
  Object localValue=value;
  boolean rValue=false;
  if (localValue == null | localValue instanceof SetFuture) {
    Object valueToSet=GENERATE_CANCELLATION_CAUSES ? new Cancellation(mayInterruptIfRunning,new CancellationException(""String_Node_Str"")) : (mayInterruptIfRunning ? Cancellation.CAUSELESS_INTERRUPTED : Cancellation.CAUSELESS_CANCELLED);
    AbstractFuture<?> abstractFuture=this;
    while (true) {
      if (ATOMIC_HELPER.casValue(abstractFuture,localValue,valueToSet)) {
        rValue=true;
        if (mayInterruptIfRunning) {
          abstractFuture.interruptTask();
        }
        complete(abstractFuture);
        if (localValue instanceof SetFuture) {
          ListenableFuture<?> futureToPropagateTo=((SetFuture)localValue).future;
          if (futureToPropagateTo instanceof TrustedFuture) {
            AbstractFuture<?> trusted=(AbstractFuture<?>)futureToPropagateTo;
            localValue=trusted.value;
            if (localValue == null | localValue instanceof SetFuture) {
              abstractFuture=trusted;
              continue;
            }
          }
 else {
            futureToPropagateTo.cancel(mayInterruptIfRunning);
          }
        }
        break;
      }
      localValue=abstractFuture.value;
      if (!(localValue instanceof SetFuture)) {
        break;
      }
    }
  }
  return rValue;
}",0.9532846715328468
60028,"/** 
 * Returns a value, suitable for storing in the   {@link #value} field. From the given future,which is assumed to be done. <p>This is approximately the inverse of  {@link #getDoneValue(Object)}
 */
private static Object getFutureValue(ListenableFuture<?> future){
  Object valueToSet;
  if (future instanceof TrustedFuture) {
    return ((AbstractFuture<?>)future).value;
  }
 else {
    try {
      Object v=getDone(future);
      valueToSet=v == null ? NULL : v;
    }
 catch (    ExecutionException exception) {
      valueToSet=new Failure(exception.getCause());
    }
catch (    CancellationException cancellation) {
      valueToSet=new Cancellation(false,cancellation);
    }
catch (    Throwable t) {
      valueToSet=new Failure(t);
    }
  }
  return valueToSet;
}","/** 
 * Returns a value that satisfies the contract of the   {@link #value} field based on the state ofgiven future. <p>This is approximately the inverse of  {@link #getDoneValue(Object)}
 */
private static Object getFutureValue(ListenableFuture<?> future){
  Object valueToSet;
  if (future instanceof TrustedFuture) {
    Object v=((AbstractFuture<?>)future).value;
    if (v instanceof Cancellation) {
      Cancellation c=(Cancellation)v;
      if (c.wasInterrupted) {
        v=c.cause != null ? new Cancellation(false,c.cause) : Cancellation.CAUSELESS_CANCELLED;
      }
    }
    return v;
  }
 else {
    try {
      Object v=getDone(future);
      valueToSet=v == null ? NULL : v;
    }
 catch (    ExecutionException exception) {
      valueToSet=new Failure(exception.getCause());
    }
catch (    CancellationException cancellation) {
      valueToSet=new Cancellation(false,cancellation);
    }
catch (    Throwable t) {
      valueToSet=new Failure(t);
    }
  }
  return valueToSet;
}",0.7559055118110236
60029,"/** 
 * Sets the result of this   {@code Future} to match the supplied input {@code Future} once thesupplied  {@code Future} is done, unless this {@code Future} has already been cancelled or set(including ""set asynchronously,"" defined below). <p>If the supplied future is  {@linkplain #isDone done} when this method is called and the callis accepted, then this future is guaranteed to have been completed with the supplied future by the time this method returns. If the supplied future is not done and the call is accepted, then the future will be <i>set asynchronously</i>. Note that such a result, though not yet known, cannot be overridden by a call to a  {@code set*} method, only by a call to {@link #cancel}. <p>If the call   {@code setFuture(delegate)} is accepted and this {@code Future} is latercancelled, cancellation will be propagated to  {@code delegate}. Additionally, any call to  {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code Future}.
 * @param future the future to delegate to
 * @return true if the attempt was accepted, indicating that the {@code Future} was not previouslycancelled or set.
 * @since 19.0
 */
@Beta @CanIgnoreReturnValue protected boolean setFuture(ListenableFuture<? extends V> future){
  checkNotNull(future);
  Object localValue=value;
  if (localValue == null) {
    if (future.isDone()) {
      Object value=getFutureValue(future);
      if (ATOMIC_HELPER.casValue(this,null,value)) {
        complete(this);
        return true;
      }
      return false;
    }
    SetFuture valueToSet=new SetFuture<V>(this,future);
    if (ATOMIC_HELPER.casValue(this,null,valueToSet)) {
      try {
        future.addListener(valueToSet,directExecutor());
      }
 catch (      Throwable t) {
        Failure failure;
        try {
          failure=new Failure(t);
        }
 catch (        Throwable oomMostLikely) {
          failure=Failure.FALLBACK_INSTANCE;
        }
        boolean unused=ATOMIC_HELPER.casValue(this,valueToSet,failure);
      }
      return true;
    }
    localValue=value;
  }
  if (localValue instanceof Cancellation) {
    future.cancel(((Cancellation)localValue).wasInterrupted);
  }
  return false;
}","/** 
 * Sets the result of this   {@code Future} to match the supplied input {@code Future} once thesupplied  {@code Future} is done, unless this {@code Future} has already been cancelled or set(including ""set asynchronously,"" defined below). <p>If the supplied future is  {@linkplain #isDone done} when this method is called and the callis accepted, then this future is guaranteed to have been completed with the supplied future by the time this method returns. If the supplied future is not done and the call is accepted, then the future will be <i>set asynchronously</i>. Note that such a result, though not yet known, cannot be overridden by a call to a  {@code set*} method, only by a call to {@link #cancel}. <p>If the call   {@code setFuture(delegate)} is accepted and this {@code Future} is latercancelled, cancellation will be propagated to  {@code delegate}. Additionally, any call to  {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code Future}. <p>Note that, even if the supplied future is cancelled and it causes this future to complete, it will never trigger interruption behavior. In particular, it will not cause this future to invoke the   {@link #interruptTask} method, and the {@link #wasInterrupted} method will notreturn  {@code true}.
 * @param future the future to delegate to
 * @return true if the attempt was accepted, indicating that the {@code Future} was not previouslycancelled or set.
 * @since 19.0
 */
@Beta @CanIgnoreReturnValue protected boolean setFuture(ListenableFuture<? extends V> future){
  checkNotNull(future);
  Object localValue=value;
  if (localValue == null) {
    if (future.isDone()) {
      Object value=getFutureValue(future);
      if (ATOMIC_HELPER.casValue(this,null,value)) {
        complete(this);
        return true;
      }
      return false;
    }
    SetFuture valueToSet=new SetFuture<V>(this,future);
    if (ATOMIC_HELPER.casValue(this,null,valueToSet)) {
      try {
        future.addListener(valueToSet,directExecutor());
      }
 catch (      Throwable t) {
        Failure failure;
        try {
          failure=new Failure(t);
        }
 catch (        Throwable oomMostLikely) {
          failure=Failure.FALLBACK_INSTANCE;
        }
        boolean unused=ATOMIC_HELPER.casValue(this,valueToSet,failure);
      }
      return true;
    }
    localValue=value;
  }
  if (localValue instanceof Cancellation) {
    future.cancel(((Cancellation)localValue).wasInterrupted);
  }
  return false;
}",0.9363867684478372
60030,"@GwtIncompatible public void testChooseTableSize(){
  assertEquals(8,ImmutableSet.chooseTableSize(3));
  assertEquals(8,ImmutableSet.chooseTableSize(4));
  assertEquals(1 << 29,ImmutableSet.chooseTableSize(1 << 28));
  assertEquals(1 << 29,ImmutableSet.chooseTableSize(1 << 29 - 1));
  assertEquals(1 << 30,ImmutableSet.chooseTableSize(1 << 29));
  assertEquals(1 << 30,ImmutableSet.chooseTableSize(1 << 30 - 1));
  try {
    ImmutableSet.chooseTableSize(1 << 30);
    fail();
  }
 catch (  IllegalArgumentException expected) {
  }
}","@GwtIncompatible public void testChooseTableSize(){
  assertEquals(8,ImmutableSet.chooseTableSize(3));
  assertEquals(8,ImmutableSet.chooseTableSize(4));
  assertEquals(1 << 29,ImmutableSet.chooseTableSize(1 << 28));
  assertEquals(1 << 29,ImmutableSet.chooseTableSize((1 << 29) * 3 / 5));
  assertEquals(1 << 30,ImmutableSet.chooseTableSize(1 << 29));
  assertEquals(1 << 30,ImmutableSet.chooseTableSize((1 << 30) - 1));
  try {
    ImmutableSet.chooseTableSize(1 << 30);
    fail();
  }
 catch (  IllegalArgumentException expected) {
  }
}",0.9851024208566108
60031,"@Override public void forEachEntry(ObjIntConsumer<? super E> action){
  checkNotNull(action);
  for (int i=0; i < size(); i++) {
    action.accept(elementSet.asList().get(i),getCount(i));
  }
}","@Override public void forEachEntry(ObjIntConsumer<? super E> action){
  checkNotNull(action);
  for (int i=0; i < length; i++) {
    action.accept(elementSet.asList().get(i),getCount(i));
  }
}",0.9740932642487048
60032,"/** 
 * Call this in a   {@link TestSubtype} public method asserting subtype relationship. 
 */
final <T>T isSubtype(T sub){
  Type returnType=method.getGenericReturnType();
  Type paramType=getOnlyParameterType();
  TestSubtype spec=method.getAnnotation(TestSubtype.class);
  assertThat(TypeToken.of(paramType).isSubtypeOf(returnType)).isTrue();
  assertThat(TypeToken.of(returnType).isSupertypeOf(paramType)).isTrue();
  if (!spec.suppressGetSubtype()) {
    assertThat(getSubtype(returnType,TypeToken.of(paramType).getRawType())).isEqualTo(paramType);
  }
  if (!spec.suppressGetSupertype()) {
    assertThat(getSupertype(paramType,TypeToken.of(returnType).getRawType())).isEqualTo(returnType);
  }
  return sub;
}","/** 
 * Call this in a   {@link TestSubtype} public method asserting subtype relationship. 
 */
final <T>T isSubtype(T sub){
  Type returnType=method.getGenericReturnType();
  Type paramType=getOnlyParameterType();
  TestSubtype spec=method.getAnnotation(TestSubtype.class);
  assertThat(TypeToken.of(paramType).isSubtypeOf(returnType)).named(""String_Node_Str"",paramType,returnType).isTrue();
  assertThat(TypeToken.of(returnType).isSupertypeOf(paramType)).named(""String_Node_Str"",returnType,paramType).isTrue();
  if (!spec.suppressGetSubtype()) {
    assertThat(getSubtype(returnType,TypeToken.of(paramType).getRawType())).isEqualTo(paramType);
  }
  if (!spec.suppressGetSupertype()) {
    assertThat(getSupertype(paramType,TypeToken.of(returnType).getRawType())).isEqualTo(returnType);
  }
  return sub;
}",0.9397116644823068
60033,"/** 
 * Call this in a   {@link TestSubtype} public method asserting that subtype relationship does nothold.
 */
final <X>X notSubtype(@SuppressWarnings(""String_Node_Str"") Object sub){
  Type returnType=method.getGenericReturnType();
  Type paramType=getOnlyParameterType();
  TestSubtype spec=method.getAnnotation(TestSubtype.class);
  assertThat(TypeToken.of(paramType).isSubtypeOf(returnType)).isFalse();
  assertThat(TypeToken.of(returnType).isSupertypeOf(paramType)).isFalse();
  if (!spec.suppressGetSubtype()) {
    try {
      assertThat(getSubtype(returnType,TypeToken.of(paramType).getRawType())).isNotEqualTo(paramType);
    }
 catch (    IllegalArgumentException notSubtype1) {
    }
  }
  if (!spec.suppressGetSupertype()) {
    try {
      assertThat(getSupertype(paramType,TypeToken.of(returnType).getRawType())).isNotEqualTo(returnType);
    }
 catch (    IllegalArgumentException notSubtype2) {
    }
  }
  return null;
}","/** 
 * Call this in a   {@link TestSubtype} public method asserting that subtype relationship does nothold.
 */
final <X>X notSubtype(@SuppressWarnings(""String_Node_Str"") Object sub){
  Type returnType=method.getGenericReturnType();
  Type paramType=getOnlyParameterType();
  TestSubtype spec=method.getAnnotation(TestSubtype.class);
  assertThat(TypeToken.of(paramType).isSubtypeOf(returnType)).named(""String_Node_Str"",paramType,returnType).isFalse();
  assertThat(TypeToken.of(returnType).isSupertypeOf(paramType)).named(""String_Node_Str"",returnType,paramType).isFalse();
  if (!spec.suppressGetSubtype()) {
    try {
      assertThat(getSubtype(returnType,TypeToken.of(paramType).getRawType())).isNotEqualTo(paramType);
    }
 catch (    IllegalArgumentException notSubtype1) {
    }
  }
  if (!spec.suppressGetSupertype()) {
    try {
      assertThat(getSupertype(paramType,TypeToken.of(returnType).getRawType())).isNotEqualTo(returnType);
    }
 catch (    IllegalArgumentException notSubtype2) {
    }
  }
  return null;
}",0.9532520325203252
60034,"void setList(List<T> list){
  this.list=list;
}","void setList(List<T> list){
}",0.7631578947368421
60035,"private Type[] capture(Type[] types){
  Type[] result=new Type[types.length];
  for (int i=0; i < types.length; i++) {
    result[i]=capture(types[i]);
  }
  return result;
}","final Type capture(Type type){
  checkNotNull(type);
  if (type instanceof Class) {
    return type;
  }
  if (type instanceof TypeVariable) {
    return type;
  }
  if (type instanceof GenericArrayType) {
    GenericArrayType arrayType=(GenericArrayType)type;
    return Types.newArrayType(notForTypeVariable().capture(arrayType.getGenericComponentType()));
  }
  if (type instanceof ParameterizedType) {
    ParameterizedType parameterizedType=(ParameterizedType)type;
    Class<?> rawType=(Class<?>)parameterizedType.getRawType();
    TypeVariable<?>[] typeVars=rawType.getTypeParameters();
    Type[] typeArgs=parameterizedType.getActualTypeArguments();
    for (int i=0; i < typeArgs.length; i++) {
      typeArgs[i]=forTypeVariable(typeVars[i]).capture(typeArgs[i]);
    }
    return Types.newParameterizedTypeWithOwner(notForTypeVariable().captureNullable(parameterizedType.getOwnerType()),rawType,typeArgs);
  }
  if (type instanceof WildcardType) {
    WildcardType wildcardType=(WildcardType)type;
    Type[] lowerBounds=wildcardType.getLowerBounds();
    if (lowerBounds.length == 0) {
      return captureAsTypeVariable(wildcardType.getUpperBounds());
    }
 else {
      return type;
    }
  }
  throw new AssertionError(""String_Node_Str"");
}",0.0545836249125262
60036,"/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge. <p>In an undirected graph, this is equivalent to   {@link #adjacentNodes(Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
@Override Set<N> predecessors(@CompatibleWith(""String_Node_Str"") Object node);","/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge. <p>In an undirected graph, this is equivalent to   {@link #adjacentNodes(Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
@Override Set<N> predecessors(Object node);",0.9576783555018138
60037,"/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>In an undirected graph, this is equivalent to   {@link #adjacentNodes(Object)}. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
@Override Set<N> successors(@CompatibleWith(""String_Node_Str"") Object node);","/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>In an undirected graph, this is equivalent to   {@link #adjacentNodes(Object)}. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
@Override Set<N> successors(Object node);",0.9696969696969696
60038,"/** 
 * Returns all nodes in this network adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge. <p>In an undirected network, this is equivalent to   {@link #adjacentNodes(Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this network
 */
@Override Set<N> predecessors(@CompatibleWith(""String_Node_Str"") Object node);","/** 
 * Returns all nodes in this network adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge. <p>In an undirected network, this is equivalent to   {@link #adjacentNodes(Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this network
 */
@Override Set<N> predecessors(Object node);",0.9582836710369488
60039,"/** 
 * Returns all nodes in this network adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>In an undirected network, this is equivalent to   {@link #adjacentNodes(Object)}. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this network
 */
@Override Set<N> successors(@CompatibleWith(""String_Node_Str"") Object node);","/** 
 * Returns all nodes in this network adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>In an undirected network, this is equivalent to   {@link #adjacentNodes(Object)}. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this network
 */
@Override Set<N> successors(Object node);",0.9700085689802912
60040,"/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
Set<N> predecessors(N node);","/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
Set<N> predecessors(@CompatibleWith(""String_Node_Str"") Object node);",0.9371069182389936
60041,"/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
Set<N> successors(N node);","/** 
 * Returns all nodes in this graph adjacent to   {@code node} which can be reached by traversing{@code node}'s outgoing edges in the direction (if any) of the edge. <p>This is <i>not</i> the same as ""all nodes reachable from   {@code node} by following outgoingedges"". For that functionality, see  {@link Graphs#reachableNodes(Graph,Object)}.
 * @throws IllegalArgumentException if {@code node} is not an element of this graph
 */
Set<N> successors(@CompatibleWith(""String_Node_Str"") Object node);",0.95850622406639
60042,"@AndroidIncompatible public void testClassPathEntries_URLClassLoader_withParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url1},null);
  URLClassLoader child=new URLClassLoader(new URL[]{url2},parent){
  }
;
  ImmutableMap<File,ClassLoader> classPathEntries=ClassPath.Scanner.getClassPathEntries(child);
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),parent,new File(""String_Node_Str""),child),classPathEntries);
  assertThat(classPathEntries.keySet()).containsExactly(new File(""String_Node_Str""),new File(""String_Node_Str"")).inOrder();
}","@AndroidIncompatible public void testClassPathEntries_URLClassLoader_withParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url1},null);
  URLClassLoader child=new URLClassLoader(new URL[]{url2},parent){
  }
;
  assertThat(ClassPath.Scanner.getClassPathEntries(child)).containsExactly(new File(""String_Node_Str""),parent,new File(""String_Node_Str""),child).inOrder();
}",0.7954144620811288
60043,"@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_noParent(){
  assertThat(ClassPath.Scanner.getClassPathEntries(new ClassLoader(null){
  }
).keySet()).isEmpty();
}","@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_noParent(){
  assertThat(ClassPath.Scanner.getClassPathEntries(new ClassLoader(null){
  }
)).isEmpty();
}",0.975206611570248
60044,"@AndroidIncompatible public void testClassPathEntries_duplicateUri_parentWins() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url},null);
  URLClassLoader child=new URLClassLoader(new URL[]{url},parent){
  }
;
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),parent),ClassPath.Scanner.getClassPathEntries(child));
}","@AndroidIncompatible public void testClassPathEntries_duplicateUri_parentWins() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url},null);
  URLClassLoader child=new URLClassLoader(new URL[]{url},parent){
  }
;
  assertThat(ClassPath.Scanner.getClassPathEntries(child)).containsExactly(new File(""String_Node_Str""),parent);
}",0.8505154639175257
60045,"@AndroidIncompatible public void testClassPathEntries_URLClassLoader_noParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader classloader=new URLClassLoader(new URL[]{url1,url2},null);
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),classloader,new File(""String_Node_Str""),classloader),ClassPath.Scanner.getClassPathEntries(classloader));
}","@AndroidIncompatible public void testClassPathEntries_URLClassLoader_noParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader classloader=new URLClassLoader(new URL[]{url1,url2},null);
  assertThat(ClassPath.Scanner.getClassPathEntries(classloader)).containsExactly(new File(""String_Node_Str""),classloader,new File(""String_Node_Str""),classloader);
}",0.7535885167464115
60046,"@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParent() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url},null);
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),parent),ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
));
}","@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParent() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader parent=new URLClassLoader(new URL[]{url},null);
  assertThat(ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
)).containsExactly(new File(""String_Node_Str""),parent);
}",0.8318840579710145
60047,"public void testScan_classPathCycle() throws IOException {
  File jarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  try {
    writeSelfReferencingJarFile(jarFile,""String_Node_Str"");
    ClassPath.DefaultScanner scanner=new ClassPath.DefaultScanner();
    scanner.scan(jarFile,ClassPathTest.class.getClassLoader());
    assertEquals(1,scanner.getResources().size());
  }
  finally {
    jarFile.delete();
  }
}","public void testScan_classPathCycle() throws IOException {
  File jarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  try {
    writeSelfReferencingJarFile(jarFile,""String_Node_Str"");
    ClassPath.DefaultScanner scanner=new ClassPath.DefaultScanner();
    scanner.scan(jarFile,ClassPathTest.class.getClassLoader());
    assertThat(scanner.getResources()).hasSize(1);
  }
  finally {
    jarFile.delete();
  }
}",0.918032786885246
60048,"@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParentAndGrandParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader grandParent=new URLClassLoader(new URL[]{url1},null);
  URLClassLoader parent=new URLClassLoader(new URL[]{url2},grandParent);
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),grandParent,new File(""String_Node_Str""),parent),ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
));
}","@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParentAndGrandParent() throws Exception {
  URL url1=new URL(""String_Node_Str"");
  URL url2=new URL(""String_Node_Str"");
  URLClassLoader grandParent=new URLClassLoader(new URL[]{url1},null);
  URLClassLoader parent=new URLClassLoader(new URL[]{url2},grandParent);
  assertThat(ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
)).containsExactly(new File(""String_Node_Str""),grandParent,new File(""String_Node_Str""),parent);
}",0.8262548262548263
60049,"@Override protected void scanDirectory(ClassLoader loader,File root) throws IOException {
  URI base=root.toURI();
  for (  File entry : Files.fileTreeTraverser().preOrderTraversal(root)) {
    String resourceName=new File(base.relativize(entry.toURI()).getPath()).getPath();
    resources.add(resourceName);
  }
}","@Override protected void scanDirectory(ClassLoader loader,File root){
}",0.3688311688311688
60050,"@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withGrandParent() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader grandParent=new URLClassLoader(new URL[]{url},null);
  ClassLoader parent=new ClassLoader(grandParent){
  }
;
  assertEquals(ImmutableMap.of(new File(""String_Node_Str""),grandParent),ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
));
}","@AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withGrandParent() throws Exception {
  URL url=new URL(""String_Node_Str"");
  URLClassLoader grandParent=new URLClassLoader(new URL[]{url},null);
  ClassLoader parent=new ClassLoader(grandParent){
  }
;
  assertThat(ClassPath.Scanner.getClassPathEntries(new ClassLoader(parent){
  }
)).containsExactly(new File(""String_Node_Str""),grandParent);
}",0.7841726618705036
60051,"@Override protected void scanJarFile(ClassLoader loader,JarFile file) throws IOException {
  Enumeration<JarEntry> entries=file.entries();
  while (entries.hasMoreElements()) {
    resources.add(entries.nextElement().getName());
  }
}","@Override protected void scanJarFile(ClassLoader loader,JarFile file) throws IOException {
  this.found=new File(file.getName());
  throw new StopScanningException();
}",0.5870646766169154
60052,"/** 
 * Returns the class path URIs specified by the   {@code Class-Path} manifest attribute, accordingto <a href=""http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes""> JAR File Specification</a>. If  {@code manifest} is null, it means the jar file has nomanifest, and an empty set will be returned.
 */
@VisibleForTesting static ImmutableSet<File> getClassPathFromManifest(File jarFile,@Nullable Manifest manifest){
  if (manifest == null) {
    return ImmutableSet.of();
  }
  ImmutableSet.Builder<File> builder=ImmutableSet.builder();
  String classpathAttribute=manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());
  if (classpathAttribute != null) {
    for (    String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {
      URL url;
      try {
        url=getClassPathEntry(jarFile,path);
      }
 catch (      MalformedURLException e) {
        logger.warning(""String_Node_Str"" + path);
        continue;
      }
      if (url.getProtocol().equals(""String_Node_Str"")) {
        builder.add(new File(url.getFile()));
      }
    }
  }
  return builder.build();
}","/** 
 * Returns the class path URIs specified by the   {@code Class-Path} manifest attribute, accordingto <a href=""http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes""> JAR File Specification</a>. If  {@code manifest} is null, it means the jar file has nomanifest, and an empty set will be returned.
 */
@VisibleForTesting static ImmutableSet<File> getClassPathFromManifest(File jarFile,@Nullable Manifest manifest){
  if (manifest == null) {
    return ImmutableSet.of();
  }
  ImmutableSet.Builder<File> builder=ImmutableSet.builder();
  String classpathAttribute=manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());
  if (classpathAttribute != null) {
    for (    String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {
      URL url;
      try {
        url=getClassPathEntry(jarFile,path);
      }
 catch (      MalformedURLException e) {
        logger.warning(""String_Node_Str"" + path);
        continue;
      }
      if (url.getProtocol().equals(""String_Node_Str"")) {
        builder.add(toFile(url));
      }
    }
  }
  return builder.build();
}",0.9929639401934915
60053,"@VisibleForTesting static ImmutableMap<File,ClassLoader> getClassPathEntries(ClassLoader classloader){
  LinkedHashMap<File,ClassLoader> entries=Maps.newLinkedHashMap();
  ClassLoader parent=classloader.getParent();
  if (parent != null) {
    entries.putAll(getClassPathEntries(parent));
  }
  if (classloader instanceof URLClassLoader) {
    URLClassLoader urlClassLoader=(URLClassLoader)classloader;
    for (    URL entry : urlClassLoader.getURLs()) {
      if (entry.getProtocol().equals(""String_Node_Str"")) {
        File file=new File(entry.getFile());
        if (!entries.containsKey(file)) {
          entries.put(file,classloader);
        }
      }
    }
  }
  return ImmutableMap.copyOf(entries);
}","@VisibleForTesting static ImmutableMap<File,ClassLoader> getClassPathEntries(ClassLoader classloader){
  LinkedHashMap<File,ClassLoader> entries=Maps.newLinkedHashMap();
  ClassLoader parent=classloader.getParent();
  if (parent != null) {
    entries.putAll(getClassPathEntries(parent));
  }
  if (classloader instanceof URLClassLoader) {
    URLClassLoader urlClassLoader=(URLClassLoader)classloader;
    for (    URL entry : urlClassLoader.getURLs()) {
      if (entry.getProtocol().equals(""String_Node_Str"")) {
        File file=toFile(entry);
        if (!entries.containsKey(file)) {
          entries.put(file,classloader);
        }
      }
    }
  }
  return ImmutableMap.copyOf(entries);
}",0.9886524822695036
60054,"/** 
 * Returns the contained instance, which must be present. If the instance might be absent, use  {@link #or(Object)} or {@link #orNull} instead.<p><b>Comparison to  {@code java.util.Optional}:</b> when the value is absent, this method throws   {@link IllegalStateException}, whereas the Java 8 counterpart throws  {@link NoSuchElementException}.
 * @throws IllegalStateException if the instance is absent ({@link #isPresent} returns{@code false}); depending on this <i>specific</i> exception type (over the more general  {@link RuntimeException}) is discouraged
 */
public abstract T get();","/** 
 * Returns the contained instance, which must be present. If the instance might be absent, use  {@link #or(Object)} or {@link #orNull} instead.<p><b>Comparison to  {@code java.util.Optional}:</b> when the value is absent, this method throws   {@link IllegalStateException}, whereas the Java 8 counterpart throws  {@link java.util.NoSuchElementException NoSuchElementException}.
 * @throws IllegalStateException if the instance is absent ({@link #isPresent} returns{@code false}); depending on this <i>specific</i> exception type (over the more general  {@link RuntimeException}) is discouraged
 */
public abstract T get();",0.972972972972973
60055,"/** 
 * Returns a collection that applies   {@code function} to each element of{@code fromCollection}. The returned collection is a live view of   {@code fromCollection}; changes to one affect the other. <p>The returned collection's   {@code add()} and {@code addAll()} methodsthrow an  {@link UnsupportedOperationException}. All other collection methods are supported, as long as   {@code fromCollection} supports them.<p>The returned collection isn't threadsafe or serializable, even if {@code fromCollection} is.<p>When a live view is <i>not</i> needed, it may be faster to copy the transformed collection and use the copy. <p>If the input  {@code Collection} is known to be a {@code List}, consider  {@link Lists#transform}. If only an   {@code Iterable} is available, use{@link Iterables#transform}. <p><b>  {@code Stream} equivalent:</b> {@link Stream#map}.
 */
public static <F,T>Collection<T> transform(Collection<F> fromCollection,Function<? super F,T> function){
  return new TransformedCollection<F,T>(fromCollection,function);
}","/** 
 * Returns a collection that applies   {@code function} to each element of{@code fromCollection}. The returned collection is a live view of   {@code fromCollection}; changes to one affect the other. <p>The returned collection's   {@code add()} and {@code addAll()} methodsthrow an  {@link UnsupportedOperationException}. All other collection methods are supported, as long as   {@code fromCollection} supports them.<p>The returned collection isn't threadsafe or serializable, even if {@code fromCollection} is.<p>When a live view is <i>not</i> needed, it may be faster to copy the transformed collection and use the copy. <p>If the input  {@code Collection} is known to be a {@code List}, consider  {@link Lists#transform}. If only an   {@code Iterable} is available, use{@link Iterables#transform}. <p><b>  {@code Stream} equivalent:</b> {@link java.util.stream.Stream#map Stream.map}.
 */
public static <F,T>Collection<T> transform(Collection<F> fromCollection,Function<? super F,T> function){
  return new TransformedCollection<F,T>(fromCollection,function);
}",0.986717267552182
60056,"/** 
 * Returns the elements of   {@code unfiltered} that satisfy a predicate. Thereturned collection is a live view of  {@code unfiltered}; changes to one affect the other. <p>The resulting collection's iterator does not support   {@code remove()}, but all other collection methods are supported. When given an element that doesn't satisfy the predicate, the collection's   {@code add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods such as   {@code removeAll()} and {@code clear()} are called on the filteredcollection, only elements that satisfy the filter will be removed from the underlying collection. <p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.<p>Many of the filtered collection's methods, such as  {@code size()}, iterate across every element in the underlying collection and determine which elements satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy   {@code Iterables.filter(unfiltered, predicate)}and use the copy. <p><b>Warning:</b>   {@code predicate} must be <i>consistent with equals</i>,as documented at  {@link Predicate#apply}. Do not provide a predicate such as   {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See   {@link Iterables#filter(Iterable,Class)} for relatedfunctionality.) <p><b> {@code Stream} equivalent:</b> {@link Stream#filter}.
 */
public static <E>Collection<E> filter(Collection<E> unfiltered,Predicate<? super E> predicate){
  if (unfiltered instanceof FilteredCollection) {
    return ((FilteredCollection<E>)unfiltered).createCombined(predicate);
  }
  return new FilteredCollection<E>(checkNotNull(unfiltered),checkNotNull(predicate));
}","/** 
 * Returns the elements of   {@code unfiltered} that satisfy a predicate. Thereturned collection is a live view of  {@code unfiltered}; changes to one affect the other. <p>The resulting collection's iterator does not support   {@code remove()}, but all other collection methods are supported. When given an element that doesn't satisfy the predicate, the collection's   {@code add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods such as   {@code removeAll()} and {@code clear()} are called on the filteredcollection, only elements that satisfy the filter will be removed from the underlying collection. <p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.<p>Many of the filtered collection's methods, such as  {@code size()}, iterate across every element in the underlying collection and determine which elements satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy   {@code Iterables.filter(unfiltered, predicate)}and use the copy. <p><b>Warning:</b>   {@code predicate} must be <i>consistent with equals</i>,as documented at  {@link Predicate#apply}. Do not provide a predicate such as   {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See   {@link Iterables#filter(Iterable,Class)} for relatedfunctionality.) <p><b> {@code Stream} equivalent:</b> {@link java.util.stream.Stream#filter Stream.filter}.
 */
public static <E>Collection<E> filter(Collection<E> unfiltered,Predicate<? super E> predicate){
  if (unfiltered instanceof FilteredCollection) {
    return ((FilteredCollection<E>)unfiltered).createCombined(predicate);
  }
  return new FilteredCollection<E>(checkNotNull(unfiltered),checkNotNull(predicate));
}",0.9911655742376746
60057,"/** 
 * Returns a fluent iterable containing the specified elements in order. <p><b>  {@code Stream} equivalent:</b> {@link Stream#of(T)}.
 * @since 20.0
 */
@Beta public static <E>FluentIterable<E> of(@Nullable E element,E... elements){
  return from(Lists.asList(element,elements));
}","/** 
 * Returns a fluent iterable containing the specified elements in order. <p><b>  {@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[]) Stream.of(T...)}.
 * @since 20.0
 */
@Beta public static <E>FluentIterable<E> of(@Nullable E element,E... elements){
  return from(Lists.asList(element,elements));
}",0.934640522875817
60058,"/** 
 * Returns the number of elements in the specified iterable that equal the specified object. This implementation avoids a full iteration when the iterable is a   {@link Multiset} or {@link Set}. <p><b>Java 8 users:</b> In most cases, the   {@code Stream} equivalent of this method is {@code stream.filter(element::equals).count()}. If   {@code element} might be null, use {@code stream.filter(Predicate.isEqual(element)).count()} instead.
 * @see Collections#frequency
 */
public static int frequency(Iterable<?> iterable,@Nullable Object element){
  if ((iterable instanceof Multiset)) {
    return ((Multiset<?>)iterable).count(element);
  }
 else   if ((iterable instanceof Set)) {
    return ((Set<?>)iterable).contains(element) ? 1 : 0;
  }
  return Iterators.frequency(iterable.iterator(),element);
}","/** 
 * Returns the number of elements in the specified iterable that equal the specified object. This implementation avoids a full iteration when the iterable is a   {@link Multiset} or {@link Set}. <p><b>Java 8 users:</b> In most cases, the   {@code Stream} equivalent of this method is {@code stream.filter(element::equals).count()}. If   {@code element} might be null, use {@code stream.filter(Predicate.isEqual(element)).count()} instead.
 * @see java.util.Collections#frequency(Collection,Object) Collections.frequency(Collection,Object)
 */
public static int frequency(Iterable<?> iterable,@Nullable Object element){
  if ((iterable instanceof Multiset)) {
    return ((Multiset<?>)iterable).count(element);
  }
 else   if ((iterable instanceof Set)) {
    return ((Set<?>)iterable).contains(element) ? 1 : 0;
  }
  return Iterators.frequency(iterable.iterator(),element);
}",0.958628841607565
60059,"/** 
 * Returns   {@code true} if each element in {@code iterable} after the first is greater than orequal to the element that preceded it, according to this ordering. Note that this is always true when the iterable has fewer than two elements. <p><b>Java 8 users:</b> Use the equivalent  {@link Comparators#isInOrder(Iterable)} instead,since the rest of  {@code Ordering} is mostly obsolete (as explained in the classdocumentation).
 */
public boolean isOrdered(Iterable<? extends T> iterable){
  Iterator<? extends T> it=iterable.iterator();
  if (it.hasNext()) {
    T prev=it.next();
    while (it.hasNext()) {
      T next=it.next();
      if (compare(prev,next) > 0) {
        return false;
      }
      prev=next;
    }
  }
  return true;
}","/** 
 * Returns   {@code true} if each element in {@code iterable} after the first is greater than orequal to the element that preceded it, according to this ordering. Note that this is always true when the iterable has fewer than two elements. <p><b>Java 8 users:</b> Use the equivalent  {@link Comparators#isInOrder(Iterable,Comparator)}instead, since the rest of   {@code Ordering} is mostly obsolete (as explained in the classdocumentation).
 */
public boolean isOrdered(Iterable<? extends T> iterable){
  Iterator<? extends T> it=iterable.iterator();
  if (it.hasNext()) {
    T prev=it.next();
    while (it.hasNext()) {
      T next=it.next();
      if (compare(prev,next) > 0) {
        return false;
      }
      prev=next;
    }
  }
  return true;
}",0.9907161803713528
60060,"/** 
 * Returns   {@code true} if each element in {@code iterable} after the first is <i>strictly</i>greater than the element that preceded it, according to this ordering. Note that this is always true when the iterable has fewer than two elements. <p><b>Java 8 users:</b> Use the equivalent  {@link Comparators#isInStrictOrder(Iterable)}instead, since the rest of   {@code Ordering} is mostly obsolete (as explained in the classdocumentation).
 */
public boolean isStrictlyOrdered(Iterable<? extends T> iterable){
  Iterator<? extends T> it=iterable.iterator();
  if (it.hasNext()) {
    T prev=it.next();
    while (it.hasNext()) {
      T next=it.next();
      if (compare(prev,next) >= 0) {
        return false;
      }
      prev=next;
    }
  }
  return true;
}","/** 
 * Returns   {@code true} if each element in {@code iterable} after the first is <i>strictly</i>greater than the element that preceded it, according to this ordering. Note that this is always true when the iterable has fewer than two elements. <p><b>Java 8 users:</b> Use the equivalent  {@link Comparators#isInStrictOrder(Iterable,Comparator)} instead, since the rest of {@code Ordering} is mostly obsolete (as explained inthe class documentation).
 */
public boolean isStrictlyOrdered(Iterable<? extends T> iterable){
  Iterator<? extends T> it=iterable.iterator();
  if (it.hasNext()) {
    T prev=it.next();
    while (it.hasNext()) {
      T next=it.next();
      if (compare(prev,next) >= 0) {
        return false;
      }
      prev=next;
    }
  }
  return true;
}",0.9780077619663649
60061,"/** 
 * Load 4 bytes from the provided array at the indicated offset.
 * @param input the input bytes
 * @param offset the offset into the array at which to start
 * @return the value found in the array in the form of a long
 */
static int load32(byte[] source,int offset){
  return (source[offset] & 0xFF) | ((source[offset + 1] & 0xFF) << 8) | ((source[offset + 2] & 0xFF) << 16)| ((source[offset + 3] & 0xFF) << 24);
}","/** 
 * Load 4 bytes from the provided array at the indicated offset.
 * @param source the input bytes
 * @param offset the offset into the array at which to start
 * @return the value found in the array in the form of a long
 */
static int load32(byte[] source,int offset){
  return (source[offset] & 0xFF) | ((source[offset + 1] & 0xFF) << 8) | ((source[offset + 2] & 0xFF) << 16)| ((source[offset + 3] & 0xFF) << 24);
}",0.9869513641755636
60062,"/** 
 * Attempts to skip up to   {@code n} bytes from the given input stream, but not more than{@code in.available()} bytes. This prevents {@code FileInputStream} from skipping more bytesthan actually remain in the file, something that it  {@linkplain FileInputStream#skip(long) specifies} it can do in its Javadoc despite the fact that it is violating the contract of{@code InputStream.skip()}.
 */
private static long skipSafely(InputStream in,long n) throws IOException {
  int available=in.available();
  return available == 0 ? 0 : in.skip(Math.min(available,n));
}","/** 
 * Attempts to skip up to   {@code n} bytes from the given input stream, but not more than{@code in.available()} bytes. This prevents {@code FileInputStream} from skipping more bytesthan actually remain in the file, something that it  {@linkplain java.io.FileInputStream#skip(long) specifies} it can do in its Javadoc despite the fact thatit is violating the contract of  {@code InputStream.skip()}.
 */
private static long skipSafely(InputStream in,long n) throws IOException {
  int available=in.available();
  return available == 0 ? 0 : in.skip(Math.min(available,n));
}",0.9364664926022628
60063,"/** 
 * Returns the unsigned   {@code long} value represented by a string with the given radix.
 * @param s the string containing the unsigned {@code long} representation to be parsed.
 * @param radix the radix to use while parsing {@code string}
 * @throws NumberFormatException if the string does not contain a valid unsigned {@code long} withthe given radix, or if  {@code radix} is not between {@link Character#MIN_RADIX} and{@link Character#MAX_RADIX}.
 * @throws NullPointerException if {@code string} is null (in contrast to{@link Long#parseLong(String)})
 */
@CanIgnoreReturnValue public static long parseUnsignedLong(String string,int radix){
  checkNotNull(string);
  if (string.length() == 0) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + radix);
  }
  int maxSafePos=maxSafeDigits[radix] - 1;
  long value=0;
  for (int pos=0; pos < string.length(); pos++) {
    int digit=Character.digit(string.charAt(pos),radix);
    if (digit == -1) {
      throw new NumberFormatException(string);
    }
    if (pos > maxSafePos && overflowInParse(value,digit,radix)) {
      throw new NumberFormatException(""String_Node_Str"" + string);
    }
    value=(value * radix) + digit;
  }
  return value;
}","/** 
 * Returns the unsigned   {@code long} value represented by a string with the given radix.
 * @param string the string containing the unsigned {@code long} representation to be parsed.
 * @param radix the radix to use while parsing {@code string}
 * @throws NumberFormatException if the string does not contain a valid unsigned {@code long} withthe given radix, or if  {@code radix} is not between {@link Character#MIN_RADIX} and{@link Character#MAX_RADIX}.
 * @throws NullPointerException if {@code string} is null (in contrast to{@link Long#parseLong(String)})
 */
@CanIgnoreReturnValue public static long parseUnsignedLong(String string,int radix){
  checkNotNull(string);
  if (string.length() == 0) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + radix);
  }
  int maxSafePos=maxSafeDigits[radix] - 1;
  long value=0;
  for (int pos=0; pos < string.length(); pos++) {
    int digit=Character.digit(string.charAt(pos),radix);
    if (digit == -1) {
      throw new NumberFormatException(string);
    }
    if (pos > maxSafePos && overflowInParse(value,digit,radix)) {
      throw new NumberFormatException(""String_Node_Str"" + string);
    }
    value=(value * radix) + digit;
  }
  return value;
}",0.9981364144614238
60064,"/** 
 * If the class is parameterized, such as   {@link ArrayList}, this returns   {@code ArrayList<E>}.
 */
@Override Type getGenericReturnType(){
  Class<?> declaringClass=getDeclaringClass();
  TypeVariable<?>[] typeParams=declaringClass.getTypeParameters();
  if (typeParams.length > 0) {
    return Types.newParameterizedType(declaringClass,typeParams);
  }
 else {
    return declaringClass;
  }
}","/** 
 * If the class is parameterized, such as   {@link java.util.ArrayList ArrayList}, this returns  {@code ArrayList<E>}.
 */
@Override Type getGenericReturnType(){
  Class<?> declaringClass=getDeclaringClass();
  TypeVariable<?>[] typeParams=declaringClass.getTypeParameters();
  if (typeParams.length > 0) {
    return Types.newParameterizedType(declaringClass,typeParams);
  }
 else {
    return declaringClass;
  }
}",0.9745454545454544
60065,"/** 
 * Returns the result of the input   {@code Future}, which must have already completed. <p>The benefits of this method are twofold. First, the name ""getDone"" suggests to readers that the   {@code Future} is already done. Second, if buggy code calls {@code getDone} on a {@code Future} that is still pending, the program will throw instead of block. This can be importantfor APIs like  {@link whenAllComplete whenAllComplete(...)}{@code .}{@link FutureCombiner#call(Callable) call(...)}, where it is easy to use a new input from the   {@code call} implementation but forget to add it to the arguments of {@code whenAllComplete}. <p>If you are looking for a method to determine whether a given   {@code Future} is done, use theinstance method  {@link Future#isDone()}.
 * @throws ExecutionException if the {@code Future} failed with an exception
 * @throws CancellationException if the {@code Future} was cancelled
 * @throws IllegalStateException if the {@code Future} is not done
 * @since 20.0
 */
@CanIgnoreReturnValue public static <V>V getDone(Future<V> future) throws ExecutionException {
  checkState(future.isDone(),""String_Node_Str"",future);
  return getUninterruptibly(future);
}","/** 
 * Returns the result of the input   {@code Future}, which must have already completed. <p>The benefits of this method are twofold. First, the name ""getDone"" suggests to readers that the   {@code Future} is already done. Second, if buggy code calls {@code getDone} on a {@code Future} that is still pending, the program will throw instead of block. This can be importantfor APIs like  {@link #whenAllComplete whenAllComplete(...)}{@code .}{@link FutureCombiner#call(Callable) call(...)}, where it is easy to use a new input from the   {@code call} implementation but forget to add it to the arguments of {@code whenAllComplete}. <p>If you are looking for a method to determine whether a given   {@code Future} is done, use theinstance method  {@link Future#isDone()}.
 * @throws ExecutionException if the {@code Future} failed with an exception
 * @throws CancellationException if the {@code Future} was cancelled
 * @throws IllegalStateException if the {@code Future} is not done
 * @since 20.0
 */
@CanIgnoreReturnValue public static <V>V getDone(Future<V> future) throws ExecutionException {
  checkState(future.isDone(),""String_Node_Str"",future);
  return getUninterruptibly(future);
}",0.9995810640971932
60066,"/** 
 * This tests a special case where removeAt has to trickle an element first down one level from a min to a max level, then up one level above the index of the removed element. It also tests that skipMe in the iterator plays nicely with forgetMeNot.
 */
public void testIteratorInvalidatingIteratorRemove2(){
  MinMaxPriorityQueue<Integer> mmHeap=MinMaxPriorityQueue.create();
  mmHeap.addAll(Lists.newArrayList(1,20,1000,2,3,30,40,10,11,12,13,200,300,500,400));
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  Iterator<Integer> it=mmHeap.iterator();
  assertEquals((Integer)1,it.next());
  assertEquals((Integer)20,it.next());
  assertEquals((Integer)1000,it.next());
  assertEquals((Integer)2,it.next());
  it.remove();
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  assertEquals((Integer)10,it.next());
  assertEquals((Integer)3,it.next());
  it.remove();
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  assertEquals((Integer)12,it.next());
  assertEquals((Integer)30,it.next());
  assertEquals((Integer)40,it.next());
  assertEquals((Integer)11,it.next());
  assertEquals((Integer)13,it.next());
  assertEquals((Integer)200,it.next());
  assertEquals((Integer)300,it.next());
  assertEquals((Integer)400,it.next());
  assertEquals((Integer)500,it.next());
}","/** 
 * This tests a special case where removeAt has to trickle an element first down one level from a min to a max level, then up one level above the index of the removed element. It also tests that skipMe in the iterator plays nicely with forgetMeNot.
 */
public void testIteratorInvalidatingIteratorRemove2(){
  MinMaxPriorityQueue<Integer> mmHeap=MinMaxPriorityQueue.create();
  mmHeap.addAll(Lists.newArrayList(1,20,1000,2,3,30,40,10,11,12,13,200,300,500,400));
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  Iterator<Integer> it=mmHeap.iterator();
  assertEquals((Integer)1,it.next());
  assertEquals((Integer)20,it.next());
  assertEquals((Integer)1000,it.next());
  assertEquals((Integer)2,it.next());
  it.remove();
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  assertEquals((Integer)10,it.next());
  assertEquals((Integer)3,it.next());
  it.remove();
  assertTrue(""String_Node_Str"",mmHeap.isIntact());
  assertEquals((Integer)12,it.next());
  assertEquals((Integer)30,it.next());
  assertEquals((Integer)40,it.next());
  assertEquals((Integer)11,it.next());
  assertEquals((Integer)400,it.next());
  assertEquals((Integer)13,it.next());
  assertEquals((Integer)200,it.next());
  assertEquals((Integer)300,it.next());
  assertEquals((Integer)500,it.next());
}",0.9687743950039032
60067,"@Override public boolean hasNext(){
  checkModCount();
  return (nextNotInSkipMe(cursor + 1) < size()) || ((forgetMeNot != null) && !forgetMeNot.isEmpty());
}","@Override public boolean hasNext(){
  checkModCount();
  nextNotInSkipMe(cursor + 1);
  return (nextCursor < size()) || ((forgetMeNot != null) && !forgetMeNot.isEmpty());
}",0.9090909090909092
60068,"@Override public E next(){
  checkModCount();
  int tempCursor=nextNotInSkipMe(cursor + 1);
  if (tempCursor < size()) {
    cursor=tempCursor;
    canRemove=true;
    return elementData(cursor);
  }
 else   if (forgetMeNot != null) {
    cursor=size();
    lastFromForgetMeNot=forgetMeNot.poll();
    if (lastFromForgetMeNot != null) {
      canRemove=true;
      return lastFromForgetMeNot;
    }
  }
  throw new NoSuchElementException(""String_Node_Str"");
}","@Override public E next(){
  checkModCount();
  nextNotInSkipMe(cursor + 1);
  if (nextCursor < size()) {
    cursor=nextCursor;
    canRemove=true;
    return elementData(cursor);
  }
 else   if (forgetMeNot != null) {
    cursor=size();
    lastFromForgetMeNot=forgetMeNot.poll();
    if (lastFromForgetMeNot != null) {
      canRemove=true;
      return lastFromForgetMeNot;
    }
  }
  throw new NoSuchElementException(""String_Node_Str"");
}",0.9656699889258028
60069,"@Override public void remove(){
  checkRemove(canRemove);
  checkModCount();
  canRemove=false;
  expectedModCount++;
  if (cursor < size()) {
    MoveDesc<E> moved=removeAt(cursor);
    if (moved != null) {
      if (forgetMeNot == null) {
        forgetMeNot=new ArrayDeque<E>();
        skipMe=new ArrayList<E>(3);
      }
      if (!containsExact(skipMe,moved.toTrickle)) {
        forgetMeNot.add(moved.toTrickle);
      }
      skipMe.add(moved.replaced);
    }
    cursor--;
  }
 else {
    checkState(removeExact(lastFromForgetMeNot));
    lastFromForgetMeNot=null;
  }
}","@Override public void remove(){
  checkRemove(canRemove);
  checkModCount();
  canRemove=false;
  expectedModCount++;
  if (cursor < size()) {
    MoveDesc<E> moved=removeAt(cursor);
    if (moved != null) {
      if (forgetMeNot == null) {
        forgetMeNot=new ArrayDeque<E>();
        skipMe=new ArrayList<E>(3);
      }
      if (!foundAndRemovedExactReference(skipMe,moved.toTrickle)) {
        forgetMeNot.add(moved.toTrickle);
      }
      if (!foundAndRemovedExactReference(forgetMeNot,moved.replaced)) {
        skipMe.add(moved.replaced);
      }
    }
    cursor--;
    nextCursor--;
  }
 else {
    checkState(removeExact(lastFromForgetMeNot));
    lastFromForgetMeNot=null;
  }
}",0.8916797488226059
60070,"boolean removeExact(Object target){
  for (int i=0; i < size; i++) {
    if (queue[i] == target) {
      removeAt(i);
      return true;
    }
  }
  return false;
}","/** 
 * Removes only this exact instance, not others that are equals() 
 */
private boolean removeExact(Object target){
  for (int i=0; i < size; i++) {
    if (queue[i] == target) {
      removeAt(i);
      return true;
    }
  }
  return false;
}",0.7961165048543689
60071,"/** 
 * Returns the index of the first element after   {@code c} that is not in{@code skipMe} and returns {@code size()} if there is no such element.
 */
private int nextNotInSkipMe(int c){
  if (skipMe != null) {
    while (c < size() && containsExact(skipMe,elementData(c))) {
      c++;
    }
  }
  return c;
}","/** 
 * Advances nextCursor to the index of the first element after   {@code c} that is not in{@code skipMe} and returns {@code size()} if there is no such element.
 */
private void nextNotInSkipMe(int c){
  if (nextCursor < c) {
    if (skipMe != null) {
      while (c < size() && foundAndRemovedExactReference(skipMe,elementData(c))) {
        c++;
      }
    }
    nextCursor=c;
  }
}",0.7948717948717948
60072,"void checkModCount(){
  if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
  }
}","private void checkModCount(){
  if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
  }
}",0.9661016949152542
60073,"public static void serialize(SerializationStreamWriter writer,RegularImmutableAsList<?> instance) throws SerializationException {
  writer.writeObject(instance.delegateCollection());
  writer.writeObject(instance.delegateList());
}","public static void serialize(SerializationStreamWriter writer,RegularImmutableAsList<?> instance) throws SerializationException {
  Collection_CustomFieldSerializerBase.serialize(writer,instance);
}",0.7505827505827506
60074,"public static RegularImmutableAsList<Object> instantiate(SerializationStreamReader reader) throws SerializationException {
  @SuppressWarnings(""String_Node_Str"") ImmutableCollection<Object> delegateCollection=(ImmutableCollection)reader.readObject();
  ImmutableList<?> delegateList=(ImmutableList<?>)reader.readObject();
  return new RegularImmutableAsList<Object>(delegateCollection,delegateList);
}","public static RegularImmutableAsList<Object> instantiate(SerializationStreamReader reader) throws SerializationException {
  ArrayList<Object> elements=new ArrayList<Object>();
  Collection_CustomFieldSerializerBase.deserialize(reader,elements);
  ImmutableList<Object> delegate=ImmutableList.copyOf(elements);
  return new RegularImmutableAsList<Object>(delegate,delegate);
}",0.3603603603603603
60075,"@Override public ImmutableSortedMap<K,V> descendingMap(){
  ImmutableSortedMap<K,V> result=descendingMap;
  if (result == null) {
    if (isEmpty()) {
      return result=emptyMap(Ordering.from(comparator()).reverse());
    }
 else {
      return result=new ImmutableSortedMap<K,V>((RegularImmutableSortedSet<K>)keySet.descendingSet(),valueList.reverse(),this);
    }
  }
  return result;
}","@Override public ImmutableSortedMap<K,V> descendingMap(){
  ImmutableSortedMap<K,V> result=descendingMap;
  if (result == null) {
    if (isEmpty()) {
      return result=emptyMap(Ordering.from(comparator()).<K>reverse());
    }
 else {
      return result=new ImmutableSortedMap<K,V>((RegularImmutableSortedSet<K>)keySet.descendingSet(),valueList.reverse(),this);
    }
  }
  return result;
}",0.9961685823754788
60076,"@Override public ImmutableSortedMultiset<E> descendingMultiset(){
  ImmutableSortedMultiset<E> result=descendingMultiset;
  if (result == null) {
    return descendingMultiset=this.isEmpty() ? emptyMultiset(Ordering.from(comparator()).reverse()) : new DescendingImmutableSortedMultiset<E>(this);
  }
  return result;
}","@Override public ImmutableSortedMultiset<E> descendingMultiset(){
  ImmutableSortedMultiset<E> result=descendingMultiset;
  if (result == null) {
    return descendingMultiset=this.isEmpty() ? emptyMultiset(Ordering.from(comparator()).<E>reverse()) : new DescendingImmutableSortedMultiset<E>(this);
  }
  return result;
}",0.9953051643192488
60077,"/** 
 * Asserts that all pairs of   {@code T} values within {@code valuesInExpectedOrder} are orderedconsistently between their order within  {@code valuesInExpectedOrder} and the order implied bythe given  {@code comparator}. <p>In detail, this method asserts <ul> <li><i>reflexivity</i>:   {@code comparator.compare(t, t) = 0} for all {@code t} in{@code valuesInExpectedOrder}; and <li><i>consistency</i>:   {@code comparator.compare(ti, tj) < 0} and{@code comparator.compare(tj, ti) > 0} for {@code i < j}, where  {@code ti = valuesInExpectedOrder.get(i)} and {@code tj = valuesInExpectedOrder.get(j)}.
 */
public static <T>void testComparator(Comparator<? super T> comparator,List<T> valuesInExpectedOrder){
  for (int i=0; i < valuesInExpectedOrder.size(); i++) {
    T t=valuesInExpectedOrder.get(i);
    for (int j=0; j < i; j++) {
      T lesser=valuesInExpectedOrder.get(j);
      assertTrue(comparator + ""String_Node_Str"" + lesser+ ""String_Node_Str""+ t+ ""String_Node_Str"",comparator.compare(lesser,t) < 0);
    }
    assertEquals(comparator + ""String_Node_Str"" + t+ ""String_Node_Str""+ t+ ""String_Node_Str"",0,comparator.compare(t,t));
    for (int j=i + 1; j < valuesInExpectedOrder.size(); j++) {
      T greater=valuesInExpectedOrder.get(j);
      assertTrue(comparator + ""String_Node_Str"" + greater+ ""String_Node_Str""+ t+ ""String_Node_Str"",comparator.compare(greater,t) > 0);
    }
  }
}","/** 
 * Asserts that all pairs of   {@code T} values within {@code valuesInExpectedOrder} are orderedconsistently between their order within  {@code valuesInExpectedOrder} and the order implied bythe given  {@code comparator}. <p>In detail, this method asserts <ul> <li><i>reflexivity</i>:   {@code comparator.compare(t, t) = 0} for all {@code t} in {@code valuesInExpectedOrder}; and <li><i>consistency</i>:   {@code comparator.compare(ti, tj) < 0} and {@code comparator.compare(tj, ti) > 0} for {@code i < j}, where   {@code ti =valuesInExpectedOrder.get(i)} and {@code tj = valuesInExpectedOrder.get(j)}. </ul>
 */
public static <T>void testComparator(Comparator<? super T> comparator,List<T> valuesInExpectedOrder){
  for (int i=0; i < valuesInExpectedOrder.size(); i++) {
    T t=valuesInExpectedOrder.get(i);
    for (int j=0; j < i; j++) {
      T lesser=valuesInExpectedOrder.get(j);
      assertTrue(comparator + ""String_Node_Str"" + lesser+ ""String_Node_Str""+ t+ ""String_Node_Str"",comparator.compare(lesser,t) < 0);
    }
    assertEquals(comparator + ""String_Node_Str"" + t+ ""String_Node_Str""+ t+ ""String_Node_Str"",0,comparator.compare(t,t));
    for (int j=i + 1; j < valuesInExpectedOrder.size(); j++) {
      T greater=valuesInExpectedOrder.get(j);
      assertTrue(comparator + ""String_Node_Str"" + greater+ ""String_Node_Str""+ t+ ""String_Node_Str"",comparator.compare(greater,t) > 0);
    }
  }
}",0.9964362081254454
60078,"/** 
 * Trigger the other.size() >= this.size() case in AbstractSet.removeAll().
 */
@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_somePresentLargeCollectionToRemove(){
  assertTrue(""String_Node_Str"",collection.removeAll(MinimalCollection.of(e0(),e0(),e0(),e3(),e3(),e3())));
  expectMissing(e0());
}","/** 
 * Trigger the   {@code other.size() >= this.size()} case in {@link AbstractSet#removeAll()}. 
 */
@CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_somePresentLargeCollectionToRemove(){
  assertTrue(""String_Node_Str"",collection.removeAll(MinimalCollection.of(e0(),e0(),e0(),e3(),e3(),e3())));
  expectMissing(e0());
}",0.9473684210526316
60079,"/** 
 * Asserts that an escaper behaves correctly with respect to null inputs.
 * @param escaper the non-null escaper to test
 * @throws IOException
 */
public static void assertBasic(Escaper escaper) throws IOException {
  Assert.assertEquals(""String_Node_Str"",escaper.escape(""String_Node_Str""));
  try {
    escaper.escape((String)null);
    Assert.fail(""String_Node_Str"");
  }
 catch (  NullPointerException e) {
  }
}","/** 
 * Asserts that an escaper behaves correctly with respect to null inputs.
 * @param escaper the non-null escaper to test
 */
public static void assertBasic(Escaper escaper) throws IOException {
  Assert.assertEquals(""String_Node_Str"",escaper.escape(""String_Node_Str""));
  try {
    escaper.escape((String)null);
    Assert.fail(""String_Node_Str"");
  }
 catch (  NullPointerException e) {
  }
}",0.4004884004884005
60080,"/** 
 * Returns true if the the given member is a method that overrides   {@link Object#equals(Object)}. <p>The documentation for   {@link Object#equals} says it should accept null, so don't require anexplicit  {@link @Nullable} annotation (see <ahref=""https://github.com/google/guava/issues/1819"">#1819</a>). <p>It is not necessary to consider visibility, return type, or type parameter declarations. The declaration of a method with the same name and formal parameters as  {@link Object#equals} thatis not public and boolean-returning, or that declares any type parameters, would be rejected at compile-time.
 */
private static boolean isEquals(Member member){
  if (!(member instanceof Method)) {
    return false;
  }
  Method method=(Method)member;
  if (!method.getName().contentEquals(""String_Node_Str"")) {
    return false;
  }
  Class<?>[] parameters=method.getParameterTypes();
  if (parameters.length != 1) {
    return false;
  }
  if (!parameters[0].equals(Object.class)) {
    return false;
  }
  return true;
}","/** 
 * Returns true if the the given member is a method that overrides   {@link Object#equals(Object)}. <p>The documentation for   {@link Object#equals} says it should accept null, so don't require anexplicit  {@code @Nullable} annotation (see <ahref=""https://github.com/google/guava/issues/1819"">#1819</a>). <p>It is not necessary to consider visibility, return type, or type parameter declarations. The declaration of a method with the same name and formal parameters as  {@link Object#equals} thatis not public and boolean-returning, or that declares any type parameters, would be rejected at compile-time.
 */
private static boolean isEquals(Member member){
  if (!(member instanceof Method)) {
    return false;
  }
  Method method=(Method)member;
  if (!method.getName().contentEquals(""String_Node_Str"")) {
    return false;
  }
  Class<?>[] parameters=method.getParameterTypes();
  if (parameters.length != 1) {
    return false;
  }
  if (!parameters[0].equals(Object.class)) {
    return false;
  }
  return true;
}",0.9960975609756098
60081,"/** 
 * Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation.  The returned size is the smallest power of two that can hold setSize elements with the desired load factor. <p>Do not call this method with setSize < 2.
 */
@VisibleForTesting static int chooseTableSize(int setSize){
  if (setSize < CUTOFF) {
    int tableSize=Integer.highestOneBit(setSize - 1) << 1;
    while (tableSize * DESIRED_LOAD_FACTOR < setSize) {
      tableSize<<=1;
    }
    return tableSize;
  }
  checkArgument(setSize < MAX_TABLE_SIZE,""String_Node_Str"");
  return MAX_TABLE_SIZE;
}","/** 
 * Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation. The returned size is the smallest power of two that can hold setSize elements with the desired load factor. <p>Do not call this method with setSize less than 2.
 */
@VisibleForTesting static int chooseTableSize(int setSize){
  if (setSize < CUTOFF) {
    int tableSize=Integer.highestOneBit(setSize - 1) << 1;
    while (tableSize * DESIRED_LOAD_FACTOR < setSize) {
      tableSize<<=1;
    }
    return tableSize;
  }
  checkArgument(setSize < MAX_TABLE_SIZE,""String_Node_Str"");
  return MAX_TABLE_SIZE;
}",0.9915188897455668
60082,"/** 
 * Returns a new builder. The generated builder is equivalent to the builder created by the   {@link Builder#Builder()} constructor.
 */
public static <R,C,V>Builder<R,C,V> builder(){
  return new Builder<R,C,V>();
}","/** 
 * Returns a new builder. The generated builder is equivalent to the builder created by the   {@link Builder#Builder() ImmutableTable.Builder()} constructor.
 */
public static <R,C,V>Builder<R,C,V> builder(){
  return new Builder<R,C,V>();
}",0.9464668094218416
60083,"/** 
 * @param map
 * @param initialCapacity
 * @param maxSegmentSize
 */
StrongKeyWeakValueSegment(MapMakerInternalMap<K,V,StrongKeyWeakValueEntry<K,V>,StrongKeyWeakValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}","StrongKeyWeakValueSegment(MapMakerInternalMap<K,V,StrongKeyWeakValueEntry<K,V>,StrongKeyWeakValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}",0.8451882845188284
60084,"/** 
 * @param map
 * @param initialCapacity
 * @param maxSegmentSize
 */
WeakKeyStrongValueSegment(MapMakerInternalMap<K,V,WeakKeyStrongValueEntry<K,V>,WeakKeyStrongValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}","WeakKeyStrongValueSegment(MapMakerInternalMap<K,V,WeakKeyStrongValueEntry<K,V>,WeakKeyStrongValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}",0.8451882845188284
60085,"/** 
 * @param map
 * @param initialCapacity
 * @param maxSegmentSize
 */
WeakKeyWeakValueSegment(MapMakerInternalMap<K,V,WeakKeyWeakValueEntry<K,V>,WeakKeyWeakValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}","WeakKeyWeakValueSegment(MapMakerInternalMap<K,V,WeakKeyWeakValueEntry<K,V>,WeakKeyWeakValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}",0.8412017167381974
60086,"/** 
 * @param map
 * @param initialCapacity
 * @param maxSegmentSize
 */
StrongKeyStrongValueSegment(MapMakerInternalMap<K,V,StrongKeyStrongValueEntry<K,V>,StrongKeyStrongValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}","StrongKeyStrongValueSegment(MapMakerInternalMap<K,V,StrongKeyStrongValueEntry<K,V>,StrongKeyStrongValueSegment<K,V>> map,int initialCapacity,int maxSegmentSize){
  super(map,initialCapacity,maxSegmentSize);
}",0.8489795918367347
60087,"/** 
 * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no larger than expectedSize and the load factor is >= its default (0.75).
 */
static int capacity(int expectedSize){
  if (expectedSize < 3) {
    checkNonnegative(expectedSize,""String_Node_Str"");
    return expectedSize + 1;
  }
  if (expectedSize < Ints.MAX_POWER_OF_TWO) {
    return (int)((float)expectedSize / 0.75F + 1.0F);
  }
  return Integer.MAX_VALUE;
}","/** 
 * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no larger than expectedSize and the load factor is  its default (0.75).
 */
static int capacity(int expectedSize){
  if (expectedSize < 3) {
    checkNonnegative(expectedSize,""String_Node_Str"");
    return expectedSize + 1;
  }
  if (expectedSize < Ints.MAX_POWER_OF_TWO) {
    return (int)((float)expectedSize / 0.75F + 1.0F);
  }
  return Integer.MAX_VALUE;
}",0.9967637540453076
60088,"/** 
 * Returns an unmodifiable view of the specified table. This method allows modules to provide users with ""read-only"" access to internal tables. Query operations on the returned table ""read through"" to the specified table, and attempts to modify the returned table, whether direct or via its collection views, result in an   {@code UnsupportedOperationException}. <p>The returned table will be serializable if the specified table is serializable. <p>Consider using an   {@link ImmutableTable}, which is guaranteed never to change.
 * @param table the table for which an unmodifiable view is to be returned
 * @return an unmodifiable view of the specified table
 * @since 11.0
 */
public static <R,C,V>Table<R,C,V> unmodifiableTable(Table<? extends R,? extends C,? extends V> table){
  return new UnmodifiableTable<R,C,V>(table);
}","/** 
 * Returns an unmodifiable view of the specified table. This method allows modules to provide users with ""read-only"" access to internal tables. Query operations on the returned table ""read through"" to the specified table, and attempts to modify the returned table, whether direct or via its collection views, result in an   {@code UnsupportedOperationException}. <p>The returned table will be serializable if the specified table is serializable. <p>Consider using an   {@link ImmutableTable}, which is guaranteed never to change.
 * @since 11.0
 */
public static <R,C,V>Table<R,C,V> unmodifiableTable(Table<? extends R,? extends C,? extends V> table){
  return new UnmodifiableTable<R,C,V>(table);
}",0.9154746423927178
60089,"/** 
 * Partitions the contents of buffer in the range [left, right] around the pivot element previously stored in buffer[pivotValue]. Returns the new index of the pivot element, pivotNewIndex, so that everything in [left, pivotNewIndex] is <= pivotValue and everything in (pivotNewIndex, right] is > pivotValue.
 */
private int partition(int left,int right,int pivotIndex){
  T pivotValue=buffer[pivotIndex];
  buffer[pivotIndex]=buffer[right];
  int pivotNewIndex=left;
  for (int i=left; i < right; i++) {
    if (comparator.compare(buffer[i],pivotValue) < 0) {
      swap(pivotNewIndex,i);
      pivotNewIndex++;
    }
  }
  buffer[right]=buffer[pivotNewIndex];
  buffer[pivotNewIndex]=pivotValue;
  return pivotNewIndex;
}","/** 
 * Partitions the contents of buffer in the range [left, right] around the pivot element previously stored in buffer[pivotValue]. Returns the new index of the pivot element, pivotNewIndex, so that everything in [left, pivotNewIndex] is  pivotValue and everything in (pivotNewIndex, right] is greater than pivotValue.
 */
private int partition(int left,int right,int pivotIndex){
  T pivotValue=buffer[pivotIndex];
  buffer[pivotIndex]=buffer[right];
  int pivotNewIndex=left;
  for (int i=left; i < right; i++) {
    if (comparator.compare(buffer[i],pivotValue) < 0) {
      swap(pivotNewIndex,i);
      pivotNewIndex++;
    }
  }
  buffer[right]=buffer[pivotNewIndex];
  buffer[pivotNewIndex]=pivotValue;
  return pivotNewIndex;
}",0.989071038251366
60090,"private static boolean isEmpty(Iterable<?> iterable){
  return iterable instanceof Collection ? ((Collection<?>)iterable).isEmpty() : iterable.iterator().hasNext();
}","private static boolean isEmpty(Iterable<?> iterable){
  return iterable instanceof Collection ? ((Collection<?>)iterable).isEmpty() : !iterable.iterator().hasNext();
}",0.996996996996997
60091,"public void testIsEmpty_iterable(){
  List<Object> list=new ArrayList<Object>();
  Helpers.assertEmpty(list);
  list.add(""String_Node_Str"");
  try {
    Helpers.assertEmpty(list);
    throw new Error();
  }
 catch (  AssertionFailedError expected) {
  }
}","public void testIsEmpty_iterable(){
  List<Object> list=new ArrayList<Object>();
  Helpers.assertEmpty(list);
  Helpers.assertEmpty(new Iterable<Object>(){
    @Override public Iterator<Object> iterator(){
      return Collections.emptyList().iterator();
    }
  }
);
  list.add(""String_Node_Str"");
  try {
    Helpers.assertEmpty(list);
    throw new Error();
  }
 catch (  AssertionFailedError expected) {
  }
  try {
    Helpers.assertEmpty(new Iterable<String>(){
      @Override public Iterator<String> iterator(){
        return Collections.singleton(""String_Node_Str"").iterator();
      }
    }
);
    throw new Error();
  }
 catch (  AssertionFailedError expected) {
  }
}",0.5433155080213904
60092,"@GwtIncompatible public void testRoundFractionalDoubleToInt(){
  for (  double d : FRACTIONAL_DOUBLE_CANDIDATES) {
    for (    RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {
      BigDecimal expected=new BigDecimal(d).setScale(0,mode);
      boolean isInBounds=expected.compareTo(MAX_INT_AS_BIG_DECIMAL) <= 0 & expected.compareTo(MIN_INT_AS_BIG_DECIMAL) >= 0;
      try {
        assertEquals(expected.intValue(),DoubleMath.roundToInt(d,mode));
        assertTrue(isInBounds);
      }
 catch (      ArithmeticException e) {
        assertFalse(isInBounds);
      }
    }
  }
}","@GwtIncompatible public void testRoundFractionalDoubleToInt(){
  for (  double d : FRACTIONAL_DOUBLE_CANDIDATES) {
    for (    RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {
      BigDecimal expected=new BigDecimal(d).setScale(0,mode);
      boolean isInBounds=expected.compareTo(MAX_INT_AS_BIG_DECIMAL) <= 0 & expected.compareTo(MIN_INT_AS_BIG_DECIMAL) >= 0;
      try {
        assertEquals(""String_Node_Str"" + d + ""String_Node_Str""+ mode,expected.intValue(),DoubleMath.roundToInt(d,mode));
        assertTrue(isInBounds);
      }
 catch (      ArithmeticException e) {
        assertFalse(isInBounds);
      }
    }
  }
}",0.9600665557404326
60093,"@GwtIncompatible static double roundIntermediate(double x,RoundingMode mode){
  if (!isFinite(x)) {
    throw new ArithmeticException(""String_Node_Str"");
  }
switch (mode) {
case UNNECESSARY:
    checkRoundingUnnecessary(isMathematicalInteger(x));
  return x;
case FLOOR:
if (x >= 0.0 || isMathematicalInteger(x)) {
  return x;
}
 else {
  return x - 1.0;
}
case CEILING:
if (x <= 0.0 || isMathematicalInteger(x)) {
return x;
}
 else {
return x + 1.0;
}
case DOWN:
return x;
case UP:
if (isMathematicalInteger(x)) {
return x;
}
 else {
return x + Math.copySign(1.0,x);
}
case HALF_EVEN:
return rint(x);
case HALF_UP:
{
double z=rint(x);
if (abs(x - z) == 0.5) {
return x + copySign(0.5,x);
}
 else {
return z;
}
}
case HALF_DOWN:
{
double z=rint(x);
if (abs(x - z) == 0.5) {
return x;
}
 else {
return z;
}
}
default :
throw new AssertionError();
}
}","@GwtIncompatible static double roundIntermediate(double x,RoundingMode mode){
  if (!isFinite(x)) {
    throw new ArithmeticException(""String_Node_Str"");
  }
switch (mode) {
case UNNECESSARY:
    checkRoundingUnnecessary(isMathematicalInteger(x));
  return x;
case FLOOR:
if (x >= 0.0 || isMathematicalInteger(x)) {
  return x;
}
 else {
  return (long)x - 1;
}
case CEILING:
if (x <= 0.0 || isMathematicalInteger(x)) {
return x;
}
 else {
return (long)x + 1;
}
case DOWN:
return x;
case UP:
if (isMathematicalInteger(x)) {
return x;
}
 else {
return (long)x + (x > 0 ? 1 : -1);
}
case HALF_EVEN:
return rint(x);
case HALF_UP:
{
double z=rint(x);
if (abs(x - z) == 0.5) {
return x + copySign(0.5,x);
}
 else {
return z;
}
}
case HALF_DOWN:
{
double z=rint(x);
if (abs(x - z) == 0.5) {
return x;
}
 else {
return z;
}
}
default :
throw new AssertionError();
}
}",0.968421052631579
60094,"boolean isPermitted(RuntimeException exception){
  for (  Class<? extends RuntimeException> clazz : exceptionClasses) {
    if (Platform.checkIsInstance(clazz,exception)) {
      return true;
    }
  }
  return false;
}",abstract boolean isPermitted(RuntimeException exception);,0.3478260869565217
60095,"private PermittedMetaException(Class<? extends RuntimeException> exceptionClass){
  this(Collections.singleton(exceptionClass));
}","private PermittedMetaException(String message){
  super(message);
}",0.4873096446700508
60096,"private static void assertFailure(IteratorTester<?> tester){
  try {
    tester.test();
    fail();
  }
 catch (  AssertionFailedError expected) {
  }
}","private static void assertFailure(IteratorTester<?> tester){
  try {
    tester.test();
  }
 catch (  AssertionFailedError expected) {
    return;
  }
  fail();
}",0.89171974522293
60097,"@Override public void invalidate(Object key){
  key=checkNotNull(key);
  localCache.remove(key);
}","@Override public void invalidate(Object key){
  checkNotNull(key);
  localCache.remove(key);
}",0.9791666666666666
60098,"/** 
 * Returns true iff the configuration defined by this object is <i>compatible with</i> the configuration defined by   {@code that}.  Intuitively, this checks for structural properties and ignores non-structural properties.  Specifically, this method checks whether the configurations have compatible support for: <ul> <li>parallel edges <li>self-loops </ul> <p>It does not compare expected values for numbers of edges or nodes, and it is not equivalent to   {@code Object.equals}.
 */
public boolean compatibleWith(GraphConfig that){
  checkNotNull(that,""String_Node_Str"");
  return this.multigraph == that.multigraph && this.selfLoopsAllowed == that.selfLoopsAllowed;
}","/** 
 * Returns true iff the configuration defined by this object is <i>compatible with</i> the configuration defined by   {@code that}.  Intuitively, this checks for structural properties and ignores non-structural properties.  Specifically, this method checks whether the configurations have compatible support for: <ul> <li>parallel edges <li>self-loops </ul> By ""compatible with"", we mean that this instance must be at least as permissive as the input config (  {@code that}).  Thus, for example, if the input permits parallel edges, this instance must also permit parallel edges in order for the configurations to be compatible. <p>It does not compare expected values for numbers of edges or nodes, and it is not equivalent to   {@code Object.equals}.
 */
public boolean compatibleWith(GraphConfig that){
  checkNotNull(that,""String_Node_Str"");
  if (that.multigraph && !this.multigraph) {
    return false;
  }
  if (that.selfLoopsAllowed && !this.selfLoopsAllowed) {
    return false;
  }
  return true;
}",0.7611144042679312
60099,"public void testNull(){
  try {
    map.putInstance((TypeToken)null,new Integer(1));
    fail();
  }
 catch (  NullPointerException expected) {
  }
  map.putInstance(Integer.class,null);
  assertNull(map.get((Object)Integer.class));
  assertNull(map.getInstance(Integer.class));
  map.putInstance(Long.class,null);
  assertNull(map.get((Object)Long.class));
  assertNull(map.getInstance(Long.class));
}","public void testNull(){
  try {
    map.putInstance((TypeToken)null,new Integer(1));
    fail();
  }
 catch (  NullPointerException expected) {
  }
  map.putInstance(Integer.class,null);
  assertTrue(map.containsKey(TypeToken.of(Integer.class)));
  assertTrue(map.entrySet().contains(immutableEntry(TypeToken.of(Integer.class),null)));
  assertNull(map.get(TypeToken.of(Integer.class)));
  assertNull(map.getInstance(Integer.class));
  map.putInstance(Long.class,null);
  assertTrue(map.containsKey(TypeToken.of(Long.class)));
  assertTrue(map.entrySet().contains(immutableEntry(TypeToken.of(Long.class),null)));
  assertNull(map.get(TypeToken.of(Long.class)));
  assertNull(map.getInstance(Long.class));
}",0.5090252707581228
60100,"/** 
 * Returns a   {@code ClassPath} representing all classes and resources loadable from {@code classloader} and its parent class loaders.<p>Currently only  {@link URLClassLoader} and only {@code file://} urls are supported.
 * @throws IOException if the attempt to read class path resources (jar files or directories)failed.
 */
public static ClassPath from(ClassLoader classloader) throws IOException {
  DefaultScanner scanner=new DefaultScanner();
  scanner.scan(classloader);
  return new ClassPath(scanner.getResources());
}","/** 
 * Returns a   {@code ClassPath} representing all classes and resources loadable from {@code classloader} and its parent class loaders.<p><b>Warning:</b> Currently only  {@link URLClassLoader} and only {@code file://} urls aresupported.
 * @throws IOException if the attempt to read class path resources (jar files or directories)failed.
 */
public static ClassPath from(ClassLoader classloader) throws IOException {
  DefaultScanner scanner=new DefaultScanner();
  scanner.scan(classloader);
  return new ClassPath(scanner.getResources());
}",0.9842446709916588
60101,"/** 
 * Create a suite whose maps are descending views of other maps.
 */
private TestSuite createDescendingSuite(final FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>> parentBuilder){
  final TestMapGenerator<K,V> delegate=(TestMapGenerator<K,V>)parentBuilder.getSubjectGenerator().getInnerGenerator();
  List<Feature<?>> features=new ArrayList<Feature<?>>();
  features.add(NoRecurse.DESCENDING);
  features.addAll(parentBuilder.getFeatures());
  return NavigableMapTestSuiteBuilder.using(new ForwardingTestMapGenerator<K,V>(delegate){
    @Override public Map<K,V> create(    Object... entries){
      NavigableMap<K,V> map=(NavigableMap<K,V>)delegate.create(entries);
      return map.descendingMap();
    }
    @Override public Iterable<Entry<K,V>> order(    List<Entry<K,V>> insertionOrder){
      insertionOrder=castOrCopyToList(delegate.order(insertionOrder));
      reverse(insertionOrder);
      return insertionOrder;
    }
  }
).named(parentBuilder.getName() + ""String_Node_Str"").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();
}","/** 
 * Create a suite whose maps are descending views of other maps.
 */
private TestSuite createDescendingSuite(final FeatureSpecificTestSuiteBuilder<?,? extends OneSizeTestContainerGenerator<Map<K,V>,Entry<K,V>>> parentBuilder){
  final TestSortedMapGenerator<K,V> delegate=(TestSortedMapGenerator<K,V>)parentBuilder.getSubjectGenerator().getInnerGenerator();
  List<Feature<?>> features=new ArrayList<Feature<?>>();
  features.add(NoRecurse.DESCENDING);
  features.addAll(parentBuilder.getFeatures());
  return NavigableMapTestSuiteBuilder.using(new DescendingTestMapGenerator<K,V>(delegate)).named(parentBuilder.getName() + ""String_Node_Str"").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();
}",0.7715355805243446
60102,"@Override public Map<K,V> create(Object... elements){
  return delegate.create(elements);
}","@Override public NavigableMap<K,V> create(Object... entries){
  NavigableMap<K,V> map=(NavigableMap<K,V>)delegate.create(entries);
  return map.descendingMap();
}",0.616600790513834
60103,"@Override public Iterable<Entry<K,V>> order(List<Entry<K,V>> insertionOrder){
  return delegate.order(insertionOrder);
}","@Override public Iterable<Entry<K,V>> order(List<Entry<K,V>> insertionOrder){
  insertionOrder=castOrCopyToList(delegate.order(insertionOrder));
  reverse(insertionOrder);
  return insertionOrder;
}",0.7358490566037735
60104,"@GwtIncompatible(""String_Node_Str"") public void testCheckedSubtract(){
  for (  long a : ALL_INTEGER_CANDIDATES) {
    for (    long b : ALL_INTEGER_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).subtract(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a - b,LongMath.checkedSubtract(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}","@GwtIncompatible(""String_Node_Str"") public void testCheckedSubtract(){
  for (  long a : ALL_LONG_CANDIDATES) {
    for (    long b : ALL_LONG_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).subtract(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a - b,LongMath.checkedSubtract(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}",0.985858585858586
60105,"@GwtIncompatible(""String_Node_Str"") public void testCheckedPow(){
  for (  long b : ALL_INTEGER_CANDIDATES) {
    for (    int exp : EXPONENTS) {
      BigInteger expectedResult=valueOf(b).pow(exp);
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(expectedResult.longValue(),LongMath.checkedPow(b,exp));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}","@GwtIncompatible(""String_Node_Str"") public void testCheckedPow(){
  for (  long b : ALL_LONG_CANDIDATES) {
    for (    int exp : EXPONENTS) {
      BigInteger expectedResult=valueOf(b).pow(exp);
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(expectedResult.longValue(),LongMath.checkedPow(b,exp));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}",0.9927909371781668
60106,"@GwtIncompatible(""String_Node_Str"") public void testCheckedMultiply(){
  for (  long a : ALL_INTEGER_CANDIDATES) {
    for (    long b : ALL_INTEGER_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).multiply(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a * b,LongMath.checkedMultiply(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}","@GwtIncompatible(""String_Node_Str"") public void testCheckedMultiply(){
  for (  long a : ALL_LONG_CANDIDATES) {
    for (    long b : ALL_LONG_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).multiply(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a * b,LongMath.checkedMultiply(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}",0.985858585858586
60107,"@GwtIncompatible(""String_Node_Str"") public void testCheckedAdd(){
  for (  long a : ALL_INTEGER_CANDIDATES) {
    for (    long b : ALL_INTEGER_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).add(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a + b,LongMath.checkedAdd(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}","@GwtIncompatible(""String_Node_Str"") public void testCheckedAdd(){
  for (  long a : ALL_LONG_CANDIDATES) {
    for (    long b : ALL_LONG_CANDIDATES) {
      BigInteger expectedResult=valueOf(a).add(valueOf(b));
      boolean expectedSuccess=fitsInLong(expectedResult);
      try {
        assertEquals(a + b,LongMath.checkedAdd(a,b));
        assertTrue(expectedSuccess);
      }
 catch (      ArithmeticException e) {
        assertFalse(expectedSuccess);
      }
    }
  }
}",0.9854166666666668
60108,"/** 
 * Returns the   {@code b} to the {@code k}th power, provided it does not overflow.
 * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed  {@code long} arithmetic
 */
@GwtIncompatible(""String_Node_Str"") public static long checkedPow(long b,int k){
  checkNonNegative(""String_Node_Str"",k);
  if (b >= -2 & b <= 2) {
switch ((int)b) {
case 0:
      return (k == 0) ? 1 : 0;
case 1:
    return 1;
case (-1):
  return ((k & 1) == 0) ? 1 : -1;
case 2:
checkNoOverflow(k < Long.SIZE - 1);
return 1L << k;
case (-2):
checkNoOverflow(k < Long.SIZE);
return ((k & 1) == 0) ? (1L << k) : (-1L << k);
default :
throw new AssertionError();
}
}
long accum=1;
while (true) {
switch (k) {
case 0:
return accum;
case 1:
return checkedMultiply(accum,b);
default :
if ((k & 1) != 0) {
accum=checkedMultiply(accum,b);
}
k>>=1;
if (k > 0) {
checkNoOverflow(b <= FLOOR_SQRT_MAX_LONG);
b*=b;
}
}
}
}","/** 
 * Returns the   {@code b} to the {@code k}th power, provided it does not overflow.
 * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed  {@code long} arithmetic
 */
@GwtIncompatible(""String_Node_Str"") public static long checkedPow(long b,int k){
  checkNonNegative(""String_Node_Str"",k);
  if (b >= -2 & b <= 2) {
switch ((int)b) {
case 0:
      return (k == 0) ? 1 : 0;
case 1:
    return 1;
case (-1):
  return ((k & 1) == 0) ? 1 : -1;
case 2:
checkNoOverflow(k < Long.SIZE - 1);
return 1L << k;
case (-2):
checkNoOverflow(k < Long.SIZE);
return ((k & 1) == 0) ? (1L << k) : (-1L << k);
default :
throw new AssertionError();
}
}
long accum=1;
while (true) {
switch (k) {
case 0:
return accum;
case 1:
return checkedMultiply(accum,b);
default :
if ((k & 1) != 0) {
accum=checkedMultiply(accum,b);
}
k>>=1;
if (k > 0) {
checkNoOverflow(-FLOOR_SQRT_MAX_LONG <= b && b <= FLOOR_SQRT_MAX_LONG);
b*=b;
}
}
}
}",0.9790660225442834
60109,"@Override public Iterator<Entry<V,K>> iterator(){
  return new Itr<Entry<V,K>>(){
    @Override Entry<V,K> output(    BiEntry<K,V> entry){
      return new InverseEntry(entry);
    }
class InverseEntry extends AbstractMapEntry<V,K> {
      BiEntry<K,V> delegate;
      InverseEntry(      BiEntry<K,V> entry){
        this.delegate=entry;
      }
      @Override public V getKey(){
        return delegate.value;
      }
      @Override public K getValue(){
        return delegate.key;
      }
      @Override public K setValue(      K key){
        K oldKey=delegate.key;
        int keyHash=smearedHash(key);
        if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
          return key;
        }
        checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
        delete(delegate);
        BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
        insert(newEntry);
        expectedModCount=modCount;
        return oldKey;
      }
    }
  }
;
}","@Override public Iterator<Entry<V,K>> iterator(){
  return new Itr<Entry<V,K>>(){
    @Override Entry<V,K> output(    BiEntry<K,V> entry){
      return new InverseEntry(entry);
    }
class InverseEntry extends AbstractMapEntry<V,K> {
      BiEntry<K,V> delegate;
      InverseEntry(      BiEntry<K,V> entry){
        this.delegate=entry;
      }
      @Override public V getKey(){
        return delegate.value;
      }
      @Override public K getValue(){
        return delegate.key;
      }
      @Override public K setValue(      K key){
        K oldKey=delegate.key;
        int keyHash=smearedHash(key);
        if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
          return key;
        }
        checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
        delete(delegate);
        BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
        delegate=newEntry;
        insert(newEntry);
        expectedModCount=modCount;
        return oldKey;
      }
    }
  }
;
}",0.98691226369365
60110,"@Override public Set<Entry<V,K>> entrySet(){
  return new Maps.EntrySet<V,K>(){
    @Override Map<V,K> map(){
      return Inverse.this;
    }
    @Override public Iterator<Entry<V,K>> iterator(){
      return new Itr<Entry<V,K>>(){
        @Override Entry<V,K> output(        BiEntry<K,V> entry){
          return new InverseEntry(entry);
        }
class InverseEntry extends AbstractMapEntry<V,K> {
          BiEntry<K,V> delegate;
          InverseEntry(          BiEntry<K,V> entry){
            this.delegate=entry;
          }
          @Override public V getKey(){
            return delegate.value;
          }
          @Override public K getValue(){
            return delegate.key;
          }
          @Override public K setValue(          K key){
            K oldKey=delegate.key;
            int keyHash=smearedHash(key);
            if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
              return key;
            }
            checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
            delete(delegate);
            BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
            insert(newEntry);
            expectedModCount=modCount;
            return oldKey;
          }
        }
      }
;
    }
  }
;
}","@Override public Set<Entry<V,K>> entrySet(){
  return new Maps.EntrySet<V,K>(){
    @Override Map<V,K> map(){
      return Inverse.this;
    }
    @Override public Iterator<Entry<V,K>> iterator(){
      return new Itr<Entry<V,K>>(){
        @Override Entry<V,K> output(        BiEntry<K,V> entry){
          return new InverseEntry(entry);
        }
class InverseEntry extends AbstractMapEntry<V,K> {
          BiEntry<K,V> delegate;
          InverseEntry(          BiEntry<K,V> entry){
            this.delegate=entry;
          }
          @Override public V getKey(){
            return delegate.value;
          }
          @Override public K getValue(){
            return delegate.key;
          }
          @Override public K setValue(          K key){
            K oldKey=delegate.key;
            int keyHash=smearedHash(key);
            if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
              return key;
            }
            checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
            delete(delegate);
            BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
            delegate=newEntry;
            insert(newEntry);
            expectedModCount=modCount;
            return oldKey;
          }
        }
      }
;
    }
  }
;
}",0.9882620219613782
60111,"@Override public K setValue(K key){
  K oldKey=delegate.key;
  int keyHash=smearedHash(key);
  if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
    return key;
  }
  checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
  delete(delegate);
  BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
  insert(newEntry);
  expectedModCount=modCount;
  return oldKey;
}","@Override public K setValue(K key){
  K oldKey=delegate.key;
  int keyHash=smearedHash(key);
  if (keyHash == delegate.keyHash && Objects.equal(key,oldKey)) {
    return key;
  }
  checkArgument(seekByKey(key,keyHash) == null,""String_Node_Str"",key);
  delete(delegate);
  BiEntry<K,V> newEntry=new BiEntry<K,V>(key,keyHash,delegate.value,delegate.valueHash);
  delegate=newEntry;
  insert(newEntry);
  expectedModCount=modCount;
  return oldKey;
}",0.9599083619702176
60112,"/** 
 * Checks if the executor has been shut down and increments the running task count.
 * @throws RejectedExecutionException if the executor has been previouslyshutdown
 */
private void startTask(){
  lock.lock();
  try {
    if (isShutdown()) {
      throw new RejectedExecutionException(""String_Node_Str"");
    }
    runningTasks++;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Checks if the executor has been shut down and increments the running task count.
 * @throws RejectedExecutionException if the executor has been previouslyshutdown
 */
private void startTask(){
synchronized (lock) {
    if (shutdown) {
      throw new RejectedExecutionException(""String_Node_Str"");
    }
    runningTasks++;
  }
}",0.8515406162464986
60113,"/** 
 * Decrements the running task count.
 */
private void endTask(){
  lock.lock();
  try {
    runningTasks--;
    if (isTerminated()) {
      termination.signalAll();
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Decrements the running task count.
 */
private void endTask(){
synchronized (lock) {
    int numRunning=--runningTasks;
    if (numRunning == 0) {
      lock.notifyAll();
    }
  }
}",0.687960687960688
60114,"@Benchmark int addThenExecute_multiThreaded(final int reps) throws InterruptedException {
  Runnable addTask=new Runnable(){
    @Override public void run(){
      for (int i=0; i < numListeners; i++) {
        list.add(listener,directExecutor());
      }
    }
  }
;
  int returnValue=0;
  for (int i=0; i < reps; i++) {
    list=impl.newExecutionList();
    listenerLatch=new CountDownLatch(numListeners * NUM_THREADS);
    for (int j=0; j < NUM_THREADS; j++) {
      executorService.submit(addTask);
    }
    executorService.submit(executeTask);
    returnValue=(int)listenerLatch.getCount();
    listenerLatch.await();
  }
  return returnValue;
}","@Benchmark int addThenExecute_multiThreaded(final int reps) throws InterruptedException {
  Runnable addTask=new Runnable(){
    @Override public void run(){
      for (int i=0; i < numListeners; i++) {
        list.add(listener,directExecutor());
      }
    }
  }
;
  int returnValue=0;
  for (int i=0; i < reps; i++) {
    list=impl.newExecutionList();
    listenerLatch=new CountDownLatch(numListeners * NUM_THREADS);
    for (int j=0; j < NUM_THREADS; j++) {
      executorService.submit(addTask);
    }
    executorService.submit(executeTask);
    returnValue+=(int)listenerLatch.getCount();
    listenerLatch.await();
  }
  return returnValue;
}",0.9992325402916348
60115,"@Override public Object getImpl(){
  return list;
}","@Override public Object getImpl(){
  return future;
}",0.9230769230769232
60116,"@BeforeExperiment void setUp() throws Exception {
  executorService=new ThreadPoolExecutor(NUM_THREADS,NUM_THREADS,Long.MAX_VALUE,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(1000));
  final AtomicInteger integer=new AtomicInteger();
  for (int i=0; i < NUM_THREADS * 10; i++) {
    executorService.submit(new Runnable(){
      @Override public void run(){
        integer.getAndIncrement();
      }
    }
);
  }
}","@BeforeExperiment void setUp() throws Exception {
  executorService=new ThreadPoolExecutor(NUM_THREADS,NUM_THREADS,Long.MAX_VALUE,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(1000));
  executorService.prestartAllCoreThreads();
  final AtomicInteger integer=new AtomicInteger();
  for (int i=0; i < NUM_THREADS * 10; i++) {
    executorService.submit(new Runnable(){
      @Override public void run(){
        integer.getAndIncrement();
      }
    }
);
  }
}",0.9501133786848072
60117,"@Benchmark int executeThenAdd_multiThreaded(final int reps) throws InterruptedException {
  Runnable addTask=new Runnable(){
    @Override public void run(){
      for (int i=0; i < numListeners; i++) {
        list.add(listener,directExecutor());
      }
    }
  }
;
  int returnValue=0;
  for (int i=0; i < reps; i++) {
    list=impl.newExecutionList();
    listenerLatch=new CountDownLatch(numListeners * NUM_THREADS);
    executorService.submit(executeTask);
    for (int j=0; j < NUM_THREADS; j++) {
      executorService.submit(addTask);
    }
    returnValue=(int)listenerLatch.getCount();
    listenerLatch.await();
  }
  return returnValue;
}","@Benchmark int executeThenAdd_multiThreaded(final int reps) throws InterruptedException {
  Runnable addTask=new Runnable(){
    @Override public void run(){
      for (int i=0; i < numListeners; i++) {
        list.add(listener,directExecutor());
      }
    }
  }
;
  int returnValue=0;
  for (int i=0; i < reps; i++) {
    list=impl.newExecutionList();
    listenerLatch=new CountDownLatch(numListeners * NUM_THREADS);
    executorService.submit(executeTask);
    for (int j=0; j < NUM_THREADS; j++) {
      executorService.submit(addTask);
    }
    returnValue+=(int)listenerLatch.getCount();
    listenerLatch.await();
  }
  return returnValue;
}",0.9992325402916348
60118,"private Range(Cut<C> lowerBound,Cut<C> upperBound){
  if (lowerBound.compareTo(upperBound) > 0 || lowerBound == Cut.<C>aboveAll() || upperBound == Cut.<C>belowAll()) {
    throw new IllegalArgumentException(""String_Node_Str"" + toString(lowerBound,upperBound));
  }
  this.lowerBound=checkNotNull(lowerBound);
  this.upperBound=checkNotNull(upperBound);
}","private Range(Cut<C> lowerBound,Cut<C> upperBound){
  this.lowerBound=checkNotNull(lowerBound);
  this.upperBound=checkNotNull(upperBound);
  if (lowerBound.compareTo(upperBound) > 0 || lowerBound == Cut.<C>aboveAll() || upperBound == Cut.<C>belowAll()) {
    throw new IllegalArgumentException(""String_Node_Str"" + toString(lowerBound,upperBound));
  }
}",0.751412429378531
60119,"private void testEqualsUsing(final Invokable<?,?> factory) throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException, IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
  List<Parameter> params=factory.getParameters();
  List<FreshValueGenerator> argGenerators=Lists.newArrayListWithCapacity(params.size());
  List<Object> args=Lists.newArrayListWithCapacity(params.size());
  for (  Parameter param : params) {
    FreshValueGenerator generator=newFreshValueGenerator();
    argGenerators.add(generator);
    args.add(generateDummyArg(param,generator));
  }
  Object instance=createInstance(factory,args);
  List<Object> equalArgs=generateEqualFactoryArguments(factory,params,args);
  final List<List<List<Object>>> argGroups=Lists.newArrayList();
  argGroups.add(ImmutableList.of(args,equalArgs));
  EqualsTester tester=new EqualsTester(new ItemReporter(){
    @Override String reportItem(    Item<?> item){
      List<Object> factoryArgs=argGroups.get(item.groupNumber).get(item.itemNumber);
      return factory.getName() + ""String_Node_Str"" + Joiner.on(""String_Node_Str"").useForNull(""String_Node_Str"").join(factoryArgs)+ ""String_Node_Str"";
    }
  }
);
  tester.addEqualityGroup(instance,createInstance(factory,equalArgs));
  for (int i=0; i < params.size(); i++) {
    List<Object> newArgs=Lists.newArrayList(args);
    Object newArg=argGenerators.get(i).generate(params.get(i).getType());
    if (newArg == null || Objects.equal(args.get(i),newArg)) {
      if (params.get(i).getType().getRawType().isEnum()) {
        continue;
      }
      throw new ParameterHasNoDistinctValueException(params.get(i));
    }
    newArgs.set(i,newArg);
    tester.addEqualityGroup(createInstance(factory,newArgs));
    argGroups.add(ImmutableList.of(newArgs));
  }
  tester.testEquals();
}","private void testEqualsUsing(final Invokable<?,?> factory) throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException, IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
  List<Parameter> params=factory.getParameters();
  List<FreshValueGenerator> argGenerators=Lists.newArrayListWithCapacity(params.size());
  List<Object> args=Lists.newArrayListWithCapacity(params.size());
  for (  Parameter param : params) {
    FreshValueGenerator generator=newFreshValueGenerator();
    argGenerators.add(generator);
    args.add(generateDummyArg(param,generator));
  }
  Object instance=createInstance(factory,args);
  List<Object> equalArgs=generateEqualFactoryArguments(factory,params,args);
  final List<List<List<Object>>> argGroups=Lists.newArrayList();
  argGroups.add(ImmutableList.of(args,equalArgs));
  EqualsTester tester=new EqualsTester(new ItemReporter(){
    @Override String reportItem(    Item<?> item){
      List<Object> factoryArgs=argGroups.get(item.groupNumber).get(item.itemNumber);
      return factory.getName() + ""String_Node_Str"" + Joiner.on(""String_Node_Str"").useForNull(""String_Node_Str"").join(factoryArgs)+ ""String_Node_Str"";
    }
  }
);
  tester.addEqualityGroup(instance,createInstance(factory,equalArgs));
  for (int i=0; i < params.size(); i++) {
    List<Object> newArgs=Lists.newArrayList(args);
    Object newArg=argGenerators.get(i).generateFresh(params.get(i).getType());
    if (newArg == null || Objects.equal(args.get(i),newArg)) {
      if (params.get(i).getType().getRawType().isEnum()) {
        continue;
      }
      throw new ParameterHasNoDistinctValueException(params.get(i));
    }
    newArgs.set(i,newArg);
    tester.addEqualityGroup(createInstance(factory,newArgs));
    argGroups.add(ImmutableList.of(newArgs));
  }
  tester.testEquals();
}",0.9986424110779256
60120,"private static @Nullable Object generateDummyArg(Parameter param,FreshValueGenerator generator) throws ParameterNotInstantiableException {
  if (param.isAnnotationPresent(Nullable.class)) {
    return null;
  }
  Object arg=generator.generate(param.getType());
  if (arg == null) {
    throw new ParameterNotInstantiableException(param);
  }
  return arg;
}","private static @Nullable Object generateDummyArg(Parameter param,FreshValueGenerator generator) throws ParameterNotInstantiableException {
  if (param.isAnnotationPresent(Nullable.class)) {
    return null;
  }
  Object arg=generator.generateFresh(param.getType());
  if (arg == null) {
    throw new ParameterNotInstantiableException(param);
  }
  return arg;
}",0.9930458970792768
60121,"private static Object[] getParameterValues(Method method){
  FreshValueGenerator paramValues=new FreshValueGenerator();
  final List<Object> passedArgs=Lists.newArrayList();
  for (  Class<?> paramType : method.getParameterTypes()) {
    passedArgs.add(paramValues.generate(paramType));
  }
  return passedArgs.toArray();
}","private static Object[] getParameterValues(Method method){
  FreshValueGenerator paramValues=new FreshValueGenerator();
  final List<Object> passedArgs=Lists.newArrayList();
  for (  Class<?> paramType : method.getParameterTypes()) {
    passedArgs.add(paramValues.generateFresh(paramType));
  }
  return passedArgs.toArray();
}",0.9923195084485408
60122,"private static <T>void testToString(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  T proxy=new FreshValueGenerator().newProxy(interfaceType);
  assertEquals(""String_Node_Str"",proxy.toString(),wrapperFunction.apply(proxy).toString());
}","private static <T>void testToString(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  T proxy=new FreshValueGenerator().newFreshProxy(interfaceType);
  assertEquals(""String_Node_Str"",proxy.toString(),wrapperFunction.apply(proxy).toString());
}",0.9905838041431262
60123,"InteractionTester(Class<T> interfaceType,Method method){
  this.interfaceType=interfaceType;
  this.method=method;
  this.passedArgs=getParameterValues(method);
  this.returnValue=new FreshValueGenerator().generate(method.getReturnType());
}","InteractionTester(Class<T> interfaceType,Method method){
  this.interfaceType=interfaceType;
  this.method=method;
  this.passedArgs=getParameterValues(method);
  this.returnValue=new FreshValueGenerator().generateFresh(method.getReturnType());
}",0.9897330595482546
60124,"private static <T>void testEquals(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  FreshValueGenerator generator=new FreshValueGenerator();
  T instance=generator.newProxy(interfaceType);
  new EqualsTester().addEqualityGroup(wrapperFunction.apply(instance),wrapperFunction.apply(instance)).addEqualityGroup(wrapperFunction.apply(generator.newProxy(interfaceType))).testEquals();
}","private static <T>void testEquals(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  FreshValueGenerator generator=new FreshValueGenerator();
  T instance=generator.newFreshProxy(interfaceType);
  new EqualsTester().addEqualityGroup(wrapperFunction.apply(instance),wrapperFunction.apply(instance)).addEqualityGroup(wrapperFunction.apply(generator.newFreshProxy(interfaceType))).testEquals();
}",0.9878640776699028
60125,"ReferenceEntry<K,V> getNextEvictable(){
  for (  ReferenceEntry<K,V> e : accessQueue) {
    int weight=e.getValueReference().getWeight();
    if (weight > 0) {
      return e;
    }
  }
  throw new AssertionError();
}","@GuardedBy(""String_Node_Str"") ReferenceEntry<K,V> getNextEvictable(){
  for (  ReferenceEntry<K,V> e : accessQueue) {
    int weight=e.getValueReference().getWeight();
    if (weight > 0) {
      return e;
    }
  }
  throw new AssertionError();
}",0.9353448275862069
60126,"/** 
 * Tests that the forwarding wrapper returned by   {@code wrapperFunction} properly forwardsmethod calls with parameters passed as is, return value returned as is, and exceptions propagated as is.
 */
public <T>void testForwarding(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  checkNotNull(wrapperFunction);
  checkArgument(interfaceType.isInterface(),""String_Node_Str"",interfaceType);
  Method[] methods=getMostConcreteMethods(interfaceType);
  AccessibleObject.setAccessible(methods,true);
  for (  Method method : methods) {
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class) {
      continue;
    }
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 0) {
      continue;
    }
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 0) {
      continue;
    }
    testSuccessfulForwarding(interfaceType,method,wrapperFunction);
    testExceptionPropagation(interfaceType,method,wrapperFunction);
  }
  if (testsEquals) {
    testEquals(interfaceType,wrapperFunction);
  }
  testToString(interfaceType,wrapperFunction);
}","/** 
 * Tests that the forwarding wrapper returned by   {@code wrapperFunction} properly forwardsmethod calls with parameters passed as is, return value returned as is, and exceptions propagated as is.
 */
public <T>void testForwarding(Class<T> interfaceType,Function<? super T,? extends T> wrapperFunction){
  checkNotNull(wrapperFunction);
  checkArgument(interfaceType.isInterface(),""String_Node_Str"",interfaceType);
  Method[] methods=getMostConcreteMethods(interfaceType);
  AccessibleObject.setAccessible(methods,true);
  for (  Method method : methods) {
    if (!Modifier.isAbstract(method.getModifiers())) {
      continue;
    }
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class) {
      continue;
    }
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 0) {
      continue;
    }
    if (method.getName().equals(""String_Node_Str"") && method.getParameterTypes().length == 0) {
      continue;
    }
    testSuccessfulForwarding(interfaceType,method,wrapperFunction);
    testExceptionPropagation(interfaceType,method,wrapperFunction);
  }
  if (testsEquals) {
    testEquals(interfaceType,wrapperFunction);
  }
  testToString(interfaceType,wrapperFunction);
}",0.969529085872576
60127,"/** 
 * Returns   {@code n!}, that is, the product of the first   {@code n} positiveintegers,  {@code 1} if {@code n == 0}, or e n!}, or  {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}. <p>The result is within 1 ulp of the true value.
 * @throws IllegalArgumentException if {@code n < 0}
 */
public static double factorial(int n){
  checkNonNegative(""String_Node_Str"",n);
  if (n > MAX_FACTORIAL) {
    return Double.POSITIVE_INFINITY;
  }
 else {
    double accum=1.0;
    for (int i=1 + (n & ~0xf); i <= n; i++) {
      accum*=i;
    }
    return accum * everySixteenthFactorial[n >> 4];
  }
}","/** 
 * Returns   {@code n!}, that is, the product of the first   {@code n} positiveintegers,  {@code 1} if {@code n == 0}, or   {@code n!}, or  {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}. <p>The result is within 1 ulp of the true value.
 * @throws IllegalArgumentException if {@code n < 0}
 */
public static double factorial(int n){
  checkNonNegative(""String_Node_Str"",n);
  if (n > MAX_FACTORIAL) {
    return Double.POSITIVE_INFINITY;
  }
 else {
    double accum=1.0;
    for (int i=1 + (n & ~0xf); i <= n; i++) {
      accum*=i;
    }
    return accum * everySixteenthFactorial[n >> 4];
  }
}",0.994331983805668
60128,"/** 
 * Returns   {@code n!}, that is, the product of the first   {@code n} positiveintegers,  {@code 1} if {@code n == 0}, or e n!}, or  {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}. <p>The result is within 1 ulp of the true value.
 * @throws IllegalArgumentException if {@code n < 0}
 */
public static double factorial(int n){
  checkNonNegative(""String_Node_Str"",n);
  if (n > MAX_FACTORIAL) {
    return Double.POSITIVE_INFINITY;
  }
 else {
    double accum=1.0;
    for (int i=1 + (n & ~0xf); i <= n; i++) {
      accum*=i;
    }
    return accum * everySixteenthFactorial[n >> 4];
  }
}","/** 
 * Returns   {@code n!}, that is, the product of the first   {@code n} positiveintegers,  {@code 1} if {@code n == 0}, or   {@code n!}, or  {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}. <p>The result is within 1 ulp of the true value.
 * @throws IllegalArgumentException if {@code n < 0}
 */
public static double factorial(int n){
  checkNonNegative(""String_Node_Str"",n);
  if (n > MAX_FACTORIAL) {
    return Double.POSITIVE_INFINITY;
  }
 else {
    double accum=1.0;
    for (int i=1 + (n & ~0xf); i <= n; i++) {
      accum*=i;
    }
    return accum * everySixteenthFactorial[n >> 4];
  }
}",0.994331983805668
60129,"public void testDefaultExecutorIsShutdownWhenServiceFails() throws Exception {
  final CountDownLatch failureLatch=new CountDownLatch(1);
  AbstractScheduledService service=new AbstractScheduledService(){
    volatile ScheduledExecutorService executorService;
    @Override protected void runOneIteration() throws Exception {
    }
    @Override protected void startUp() throws Exception {
      throw new Exception(""String_Node_Str"");
    }
    @Override protected ScheduledExecutorService executor(){
      if (executorService == null) {
        executorService=super.executor();
        addListener(new Listener(){
          @Override public void failed(          State from,          Throwable failure){
            failureLatch.countDown();
          }
        }
,MoreExecutors.sameThreadExecutor());
      }
      return executorService;
    }
    @Override protected Scheduler scheduler(){
      return Scheduler.newFixedDelaySchedule(0,1,TimeUnit.MILLISECONDS);
    }
  }
;
  try {
    service.startAsync().awaitRunning();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException expected) {
  }
  failureLatch.await();
  assertTrue(service.executor().isShutdown());
  assertTrue(service.executor().awaitTermination(100,TimeUnit.MILLISECONDS));
}","public void testDefaultExecutorIsShutdownWhenServiceFails() throws Exception {
  final AtomicReference<ScheduledExecutorService> executor=Atomics.newReference();
  AbstractScheduledService service=new AbstractScheduledService(){
    @Override protected void startUp() throws Exception {
      throw new Exception(""String_Node_Str"");
    }
    @Override protected void runOneIteration() throws Exception {
    }
    @Override protected ScheduledExecutorService executor(){
      executor.set(super.executor());
      return executor.get();
    }
    @Override protected Scheduler scheduler(){
      return Scheduler.newFixedDelaySchedule(0,1,TimeUnit.MILLISECONDS);
    }
  }
;
  try {
    service.startAsync().awaitRunning();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException expected) {
  }
  assertTrue(executor.get().awaitTermination(100,TimeUnit.MILLISECONDS));
}",0.6203358208955224
60130,"public void testDefaultExecutorIsShutdownWhenServiceIsStopped() throws Exception {
  final CountDownLatch terminationLatch=new CountDownLatch(1);
  AbstractScheduledService service=new AbstractScheduledService(){
    volatile ScheduledExecutorService executorService;
    @Override protected void runOneIteration() throws Exception {
    }
    @Override protected ScheduledExecutorService executor(){
      if (executorService == null) {
        executorService=super.executor();
        addListener(new Listener(){
          @Override public void terminated(          State from){
            terminationLatch.countDown();
          }
        }
,MoreExecutors.sameThreadExecutor());
      }
      return executorService;
    }
    @Override protected Scheduler scheduler(){
      return Scheduler.newFixedDelaySchedule(0,1,TimeUnit.MILLISECONDS);
    }
  }
;
  service.startAsync();
  assertFalse(service.executor().isShutdown());
  service.awaitRunning();
  service.stopAsync();
  terminationLatch.await();
  assertTrue(service.executor().isShutdown());
  assertTrue(service.executor().awaitTermination(100,TimeUnit.MILLISECONDS));
}","public void testDefaultExecutorIsShutdownWhenServiceIsStopped() throws Exception {
  final AtomicReference<ScheduledExecutorService> executor=Atomics.newReference();
  AbstractScheduledService service=new AbstractScheduledService(){
    @Override protected void runOneIteration() throws Exception {
    }
    @Override protected ScheduledExecutorService executor(){
      executor.set(super.executor());
      return executor.get();
    }
    @Override protected Scheduler scheduler(){
      return Scheduler.newFixedDelaySchedule(0,1,TimeUnit.MILLISECONDS);
    }
  }
;
  service.startAsync();
  assertFalse(service.executor().isShutdown());
  service.awaitRunning();
  service.stopAsync();
  service.awaitTerminated();
  assertTrue(executor.get().awaitTermination(100,TimeUnit.MILLISECONDS));
}",0.6628689798032108
60131,"/** 
 * Copies bytes from this hash code into   {@code dest}.
 * @param dest the byte array into which the hash code will be written
 * @param offset the start offset in the data
 * @param maxLength the maximum number of bytes to write
 * @return the number of bytes written to {@code dest}
 * @throws IndexOutOfBoundsException if there is not enough room in {@code dest}
 */
public final int writeBytesTo(byte[] dest,int offset,int maxLength){
  maxLength=Ints.min(maxLength,bits() * 8);
  Preconditions.checkPositionIndexes(offset,offset + maxLength,dest.length);
  byte[] hash=asBytes();
  System.arraycopy(hash,0,dest,offset,maxLength);
  return maxLength;
}","/** 
 * Copies bytes from this hash code into   {@code dest}.
 * @param dest the byte array into which the hash code will be written
 * @param offset the start offset in the data
 * @param maxLength the maximum number of bytes to write
 * @return the number of bytes written to {@code dest}
 * @throws IndexOutOfBoundsException if there is not enough room in {@code dest}
 */
public final int writeBytesTo(byte[] dest,int offset,int maxLength){
  maxLength=Ints.min(maxLength,bits() / 8);
  Preconditions.checkPositionIndexes(offset,offset + maxLength,dest.length);
  byte[] hash=asBytes();
  System.arraycopy(hash,0,dest,offset,maxLength);
  return maxLength;
}",0.9984894259818732
60132,"private static <K,V>void assertSameEntries(List<ReferenceEntry<K,V>> expectedEntries,List<ReferenceEntry<K,V>> actualEntries){
  int size=expectedEntries.size();
  assertEquals(size,actualEntries.size());
  for (int i=0; i < size; i++) {
    ReferenceEntry<K,V> expectedEntry=expectedEntries.get(0);
    ReferenceEntry<K,V> actualEntry=actualEntries.get(0);
    assertSame(expectedEntry.getKey(),actualEntry.getKey());
    assertSame(expectedEntry.getValueReference().get(),actualEntry.getValueReference().get());
  }
}","private static <K,V>void assertSameEntries(List<ReferenceEntry<K,V>> expectedEntries,List<ReferenceEntry<K,V>> actualEntries){
  int size=expectedEntries.size();
  assertEquals(size,actualEntries.size());
  for (int i=0; i < size; i++) {
    ReferenceEntry<K,V> expectedEntry=expectedEntries.get(i);
    ReferenceEntry<K,V> actualEntry=actualEntries.get(i);
    assertSame(expectedEntry.getKey(),actualEntry.getKey());
    assertSame(expectedEntry.getValueReference().get(),actualEntry.getValueReference().get());
  }
}",0.9961464354527938
60133,"@Override public NavigableMap<K,Collection<V>> headMap(K toKey,boolean inclusive){
  return new NavigableAsMap(sortedMap().headMap(toKey,false));
}","@Override public NavigableMap<K,Collection<V>> headMap(K toKey,boolean inclusive){
  return new NavigableAsMap(sortedMap().headMap(toKey,inclusive));
}",0.9731543624161074
60134,"public <T>void testRejectTypeVariable_withOwnerType(){
  assertHasTypeVariable(new From<Integer>().new To<String>().type());
  assertHasTypeVariable(new From<T>().new To<String>().type());
  assertHasTypeVariable(new From<Integer>().new To<T>().type());
  assertHasTypeVariable(new From<Integer>(){
  }
.new To<String>().type());
  assertHasTypeVariable(new From<T>(){
  }
.new To<String>().type());
  assertNoTypeVariable(new From<Integer>().new To<String>(){
  }
.type());
  assertHasTypeVariable(new From<Integer>().new To<T>(){
  }
.type());
  assertNoTypeVariable(new From<Integer>(){
  }
.new To<String>(){
  }
.type());
  assertHasTypeVariable(new From<Integer>(){
  }
.new To<T>(){
  }
.type());
}","public <T>void testRejectTypeVariable_withOwnerType(){
  assertHasTypeVariable(new From<Integer>().new To<String>().type());
  assertHasTypeVariable(new From<T>().new To<String>().type());
  assertHasTypeVariable(new From<Integer>().new To<T>().type());
  assertHasTypeVariable(new From<Integer>(){
  }
.new To<String>().type());
  assertHasTypeVariable(new From<T>(){
  }
.new To<String>().type());
  assertNoTypeVariable(new From<Integer>().new To<String>(){
  }
.type());
  assertHasTypeVariable(new From<Integer>().new To<T>(){
  }
.type());
  assertHasTypeVariable(new From<T>().new To<String>(){
  }
.type());
  assertHasTypeVariable(new From<T>(){
  }
.new To<String>(){
  }
.type());
  assertNoTypeVariable(new From<Integer>(){
  }
.new To<String>(){
  }
.type());
  assertHasTypeVariable(new From<Integer>(){
  }
.new To<T>(){
  }
.type());
}",0.9061696658097688
60135,"/** 
 * Ensures that this type token doesn't contain type variables, which can cause unchecked type errors for callers like   {@link TypeToInstanceMap}.
 */
final TypeToken<T> rejectTypeVariables(){
  new TypeVisitor(){
    @Override void visitTypeVariable(    TypeVariable<?> type){
      throw new IllegalArgumentException(runtimeType + ""String_Node_Str"");
    }
    @Override void visitWildcardType(    WildcardType type){
      visit(type.getLowerBounds());
      visit(type.getUpperBounds());
    }
    @Override void visitParameterizedType(    ParameterizedType type){
      visit(type.getActualTypeArguments());
    }
    @Override void visitGenericArrayType(    GenericArrayType type){
      visit(type.getGenericComponentType());
    }
  }
.visit(runtimeType);
  return this;
}","/** 
 * Ensures that this type token doesn't contain type variables, which can cause unchecked type errors for callers like   {@link TypeToInstanceMap}.
 */
final TypeToken<T> rejectTypeVariables(){
  new TypeVisitor(){
    @Override void visitTypeVariable(    TypeVariable<?> type){
      throw new IllegalArgumentException(runtimeType + ""String_Node_Str"");
    }
    @Override void visitWildcardType(    WildcardType type){
      visit(type.getLowerBounds());
      visit(type.getUpperBounds());
    }
    @Override void visitParameterizedType(    ParameterizedType type){
      visit(type.getActualTypeArguments());
      visit(type.getOwnerType());
    }
    @Override void visitGenericArrayType(    GenericArrayType type){
      visit(type.getGenericComponentType());
    }
  }
.visit(runtimeType);
  return this;
}",0.978829389788294
60136,"ListenableFuture<V> loadAsync(final K key,final int hash,final LoadingValueReference<K,V> loadingValueReference,CacheLoader<? super K,V> loader){
  final ListenableFuture<V> loadingFuture=loadingValueReference.loadFuture(key,loader);
  loadingFuture.addListener(new Runnable(){
    @Override public void run(){
      try {
        V newValue=getAndRecordStats(key,hash,loadingValueReference,loadingFuture);
        loadingValueReference.set(newValue);
      }
 catch (      Throwable t) {
        logger.log(Level.WARNING,""String_Node_Str"",t);
        loadingValueReference.setException(t);
      }
    }
  }
,sameThreadExecutor);
  return loadingFuture;
}","ListenableFuture<V> loadAsync(final K key,final int hash,final LoadingValueReference<K,V> loadingValueReference,CacheLoader<? super K,V> loader){
  final ListenableFuture<V> loadingFuture=loadingValueReference.loadFuture(key,loader);
  loadingFuture.addListener(new Runnable(){
    @Override public void run(){
      try {
        V newValue=getAndRecordStats(key,hash,loadingValueReference,loadingFuture);
      }
 catch (      Throwable t) {
        logger.log(Level.WARNING,""String_Node_Str"",t);
        loadingValueReference.setException(t);
      }
    }
  }
,sameThreadExecutor);
  return loadingFuture;
}",0.9644830307813732
60137,"public ListenableFuture<V> loadFuture(K key,CacheLoader<? super K,V> loader){
  stopwatch.start();
  V previousValue=oldValue.get();
  try {
    if (previousValue == null) {
      V newValue=loader.load(key);
      return set(newValue) ? futureValue : Futures.immediateFuture(newValue);
    }
 else {
      ListenableFuture<V> newValue=loader.reload(key,previousValue);
      return newValue != null ? newValue : Futures.<V>immediateFuture(null);
    }
  }
 catch (  Throwable t) {
    if (t instanceof InterruptedException) {
      Thread.currentThread().interrupt();
    }
    return setException(t) ? futureValue : fullyFailedFuture(t);
  }
}","public ListenableFuture<V> loadFuture(K key,CacheLoader<? super K,V> loader){
  stopwatch.start();
  V previousValue=oldValue.get();
  try {
    if (previousValue == null) {
      V newValue=loader.load(key);
      return set(newValue) ? futureValue : Futures.immediateFuture(newValue);
    }
    ListenableFuture<V> newValue=loader.reload(key,previousValue);
    if (newValue == null) {
      return Futures.immediateFuture(null);
    }
    return Futures.transform(newValue,new Function<V,V>(){
      @Override public V apply(      V newValue){
        LoadingValueReference.this.set(newValue);
        return newValue;
      }
    }
);
  }
 catch (  Throwable t) {
    if (t instanceof InterruptedException) {
      Thread.currentThread().interrupt();
    }
    return setException(t) ? futureValue : fullyFailedFuture(t);
  }
}",0.7940379403794038
60138,"@Override public void run(){
  try {
    V newValue=getAndRecordStats(key,hash,loadingValueReference,loadingFuture);
    loadingValueReference.set(newValue);
  }
 catch (  Throwable t) {
    logger.log(Level.WARNING,""String_Node_Str"",t);
    loadingValueReference.setException(t);
  }
}","@Override public void run(){
  try {
    V newValue=getAndRecordStats(key,hash,loadingValueReference,loadingFuture);
  }
 catch (  Throwable t) {
    logger.log(Level.WARNING,""String_Node_Str"",t);
    loadingValueReference.setException(t);
  }
}",0.9227871939736346
60139,"/** 
 * @since 13.0
 */
@Override public final void addListener(Listener listener,Executor executor){
  checkNotNull(listener,""String_Node_Str"");
  checkNotNull(executor,""String_Node_Str"");
  lock.lock();
  try {
    if (snapshot.state != State.TERMINATED && snapshot.state != State.FAILED) {
      listeners.add(new ListenerExecutorPair(listener,executor));
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * @since 13.0
 */
@Override public final void addListener(Listener listener,Executor executor){
  checkNotNull(listener,""String_Node_Str"");
  checkNotNull(executor,""String_Node_Str"");
  lock.lock();
  try {
    State currentState=state();
    if (currentState != State.TERMINATED && currentState != State.FAILED) {
      listeners.add(new ListenerExecutorPair(listener,executor));
    }
  }
  finally {
    lock.unlock();
  }
}",0.918854415274463
60140,"@Override public final ListenableFuture<State> start(){
  lock.lock();
  try {
    if (snapshot.state == State.NEW) {
      snapshot=new StateSnapshot(State.STARTING);
      starting();
      doStart();
    }
  }
 catch (  Throwable startupFailure) {
    notifyFailed(startupFailure);
  }
 finally {
    lock.unlock();
    executeListeners();
  }
  return startup;
}","@Override public final ListenableFuture<State> start(){
  lock.lock();
  try {
    if (state() == State.NEW) {
      snapshot=new StateSnapshot(State.STARTING);
      starting();
      doStart();
    }
  }
 catch (  Throwable startupFailure) {
    notifyFailed(startupFailure);
  }
 finally {
    lock.unlock();
    executeListeners();
  }
  return startup;
}",0.973793103448276
60141,"/** 
 * Implementing classes should invoke this method once their service has stopped. It will cause the service to transition from   {@link State#STOPPING} to {@link State#TERMINATED}.
 * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor{@link State#RUNNING}.
 */
protected final void notifyStopped(){
  lock.lock();
  try {
    if (snapshot.state != State.STOPPING && snapshot.state != State.RUNNING) {
      IllegalStateException failure=new IllegalStateException(""String_Node_Str"" + snapshot.state);
      notifyFailed(failure);
      throw failure;
    }
    State previous=snapshot.state;
    snapshot=new StateSnapshot(State.TERMINATED);
    terminated(previous);
  }
  finally {
    lock.unlock();
    executeListeners();
  }
}","/** 
 * Implementing classes should invoke this method once their service has stopped. It will cause the service to transition from   {@link State#STOPPING} to {@link State#TERMINATED}.
 * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor{@link State#RUNNING}.
 */
protected final void notifyStopped(){
  lock.lock();
  try {
    State previous=snapshot.state;
    if (previous != State.STOPPING && previous != State.RUNNING) {
      IllegalStateException failure=new IllegalStateException(""String_Node_Str"" + previous);
      notifyFailed(failure);
      throw failure;
    }
    snapshot=new StateSnapshot(State.TERMINATED);
    terminated(previous);
  }
  finally {
    lock.unlock();
    executeListeners();
  }
}",0.9051383399209486
60142,"@Override public final ListenableFuture<State> stop(){
  lock.lock();
  try {
switch (snapshot.state) {
case NEW:
      snapshot=new StateSnapshot(State.TERMINATED);
    terminated(State.NEW);
  break;
case STARTING:
snapshot=new StateSnapshot(State.STARTING,true,null);
stopping(State.STARTING);
break;
case RUNNING:
snapshot=new StateSnapshot(State.STOPPING);
stopping(State.RUNNING);
doStop();
break;
case STOPPING:
case TERMINATED:
case FAILED:
break;
default :
throw new AssertionError(""String_Node_Str"" + snapshot.state);
}
}
 catch (Throwable shutdownFailure) {
notifyFailed(shutdownFailure);
}
 finally {
lock.unlock();
executeListeners();
}
return shutdown;
}","@Override public final ListenableFuture<State> stop(){
  lock.lock();
  try {
    State previous=state();
switch (previous) {
case NEW:
      snapshot=new StateSnapshot(State.TERMINATED);
    terminated(State.NEW);
  break;
case STARTING:
snapshot=new StateSnapshot(State.STARTING,true,null);
stopping(State.STARTING);
break;
case RUNNING:
snapshot=new StateSnapshot(State.STOPPING);
stopping(State.RUNNING);
doStop();
break;
case STOPPING:
case TERMINATED:
case FAILED:
break;
default :
throw new AssertionError(""String_Node_Str"" + previous);
}
}
 catch (Throwable shutdownFailure) {
notifyFailed(shutdownFailure);
}
 finally {
lock.unlock();
executeListeners();
}
return shutdown;
}",0.9349112426035504
60143,"/** 
 * Invoke this method to transition the service to the   {@link State#FAILED}. The service will <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically or otherwise cannot be started nor stopped.
 */
protected final void notifyFailed(Throwable cause){
  checkNotNull(cause);
  lock.lock();
  try {
switch (snapshot.state) {
case NEW:
case TERMINATED:
      throw new IllegalStateException(""String_Node_Str"" + snapshot.state,cause);
case RUNNING:
case STARTING:
case STOPPING:
    State previous=snapshot.state;
  snapshot=new StateSnapshot(State.FAILED,false,cause);
failed(previous,cause);
break;
case FAILED:
break;
default :
throw new AssertionError(""String_Node_Str"" + snapshot.state);
}
}
  finally {
lock.unlock();
executeListeners();
}
}","/** 
 * Invoke this method to transition the service to the   {@link State#FAILED}. The service will <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically or otherwise cannot be started nor stopped.
 */
protected final void notifyFailed(Throwable cause){
  checkNotNull(cause);
  lock.lock();
  try {
    State previous=state();
switch (previous) {
case NEW:
case TERMINATED:
      throw new IllegalStateException(""String_Node_Str"" + previous,cause);
case RUNNING:
case STARTING:
case STOPPING:
    snapshot=new StateSnapshot(State.FAILED,false,cause);
  failed(previous,cause);
break;
case FAILED:
break;
default :
throw new AssertionError(""String_Node_Str"" + previous);
}
}
  finally {
lock.unlock();
executeListeners();
}
}",0.8426461143224149
60144,"@Override public T next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  try {
    return iterator.next();
  }
  finally {
    atStart=false;
  }
}","@Override public T next(){
  T result=iterator.next();
  atStart=false;
  return result;
}",0.5525291828793775
60145,"/** 
 * Returns a view of   {@code iterable} that skips its first{@code numberToSkip} elements. If {@code iterable} contains fewer than{@code numberToSkip} elements, the returned iterable skips all of itselements. <p>Modifications to the underlying  {@link Iterable} before a call to{@code iterator()} are reflected in the returned iterator. That is, theiterator skips the first  {@code numberToSkip} elements that exist when the{@code Iterator} is created, not when {@code skip()} is called.<p>The returned iterable's iterator supports  {@code remove()} if theiterator of the underlying iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by immediately calling  {@code remove()} on that iterator, as the {@code Iterator}contract states that a call to   {@code remove()} before a call to{@code next()} will throw an {@link IllegalStateException}.
 * @since 3.0
 */
public static <T>Iterable<T> skip(final Iterable<T> iterable,final int numberToSkip){
  checkNotNull(iterable);
  checkArgument(numberToSkip >= 0,""String_Node_Str"");
  if (iterable instanceof List) {
    final List<T> list=(List<T>)iterable;
    return new FluentIterable<T>(){
      @Override public Iterator<T> iterator(){
        return (numberToSkip >= list.size()) ? Iterators.<T>emptyIterator() : list.subList(numberToSkip,list.size()).iterator();
      }
    }
;
  }
  return new FluentIterable<T>(){
    @Override public Iterator<T> iterator(){
      final Iterator<T> iterator=iterable.iterator();
      Iterators.advance(iterator,numberToSkip);
      return new Iterator<T>(){
        boolean atStart=true;
        @Override public boolean hasNext(){
          return iterator.hasNext();
        }
        @Override public T next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          try {
            return iterator.next();
          }
  finally {
            atStart=false;
          }
        }
        @Override public void remove(){
          if (atStart) {
            throw new IllegalStateException();
          }
          iterator.remove();
        }
      }
;
    }
  }
;
}","/** 
 * Returns a view of   {@code iterable} that skips its first{@code numberToSkip} elements. If {@code iterable} contains fewer than{@code numberToSkip} elements, the returned iterable skips all of itselements. <p>Modifications to the underlying  {@link Iterable} before a call to{@code iterator()} are reflected in the returned iterator. That is, theiterator skips the first  {@code numberToSkip} elements that exist when the{@code Iterator} is created, not when {@code skip()} is called.<p>The returned iterable's iterator supports  {@code remove()} if theiterator of the underlying iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by immediately calling  {@code remove()} on that iterator, as the {@code Iterator}contract states that a call to   {@code remove()} before a call to{@code next()} will throw an {@link IllegalStateException}.
 * @since 3.0
 */
public static <T>Iterable<T> skip(final Iterable<T> iterable,final int numberToSkip){
  checkNotNull(iterable);
  checkArgument(numberToSkip >= 0,""String_Node_Str"");
  if (iterable instanceof List) {
    final List<T> list=(List<T>)iterable;
    return new FluentIterable<T>(){
      @Override public Iterator<T> iterator(){
        int toSkip=Math.min(list.size(),numberToSkip);
        return list.subList(toSkip,list.size()).iterator();
      }
    }
;
  }
  return new FluentIterable<T>(){
    @Override public Iterator<T> iterator(){
      final Iterator<T> iterator=iterable.iterator();
      Iterators.advance(iterator,numberToSkip);
      return new Iterator<T>(){
        boolean atStart=true;
        @Override public boolean hasNext(){
          return iterator.hasNext();
        }
        @Override public T next(){
          T result=iterator.next();
          atStart=false;
          return result;
        }
        @Override public void remove(){
          Iterators.checkRemove(!atStart);
          iterator.remove();
        }
      }
;
    }
  }
;
}",0.9040232670867668
60146,"/** 
 * Returns the last element of   {@code iterable} or {@code defaultValue} ifthe iterable is empty.
 * @param defaultValue the value to return if {@code iterable} is empty
 * @return the last element of {@code iterable} or the default value
 * @since 3.0
 */
@Nullable public static <T>T getLast(Iterable<? extends T> iterable,@Nullable T defaultValue){
  if (iterable instanceof Collection) {
    Collection<? extends T> c=Collections2.cast(iterable);
    if (c.isEmpty()) {
      return defaultValue;
    }
 else     if (iterable instanceof List) {
      List<? extends T> list=Lists.cast(iterable);
      return getLastInNonemptyList(list);
    }
  }
  return Iterators.getLast(iterable.iterator(),defaultValue);
}","/** 
 * Returns the last element of   {@code iterable} or {@code defaultValue} ifthe iterable is empty.
 * @param defaultValue the value to return if {@code iterable} is empty
 * @return the last element of {@code iterable} or the default value
 * @since 3.0
 */
@Nullable public static <T>T getLast(Iterable<? extends T> iterable,@Nullable T defaultValue){
  if (iterable instanceof Collection) {
    Collection<? extends T> c=Collections2.cast(iterable);
    if (c.isEmpty()) {
      return defaultValue;
    }
 else     if (iterable instanceof List) {
      return getLastInNonemptyList(Lists.cast(iterable));
    }
  }
  return Iterators.getLast(iterable.iterator(),defaultValue);
}",0.9466950959488272
60147,"@Override public void remove(){
  if (atStart) {
    throw new IllegalStateException();
  }
  iterator.remove();
}","@Override public void remove(){
  Iterators.checkRemove(!atStart);
  iterator.remove();
}",0.6600985221674877
60148,"/** 
 * Adds all elements in   {@code iterable} to {@code collection}.
 * @return {@code true} if {@code collection} was modified as a result of thisoperation.
 */
public static <T>boolean addAll(Collection<T> addTo,Iterable<? extends T> elementsToAdd){
  if (elementsToAdd instanceof Collection) {
    Collection<? extends T> c=Collections2.cast(elementsToAdd);
    return addTo.addAll(c);
  }
  return Iterators.addAll(addTo,elementsToAdd.iterator());
}","/** 
 * Adds all elements in   {@code iterable} to {@code collection}.
 * @return {@code true} if {@code collection} was modified as a result of thisoperation.
 */
public static <T>boolean addAll(Collection<T> addTo,Iterable<? extends T> elementsToAdd){
  if (elementsToAdd instanceof Collection) {
    Collection<? extends T> c=Collections2.cast(elementsToAdd);
    return addTo.addAll(c);
  }
  return Iterators.addAll(addTo,checkNotNull(elementsToAdd).iterator());
}",0.9567099567099568
60149,"/** 
 * Combines multiple iterators into a single iterator. The returned iterator iterates across the elements of each iterator in   {@code inputs}. The input iterators are not polled until necessary. <p>The returned iterator supports   {@code remove()} when the correspondinginput iterator supports it. The methods of the returned iterator may throw {@code NullPointerException} if any of the input iterators is null.<p><b>Note:</b> the current implementation is not suitable for nested concatenated iterators, i.e. the following should be avoided when in a loop: {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the resulting iterator has a cubic complexity to the depth of the nesting.
 */
public static <T>Iterator<T> concat(final Iterator<? extends Iterator<? extends T>> inputs){
  checkNotNull(inputs);
  return new Iterator<T>(){
    Iterator<? extends T> current=emptyIterator();
    Iterator<? extends T> removeFrom;
    @Override public boolean hasNext(){
      boolean currentHasNext;
      while (!(currentHasNext=checkNotNull(current).hasNext()) && inputs.hasNext()) {
        current=inputs.next();
      }
      return currentHasNext;
    }
    @Override public T next(){
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      removeFrom=current;
      return current.next();
    }
    @Override public void remove(){
      checkState(removeFrom != null,""String_Node_Str"");
      removeFrom.remove();
      removeFrom=null;
    }
  }
;
}","/** 
 * Combines multiple iterators into a single iterator. The returned iterator iterates across the elements of each iterator in   {@code inputs}. The input iterators are not polled until necessary. <p>The returned iterator supports   {@code remove()} when the correspondinginput iterator supports it. The methods of the returned iterator may throw {@code NullPointerException} if any of the input iterators is null.<p><b>Note:</b> the current implementation is not suitable for nested concatenated iterators, i.e. the following should be avoided when in a loop: {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the resulting iterator has a cubic complexity to the depth of the nesting.
 */
public static <T>Iterator<T> concat(final Iterator<? extends Iterator<? extends T>> inputs){
  checkNotNull(inputs);
  return new Iterator<T>(){
    Iterator<? extends T> current=emptyIterator();
    Iterator<? extends T> removeFrom;
    @Override public boolean hasNext(){
      boolean currentHasNext;
      while (!(currentHasNext=checkNotNull(current).hasNext()) && inputs.hasNext()) {
        current=inputs.next();
      }
      return currentHasNext;
    }
    @Override public T next(){
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      removeFrom=current;
      return current.next();
    }
    @Override public void remove(){
      checkRemove(removeFrom != null);
      removeFrom.remove();
      removeFrom=null;
    }
  }
;
}",0.9909969989996664
60150,"/** 
 * Adds all elements in   {@code iterator} to {@code collection}. The iterator will be left exhausted: its   {@code hasNext()} method will return{@code false}.
 * @return {@code true} if {@code collection} was modified as a result of thisoperation
 */
public static <T>boolean addAll(Collection<T> addTo,Iterator<? extends T> iterator){
  checkNotNull(addTo);
  boolean wasModified=false;
  while (iterator.hasNext()) {
    wasModified|=addTo.add(iterator.next());
  }
  return wasModified;
}","/** 
 * Adds all elements in   {@code iterator} to {@code collection}. The iterator will be left exhausted: its   {@code hasNext()} method will return{@code false}.
 * @return {@code true} if {@code collection} was modified as a result of thisoperation
 */
public static <T>boolean addAll(Collection<T> addTo,Iterator<? extends T> iterator){
  checkNotNull(addTo);
  checkNotNull(iterator);
  boolean wasModified=false;
  while (iterator.hasNext()) {
    wasModified|=addTo.add(iterator.next());
  }
  return wasModified;
}",0.9745098039215686
60151,"/** 
 * Creates a   {@code LinkedList} instance containing the given elements.
 * @param elements the elements that the list should contain, in order
 * @return a new {@code LinkedList} containing those elements
 */
@GwtCompatible(serializable=true) public static <E>LinkedList<E> newLinkedList(Iterable<? extends E> elements){
  LinkedList<E> list=newLinkedList();
  for (  E element : elements) {
    list.add(element);
  }
  return list;
}","/** 
 * Creates a   {@code LinkedList} instance containing the given elements.
 * @param elements the elements that the list should contain, in order
 * @return a new {@code LinkedList} containing those elements
 */
@GwtCompatible(serializable=true) public static <E>LinkedList<E> newLinkedList(Iterable<? extends E> elements){
  LinkedList<E> list=newLinkedList();
  Iterables.addAll(list,elements);
  return list;
}",0.8731082654249127
60152,"/** 
 * Creates a <i>mutable</i>   {@code ArrayList} instance containing the givenelements. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableList#copyOf(Iterator)} instead.
 * @param elements the elements that the list should contain, in order
 * @return a new {@code ArrayList} containing those elements
 */
@GwtCompatible(serializable=true) public static <E>ArrayList<E> newArrayList(Iterator<? extends E> elements){
  checkNotNull(elements);
  ArrayList<E> list=newArrayList();
  while (elements.hasNext()) {
    list.add(elements.next());
  }
  return list;
}","/** 
 * Creates a <i>mutable</i>   {@code ArrayList} instance containing the givenelements. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableList#copyOf(Iterator)} instead.
 * @param elements the elements that the list should contain, in order
 * @return a new {@code ArrayList} containing those elements
 */
@GwtCompatible(serializable=true) public static <E>ArrayList<E> newArrayList(Iterator<? extends E> elements){
  ArrayList<E> list=newArrayList();
  Iterators.addAll(list,elements);
  return list;
}",0.8791773778920309
60153,"/** 
 * Creates a <i>mutable</i>   {@code LinkedHashSet} instance containing thegiven elements in order. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableSet#copyOf(Iterable)} instead.
 * @param elements the elements that the set should contain, in order
 * @return a new {@code LinkedHashSet} containing those elements (minusduplicates)
 */
public static <E>LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements){
  if (elements instanceof Collection) {
    return new LinkedHashSet<E>(Collections2.cast(elements));
  }
  LinkedHashSet<E> set=newLinkedHashSet();
  for (  E element : elements) {
    set.add(element);
  }
  return set;
}","/** 
 * Creates a <i>mutable</i>   {@code LinkedHashSet} instance containing thegiven elements in order. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableSet#copyOf(Iterable)} instead.
 * @param elements the elements that the set should contain, in order
 * @return a new {@code LinkedHashSet} containing those elements (minusduplicates)
 */
public static <E>LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements){
  if (elements instanceof Collection) {
    return new LinkedHashSet<E>(Collections2.cast(elements));
  }
  LinkedHashSet<E> set=newLinkedHashSet();
  Iterables.addAll(set,elements);
  return set;
}",0.9277899343544858
60154,"/** 
 * Creates a <i>mutable</i>   {@code HashSet} instance containing the givenelements in unspecified order. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableSet#copyOf(Iterable)} instead.<p><b>Note:</b> if  {@code E} is an {@link Enum} type, you should create an{@link EnumSet} instead.
 * @param elements the elements that the set should contain
 * @return a new {@code HashSet} containing those elements (minus duplicates)
 */
public static <E>HashSet<E> newHashSet(Iterator<? extends E> elements){
  HashSet<E> set=newHashSet();
  while (elements.hasNext()) {
    set.add(elements.next());
  }
  return set;
}","/** 
 * Creates a <i>mutable</i>   {@code HashSet} instance containing the givenelements in unspecified order. <p><b>Note:</b> if mutability is not required and the elements are non-null, use  {@link ImmutableSet#copyOf(Iterable)} instead.<p><b>Note:</b> if  {@code E} is an {@link Enum} type, you should create an{@link EnumSet} instead.
 * @param elements the elements that the set should contain
 * @return a new {@code HashSet} containing those elements (minus duplicates)
 */
public static <E>HashSet<E> newHashSet(Iterator<? extends E> elements){
  HashSet<E> set=newHashSet();
  Iterators.addAll(set,elements);
  return set;
}",0.9144178874325366
60155,"static boolean removeAllImpl(Set<?> set,Collection<?> collection){
  checkNotNull(collection);
  if (collection instanceof Multiset) {
    collection=((Multiset<?>)collection).elementSet();
  }
  if (collection instanceof Set && collection.size() > set.size()) {
    Iterator<?> setIterator=set.iterator();
    boolean changed=false;
    while (setIterator.hasNext()) {
      if (collection.contains(setIterator.next())) {
        changed=true;
        setIterator.remove();
      }
    }
    return changed;
  }
 else {
    return removeAllImpl(set,collection.iterator());
  }
}","static boolean removeAllImpl(Set<?> set,Collection<?> collection){
  checkNotNull(collection);
  if (collection instanceof Multiset) {
    collection=((Multiset<?>)collection).elementSet();
  }
  if (collection instanceof Set && collection.size() > set.size()) {
    return Iterators.removeAll(set.iterator(),collection);
  }
 else {
    return removeAllImpl(set,collection.iterator());
  }
}",0.5849639546858908
60156,"public sun.misc.Unsafe run() throws Exception {
  java.lang.reflect.Field f;
  try {
    f=sun.misc.Unsafe.class.getDeclaredField(""String_Node_Str"");
  }
 catch (  NoSuchFieldException e) {
    f=sun.misc.Unsafe.class.getDeclaredField(""String_Node_Str"");
  }
  f.setAccessible(true);
  return (sun.misc.Unsafe)f.get(null);
}","public sun.misc.Unsafe run() throws Exception {
  Class<sun.misc.Unsafe> k=sun.misc.Unsafe.class;
  for (  java.lang.reflect.Field f : k.getDeclaredFields()) {
    f.setAccessible(true);
    Object x=f.get(null);
    if (k.isInstance(x))     return k.cast(x);
  }
  throw new NoSuchFieldError(""String_Node_Str"");
}",0.3605015673981191
60157,"/** 
 * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package. Replace with a simple call to Unsafe.getUnsafe when integrating into a jdk.
 * @return a sun.misc.Unsafe
 */
private static sun.misc.Unsafe getUnsafe(){
  try {
    return sun.misc.Unsafe.getUnsafe();
  }
 catch (  SecurityException se) {
    try {
      return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>(){
        public sun.misc.Unsafe run() throws Exception {
          java.lang.reflect.Field f;
          try {
            f=sun.misc.Unsafe.class.getDeclaredField(""String_Node_Str"");
          }
 catch (          NoSuchFieldException e) {
            f=sun.misc.Unsafe.class.getDeclaredField(""String_Node_Str"");
          }
          f.setAccessible(true);
          return (sun.misc.Unsafe)f.get(null);
        }
      }
);
    }
 catch (    java.security.PrivilegedActionException e) {
      throw new RuntimeException(""String_Node_Str"",e.getCause());
    }
  }
}","/** 
 * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package. Replace with a simple call to Unsafe.getUnsafe when integrating into a jdk.
 * @return a sun.misc.Unsafe
 */
private static sun.misc.Unsafe getUnsafe(){
  try {
    return sun.misc.Unsafe.getUnsafe();
  }
 catch (  SecurityException tryReflectionInstead) {
  }
  try {
    return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>(){
      public sun.misc.Unsafe run() throws Exception {
        Class<sun.misc.Unsafe> k=sun.misc.Unsafe.class;
        for (        java.lang.reflect.Field f : k.getDeclaredFields()) {
          f.setAccessible(true);
          Object x=f.get(null);
          if (k.isInstance(x))           return k.cast(x);
        }
        throw new NoSuchFieldError(""String_Node_Str"");
      }
    }
);
  }
 catch (  java.security.PrivilegedActionException e) {
    throw new RuntimeException(""String_Node_Str"",e.getCause());
  }
}",0.6369107321965898
60158,"@Override public Object run(){
  try {
    Field f=Unsafe.class.getDeclaredField(""String_Node_Str"");
    f.setAccessible(true);
    return f.get(null);
  }
 catch (  NoSuchFieldException e) {
    throw new Error();
  }
catch (  IllegalAccessException e) {
    throw new Error();
  }
}","public sun.misc.Unsafe run() throws Exception {
  Class<sun.misc.Unsafe> k=sun.misc.Unsafe.class;
  for (  java.lang.reflect.Field f : k.getDeclaredFields()) {
    f.setAccessible(true);
    Object x=f.get(null);
    if (k.isInstance(x))     return k.cast(x);
  }
  throw new NoSuchFieldError(""String_Node_Str"");
}",0.1270903010033444
60159,"@Override public V get(@Nullable Object key){
  if (key instanceof Range) {
    Range<?> range=(Range<?>)key;
    RangeMapEntry<K,V> rangeMapEntry=entriesByLowerBound.get(range.lowerBound);
    if (rangeMapEntry.getKey().equals(range)) {
      return rangeMapEntry.getValue();
    }
  }
  return null;
}","@Override public V get(@Nullable Object key){
  if (key instanceof Range) {
    Range<?> range=(Range<?>)key;
    RangeMapEntry<K,V> rangeMapEntry=entriesByLowerBound.get(range.lowerBound);
    if (rangeMapEntry != null && rangeMapEntry.getKey().equals(range)) {
      return rangeMapEntry.getValue();
    }
  }
  return null;
}",0.960380348652932
60160,"public void testCancel_notDoneNoInterrupt(){
  InterruptibleFuture future=new InterruptibleFuture();
  assertTrue(future.cancel(false));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  assertFalse(future.wasInterrupted());
  assertFalse(future.interruptTaskWasCalled);
}","public void testCancel_notDoneNoInterrupt() throws Exception {
  InterruptibleFuture future=new InterruptibleFuture();
  assertTrue(future.cancel(false));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  assertFalse(future.wasInterrupted());
  assertFalse(future.interruptTaskWasCalled);
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException e) {
    assertNotNull(e.getCause());
  }
}",0.7939972714870396
60161,"public void testCancel_notDoneInterrupt(){
  InterruptibleFuture future=new InterruptibleFuture();
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  assertTrue(future.wasInterrupted());
  assertTrue(future.interruptTaskWasCalled);
}","public void testCancel_notDoneInterrupt() throws Exception {
  InterruptibleFuture future=new InterruptibleFuture();
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  assertTrue(future.isDone());
  assertTrue(future.wasInterrupted());
  assertTrue(future.interruptTaskWasCalled);
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException e) {
    assertNotNull(e.getCause());
  }
}",0.7911479944674965
60162,"@Override protected void interruptTask(){
  interruptTaskWasCalled=true;
}","@Override protected void interruptTask(){
  assertFalse(interruptTaskWasCalled);
  interruptTaskWasCalled=true;
}",0.7914438502673797
60163,"public void testCancel_done(){
  AbstractFuture<String> future=new AbstractFuture<String>(){
{
      set(""String_Node_Str"");
    }
  }
;
  assertFalse(future.cancel(true));
  assertFalse(future.isCancelled());
  assertTrue(future.isDone());
}","public void testCancel_done() throws Exception {
  AbstractFuture<String> future=new AbstractFuture<String>(){
{
      set(""String_Node_Str"");
    }
  }
;
  assertFalse(future.cancel(true));
  assertFalse(future.isCancelled());
  assertTrue(future.isDone());
}",0.9641434262948207
60164,"/** 
 * Implementation of completing a task.  Either   {@code v} or {@code t} willbe set but not both.  The  {@code finalState} is the state to change tofrom  {@link #RUNNING}.  If the state is not in the RUNNING state we return   {@code false} after waiting for the state to be set to a validfinal state ( {@link #COMPLETED},   {@link #CANCELLED}, or   {@link #INTERRUPTED}).
 * @param v the value to set as the result of the computation.
 * @param t the exception to set as the result of the computation.
 * @param finalState the state to transition to.
 */
private boolean complete(@Nullable V v,@Nullable Throwable t,int finalState){
  boolean doCompletion=compareAndSetState(RUNNING,COMPLETING);
  if (doCompletion) {
    this.value=v;
    this.exception=isCancelled() ? new CancellationException(""String_Node_Str"") : t;
    releaseShared(finalState);
  }
 else   if (getState() == COMPLETING) {
    acquireShared(-1);
  }
  return doCompletion;
}","/** 
 * Implementation of completing a task.  Either   {@code v} or {@code t} willbe set but not both.  The  {@code finalState} is the state to change tofrom  {@link #RUNNING}.  If the state is not in the RUNNING state we return   {@code false} after waiting for the state to be set to a validfinal state ( {@link #COMPLETED},   {@link #CANCELLED}, or   {@link #INTERRUPTED}).
 * @param v the value to set as the result of the computation.
 * @param t the exception to set as the result of the computation.
 * @param finalState the state to transition to.
 */
private boolean complete(@Nullable V v,@Nullable Throwable t,int finalState){
  boolean doCompletion=compareAndSetState(RUNNING,COMPLETING);
  if (doCompletion) {
    this.value=v;
    this.exception=((finalState & (CANCELLED | INTERRUPTED)) != 0) ? new CancellationException(""String_Node_Str"") : t;
    releaseShared(finalState);
  }
 else   if (getState() == COMPLETING) {
    acquireShared(-1);
  }
  return doCompletion;
}",0.9700722394220846
60165,"public void testGenericInterface(){
  Type fType=Function.class.getTypeParameters()[0];
  assertEquals(Integer.class,TypeToken.of(IntegerStringFunction.class).resolveType(fType).getRawType());
  Type predicateParameterType=Predicate.class.getTypeParameters()[0];
  assertEquals(new TypeToken<List<String>>(){
  }
.getType(),TypeToken.of(IntegerStringFunction.class).resolveType(predicateParameterType).getType());
}","public void testGenericInterface(){
  Type fType=Supplier.class.getTypeParameters()[0];
  assertEquals(Integer.class,TypeToken.of(IntegerStringFunction.class).resolveType(fType).getRawType());
  Type predicateParameterType=Predicate.class.getTypeParameters()[0];
  assertEquals(new TypeToken<List<String>>(){
  }
.getType(),TypeToken.of(IntegerStringFunction.class).resolveType(predicateParameterType).getType());
}",0.980722891566265
60166,"public void testParse_multipleKeys(){
  CacheBuilderSpec spec=parse(""String_Node_Str"" + ""String_Node_Str"");
  assertEquals(10,spec.initialCapacity.intValue());
  assertEquals(20,spec.maximumSize.intValue());
  assertNull(spec.maximumWeight);
  assertEquals(30,spec.concurrencyLevel.intValue());
  assertEquals(Strength.WEAK,spec.keyStrength);
  assertEquals(Strength.WEAK,spec.valueStrength);
  assertEquals(TimeUnit.HOURS,spec.writeExpirationTimeUnit);
  assertEquals(TimeUnit.MINUTES,spec.accessExpirationTimeUnit);
  assertEquals(1L,spec.writeExpirationDuration);
  assertEquals(10L,spec.accessExpirationDuration);
  CacheBuilder expected=CacheBuilder.newBuilder().initialCapacity(10).maximumSize(20).concurrencyLevel(30).weakKeys().weakValues().expireAfterAccess(10L,TimeUnit.MINUTES);
  assertCacheBuilderEquivalence(expected,CacheBuilder.from(spec));
}","public void testParse_multipleKeys(){
  CacheBuilderSpec spec=parse(""String_Node_Str"" + ""String_Node_Str"");
  assertEquals(10,spec.initialCapacity.intValue());
  assertEquals(20,spec.maximumSize.intValue());
  assertNull(spec.maximumWeight);
  assertEquals(30,spec.concurrencyLevel.intValue());
  assertEquals(Strength.WEAK,spec.keyStrength);
  assertEquals(Strength.WEAK,spec.valueStrength);
  assertEquals(TimeUnit.HOURS,spec.writeExpirationTimeUnit);
  assertEquals(TimeUnit.MINUTES,spec.accessExpirationTimeUnit);
  assertEquals(1L,spec.writeExpirationDuration);
  assertEquals(10L,spec.accessExpirationDuration);
  CacheBuilder expected=CacheBuilder.newBuilder().initialCapacity(10).maximumSize(20).concurrencyLevel(30).weakKeys().weakValues().expireAfterAccess(10L,TimeUnit.MINUTES).expireAfterWrite(1L,TimeUnit.HOURS);
  assertCacheBuilderEquivalence(expected,CacheBuilder.from(spec));
}",0.9794520547945206
60167,"private void assertCacheBuilderEquivalence(CacheBuilder a,CacheBuilder b){
  for (  Field f : CacheBuilder.class.getFields()) {
    f.setAccessible(true);
    try {
      assertEquals(""String_Node_Str"" + f.getName() + ""String_Node_Str"",f.get(a),f.get(b));
    }
 catch (    IllegalArgumentException e) {
      throw new AssertionError(e.getMessage());
    }
catch (    IllegalAccessException e) {
      throw new AssertionError(e.getMessage());
    }
  }
}","private static void assertCacheBuilderEquivalence(CacheBuilder a,CacheBuilder b){
  assertEquals(""String_Node_Str"",a.concurrencyLevel,b.concurrencyLevel);
  assertEquals(""String_Node_Str"",a.expireAfterAccessNanos,b.expireAfterAccessNanos);
  assertEquals(""String_Node_Str"",a.expireAfterWriteNanos,b.expireAfterWriteNanos);
  assertEquals(""String_Node_Str"",a.initialCapacity,b.initialCapacity);
  assertEquals(""String_Node_Str"",a.maximumSize,b.maximumSize);
  assertEquals(""String_Node_Str"",a.maximumWeight,b.maximumWeight);
  assertEquals(""String_Node_Str"",a.refreshNanos,b.refreshNanos);
  assertEquals(""String_Node_Str"",a.keyEquivalence,b.keyEquivalence);
  assertEquals(""String_Node_Str"",a.keyStrength,b.keyStrength);
  assertEquals(""String_Node_Str"",a.removalListener,b.removalListener);
  assertEquals(""String_Node_Str"",a.weigher,b.weigher);
  assertEquals(""String_Node_Str"",a.valueEquivalence,b.valueEquivalence);
  assertEquals(""String_Node_Str"",a.valueStrength,b.valueStrength);
  assertEquals(""String_Node_Str"",a.statsCounterSupplier,b.statsCounterSupplier);
  assertEquals(""String_Node_Str"",a.ticker,b.ticker);
}",0.1064638783269961
60168,"public void testParse_accessExpirationAndWriteExpiration(){
  CacheBuilderSpec spec=parse(""String_Node_Str"");
  assertEquals(TimeUnit.MINUTES,spec.writeExpirationTimeUnit);
  assertEquals(9L,spec.writeExpirationDuration);
  assertEquals(TimeUnit.SECONDS,spec.accessExpirationTimeUnit);
  assertEquals(10L,spec.accessExpirationDuration);
  assertCacheBuilderEquivalence(CacheBuilder.newBuilder().expireAfterAccess(10L,TimeUnit.SECONDS),CacheBuilder.from(spec));
}","public void testParse_accessExpirationAndWriteExpiration(){
  CacheBuilderSpec spec=parse(""String_Node_Str"");
  assertEquals(TimeUnit.MINUTES,spec.writeExpirationTimeUnit);
  assertEquals(9L,spec.writeExpirationDuration);
  assertEquals(TimeUnit.SECONDS,spec.accessExpirationTimeUnit);
  assertEquals(10L,spec.accessExpirationDuration);
  assertCacheBuilderEquivalence(CacheBuilder.newBuilder().expireAfterAccess(10L,TimeUnit.SECONDS).expireAfterWrite(9L,TimeUnit.MINUTES),CacheBuilder.from(spec));
}",0.9604989604989606
60169,"/** 
 * Creates a   {@link CheckedFuture} out of a normal {@link ListenableFuture}and a   {@link Function} that maps from {@link Exception} instances into theappropriate checked type. <p>The given mapping function will be applied to an {@link InterruptedException}, a   {@link CancellationException}, or an  {@link ExecutionException} with the actual cause of the exception.See  {@link Future#get()} for details on the exceptions thrown.
 * @since 9.0 (source-compatible since 1.0)
 */
public static <V,X extends Exception>CheckedFuture<V,X> makeChecked(ListenableFuture<V> future,Function<Exception,X> mapper){
  return new MappingCheckedFuture<V,X>(checkNotNull(future),mapper);
}","/** 
 * Creates a   {@link CheckedFuture} out of a normal {@link ListenableFuture}and a   {@link Function} that maps from {@link Exception} instances into theappropriate checked type. <p>The given mapping function will be applied to an {@link InterruptedException}, a   {@link CancellationException}, or an  {@link ExecutionException}. See   {@link Future#get()} for details on the exceptions thrown.
 * @since 9.0 (source-compatible since 1.0)
 */
public static <V,X extends Exception>CheckedFuture<V,X> makeChecked(ListenableFuture<V> future,Function<Exception,X> mapper){
  return new MappingCheckedFuture<V,X>(checkNotNull(future),mapper);
}",0.9691032403918614
60170,"public void testManualServiceStopWhileStarting() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  service.notifyStarted();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(Arrays.asList(State.STARTING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testManualServiceStopWhileStarting() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  service.notifyStarted();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(ImmutableList.of(State.STARTING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9875074360499704
60171,"public void testManualServiceNotifyStoppedWhileRunning() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.TERMINATED),listener.getStateHistory());
}","public void testManualServiceNotifyStoppedWhileRunning() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.TERMINATED),listener.getStateHistory());
}",0.979187314172448
60172,"@Override protected void doStop(){
  notifyFailed(EXCEPTION);
}","@Override protected void doStop(){
}",0.7272727272727273
60173,"public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
  RunThrowingService service=new RunThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  service.startAndWait();
  try {
    service.stopAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(EXCEPTION,e.getCause().getCause());
  }
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.FAILED),listener.getStateHistory());
}","public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
  RunThrowingService service=new RunThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  service.startAndWait();
  try {
    service.stopAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(service.exception,e.getCause().getCause());
  }
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.FAILED),listener.getStateHistory());
}",0.8592283628779979
60174,"public void testManualServiceFailWhileRunning() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.notifyFailed(EXCEPTION);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.FAILED),listener.getStateHistory());
}","public void testManualServiceFailWhileRunning() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.notifyFailed(EXCEPTION);
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.FAILED),listener.getStateHistory());
}",0.9721115537848606
60175,"public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
  StopThrowingService service=new StopThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  service.startAndWait();
  try {
    service.stopAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(EXCEPTION,e.getCause());
  }
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.FAILED),listener.getStateHistory());
}","public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
  StopThrowingService service=new StopThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  service.startAndWait();
  try {
    service.stopAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(service.exception,e.getCause());
  }
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.FAILED),listener.getStateHistory());
}",0.8838643371017472
60176,"public void testManualServiceStopWhileNew() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStartCalled);
  assertFalse(service.doStopCalled);
  assertEquals(Arrays.asList(State.TERMINATED),listener.getStateHistory());
}","public void testManualServiceStopWhileNew() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStartCalled);
  assertFalse(service.doStopCalled);
  assertEquals(ImmutableList.of(State.TERMINATED),listener.getStateHistory());
}",0.9764309764309764
60177,"public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
  final StartThrowingService service=new StartThrowingService();
  service.start();
  assertEquals(State.FAILED,service.state());
  service.addListener(new RecordingListener(service),MoreExecutors.sameThreadExecutor());
  Thread thread=new Thread(){
    @Override public void run(){
      service.start();
    }
  }
;
  thread.start();
  thread.join(100);
  assertFalse(thread + ""String_Node_Str"",thread.isAlive());
}","public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
  final StartFailingService service=new StartFailingService();
  service.start();
  assertEquals(State.FAILED,service.state());
  service.addListener(new RecordingListener(service),MoreExecutors.sameThreadExecutor());
  Thread thread=new Thread(){
    @Override public void run(){
      service.start();
    }
  }
;
  thread.start();
  thread.join(100);
  assertFalse(thread + ""String_Node_Str"",thread.isAlive());
}",0.9289940828402368
60178,"public void testNoOpServiceStartStop() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  assertEquals(State.NEW,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  service.start();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  assertTrue(service.running);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testNoOpServiceStartStop() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  assertEquals(State.NEW,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  service.start();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  assertTrue(service.running);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.984198645598194
60179,"public void testManualServiceFailWhileStopping() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.stop();
  service.notifyFailed(EXCEPTION);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.FAILED),listener.getStateHistory());
}","public void testManualServiceFailWhileStopping() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyStarted();
  service.stop();
  service.notifyFailed(EXCEPTION);
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.FAILED),listener.getStateHistory());
}",0.97442143727162
60180,"public void testManualServiceFailureIdempotence(){
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyFailed(new Exception(""String_Node_Str""));
  service.notifyFailed(new Exception(""String_Node_Str""));
  try {
    service.startAndWait();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(""String_Node_Str"",e.getCause().getMessage());
  }
}","public void testManualServiceFailureIdempotence(){
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener.record(service);
  service.start();
  service.notifyFailed(new Exception(""String_Node_Str""));
  service.notifyFailed(new Exception(""String_Node_Str""));
  try {
    service.startAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(""String_Node_Str"",e.getCause().getMessage());
  }
}",0.9570957095709572
60181,"public void testManualServiceStartStop() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.notifyStarted();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testManualServiceStartStop() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.notifyStarted();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9869969040247678
60182,"@Override public synchronized void failed(State from,Throwable failure){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.FAILED);
  assertEquals(State.FAILED,service.state());
  if (from == State.STARTING) {
    try {
      service.startAndWait();
    }
 catch (    UncheckedExecutionException e) {
      assertEquals(failure,e.getCause());
    }
  }
  try {
    service.stopAndWait();
  }
 catch (  UncheckedExecutionException e) {
    if (from == State.STOPPING) {
      assertEquals(failure,e.getCause());
    }
 else {
      assertEquals(failure,e.getCause().getCause());
    }
  }
  completionLatch.countDown();
}","@Override public synchronized void failed(State from,Throwable failure){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.FAILED);
  assertEquals(State.FAILED,service.state());
  if (from == State.STARTING) {
    try {
      service.startAndWait();
      fail();
    }
 catch (    UncheckedExecutionException e) {
      assertEquals(failure,e.getCause());
    }
  }
  try {
    service.stopAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    if (from == State.STOPPING) {
      assertEquals(failure,e.getCause());
    }
 else {
      assertEquals(failure,e.getCause().getCause());
    }
  }
  completionLatch.countDown();
}",0.9803625377643505
60183,"public void testManualServiceFailWhileStarting() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyFailed(EXCEPTION);
  assertEquals(Arrays.asList(State.STARTING,State.FAILED),listener.getStateHistory());
}","public void testManualServiceFailWhileStarting() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.notifyFailed(EXCEPTION);
  assertEquals(ImmutableList.of(State.STARTING,State.FAILED),listener.getStateHistory());
}",0.9687964338781576
60184,"public void testNoOpServiceStartStopIdempotence() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.start();
  assertEquals(State.RUNNING,service.state());
  service.stop();
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testNoOpServiceStartStopIdempotence() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.start();
  assertEquals(State.RUNNING,service.state());
  service.stop();
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9775401069518715
60185,"@Override protected void doStart(){
  notifyStarted();
}","@Override protected void doStart(){
}",0.7956989247311828
60186,"public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
  ThreadedService service=new ThreadedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start().get();
  assertEquals(State.RUNNING,service.state());
  service.awaitRunChecks();
  service.stop().get();
  assertEquals(State.TERMINATED,service.state());
  throwIfSet(thrownByExecutionThread);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
  ThreadedService service=new ThreadedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start().get();
  assertEquals(State.RUNNING,service.state());
  service.awaitRunChecks();
  service.stopAndWait();
  assertEquals(State.TERMINATED,service.state());
  throwIfSet(thrownByExecutionThread);
  assertEquals(ImmutableList.of(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9695238095238096
60187,"public void testThrowingServiceStartAndWait() throws Exception {
  StartThrowingService service=new StartThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  try {
    service.startAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(EXCEPTION,e.getCause());
  }
  assertEquals(Arrays.asList(State.STARTING,State.FAILED),listener.getStateHistory());
}","public void testThrowingServiceStartAndWait() throws Exception {
  StartThrowingService service=new StartThrowingService();
  RecordingListener listener=RecordingListener.record(service);
  try {
    service.startAndWait();
    fail();
  }
 catch (  UncheckedExecutionException e) {
    assertEquals(service.exception,e.getCause());
  }
  assertEquals(ImmutableList.of(State.STARTING,State.FAILED),listener.getStateHistory());
}",0.8662721893491124
60188,"synchronized ImmutableList<State> getStateHistory() throws Exception {
  completionLatch.await();
  return ImmutableList.copyOf(stateHistory);
}","ImmutableList<State> getStateHistory() throws Exception {
  completionLatch.await();
synchronized (this) {
    return ImmutableList.copyOf(stateHistory);
  }
}",0.8646864686468647
60189,"StateSnapshot(State internalState,boolean shutdownWhenStartupFinishes,Throwable failure){
  checkArgument(!shutdownWhenStartupFinishes || internalState == State.STARTING,""String_Node_Str"",internalState);
  checkArgument(!(failure != null ^ internalState == State.FAILED),""String_Node_Str"" + ""String_Node_Str"",internalState,failure);
  this.state=internalState;
  this.shutdownWhenStartupFinishes=shutdownWhenStartupFinishes;
  this.failure=failure;
}","StateSnapshot(State internalState,boolean shutdownWhenStartupFinishes,@Nullable Throwable failure){
  checkArgument(!shutdownWhenStartupFinishes || internalState == State.STARTING,""String_Node_Str"",internalState);
  checkArgument(!(failure != null ^ internalState == State.FAILED),""String_Node_Str"" + ""String_Node_Str"",internalState,failure);
  this.state=internalState;
  this.shutdownWhenStartupFinishes=shutdownWhenStartupFinishes;
  this.failure=failure;
}",0.989010989010989
60190,"/** 
 * Copies all characters between the   {@link Readable} and {@link Appendable}objects. Does not close or flush either object.
 * @param from the object to read from
 * @param to the object to write to
 * @return the number of characters copied
 * @throws IOException if an I/O error occurs
 */
public static long copy(Readable from,Appendable to) throws IOException {
  CharBuffer buf=CharBuffer.allocate(BUF_SIZE);
  long total=0;
  while (true) {
    int r=from.read(buf);
    if (r == -1) {
      break;
    }
    buf.flip();
    to.append(buf,0,r);
    total+=r;
  }
  return total;
}","/** 
 * Copies all characters between the   {@link Readable} and {@link Appendable}objects. Does not close or flush either object.
 * @param from the object to read from
 * @param to the object to write to
 * @return the number of characters copied
 * @throws IOException if an I/O error occurs
 */
public static long copy(Readable from,Appendable to) throws IOException {
  CharBuffer buf=CharBuffer.allocate(BUF_SIZE);
  long total=0;
  while (from.read(buf) != -1) {
    buf.flip();
    to.append(buf);
    total+=buf.remaining();
    buf.clear();
  }
  return total;
}",0.8497854077253219
60191,"public void testManualServiceStopWhileStarting(){
  ManualSwitchedService service=new ManualSwitchedService();
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  service.notifyStarted();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
}","public void testManualServiceStopWhileStarting() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.doStopCalled);
  service.notifyStarted();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(Arrays.asList(State.STARTING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.8738255033557047
60192,"@Override public void run(){
  service.state();
}","@Override protected void run() throws Exception {
}",0.52
60193,"@Override public synchronized void running(){
  assertEquals(State.STARTING,Iterables.getOnlyElement(stateHistory));
  stateHistory.add(State.RUNNING);
}","@Override public synchronized void running(){
  assertEquals(State.STARTING,Iterables.getOnlyElement(stateHistory));
  stateHistory.add(State.RUNNING);
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.start().isDone());
  assertEquals(State.RUNNING,service.startAndWait());
}",0.6845637583892618
60194,"public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
  final StartThrowingService service=new StartThrowingService();
  service.start();
  assertEquals(State.FAILED,service.state());
  service.addListener(new RecordingListener(),MoreExecutors.sameThreadExecutor());
  Thread thread=new Thread(){
    @Override public void run(){
      service.state();
    }
  }
;
  thread.start();
  thread.join(100);
  assertFalse(thread + ""String_Node_Str"",thread.isAlive());
}","public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
  final StartThrowingService service=new StartThrowingService();
  service.start();
  assertEquals(State.FAILED,service.state());
  service.addListener(new RecordingListener(service),MoreExecutors.sameThreadExecutor());
  Thread thread=new Thread(){
    @Override public void run(){
      service.start();
    }
  }
;
  thread.start();
  thread.join(100);
  assertFalse(thread + ""String_Node_Str"",thread.isAlive());
}",0.9890981169474728
60195,"@Override public synchronized void terminated(State from){
  assertEquals(from,Iterables.getLast(stateHistory,State.NEW));
  stateHistory.add(State.TERMINATED);
}","@Override public synchronized void terminated(State from){
  assertEquals(from,Iterables.getLast(stateHistory,State.NEW));
  stateHistory.add(State.TERMINATED);
  assertEquals(State.TERMINATED,service.state());
  assertTrue(service.start().isDone());
  if (from == State.NEW) {
    assertEquals(State.TERMINATED,service.startAndWait());
  }
  assertTrue(service.stop().isDone());
  assertEquals(State.TERMINATED,service.stopAndWait());
  completionLatch.countDown();
}",0.5142857142857142
60196,"public void testStopUnstartedService() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=new RecordingListener();
  service.addListener(listener,MoreExecutors.sameThreadExecutor());
  Future<State> stopResult=service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(State.TERMINATED,stopResult.get());
  Future<State> startResult=service.start();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(State.TERMINATED,startResult.get());
  assertEquals(State.TERMINATED,Iterables.getOnlyElement(listener.getStateHistory()));
}","public void testStopUnstartedService() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  Future<State> stopResult=service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(State.TERMINATED,stopResult.get());
  Future<State> startResult=service.start();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(State.TERMINATED,startResult.get());
  assertEquals(State.TERMINATED,Iterables.getOnlyElement(listener.getStateHistory()));
}",0.9246935201401052
60197,"public void testNoOpServiceStartStop(){
  RecordingListener listener=new RecordingListener();
  NoOpService service=new NoOpService();
  service.addListener(listener,MoreExecutors.sameThreadExecutor());
  assertEquals(State.NEW,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  service.start();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  assertTrue(service.running);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testNoOpServiceStartStop() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  assertEquals(State.NEW,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  service.start();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  assertTrue(service.running);
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertFalse(service.running);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.8740849194729137
60198,"public void testManualServiceStartStop(){
  ManualSwitchedService service=new ManualSwitchedService();
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.notifyStarted();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
}","public void testManualServiceStartStop() throws Exception {
  ManualSwitchedService service=new ManualSwitchedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  assertEquals(State.STARTING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStartCalled);
  service.notifyStarted();
  assertEquals(State.RUNNING,service.state());
  assertTrue(service.isRunning());
  service.stop();
  assertEquals(State.STOPPING,service.state());
  assertFalse(service.isRunning());
  assertTrue(service.doStopCalled);
  service.notifyStopped();
  assertEquals(State.TERMINATED,service.state());
  assertFalse(service.isRunning());
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.8567375886524823
60199,"@Override public synchronized void failed(State from,Throwable failure){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.FAILED);
}","@Override public synchronized void failed(State from,Throwable failure){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.FAILED);
  assertEquals(State.FAILED,service.state());
  completionLatch.countDown();
}",0.8079800498753117
60200,"@Override public synchronized void stopping(State from){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.STOPPING);
}","@Override public synchronized void stopping(State from){
  assertEquals(from,Iterables.getLast(stateHistory));
  stateHistory.add(State.STOPPING);
  assertEquals(State.STOPPING,service.state());
  if (from == State.STARTING) {
    assertTrue(service.start().isDone());
    assertEquals(State.STOPPING,service.startAndWait());
  }
}",0.6179540709812108
60201,"public void testNoOpServiceStartStopIdempotence() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=new RecordingListener();
  service.addListener(listener,MoreExecutors.sameThreadExecutor());
  service.start();
  service.start();
  assertEquals(State.RUNNING,service.state());
  service.stop();
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testNoOpServiceStartStopIdempotence() throws Exception {
  NoOpService service=new NoOpService();
  RecordingListener listener=RecordingListener.record(service);
  service.start();
  service.start();
  assertEquals(State.RUNNING,service.state());
  service.stop();
  service.stop();
  assertEquals(State.TERMINATED,service.state());
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9131313131313132
60202,"public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
  ThreadedService service=new ThreadedService();
  RecordingListener listener=new RecordingListener();
  service.addListener(listener,MoreExecutors.sameThreadExecutor());
  service.start().get();
  assertEquals(State.RUNNING,service.state());
  service.awaitRunChecks();
  service.stop().get();
  assertEquals(State.TERMINATED,service.state());
  throwIfSet(thrownByExecutionThread);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}","public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
  ThreadedService service=new ThreadedService();
  RecordingListener listener=RecordingListener.record(service);
  service.start().get();
  assertEquals(State.RUNNING,service.state());
  service.awaitRunChecks();
  service.stop().get();
  assertEquals(State.TERMINATED,service.state());
  throwIfSet(thrownByExecutionThread);
  assertEquals(Arrays.asList(State.STARTING,State.RUNNING,State.STOPPING,State.TERMINATED),listener.getStateHistory());
}",0.9202898550724636
60203,"@Override public synchronized void starting(){
  assertTrue(stateHistory.isEmpty());
  stateHistory.add(State.STARTING);
}","@Override public synchronized void starting(){
  assertTrue(stateHistory.isEmpty());
  stateHistory.add(State.STARTING);
  assertEquals(State.STARTING,service.state());
  assertFalse(service.start().isDone());
}",0.7327327327327328
60204,"synchronized ImmutableList<State> getStateHistory(){
  return ImmutableList.copyOf(stateHistory);
}","synchronized ImmutableList<State> getStateHistory() throws Exception {
  completionLatch.await();
  return ImmutableList.copyOf(stateHistory);
}",0.8148148148148148
60205,"/** 
 * Specifies the maximum weight of entries the cache may contain. Weight is determined using the  {@link Weigher} specified with {@link #weigher}, and use of this method requires a corresponding call to   {@link #weigher} prior to calling {@link #build}. <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code weight} is zero, elements will be evicted immediately after being loaded intocache. This can be useful in testing, or to disable caching temporarily without a code change. <p>Note that weight is only used to determine whether the cache is over capacity; it has no effect on selecting which entry should be evicted next.
 * @param weight the maximum weight the cache may contain
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 * @since 11.0
 */
public CacheBuilder<K,V> maximumWeight(long weight){
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  this.maximumWeight=weight;
  checkArgument(weight >= 0,""String_Node_Str"");
  return this;
}","/** 
 * Specifies the maximum weight of entries the cache may contain. Weight is determined using the  {@link Weigher} specified with {@link #weigher}, and use of this method requires a corresponding call to   {@link #weigher} prior to calling {@link #build}. <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code weight} is zero, elements will be evicted immediately after being loaded intocache. This can be useful in testing, or to disable caching temporarily without a code change. <p>Note that weight is only used to determine whether the cache is over capacity; it has no effect on selecting which entry should be evicted next. <p>This feature cannot be used in conjunction with  {@link #maximumSize}.
 * @param weight the maximum total weight of entries the cache may contain
 * @throws IllegalArgumentException if {@code weight} is negative
 * @throws IllegalStateException if a maximum weight or size was already set
 * @since 11.0
 */
public CacheBuilder<K,V> maximumWeight(long weight){
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  this.maximumWeight=weight;
  checkArgument(weight >= 0,""String_Node_Str"");
  return this;
}",0.9576008273009308
60206,"/** 
 * Specifies the maximum number of entries the cache may contain. Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code size} is zero, elements will be evicted immediately after being loaded into thecache. This can be useful in testing, or to disable caching temporarily without a code change.
 * @param size the maximum size of the cache
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 */
public CacheBuilder<K,V> maximumSize(long size){
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.weigher == null,""String_Node_Str"");
  checkArgument(size >= 0,""String_Node_Str"");
  this.maximumSize=size;
  return this;
}","/** 
 * Specifies the maximum number of entries the cache may contain. Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code size} is zero, elements will be evicted immediately after being loaded into thecache. This can be useful in testing, or to disable caching temporarily without a code change. <p>This feature cannot be used in conjunction with  {@link #maximumWeight}.
 * @param size the maximum size of the cache
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size or weight was already set
 */
public CacheBuilder<K,V> maximumSize(long size){
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.weigher == null,""String_Node_Str"");
  checkArgument(size >= 0,""String_Node_Str"");
  this.maximumSize=size;
  return this;
}",0.9616071428571428
60207,"/** 
 * Loads a new value for key   {@code key}, possibly asynchronously. While the new value is loading the previous value (if any) will continue to be returned by   {@code get(key)} unless it isevicted. If the new value is loaded successfully it will replace the previous value in the cache; if an exception is thrown while refreshing the previous value will remain, <i>and the exception will be logged (using  {@link java.util.logging.Logger}) and swallowed</i>. <p>Caches loaded by a   {@link CacheLoader} will call {@link CacheLoader#reload} if thecache currently contains a value for  {@code key}, and   {@link CacheLoader#load} otherwise.<p>Returns without doing anything if another thread is currently loading the value for {@code key}. If the cache loader associated with this cache performs refresh asynchronously then this method may return before refresh completes.
 * @since 11.0
 */
void refresh(K key);","/** 
 * Loads a new value for key   {@code key}, possibly asynchronously. While the new value is loading the previous value (if any) will continue to be returned by   {@code get(key)} unless it isevicted. If the new value is loaded successfully it will replace the previous value in the cache; if an exception is thrown while refreshing the previous value will remain, <i>and the exception will be logged (using  {@link java.util.logging.Logger}) and swallowed</i>. <p>Caches loaded by a   {@link CacheLoader} will call {@link CacheLoader#reload} if thecache currently contains a value for  {@code key}, and   {@link CacheLoader#load} otherwise.Loading is asynchronous only if  {@link CacheLoader#reload} was overridden with anasynchronous implementation. <p>Returns without doing anything if another thread is currently loading the value for {@code key}. If the cache loader associated with this cache performs refresh asynchronously then this method may return before refresh completes.
 * @since 11.0
 */
void refresh(K key);",0.94293059125964
60208,"public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
  final CountDownLatch computationStarted=new CountDownLatch(2);
  final CountDownLatch letGetFinishSignal=new CountDownLatch(1);
  final CountDownLatch getFinishedSignal=new CountDownLatch(2);
  final String getKey=""String_Node_Str"";
  final String refreshKey=""String_Node_Str"";
  final String suffix=""String_Node_Str"";
  CacheLoader<String,String> computeFunction=new CacheLoader<String,String>(){
    @Override public String load(    String key) throws InterruptedException {
      computationStarted.countDown();
      letGetFinishSignal.await();
      return key + suffix;
    }
  }
;
  final LoadingCache<String,String> cache=CacheBuilder.newBuilder().build(computeFunction);
  ConcurrentMap<String,String> map=cache.asMap();
  map.put(refreshKey,refreshKey);
  new Thread(){
    @Override public void run(){
      cache.getUnchecked(getKey);
      getFinishedSignal.countDown();
    }
  }
.start();
  new Thread(){
    @Override public void run(){
      cache.refresh(refreshKey);
      getFinishedSignal.countDown();
    }
  }
.start();
  computationStarted.await();
  cache.invalidate(getKey);
  cache.invalidate(refreshKey);
  assertFalse(map.containsKey(getKey));
  assertFalse(map.containsKey(refreshKey));
  letGetFinishSignal.countDown();
  getFinishedSignal.await();
  checkNothingLogged();
  assertEquals(2,cache.size());
  assertEquals(getKey + suffix,map.get(getKey));
  assertEquals(refreshKey + suffix,map.get(refreshKey));
}","public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
  final CountDownLatch computationStarted=new CountDownLatch(2);
  final CountDownLatch letGetFinishSignal=new CountDownLatch(1);
  final CountDownLatch getFinishedSignal=new CountDownLatch(2);
  final String getKey=""String_Node_Str"";
  final String refreshKey=""String_Node_Str"";
  final String suffix=""String_Node_Str"";
  CacheLoader<String,String> computeFunction=new CacheLoader<String,String>(){
    @Override public String load(    String key) throws InterruptedException {
      computationStarted.countDown();
      letGetFinishSignal.await();
      return key + suffix;
    }
  }
;
  final LoadingCache<String,String> cache=CacheBuilder.newBuilder().build(computeFunction);
  ConcurrentMap<String,String> map=cache.asMap();
  map.put(refreshKey,refreshKey);
  new Thread(){
    @Override public void run(){
      cache.getUnchecked(getKey);
      getFinishedSignal.countDown();
    }
  }
.start();
  new Thread(){
    @Override public void run(){
      cache.refresh(refreshKey);
      getFinishedSignal.countDown();
    }
  }
.start();
  computationStarted.await();
  cache.invalidate(getKey);
  cache.invalidate(refreshKey);
  assertFalse(map.containsKey(getKey));
  assertFalse(map.containsKey(refreshKey));
  letGetFinishSignal.countDown();
  getFinishedSignal.await();
  checkNothingLogged();
  assertEquals(2,cache.size());
  assertEquals(getKey + suffix,map.get(getKey));
  assertEquals(refreshKey + suffix,map.get(refreshKey));
  assertEquals(2,cache.size());
}",0.9896973599484868
60209,"boolean storeLoadedValue(K key,int hash,LoadingValueReference<K,V> oldValueReference,V newValue){
  lock();
  try {
    long now=map.ticker.read();
    preWriteCleanup(now);
    int newCount=this.count + 1;
    AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
    int index=hash & (table.length() - 1);
    ReferenceEntry<K,V> first=table.get(index);
    for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
      K entryKey=e.getKey();
      if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key,entryKey)) {
        ValueReference<K,V> valueReference=e.getValueReference();
        V entryValue=valueReference.get();
        if (entryValue == null || oldValueReference == valueReference) {
          ++modCount;
          if (oldValueReference.isActive()) {
            RemovalCause cause=(entryValue == null) ? RemovalCause.COLLECTED : RemovalCause.REPLACED;
            enqueueNotification(key,hash,oldValueReference,cause);
            newCount--;
          }
          setValue(e,key,newValue,now);
          this.count=newCount;
          evictEntries();
          return true;
        }
        valueReference=new WeightedStrongValueReference<K,V>(newValue,0);
        enqueueNotification(key,hash,valueReference,RemovalCause.REPLACED);
        return false;
      }
    }
    ++modCount;
    ReferenceEntry<K,V> newEntry=newEntry(key,hash,first);
    setValue(newEntry,key,newValue,now);
    table.set(index,newEntry);
    this.count=newCount;
    evictEntries();
    return true;
  }
  finally {
    unlock();
    postWriteCleanup();
  }
}","boolean storeLoadedValue(K key,int hash,LoadingValueReference<K,V> oldValueReference,V newValue){
  lock();
  try {
    long now=map.ticker.read();
    preWriteCleanup(now);
    int newCount=this.count + 1;
    AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
    int index=hash & (table.length() - 1);
    ReferenceEntry<K,V> first=table.get(index);
    for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
      K entryKey=e.getKey();
      if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key,entryKey)) {
        ValueReference<K,V> valueReference=e.getValueReference();
        V entryValue=valueReference.get();
        if (oldValueReference == valueReference || (entryValue == null && valueReference != UNSET)) {
          ++modCount;
          if (oldValueReference.isActive()) {
            RemovalCause cause=(entryValue == null) ? RemovalCause.COLLECTED : RemovalCause.REPLACED;
            enqueueNotification(key,hash,oldValueReference,cause);
            newCount--;
          }
          setValue(e,key,newValue,now);
          this.count=newCount;
          evictEntries();
          return true;
        }
        valueReference=new WeightedStrongValueReference<K,V>(newValue,0);
        enqueueNotification(key,hash,valueReference,RemovalCause.REPLACED);
        return false;
      }
    }
    ++modCount;
    ReferenceEntry<K,V> newEntry=newEntry(key,hash,first);
    setValue(newEntry,key,newValue,now);
    table.set(index,newEntry);
    this.count=newCount;
    evictEntries();
    return true;
  }
  finally {
    unlock();
    postWriteCleanup();
  }
}",0.9674014281279106
60210,"@Sequential public void testUnloadableWithoutSecurityManager() throws Exception {
  SecurityManager oldSecurityManager=System.getSecurityManager();
  try {
    System.setSecurityManager(null);
    doTestUnloadable();
  }
  finally {
    System.setSecurityManager(oldSecurityManager);
  }
}","public void testUnloadableWithoutSecurityManager() throws Exception {
  SecurityManager oldSecurityManager=System.getSecurityManager();
  try {
    System.setSecurityManager(null);
    doTestUnloadable();
  }
  finally {
    System.setSecurityManager(oldSecurityManager);
  }
}",0.978798586572438
60211,"@Sequential public void testUnloadableWithSecurityManager() throws Exception {
  Policy oldPolicy=Policy.getPolicy();
  SecurityManager oldSecurityManager=System.getSecurityManager();
  try {
    Policy.setPolicy(new PermissivePolicy());
    System.setSecurityManager(new SecurityManager());
    doTestUnloadable();
  }
  finally {
    System.setSecurityManager(oldSecurityManager);
    Policy.setPolicy(oldPolicy);
  }
}","public void testUnloadableWithSecurityManager() throws Exception {
  Policy oldPolicy=Policy.getPolicy();
  SecurityManager oldSecurityManager=System.getSecurityManager();
  try {
    Policy.setPolicy(new PermissivePolicy());
    System.setSecurityManager(new SecurityManager());
    doTestUnloadable();
  }
  finally {
    System.setSecurityManager(oldSecurityManager);
    Policy.setPolicy(oldPolicy);
  }
}",0.9855421686746988
60212,"/** 
 * Returns a factory that will supply instances of   {@link OutputStreamWriter}, using the given   {@link OutputStream} factory and character set.
 * @param out the factory that will be used to open output streams
 * @param charset the character set used to encode the output stream
 * @return the factory
 */
public static OutputSupplier<OutputStreamWriter> newWriterSupplier(final OutputSupplier<? extends OutputStream> out,final Charset charset){
  Preconditions.checkNotNull(out);
  Preconditions.checkNotNull(charset);
  return new OutputSupplier<OutputStreamWriter>(){
    @Override public OutputStreamWriter getOutput() throws IOException {
      return new OutputStreamWriter(out.getOutput(),charset);
    }
  }
;
}","/** 
 * Returns a factory that will supply instances of   {@link OutputStreamWriter}, using the given   {@link OutputStream} factory and character set.
 * @param out the factory that will be used to open output streams
 * @param charset the charset used to encode the output stream; see {@link Charsets} for helpful predefined constants
 * @return the factory
 */
public static OutputSupplier<OutputStreamWriter> newWriterSupplier(final OutputSupplier<? extends OutputStream> out,final Charset charset){
  Preconditions.checkNotNull(out);
  Preconditions.checkNotNull(charset);
  return new OutputSupplier<OutputStreamWriter>(){
    @Override public OutputStreamWriter getOutput() throws IOException {
      return new OutputStreamWriter(out.getOutput(),charset);
    }
  }
;
}",0.9116279069767442
60213,"/** 
 * Returns a factory that will supply instances of   {@link InputStreamReader}, using the given   {@link InputStream} factory and character set.
 * @param in the factory that will be used to open input streams
 * @param charset the character set used to decode the input stream
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(final InputSupplier<? extends InputStream> in,final Charset charset){
  Preconditions.checkNotNull(in);
  Preconditions.checkNotNull(charset);
  return new InputSupplier<InputStreamReader>(){
    @Override public InputStreamReader getInput() throws IOException {
      return new InputStreamReader(in.getInput(),charset);
    }
  }
;
}","/** 
 * Returns a factory that will supply instances of   {@link InputStreamReader}, using the given   {@link InputStream} factory and character set.
 * @param in the factory that will be used to open input streams
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(final InputSupplier<? extends InputStream> in,final Charset charset){
  Preconditions.checkNotNull(in);
  Preconditions.checkNotNull(charset);
  return new InputSupplier<InputStreamReader>(){
    @Override public InputStreamReader getInput() throws IOException {
      return new InputStreamReader(in.getInput(),charset);
    }
  }
;
}",0.9108236895847516
60214,"/** 
 * Returns a buffered writer that writes to a file using the given character set.
 * @param file the file to write to
 * @param charset the character set used when writing the file
 * @return the buffered writer
 */
public static BufferedWriter newWriter(File file,Charset charset) throws FileNotFoundException {
  return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),charset));
}","/** 
 * Returns a buffered writer that writes to a file using the given character set.
 * @param file the file to write to
 * @param charset the charset used to encode the output stream; see {@link Charsets} for helpful predefined constants
 * @return the buffered writer
 */
public static BufferedWriter newWriter(File file,Charset charset) throws FileNotFoundException {
  return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),charset));
}",0.8541905855338691
60215,"/** 
 * Streams lines from a   {@link File}, stopping when our callback returns false, or we have read all of the lines.
 * @param file the file to read from
 * @param charset the character set used when writing the file
 * @param callback the {@link LineProcessor} to use to handle the lines
 * @return the output of processing the lines
 * @throws IOException if an I/O error occurs
 */
public static <T>T readLines(File file,Charset charset,LineProcessor<T> callback) throws IOException {
  return CharStreams.readLines(Files.newReaderSupplier(file,charset),callback);
}","/** 
 * Streams lines from a   {@link File}, stopping when our callback returns false, or we have read all of the lines.
 * @param file the file to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @param callback the {@link LineProcessor} to use to handle the lines
 * @return the output of processing the lines
 * @throws IOException if an I/O error occurs
 */
public static <T>T readLines(File file,Charset charset,LineProcessor<T> callback) throws IOException {
  return CharStreams.readLines(Files.newReaderSupplier(file,charset),callback);
}",0.895
60216,"/** 
 * Copies all characters from a file to an appendable object, using the given character set.
 * @param from the source file
 * @param charset the character set used when reading the file
 * @param to the appendable object
 * @throws IOException if an I/O error occurs
 */
public static void copy(File from,Charset charset,Appendable to) throws IOException {
  CharStreams.copy(newReaderSupplier(from,charset),to);
}","/** 
 * Copies all characters from a file to an appendable object, using the given character set.
 * @param from the source file
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @param to the appendable object
 * @throws IOException if an I/O error occurs
 */
public static void copy(File from,Charset charset,Appendable to) throws IOException {
  CharStreams.copy(newReaderSupplier(from,charset),to);
}",0.8590604026845637
60217,"/** 
 * Private helper method. Writes a character sequence to a file, optionally appending.
 * @param from the character sequence to append
 * @param to the destination file
 * @param charset the character set used when writing the file
 * @param append true to append, false to overwrite
 * @throws IOException if an I/O error occurs
 */
private static void write(CharSequence from,File to,Charset charset,boolean append) throws IOException {
  CharStreams.write(from,newWriterSupplier(to,charset,append));
}","/** 
 * Private helper method. Writes a character sequence to a file, optionally appending.
 * @param from the character sequence to append
 * @param to the destination file
 * @param charset the charset used to encode the output stream; see {@link Charsets} for helpful predefined constants
 * @param append true to append, false to overwrite
 * @throws IOException if an I/O error occurs
 */
private static void write(CharSequence from,File to,Charset charset,boolean append) throws IOException {
  CharStreams.write(from,newWriterSupplier(to,charset,append));
}",0.8816402609506058
60218,"/** 
 * Returns a buffered reader that reads from a file using the given character set.
 * @param file the file to read from
 * @param charset the character set used when writing the file
 * @return the buffered reader
 */
public static BufferedReader newReader(File file,Charset charset) throws FileNotFoundException {
  return new BufferedReader(new InputStreamReader(new FileInputStream(file),charset));
}","/** 
 * Returns a buffered reader that reads from a file using the given character set.
 * @param file the file to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return the buffered reader
 */
public static BufferedReader newReader(File file,Charset charset) throws FileNotFoundException {
  return new BufferedReader(new InputStreamReader(new FileInputStream(file),charset));
}",0.8551724137931035
60219,"/** 
 * Reads the first line from a file. The line does not include line-termination characters, but does include other leading and trailing whitespace.
 * @param file the file to read from
 * @param charset the character set used when writing the file
 * @return the first line, or null if the file is empty
 * @throws IOException if an I/O error occurs
 */
public static String readFirstLine(File file,Charset charset) throws IOException {
  return CharStreams.readFirstLine(Files.newReaderSupplier(file,charset));
}","/** 
 * Reads the first line from a file. The line does not include line-termination characters, but does include other leading and trailing whitespace.
 * @param file the file to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return the first line, or null if the file is empty
 * @throws IOException if an I/O error occurs
 */
public static String readFirstLine(File file,Charset charset) throws IOException {
  return CharStreams.readFirstLine(Files.newReaderSupplier(file,charset));
}",0.8844036697247707
60220,"/** 
 * Returns a factory that will supply instances of   {@link OutputStreamWriter}that write to or append to a file using the given character set.
 * @param file the file to write to
 * @param charset the character set used when writing the file
 * @param append if true, the encoded characters will be appended to the file;otherwise the file is overwritten
 * @return the factory
 */
public static OutputSupplier<OutputStreamWriter> newWriterSupplier(File file,Charset charset,boolean append){
  return CharStreams.newWriterSupplier(newOutputStreamSupplier(file,append),charset);
}","/** 
 * Returns a factory that will supply instances of   {@link OutputStreamWriter}that write to or append to a file using the given character set.
 * @param file the file to write to
 * @param charset the charset used to encode the output stream; see {@link Charsets} for helpful predefined constants
 * @param append if true, the encoded characters will be appended to the file;otherwise the file is overwritten
 * @return the factory
 */
public static OutputSupplier<OutputStreamWriter> newWriterSupplier(File file,Charset charset,boolean append){
  return CharStreams.newWriterSupplier(newOutputStreamSupplier(file,append),charset);
}",0.8961569910057237
60221,"/** 
 * Reads all characters from a file into a   {@link String}, using the given character set.
 * @param file the file to read from
 * @param charset the character set used when reading the file
 * @return a string containing all the characters from the file
 * @throws IOException if an I/O error occurs
 */
public static String toString(File file,Charset charset) throws IOException {
  return new String(toByteArray(file),charset.name());
}","/** 
 * Reads all characters from a file into a   {@link String}, using the given character set.
 * @param file the file to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return a string containing all the characters from the file
 * @throws IOException if an I/O error occurs
 */
public static String toString(File file,Charset charset) throws IOException {
  return new String(toByteArray(file),charset.name());
}",0.8665254237288136
60222,"/** 
 * Returns a factory that will supply instances of  {@link InputStreamReader} that read a file using the given character set.
 * @param file the file to read from
 * @param charset the character set used when reading the file
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(File file,Charset charset){
  return CharStreams.newReaderSupplier(newInputStreamSupplier(file),charset);
}","/** 
 * Returns a factory that will supply instances of  {@link InputStreamReader} that read a file using the given character set.
 * @param file the file to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(File file,Charset charset){
  return CharStreams.newReaderSupplier(newInputStreamSupplier(file),charset);
}",0.862144420131291
60223,"/** 
 * Appends a character sequence (such as a string) to a file using the given character set.
 * @param from the character sequence to append
 * @param to the destination file
 * @param charset the character set used when writing the file
 * @throws IOException if an I/O error occurs
 */
public static void append(CharSequence from,File to,Charset charset) throws IOException {
  write(from,to,charset,true);
}","/** 
 * Appends a character sequence (such as a string) to a file using the given character set.
 * @param from the character sequence to append
 * @param to the destination file
 * @param charset the charset used to encode the output stream; see {@link Charsets} for helpful predefined constants
 * @throws IOException if an I/O error occurs
 */
public static void append(CharSequence from,File to,Charset charset) throws IOException {
  write(from,to,charset,true);
}",0.8561721404303511
60224,"/** 
 * Reads all of the lines from a URL. The lines do not include line-termination characters, but do include other leading and trailing whitespace.
 * @param url the URL to read from
 * @param charset the character set used when writing the file
 * @return a mutable {@link List} containing all the lines
 * @throws IOException if an I/O error occurs
 */
public static List<String> readLines(URL url,Charset charset) throws IOException {
  return CharStreams.readLines(newReaderSupplier(url,charset));
}","/** 
 * Reads all of the lines from a URL. The lines do not include line-termination characters, but do include other leading and trailing whitespace.
 * @param url the URL to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return a mutable {@link List} containing all the lines
 * @throws IOException if an I/O error occurs
 */
public static List<String> readLines(URL url,Charset charset) throws IOException {
  return CharStreams.readLines(newReaderSupplier(url,charset));
}",0.8818011257035647
60225,"/** 
 * Reads all characters from a URL into a   {@link String}, using the given character set.
 * @param url the URL to read from
 * @param charset the character set used when reading the URL
 * @return a string containing all the characters from the URL
 * @throws IOException if an I/O error occurs.
 */
public static String toString(URL url,Charset charset) throws IOException {
  return CharStreams.toString(newReaderSupplier(url,charset));
}","/** 
 * Reads all characters from a URL into a   {@link String}, using the given character set.
 * @param url the URL to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return a string containing all the characters from the URL
 * @throws IOException if an I/O error occurs.
 */
public static String toString(URL url,Charset charset) throws IOException {
  return CharStreams.toString(newReaderSupplier(url,charset));
}",0.8682824025289779
60226,"/** 
 * Returns a factory that will supply instances of  {@link InputStreamReader} that read a URL using the given character set.
 * @param url the URL to read from
 * @param charset the character set used when reading the URL contents
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(URL url,Charset charset){
  return CharStreams.newReaderSupplier(newInputStreamSupplier(url),charset);
}","/** 
 * Returns a factory that will supply instances of  {@link InputStreamReader} that read a URL using the given character set.
 * @param url the URL to read from
 * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful predefined constants
 * @return the factory
 */
public static InputSupplier<InputStreamReader> newReaderSupplier(URL url,Charset charset){
  return CharStreams.newReaderSupplier(newInputStreamSupplier(url),charset);
}",0.8593406593406593
60227,"/** 
 * Associates   {@code value} with {@code key} in this cache. If the cache previously contained avalue associated with  {@code key}, the old value is replaced by   {@code value}. <p>Prefer   {@link #get(K,Callable)} when using the conventional ""if cached, return; otherwisecreate, cache and return"" pattern.
 * @since 11.0
 */
void put(K key,V value);","/** 
 * Associates   {@code value} with {@code key} in this cache. If the cache previously contained avalue associated with  {@code key}, the old value is replaced by   {@code value}. <p>Prefer   {@link #get(Object,Callable)} when using the conventional ""if cached, return;otherwise create, cache and return"" pattern.
 * @since 11.0
 */
void put(K key,V value);",0.98744769874477
60228,"/** 
 * Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, the most recent replacement of its value, or its last access. Access time is reset by all cache read and write operations (including  {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations on the collection-views of   {@link Cache#asMap}. <p>When   {@code duration} is zero, this method hands off to{@link #maximumSize maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be useful in testing, or to disable caching temporarily without a code change. <p>Expired entries may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Expired entries are cleaned up as part of the routine maintenance described in the class javadoc.
 * @param duration the length of time after an entry is last accessed that it should beautomatically removed
 * @param unit the unit that {@code duration} is expressed in
 * @throws IllegalArgumentException if {@code duration} is negative
 * @throws IllegalStateException if the time to idle or time to live was already set
 */
public CacheBuilder<K,V> expireAfterAccess(long duration,TimeUnit unit){
  checkState(expireAfterAccessNanos == UNSET_INT,""String_Node_Str"",expireAfterAccessNanos);
  checkArgument(duration >= 0,""String_Node_Str"",duration,unit);
  this.expireAfterAccessNanos=unit.toNanos(duration);
  return this;
}","/** 
 * Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, the most recent replacement of its value, or its last access. Access time is reset by all cache read and write operations (including  {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations on the collection-views of   {@link Cache#asMap}. <p>When   {@code duration} is zero, this method hands off to{@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be useful in testing, or to disable caching temporarily without a code change. <p>Expired entries may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Expired entries are cleaned up as part of the routine maintenance described in the class javadoc.
 * @param duration the length of time after an entry is last accessed that it should beautomatically removed
 * @param unit the unit that {@code duration} is expressed in
 * @throws IllegalArgumentException if {@code duration} is negative
 * @throws IllegalStateException if the time to idle or time to live was already set
 */
public CacheBuilder<K,V> expireAfterAccess(long duration,TimeUnit unit){
  checkState(expireAfterAccessNanos == UNSET_INT,""String_Node_Str"",expireAfterAccessNanos);
  checkArgument(duration >= 0,""String_Node_Str"",duration,unit);
  this.expireAfterAccessNanos=unit.toNanos(duration);
  return this;
}",0.9980184940554822
60229,"/** 
 * Specifies the maximum weight of entries the cache may contain. Weight is determined using the  {@link Weigher} specified with {@link #weigher}, and use of this method requires a corresponding call to   {@link #weigher} prior to calling {@link #build}. <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code weight} is zero, elements will be evicted immediately after being loaded intocache. This can be useful in testing, or to disable caching temporarily without a code change.
 * @param weight the maximum weight the cache may contain
 * @param weigher the weigher to use in calculating the weight of cache entries
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 * @since 11.0
 */
public CacheBuilder<K,V> maximumWeight(long weight){
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  this.maximumWeight=weight;
  checkArgument(weight >= 0,""String_Node_Str"");
  return this;
}","/** 
 * Specifies the maximum weight of entries the cache may contain. Weight is determined using the  {@link Weigher} specified with {@link #weigher}, and use of this method requires a corresponding call to   {@link #weigher} prior to calling {@link #build}. <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. <p>When   {@code weight} is zero, elements will be evicted immediately after being loaded intocache. This can be useful in testing, or to disable caching temporarily without a code change.
 * @param weight the maximum weight the cache may contain
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 * @since 11.0
 */
public CacheBuilder<K,V> maximumWeight(long weight){
  checkState(this.maximumWeight == UNSET_INT,""String_Node_Str"",this.maximumWeight);
  checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  this.maximumWeight=weight;
  checkArgument(weight >= 0,""String_Node_Str"");
  return this;
}",0.9690162664601084
60230,"/** 
 * Specifies that each value (not key) stored in the cache should be wrapped in a  {@link SoftReference} (by default, strong references are used). Softly-referenced objects willbe garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory demand. <p><b>Warning:</b> in most circumstances it is better to set a per-cache  {@linkplain #maximumSize maximum size} instead of using soft references. You should only use this method ifyou are well familiar with the practical consequences of soft references. <p><b>Note:</b> when this method is used, the resulting cache will use identity ( {@code ==}) comparison to determine equality of values. <p>Entries with values that have been garbage collected may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Entries with garbage collected values are cleaned up as part of the routine maintenance described in the class javadoc.
 * @throws IllegalStateException if the value strength was already set
 */
@GwtIncompatible(""String_Node_Str"") public CacheBuilder<K,V> softValues(){
  return setValueStrength(Strength.SOFT);
}","/** 
 * Specifies that each value (not key) stored in the cache should be wrapped in a  {@link SoftReference} (by default, strong references are used). Softly-referenced objects willbe garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory demand. <p><b>Warning:</b> in most circumstances it is better to set a per-cache  {@linkplain #maximumSize(long) maximum size} instead of using soft references. You should only use thismethod if you are well familiar with the practical consequences of soft references. <p><b>Note:</b> when this method is used, the resulting cache will use identity ( {@code ==}) comparison to determine equality of values. <p>Entries with values that have been garbage collected may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Entries with garbage collected values are cleaned up as part of the routine maintenance described in the class javadoc.
 * @throws IllegalStateException if the value strength was already set
 */
@GwtIncompatible(""String_Node_Str"") public CacheBuilder<K,V> softValues(){
  return setValueStrength(Strength.SOFT);
}",0.98861646234676
60231,"/** 
 * Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, or the most recent replacement of its value. <p>When   {@code duration} is zero, this method hands off to{@link #maximumSize maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be useful in testing, or to disable caching temporarily without a code change. <p>Expired entries may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Expired entries are cleaned up as part of the routine maintenance described in the class javadoc.
 * @param duration the length of time after an entry is created that it should be automaticallyremoved
 * @param unit the unit that {@code duration} is expressed in
 * @throws IllegalArgumentException if {@code duration} is negative
 * @throws IllegalStateException if the time to live or time to idle was already set
 */
public CacheBuilder<K,V> expireAfterWrite(long duration,TimeUnit unit){
  checkState(expireAfterWriteNanos == UNSET_INT,""String_Node_Str"",expireAfterWriteNanos);
  checkArgument(duration >= 0,""String_Node_Str"",duration,unit);
  this.expireAfterWriteNanos=unit.toNanos(duration);
  return this;
}","/** 
 * Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, or the most recent replacement of its value. <p>When   {@code duration} is zero, this method hands off to{@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be useful in testing, or to disable caching temporarily without a code change. <p>Expired entries may be counted in   {@link Cache#size}, but will never be visible to read or write operations. Expired entries are cleaned up as part of the routine maintenance described in the class javadoc.
 * @param duration the length of time after an entry is created that it should be automaticallyremoved
 * @param unit the unit that {@code duration} is expressed in
 * @throws IllegalArgumentException if {@code duration} is negative
 * @throws IllegalStateException if the time to live or time to idle was already set
 */
public CacheBuilder<K,V> expireAfterWrite(long duration,TimeUnit unit){
  checkState(expireAfterWriteNanos == UNSET_INT,""String_Node_Str"",expireAfterWriteNanos);
  checkArgument(duration >= 0,""String_Node_Str"",duration,unit);
  this.expireAfterWriteNanos=unit.toNanos(duration);
  return this;
}",0.997639653815893
60232,"/** 
 * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into consideration by   {@link #maximumWeight} when determining which entries to evict, anduse of this method requires a corresponding call to  {@link #maximumWeight} prior to calling{@link #build}. Weights are measured and recorded when entries are inserted into the cache, and are thus effectively static during the lifetime of a cache entry. <p>When the weight of an entry is zero it will not be considered for size-based eviction (though it still may be evicted by other means). <p><b>Important note:</b> Instead of returning <em>this</em> as a   {@code CacheBuilder}instance, this method returns   {@code CacheBuilder<K1, V1>}. From this point on, either the original reference or the returned reference may be used to complete configuration and build the cache, but only the ""generic"" one is type-safe. That is, it will properly prevent you from building caches whose key or value types are incompatible with the types accepted by the weigher already provided; the   {@code CacheBuilder} type cannot do this. For best results,simply use the standard method-chaining idiom, as illustrated in the documentation at top, configuring a  {@code CacheBuilder} and building your {@link Cache} all in a single statement.<p><b>Warning:</b> if you ignore the above advice, and use this  {@code CacheBuilder} to builda cache whose key or value type is incompatible with the weigher, you will likely experience a  {@link ClassCastException} at some <i>undefined</i> point in the future.
 * @param weight the maximum weight the cache may contain
 * @param weigher the weigher to use in calculating the weight of cache entries
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 * @since 11.0
 */
public <K1 extends K,V1 extends V>CacheBuilder<K1,V1> weigher(Weigher<? super K1,? super V1> weigher){
  checkState(this.weigher == null);
  if (strictParsing) {
    checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  }
  @SuppressWarnings(""String_Node_Str"") CacheBuilder<K1,V1> me=(CacheBuilder<K1,V1>)this;
  me.weigher=checkNotNull(weigher);
  return me;
}","/** 
 * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into consideration by   {@link #maximumWeight(long)} when determining which entries to evict, anduse of this method requires a corresponding call to  {@link #maximumWeight(long)} prior tocalling  {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and are thus effectively static during the lifetime of a cache entry. <p>When the weight of an entry is zero it will not be considered for size-based eviction (though it still may be evicted by other means). <p><b>Important note:</b> Instead of returning <em>this</em> as a   {@code CacheBuilder}instance, this method returns   {@code CacheBuilder<K1, V1>}. From this point on, either the original reference or the returned reference may be used to complete configuration and build the cache, but only the ""generic"" one is type-safe. That is, it will properly prevent you from building caches whose key or value types are incompatible with the types accepted by the weigher already provided; the   {@code CacheBuilder} type cannot do this. For best results,simply use the standard method-chaining idiom, as illustrated in the documentation at top, configuring a  {@code CacheBuilder} and building your {@link Cache} all in a single statement.<p><b>Warning:</b> if you ignore the above advice, and use this  {@code CacheBuilder} to builda cache whose key or value type is incompatible with the weigher, you will likely experience a  {@link ClassCastException} at some <i>undefined</i> point in the future.
 * @param weigher the weigher to use in calculating the weight of cache entries
 * @throws IllegalArgumentException if {@code size} is negative
 * @throws IllegalStateException if a maximum size was already set
 * @since 11.0
 */
public <K1 extends K,V1 extends V>CacheBuilder<K1,V1> weigher(Weigher<? super K1,? super V1> weigher){
  checkState(this.weigher == null);
  if (strictParsing) {
    checkState(this.maximumSize == UNSET_INT,""String_Node_Str"",this.maximumSize);
  }
  @SuppressWarnings(""String_Node_Str"") CacheBuilder<K1,V1> me=(CacheBuilder<K1,V1>)this;
  me.weigher=checkNotNull(weigher);
  return me;
}",0.9804888988562458
60233,"/** 
 * Returns the value of each present instance from the supplied   {@code optionals}, in order, skipping over occurrences of   {@link Optional#absent}. Iterators are unmodifiable and are evaluated lazily.
 * @since 11.0
 */
public static <T>Iterable<T> presentInstances(Iterable<Optional<T>> optionals){
  checkNotNull(optionals);
  final Iterator<Optional<T>> iterator=checkNotNull(optionals.iterator());
  return new Iterable<T>(){
    @Override public Iterator<T> iterator(){
      return new AbstractIterator<T>(){
        @Override protected T computeNext(){
          while (iterator.hasNext()) {
            Optional<T> optional=iterator.next();
            if (optional.isPresent()) {
              return optional.get();
            }
          }
          return endOfData();
        }
      }
;
    }
  }
;
}","/** 
 * Returns the value of each present instance from the supplied   {@code optionals}, in order, skipping over occurrences of   {@link Optional#absent}. Iterators are unmodifiable and are evaluated lazily.
 * @since 11.0
 */
public static <T>Iterable<T> presentInstances(final Iterable<Optional<T>> optionals){
  checkNotNull(optionals);
  return new Iterable<T>(){
    @Override public Iterator<T> iterator(){
      return new AbstractIterator<T>(){
        private final Iterator<Optional<T>> iterator=checkNotNull(optionals.iterator());
        @Override protected T computeNext(){
          while (iterator.hasNext()) {
            Optional<T> optional=iterator.next();
            if (optional.isPresent()) {
              return optional.get();
            }
          }
          return endOfData();
        }
      }
;
    }
  }
;
}",0.8979591836734694
60234,"@Override public Iterator<T> iterator(){
  return new AbstractIterator<T>(){
    @Override protected T computeNext(){
      while (iterator.hasNext()) {
        Optional<T> optional=iterator.next();
        if (optional.isPresent()) {
          return optional.get();
        }
      }
      return endOfData();
    }
  }
;
}","@Override public Iterator<T> iterator(){
  return new AbstractIterator<T>(){
    private final Iterator<Optional<T>> iterator=checkNotNull(optionals.iterator());
    @Override protected T computeNext(){
      while (iterator.hasNext()) {
        Optional<T> optional=iterator.next();
        if (optional.isPresent()) {
          return optional.get();
        }
      }
      return endOfData();
    }
  }
;
}",0.8843537414965986
60235,"private Object[] buildParamList(Functor func,int indexOfParamToSetToNull){
  Class<?>[] types=func.getParameterTypes();
  Object[] params=new Object[types.length];
  for (int i=0; i < types.length; i++) {
    if (i != indexOfParamToSetToNull) {
      params[i]=defaults.get(types[i]);
      if (!parameterIsPrimitiveOrNullable(func,indexOfParamToSetToNull)) {
        Assert.assertTrue(""String_Node_Str"" + types[i].getName(),params[i] != null);
      }
    }
  }
  return params;
}","private Object[] buildParamList(Functor func,int indexOfParamToSetToNull){
  Class<?>[] types=func.getParameterTypes();
  Object[] params=new Object[types.length];
  for (int i=0; i < types.length; i++) {
    if (i != indexOfParamToSetToNull) {
      params[i]=defaults.get(types[i]);
      if (!parameterIsPrimitiveOrNullable(func,i)) {
        Assert.assertTrue(""String_Node_Str"" + types[i].getName(),params[i] != null);
      }
    }
  }
  return params;
}",0.9765957446808512
60236,"public void testXmlEscaper() throws Exception {
  CharEscaper xmlEscaper=XmlEscapers.xmlEscaper();
  assertBasicXmlEscaper(xmlEscaper,true);
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
}","public void testXmlEscaper() throws Exception {
  CharEscaper xmlEscaper=XmlEscapers.xmlEscaper();
  assertBasicXmlEscaper(xmlEscaper,true,false);
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
}",0.9916897506925209
60237,"public void testXmlContentEscaper() throws Exception {
  CharEscaper xmlContentEscaper=XmlEscapers.xmlContentEscaper();
  assertBasicXmlEscaper(xmlContentEscaper,false);
  assertEquals(""String_Node_Str"",xmlContentEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlContentEscaper.escape(""String_Node_Str""));
}","public void testXmlContentEscaper() throws Exception {
  CharEscaper xmlContentEscaper=XmlEscapers.xmlContentEscaper();
  assertBasicXmlEscaper(xmlContentEscaper,false,false);
  assertEquals(""String_Node_Str"",xmlContentEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlContentEscaper.escape(""String_Node_Str""));
}",0.9909638554216867
60238,"private void assertBasicXmlEscaper(CharEscaper xmlEscaper,boolean shouldEscapeQuotes){
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  String s=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(s,xmlEscaper.escape(s));
  for (char ch=0; ch < 0x20; ch++) {
    if (ch == '\t' || ch == '\n' || ch == '\r') {
      assertUnescaped(xmlEscaper,ch);
    }
 else {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
  }
  for (char ch=0x20; ch <= 0xFFFD; ch++) {
    if (ch == '&') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (ch == '<') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (ch == '>') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (shouldEscapeQuotes && ch == '\'') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (shouldEscapeQuotes && ch == '""') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else {
      String input=String.valueOf(ch);
      String escaped=xmlEscaper.escape(input);
      assertEquals(""String_Node_Str"" + Integer.toString(ch,16) + ""String_Node_Str"",input,escaped);
    }
  }
  assertUnescaped(xmlEscaper,'\uFFFE');
  assertUnescaped(xmlEscaper,'\uFFFF');
}","private void assertBasicXmlEscaper(CharEscaper xmlEscaper,boolean shouldEscapeQuotes,boolean shouldEscapeWhitespaceChars){
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  assertEquals(""String_Node_Str"",xmlEscaper.escape(""String_Node_Str""));
  String s=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(s,xmlEscaper.escape(s));
  for (char ch=0; ch < 0x20; ch++) {
    if (ch == '\t' || ch == '\n' || ch == '\r') {
      if (shouldEscapeWhitespaceChars) {
        assertEscaping(xmlEscaper,""String_Node_Str"" + Integer.toHexString(ch).toUpperCase() + ""String_Node_Str"",ch);
      }
 else {
        assertUnescaped(xmlEscaper,ch);
      }
    }
 else {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
  }
  for (char ch=0x20; ch <= 0xFFFD; ch++) {
    if (ch == '&') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (ch == '<') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (ch == '>') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (shouldEscapeQuotes && ch == '\'') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else     if (shouldEscapeQuotes && ch == '""') {
      assertEscaping(xmlEscaper,""String_Node_Str"",ch);
    }
 else {
      String input=String.valueOf(ch);
      String escaped=xmlEscaper.escape(input);
      assertEquals(""String_Node_Str"" + Integer.toString(ch,16) + ""String_Node_Str"",input,escaped);
    }
  }
  assertUnescaped(xmlEscaper,'\uFFFE');
  assertUnescaped(xmlEscaper,'\uFFFF');
}",0.9316037735849056
60239,"/** 
 * Returns an   {@link Escaper} instance that escapes special characters in astring so it can safely be included in an XML document as element content. See section <a href=""http://www.w3.org/TR/2008/REC-xml-20081126/#syntax"">2.4</a> of the XML specification. <p><b>Note</b>: Double and single quotes are not escaped, so it is <b>not safe</b> to use this escaper to escape attribute values. Use {@link #xmlEscaper} for cases where the output can appear in eitherattribute values or element content. <p>This escaper does not escape non-ASCII characters to their numeric character references (NCR). Any non-ASCII characters appearing in the input will be preserved in the output. Specifically ""\r"" (carriage return) is preserved in the output, which may result in it being silently converted to ""\n"" when the XML is parsed. <p>This escaper does not treat surrogate pairs specially and does not perform Unicode validation on its input.
 */
public static CharEscaper xmlContentEscaper(){
  return XML_CONTENT_ESCAPER;
}","/** 
 * Returns an   {@link Escaper} instance that escapes special characters in astring so it can safely be included in an XML document as element content. See section <a href=""http://www.w3.org/TR/2008/REC-xml-20081126/#syntax"">2.4</a> of the XML specification. <p><b>Note</b>: Double and single quotes are not escaped, so it is <b>not safe</b> to use this escaper to escape attribute values. Use {@link #xmlEscaper} if the output can appear in element content or{@link #xmlAttributeEscaper} in attribute values.<p>This escaper does not escape non-ASCII characters to their numeric character references (NCR). Any non-ASCII characters appearing in the input will be preserved in the output. Specifically ""\r"" (carriage return) is preserved in the output, which may result in it being silently converted to ""\n"" when the XML is parsed. <p>This escaper does not treat surrogate pairs specially and does not perform Unicode validation on its input.
 */
public static CharEscaper xmlContentEscaper(){
  return XML_CONTENT_ESCAPER;
}",0.9302098584675452
60240,"/** 
 * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this point.
 * @throws IllegalStateException if the stopwatch is already stopped.
 */
public Stopwatch stop(){
  long tick=ticker.read();
  checkState(isRunning);
  isRunning=false;
  elapsedNanos+=tick - startTick;
  return this;
}","/** 
 * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this point.
 * @return this {@code Stopwatch} instance
 * @throws IllegalStateException if the stopwatch is already stopped.
 */
public Stopwatch stop(){
  long tick=ticker.read();
  checkState(isRunning);
  isRunning=false;
  elapsedNanos+=tick - startTick;
  return this;
}",0.938483547925608
60241,"/** 
 * Starts the stopwatch.
 * @throws IllegalStateException if the stopwatch is already running.
 */
public Stopwatch start(){
  checkState(!isRunning);
  isRunning=true;
  startTick=ticker.read();
  return this;
}","/** 
 * Starts the stopwatch.
 * @return this {@code Stopwatch} instance
 * @throws IllegalStateException if the stopwatch is already running.
 */
public Stopwatch start(){
  checkState(!isRunning);
  isRunning=true;
  startTick=ticker.read();
  return this;
}",0.909853249475891
60242,"/** 
 * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.
 */
public Stopwatch reset(){
  elapsedNanos=0;
  isRunning=false;
  return this;
}","/** 
 * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.
 * @return this {@code Stopwatch} instance
 */
public Stopwatch reset(){
  elapsedNanos=0;
  isRunning=false;
  return this;
}",0.8905852417302799
60243,"/** 
 * Returns the empty iterator. <p>The   {@link Iterable} equivalent of this method is {@link Collections#emptySet}.
 */
@SuppressWarnings(""String_Node_Str"") public static <T>UnmodifiableIterator<T> emptyIterator(){
  return (UnmodifiableIterator<T>)EMPTY_ITERATOR;
}","/** 
 * Returns the empty iterator. <p>The   {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.
 */
@SuppressWarnings(""String_Node_Str"") public static <T>UnmodifiableIterator<T> emptyIterator(){
  return (UnmodifiableIterator<T>)EMPTY_ITERATOR;
}",0.935064935064935
60244,"/** 
 * Creates a new   {@code ListMultimap} that uses the provided map and factory.It can generate a multimap based on arbitrary  {@link Map} and {@link List}classes. <p>The   {@code factory}-generated and   {@code map} classes determine themultimap iteration order. They also specify the behavior of the {@code equals},   {@code hashCode}, and   {@code toString} methods for themultimap and its returned views. The multimap's  {@code get},   {@code removeAll}, and   {@code replaceValues} methods return {@code RandomAccess}lists if the factory does. However, the multimap's   {@code get} methodreturns instances of a different class than does  {@code factory.get()}. <p>The multimap is serializable if   {@code map},   {@code factory}, the lists generated by   {@code factory}, and the multimap contents are all serializable. <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if   {@code map} and the instances generated by{@code factory} are. Concurrent read operations will work correctly. Toallow concurrent update operations, wrap the multimap with a call to {@link #synchronizedListMultimap}. <p>Call this method only when the simpler methods  {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}won't suffice. <p>Note: the multimap assumes complete ownership over of   {@code map} andthe lists returned by  {@code factory}. Those objects should not be manually updated and they should not use soft, weak, or phantom references.
 * @param map place to store the mapping from each key to its correspondingvalues
 * @param factory supplier of new, empty lists that will each hold all valuesfor a given key
 * @throws IllegalArgumentException if {@code map} is not empty
 */
public static <K,V>ListMultimap<K,V> newListMultimap(Map<K,Collection<V>> map,final Supplier<? extends List<V>> factory){
  return new CustomListMultimap<K,V>(map,factory);
}","/** 
 * Creates a new   {@code ListMultimap} that uses the provided map and factory.It can generate a multimap based on arbitrary  {@link Map} and {@link List}classes. <p>The   {@code factory}-generated and   {@code map} classes determine themultimap iteration order. They also specify the behavior of the {@code equals},   {@code hashCode}, and   {@code toString} methods for themultimap and its returned views. The multimap's  {@code get},   {@code removeAll}, and   {@code replaceValues} methods return {@code RandomAccess}lists if the factory does. However, the multimap's   {@code get} methodreturns instances of a different class than does  {@code factory.get()}. <p>The multimap is serializable if   {@code map},   {@code factory}, the lists generated by   {@code factory}, and the multimap contents are all serializable. <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if   {@code map} and the instances generated by{@code factory} are. Concurrent read operations will work correctly. Toallow concurrent update operations, wrap the multimap with a call to {@link #synchronizedListMultimap}. <p>Call this method only when the simpler methods  {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}won't suffice. <p>Note: the multimap assumes complete ownership over of   {@code map} andthe lists returned by  {@code factory}. Those objects should not be manually updated, they should be empty when provided, and they should not use soft, weak, or phantom references.
 * @param map place to store the mapping from each key to its correspondingvalues
 * @param factory supplier of new, empty lists that will each hold all valuesfor a given key
 * @throws IllegalArgumentException if {@code map} is not empty
 */
public static <K,V>ListMultimap<K,V> newListMultimap(Map<K,Collection<V>> map,final Supplier<? extends List<V>> factory){
  return new CustomListMultimap<K,V>(map,factory);
}",0.9904417463187808
60245,"@Override public Iterator<Integer> iterator(){
  return newDoubler(2,32);
}","@Override public Iterator<Integer> iterator(){
  Iterator<Integer> powersOfTwo=new AbstractLinkedIterator<Integer>(1){
    protected Integer computeNext(    Integer previous){
      return (previous == 1 << 30) ? null : previous * 2;
    }
  }
;
  return powersOfTwo;
}",0.3197674418604651
60246,"/** 
 * Returns a predicate that evaluates to   {@code true} if the{@code CharSequence} being tested contains any match for the givenregular expression pattern. The test used is equivalent to {@code regex.matcher(arg).find()}
 * @since 3.0
 */
@GwtIncompatible(value=""String_Node_Str"") public static Predicate<CharSequence> contains(Pattern pattern){
  return new ContainsPatternPredicate(pattern);
}","/** 
 * Returns a predicate that evaluates to   {@code true} if the{@code CharSequence} being tested contains any match for the givenregular expression pattern. The test used is equivalent to {@code pattern.matcher(arg).find()}
 * @since 3.0
 */
@GwtIncompatible(value=""String_Node_Str"") public static Predicate<CharSequence> contains(Pattern pattern){
  return new ContainsPatternPredicate(pattern);
}",0.9850374064837906
60247,"/** 
 * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this point.
 * @throws IllegalStateException if the stopwatch is already stopped.
 */
public Stopwatch stop(){
  long tick=ticker.read();
  checkState(isRunning);
  isRunning=false;
  elapsedNanos+=tick - startTick;
  return this;
}","/** 
 * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this point.
 * @return this {@code Stopwatch} instance
 * @throws IllegalStateException if the stopwatch is already stopped.
 */
public Stopwatch stop(){
  long tick=ticker.read();
  checkState(isRunning);
  isRunning=false;
  elapsedNanos+=tick - startTick;
  return this;
}",0.938483547925608
60248,"/** 
 * Starts the stopwatch.
 * @throws IllegalStateException if the stopwatch is already running.
 */
public Stopwatch start(){
  checkState(!isRunning);
  isRunning=true;
  startTick=ticker.read();
  return this;
}","/** 
 * Starts the stopwatch.
 * @return this {@code Stopwatch} instance
 * @throws IllegalStateException if the stopwatch is already running.
 */
public Stopwatch start(){
  checkState(!isRunning);
  isRunning=true;
  startTick=ticker.read();
  return this;
}",0.909853249475891
60249,"/** 
 * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.
 */
public Stopwatch reset(){
  elapsedNanos=0;
  isRunning=false;
  return this;
}","/** 
 * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.
 * @return this {@code Stopwatch} instance
 */
public Stopwatch reset(){
  elapsedNanos=0;
  isRunning=false;
  return this;
}",0.8905852417302799
60250,"/** 
 * Returns an asynchronous   {@code RemovalListener} which processes alleviction notifications asynchronously, using  {@code executor}.
 * @param listener the backing listener
 * @param executor the executor with which removal notifications areasynchronously executed
 */
public static <K,V>RemovalListener<K,V> asynchronous(final RemovalListener<K,V> listener,final Executor executor){
  return new RemovalListener<K,V>(){
    @Override public void onRemoval(    final RemovalNotification<K,V> notification){
      executor.execute(new Runnable(){
        @Override public void run(){
          listener.onRemoval(notification);
        }
      }
);
    }
  }
;
}","/** 
 * Returns a   {@code RemovalListener} which processes all evictionnotifications using  {@code executor}.
 * @param listener the backing listener
 * @param executor the executor with which removal notifications areasynchronously executed
 */
public static <K,V>RemovalListener<K,V> asynchronous(final RemovalListener<K,V> listener,final Executor executor){
  return new RemovalListener<K,V>(){
    @Override public void onRemoval(    final RemovalNotification<K,V> notification){
      executor.execute(new Runnable(){
        @Override public void run(){
          listener.onRemoval(notification);
        }
      }
);
    }
  }
;
}",0.9434250764525994
60251,"/** 
 * Returns the empty iterator. <p>The   {@link Iterable} equivalent of this method is {@link Collections#emptySet}.
 */
@SuppressWarnings(""String_Node_Str"") public static <T>UnmodifiableIterator<T> emptyIterator(){
  return (UnmodifiableIterator<T>)EMPTY_ITERATOR;
}","/** 
 * Returns the empty iterator. <p>The   {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.
 */
@SuppressWarnings(""String_Node_Str"") public static <T>UnmodifiableIterator<T> emptyIterator(){
  return (UnmodifiableIterator<T>)EMPTY_ITERATOR;
}",0.935064935064935
60252,"/** 
 * Creates a new   {@code ListMultimap} that uses the provided map and factory.It can generate a multimap based on arbitrary  {@link Map} and {@link List}classes. <p>The   {@code factory}-generated and   {@code map} classes determine themultimap iteration order. They also specify the behavior of the {@code equals},   {@code hashCode}, and   {@code toString} methods for themultimap and its returned views. The multimap's  {@code get},   {@code removeAll}, and   {@code replaceValues} methods return {@code RandomAccess}lists if the factory does. However, the multimap's   {@code get} methodreturns instances of a different class than does  {@code factory.get()}. <p>The multimap is serializable if   {@code map},   {@code factory}, the lists generated by   {@code factory}, and the multimap contents are all serializable. <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if   {@code map} and the instances generated by{@code factory} are. Concurrent read operations will work correctly. Toallow concurrent update operations, wrap the multimap with a call to {@link #synchronizedListMultimap}. <p>Call this method only when the simpler methods  {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}won't suffice. <p>Note: the multimap assumes complete ownership over of   {@code map} andthe lists returned by  {@code factory}. Those objects should not be manually updated and they should not use soft, weak, or phantom references.
 * @param map place to store the mapping from each key to its correspondingvalues
 * @param factory supplier of new, empty lists that will each hold all valuesfor a given key
 * @throws IllegalArgumentException if {@code map} is not empty
 */
public static <K,V>ListMultimap<K,V> newListMultimap(Map<K,Collection<V>> map,final Supplier<? extends List<V>> factory){
  return new CustomListMultimap<K,V>(map,factory);
}","/** 
 * Creates a new   {@code ListMultimap} that uses the provided map and factory.It can generate a multimap based on arbitrary  {@link Map} and {@link List}classes. <p>The   {@code factory}-generated and   {@code map} classes determine themultimap iteration order. They also specify the behavior of the {@code equals},   {@code hashCode}, and   {@code toString} methods for themultimap and its returned views. The multimap's  {@code get},   {@code removeAll}, and   {@code replaceValues} methods return {@code RandomAccess}lists if the factory does. However, the multimap's   {@code get} methodreturns instances of a different class than does  {@code factory.get()}. <p>The multimap is serializable if   {@code map},   {@code factory}, the lists generated by   {@code factory}, and the multimap contents are all serializable. <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if   {@code map} and the instances generated by{@code factory} are. Concurrent read operations will work correctly. Toallow concurrent update operations, wrap the multimap with a call to {@link #synchronizedListMultimap}. <p>Call this method only when the simpler methods  {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}won't suffice. <p>Note: the multimap assumes complete ownership over of   {@code map} andthe lists returned by  {@code factory}. Those objects should not be manually updated, they should be empty when provided, and they should not use soft, weak, or phantom references.
 * @param map place to store the mapping from each key to its correspondingvalues
 * @param factory supplier of new, empty lists that will each hold all valuesfor a given key
 * @throws IllegalArgumentException if {@code map} is not empty
 */
public static <K,V>ListMultimap<K,V> newListMultimap(Map<K,Collection<V>> map,final Supplier<? extends List<V>> factory){
  return new CustomListMultimap<K,V>(map,factory);
}",0.9904417463187808
60253,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(MultisetTestSuiteBuilder.using(hashMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.GENERAL_PURPOSE).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(unmodifiableMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(SortedMultisetTestSuiteBuilder.using(new TestStringMultisetGenerator(){
    @Override protected Multiset<String> create(    String[] elements){
      return TreeMultiset.create(Arrays.asList(elements));
    }
    @Override public List<String> order(    List<String> insertionOrder){
      return Ordering.natural().sortedCopy(insertionOrder);
    }
  }
).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(SortedMultisetTestSuiteBuilder.using(new TestStringMultisetGenerator(){
    @Override protected Multiset<String> create(    String[] elements){
      Multiset<String> result=TreeMultiset.create(Ordering.natural().nullsFirst());
      result.addAll(Arrays.asList(elements));
      return result;
    }
    @Override public List<String> order(    List<String> insertionOrder){
      return Ordering.natural().nullsFirst().sortedCopy(insertionOrder);
    }
  }
).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_VALUES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(forSetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.REMOVE_OPERATIONS).suppressing(getReadsDuplicateInitializingMethods()).suppressing(getSetCountDuplicateInitializingMethods()).suppressing(getIteratorDuplicateInitializingMethods()).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(concurrentMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(enumMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(intersectionGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.KNOWN_ORDER).named(""String_Node_Str"").createTestSuite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(MultisetTestSuiteBuilder.using(hashMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.GENERAL_PURPOSE).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(unmodifiableMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(forSetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.REMOVE_OPERATIONS).suppressing(getReadsDuplicateInitializingMethods()).suppressing(getSetCountDuplicateInitializingMethods()).suppressing(getIteratorDuplicateInitializingMethods()).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(concurrentMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(enumMultisetGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.KNOWN_ORDER,CollectionFeature.GENERAL_PURPOSE,CollectionFeature.ALLOWS_NULL_QUERIES).named(""String_Node_Str"").createTestSuite());
  suite.addTest(MultisetTestSuiteBuilder.using(intersectionGenerator()).withFeatures(CollectionSize.ANY,CollectionFeature.ALLOWS_NULL_VALUES,CollectionFeature.KNOWN_ORDER).named(""String_Node_Str"").createTestSuite());
  return suite;
}",0.7266545784224842
60254,"static <E,E2 extends E>ImmutableMultiset<E> copyFromEntries(Collection<Entry<E2>> entries){
  long size=0;
  ImmutableMap.Builder<E,Integer> builder=ImmutableMap.builder();
  for (  Entry<E2> entry : entries) {
    int count=entry.getCount();
    if (count > 0) {
      builder.put(entry.getElement(),count);
      size+=count;
    }
  }
  if (size == 0) {
    return of();
  }
  return new RegularImmutableMultiset<E>(builder.build(),Ints.saturatedCast(size));
}","static <E>ImmutableMultiset<E> copyFromEntries(Collection<? extends Entry<? extends E>> entries){
  long size=0;
  ImmutableMap.Builder<E,Integer> builder=ImmutableMap.builder();
  for (  Entry<? extends E> entry : entries) {
    int count=entry.getCount();
    if (count > 0) {
      builder.put(entry.getElement(),count);
      size+=count;
    }
  }
  if (size == 0) {
    return of();
  }
  return new RegularImmutableMultiset<E>(builder.build(),Ints.saturatedCast(size));
}",0.0998937300743889
60255,"@Override public Set<Entry<E>> entrySet(){
  Set<Entry<E>> es=entrySet;
  if (es == null) {
    es=new EntrySet<E>(){
      @Override Multiset<E> multiset(){
        return SetMultiset.this;
      }
      @Override public Iterator<Entry<E>> iterator(){
        return Iterators.transform(delegate.iterator(),new Function<E,Entry<E>>(){
          @Override public Entry<E> apply(          E elem){
            return immutableEntry(elem,1);
          }
        }
);
      }
      @Override public int size(){
        return delegate.size();
      }
    }
;
  }
  return es;
}","@Override public Set<Entry<E>> entrySet(){
  Set<Entry<E>> es=entrySet;
  if (es == null) {
    es=entrySet=new EntrySet<E>(){
      @Override Multiset<E> multiset(){
        return SetMultiset.this;
      }
      @Override public Iterator<Entry<E>> iterator(){
        return Iterators.transform(delegate.iterator(),new Function<E,Entry<E>>(){
          @Override public Entry<E> apply(          E elem){
            return immutableEntry(elem,1);
          }
        }
);
      }
      @Override public int size(){
        return delegate.size();
      }
    }
;
  }
  return es;
}",0.9922212618841832
60256,"public void testConstructorLenient_classObject(){
  String toTest=Objects.toStringHelper(TestClass.class).toString();
  assertTrue(toTest.matches(""String_Node_Str""));
}","public void testConstructorLenient_classObject(){
  String toTest=Objects.toStringHelper(TestClass.class).toString();
  assertTrue(toTest,toTest.matches(""String_Node_Str""));
}",0.979591836734694
60257,"public void testConstructor_anonymousClass(){
  String toTest=Objects.toStringHelper(new Object(){
  }
).toString();
  assertTrue(toTest,toTest.matches(""String_Node_Str""));
}","public void testConstructor_anonymousClass(){
  String toTest=Objects.toStringHelper(new Object(){
  }
).toString();
  assertEquals(""String_Node_Str"",toTest);
}",0.8982035928143712
60258,"/** 
 * {@link Class#getSimpleName()} is not GWT compatible yet, so weprovide our own implementation.
 */
private static String simpleName(Class<?> clazz){
  String name=clazz.getName();
  int start=name.lastIndexOf('$');
  if (start == -1) {
    start=name.lastIndexOf('.');
  }
  return name.substring(start + 1);
}","/** 
 * {@link Class#getSimpleName()} is not GWT compatible yet, so weprovide our own implementation.
 */
private static String simpleName(Class<?> clazz){
  String name=clazz.getName();
  name=name.replaceAll(""String_Node_Str"",""String_Node_Str"");
  int start=name.lastIndexOf('$');
  if (start == -1) {
    start=name.lastIndexOf('.');
  }
  return name.substring(start + 1);
}",0.912230215827338
60259,"@Override public E intern(E sample){
  while (true) {
    ReferenceEntry<E,Dummy> entry=map.getLiveEntry(sample);
    if (entry != null) {
      return entry.getKey();
    }
    Dummy sneaky=map.putIfAbsent(sample,Dummy.VALUE);
    if (sneaky == null) {
      return sample;
    }
 else {
    }
  }
}","@Override public E intern(E sample){
  while (true) {
    ReferenceEntry<E,Dummy> entry=map.getEntry(sample);
    if (entry != null) {
      E canonical=entry.getKey();
      if (canonical != null) {
        return canonical;
      }
    }
    Dummy sneaky=map.putIfAbsent(sample,Dummy.VALUE);
    if (sneaky == null) {
      return sample;
    }
 else {
    }
  }
}",0.8678678678678678
60260,"/** 
 * Returns the ratio of cache creates which threw exceptions. This is defined as  {@code createExceptionCount / (createSuccessCount + createExceptionCount)}, or  {@code 0.0} when {@code createSuccessCount + createExceptionCount == 0}.
 */
public double createExceptionRate(){
  long totalCreateCount=createSuccessCount + createExceptionCount;
  return (totalCreateCount == 0) ? 0.0 : createExceptionCount / totalCreateCount;
}","/** 
 * Returns the ratio of cache creates which threw exceptions. This is defined as  {@code createExceptionCount / (createSuccessCount + createExceptionCount)}, or  {@code 0.0} when {@code createSuccessCount + createExceptionCount == 0}.
 */
public double createExceptionRate(){
  long totalCreateCount=createSuccessCount + createExceptionCount;
  return (totalCreateCount == 0) ? 0.0 : (double)createExceptionCount / totalCreateCount;
}",0.9908045977011494
60261,"public final V get(@Nullable Object key){
  return Maps.safeGet(delegate,key);
}","public final V get(@Nullable Object key){
  return (key == null) ? null : Maps.safeGet(delegate,key);
}",0.8743169398907104
60262,"private static byte[] textToNumericFormatV6(String ipString){
  if (!ipString.contains(""String_Node_Str"")) {
    return null;
  }
  if (ipString.contains(""String_Node_Str"")) {
    return null;
  }
  if (ipString.contains(""String_Node_Str"")) {
    ipString=convertDottedQuadToHex(ipString);
    if (ipString == null) {
      return null;
    }
  }
  ByteBuffer rawBytes=ByteBuffer.allocate(2 * IPV6_PART_COUNT);
  int partsHi=0;
  int partsLo=0;
  String[] addressHalves=ipString.split(""String_Node_Str"",2);
  if (!addressHalves[0].equals(""String_Node_Str"")) {
    String[] parts=addressHalves[0].split(""String_Node_Str"",IPV6_PART_COUNT);
    try {
      for (int i=0; i < parts.length; i++) {
        if (parts[i].equals(""String_Node_Str"")) {
          return null;
        }
        int piece=Integer.parseInt(parts[i],16);
        rawBytes.putShort(2 * i,(short)piece);
      }
      partsHi=parts.length;
    }
 catch (    NumberFormatException ex) {
      return null;
    }
  }
 else {
    partsHi=1;
  }
  if (addressHalves.length > 1) {
    if (!addressHalves[1].equals(""String_Node_Str"")) {
      String[] parts=addressHalves[1].split(""String_Node_Str"",IPV6_PART_COUNT);
      try {
        for (int i=0; i < parts.length; i++) {
          int partsIndex=parts.length - i - 1;
          if (parts[partsIndex].equals(""String_Node_Str"")) {
            return null;
          }
          int piece=Integer.parseInt(parts[partsIndex],16);
          int bytesIndex=2 * (IPV6_PART_COUNT - i - 1);
          rawBytes.putShort(bytesIndex,(short)piece);
        }
        partsLo=parts.length;
      }
 catch (      NumberFormatException ex) {
        return null;
      }
    }
 else {
      partsLo=1;
    }
  }
  int totalParts=partsHi + partsLo;
  if (totalParts > IPV6_PART_COUNT) {
    return null;
  }
  if (addressHalves.length == 1 && totalParts != IPV6_PART_COUNT) {
    return null;
  }
  return rawBytes.array();
}","private static byte[] textToNumericFormatV6(String ipString){
  if (!ipString.contains(""String_Node_Str"")) {
    return null;
  }
  if (ipString.contains(""String_Node_Str"")) {
    return null;
  }
  if (ipString.contains(""String_Node_Str"")) {
    ipString=convertDottedQuadToHex(ipString);
    if (ipString == null) {
      return null;
    }
  }
  ByteBuffer rawBytes=ByteBuffer.allocate(2 * IPV6_PART_COUNT);
  int partsHi=0;
  int partsLo=0;
  String[] addressHalves=ipString.split(""String_Node_Str"",2);
  if (!addressHalves[0].equals(""String_Node_Str"")) {
    String[] parts=addressHalves[0].split(""String_Node_Str"",IPV6_PART_COUNT);
    try {
      for (int i=0; i < parts.length; i++) {
        rawBytes.putShort(2 * i,parseHextet(parts[i]));
      }
      partsHi=parts.length;
    }
 catch (    NumberFormatException ex) {
      return null;
    }
  }
 else {
    partsHi=1;
  }
  if (addressHalves.length > 1) {
    if (!addressHalves[1].equals(""String_Node_Str"")) {
      String[] parts=addressHalves[1].split(""String_Node_Str"",IPV6_PART_COUNT);
      try {
        for (int i=0; i < parts.length; i++) {
          int partsIndex=parts.length - i - 1;
          int bytesIndex=2 * (IPV6_PART_COUNT - i - 1);
          rawBytes.putShort(bytesIndex,parseHextet(parts[partsIndex]));
        }
        partsLo=parts.length;
      }
 catch (      NumberFormatException ex) {
        return null;
      }
    }
 else {
      partsLo=1;
    }
  }
  int totalParts=partsHi + partsLo;
  if (totalParts > IPV6_PART_COUNT) {
    return null;
  }
  if (addressHalves.length == 1 && totalParts != IPV6_PART_COUNT) {
    return null;
  }
  return rawBytes.array();
}",0.8982436576526345
60263,"private static byte[] textToNumericFormatV4(String ipString){
  if (ipString.contains(""String_Node_Str"")) {
    return null;
  }
  String[] address=ipString.split(""String_Node_Str"");
  if (address.length != IPV4_PART_COUNT) {
    return null;
  }
  byte[] bytes=new byte[IPV4_PART_COUNT];
  try {
    for (int i=0; i < bytes.length; i++) {
      int piece=Integer.parseInt(address[i]);
      if (piece < 0 || piece > 255) {
        return null;
      }
      if (address[i].startsWith(""String_Node_Str"") && address[i].length() != 1) {
        return null;
      }
      bytes[i]=(byte)piece;
    }
  }
 catch (  NumberFormatException ex) {
    return null;
  }
  return bytes;
}","private static byte[] textToNumericFormatV4(String ipString){
  if (ipString.contains(""String_Node_Str"")) {
    return null;
  }
  String[] address=ipString.split(""String_Node_Str"",IPV4_PART_COUNT + 1);
  if (address.length != IPV4_PART_COUNT) {
    return null;
  }
  byte[] bytes=new byte[IPV4_PART_COUNT];
  try {
    for (int i=0; i < bytes.length; i++) {
      bytes[i]=parseOctet(address[i]);
    }
  }
 catch (  NumberFormatException ex) {
    return null;
  }
  return bytes;
}",0.6190885640584695
60264,"/** 
 * Moves an element one level up from a min level to a max level (or vice versa). Returns the new position of the element.
 */
int crossOverUp(int index,E x){
  if (index == 0) {
    queue[0]=x;
    return 0;
  }
  int parentIndex=getParentIndex(index);
  E parentElement=elementData(parentIndex);
  if (parentIndex != 0) {
    int grandparentIndex=getParentIndex(parentIndex);
    int uncleIndex=getRightChildIndex(grandparentIndex);
    if (uncleIndex != parentIndex) {
      E uncleElement=elementData(uncleIndex);
      if (ordering.compare(uncleElement,parentElement) < 0) {
        parentIndex=uncleIndex;
        parentElement=uncleElement;
      }
    }
  }
  if (ordering.compare(parentElement,x) < 0) {
    queue[index]=parentElement;
    queue[parentIndex]=x;
    return parentIndex;
  }
  queue[index]=x;
  return index;
}","/** 
 * Moves an element one level up from a min level to a max level (or vice versa). Returns the new position of the element.
 */
int crossOverUp(int index,E x){
  if (index == 0) {
    queue[0]=x;
    return 0;
  }
  int parentIndex=getParentIndex(index);
  E parentElement=elementData(parentIndex);
  if (parentIndex != 0) {
    int grandparentIndex=getParentIndex(parentIndex);
    int uncleIndex=getRightChildIndex(grandparentIndex);
    if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size) {
      E uncleElement=elementData(uncleIndex);
      if (ordering.compare(uncleElement,parentElement) < 0) {
        parentIndex=uncleIndex;
        parentElement=uncleElement;
      }
    }
  }
  if (ordering.compare(parentElement,x) < 0) {
    queue[index]=parentElement;
    queue[parentIndex]=x;
    return parentIndex;
  }
  queue[index]=x;
  return index;
}",0.9761489237929027
60265,"/** 
 * Removes the element at position   {@code index}. <p>Normally this method leaves the elements at up to   {@code index - 1}, inclusive, untouched.  Under these circumstances, it returns   {@code null}. <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the list with one before   {@code index}. Under these circumstances it returns a pair of elements as a   {@link MoveDesc}. The first one is the element that was previously at the end of the heap and is now at some position before   {@code index}. The second element is the one that was swapped down to replace the element at   {@code index}. This fact is used by iterator.remove so as to visit elements during a traversal once and only once.
 */
@VisibleForTesting MoveDesc<E> removeAt(int index){
  checkPositionIndex(index,size);
  modCount++;
  size--;
  if (size == index) {
    queue[size]=null;
    return null;
  }
  E toTrickle=elementData(size);
  queue[size]=null;
  Heap heap=heapForIndex(index);
  int vacated=heap.fillHoleAt(index);
  int bubbledTo=heap.bubbleUpAlternatingLevels(vacated,toTrickle);
  if (bubbledTo == vacated) {
    return heap.tryCrossOverAndBubbleUp(index,vacated,toTrickle);
  }
 else {
    return (bubbledTo < index) ? new MoveDesc<E>(toTrickle,elementData(index)) : null;
  }
}","/** 
 * Removes the element at position   {@code index}. <p>Normally this method leaves the elements at up to   {@code index - 1}, inclusive, untouched.  Under these circumstances, it returns   {@code null}. <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the list with one before   {@code index}. Under these circumstances it returns a pair of elements as a   {@link MoveDesc}. The first one is the element that was previously at the end of the heap and is now at some position before   {@code index}. The second element is the one that was swapped down to replace the element at   {@code index}. This fact is used by iterator.remove so as to visit elements during a traversal once and only once.
 */
@VisibleForTesting MoveDesc<E> removeAt(int index){
  checkPositionIndex(index,size);
  modCount++;
  size--;
  if (size == index) {
    queue[size]=null;
    return null;
  }
  E actualLastElement=elementData(size);
  int lastElementAt=heapForIndex(size).getCorrectLastElement(actualLastElement);
  E toTrickle=elementData(size);
  queue[size]=null;
  MoveDesc<E> changes=fillHole(index,toTrickle);
  if (lastElementAt < index) {
    if (changes == null) {
      return new MoveDesc<E>(actualLastElement,toTrickle);
    }
 else {
      return new MoveDesc<E>(actualLastElement,changes.replaced);
    }
  }
  return changes;
}",0.7676240208877284
60266,"@Override public void clear(){
  linkedEntries.removeAll(createEntries(delegate()));
  delegate.clear();
}","@Override public void clear(){
  for (  V value : delegate) {
    linkedEntries.remove(createEntry(value));
  }
  delegate.clear();
}",0.7531380753138075
60267,"@Override public void clear(){
  linkedEntries.removeAll(createEntries(delegate()));
  delegate.clear();
}","@Override public void clear(){
  for (  V value : delegate) {
    linkedEntries.remove(createEntry(value));
  }
  delegate.clear();
}",0.7531380753138075
60268,"@Override public K getKey(){
  return key;
}","@Override public K getKey(){
  return entry.getKey();
}",0.8686868686868687
60269,"@Override public Collection<Entry<K,V2>> entries(){
  if (entries == null) {
    Collection<Entry<K,V2>> es=new TransformedEntries();
    entries=es;
    return es;
  }
  return entries;
}","@Override public Collection<Entry<K,V2>> entries(){
  if (entries == null) {
    Collection<Entry<K,V2>> es=new TransformedEntries(transformer);
    entries=es;
    return es;
  }
  return entries;
}",0.9715762273901808
60270,"@Override public Collection<V> getValue(){
  return get(key);
}","@Override public V2 getValue(){
  return transformer.transformEntry(entry.getKey(),entry.getValue());
}",0.5903614457831325
60271,"TransformedEntries(){
  super(fromMultimap.entries(),new Function<Entry<K,V1>,Entry<K,V2>>(){
    @Override public Entry<K,V2> apply(    Entry<K,V1> entry){
      K key=entry.getKey();
      return Maps.immutableEntry(key,transformer.transformEntry(key,entry.getValue()));
    }
  }
);
}","TransformedEntries(final EntryTransformer<? super K,? super V1,V2> transformer){
  super(fromMultimap.entries(),new Function<Entry<K,V1>,Entry<K,V2>>(){
    @Override public Entry<K,V2> apply(    final Entry<K,V1> entry){
      return new AbstractMapEntry<K,V2>(){
        @Override public K getKey(){
          return entry.getKey();
        }
        @Override public V2 getValue(){
          return transformer.transformEntry(entry.getKey(),entry.getValue());
        }
      }
;
    }
  }
);
}",0.5229591836734694
60272,"/** 
 * Provides singleton scope with the following properties: - creates no more than one instance per Key as a creator is used no more than once, - result is cached and returned quickly on subsequent calls, - exception in a creator is not treated as instance creation and is not cached, - creates singletons in parallel whenever possible, - waits for dependent singletons to be created even across threads and when dependencies are shared as long as no circular dependencies are detected, - returns circular proxy only when circular dependencies are detected, - aside from that, blocking synchronization is only used for proxy creation and initialization,
 * @see CycleDetectingLockFactory
 */
@Override public <T>Provider<T> scope(final Key<T> key,final Provider<T> creator){
  return new Provider<T>(){
    /** 
 * The lazily initialized singleton instance. Once set, this will either have type T or will be equal to NULL. Would never be reset to null.
 */
    volatile Object instance;
    /** 
 * Circular proxies are used when potential deadlocks are detected. Guarded by itself. ConstructionContext is not thread-safe, so each call should be synchronized.
 */
    final ConstructionContext<T> constructionContext=new ConstructionContext<>();
    /** 
 * For each binding there is a separate lock that we hold during object creation. 
 */
    final CycleDetectingLock<Key<?>> creationLock=cycleDetectingLockFactory.create(key);
    /** 
 * The singleton provider needs a reference back to the injector, in order to get ahold of InternalContext during instantiation.
 */
    final InjectorImpl injector;
{
      if (creator instanceof ProviderToInternalFactoryAdapter) {
        injector=((ProviderToInternalFactoryAdapter)creator).getInjector();
      }
 else {
        injector=null;
      }
    }
    @SuppressWarnings(""String_Node_Str"") @Override public T get(){
      final Object initialInstance=instance;
      if (initialInstance == null) {
        final InternalContext context=injector == null ? null : injector.getLocalContext();
        final ListMultimap<Thread,Key<?>> locksCycle=creationLock.lockOrDetectPotentialLocksCycle();
        if (locksCycle.isEmpty()) {
          try {
            if (instance == null) {
              T provided=creator.get();
              Object providedNotNull=provided == null ? NULL : provided;
              if (instance == null) {
                if (Scopes.isCircularProxy(provided)) {
                  return provided;
                }
synchronized (constructionContext) {
                  instance=providedNotNull;
                  constructionContext.setProxyDelegates(provided);
                }
              }
 else {
                Preconditions.checkState(instance == providedNotNull,""String_Node_Str"");
              }
            }
          }
 catch (          RuntimeException e) {
synchronized (constructionContext) {
              constructionContext.finishConstruction();
            }
            throw e;
          }
 finally {
            creationLock.unlock();
          }
        }
 else {
          if (context == null) {
            throw new ProvisionException(ImmutableList.of(createCycleDependenciesMessage(locksCycle,null)));
          }
synchronized (constructionContext) {
            if (instance == null) {
              Dependency<?> dependency=Preconditions.checkNotNull(context.getDependency(),""String_Node_Str"");
              Class<?> rawType=dependency.getKey().getTypeLiteral().getRawType();
              try {
                @SuppressWarnings(""String_Node_Str"") T proxy=(T)constructionContext.createProxy(context.getInjectorOptions(),rawType);
                return proxy;
              }
 catch (              InternalProvisionException e) {
                Message proxyCreationError=Iterables.getOnlyElement(e.getErrors());
                Message cycleDependenciesMessage=createCycleDependenciesMessage(locksCycle,proxyCreationError);
                throw new ProvisionException(ImmutableList.of(cycleDependenciesMessage,proxyCreationError));
              }
            }
          }
        }
        final Object initializedInstance=instance;
        Preconditions.checkState(initializedInstance != null,""String_Node_Str"");
        @SuppressWarnings(""String_Node_Str"") T initializedTypedInstance=(T)initializedInstance;
        return initializedInstance == NULL ? null : initializedTypedInstance;
      }
 else {
        @SuppressWarnings(""String_Node_Str"") T typedInitialIntance=(T)initialInstance;
        return initialInstance == NULL ? null : typedInitialIntance;
      }
    }
    /** 
 * Helper method to create beautiful and rich error descriptions. Best effort and slow. Tries its best to provide dependency information from injectors currently available in a global internal context. <p>The main thing being done is creating a list of Dependencies involved into lock cycle across all the threads involved. This is a structure we're creating: <pre> { Current Thread, C.class, B.class, Other Thread, B.class, C.class, Current Thread } To be inserted in the beginning by Guice: { A.class, B.class, C.class } </pre> When we're calling Guice to create A and it fails in the deadlock while trying to create C, which is being created by another thread, which waits for B. List would be reversed before printing it to the end user.
 */
    private Message createCycleDependenciesMessage(    ListMultimap<Thread,Key<?>> locksCycle,    Message proxyCreationError){
      StringBuilder sb=new StringBuilder();
      Formatter fmt=new Formatter(sb);
      fmt.format(""String_Node_Str"");
      if (proxyCreationError != null) {
        fmt.format(""String_Node_Str"",proxyCreationError.getMessage());
      }
      fmt.format(""String_Node_Str"");
      for (      Thread lockedThread : locksCycle.keySet()) {
        List<Key<?>> lockedKeys=locksCycle.get(lockedThread);
        fmt.format(""String_Node_Str"",lockedThread);
        for (        Key<?> lockedKey : lockedKeys) {
          fmt.format(""String_Node_Str"",Errors.convert(lockedKey));
        }
        for (        StackTraceElement traceElement : lockedThread.getStackTrace()) {
          fmt.format(""String_Node_Str"",traceElement);
        }
      }
      fmt.close();
      return new Message(Thread.currentThread(),sb.toString());
    }
    @Override public String toString(){
      return String.format(""String_Node_Str"",creator,Scopes.SINGLETON);
    }
  }
;
}","/** 
 * Provides singleton scope with the following properties: <ul> <li>creates no more than one instance per Key as a creator is used no more than once <li>result is cached and returned quickly on subsequent calls <li>exception in a creator is not treated as instance creation and is not cached <li>creates singletons in parallel whenever possible <li>waits for dependent singletons to be created even across threads and when dependencies are shared as long as no circular dependencies are detected <li>returns circular proxy only when circular dependencies are detected <li>aside from that, blocking synchronization is only used for proxy creation and initialization </ul>
 * @see CycleDetectingLockFactory
 */
@Override public <T>Provider<T> scope(final Key<T> key,final Provider<T> creator){
  return new Provider<T>(){
    /** 
 * The lazily initialized singleton instance. Once set, this will either have type T or will be equal to NULL. Would never be reset to null. <p>Locking strategy: double-checked locking for quick exit when scope is initialized.
 */
    volatile Object instance;
    /** 
 * Circular proxies are used when potential deadlocks are detected. Guarded by itself. ConstructionContext is not thread-safe, so each call should be synchronized. <p>Locking strategy: manipulations with proxies list or instance initialization.
 */
    final ConstructionContext<T> constructionContext=new ConstructionContext<>();
    /** 
 * For each binding there is a separate lock that we hold during object creation. <p>Locking strategy: singleton instance creation. <ul> <li>allows to guarantee only one instance per singleton, <li>special type of a lock, that prevents potential deadlocks, <li>guards constructionContext for all operations except proxy creation </ul>
 */
    final CycleDetectingLock<Key<?>> creationLock=cycleDetectingLockFactory.create(key);
    /** 
 * The singleton provider needs a reference back to the injector, in order to get ahold of InternalContext during instantiation.
 */
    final InjectorImpl injector;
{
      if (creator instanceof ProviderToInternalFactoryAdapter) {
        injector=((ProviderToInternalFactoryAdapter)creator).getInjector();
      }
 else {
        injector=null;
      }
    }
    @SuppressWarnings(""String_Node_Str"") @Override public T get(){
      final Object initialInstance=instance;
      if (initialInstance == null) {
        final InternalContext context=injector == null ? null : injector.getLocalContext();
        final ListMultimap<Thread,Key<?>> locksCycle=creationLock.lockOrDetectPotentialLocksCycle();
        if (locksCycle.isEmpty()) {
          try {
            if (instance == null) {
              T provided=creator.get();
              Object providedNotNull=provided == null ? NULL : provided;
              if (instance == null) {
                if (Scopes.isCircularProxy(provided)) {
                  return provided;
                }
synchronized (constructionContext) {
                  instance=providedNotNull;
                  constructionContext.setProxyDelegates(provided);
                }
              }
 else {
                Preconditions.checkState(instance == providedNotNull,""String_Node_Str"");
              }
            }
          }
 catch (          RuntimeException e) {
synchronized (constructionContext) {
              constructionContext.finishConstruction();
            }
            throw e;
          }
 finally {
            creationLock.unlock();
          }
        }
 else {
          if (context == null) {
            throw new ProvisionException(ImmutableList.of(createCycleDependenciesMessage(locksCycle,null)));
          }
synchronized (constructionContext) {
            if (instance == null) {
              Dependency<?> dependency=Preconditions.checkNotNull(context.getDependency(),""String_Node_Str"");
              Class<?> rawType=dependency.getKey().getTypeLiteral().getRawType();
              try {
                @SuppressWarnings(""String_Node_Str"") T proxy=(T)constructionContext.createProxy(context.getInjectorOptions(),rawType);
                return proxy;
              }
 catch (              InternalProvisionException e) {
                Message proxyCreationError=Iterables.getOnlyElement(e.getErrors());
                Message cycleDependenciesMessage=createCycleDependenciesMessage(locksCycle,proxyCreationError);
                throw new ProvisionException(ImmutableList.of(cycleDependenciesMessage,proxyCreationError));
              }
            }
          }
        }
        final Object initializedInstance=instance;
        Preconditions.checkState(initializedInstance != null,""String_Node_Str"");
        @SuppressWarnings(""String_Node_Str"") T initializedTypedInstance=(T)initializedInstance;
        return initializedInstance == NULL ? null : initializedTypedInstance;
      }
 else {
        @SuppressWarnings(""String_Node_Str"") T typedInitialIntance=(T)initialInstance;
        return initialInstance == NULL ? null : typedInitialIntance;
      }
    }
    /** 
 * Helper method to create beautiful and rich error descriptions. Best effort and slow. Tries its best to provide dependency information from injectors currently available in a global internal context. <p>The main thing being done is creating a list of Dependencies involved into lock cycle across all the threads involved. This is a structure we're creating: <pre> { Current Thread, C.class, B.class, Other Thread, B.class, C.class, Current Thread } To be inserted in the beginning by Guice: { A.class, B.class, C.class } </pre> When we're calling Guice to create A and it fails in the deadlock while trying to create C, which is being created by another thread, which waits for B. List would be reversed before printing it to the end user.
 */
    private Message createCycleDependenciesMessage(    ListMultimap<Thread,Key<?>> locksCycle,    Message proxyCreationError){
      StringBuilder sb=new StringBuilder();
      Formatter fmt=new Formatter(sb);
      fmt.format(""String_Node_Str"");
      if (proxyCreationError != null) {
        fmt.format(""String_Node_Str"",proxyCreationError.getMessage());
      }
      fmt.format(""String_Node_Str"");
      for (      Thread lockedThread : locksCycle.keySet()) {
        List<Key<?>> lockedKeys=locksCycle.get(lockedThread);
        fmt.format(""String_Node_Str"",lockedThread);
        for (        Key<?> lockedKey : lockedKeys) {
          fmt.format(""String_Node_Str"",Errors.convert(lockedKey));
        }
        for (        StackTraceElement traceElement : lockedThread.getStackTrace()) {
          fmt.format(""String_Node_Str"",traceElement);
        }
      }
      fmt.close();
      return new Message(Thread.currentThread(),sb.toString());
    }
    @Override public String toString(){
      return String.format(""String_Node_Str"",creator,Scopes.SINGLETON);
    }
  }
;
}",0.8919792528001202
60273,"public Class<? extends Annotation> getAnnotationType(){
  return annotationType;
}","@Override public Class<? extends Annotation> getAnnotationType(){
  return annotationType;
}",0.942528735632184
60274,"public AnnotationStrategy withoutAttributes(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public AnnotationStrategy withoutAttributes(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9565217391304348
60275,"public Annotation getAnnotation(){
  return annotation;
}","@Override public Annotation getAnnotation(){
  return annotation;
}",0.9193548387096774
60276,"public boolean hasAttributes(){
  return false;
}","@Override public boolean hasAttributes(){
  return false;
}",0.9074074074074074
60277,PrivateBinder skipSources(Class... classesToSkip);,@Override PrivateBinder skipSources(Class... classesToSkip);,0.9090909090909092
60278,PrivateBinder withSource(Object source);,@Override PrivateBinder withSource(Object source);,0.8888888888888888
60279,"/** 
 * Provides an instance of   {@code T}. Must never return   {@code null}.
 * @throws OutOfScopeException when an attempt is made to access a scoped object while the scopein question is not currently active
 * @throws ProvisionException if an instance cannot be provided. Such exceptions include messagesand throwables to describe why provision failed.
 */
T get();","/** 
 * Provides an instance of   {@code T}. Must never return   {@code null}.
 * @throws OutOfScopeException when an attempt is made to access a scoped object while the scopein question is not currently active
 * @throws ProvisionException if an instance cannot be provided. Such exceptions include messagesand throwables to describe why provision failed.
 */
@Override T get();",0.9866310160427808
60280,"/** 
 * A short but useful description of this scope.  For comparison, the standard scopes that ship with guice use the descriptions  {@code ""Scopes.SINGLETON""},   {@code ""ServletScopes.SESSION""} and{@code ""ServletScopes.REQUEST""}.
 */
String toString();","/** 
 * A short but useful description of this scope. For comparison, the standard scopes that ship with guice use the descriptions   {@code ""Scopes.SINGLETON""},   {@code ""ServletScopes.SESSION""} and{@code ""ServletScopes.REQUEST""}.
 */
@Override String toString();",0.9768339768339768
60281,"public <T>Provider<T> scope(Key<T> key,Provider<T> unscoped){
  return unscoped;
}","@Override public <T>Provider<T> scope(Key<T> key,Provider<T> unscoped){
  return unscoped;
}",0.942528735632184
60282,"public Boolean visitNoScoping(){
  return false;
}","@Override public Boolean visitNoScoping(){
  return false;
}",0.9090909090909092
60283,"public Boolean visitScope(Scope visitedScope){
  return visitedScope == scope;
}","@Override public Boolean visitScope(Scope visitedScope){
  return visitedScope == scope;
}",0.9411764705882352
60284,"/** 
 * Returns true if   {@code binding} has the given scope. If the binding is a {@link com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. itwas retrieved via  {@link Injector#getBinding Injector.getBinding()}), then this method will also true if the target binding has the given scope.
 * @param binding binding to check
 * @param scope scope implementation instance
 * @param scopeAnnotation scope annotation class
 * @since 4.0
 */
public static boolean isScoped(Binding<?> binding,final Scope scope,final Class<? extends Annotation> scopeAnnotation){
  do {
    boolean matches=binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>(){
      public Boolean visitNoScoping(){
        return false;
      }
      public Boolean visitScopeAnnotation(      Class<? extends Annotation> visitedAnnotation){
        return visitedAnnotation == scopeAnnotation;
      }
      public Boolean visitScope(      Scope visitedScope){
        return visitedScope == scope;
      }
      public Boolean visitEagerSingleton(){
        return false;
      }
    }
);
    if (matches) {
      return true;
    }
    if (binding instanceof LinkedBindingImpl) {
      LinkedBindingImpl<?> linkedBinding=(LinkedBindingImpl)binding;
      Injector injector=linkedBinding.getInjector();
      if (injector != null) {
        binding=injector.getBinding(linkedBinding.getLinkedKey());
        continue;
      }
    }
 else     if (binding instanceof ExposedBinding) {
      ExposedBinding<?> exposedBinding=(ExposedBinding)binding;
      Injector injector=exposedBinding.getPrivateElements().getInjector();
      if (injector != null) {
        binding=injector.getBinding(exposedBinding.getKey());
        continue;
      }
    }
    return false;
  }
 while (true);
}","/** 
 * Returns true if   {@code binding} has the given scope. If the binding is a {@link com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. itwas retrieved via  {@link Injector#getBinding Injector.getBinding()}), then this method will also true if the target binding has the given scope.
 * @param binding binding to check
 * @param scope scope implementation instance
 * @param scopeAnnotation scope annotation class
 * @since 4.0
 */
public static boolean isScoped(Binding<?> binding,final Scope scope,final Class<? extends Annotation> scopeAnnotation){
  do {
    boolean matches=binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>(){
      @Override public Boolean visitNoScoping(){
        return false;
      }
      @Override public Boolean visitScopeAnnotation(      Class<? extends Annotation> visitedAnnotation){
        return visitedAnnotation == scopeAnnotation;
      }
      @Override public Boolean visitScope(      Scope visitedScope){
        return visitedScope == scope;
      }
      @Override public Boolean visitEagerSingleton(){
        return false;
      }
    }
);
    if (matches) {
      return true;
    }
    if (binding instanceof LinkedBindingImpl) {
      LinkedBindingImpl<?> linkedBinding=(LinkedBindingImpl)binding;
      Injector injector=linkedBinding.getInjector();
      if (injector != null) {
        binding=injector.getBinding(linkedBinding.getLinkedKey());
        continue;
      }
    }
 else     if (binding instanceof ExposedBinding) {
      ExposedBinding<?> exposedBinding=(ExposedBinding)binding;
      Injector injector=exposedBinding.getPrivateElements().getInjector();
      if (injector != null) {
        binding=injector.getBinding(exposedBinding.getKey());
        continue;
      }
    }
    return false;
  }
 while (true);
}",0.9807692307692308
60285,"public Boolean visitScopeAnnotation(Class<? extends Annotation> visitedAnnotation){
  return visitedAnnotation == scopeAnnotation;
}","@Override public Boolean visitScopeAnnotation(Class<? extends Annotation> visitedAnnotation){
  return visitedAnnotation == scopeAnnotation;
}",0.9635036496350364
60286,"public Boolean visitEagerSingleton(){
  return false;
}","@Override public Boolean visitEagerSingleton(){
  return false;
}",0.9166666666666666
60287,"public Boolean load(Class<? extends Annotation> annotationType){
  for (  Annotation annotation : annotationType.getAnnotations()) {
    if (annotationTypes.contains(annotation.annotationType())) {
      return true;
    }
  }
  return false;
}","@Override public Boolean load(Class<? extends Annotation> annotationType){
  for (  Annotation annotation : annotationType.getAnnotations()) {
    if (annotationTypes.contains(annotation.annotationType())) {
      return true;
    }
  }
  return false;
}",0.9799196787148594
60288,"public void toInstance(T instance){
  checkNotTargetted();
  Set<InjectionPoint> injectionPoints;
  if (instance != null) {
    try {
      injectionPoints=InjectionPoint.forInstanceMethodsAndFields(instance.getClass());
    }
 catch (    ConfigurationException e) {
      copyErrorsToBinder(e);
      injectionPoints=e.getPartialValue();
    }
  }
 else {
    binder.addError(BINDING_TO_NULL);
    injectionPoints=ImmutableSet.of();
  }
  BindingImpl<T> base=getBinding();
  setBinding(new InstanceBindingImpl<T>(base.getSource(),base.getKey(),Scoping.EAGER_SINGLETON,injectionPoints,instance));
}","@Override public void toInstance(T instance){
  checkNotTargetted();
  Set<InjectionPoint> injectionPoints;
  if (instance != null) {
    try {
      injectionPoints=InjectionPoint.forInstanceMethodsAndFields(instance.getClass());
    }
 catch (    ConfigurationException e) {
      copyErrorsToBinder(e);
      injectionPoints=e.getPartialValue();
    }
  }
 else {
    binder.addError(BINDING_TO_NULL);
    injectionPoints=ImmutableSet.of();
  }
  BindingImpl<T> base=getBinding();
  setBinding(new InstanceBindingImpl<T>(base.getSource(),base.getKey(),Scoping.EAGER_SINGLETON,injectionPoints,instance));
}",0.9917081260364844
60289,"public BindingBuilder<T> to(Key<? extends T> linkedKey){
  checkNotNull(linkedKey,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  setBinding(new LinkedBindingImpl<T>(base.getSource(),base.getKey(),base.getScoping(),linkedKey));
  return this;
}","@Override public BindingBuilder<T> to(Key<? extends T> linkedKey){
  checkNotNull(linkedKey,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  setBinding(new LinkedBindingImpl<T>(base.getSource(),base.getKey(),base.getScoping(),linkedKey));
  return this;
}",0.9822695035460992
60290,"public BindingBuilder<T> annotatedWith(Annotation annotation){
  annotatedWithInternal(annotation);
  return this;
}","@Override public BindingBuilder<T> annotatedWith(Annotation annotation){
  annotatedWithInternal(annotation);
  return this;
}",0.9586776859504132
60291,"public BindingBuilder<T> toProvider(Key<? extends javax.inject.Provider<? extends T>> providerKey){
  checkNotNull(providerKey,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  setBinding(new LinkedProviderBindingImpl<T>(base.getSource(),base.getKey(),base.getScoping(),providerKey));
  return this;
}","@Override public BindingBuilder<T> toProvider(Key<? extends javax.inject.Provider<? extends T>> providerKey){
  checkNotNull(providerKey,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  setBinding(new LinkedProviderBindingImpl<T>(base.getSource(),base.getKey(),base.getScoping(),providerKey));
  return this;
}",0.9851632047477744
60292,"public <S extends T>ScopedBindingBuilder toConstructor(Constructor<S> constructor,TypeLiteral<? extends S> type){
  checkNotNull(constructor,""String_Node_Str"");
  checkNotNull(type,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=InjectionPoint.forInstanceMethodsAndFields(type);
  }
 catch (  ConfigurationException e) {
    copyErrorsToBinder(e);
    injectionPoints=e.getPartialValue();
  }
  try {
    InjectionPoint constructorPoint=InjectionPoint.forConstructor(constructor,type);
    setBinding(new ConstructorBindingImpl<T>(base.getKey(),base.getSource(),base.getScoping(),constructorPoint,injectionPoints));
  }
 catch (  ConfigurationException e) {
    copyErrorsToBinder(e);
  }
  return this;
}","@Override public <S extends T>ScopedBindingBuilder toConstructor(Constructor<S> constructor,TypeLiteral<? extends S> type){
  checkNotNull(constructor,""String_Node_Str"");
  checkNotNull(type,""String_Node_Str"");
  checkNotTargetted();
  BindingImpl<T> base=getBinding();
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=InjectionPoint.forInstanceMethodsAndFields(type);
  }
 catch (  ConfigurationException e) {
    copyErrorsToBinder(e);
    injectionPoints=e.getPartialValue();
  }
  try {
    InjectionPoint constructorPoint=InjectionPoint.forConstructor(constructor,type);
    setBinding(new ConstructorBindingImpl<T>(base.getKey(),base.getSource(),base.getScoping(),constructorPoint,injectionPoints));
  }
 catch (  ConfigurationException e) {
    copyErrorsToBinder(e);
  }
  return this;
}",0.9938118811881188
60293,"public <V>V acceptVisitor(ElementVisitor<V> visitor){
  return visitor.visit(this);
}","@Override public <V>V acceptVisitor(ElementVisitor<V> visitor){
  return visitor.visit(this);
}",0.9444444444444444
60294,"public Key<T> getKey(){
  return key;
}","@Override public Key<T> getKey(){
  return key;
}",0.8863636363636364
60295,"public <V>V acceptScopingVisitor(BindingScopingVisitor<V> visitor){
  return scoping.acceptVisitor(visitor);
}","@Override public <V>V acceptScopingVisitor(BindingScopingVisitor<V> visitor){
  return scoping.acceptVisitor(visitor);
}",0.9565217391304348
60296,"public Object getSource(){
  return source;
}","@Override public Object getSource(){
  return source;
}",0.9
60297,"public Provider<T> getProvider(){
  if (provider == null) {
    if (injector == null) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    provider=injector.getProvider(key);
  }
  return provider;
}","@Override public Provider<T> getProvider(){
  if (provider == null) {
    if (injector == null) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    provider=injector.getProvider(key);
  }
  return provider;
}",0.9781659388646288
60298,"public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  context.pushState(providerKey,source);
  try {
    errors=errors.withSource(providerKey);
    javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency,true);
    return circularGet(provider,errors,context,dependency,provisionCallback);
  }
  finally {
    context.popState();
  }
}","@Override public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  context.pushState(providerKey,source);
  try {
    errors=errors.withSource(providerKey);
    javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency,true);
    return circularGet(provider,errors,context,dependency,provisionCallback);
  }
  finally {
    context.popState();
  }
}",0.9885844748858448
60299,"public void notify(Errors errors){
  try {
    providerFactory=injector.getInternalFactory(providerKey,errors.withSource(source),JitLimitation.NEW_OR_EXISTING_JIT);
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}","@Override public void notify(Errors errors){
  try {
    providerFactory=injector.getInternalFactory(providerKey,errors.withSource(source),JitLimitation.NEW_OR_EXISTING_JIT);
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}",0.9794238683127572
60300,"public void atInject(){
}","@SuppressWarnings(""String_Node_Str"") public void atInject(){
}",0.5747126436781609
60301,"@Override public void privateGAndPublicAt(){
}","@SuppressWarnings(""String_Node_Str"") @Override public void privateGAndPublicAt(){
}",0.7131782945736435
60302,"public String getName(){
  return ""String_Node_Str"";
}","@Override public String getName(){
  return ""String_Node_Str"";
}",0.9152542372881356
60303,"@Provides @Singleton @Sole Bob provideSoleBob(final Dagny dagny){
  return new Bob(){
    public String getName(){
      return ""String_Node_Str"";
    }
    public Dagny getDaughter(){
      return dagny;
    }
  }
;
}","@Provides @Singleton @Sole Bob provideSoleBob(final Dagny dagny){
  return new Bob(){
    @Override public String getName(){
      return ""String_Node_Str"";
    }
    @Override public Dagny getDaughter(){
      return dagny;
    }
  }
;
}",0.956140350877193
60304,"@Provides public String getT(){
  return ""String_Node_Str"";
}","@Override @Provides public String getT(){
  return ""String_Node_Str"";
}",0.9242424242424242
60305,"@Provides @Singleton Dagny provideDagny(){
  return new Dagny(){
    public int getAge(){
      return 1;
    }
  }
;
}","@Provides @Singleton Dagny provideDagny(){
  return new Dagny(){
    @Override public int getAge(){
      return 1;
    }
  }
;
}",0.9596774193548387
60306,"@Provides Integer provideInt(@Named(""String_Node_Str"") String dep){
  return 42;
}","@Provides @Singleton int provideInt(){
  throw new RuntimeException(""String_Node_Str"");
}",0.5614035087719298
60307,"public int getAge(){
  return 1;
}","@Override public int getAge(){
  return 1;
}",0.8717948717948718
60308,"@Provides Bob provideBob(final Dagny dagny){
  return new Bob(){
    public String getName(){
      return ""String_Node_Str"";
    }
    public Dagny getDaughter(){
      return dagny;
    }
  }
;
}","@Provides Bob provideBob(final Dagny dagny){
  return new Bob(){
    @Override public String getName(){
      return ""String_Node_Str"";
    }
    @Override public Dagny getDaughter(){
      return dagny;
    }
  }
;
}",0.9516908212560388
60309,"public Dagny getDaughter(){
  return dagny;
}","@Override public Dagny getDaughter(){
  return dagny;
}",0.9
60310,"@SuppressWarnings(""String_Node_Str"") public ProvidesMethodBinding<T> visit(ProvidesMethodBinding<? extends T> providesMethodBinding){
  return (ProvidesMethodBinding<T>)providesMethodBinding;
}","@Override @SuppressWarnings(""String_Node_Str"") public ProvidesMethodBinding<T> visit(ProvidesMethodBinding<? extends T> providesMethodBinding){
  return (ProvidesMethodBinding<T>)providesMethodBinding;
}",0.9747474747474748
60311,"public void testReturnDelegateCookies(){
  Cookie[] cookies=new Cookie[]{new Cookie(""String_Node_Str"",TEST_VALUE_1),new Cookie(""String_Node_Str"",""String_Node_Str"")};
  HttpServletRequest delegate=createMock(HttpServletRequest.class);
  expect(delegate.getCookies()).andStubReturn(cookies);
  replay(delegate);
  ContinuingHttpServletRequest continuingRequest=new ContinuingHttpServletRequest(delegate);
  assertCookieArraysEqual(cookies,continuingRequest.getCookies());
  cookies[0].setValue(""String_Node_Str"");
  cookies[1].setValue(""String_Node_Str"");
  cookies[1].setMaxAge(123);
  try {
    assertCookieArraysEqual(cookies,continuingRequest.getCookies());
    fail();
  }
 catch (  AssertionFailedError e) {
  }
  assertEquals(TEST_VALUE_1,continuingRequest.getCookies()[0].getValue());
  assertEquals(TEST_VALUE_2,continuingRequest.getCookies()[1].getValue());
  assertEquals(DEFAULT_MAX_AGE,continuingRequest.getCookies()[1].getMaxAge());
  ContinuingHttpServletRequest furtherContinuingRequest=new ContinuingHttpServletRequest(continuingRequest);
  assertCookieArraysEqual(continuingRequest.getCookies(),furtherContinuingRequest.getCookies());
  verify(delegate);
}","public void testReturnDelegateCookies(){
  Cookie[] cookies=new Cookie[]{new Cookie(""String_Node_Str"",TEST_VALUE_1),new Cookie(""String_Node_Str"",""String_Node_Str"")};
  HttpServletRequest delegate=createMock(HttpServletRequest.class);
  expect(delegate.getCookies()).andStubReturn(cookies);
  replay(delegate);
  ContinuingHttpServletRequest continuingRequest=new ContinuingHttpServletRequest(delegate);
  assertCookieArraysEqual(cookies,continuingRequest.getCookies());
  cookies[0].setValue(""String_Node_Str"");
  cookies[1].setValue(""String_Node_Str"");
  cookies[1].setMaxAge(123);
  try {
    assertCookieArraysEqual(cookies,continuingRequest.getCookies());
    throw new Error();
  }
 catch (  AssertionFailedError e) {
  }
  assertEquals(TEST_VALUE_1,continuingRequest.getCookies()[0].getValue());
  assertEquals(TEST_VALUE_2,continuingRequest.getCookies()[1].getValue());
  assertEquals(DEFAULT_MAX_AGE,continuingRequest.getCookies()[1].getMaxAge());
  ContinuingHttpServletRequest furtherContinuingRequest=new ContinuingHttpServletRequest(continuingRequest);
  assertCookieArraysEqual(continuingRequest.getCookies(),furtherContinuingRequest.getCookies());
  verify(delegate);
}",0.991932059447983
60312,"public void testBindingSuperTypeAccessSubType(){
  final Integer testValue=1024;
  Object instance=new Object(){
    @Bind(to=Number.class) private Integer anInt=testValue;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  Injector injector=Guice.createInjector(module);
  try {
    injector.getInstance(Integer.class);
  }
 catch (  ConfigurationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testBindingSuperTypeAccessSubType(){
  final Integer testValue=1024;
  Object instance=new Object(){
    @Bind(to=Number.class) private Integer anInt=testValue;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  Injector injector=Guice.createInjector(module);
  try {
    injector.getInstance(Integer.class);
    fail();
  }
 catch (  ConfigurationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}",0.986425339366516
60313,"public void testMultipleErrorsAreAggregated(){
  Object instance=new Object(){
    @Bind private Provider aProvider;
    @Bind(to=String.class) private Integer anInt;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
  }
 catch (  CreationException e) {
    assertEquals(2,e.getErrorMessages().size());
  }
}","public void testMultipleErrorsAreAggregated(){
  Object instance=new Object(){
    @Bind private Provider aProvider;
    @Bind(to=String.class) private Integer anInt;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
    fail();
  }
 catch (  CreationException e) {
    assertEquals(2,e.getErrorMessages().size());
  }
}",0.983739837398374
60314,"public void testClassIsPrintedInErrorsWhenCauseIsSuperclass(){
  Object instance=new InvalidBindableSubclass();
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
  }
}","public void testClassIsPrintedInErrorsWhenCauseIsSuperclass(){
  Object instance=new InvalidBindableSubclass();
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
    fail();
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.981981981981982
60315,"public void testFailureOnMultipleBindingAnnotations(){
  final Integer testInt=1024;
  Object instance=new Object(){
    @Bind @Named(""String_Node_Str"") @SomeBindingAnnotation private Integer anInt=testInt;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testFailureOnMultipleBindingAnnotations(){
  final Integer testInt=1024;
  Object instance=new Object(){
    @Bind @Named(""String_Node_Str"") @SomeBindingAnnotation private Integer anInt=testInt;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
    fail();
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}",0.9855072463768116
60316,"public void testBoundFieldsCannotBeInjected(){
  Object instance=new Object(){
    @Bind @Inject Integer anInt=0;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testBoundFieldsCannotBeInjected(){
  Object instance=new Object(){
    @Bind @Inject Integer anInt=0;
  }
;
  BoundFieldModule module=BoundFieldModule.of(instance);
  try {
    Guice.createInjector(module);
    fail();
  }
 catch (  CreationException e) {
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}",0.9813084112149532
60317,"@Before public void setUp() throws Exception {
  when(provider.createEntityManagerFactory(PERSISTENCE_UNIT_NAME,PERSISTENCE_PROPERTIES)).thenReturn(factory);
  when(factory.createEntityManager()).thenReturn(entityManager);
}","@Override public void setUp() throws Exception {
  when(provider.createEntityManagerFactory(PERSISTENCE_UNIT_NAME,PERSISTENCE_PROPERTIES)).thenReturn(factory);
  when(factory.createEntityManager()).thenReturn(entityManager);
}",0.9733333333333334
60318,"public void testChildInjectorInheritsOption(){
  Injector parent=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      binder().requireExplicitBindings();
      bind(Bar.class);
    }
  }
);
  ensureWorks(parent,Bar.class);
  ensureFails(parent,FAIL_ALL,FooImpl.class,FooBar.class,Foo.class);
  try {
    parent.createChildInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(FooBar.class);
      }
    }
);
    fail(""String_Node_Str"");
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"" + jitFailed(Foo.class));
    assertTrue(expected.getMessage(),!expected.getMessage().contains(""String_Node_Str""));
  }
  Injector child=parent.createChildInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(Foo.class).to(FooImpl.class);
    }
  }
);
  ensureWorks(child,Foo.class,Bar.class);
  ensureFails(child,ALLOW_BINDING,FooImpl.class);
  ensureInChild(parent,FooImpl.class,FooBar.class,Foo.class);
  Injector grandchild=child.createChildInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(FooBar.class);
    }
  }
);
  ensureWorks(grandchild,FooBar.class,Foo.class,Bar.class);
  ensureFails(grandchild,ALLOW_BINDING,FooImpl.class);
  ensureFails(child,ALLOW_BINDING,FooImpl.class);
  ensureInChild(parent,FooImpl.class,FooBar.class,Foo.class);
}","public void testChildInjectorInheritsOption(){
  Injector parent=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      binder().requireExplicitBindings();
      bind(Bar.class);
    }
  }
);
  ensureWorks(parent,Bar.class);
  ensureFails(parent,FAIL_ALL,FooImpl.class,FooBar.class,Foo.class);
  try {
    parent.createChildInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(FooBar.class);
      }
    }
);
    fail(""String_Node_Str"");
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"" + jitFailed(Foo.class));
    assertTrue(expected.getMessage(),!expected.getMessage().contains(""String_Node_Str""));
  }
  Injector child=parent.createChildInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(Foo.class).to(FooImpl.class);
    }
  }
);
  ensureWorks(child,Foo.class,Bar.class);
  ensureFails(child,ALLOW_BINDING,FooImpl.class);
  ensureInChild(parent,FooImpl.class,Foo.class);
  Injector grandchild=child.createChildInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(FooBar.class);
    }
  }
);
  ensureWorks(grandchild,FooBar.class,Foo.class,Bar.class);
  ensureFails(grandchild,ALLOW_BINDING,FooImpl.class);
  ensureFails(child,ALLOW_BINDING,FooImpl.class);
  ensureInChild(parent,FooImpl.class,FooBar.class,Foo.class);
}",0.995420922860162
60319,"/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified.
 */
<T>BindingImpl<T> createUninitializedBinding(Key<T> key,Scoping scoping,Object source,Errors errors,boolean jitBinding) throws ErrorsException {
  Class<?> rawType=key.getTypeLiteral().getRawType();
  if (rawType.isArray() || rawType.isEnum()) {
    throw errors.missingImplementation(key).toException();
  }
  if (rawType == TypeLiteral.class) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createTypeLiteralBinding((Key<TypeLiteral<Object>>)key,errors);
    return binding;
  }
  ImplementedBy implementedBy=rawType.getAnnotation(ImplementedBy.class);
  if (implementedBy != null) {
    Annotations.checkForMisplacedScopeAnnotations(rawType,source,errors);
    return createImplementedByBinding(key,scoping,implementedBy,errors);
  }
  ProvidedBy providedBy=rawType.getAnnotation(ProvidedBy.class);
  if (providedBy != null) {
    Annotations.checkForMisplacedScopeAnnotations(rawType,source,errors);
    return createProvidedByBinding(key,scoping,providedBy,errors);
  }
  return ConstructorBindingImpl.create(this,key,null,source,scoping,errors,jitBinding && options.jitDisabled,options.atInjectRequired);
}","/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified.
 */
<T>BindingImpl<T> createUninitializedBinding(Key<T> key,Scoping scoping,Object source,Errors errors,boolean jitBinding) throws ErrorsException {
  Class<?> rawType=key.getTypeLiteral().getRawType();
  ImplementedBy implementedBy=rawType.getAnnotation(ImplementedBy.class);
  if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) {
    throw errors.missingImplementation(key).toException();
  }
  if (rawType == TypeLiteral.class) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createTypeLiteralBinding((Key<TypeLiteral<Object>>)key,errors);
    return binding;
  }
  if (implementedBy != null) {
    Annotations.checkForMisplacedScopeAnnotations(rawType,source,errors);
    return createImplementedByBinding(key,scoping,implementedBy,errors);
  }
  ProvidedBy providedBy=rawType.getAnnotation(ProvidedBy.class);
  if (providedBy != null) {
    Annotations.checkForMisplacedScopeAnnotations(rawType,source,errors);
    return createProvidedByBinding(key,scoping,providedBy,errors);
  }
  return ConstructorBindingImpl.create(this,key,null,source,scoping,errors,jitBinding && options.jitDisabled,options.atInjectRequired);
}",0.9319860085503304
60320,"public String get(){
  return TEST_VALUE;
}","@Override public EmptyEnum get(){
  return null;
}",0.6236559139784946
60321,"public boolean matches(String uri){
  return null != uri && this.pattern.matcher(uri).matches();
}","public boolean matches(String uri){
  return null != uri && this.pattern.matcher(getUri(uri)).matches();
}",0.9607843137254902
60322,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTestSuite(EdslTest.class);
  suite.addTestSuite(FilterDefinitionTest.class);
  suite.addTestSuite(FilterDispatchIntegrationTest.class);
  suite.addTestSuite(FilterPipelineTest.class);
  suite.addTestSuite(ServletModuleTest.class);
  suite.addTestSuite(ServletTest.class);
  suite.addTestSuite(ServletDefinitionTest.class);
  suite.addTestSuite(ServletDefinitionPathsTest.class);
  suite.addTestSuite(ServletPipelineRequestDispatcherTest.class);
  suite.addTestSuite(ServletDispatchIntegrationTest.class);
  suite.addTestSuite(InvalidScopeBindingTest.class);
  suite.addTestSuite(ContinuingHttpServletRequestTest.class);
  suite.addTestSuite(VarargsFilterDispatchIntegrationTest.class);
  suite.addTestSuite(VarargsServletDispatchIntegrationTest.class);
  suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
  suite.addTestSuite(ExtensionSpiTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTestSuite(EdslTest.class);
  suite.addTestSuite(FilterDefinitionTest.class);
  suite.addTestSuite(FilterDispatchIntegrationTest.class);
  suite.addTestSuite(FilterPipelineTest.class);
  suite.addTestSuite(ServletModuleTest.class);
  suite.addTestSuite(ServletTest.class);
  suite.addTestSuite(ServletDefinitionTest.class);
  suite.addTestSuite(ServletDefinitionPathsTest.class);
  suite.addTestSuite(ServletPipelineRequestDispatcherTest.class);
  suite.addTestSuite(ServletDispatchIntegrationTest.class);
  suite.addTestSuite(InvalidScopeBindingTest.class);
  suite.addTestSuite(ContinuingHttpServletRequestTest.class);
  suite.addTestSuite(VarargsFilterDispatchIntegrationTest.class);
  suite.addTestSuite(VarargsServletDispatchIntegrationTest.class);
  suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
  suite.addTestSuite(ExtensionSpiTest.class);
  suite.addTestSuite(UriPatternTypeTest.class);
  return suite;
}",0.9754601226993864
60323,"@Override protected void configureServlets(){
  serve(""String_Node_Str"").with(ForwardingServlet.class);
  serve(""String_Node_Str"").with(ForwardedServlet.class);
}","@Override protected void configureServlets(){
  filter(""String_Node_Str"").through(TestFilter.class);
  serve(""String_Node_Str"").with(TestServlet.class);
}",0.8607594936708861
60324,"public Entry<K,Provider<V>> get(){
  return this;
}","@Override public List<String> get(){
  return Lists.newArrayList();
}",0.55
60325,"@Override public String getPathInfo(){
  if (!isPathInfoComputed()) {
    int servletPathLength=getServletPath().length();
    pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
    pathInfo=pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;
    if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
      pathInfo=null;
    }
    pathInfoComputed=true;
  }
  return pathInfo;
}","@Override public String getPathInfo(){
  if (!isPathInfoComputed()) {
    String servletPath=getServletPath();
    int servletPathLength=servletPath.length();
    String requestUri=getRequestURI();
    pathInfo=requestUri.substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (pathInfo.startsWith(servletPath)) {
      pathInfo=pathInfo.substring(servletPathLength);
      if (pathInfo.isEmpty() && servletPathLength > 0) {
        pathInfo=null;
      }
    }
    pathInfoComputed=true;
  }
  return pathInfo;
}",0.6011560693641619
60326,"/** 
 * Utility that delegates to the actual service method of the servlet wrapped with a contextual request (i.e. with correctly computed path info). We need to suppress deprecation coz we use HttpServletRequestWrapper, which implements deprecated API for backwards compatibility.
 */
void doService(final ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  HttpServletRequest request=new HttpServletRequestWrapper((HttpServletRequest)servletRequest){
    private boolean pathComputed;
    private String path;
    private boolean pathInfoComputed;
    private String pathInfo;
    @Override public String getPathInfo(){
      if (!isPathInfoComputed()) {
        int servletPathLength=getServletPath().length();
        pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
        pathInfo=pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;
        if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
          pathInfo=null;
        }
        pathInfoComputed=true;
      }
      return pathInfo;
    }
    private boolean isPathInfoComputed(){
      return pathInfoComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    private boolean isPathComputed(){
      return pathComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    @Override public String getServletPath(){
      return computePath();
    }
    @Override public String getPathTranslated(){
      final String info=getPathInfo();
      return (null == info) ? null : getRealPath(info);
    }
    private String computePath(){
      if (!isPathComputed()) {
        String servletPath=super.getServletPath();
        path=patternMatcher.extractPath(servletPath);
        pathComputed=true;
        if (null == path) {
          path=servletPath;
        }
      }
      return path;
    }
  }
;
  doServiceImpl(request,(HttpServletResponse)servletResponse);
}","/** 
 * Utility that delegates to the actual service method of the servlet wrapped with a contextual request (i.e. with correctly computed path info). We need to suppress deprecation coz we use HttpServletRequestWrapper, which implements deprecated API for backwards compatibility.
 */
void doService(final ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  HttpServletRequest request=new HttpServletRequestWrapper((HttpServletRequest)servletRequest){
    private boolean pathComputed;
    private String path;
    private boolean pathInfoComputed;
    private String pathInfo;
    @Override public String getPathInfo(){
      if (!isPathInfoComputed()) {
        String servletPath=getServletPath();
        int servletPathLength=servletPath.length();
        String requestUri=getRequestURI();
        pathInfo=requestUri.substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
        if (pathInfo.startsWith(servletPath)) {
          pathInfo=pathInfo.substring(servletPathLength);
          if (pathInfo.isEmpty() && servletPathLength > 0) {
            pathInfo=null;
          }
        }
        pathInfoComputed=true;
      }
      return pathInfo;
    }
    private boolean isPathInfoComputed(){
      return pathInfoComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    private boolean isPathComputed(){
      return pathComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    @Override public String getServletPath(){
      return computePath();
    }
    @Override public String getPathTranslated(){
      final String info=getPathInfo();
      return (null == info) ? null : getRealPath(info);
    }
    private String computePath(){
      if (!isPathComputed()) {
        String servletPath=super.getServletPath();
        path=patternMatcher.extractPath(servletPath);
        pathComputed=true;
        if (null == path) {
          path=servletPath;
        }
      }
      return path;
    }
  }
;
  doServiceImpl(request,(HttpServletResponse)servletResponse);
}",0.9087434304825608
60327,"public final void testPathInfoWithServletStyleMatching() throws IOException, ServletException {
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
}","public final void testPathInfoWithServletStyleMatching() throws IOException, ServletException {
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
  pathInfoWithServletStyleMatching(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"");
}",0.9607903673973448
60328,"/** 
 * Creates and returns the injector shells for the current modules. Multiple shells will be returned if any modules contain   {@link Binder#newPrivateBinder private environments}. The primary injector will be first in the returned list.
 */
List<InjectorShell> build(Initializer initializer,ProcessedBindingData bindingData,Stopwatch stopwatch,Errors errors){
  checkState(stage != null,""String_Node_Str"");
  checkState(privateElements == null || parent != null,""String_Node_Str"");
  checkState(state != null,""String_Node_Str"");
  if (parent == null) {
    modules.add(0,new RootModule());
  }
  elements.addAll(Elements.getElements(stage,modules));
  InjectorOptionsProcessor optionsProcessor=new InjectorOptionsProcessor(errors);
  optionsProcessor.process(null,elements);
  options=optionsProcessor.getOptions(stage,options);
  InjectorImpl injector=new InjectorImpl(parent,state,options);
  if (privateElements != null) {
    privateElements.initInjector(injector);
  }
  if (parent == null) {
    new TypeConverterBindingProcessor(errors).prepareBuiltInConverters(injector);
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  new MessageProcessor(errors).process(injector,elements);
  new InterceptorBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ListenerBindingProcessor(errors).process(injector,elements);
  List<TypeListenerBinding> typeListenerBindings=injector.state.getTypeListenerBindings();
  injector.membersInjectorStore=new MembersInjectorStore(injector,typeListenerBindings);
  List<ProvisionListenerBinding> provisionListenerBindings=injector.state.getProvisionListenerBindings();
  injector.provisionListenerStore=new ProvisionListenerCallbackStore(provisionListenerBindings);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopeBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeConverterBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindStage(injector,stage);
  bindInjector(injector);
  bindLogger(injector);
  new BindingProcessor(errors,initializer,bindingData).process(injector,elements);
  new UntargettedBindingProcessor(errors,bindingData).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  List<InjectorShell> injectorShells=Lists.newArrayList();
  injectorShells.add(new InjectorShell(this,elements,injector));
  PrivateElementProcessor processor=new PrivateElementProcessor(errors);
  processor.process(injector,elements);
  for (  Builder builder : processor.getInjectorShellBuilders()) {
    injectorShells.addAll(builder.build(initializer,bindingData,stopwatch,errors));
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  return injectorShells;
}","/** 
 * Creates and returns the injector shells for the current modules. Multiple shells will be returned if any modules contain   {@link Binder#newPrivateBinder private environments}. The primary injector will be first in the returned list.
 */
List<InjectorShell> build(Initializer initializer,ProcessedBindingData bindingData,Stopwatch stopwatch,Errors errors){
  checkState(stage != null,""String_Node_Str"");
  checkState(privateElements == null || parent != null,""String_Node_Str"");
  checkState(state != null,""String_Node_Str"");
  if (parent == null) {
    modules.add(0,new RootModule());
  }
  elements.addAll(Elements.getElements(stage,modules));
  InjectorOptionsProcessor optionsProcessor=new InjectorOptionsProcessor(errors);
  optionsProcessor.process(null,elements);
  options=optionsProcessor.getOptions(stage,options);
  InjectorImpl injector=new InjectorImpl(parent,state,options);
  if (privateElements != null) {
    privateElements.initInjector(injector);
  }
  if (parent == null) {
    TypeConverterBindingProcessor.prepareBuiltInConverters(injector);
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  new MessageProcessor(errors).process(injector,elements);
  new InterceptorBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ListenerBindingProcessor(errors).process(injector,elements);
  List<TypeListenerBinding> typeListenerBindings=injector.state.getTypeListenerBindings();
  injector.membersInjectorStore=new MembersInjectorStore(injector,typeListenerBindings);
  List<ProvisionListenerBinding> provisionListenerBindings=injector.state.getProvisionListenerBindings();
  injector.provisionListenerStore=new ProvisionListenerCallbackStore(provisionListenerBindings);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopeBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeConverterBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindStage(injector,stage);
  bindInjector(injector);
  bindLogger(injector);
  new BindingProcessor(errors,initializer,bindingData).process(injector,elements);
  new UntargettedBindingProcessor(errors,bindingData).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  List<InjectorShell> injectorShells=Lists.newArrayList();
  injectorShells.add(new InjectorShell(this,elements,injector));
  PrivateElementProcessor processor=new PrivateElementProcessor(errors);
  processor.process(injector,elements);
  for (  Builder builder : processor.getInjectorShellBuilders()) {
    injectorShells.addAll(builder.build(initializer,bindingData,stopwatch,errors));
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  return injectorShells;
}",0.9978323699421964
60329,"/** 
 * Installs default converters for primitives, enums, and class literals. 
 */
void prepareBuiltInConverters(InjectorImpl injector){
  this.injector=injector;
  try {
    convertToPrimitiveType(int.class,Integer.class);
    convertToPrimitiveType(long.class,Long.class);
    convertToPrimitiveType(boolean.class,Boolean.class);
    convertToPrimitiveType(byte.class,Byte.class);
    convertToPrimitiveType(short.class,Short.class);
    convertToPrimitiveType(float.class,Float.class);
    convertToPrimitiveType(double.class,Double.class);
    convertToClass(Character.class,new TypeConverter(){
      public Object convert(      String value,      TypeLiteral<?> toType){
        value=value.trim();
        if (value.length() != 1) {
          throw new RuntimeException(""String_Node_Str"");
        }
        return value.charAt(0);
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
);
    convertToClasses(Matchers.subclassesOf(Enum.class),new TypeConverter(){
      @SuppressWarnings(""String_Node_Str"") public Object convert(      String value,      TypeLiteral<?> toType){
        return Enum.valueOf((Class)toType.getRawType(),value);
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
);
    internalConvertToTypes(new AbstractMatcher<TypeLiteral<?>>(){
      public boolean matches(      TypeLiteral<?> typeLiteral){
        return typeLiteral.getRawType() == Class.class;
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
,new TypeConverter(){
      @SuppressWarnings(""String_Node_Str"") public Object convert(      String value,      TypeLiteral<?> toType){
        try {
          return Class.forName(value);
        }
 catch (        ClassNotFoundException e) {
          throw new RuntimeException(e.getMessage());
        }
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
);
  }
  finally {
    this.injector=null;
  }
}","/** 
 * Installs default converters for primitives, enums, and class literals. 
 */
static void prepareBuiltInConverters(InjectorImpl injector){
  convertToPrimitiveType(injector,int.class,Integer.class);
  convertToPrimitiveType(injector,long.class,Long.class);
  convertToPrimitiveType(injector,boolean.class,Boolean.class);
  convertToPrimitiveType(injector,byte.class,Byte.class);
  convertToPrimitiveType(injector,short.class,Short.class);
  convertToPrimitiveType(injector,float.class,Float.class);
  convertToPrimitiveType(injector,double.class,Double.class);
  convertToClass(injector,Character.class,new TypeConverter(){
    public Object convert(    String value,    TypeLiteral<?> toType){
      value=value.trim();
      if (value.length() != 1) {
        throw new RuntimeException(""String_Node_Str"");
      }
      return value.charAt(0);
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  convertToClasses(injector,Matchers.subclassesOf(Enum.class),new TypeConverter(){
    @SuppressWarnings(""String_Node_Str"") public Object convert(    String value,    TypeLiteral<?> toType){
      return Enum.valueOf((Class)toType.getRawType(),value);
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  internalConvertToTypes(injector,new AbstractMatcher<TypeLiteral<?>>(){
    public boolean matches(    TypeLiteral<?> typeLiteral){
      return typeLiteral.getRawType() == Class.class;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
,new TypeConverter(){
    @SuppressWarnings(""String_Node_Str"") public Object convert(    String value,    TypeLiteral<?> toType){
      try {
        return Class.forName(value);
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeException(e.getMessage());
      }
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
);
}",0.739119496855346
60330,"private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,TypeConverter converter){
  injector.state.addConverter(new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE,typeMatcher,converter));
}","private static void internalConvertToTypes(InjectorImpl injector,Matcher<? super TypeLiteral<?>> typeMatcher,TypeConverter converter){
  injector.state.addConverter(new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE,typeMatcher,converter));
}",0.937365010799136
60331,"private void convertToClasses(final Matcher<? super Class<?>> typeMatcher,TypeConverter converter){
  internalConvertToTypes(new AbstractMatcher<TypeLiteral<?>>(){
    public boolean matches(    TypeLiteral<?> typeLiteral){
      Type type=typeLiteral.getType();
      if (!(type instanceof Class)) {
        return false;
      }
      Class<?> clazz=(Class<?>)type;
      return typeMatcher.matches(clazz);
    }
    @Override public String toString(){
      return typeMatcher.toString();
    }
  }
,converter);
}","private static void convertToClasses(InjectorImpl injector,final Matcher<? super Class<?>> typeMatcher,TypeConverter converter){
  internalConvertToTypes(injector,new AbstractMatcher<TypeLiteral<?>>(){
    public boolean matches(    TypeLiteral<?> typeLiteral){
      Type type=typeLiteral.getType();
      if (!(type instanceof Class)) {
        return false;
      }
      Class<?> clazz=(Class<?>)type;
      return typeMatcher.matches(clazz);
    }
    @Override public String toString(){
      return typeMatcher.toString();
    }
  }
,converter);
}",0.9644859813084112
60332,"private <T>void convertToClass(Class<T> type,TypeConverter converter){
  convertToClasses(Matchers.identicalTo(type),converter);
}","private static <T>void convertToClass(InjectorImpl injector,Class<T> type,TypeConverter converter){
  convertToClasses(injector,Matchers.identicalTo(type),converter);
}",0.87248322147651
60333,"private <T>void convertToPrimitiveType(Class<T> primitiveType,final Class<T> wrapperType){
  try {
    final Method parser=wrapperType.getMethod(""String_Node_Str"" + capitalize(primitiveType.getName()),String.class);
    TypeConverter typeConverter=new TypeConverter(){
      @SuppressWarnings(""String_Node_Str"") public Object convert(      String value,      TypeLiteral<?> toType){
        try {
          return parser.invoke(null,value);
        }
 catch (        IllegalAccessException e) {
          throw new AssertionError(e);
        }
catch (        InvocationTargetException e) {
          throw new RuntimeException(e.getTargetException().getMessage());
        }
      }
      @Override public String toString(){
        return ""String_Node_Str"" + wrapperType.getSimpleName() + ""String_Node_Str"";
      }
    }
;
    convertToClass(wrapperType,typeConverter);
  }
 catch (  NoSuchMethodException e) {
    throw new AssertionError(e);
  }
}","private static <T>void convertToPrimitiveType(InjectorImpl injector,Class<T> primitiveType,final Class<T> wrapperType){
  try {
    final Method parser=wrapperType.getMethod(""String_Node_Str"" + capitalize(primitiveType.getName()),String.class);
    TypeConverter typeConverter=new TypeConverter(){
      @SuppressWarnings(""String_Node_Str"") public Object convert(      String value,      TypeLiteral<?> toType){
        try {
          return parser.invoke(null,value);
        }
 catch (        IllegalAccessException e) {
          throw new AssertionError(e);
        }
catch (        InvocationTargetException e) {
          throw new RuntimeException(e.getTargetException().getMessage());
        }
      }
      @Override public String toString(){
        return ""String_Node_Str"" + wrapperType.getSimpleName() + ""String_Node_Str"";
      }
    }
;
    convertToClass(injector,wrapperType,typeConverter);
  }
 catch (  NoSuchMethodException e) {
    throw new AssertionError(e);
  }
}",0.9804123711340206
60334,"public Object proceed() throws Throwable {
  try {
    index++;
    return index == interceptors.length ? methodProxy.invokeSuper(proxy,arguments) : interceptors[index].invoke(this);
  }
 catch (  Throwable t) {
    pruneStacktrace(t);
    throw t;
  }
 finally {
    index--;
  }
}","public Object proceed() throws Throwable {
  try {
    return index == interceptors.length ? methodProxy.invokeSuper(proxy,arguments) : interceptors[index].invoke(new InterceptedMethodInvocation(proxy,methodProxy,arguments,index + 1));
  }
 catch (  Throwable t) {
    pruneStacktrace(t);
    throw t;
  }
}",0.8047538200339559
60335,"public Object intercept(Object proxy,Method method,Object[] arguments,MethodProxy methodProxy) throws Throwable {
  return new InterceptedMethodInvocation(proxy,methodProxy,arguments).proceed();
}","public Object intercept(Object proxy,Method method,Object[] arguments,MethodProxy methodProxy) throws Throwable {
  return new InterceptedMethodInvocation(proxy,methodProxy,arguments,0).proceed();
}",0.9949238578680204
60336,"public InterceptedMethodInvocation(Object proxy,MethodProxy methodProxy,Object[] arguments){
  this.proxy=proxy;
  this.methodProxy=methodProxy;
  this.arguments=arguments;
}","public InterceptedMethodInvocation(Object proxy,MethodProxy methodProxy,Object[] arguments,int index){
  this.proxy=proxy;
  this.methodProxy=methodProxy;
  this.arguments=arguments;
  this.index=index;
}",0.9206349206349206
60337,"public Object invoke(MethodInvocation methodInvocation) throws Throwable {
  called.add(name);
  return methodInvocation.proceed();
}","public Object invoke(final MethodInvocation methodInvocation) throws Throwable {
  queue.add(new Runnable(){
    @Override public void run(){
      try {
        methodInvocation.proceed();
      }
 catch (      Throwable t) {
        throw new RuntimeException(t);
      }
    }
  }
);
  return null;
}",0.5137614678899083
60338,"@Override protected void configure(){
  CountingInterceptor interceptor=new CountingInterceptor();
  bindInterceptor(Matchers.any(),Matchers.any(),interceptor);
  bindInterceptor(Matchers.any(),Matchers.any(),interceptor);
}","protected void configure(){
  bindInterceptor(Matchers.any(),Matchers.any(),new CallLaterInterceptor(queue));
}",0.5850746268656717
60339,"ImmutableList<InjectionListener<? super T>> getInjectionListeners(){
  return injectionListeners == null ? ImmutableList.<InjectionListener<? super T>>of() : ImmutableList.copyOf(injectionListeners);
}","ImmutableSet<InjectionListener<? super T>> getInjectionListeners(){
  return injectionListeners == null ? ImmutableSet.<InjectionListener<? super T>>of() : ImmutableSet.copyOf(injectionListeners);
}",0.962406015037594
60340,"ImmutableList<MembersInjector<? super T>> getMembersInjectors(){
  return membersInjectors == null ? ImmutableList.<MembersInjector<? super T>>of() : ImmutableList.copyOf(membersInjectors);
}","ImmutableSet<MembersInjector<? super T>> getMembersInjectors(){
  return membersInjectors == null ? ImmutableSet.<MembersInjector<? super T>>of() : ImmutableSet.copyOf(membersInjectors);
}",0.9604221635883904
60341,"void injectMembers(T t,Errors errors,InternalContext context,boolean toolableOnly){
  for (int i=0, size=memberInjectors.size(); i < size; i++) {
    SingleMemberInjector injector=memberInjectors.get(i);
    if (!toolableOnly || injector.getInjectionPoint().isToolable()) {
      injector.inject(errors,context,t);
    }
  }
  if (!toolableOnly) {
    for (int i=0, size=userMembersInjectors.size(); i < size; i++) {
      MembersInjector<? super T> userMembersInjector=userMembersInjectors.get(i);
      try {
        userMembersInjector.injectMembers(t);
      }
 catch (      RuntimeException e) {
        errors.errorInUserInjector(userMembersInjector,typeLiteral,e);
      }
    }
  }
}","void injectMembers(T t,Errors errors,InternalContext context,boolean toolableOnly){
  for (int i=0, size=memberInjectors.size(); i < size; i++) {
    SingleMemberInjector injector=memberInjectors.get(i);
    if (!toolableOnly || injector.getInjectionPoint().isToolable()) {
      injector.inject(errors,context,t);
    }
  }
  if (!toolableOnly) {
    for (    MembersInjector<? super T> userMembersInjector : userMembersInjectors) {
      try {
        userMembersInjector.injectMembers(t);
      }
 catch (      RuntimeException e) {
        errors.errorInUserInjector(userMembersInjector,typeLiteral,e);
      }
    }
  }
}",0.9415337889141988
60342,"/** 
 * Creates a new members injector and attaches both injection listeners and method aspects.
 */
private <T>MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=InjectionPoint.forInstanceMethodsAndFields(type);
  }
 catch (  ConfigurationException e) {
    errors.merge(e.getErrorMessages());
    injectionPoints=e.getPartialValue();
  }
  ImmutableList<SingleMemberInjector> injectors=getInjectors(injectionPoints,errors);
  errors.throwIfNewErrors(numErrorsBefore);
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  for (  TypeListenerBinding typeListener : typeListenerBindings) {
    if (typeListener.getTypeMatcher().matches(type)) {
      try {
        typeListener.getListener().hear(type,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(typeListener,type,e);
      }
    }
  }
  encounter.invalidate();
  errors.throwIfNewErrors(numErrorsBefore);
  return new MembersInjectorImpl<T>(injector,type,encounter,injectors);
}","/** 
 * Creates a new members injector and attaches both injection listeners and method aspects.
 */
private <T>MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=InjectionPoint.forInstanceMethodsAndFields(type);
  }
 catch (  ConfigurationException e) {
    errors.merge(e.getErrorMessages());
    injectionPoints=e.getPartialValue();
  }
  ImmutableList<SingleMemberInjector> injectors=getInjectors(injectionPoints,errors);
  errors.throwIfNewErrors(numErrorsBefore);
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  Set<TypeListener> alreadySeenListeners=Sets.newHashSet();
  for (  TypeListenerBinding binding : typeListenerBindings) {
    TypeListener typeListener=binding.getListener();
    if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) {
      alreadySeenListeners.add(typeListener);
      try {
        typeListener.hear(type,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(binding,type,e);
      }
    }
  }
  encounter.invalidate();
  errors.throwIfNewErrors(numErrorsBefore);
  return new MembersInjectorImpl<T>(injector,type,encounter,injectors);
}",0.8889776357827476
60343,"public ProvisionListenerStackCallback(Binding<T> binding,List<ProvisionListener> listeners){
  this.binding=binding;
  if (listeners.isEmpty()) {
    this.listeners=EMPTY_LISTENER;
  }
 else {
    this.listeners=listeners.toArray(new ProvisionListener[listeners.size()]);
  }
}","public ProvisionListenerStackCallback(Binding<T> binding,List<ProvisionListener> listeners){
  this.binding=binding;
  if (listeners.isEmpty()) {
    this.listeners=EMPTY_LISTENER;
  }
 else {
    Set<ProvisionListener> deDuplicated=Sets.newLinkedHashSet(listeners);
    this.listeners=deDuplicated.toArray(new ProvisionListener[deDuplicated.size()]);
  }
}",0.8138801261829653
60344,"ProxyFactory(InjectionPoint injectionPoint,Iterable<MethodAspect> methodAspects){
  this.injectionPoint=injectionPoint;
  @SuppressWarnings(""String_Node_Str"") Constructor<T> constructor=(Constructor<T>)injectionPoint.getMember();
  declaringClass=constructor.getDeclaringClass();
  List<MethodAspect> applicableAspects=Lists.newArrayList();
  for (  MethodAspect methodAspect : methodAspects) {
    if (methodAspect.matches(declaringClass)) {
      applicableAspects.add(methodAspect);
    }
  }
  if (applicableAspects.isEmpty()) {
    interceptors=ImmutableMap.of();
    methods=ImmutableList.of();
    callbacks=null;
    return;
  }
  methods=Lists.newArrayList();
  Enhancer.getMethods(declaringClass,null,methods);
  List<MethodInterceptorsPair> methodInterceptorsPairs=Lists.newArrayList();
  for (  Method method : methods) {
    methodInterceptorsPairs.add(new MethodInterceptorsPair(method));
  }
  boolean anyMatched=false;
  for (  MethodAspect methodAspect : applicableAspects) {
    for (    MethodInterceptorsPair pair : methodInterceptorsPairs) {
      if (methodAspect.matches(pair.method)) {
        if (pair.method.isSynthetic()) {
          logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new Object[]{pair.method,methodAspect.interceptors()});
        }
        visibility=visibility.and(BytecodeGen.Visibility.forMember(pair.method));
        pair.addAll(methodAspect.interceptors());
        anyMatched=true;
      }
    }
  }
  if (!anyMatched) {
    interceptors=ImmutableMap.of();
    callbacks=null;
    return;
  }
  ImmutableMap.Builder<Method,List<MethodInterceptor>> interceptorsMapBuilder=null;
  callbacks=new Callback[methods.size()];
  for (int i=0; i < methods.size(); i++) {
    MethodInterceptorsPair pair=methodInterceptorsPairs.get(i);
    if (!pair.hasInterceptors()) {
      callbacks[i]=net.sf.cglib.proxy.NoOp.INSTANCE;
      continue;
    }
    if (interceptorsMapBuilder == null) {
      interceptorsMapBuilder=ImmutableMap.builder();
    }
    interceptorsMapBuilder.put(pair.method,ImmutableList.copyOf(pair.interceptors));
    callbacks[i]=new InterceptorStackCallback(pair.method,pair.interceptors);
  }
  interceptors=interceptorsMapBuilder != null ? interceptorsMapBuilder.build() : ImmutableMap.<Method,List<MethodInterceptor>>of();
}","ProxyFactory(InjectionPoint injectionPoint,Iterable<MethodAspect> methodAspects){
  this.injectionPoint=injectionPoint;
  @SuppressWarnings(""String_Node_Str"") Constructor<T> constructor=(Constructor<T>)injectionPoint.getMember();
  declaringClass=constructor.getDeclaringClass();
  List<MethodAspect> applicableAspects=Lists.newArrayList();
  for (  MethodAspect methodAspect : methodAspects) {
    if (methodAspect.matches(declaringClass)) {
      applicableAspects.add(methodAspect);
    }
  }
  if (applicableAspects.isEmpty()) {
    interceptors=ImmutableMap.of();
    methods=ImmutableList.of();
    callbacks=null;
    return;
  }
  methods=Lists.newArrayList();
  Enhancer.getMethods(declaringClass,null,methods);
  List<MethodInterceptorsPair> methodInterceptorsPairs=Lists.newArrayList();
  for (  Method method : methods) {
    methodInterceptorsPairs.add(new MethodInterceptorsPair(method));
  }
  boolean anyMatched=false;
  for (  MethodAspect methodAspect : applicableAspects) {
    for (    MethodInterceptorsPair pair : methodInterceptorsPairs) {
      if (methodAspect.matches(pair.method)) {
        if (pair.method.isSynthetic()) {
          logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new Object[]{pair.method,methodAspect.interceptors()});
        }
        visibility=visibility.and(BytecodeGen.Visibility.forMember(pair.method));
        pair.addAll(methodAspect.interceptors());
        anyMatched=true;
      }
    }
  }
  if (!anyMatched) {
    interceptors=ImmutableMap.of();
    callbacks=null;
    return;
  }
  ImmutableMap.Builder<Method,List<MethodInterceptor>> interceptorsMapBuilder=null;
  callbacks=new Callback[methods.size()];
  for (int i=0; i < methods.size(); i++) {
    MethodInterceptorsPair pair=methodInterceptorsPairs.get(i);
    if (!pair.hasInterceptors()) {
      callbacks[i]=net.sf.cglib.proxy.NoOp.INSTANCE;
      continue;
    }
    if (interceptorsMapBuilder == null) {
      interceptorsMapBuilder=ImmutableMap.builder();
    }
    ImmutableList<MethodInterceptor> deDuplicated=ImmutableSet.copyOf(pair.interceptors).asList();
    interceptorsMapBuilder.put(pair.method,deDuplicated);
    callbacks[i]=new InterceptorStackCallback(pair.method,deDuplicated);
  }
  interceptors=interceptorsMapBuilder != null ? interceptorsMapBuilder.build() : ImmutableMap.<Method,List<MethodInterceptor>>of();
}",0.9620038208448312
60345,"protected void configure(){
  bindInterceptor(Matchers.any(),Matchers.any(),new NamedInterceptor(""String_Node_Str"",callList),new NamedInterceptor(""String_Node_Str"",callList),new NamedInterceptor(""String_Node_Str"",callList));
}","@Override protected void configure(){
  CountingInterceptor interceptor=new CountingInterceptor();
  bindInterceptor(Matchers.any(),Matchers.any(),interceptor);
  bindInterceptor(Matchers.any(),Matchers.any(),interceptor);
}",0.3555555555555555
60346,"@Override protected void configure(){
  bindListener(Matchers.any(),new ProvisionListener(){
    @Override public <T>void onProvision(    ProvisionInvocation<T> provision){
      Object provisioned=provision.provision();
      if (provisioned instanceof X) {
        ((X)provisioned).init();
      }
 else       if (provisioned instanceof Y) {
        X.createY=false;
        ((Y)provisioned).init();
      }
    }
  }
);
}","@Override protected void configure(){
  bindListener(Matchers.any(),counter);
  bindListener(Matchers.any(),counter);
}",0.3535911602209944
60347,"public void injectMembers(D instance){
  instance.userInjected++;
  assertEquals(instance.guiceInjected,instance.userInjected);
}","public void injectMembers(D instance){
  ++instance.userInjected;
}",0.6632653061224489
60348,"public void afterInjection(Object injectee){
}","public void afterInjection(D injectee){
  ++injectee.listenersNotified;
}",0.6722689075630253
60349,"public <I>void hear(TypeLiteral<I> type,TypeEncounter<I> encounter){
  encounter.addError(""String_Node_Str"",type);
  encounter.addError(new IllegalArgumentException(""String_Node_Str""));
  encounter.addError(new Message(""String_Node_Str""));
  encounter.addError(new IllegalStateException());
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <I>void hear(TypeLiteral<I> type,TypeEncounter<I> encounter){
  ++count;
  MembersInjector membersInjector=new CountingMembersInjector();
  encounter.register(membersInjector);
  encounter.register(membersInjector);
  InjectionListener injectionListener=new CountingInjectionListener();
  encounter.register(injectionListener);
  encounter.register(injectionListener);
}",0.3691460055096419
60350,"@Override protected void configure(){
  requestInjection(new Object());
  bindListener(Matchers.any(),new TypeListener(){
    public <I>void hear(    TypeLiteral<I> type,    TypeEncounter<I> encounter){
      encounter.addError(""String_Node_Str"",type);
      encounter.addError(new IllegalArgumentException(""String_Node_Str""));
      encounter.addError(new Message(""String_Node_Str""));
      encounter.addError(new IllegalStateException());
    }
  }
);
}","@Override protected void configure(){
  bindListener(any(),typeListener);
  bindListener(only(new TypeLiteral<D>(){
  }
),typeListener);
}",0.3237774030354131
60351,"public boolean containsElement(com.google.inject.spi.Element element){
  if (entrySetBinder.containsElement(element)) {
    return true;
  }
 else {
    Key<?> key;
    if (element instanceof Binding) {
      key=((Binding<?>)element).getKey();
    }
 else     if (element instanceof ProviderLookup) {
      key=((ProviderLookup<?>)element).getKey();
    }
 else {
      return false;
    }
    return key.equals(mapKey) || key.equals(providerMapKey) || key.equals(multimapKey)|| key.equals(providerMultimapKey)|| key.equals(entrySetBinder.getSetKey())|| matchesValueKey(key);
  }
}","public boolean containsElement(com.google.inject.spi.Element element){
  if (entrySetBinder.containsElement(element)) {
    return true;
  }
 else {
    Key<?> key;
    if (element instanceof Binding) {
      key=((Binding<?>)element).getKey();
    }
 else     if (element instanceof ProviderLookup) {
      key=((ProviderLookup<?>)element).getKey();
    }
 else {
      return false;
    }
    return key.equals(mapKey) || key.equals(providerMapKey) || key.equals(javaxProviderMapKey)|| key.equals(multimapKey)|| key.equals(providerMultimapKey)|| key.equals(entrySetBinder.getSetKey())|| matchesValueKey(key);
  }
}",0.9616026711185308
60352,"private RealMapBinder(Binder binder,TypeLiteral<K> keyType,TypeLiteral<V> valueType,Key<Map<K,V>> mapKey,Key<Map<K,Provider<V>>> providerMapKey,Key<Map<K,Set<V>>> multimapKey,Key<Map<K,Set<Provider<V>>>> providerMultimapKey,Multibinder<Map.Entry<K,Provider<V>>> entrySetBinder){
  this.keyType=keyType;
  this.valueType=valueType;
  this.mapKey=mapKey;
  this.providerMapKey=providerMapKey;
  this.multimapKey=multimapKey;
  this.providerMultimapKey=providerMultimapKey;
  this.entrySetBinder=(RealMultibinder<Entry<K,Provider<V>>>)entrySetBinder;
  this.binder=binder;
}","private RealMapBinder(Binder binder,TypeLiteral<K> keyType,TypeLiteral<V> valueType,Key<Map<K,V>> mapKey,Key<Map<K,Provider<V>>> providerMapKey,Key<Map<K,Set<V>>> multimapKey,Key<Map<K,Set<Provider<V>>>> providerMultimapKey,Multibinder<Map.Entry<K,Provider<V>>> entrySetBinder){
  this.keyType=keyType;
  this.valueType=valueType;
  this.mapKey=mapKey;
  this.providerMapKey=providerMapKey;
  this.javaxProviderMapKey=providerMapKey.ofType(mapOfJavaxProviderOf(keyType,valueType));
  this.multimapKey=multimapKey;
  this.providerMultimapKey=providerMultimapKey;
  this.entrySetBinder=(RealMultibinder<Entry<K,Provider<V>>>)entrySetBinder;
  this.binder=binder;
}",0.9261962692619627
60353,"public void testMapBinderAggregationForAnnotationInstance(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Names.named(""String_Node_Str""));
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Names.named(""String_Node_Str""));
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> key=Key.get(mapOfString,Names.named(""String_Node_Str""));
  Map<String,String> abc=injector.getInstance(key);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertMapVisitor(key,stringType,stringType,setOf(module),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
}","public void testMapBinderAggregationForAnnotationInstance(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Names.named(""String_Node_Str""));
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Names.named(""String_Node_Str""));
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> key=Key.get(mapOfString,Names.named(""String_Node_Str""));
  Map<String,String> abc=injector.getInstance(key);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertMapVisitor(key,stringType,stringType,setOf(module),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  injector.getInstance(Key.get(mapOfStringProvider,Names.named(""String_Node_Str"")));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,Names.named(""String_Node_Str"")));
}",0.9302510960542048
60354,"public void testMapBinderWithMultipleAnnotationValueSets(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> abcMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,named(""String_Node_Str""));
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      MapBinder<String,String> deMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,named(""String_Node_Str""));
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> abcKey=Key.get(mapOfString,named(""String_Node_Str""));
  Map<String,String> abc=injector.getInstance(abcKey);
  Key<Map<String,String>> deKey=Key.get(mapOfString,named(""String_Node_Str""));
  Map<String,String> de=injector.getInstance(deKey);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),de);
  assertMapVisitor(abcKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  assertMapVisitor(deKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
}","public void testMapBinderWithMultipleAnnotationValueSets(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> abcMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,named(""String_Node_Str""));
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      MapBinder<String,String> deMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,named(""String_Node_Str""));
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> abcKey=Key.get(mapOfString,named(""String_Node_Str""));
  Map<String,String> abc=injector.getInstance(abcKey);
  Key<Map<String,String>> deKey=Key.get(mapOfString,named(""String_Node_Str""));
  Map<String,String> de=injector.getInstance(deKey);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),de);
  assertMapVisitor(abcKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  assertMapVisitor(deKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  injector.getInstance(Key.get(mapOfStringProvider,named(""String_Node_Str"")));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,named(""String_Node_Str"")));
  injector.getInstance(Key.get(mapOfStringProvider,named(""String_Node_Str"")));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,named(""String_Node_Str"")));
}",0.9144805876180484
60355,"public void testMapBinderWithMultipleAnnotationTypeSets(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> abcMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      MapBinder<String,String> deMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,De.class);
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> abcKey=Key.get(mapOfString,Abc.class);
  Map<String,String> abc=injector.getInstance(abcKey);
  Key<Map<String,String>> deKey=Key.get(mapOfString,De.class);
  Map<String,String> de=injector.getInstance(deKey);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),de);
  assertMapVisitor(abcKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  assertMapVisitor(deKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
}","public void testMapBinderWithMultipleAnnotationTypeSets(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> abcMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      abcMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      MapBinder<String,String> deMapBinder=MapBinder.newMapBinder(binder(),String.class,String.class,De.class);
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      deMapBinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> abcKey=Key.get(mapOfString,Abc.class);
  Map<String,String> abc=injector.getInstance(abcKey);
  Key<Map<String,String>> deKey=Key.get(mapOfString,De.class);
  Map<String,String> de=injector.getInstance(deKey);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),de);
  assertMapVisitor(abcKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  assertMapVisitor(deKey,stringType,stringType,setOf(module),BOTH,false,1,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  injector.getInstance(Key.get(mapOfStringProvider,Abc.class));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,Abc.class));
  injector.getInstance(Key.get(mapOfStringProvider,De.class));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,De.class));
}",0.9271523178807948
60356,"public void testMapBinderAggregatesMultipleModules(){
  Module abc=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Module de=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(abc,de);
  Map<String,String> abcde=injector.getInstance(Key.get(mapOfString));
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abcde);
  assertMapVisitor(Key.get(mapOfString),stringType,stringType,setOf(abc,de),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
}","public void testMapBinderAggregatesMultipleModules(){
  Module abc=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Module de=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(abc,de);
  Map<String,String> abcde=injector.getInstance(Key.get(mapOfString));
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abcde);
  assertMapVisitor(Key.get(mapOfString),stringType,stringType,setOf(abc,de),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  injector.getInstance(Key.get(mapOfStringProvider));
  injector.getInstance(Key.get(mapOfStringJavaxProvider));
}",0.9633473889069089
60357,"public void testMapBinderAggregationForAnnotationType(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> key=Key.get(mapOfString,Abc.class);
  Map<String,String> abc=injector.getInstance(key);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertMapVisitor(key,stringType,stringType,setOf(module),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
}","public void testMapBinderAggregationForAnnotationType(){
  Module module=new AbstractModule(){
    @Override protected void configure(){
      MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
      multibinder=MapBinder.newMapBinder(binder(),String.class,String.class,Abc.class);
      multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
    }
  }
;
  Injector injector=Guice.createInjector(module);
  Key<Map<String,String>> key=Key.get(mapOfString,Abc.class);
  Map<String,String> abc=injector.getInstance(key);
  assertEquals(mapOf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),abc);
  assertMapVisitor(key,stringType,stringType,setOf(module),BOTH,false,0,instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""),instance(""String_Node_Str"",""String_Node_Str""));
  injector.getInstance(Key.get(mapOfStringProvider,Abc.class));
  injector.getInstance(Key.get(mapOfStringJavaxProvider,Abc.class));
}",0.9429918559794256
60358,"@SuppressWarnings(""String_Node_Str"") private static <T>void mapModuleTest(Key<T> mapKey,TypeLiteral<?> keyType,TypeLiteral<?> valueType,Iterable<? extends Module> modules,boolean allowDuplicates,int expectedMapBindings,MapResult... results){
  Set<Element> elements=ImmutableSet.copyOf(Elements.getElements(modules));
  Visitor<T> visitor=new Visitor<T>();
  MapBinderBinding<T> mapbinder=null;
  for (  Element element : elements) {
    if (element instanceof Binding && ((Binding)element).getKey().equals(mapKey)) {
      mapbinder=(MapBinderBinding<T>)((Binding)element).acceptTargetVisitor(visitor);
      break;
    }
  }
  assertNotNull(mapbinder);
  assertEquals(keyType,mapbinder.getKeyTypeLiteral());
  assertEquals(valueType,mapbinder.getValueTypeLiteral());
  List<MapResult> mapResults=Lists.newArrayList(results);
  Key<?> mapOfProvider=adapt(mapKey,mapOfProviderOf(keyType,valueType));
  Key<?> mapOfSetOfProvider=adapt(mapKey,mapOfSetOfProviderOf(keyType,valueType));
  Key<?> mapOfSet=adapt(mapKey,mapOf(keyType,setOf(valueType)));
  Key<?> setOfEntry=adapt(mapKey,setOf(entryOfProviderOf(keyType,valueType)));
  boolean entrySetMatch=false;
  boolean mapProviderMatch=false;
  boolean mapSetMatch=false;
  boolean mapSetProviderMatch=false;
  List<Object> otherMapBindings=Lists.newArrayList();
  List<Element> otherMatches=Lists.newArrayList();
  List<Element> otherElements=Lists.newArrayList();
  for (  Element element : elements) {
    boolean contains=mapbinder.containsElement(element);
    if (!contains) {
      otherElements.add(element);
    }
    boolean matched=false;
    Key key=null;
    Binding b=null;
    if (element instanceof Binding) {
      b=(Binding)element;
      key=b.getKey();
      Object visited=b.acceptTargetVisitor(visitor);
      if (visited instanceof MapBinderBinding) {
        matched=true;
        if (visited.equals(mapbinder)) {
          assertTrue(contains);
        }
 else {
          otherMapBindings.add(visited);
        }
      }
    }
 else     if (element instanceof ProviderLookup) {
      key=((ProviderLookup)element).getKey();
    }
    if (!matched && key != null) {
      if (key.equals(mapOfProvider)) {
        matched=true;
        assertTrue(contains);
        mapProviderMatch=true;
      }
 else       if (key.equals(mapOfSet)) {
        matched=true;
        assertTrue(contains);
        mapSetMatch=true;
      }
 else       if (key.equals(mapOfSetOfProvider)) {
        matched=true;
        assertTrue(contains);
        mapSetProviderMatch=true;
      }
 else       if (key.equals(setOfEntry)) {
        matched=true;
        assertTrue(contains);
        entrySetMatch=true;
        if (b != null) {
          assertTrue(b.acceptTargetVisitor(visitor) instanceof MultibinderBinding);
        }
      }
    }
    if (!matched && contains) {
      otherMatches.add(element);
    }
  }
  int otherMatchesSize=otherMatches.size();
  if (allowDuplicates) {
    otherMatchesSize--;
  }
  otherMatchesSize=otherMatchesSize / 3;
  assertEquals(""String_Node_Str"" + otherMatches,mapResults.size(),otherMatchesSize);
  assertTrue(entrySetMatch);
  assertTrue(mapProviderMatch);
  assertEquals(allowDuplicates,mapSetMatch);
  assertEquals(allowDuplicates,mapSetProviderMatch);
  assertEquals(""String_Node_Str"" + otherMapBindings,expectedMapBindings,otherMapBindings.size());
  Guice.createInjector(Elements.getModule(otherElements));
}","@SuppressWarnings(""String_Node_Str"") private static <T>void mapModuleTest(Key<T> mapKey,TypeLiteral<?> keyType,TypeLiteral<?> valueType,Iterable<? extends Module> modules,boolean allowDuplicates,int expectedMapBindings,MapResult... results){
  Set<Element> elements=ImmutableSet.copyOf(Elements.getElements(modules));
  Visitor<T> visitor=new Visitor<T>();
  MapBinderBinding<T> mapbinder=null;
  for (  Element element : elements) {
    if (element instanceof Binding && ((Binding)element).getKey().equals(mapKey)) {
      mapbinder=(MapBinderBinding<T>)((Binding)element).acceptTargetVisitor(visitor);
      break;
    }
  }
  assertNotNull(mapbinder);
  assertEquals(keyType,mapbinder.getKeyTypeLiteral());
  assertEquals(valueType,mapbinder.getValueTypeLiteral());
  List<MapResult> mapResults=Lists.newArrayList(results);
  Key<?> mapOfProvider=mapKey.ofType(mapOfProviderOf(keyType,valueType));
  Key<?> mapOfSetOfProvider=mapKey.ofType(mapOfSetOfProviderOf(keyType,valueType));
  Key<?> mapOfSet=mapKey.ofType(mapOf(keyType,setOf(valueType)));
  Key<?> setOfEntry=mapKey.ofType(setOf(entryOfProviderOf(keyType,valueType)));
  boolean entrySetMatch=false;
  boolean mapProviderMatch=false;
  boolean mapSetMatch=false;
  boolean mapSetProviderMatch=false;
  List<Object> otherMapBindings=Lists.newArrayList();
  List<Element> otherMatches=Lists.newArrayList();
  List<Element> otherElements=Lists.newArrayList();
  for (  Element element : elements) {
    boolean contains=mapbinder.containsElement(element);
    if (!contains) {
      otherElements.add(element);
    }
    boolean matched=false;
    Key key=null;
    Binding b=null;
    if (element instanceof Binding) {
      b=(Binding)element;
      key=b.getKey();
      Object visited=b.acceptTargetVisitor(visitor);
      if (visited instanceof MapBinderBinding) {
        matched=true;
        if (visited.equals(mapbinder)) {
          assertTrue(contains);
        }
 else {
          otherMapBindings.add(visited);
        }
      }
    }
 else     if (element instanceof ProviderLookup) {
      key=((ProviderLookup)element).getKey();
    }
    if (!matched && key != null) {
      if (key.equals(mapOfProvider)) {
        matched=true;
        assertTrue(contains);
        mapProviderMatch=true;
      }
 else       if (key.equals(mapOfSet)) {
        matched=true;
        assertTrue(contains);
        mapSetMatch=true;
      }
 else       if (key.equals(mapOfSetOfProvider)) {
        matched=true;
        assertTrue(contains);
        mapSetProviderMatch=true;
      }
 else       if (key.equals(setOfEntry)) {
        matched=true;
        assertTrue(contains);
        entrySetMatch=true;
        if (b != null) {
          assertTrue(b.acceptTargetVisitor(visitor) instanceof MultibinderBinding);
        }
      }
    }
    if (!matched && contains) {
      otherMatches.add(element);
    }
  }
  int otherMatchesSize=otherMatches.size();
  if (allowDuplicates) {
    otherMatchesSize--;
  }
  otherMatchesSize=otherMatchesSize / 3;
  assertEquals(""String_Node_Str"" + otherMatches,mapResults.size(),otherMatchesSize);
  assertTrue(entrySetMatch);
  assertTrue(mapProviderMatch);
  assertEquals(allowDuplicates,mapSetMatch);
  assertEquals(allowDuplicates,mapSetProviderMatch);
  assertEquals(""String_Node_Str"" + otherMapBindings,expectedMapBindings,otherMapBindings.size());
  Guice.createInjector(Elements.getModule(otherElements));
}",0.991210079109288
60359,"@SuppressWarnings(""String_Node_Str"") private static <T>void mapInjectorTest(Key<T> mapKey,TypeLiteral<?> keyType,TypeLiteral<?> valueType,Iterable<? extends Module> modules,boolean allowDuplicates,int expectedMapBindings,MapResult... results){
  Injector injector=Guice.createInjector(modules);
  Visitor<T> visitor=new Visitor<T>();
  Binding<T> mapBinding=injector.getBinding(mapKey);
  MapBinderBinding<T> mapbinder=(MapBinderBinding<T>)mapBinding.acceptTargetVisitor(visitor);
  assertNotNull(mapbinder);
  assertEquals(keyType,mapbinder.getKeyTypeLiteral());
  assertEquals(valueType,mapbinder.getValueTypeLiteral());
  assertEquals(allowDuplicates,mapbinder.permitsDuplicates());
  List<Map.Entry<?,Binding<?>>> entries=Lists.newArrayList(mapbinder.getEntries());
  List<MapResult> mapResults=Lists.newArrayList(results);
  assertEquals(""String_Node_Str"" + mapResults + ""String_Node_Str""+ entries,mapResults.size(),entries.size());
  for (  MapResult result : mapResults) {
    Map.Entry<?,Binding<?>> found=null;
    for (    Map.Entry<?,Binding<?>> entry : entries) {
      Object key=entry.getKey();
      Binding<?> value=entry.getValue();
      if (!key.equals(result.k)) {
        continue;
      }
switch (result.v.type) {
case INSTANCE:
        if (value instanceof InstanceBinding && ((InstanceBinding)value).getInstance().equals(result.v.instance)) {
          found=entry;
        }
      break;
case LINKED:
    if (value instanceof LinkedKeyBinding && ((LinkedKeyBinding)value).getKey().equals(result.v.key)) {
      found=entry;
    }
  break;
case PROVIDER_INSTANCE:
if (value instanceof ProviderInstanceBinding && ((ProviderInstanceBinding)value).getProviderInstance().get().equals(result.v.instance)) {
  found=entry;
}
break;
}
}
if (found == null) {
fail(""String_Node_Str"" + result + ""String_Node_Str""+ entries);
}
 else {
assertTrue(mapbinder.containsElement(found.getValue()));
entries.remove(found);
}
}
if (!entries.isEmpty()) {
fail(""String_Node_Str"" + mapResults + ""String_Node_Str""+ entries);
}
Key<?> mapOfProvider=adapt(mapKey,mapOfProviderOf(keyType,valueType));
Key<?> mapOfSetOfProvider=adapt(mapKey,mapOfSetOfProviderOf(keyType,valueType));
Key<?> mapOfSet=adapt(mapKey,mapOf(keyType,setOf(valueType)));
Key<?> setOfEntry=adapt(mapKey,setOf(entryOfProviderOf(keyType,valueType)));
boolean entrySetMatch=false;
boolean mapProviderMatch=false;
boolean mapSetMatch=false;
boolean mapSetProviderMatch=false;
List<Object> otherMapBindings=Lists.newArrayList();
List<Binding> otherMatches=Lists.newArrayList();
for (Binding b : injector.getAllBindings().values()) {
boolean contains=mapbinder.containsElement(b);
Object visited=b.acceptTargetVisitor(visitor);
if (visited instanceof MapBinderBinding) {
if (visited.equals(mapbinder)) {
assertTrue(contains);
}
 else {
otherMapBindings.add(visited);
}
}
 else if (b.getKey().equals(mapOfProvider)) {
assertTrue(contains);
mapProviderMatch=true;
}
 else if (b.getKey().equals(mapOfSet)) {
assertTrue(contains);
mapSetMatch=true;
}
 else if (b.getKey().equals(mapOfSetOfProvider)) {
assertTrue(contains);
mapSetProviderMatch=true;
}
 else if (b.getKey().equals(setOfEntry)) {
assertTrue(contains);
entrySetMatch=true;
assertTrue(b.acceptTargetVisitor(visitor) instanceof MultibinderBinding);
}
 else if (contains) {
otherMatches.add(b);
}
}
int sizeOfOther=otherMatches.size();
if (allowDuplicates) {
sizeOfOther--;
}
sizeOfOther=sizeOfOther / 2;
assertEquals(""String_Node_Str"" + otherMatches,mapResults.size(),sizeOfOther);
assertTrue(entrySetMatch);
assertTrue(mapProviderMatch);
assertEquals(allowDuplicates,mapSetMatch);
assertEquals(allowDuplicates,mapSetProviderMatch);
assertEquals(""String_Node_Str"" + otherMapBindings,expectedMapBindings,otherMapBindings.size());
}","@SuppressWarnings(""String_Node_Str"") private static <T>void mapInjectorTest(Key<T> mapKey,TypeLiteral<?> keyType,TypeLiteral<?> valueType,Iterable<? extends Module> modules,boolean allowDuplicates,int expectedMapBindings,MapResult... results){
  Injector injector=Guice.createInjector(modules);
  Visitor<T> visitor=new Visitor<T>();
  Binding<T> mapBinding=injector.getBinding(mapKey);
  MapBinderBinding<T> mapbinder=(MapBinderBinding<T>)mapBinding.acceptTargetVisitor(visitor);
  assertNotNull(mapbinder);
  assertEquals(keyType,mapbinder.getKeyTypeLiteral());
  assertEquals(valueType,mapbinder.getValueTypeLiteral());
  assertEquals(allowDuplicates,mapbinder.permitsDuplicates());
  List<Map.Entry<?,Binding<?>>> entries=Lists.newArrayList(mapbinder.getEntries());
  List<MapResult> mapResults=Lists.newArrayList(results);
  assertEquals(""String_Node_Str"" + mapResults + ""String_Node_Str""+ entries,mapResults.size(),entries.size());
  for (  MapResult result : mapResults) {
    Map.Entry<?,Binding<?>> found=null;
    for (    Map.Entry<?,Binding<?>> entry : entries) {
      Object key=entry.getKey();
      Binding<?> value=entry.getValue();
      if (!key.equals(result.k)) {
        continue;
      }
switch (result.v.type) {
case INSTANCE:
        if (value instanceof InstanceBinding && ((InstanceBinding)value).getInstance().equals(result.v.instance)) {
          found=entry;
        }
      break;
case LINKED:
    if (value instanceof LinkedKeyBinding && ((LinkedKeyBinding)value).getKey().equals(result.v.key)) {
      found=entry;
    }
  break;
case PROVIDER_INSTANCE:
if (value instanceof ProviderInstanceBinding && ((ProviderInstanceBinding)value).getProviderInstance().get().equals(result.v.instance)) {
  found=entry;
}
break;
}
}
if (found == null) {
fail(""String_Node_Str"" + result + ""String_Node_Str""+ entries);
}
 else {
assertTrue(mapbinder.containsElement(found.getValue()));
entries.remove(found);
}
}
if (!entries.isEmpty()) {
fail(""String_Node_Str"" + mapResults + ""String_Node_Str""+ entries);
}
Key<?> mapOfJavaxProvider=mapKey.ofType(mapOfJavaxProviderOf(keyType,valueType));
Key<?> mapOfProvider=mapKey.ofType(mapOfProviderOf(keyType,valueType));
Key<?> mapOfSetOfProvider=mapKey.ofType(mapOfSetOfProviderOf(keyType,valueType));
Key<?> mapOfSet=mapKey.ofType(mapOf(keyType,setOf(valueType)));
Key<?> setOfEntry=mapKey.ofType(setOf(entryOfProviderOf(keyType,valueType)));
boolean entrySetMatch=false;
boolean mapJavaxProviderMatch=false;
boolean mapProviderMatch=false;
boolean mapSetMatch=false;
boolean mapSetProviderMatch=false;
List<Object> otherMapBindings=Lists.newArrayList();
List<Binding> otherMatches=Lists.newArrayList();
for (Binding b : injector.getAllBindings().values()) {
boolean contains=mapbinder.containsElement(b);
Object visited=b.acceptTargetVisitor(visitor);
if (visited instanceof MapBinderBinding) {
if (visited.equals(mapbinder)) {
assertTrue(contains);
}
 else {
otherMapBindings.add(visited);
}
}
 else if (b.getKey().equals(mapOfProvider)) {
assertTrue(contains);
mapProviderMatch=true;
}
 else if (b.getKey().equals(mapOfJavaxProvider)) {
assertTrue(contains);
mapJavaxProviderMatch=true;
}
 else if (b.getKey().equals(mapOfSet)) {
assertTrue(contains);
mapSetMatch=true;
}
 else if (b.getKey().equals(mapOfSetOfProvider)) {
assertTrue(contains);
mapSetProviderMatch=true;
}
 else if (b.getKey().equals(setOfEntry)) {
assertTrue(contains);
entrySetMatch=true;
assertTrue(b.acceptTargetVisitor(visitor) instanceof MultibinderBinding);
}
 else if (contains) {
otherMatches.add(b);
}
}
int sizeOfOther=otherMatches.size();
if (allowDuplicates) {
sizeOfOther--;
}
sizeOfOther=sizeOfOther / 2;
assertEquals(""String_Node_Str"" + otherMatches,mapResults.size(),sizeOfOther);
assertTrue(entrySetMatch);
assertTrue(mapProviderMatch);
assertTrue(mapJavaxProviderMatch);
assertEquals(allowDuplicates,mapSetMatch);
assertEquals(allowDuplicates,mapSetProviderMatch);
assertEquals(""String_Node_Str"" + otherMapBindings,expectedMapBindings,otherMapBindings.size());
}",0.9244043786220218
60360,"/** 
 * @see Binder#bindListener(com.google.inject.matcher.Matcher,com.google.inject.spi.TypeListener)
 */
protected void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher,TypeListener listener){
  binder().bindListener(typeMatcher,listener);
}","/** 
 * @see Binder#bindListener(Matcher,ProvisionListener)
 */
protected void bindListener(Matcher<? super Binding<?>> bindingMatcher,ProvisionListener... listeners){
  binder().bindListener(bindingMatcher,listeners);
}",0.7133757961783439
60361,"@Override protected void newImplementationNode(ImplementationNode node){
  NodeId nodeId=node.getId();
  GraphvizNode gnode=new GraphvizNode(nodeId);
  gnode.setStyle(NodeStyle.INVISIBLE);
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getClassName(nodeId.getKey()));
  for (  Member member : node.getMembers()) {
    gnode.addField(portIdFactory.getPortId(member),nameFactory.getMemberName(member));
  }
  addNode(gnode);
}","@Override protected void newImplementationNode(ImplementationNode node){
  NodeId nodeId=node.getId();
  GraphvizNode gnode=new GraphvizNode(nodeId);
  gnode.setStyle(NodeStyle.SOLID);
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getClassName(nodeId.getKey()));
  for (  Member member : node.getMembers()) {
    gnode.addField(portIdFactory.getPortId(member),nameFactory.getMemberName(member));
  }
  addNode(gnode);
}",0.988095238095238
60362,"@Override protected void newInstanceNode(InstanceNode node){
  NodeId nodeId=node.getId();
  GraphvizNode gnode=new GraphvizNode(nodeId);
  gnode.setStyle(NodeStyle.INVISIBLE);
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getClassName(nodeId.getKey()));
  gnode.addSubtitle(0,nameFactory.getSourceName(node.getSource()));
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getInstanceName(node.getInstance()));
  for (  Member member : node.getMembers()) {
    gnode.addField(portIdFactory.getPortId(member),nameFactory.getMemberName(member));
  }
  addNode(gnode);
}","@Override protected void newInstanceNode(InstanceNode node){
  NodeId nodeId=node.getId();
  GraphvizNode gnode=new GraphvizNode(nodeId);
  gnode.setStyle(NodeStyle.SOLID);
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getClassName(nodeId.getKey()));
  gnode.addSubtitle(0,nameFactory.getSourceName(node.getSource()));
  gnode.setHeaderBackgroundColor(""String_Node_Str"");
  gnode.setHeaderTextColor(""String_Node_Str"");
  gnode.setTitle(nameFactory.getInstanceName(node.getInstance()));
  for (  Member member : node.getMembers()) {
    gnode.addField(portIdFactory.getPortId(member),nameFactory.getMemberName(member));
  }
  addNode(gnode);
}",0.9917469050894084
60363,"IndicesCallbackFilter(Class<?> declaringClass,List<Method> methods){
  this.declaringClass=declaringClass;
  final Map<Method,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    Method method=methods.get(i);
    indices.put(method,i);
  }
  this.indices=indices;
}","IndicesCallbackFilter(List<Method> methods){
  final Map<Object,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    indices.put(MethodWrapper.create(methods.get(i)),i);
  }
  this.indices=indices;
  this.hashCode=indices.hashCode();
}",0.5642857142857143
60364,"public int accept(Method method){
  return indices.get(method);
}","public int accept(Method method){
  return indices.get(MethodWrapper.create(method));
}",0.8552631578947368
60365,"@Override public int hashCode(){
  return declaringClass.hashCode();
}","@Override public int hashCode(){
  return hashCode;
}",0.8617886178861789
60366,"@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).declaringClass == declaringClass;
}","@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).indices.equals(indices);
}",0.8610169491525423
60367,"public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(declaringClass,methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}","public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}",0.9919484702093396
60368,"public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
}","public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
  Injector injector2=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Interceptable separateNullFoos=injector2.getInstance(Interceptable.class);
  assertNull(separateNullFoos.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),separateNullFoos.getClass());
}",0.8095016301816488
60369,"IndicesCallbackFilter(Class<?> declaringClass,List<Method> methods){
  this.declaringClass=declaringClass;
  final Map<Method,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    Method method=methods.get(i);
    indices.put(method,i);
  }
  this.indices=indices;
}","IndicesCallbackFilter(List<Method> methods){
  final Map<Object,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    indices.put(MethodWrapper.create(methods.get(i)),i);
  }
  this.indices=indices;
  this.hashCode=indices.hashCode();
}",0.5642857142857143
60370,"public int accept(Method method){
  return indices.get(method);
}","public int accept(Method method){
  return indices.get(MethodWrapper.create(method));
}",0.8552631578947368
60371,"@Override public int hashCode(){
  return declaringClass.hashCode();
}","@Override public int hashCode(){
  return hashCode;
}",0.8617886178861789
60372,"@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).declaringClass == declaringClass;
}","@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).indices.equals(indices);
}",0.8610169491525423
60373,"public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(declaringClass,methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}","public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}",0.9919484702093396
60374,"public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
}","public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
  Injector injector2=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Interceptable separateNullFoos=injector2.getInstance(Interceptable.class);
  assertNull(separateNullFoos.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),separateNullFoos.getClass());
}",0.8095016301816488
60375,"IndicesCallbackFilter(List<Method> methods){
  final Map<Object,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    indices.put(MethodWrapper.create(methods.get(i)),i);
  }
  this.indices=indices;
  this.hashCode=indices.hashCode();
}","IndicesCallbackFilter(Class<?> declaringClass,List<Method> methods){
  this.declaringClass=declaringClass;
  final Map<Method,Integer> indices=Maps.newHashMap();
  for (int i=0; i < methods.size(); i++) {
    Method method=methods.get(i);
    indices.put(method,i);
  }
  this.indices=indices;
}",0.6678571428571428
60376,"public int accept(Method method){
  return indices.get(MethodWrapper.create(method));
}","public int accept(Method method){
  return indices.get(method);
}",0.8552631578947368
60377,"@Override public int hashCode(){
  return hashCode;
}","@Override public int hashCode(){
  return declaringClass.hashCode();
}",0.8617886178861789
60378,"@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).indices.equals(indices);
}","@Override public boolean equals(Object o){
  return o instanceof IndicesCallbackFilter && ((IndicesCallbackFilter)o).declaringClass == declaringClass;
}",0.8677966101694915
60379,"public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}","public ConstructionProxy<T> create() throws ErrorsException {
  if (interceptors.isEmpty()) {
    return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends Callback>[] callbackTypes=new Class[callbacks.length];
  for (int i=0; i < callbacks.length; i++) {
    if (callbacks[i] == net.sf.cglib.proxy.NoOp.INSTANCE) {
      callbackTypes[i]=net.sf.cglib.proxy.NoOp.class;
    }
 else {
      callbackTypes[i]=net.sf.cglib.proxy.MethodInterceptor.class;
    }
  }
  try {
    Enhancer enhancer=BytecodeGen.newEnhancer(declaringClass,visibility);
    enhancer.setCallbackFilter(new IndicesCallbackFilter(declaringClass,methods));
    enhancer.setCallbackTypes(callbackTypes);
    return new ProxyConstructor<T>(enhancer,injectionPoint,callbacks,interceptors);
  }
 catch (  Throwable e) {
    throw new Errors().errorEnhancingClass(declaringClass,e).toException();
  }
}",0.9919484702093396
60380,"public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
  Injector injector2=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Interceptable separateNullFoos=injector2.getInstance(Interceptable.class);
  assertNull(separateNullFoos.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),separateNullFoos.getClass());
}","public void testSharedProxyClasses(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindInterceptor(Matchers.any(),Matchers.returns(only(Foo.class)),new ReturnNullInterceptor());
    }
  }
);
  Injector childOne=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosOne=childOne.getInstance(Interceptable.class);
  assertNotNull(nullFoosOne.bar());
  assertNull(nullFoosOne.foo());
  Injector childTwo=injector.createChildInjector(new AbstractModule(){
    protected void configure(){
      bind(Interceptable.class);
    }
  }
);
  Interceptable nullFoosTwo=childTwo.getInstance(Interceptable.class);
  assertNull(nullFoosTwo.foo());
  assertSame(""String_Node_Str"",nullFoosOne.getClass(),nullFoosTwo.getClass());
}",0.8095016301816488
60381,"void validate(){
  Errors errorsForMember=errors.withSource(source);
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=request.getInjectionPoints();
  }
 catch (  ConfigurationException e) {
    errors.merge(e.getErrorMessages());
    injectionPoints=e.getPartialValue();
  }
  memberInjectors=injector.membersInjectorStore.getInjectors(injectionPoints,errorsForMember);
}","void validate(){
  Errors errorsForMember=errors.withSource(source);
  Set<InjectionPoint> injectionPoints;
  try {
    injectionPoints=request.getInjectionPoints();
  }
 catch (  ConfigurationException e) {
    errorsForMember.merge(e.getErrorMessages());
    injectionPoints=e.getPartialValue();
  }
  if (injectionPoints != null) {
    memberInjectors=injector.membersInjectorStore.getInjectors(injectionPoints,errorsForMember);
  }
 else {
    memberInjectors=ImmutableList.of();
  }
  errors.merge(errorsForMember);
}",0.8210757409440176
60382,"@Override protected void configure(){
  Multibinder.newSetBinder(binder(),String.class).addBinding().toInstance(""String_Node_Str"");
  MapBinder.newMapBinder(binder(),String.class,String.class).addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
}","@Override public void configure(){
  Multibinder<Integer> mb1=Multibinder.newSetBinder(binder(),Integer.class,Marker.class);
  Multibinder<Integer> mb2=Multibinder.newSetBinder(binder(),Integer.class,marker);
  mb1.addBinding().toInstance(1);
  mb2.addBinding().toInstance(2);
  assertEquals(mb1,mb2);
}",0.3333333333333333
60383,"/** 
 * Returns the key for the source binding. That binding can e retrieved from an injector using  {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
Key<String> getSourceKey();","/** 
 * Returns the key for the source binding. That binding can be retrieved from an injector using  {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
Key<String> getSourceKey();",0.9976133651551312
60384,"@Inject static void setPipeline(FilterPipeline pipeline){
  if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
    Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);
  }
  GuiceFilter.pipeline=pipeline;
}","@Inject static void setPipeline(FilterPipeline pipeline){
  if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
    LOGGER.warning(MULTIPLE_INJECTORS_WARNING);
  }
  GuiceFilter.pipeline=pipeline;
}",0.891832229580574
60385,"/** 
 * This creates two bindings. One for the   {@code Map.Entry<K, Provider<V>>}and another for   {@code V}.
 */
@Override public LinkedBindingBuilder<V> addBinding(K key){
  checkNotNull(key,""String_Node_Str"");
  checkConfiguration(!isInitialized(),""String_Node_Str"");
  Key<V> valueKey=Key.get(valueType,new RealElement(entrySetBinder.getSetName()));
  entrySetBinder.addBinding().toInstance(new MapEntry<K,Provider<V>>(key,binder.getProvider(valueKey),valueKey));
  return binder.bind(valueKey);
}","/** 
 * This creates two bindings. One for the   {@code Map.Entry<K, Provider<V>>}and another for   {@code V}.
 */
@Override public LinkedBindingBuilder<V> addBinding(K key){
  checkNotNull(key,""String_Node_Str"");
  checkConfiguration(!isInitialized(),""String_Node_Str"");
  Key<V> valueKey=Key.get(valueType,new RealElement(entrySetBinder.getSetName(),MAPBINDER));
  entrySetBinder.addBinding().toInstance(new MapEntry<K,Provider<V>>(key,binder.getProvider(valueKey),valueKey));
  return binder.bind(valueKey);
}",0.990138067061144
60386,"/** 
 * Returns true if the key indicates this is a value in the map. 
 */
private boolean matchesValueKey(Key key){
  return key.getAnnotation() instanceof Element && ((Element)key.getAnnotation()).setName().equals(entrySetBinder.getSetName()) && key.getTypeLiteral().equals(valueType);
}","/** 
 * Returns true if the key indicates this is a value in the map. 
 */
private boolean matchesValueKey(Key key){
  return key.getAnnotation() instanceof Element && ((Element)key.getAnnotation()).setName().equals(entrySetBinder.getSetName()) && ((Element)key.getAnnotation()).type() == MAPBINDER && key.getTypeLiteral().equals(valueType);
}",0.9145569620253164
60387,"private boolean keyMatches(Key<?> key){
  return key.getTypeLiteral().equals(elementType) && key.getAnnotation() instanceof Element && ((Element)key.getAnnotation()).setName().equals(setName);
}","private boolean keyMatches(Key<?> key){
  return key.getTypeLiteral().equals(elementType) && key.getAnnotation() instanceof Element && ((Element)key.getAnnotation()).setName().equals(setName)&& ((Element)key.getAnnotation()).type() == MULTIBINDER;
}",0.8758465011286681
60388,"@Override public LinkedBindingBuilder<T> addBinding(){
  checkConfiguration(!isInitialized(),""String_Node_Str"");
  return binder.bind(Key.get(elementType,new RealElement(setName)));
}","@Override public LinkedBindingBuilder<T> addBinding(){
  checkConfiguration(!isInitialized(),""String_Node_Str"");
  return binder.bind(Key.get(elementType,new RealElement(setName,MULTIBINDER)));
}",0.9682539682539684
60389,"@Override public int hashCode(){
  return 127 * (""String_Node_Str"".hashCode() ^ setName.hashCode()) + 127 * (""String_Node_Str"".hashCode() ^ uniqueId);
}","@Override public int hashCode(){
  return 127 * (""String_Node_Str"".hashCode() ^ setName.hashCode()) + 127 * (""String_Node_Str"".hashCode() ^ uniqueId) + 127 * (""String_Node_Str"".hashCode() ^ type.hashCode());
}",0.8421052631578947
60390,"@Override public boolean equals(Object o){
  return o instanceof Element && ((Element)o).setName().equals(setName()) && ((Element)o).uniqueId() == uniqueId();
}","@Override public boolean equals(Object o){
  return o instanceof Element && ((Element)o).setName().equals(setName()) && ((Element)o).uniqueId() == uniqueId() && ((Element)o).type() == type();
}",0.906515580736544
60391,"@Override public String toString(){
  return ""String_Node_Str"" + Element.class.getName() + ""String_Node_Str""+ setName+ ""String_Node_Str""+ uniqueId+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + Element.class.getName() + ""String_Node_Str""+ setName+ ""String_Node_Str""+ uniqueId+ ""String_Node_Str""+ type+ ""String_Node_Str"";
}",0.9307479224376732
60392,"RealElement(String setName){
  uniqueId=nextUniqueId.getAndIncrement();
  this.setName=setName;
}","RealElement(String setName,Type type){
  uniqueId=nextUniqueId.getAndIncrement();
  this.setName=setName;
  this.type=type;
}",0.8738738738738738
60393,"@Inject static void setPipeline(FilterPipeline pipeline){
  if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
    Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);
  }
  GuiceFilter.pipeline=pipeline;
}","@Inject static void setPipeline(FilterPipeline pipeline){
  if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
    LOGGER.warning(MULTIPLE_INJECTORS_WARNING);
  }
  GuiceFilter.pipeline=pipeline;
}",0.891832229580574
60394,"/** 
 * Reentrant. If   {@code instance} was registered for injection at injector-creation time, thismethod will ensure that all its members have been injected before returning.
 */
public T get(Errors errors) throws ErrorsException {
  if (ready.getCount() == 0) {
    return instance;
  }
  if (Thread.currentThread() != creatingThread) {
    try {
      ready.await();
      return instance;
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  if (pendingInjection.remove(instance) != null) {
    membersInjector.injectAndNotify(instance,errors.withSource(source),key,source,injector.options.stage == Stage.TOOL);
  }
  return instance;
}","/** 
 * Reentrant. If   {@code instance} was registered for injection at injector-creation time, thismethod will ensure that all its members have been injected before returning.
 */
public T get(Errors errors) throws ErrorsException {
  if (ready.getCount() == 0) {
    return instance;
  }
  if (Thread.currentThread() != creatingThread) {
    try {
      ready.await();
      return instance;
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  if (pendingInjection.remove(instance) != null) {
    @SuppressWarnings(""String_Node_Str"") MembersInjectorImpl<T> membersInjector=(MembersInjectorImpl<T>)pendingMembersInjectors.remove(instance);
    Preconditions.checkState(membersInjector != null,""String_Node_Str"" + instance + ""String_Node_Str""+ key);
    membersInjector.injectAndNotify(instance,errors.withSource(source),key,source,injector.options.stage == Stage.TOOL);
  }
  return instance;
}",0.8424953675108091
60395,"/** 
 * Prepares member injectors for all injected instances. This prompts Guice to do static analysis on the injected instances.
 */
void validateOustandingInjections(Errors errors){
  for (  InjectableReference<?> reference : pendingInjection.values()) {
    try {
      reference.validate(errors);
    }
 catch (    ErrorsException e) {
      errors.merge(e.getErrors());
    }
  }
}","/** 
 * Prepares member injectors for all injected instances. This prompts Guice to do static analysis on the injected instances.
 */
void validateOustandingInjections(Errors errors){
  for (  InjectableReference<?> reference : pendingInjection.values()) {
    try {
      pendingMembersInjectors.put(reference.instance,reference.validate(errors));
    }
 catch (    ErrorsException e) {
      errors.merge(e.getErrors());
    }
  }
}",0.9414634146341464
60396,"public void validate(Errors errors) throws ErrorsException {
  @SuppressWarnings(""String_Node_Str"") TypeLiteral<T> type=TypeLiteral.get((Class<T>)instance.getClass());
  membersInjector=injector.membersInjectorStore.get(type,errors.withSource(source));
}","public MembersInjectorImpl<T> validate(Errors errors) throws ErrorsException {
  @SuppressWarnings(""String_Node_Str"") TypeLiteral<T> type=TypeLiteral.get((Class<T>)instance.getClass());
  return injector.membersInjectorStore.get(type,errors.withSource(source));
}",0.9052224371373307
60397,"public void testValidationErrorOnInjectedMembers(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        requestInjection(new NeedsRunnable());
      }
    }
);
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName(),""String_Node_Str"");
  }
}","public void testValidationErrorOnInjectedMembers(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        requestInjection(new NeedsRunnable());
      }
    }
);
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName(),""String_Node_Str"");
  }
}",0.9871134020618556
60398,"public void testUserExceptionWhileInjectingStatically(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        requestStaticInjection(BlowsUpOnInject.class);
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BlowsUpOnInject.class.getName() + ""String_Node_Str"");
  }
}","public void testUserExceptionWhileInjectingStatically(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        requestStaticInjection(BlowsUpOnInject.class);
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BlowsUpOnInject.class.getName() + ""String_Node_Str"");
  }
}",0.988009592326139
60399,"public void testUserExceptionWhileInjectingInstance(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        requestInjection(new BlowsUpOnInject());
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BlowsUpOnInject.class.getName() + ""String_Node_Str"");
  }
}","public void testUserExceptionWhileInjectingInstance(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        requestInjection(new BlowsUpOnInject());
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BlowsUpOnInject.class.getName() + ""String_Node_Str"");
  }
}",0.9877750611246944
60400,"protected void configure(){
  requestStaticInjection(BlowsUpOnInject.class);
}","@Override protected void configure(){
  bindListener(Matchers.any(),new TypeListener(){
    @Override public <I>void hear(    TypeLiteral<I> type,    TypeEncounter<I> encounter){
    }
  }
);
  String fail=new String(""String_Node_Str"");
  bind(Object.class).toInstance(fail);
  bind(String.class).toInstance(fail);
  requestInjection(new Object(){
    @SuppressWarnings(""String_Node_Str"") @Inject Object obj;
    @SuppressWarnings(""String_Node_Str"") @Inject String str;
  }
);
}",0.1079136690647482
60401,"public void testInjectMembers(){
  final HasInjections hi=new HasInjections();
  Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestInjection(hi);
    }
  }
);
  assertEquals(""String_Node_Str"",hi.instanceMethod);
  assertEquals(5,hi.instanceField);
  assertNull(HasInjections.staticMethod);
  assertEquals(0,HasInjections.staticField);
}","public void testInjectMembers(){
  final HasInjections hi=new HasInjections();
  Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestInjection(hi);
    }
  }
);
  assertEquals(""String_Node_Str"",hi.instanceMethod);
  assertEquals(5,hi.instanceField);
  assertNull(HasInjections.staticMethod);
  assertEquals(0,HasInjections.staticField);
}",0.990234375
60402,"public void testInjectStatics() throws CreationException {
  Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestStaticInjection(HasInjections.class);
    }
  }
);
  assertEquals(""String_Node_Str"",HasInjections.staticMethod);
  assertEquals(5,HasInjections.staticField);
}","public void testInjectStatics() throws CreationException {
  Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestStaticInjection(HasInjections.class);
    }
  }
);
  assertEquals(""String_Node_Str"",HasInjections.staticMethod);
  assertEquals(5,HasInjections.staticField);
}",0.9887892376681614
60403,"public void testInjectMembersAndStatics(){
  final HasInjections hi=new HasInjections();
  Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestStaticInjection(HasInjections.class);
      requestInjection(hi);
    }
  }
);
  assertEquals(""String_Node_Str"",hi.instanceMethod);
  assertEquals(5,hi.instanceField);
  assertEquals(""String_Node_Str"",HasInjections.staticMethod);
  assertEquals(5,HasInjections.staticField);
}","public void testInjectMembersAndStatics(){
  final HasInjections hi=new HasInjections();
  Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bindConstant().annotatedWith(ForMethod.class).to(""String_Node_Str"");
      bindConstant().annotatedWith(ForField.class).to(5);
      requestStaticInjection(HasInjections.class);
      requestInjection(hi);
    }
  }
);
  assertEquals(""String_Node_Str"",hi.instanceMethod);
  assertEquals(5,hi.instanceField);
  assertEquals(""String_Node_Str"",HasInjections.staticMethod);
  assertEquals(5,HasInjections.staticField);
}",0.9915682967959528
60404,"protected void setUp() throws Exception {
  super.setUp();
  HasInjections.staticField=0;
  HasInjections.staticMethod=null;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  HasInjections.staticField=0;
  HasInjections.staticMethod=null;
}",0.9618320610687024
60405,"public void testInjectionErrorOnInjectedMembers(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        bind(Runnable.class).toProvider(new Provider<Runnable>(){
          public Runnable get(){
            throw new UnsupportedOperationException();
          }
        }
);
        requestInjection(new NeedsRunnable());
      }
    }
);
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}","public void testInjectionErrorOnInjectedMembers(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(Runnable.class).toProvider(new Provider<Runnable>(){
          public Runnable get(){
            throw new UnsupportedOperationException();
          }
        }
);
        requestInjection(new NeedsRunnable());
      }
    }
);
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}",0.9920255183413078
60406,"/** 
 * Returns the key for the source binding. That binding can e retrieved from an injector using  {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
Key<String> getSourceKey();","/** 
 * Returns the key for the source binding. That binding can be retrieved from an injector using  {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
Key<String> getSourceKey();",0.9976133651551312
60407,"protected ConstructorInjector<?> create(InjectionPoint constructorInjector,Errors errors) throws ErrorsException {
  return createConstructor(constructorInjector,errors);
}","@Override protected ConstructorInjector<?> create(InjectionPoint constructorInjector,Errors errors) throws ErrorsException {
  return createConstructor(constructorInjector,errors);
}",0.9717514124293786
60408,"InjectorImpl(InjectorImpl parent,State state,InjectorOptions injectorOptions){
  this.parent=parent;
  this.state=state;
  this.options=injectorOptions;
  if (parent != null) {
    localContext=parent.localContext;
  }
 else {
    localContext=new ThreadLocal<Object[]>(){
      protected Object[] initialValue(){
        return new Object[1];
      }
    }
;
  }
}","InjectorImpl(InjectorImpl parent,State state,InjectorOptions injectorOptions){
  this.parent=parent;
  this.state=state;
  this.options=injectorOptions;
  if (parent != null) {
    localContext=parent.localContext;
  }
 else {
    localContext=new ThreadLocal<Object[]>(){
      @Override protected Object[] initialValue(){
        return new Object[1];
      }
    }
;
  }
}",0.9864864864864864
60409,"protected Object[] initialValue(){
  return new Object[1];
}","@Override protected Object[] initialValue(){
  return new Object[1];
}",0.9230769230769232
60410,"/** 
 * Returns a just-in-time binding for   {@code key}, creating it if necessary.
 * @throws ErrorsException if the binding could not be created.
 */
private <T>BindingImpl<T> getJustInTimeBinding(Key<T> key,Errors errors,JitLimitation jitType) throws ErrorsException {
  boolean jitOverride=isProvider(key) || isTypeLiteral(key) || isMembersInjector(key);
synchronized (state.lock()) {
    for (InjectorImpl injector=this; injector != null; injector=injector.parent) {
      @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)injector.jitBindings.get(key);
      if (binding != null) {
        if (options.jitDisabled && jitType == JitLimitation.NO_JIT && !jitOverride && !(binding instanceof ConvertedConstantBindingImpl)) {
          throw errors.jitDisabled(key).toException();
        }
 else {
          return binding;
        }
      }
    }
    return createJustInTimeBindingRecursive(key,errors,options.jitDisabled,jitType);
  }
}","/** 
 * Returns a just-in-time binding for   {@code key}, creating it if necessary.
 * @throws ErrorsException if the binding could not be created.
 */
private <T>BindingImpl<T> getJustInTimeBinding(Key<T> key,Errors errors,JitLimitation jitType) throws ErrorsException {
  boolean jitOverride=isProvider(key) || isTypeLiteral(key) || isMembersInjector(key);
synchronized (state.lock()) {
    for (InjectorImpl injector=this; injector != null; injector=injector.parent) {
      @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)injector.jitBindings.get(key);
      if (binding != null) {
        if (options.jitDisabled && jitType == JitLimitation.NO_JIT && !jitOverride && !(binding instanceof ConvertedConstantBindingImpl)) {
          throw errors.jitDisabled(key).toException();
        }
 else {
          return binding;
        }
      }
    }
    if (failedJitBindings.contains(key) && errors.hasErrors()) {
      throw errors.toException();
    }
    return createJustInTimeBindingRecursive(key,errors,options.jitDisabled,jitType);
  }
}",0.948504168710152
60411,"/** 
 * Cleans up any state that may have been cached when constructing the JIT binding. 
 */
private void removeFailedJitBinding(Key<?> key,InjectionPoint ip){
  jitBindings.remove(key);
  membersInjectorStore.remove(key.getTypeLiteral());
  provisionListenerStore.remove(key);
  if (ip != null) {
    constructors.remove(ip);
  }
}","/** 
 * Cleans up any state that may have been cached when constructing the JIT binding. 
 */
private void removeFailedJitBinding(Key<?> key,InjectionPoint ip){
  failedJitBindings.add(key);
  jitBindings.remove(key);
  membersInjectorStore.remove(key.getTypeLiteral());
  provisionListenerStore.remove(key);
  if (ip != null) {
    constructors.remove(ip);
  }
}",0.956896551724138
60412,"public String toString(){
  return Objects.toStringHelper(Injector.class).add(""String_Node_Str"",state.getExplicitBindingsThisLevel().values()).toString();
}","@Override public String toString(){
  return Objects.toStringHelper(Injector.class).add(""String_Node_Str"",state.getExplicitBindingsThisLevel().values()).toString();
}",0.968944099378882
60413,"/** 
 * Although   {@code String[].class} isn't equal to {@code newGenericArrayTypeImpl(String.class)}, Guice should treat these two types interchangeably.
 */
public void testArrayTypeCanonicalization(){
  final String[] strings=new String[]{""String_Node_Str""};
  final Integer[] integers=new Integer[]{1};
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(String[].class).toInstance(strings);
      bind(new TypeLiteral<Integer[]>(){
      }
).toInstance(integers);
    }
  }
);
  assertSame(integers,injector.getInstance(Key.get(new TypeLiteral<Integer[]>(){
  }
)));
  assertSame(integers,injector.getInstance(new Key<Integer[]>(){
  }
));
  assertSame(integers,injector.getInstance(Integer[].class));
  assertSame(strings,injector.getInstance(Key.get(new TypeLiteral<String[]>(){
  }
)));
  assertSame(strings,injector.getInstance(new Key<String[]>(){
  }
));
  assertSame(strings,injector.getInstance(String[].class));
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        bind(String[].class).toInstance(new String[]{""String_Node_Str""});
        bind(new TypeLiteral<String[]>(){
        }
).toInstance(new String[]{""String_Node_Str""});
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
    assertContains(expected.getMessage(),""String_Node_Str"");
  }
  injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(String[].class).toInstance(strings);
      bind(new TypeLiteral<String[]>(){
      }
).toInstance(strings);
    }
  }
);
  assertSame(strings,injector.getInstance(Key.get(new TypeLiteral<String[]>(){
  }
)));
  assertSame(strings,injector.getInstance(new Key<String[]>(){
  }
));
  assertSame(strings,injector.getInstance(String[].class));
}","/** 
 * Although   {@code String[].class} isn't equal to {@code newGenericArrayTypeImpl(String.class)}, Guice should treat these two types interchangeably.
 */
public void testArrayTypeCanonicalization(){
  final String[] strings=new String[]{""String_Node_Str""};
  final Integer[] integers=new Integer[]{1};
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(String[].class).toInstance(strings);
      bind(new TypeLiteral<Integer[]>(){
      }
).toInstance(integers);
    }
  }
);
  assertSame(integers,injector.getInstance(Key.get(new TypeLiteral<Integer[]>(){
  }
)));
  assertSame(integers,injector.getInstance(new Key<Integer[]>(){
  }
));
  assertSame(integers,injector.getInstance(Integer[].class));
  assertSame(strings,injector.getInstance(Key.get(new TypeLiteral<String[]>(){
  }
)));
  assertSame(strings,injector.getInstance(new Key<String[]>(){
  }
));
  assertSame(strings,injector.getInstance(String[].class));
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(String[].class).toInstance(new String[]{""String_Node_Str""});
        bind(new TypeLiteral<String[]>(){
        }
).toInstance(new String[]{""String_Node_Str""});
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
    assertContains(expected.getMessage(),""String_Node_Str"");
  }
  injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(String[].class).toInstance(strings);
      bind(new TypeLiteral<String[]>(){
      }
).toInstance(strings);
    }
  }
);
  assertSame(strings,injector.getInstance(Key.get(new TypeLiteral<String[]>(){
  }
)));
  assertSame(strings,injector.getInstance(new Key<String[]>(){
  }
));
  assertSame(strings,injector.getInstance(String[].class));
}",0.992412746585736
60414,"public void testBindingToProvider(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        bind(new TypeLiteral<Provider<String>>(){
        }
).toInstance(Providers.of(""String_Node_Str""));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BinderTest.class.getName(),""String_Node_Str"");
  }
}","public void testBindingToProvider(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(new TypeLiteral<Provider<String>>(){
        }
).toInstance(Providers.of(""String_Node_Str""));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"" + BinderTest.class.getName(),""String_Node_Str"");
  }
}",0.98868778280543
60415,"public void testCannotBindToGuiceTypes(){
  final Named red=Names.named(""String_Node_Str"");
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        bind(AbstractModule.class).annotatedWith(red).toProvider(Providers.<AbstractModule>of(null));
        bind(Binder.class).annotatedWith(red).toProvider(Providers.<Binder>of(null));
        bind(Binding.class).annotatedWith(red).toProvider(Providers.<Binding>of(null));
        bind(Injector.class).annotatedWith(red).toProvider(Providers.<Injector>of(null));
        bind(Key.class).annotatedWith(red).toProvider(Providers.<Key>of(null));
        bind(Module.class).annotatedWith(red).toProvider(Providers.<Module>of(null));
        bind(Provider.class).annotatedWith(red).toProvider(Providers.<Provider>of(null));
        bind(Scope.class).annotatedWith(red).toProvider(Providers.<Scope>of(null));
        bind(TypeLiteral.class).annotatedWith(red).toProvider(Providers.<TypeLiteral>of(null));
        bind(new TypeLiteral<Key<String>>(){
        }
).toProvider(Providers.<Key<String>>of(null));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}","public void testCannotBindToGuiceTypes(){
  final Named red=Names.named(""String_Node_Str"");
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        bind(AbstractModule.class).annotatedWith(red).toProvider(Providers.<AbstractModule>of(null));
        bind(Binder.class).annotatedWith(red).toProvider(Providers.<Binder>of(null));
        bind(Binding.class).annotatedWith(red).toProvider(Providers.<Binding>of(null));
        bind(Injector.class).annotatedWith(red).toProvider(Providers.<Injector>of(null));
        bind(Key.class).annotatedWith(red).toProvider(Providers.<Key>of(null));
        bind(Module.class).annotatedWith(red).toProvider(Providers.<Module>of(null));
        bind(Provider.class).annotatedWith(red).toProvider(Providers.<Provider>of(null));
        bind(Scope.class).annotatedWith(red).toProvider(Providers.<Scope>of(null));
        bind(TypeLiteral.class).annotatedWith(red).toProvider(Providers.<TypeLiteral>of(null));
        bind(new TypeLiteral<Key<String>>(){
        }
).toProvider(Providers.<Key<String>>of(null));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}",0.9964054636951832
60416,"public void testUserReportedErrorsAreAlsoLogged(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        addError(new Message(ImmutableList.of(),""String_Node_Str"",new IllegalArgumentException()));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
  }
  LogRecord logRecord=Iterables.getOnlyElement(this.logRecords);
  assertContains(logRecord.getMessage(),""String_Node_Str"");
}","public void testUserReportedErrorsAreAlsoLogged(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        addError(new Message(ImmutableList.of(),""String_Node_Str"",new IllegalArgumentException()));
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
  }
  LogRecord logRecord=Iterables.getOnlyElement(this.logRecords);
  assertContains(logRecord.getMessage(),""String_Node_Str"");
}",0.9888392857142856
60417,"public void testMissingDependency(){
  try {
    Guice.createInjector(new AbstractModule(){
      public void configure(){
        bind(NeedsRunnable.class);
      }
    }
);
  }
 catch (  CreationException e) {
    assertEquals(1,e.getErrorMessages().size());
    assertContains(e.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}","public void testMissingDependency(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override public void configure(){
        bind(NeedsRunnable.class);
      }
    }
);
  }
 catch (  CreationException e) {
    assertEquals(1,e.getErrorMessages().size());
    assertContains(e.getMessage(),""String_Node_Str"",""String_Node_Str"" + NeedsRunnable.class.getName(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}",0.9889380530973452
60418,"protected void configure(){
  bind(AbstractModule.class).annotatedWith(red).toProvider(Providers.<AbstractModule>of(null));
  bind(Binder.class).annotatedWith(red).toProvider(Providers.<Binder>of(null));
  bind(Binding.class).annotatedWith(red).toProvider(Providers.<Binding>of(null));
  bind(Injector.class).annotatedWith(red).toProvider(Providers.<Injector>of(null));
  bind(Key.class).annotatedWith(red).toProvider(Providers.<Key>of(null));
  bind(Module.class).annotatedWith(red).toProvider(Providers.<Module>of(null));
  bind(Provider.class).annotatedWith(red).toProvider(Providers.<Provider>of(null));
  bind(Scope.class).annotatedWith(red).toProvider(Providers.<Scope>of(null));
  bind(TypeLiteral.class).annotatedWith(red).toProvider(Providers.<TypeLiteral>of(null));
  bind(new TypeLiteral<Key<String>>(){
  }
).toProvider(Providers.<Key<String>>of(null));
}","@Override protected void configure(){
  bind(AbstractModule.class).annotatedWith(red).toProvider(Providers.<AbstractModule>of(null));
  bind(Binder.class).annotatedWith(red).toProvider(Providers.<Binder>of(null));
  bind(Binding.class).annotatedWith(red).toProvider(Providers.<Binding>of(null));
  bind(Injector.class).annotatedWith(red).toProvider(Providers.<Injector>of(null));
  bind(Key.class).annotatedWith(red).toProvider(Providers.<Key>of(null));
  bind(Module.class).annotatedWith(red).toProvider(Providers.<Module>of(null));
  bind(Provider.class).annotatedWith(red).toProvider(Providers.<Provider>of(null));
  bind(Scope.class).annotatedWith(red).toProvider(Providers.<Scope>of(null));
  bind(TypeLiteral.class).annotatedWith(red).toProvider(Providers.<TypeLiteral>of(null));
  bind(new TypeLiteral<Key<String>>(){
  }
).toProvider(Providers.<Key<String>>of(null));
}",0.9942660550458716
60419,"public void testMissingBindings(){
  try {
    Guice.createInjector(new AbstractModule(){
      public void configure(){
        getProvider(Runnable.class);
        bind(Comparator.class);
        requireBinding(Key.get(new TypeLiteral<Callable<String>>(){
        }
));
        bind(Date.class).annotatedWith(Names.named(""String_Node_Str""));
      }
    }
);
  }
 catch (  CreationException e) {
    assertEquals(4,e.getErrorMessages().size());
    assertContains(e.getMessage(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + Comparator.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + Named.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName());
  }
}","public void testMissingBindings(){
  try {
    Guice.createInjector(new AbstractModule(){
      @Override public void configure(){
        getProvider(Runnable.class);
        bind(Comparator.class);
        requireBinding(Key.get(new TypeLiteral<Callable<String>>(){
        }
));
        bind(Date.class).annotatedWith(Names.named(""String_Node_Str""));
      }
    }
);
  }
 catch (  CreationException e) {
    assertEquals(4,e.getErrorMessages().size());
    assertContains(e.getMessage(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + Comparator.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"" + Named.class.getName() + ""String_Node_Str"",""String_Node_Str"" + getClass().getName());
  }
}",0.9939172749391728
60420,"/** 
 * Untargetted bindings should follow @ImplementedBy and @ProvidedBy annotations if they exist. Otherwise the class should be constructed directly.
 */
public void testUntargettedBinding(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(HasProvidedBy1.class);
      bind(HasImplementedBy1.class);
      bind(HasProvidedBy2.class);
      bind(HasImplementedBy2.class);
      bind(JustAClass.class);
    }
  }
);
  assertNotNull(injector.getInstance(HasProvidedBy1.class));
  assertNotNull(injector.getInstance(HasImplementedBy1.class));
  assertNotSame(HasProvidedBy2.class,injector.getInstance(HasProvidedBy2.class).getClass());
  assertSame(ExtendsHasImplementedBy2.class,injector.getInstance(HasImplementedBy2.class).getClass());
  assertSame(JustAClass.class,injector.getInstance(JustAClass.class).getClass());
}","/** 
 * Untargetted bindings should follow @ImplementedBy and @ProvidedBy annotations if they exist. Otherwise the class should be constructed directly.
 */
public void testUntargettedBinding(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(HasProvidedBy1.class);
      bind(HasImplementedBy1.class);
      bind(HasProvidedBy2.class);
      bind(HasImplementedBy2.class);
      bind(JustAClass.class);
    }
  }
);
  assertNotNull(injector.getInstance(HasProvidedBy1.class));
  assertNotNull(injector.getInstance(HasImplementedBy1.class));
  assertNotSame(HasProvidedBy2.class,injector.getInstance(HasProvidedBy2.class).getClass());
  assertSame(ExtendsHasImplementedBy2.class,injector.getInstance(HasImplementedBy2.class).getClass());
  assertSame(JustAClass.class,injector.getInstance(JustAClass.class).getClass());
}",0.994343891402715
60421,"public void testUserReportedError(){
  final Message message=new Message(getClass(),""String_Node_Str"");
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
        addError(message);
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertSame(message,Iterables.getOnlyElement(expected.getErrorMessages()));
  }
}","public void testUserReportedError(){
  final Message message=new Message(getClass(),""String_Node_Str"");
  try {
    Guice.createInjector(new AbstractModule(){
      @Override protected void configure(){
        addError(message);
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertSame(message,Iterables.getOnlyElement(expected.getErrorMessages()));
  }
}",0.986910994764398
60422,"public void testBindingOverridesImplementedBy(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(I.class).to(AlternateImpl.class);
    }
  }
);
  assertEquals(AlternateImpl.class,injector.getInstance(I.class).getClass());
}","public void testBindingOverridesImplementedBy(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(I.class).to(AlternateImpl.class);
    }
  }
);
  assertEquals(AlternateImpl.class,injector.getInstance(I.class).getClass());
}",0.9825174825174824
60423,"@SuppressWarnings(""String_Node_Str"") private void assertFailure(Injector injector,Class clazz){
  try {
    injector.getBinding(clazz);
    fail(""String_Node_Str"" + clazz);
  }
 catch (  ConfigurationException expected) {
    List<Object> sources=Iterables.getOnlyElement(expected.getErrorMessages()).getSources();
    assertEquals(Key.get(clazz).toString(),sources.get(0).toString());
    Asserts.assertContains(sources.get(sources.size() - 1).toString(),Key.get(InvalidInterface.class).toString());
  }
}","@SuppressWarnings(""String_Node_Str"") private void assertFailure(Injector injector,Class clazz){
  try {
    injector.getBinding(clazz);
    fail(""String_Node_Str"" + clazz);
  }
 catch (  ConfigurationException expected) {
    Message msg=Iterables.getOnlyElement(expected.getErrorMessages());
    assertEquals(""String_Node_Str"" + InvalidInterface.class.getName() + ""String_Node_Str"",msg.getMessage());
    List<Object> sources=msg.getSources();
    assertEquals(Key.get(clazz).toString(),sources.get(0).toString());
    Asserts.assertContains(sources.get(sources.size() - 1).toString(),Key.get(InvalidInterface.class).toString());
  }
}",0.7950963222416813
60424,"BoundProviderFactory(InjectorImpl injector,Key<? extends javax.inject.Provider<? extends T>> providerKey,Object source){
  this.injector=injector;
  this.providerKey=providerKey;
  this.source=source;
}","BoundProviderFactory(InjectorImpl injector,Key<? extends javax.inject.Provider<? extends T>> providerKey,Object source,boolean allowProxy){
  super(source,allowProxy);
  this.injector=injector;
  this.providerKey=providerKey;
}",0.8391608391608392
60425,"public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  errors=errors.withSource(providerKey);
  javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency,true);
  try {
    return errors.checkForNull(provider.get(),source,dependency);
  }
 catch (  RuntimeException userException) {
    throw errors.errorInProvider(userException).toException();
  }
}","public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  errors=errors.withSource(providerKey);
  javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency,true);
  try {
    return circularGet(provider,errors,context,dependency,linked);
  }
 catch (  RuntimeException userException) {
    throw errors.errorInProvider(userException).toException();
  }
}",0.6391061452513966
60426,"/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(Key<T> key,Scoping scoping,ProvidedBy providedBy,Errors errors) throws ErrorsException {
  final Class<?> rawType=key.getTypeLiteral().getRawType();
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == rawType) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") final Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors,JitLimitation.NEW_OR_EXISTING_JIT);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    Dependency dependency,    boolean linked) throws ErrorsException {
      errors=errors.withSource(providerKey);
      Provider<?> provider=providerBinding.getInternalFactory().get(errors,context,dependency,true);
      try {
        Object o=provider.get();
        if (o != null && !rawType.isInstance(o)) {
          throw errors.subtypeNotProvided(providerType,rawType).toException();
        }
        @SuppressWarnings(""String_Node_Str"") T t=(T)o;
        return t;
      }
 catch (      RuntimeException e) {
        throw errors.errorInProvider(e).toException();
      }
    }
  }
;
  Object source=rawType;
  return new LinkedProviderBindingImpl<T>(this,key,source,Scoping.<T>scope(key,this,internalFactory,source,scoping),scoping,providerKey);
}","/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(Key<T> key,Scoping scoping,ProvidedBy providedBy,Errors errors) throws ErrorsException {
  final Class<?> rawType=key.getTypeLiteral().getRawType();
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == rawType) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") final Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors,JitLimitation.NEW_OR_EXISTING_JIT);
  InternalFactory<T> internalFactory=new ProviderInternalFactory<T>(providerKey,!options.disableCircularProxies){
    public T get(    Errors errors,    InternalContext context,    Dependency dependency,    boolean linked) throws ErrorsException {
      errors=errors.withSource(providerKey);
      Provider provider=providerBinding.getInternalFactory().get(errors,context,dependency,true);
      try {
        @SuppressWarnings(""String_Node_Str"") Object o=circularGet(provider,errors,context,dependency,linked);
        if (o != null && !rawType.isInstance(o)) {
          throw errors.subtypeNotProvided(providerType,rawType).toException();
        }
        @SuppressWarnings(""String_Node_Str"") T t=(T)o;
        return t;
      }
 catch (      RuntimeException e) {
        throw errors.errorInProvider(e).toException();
      }
    }
  }
;
  Object source=rawType;
  return new LinkedProviderBindingImpl<T>(this,key,source,Scoping.<T>scope(key,this,internalFactory,source,scoping),scoping,providerKey);
}",0.95206106870229
60427,"public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  try {
    return errors.checkForNull(initializable.get(errors).get(),source,dependency);
  }
 catch (  RuntimeException userException) {
    throw errors.withSource(source).errorInProvider(userException).toException();
  }
}","public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  try {
    return errors.checkForNull(provider.get(),source,dependency);
  }
 catch (  RuntimeException userException) {
    throw errors.withSource(source).errorInProvider(userException).toException();
  }
}",0.4932735426008968
60428,"@Override public String toString(){
  return initializable.toString();
}","@Override public String toString(){
  return provider.toString();
}",0.8776978417266187
60429,"public InternalFactoryToProviderAdapter(Initializable<Provider<? extends T>> initializable,Object source){
  this.initializable=checkNotNull(initializable,""String_Node_Str"");
  this.source=checkNotNull(source,""String_Node_Str"");
}","public InternalFactoryToProviderAdapter(Provider<? extends T> provider,Object source){
  this.provider=checkNotNull(provider,""String_Node_Str"");
  this.source=checkNotNull(source,""String_Node_Str"");
}",0.813953488372093
60430,"/** 
 * Scopes an internal factory. 
 */
static <T>InternalFactory<? extends T> scope(Key<T> key,InjectorImpl injector,InternalFactory<? extends T> creator,Object source,Scoping scoping){
  if (scoping.isNoScope()) {
    return creator;
  }
  Scope scope=scoping.getScopeInstance();
  Provider<T> scoped=scope.scope(key,new ProviderToInternalFactoryAdapter<T>(injector,creator));
  return new InternalFactoryToProviderAdapter<T>(Initializables.<Provider<? extends T>>of(scoped),source);
}","/** 
 * Scopes an internal factory. 
 */
static <T>InternalFactory<? extends T> scope(Key<T> key,InjectorImpl injector,InternalFactory<? extends T> creator,Object source,Scoping scoping){
  if (scoping.isNoScope()) {
    return creator;
  }
  Scope scope=scoping.getScopeInstance();
  Provider<T> scoped=scope.scope(key,new ProviderToInternalFactoryAdapter<T>(injector,creator));
  return new InternalFactoryToProviderAdapter<T>(scoped,source);
}",0.9421841541755888
60431,"/** 
 * Creates a child injector that binds the args, and returns the binding for the method's result.
 */
public Binding<?> getBindingFromNewInjector(final Method method,final Object[] args,final AssistData data){
  checkState(injector != null,""String_Node_Str"");
  final Key<?> returnType=data.returnType;
  final Key<?> assistedReturnType=Key.get(returnType.getTypeLiteral(),Assisted.class);
  Module assistedModule=new AbstractModule(){
    @Override @SuppressWarnings(""String_Node_Str"") protected void configure(){
      Binder binder=binder().withSource(method);
      int p=0;
      if (!data.optimized) {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
        }
      }
 else {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
        }
      }
      Constructor constructor=data.constructor;
      if (constructor != null) {
        binder.bind(assistedReturnType).toConstructor(constructor,(TypeLiteral)data.implementationType);
      }
    }
  }
;
  Injector forCreate=injector.createChildInjector(assistedModule);
  Binding binding=forCreate.getBinding(assistedReturnType);
  if (data.optimized) {
    data.cachedBinding=binding;
  }
  return binding;
}","/** 
 * Creates a child injector that binds the args, and returns the binding for the method's result.
 */
public Binding<?> getBindingFromNewInjector(final Method method,final Object[] args,final AssistData data){
  checkState(injector != null,""String_Node_Str"");
  final Key<?> returnType=data.returnType;
  final Key<?> assistedReturnType=Key.get(returnType.getTypeLiteral(),Assisted.class);
  Module assistedModule=new AbstractModule(){
    @Override @SuppressWarnings(""String_Node_Str"") protected void configure(){
      Binder binder=binder().withSource(method);
      int p=0;
      if (!data.optimized) {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
        }
      }
 else {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
        }
      }
      Constructor constructor=data.constructor;
      if (constructor != null) {
        binder.bind(assistedReturnType).toConstructor(constructor,(TypeLiteral)data.implementationType).in(Scopes.NO_SCOPE);
      }
    }
  }
;
  Injector forCreate=injector.createChildInjector(assistedModule);
  Binding binding=forCreate.getBinding(assistedReturnType);
  if (data.optimized) {
    data.cachedBinding=binding;
  }
  return binding;
}",0.992553983618764
60432,"@Override @SuppressWarnings(""String_Node_Str"") protected void configure(){
  Binder binder=binder().withSource(method);
  int p=0;
  if (!data.optimized) {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
    }
  }
 else {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
    }
  }
  Constructor constructor=data.constructor;
  if (constructor != null) {
    binder.bind(assistedReturnType).toConstructor(constructor,(TypeLiteral)data.implementationType);
  }
}","@Override @SuppressWarnings(""String_Node_Str"") protected void configure(){
  Binder binder=binder().withSource(method);
  int p=0;
  if (!data.optimized) {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
    }
  }
 else {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
    }
  }
  Constructor constructor=data.constructor;
  if (constructor != null) {
    binder.bind(assistedReturnType).toConstructor(constructor,(TypeLiteral)data.implementationType).in(Scopes.NO_SCOPE);
  }
}",0.9836867862969004
60433,Hidden create();,AssistedSingleton create(String string);,0.5
60434,"@Override protected void configure(){
  install(new FactoryModuleBuilder().implement(Hidden.class,HiddenImpl.class).build(NotHidden.class));
}","@Override protected void configure(){
  install(new FactoryModuleBuilder().build(SingletonFactory.class));
}",0.752
60435,"@Override public Boolean visit(PrivateElements privateElements){
  for (  Key<?> key : privateElements.getExposedKeys()) {
    bindExposed(privateElements,key);
  }
  return false;
}","@Override public Boolean visit(PrivateElements privateElements){
  if (phase == Phase.PASS_TWO) {
    return false;
  }
  for (  Key<?> key : privateElements.getExposedKeys()) {
    bindExposed(privateElements,key);
  }
  return false;
}",0.8687350835322196
60436,"/** 
 * Creates and returns the injector shells for the current modules. Multiple shells will be returned if any modules contain   {@link Binder#newPrivateBinder private environments}. The primary injector will be first in the returned list.
 */
List<InjectorShell> build(BindingProcessor bindingProcessor,Stopwatch stopwatch,Errors errors){
  checkState(stage != null,""String_Node_Str"");
  checkState(privateElements == null || parent != null,""String_Node_Str"");
  checkState(state != null,""String_Node_Str"");
  if (parent == null) {
    modules.add(0,new RootModule(stage));
  }
  elements.addAll(Elements.getElements(stage,modules));
  InjectorOptionsProcessor optionsProcessor=new InjectorOptionsProcessor(errors);
  optionsProcessor.process(null,elements);
  options=optionsProcessor.getOptions(stage,options);
  InjectorImpl injector=new InjectorImpl(parent,state,options);
  if (privateElements != null) {
    privateElements.initInjector(injector);
  }
  if (parent == null) {
    new TypeConverterBindingProcessor(errors).prepareBuiltInConverters(injector);
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  new MessageProcessor(errors).process(injector,elements);
  InterceptorBindingProcessor interceptors=new InterceptorBindingProcessor(errors);
  interceptors.process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeListenerBindingProcessor(errors).process(injector,elements);
  List<TypeListenerBinding> listenerBindings=injector.state.getTypeListenerBindings();
  injector.membersInjectorStore=new MembersInjectorStore(injector,listenerBindings);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopeBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeConverterBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindInjector(injector);
  bindLogger(injector);
  bindingProcessor.process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  List<InjectorShell> injectorShells=Lists.newArrayList();
  injectorShells.add(new InjectorShell(this,elements,injector));
  PrivateElementProcessor processor=new PrivateElementProcessor(errors);
  processor.process(injector,elements);
  for (  Builder builder : processor.getInjectorShellBuilders()) {
    injectorShells.addAll(builder.build(bindingProcessor,stopwatch,errors));
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  return injectorShells;
}","/** 
 * Creates and returns the injector shells for the current modules. Multiple shells will be returned if any modules contain   {@link Binder#newPrivateBinder private environments}. The primary injector will be first in the returned list.
 */
List<InjectorShell> build(BindingProcessor bindingProcessor,Stopwatch stopwatch,Errors errors){
  checkState(stage != null,""String_Node_Str"");
  checkState(privateElements == null || parent != null,""String_Node_Str"");
  checkState(state != null,""String_Node_Str"");
  if (parent == null) {
    modules.add(0,new RootModule(stage));
  }
  elements.addAll(Elements.getElements(stage,modules));
  InjectorOptionsProcessor optionsProcessor=new InjectorOptionsProcessor(errors);
  optionsProcessor.process(null,elements);
  options=optionsProcessor.getOptions(stage,options);
  InjectorImpl injector=new InjectorImpl(parent,state,options);
  if (privateElements != null) {
    privateElements.initInjector(injector);
  }
  if (parent == null) {
    new TypeConverterBindingProcessor(errors).prepareBuiltInConverters(injector);
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  new MessageProcessor(errors).process(injector,elements);
  InterceptorBindingProcessor interceptors=new InterceptorBindingProcessor(errors);
  interceptors.process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeListenerBindingProcessor(errors).process(injector,elements);
  List<TypeListenerBinding> listenerBindings=injector.state.getTypeListenerBindings();
  injector.membersInjectorStore=new MembersInjectorStore(injector,listenerBindings);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopeBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  new TypeConverterBindingProcessor(errors).process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindInjector(injector);
  bindLogger(injector);
  bindingProcessor.setPhase(Phase.PASS_ONE);
  bindingProcessor.process(injector,elements);
  bindingProcessor.setPhase(Phase.PASS_TWO);
  bindingProcessor.process(injector,elements);
  stopwatch.resetAndLog(""String_Node_Str"");
  List<InjectorShell> injectorShells=Lists.newArrayList();
  injectorShells.add(new InjectorShell(this,elements,injector));
  PrivateElementProcessor processor=new PrivateElementProcessor(errors);
  processor.process(injector,elements);
  for (  Builder builder : processor.getInjectorShellBuilders()) {
    injectorShells.addAll(builder.build(bindingProcessor,stopwatch,errors));
  }
  stopwatch.resetAndLog(""String_Node_Str"");
  return injectorShells;
}",0.9728228526086096
60437,"/** 
 * Returns a module that installs   {@literal @}{@link CheckedProvides} methods.
 * @since 3.0
 */
public static Module forModule(Module module){
  return ThrowingProviderMethodsModule.forModule(module);
}","/** 
 * Returns a module that installs   {@literal @}{@link CheckedProvides} methods.
 * @since 3.0
 */
public static Module forModule(Module module){
  return CheckedProviderMethodsModule.forModule(module);
}",0.964200477326969
60438,"private ScopedBindingBuilder toInternal(final Key<? extends CheckedProvider> targetKey){
  final Key<Result> resultKey=Key.get(Result.class,UniqueAnnotations.create());
  final Key<P> key=createKey();
  final Provider<Result> resultProvider=binder.getProvider(resultKey);
  final Provider<? extends CheckedProvider> targetProvider=binder.getProvider(targetKey);
  if (valid) {
    binder.bind(key).toProvider(new ProviderWithDependencies<P>(){
      private final P instance=interfaceType.cast(Proxy.newProxyInstance(interfaceType.getClassLoader(),new Class<?>[]{interfaceType},new InvocationHandler(){
        public Object invoke(        Object proxy,        Method method,        Object[] args) throws Throwable {
          return resultProvider.get().getOrThrow();
        }
      }
));
      public P get(){
        return instance;
      }
      public Set<Dependency<?>> getDependencies(){
        return ImmutableSet.<Dependency<?>>of(Dependency.get(resultKey));
      }
    }
);
  }
  return binder.bind(resultKey).toProvider(new ProviderWithDependencies<Result>(){
    public Result get(){
      try {
        return Result.forValue(targetProvider.get().get());
      }
 catch (      Exception e) {
        for (        Class<? extends Throwable> exceptionType : exceptionTypes) {
          if (exceptionType.isInstance(e)) {
            return Result.forException(e);
          }
        }
        if (e instanceof RuntimeException) {
          throw (RuntimeException)e;
        }
 else {
          throw new RuntimeException(e);
        }
      }
    }
    public Set<Dependency<?>> getDependencies(){
      return ImmutableSet.<Dependency<?>>of(Dependency.get(targetKey));
    }
  }
);
}","private ScopedBindingBuilder toInternal(final Key<? extends CheckedProvider> targetKey){
  final Key<Result> resultKey=Key.get(Result.class,UniqueAnnotations.create());
  final Provider<Result> resultProvider=binder.getProvider(resultKey);
  final Provider<? extends CheckedProvider> targetProvider=binder.getProvider(targetKey);
  interfaceKey=createKey();
  if (valid) {
    binder.bind(interfaceKey).toProvider(new ProviderWithDependencies<P>(){
      private final P instance=interfaceType.cast(Proxy.newProxyInstance(interfaceType.getClassLoader(),new Class<?>[]{interfaceType},new InvocationHandler(){
        public Object invoke(        Object proxy,        Method method,        Object[] args) throws Throwable {
          return resultProvider.get().getOrThrow();
        }
      }
));
      public P get(){
        return instance;
      }
      public Set<Dependency<?>> getDependencies(){
        return ImmutableSet.<Dependency<?>>of(Dependency.get(resultKey));
      }
    }
);
  }
  return binder.bind(resultKey).toProvider(new ProviderWithDependencies<Result>(){
    public Result get(){
      try {
        return Result.forValue(targetProvider.get().get());
      }
 catch (      Exception e) {
        for (        Class<? extends Throwable> exceptionType : exceptionTypes) {
          if (exceptionType.isInstance(e)) {
            return Result.forException(e);
          }
        }
        if (e instanceof RuntimeException) {
          throw (RuntimeException)e;
        }
 else {
          throw new RuntimeException(e);
        }
      }
    }
    public Set<Dependency<?>> getDependencies(){
      return ImmutableSet.<Dependency<?>>of(Dependency.get(targetKey));
    }
  }
);
}",0.9791605518051072
60439,"ScopedBindingBuilder toProviderMethod(ThrowingProviderMethod<?> target){
  Key<ThrowingProviderMethod> targetKey=Key.get(ThrowingProviderMethod.class,UniqueAnnotations.create());
  binder.bind(targetKey).toInstance(target);
  return toInternal(targetKey);
}","ScopedBindingBuilder toProviderMethod(CheckedProviderMethod<?> target){
  Key<CheckedProviderMethod> targetKey=Key.get(CheckedProviderMethod.class,UniqueAnnotations.create());
  binder.bind(targetKey).toInstance(target);
  return toInternal(targetKey);
}",0.9119373776908024
60440,"/** 
 * Returns the exception type declared to be thrown by the get method of  {@code interfaceType}.
 */
@SuppressWarnings({""String_Node_Str""}) private List<Class<? extends Throwable>> getExceptionType(Class<P> interfaceType){
  try {
    Method getMethod=interfaceType.getMethod(""String_Node_Str"");
    List<TypeLiteral<?>> exceptionLiterals=TypeLiteral.get(interfaceType).getExceptionTypes(getMethod);
    List<Class<? extends Throwable>> results=Lists.newArrayList();
    for (    TypeLiteral<?> exLiteral : exceptionLiterals) {
      results.add(exLiteral.getRawType().asSubclass(Throwable.class));
    }
    return results;
  }
 catch (  SecurityException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","/** 
 * Returns the exception type declared to be thrown by the get method of  {@code interfaceType}.
 */
private List<Class<? extends Throwable>> getExceptionType(Class<P> interfaceType){
  try {
    Method getMethod=interfaceType.getMethod(""String_Node_Str"");
    List<TypeLiteral<?>> exceptionLiterals=TypeLiteral.get(interfaceType).getExceptionTypes(getMethod);
    List<Class<? extends Throwable>> results=Lists.newArrayList();
    for (    TypeLiteral<?> exLiteral : exceptionLiterals) {
      results.add(exLiteral.getRawType().asSubclass(Throwable.class));
    }
    return results;
  }
 catch (  SecurityException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.9758812615955472
60441,"private void bindQueryNamedParameters(Query jpaQuery,JpaFinderProxy.FinderDescriptor descriptor,Object[] arguments){
  for (int i=0; i < arguments.length; i++) {
    Object argument=arguments[i];
    Object annotation=descriptor.parameterAnnotations[i];
    if (null == annotation) {
      continue;
    }
 else     if (annotation instanceof Named) {
      Named named=(Named)annotation;
      jpaQuery.setParameter(named.value(),argument);
    }
 else     if (annotation instanceof FirstResult) {
      jpaQuery.setFirstResult((Integer)argument);
    }
 else     if (annotation instanceof MaxResults) {
      jpaQuery.setMaxResults((Integer)argument);
    }
  }
}","private void bindQueryNamedParameters(Query jpaQuery,JpaFinderProxy.FinderDescriptor descriptor,Object[] arguments){
  for (int i=0; i < arguments.length; i++) {
    Object argument=arguments[i];
    Object annotation=descriptor.parameterAnnotations[i];
    if (null == annotation) {
      continue;
    }
 else     if (annotation instanceof Named) {
      Named named=(Named)annotation;
      jpaQuery.setParameter(named.value(),argument);
    }
 else     if (annotation instanceof javax.inject.Named) {
      javax.inject.Named named=(javax.inject.Named)annotation;
      jpaQuery.setParameter(named.value(),argument);
    }
 else     if (annotation instanceof FirstResult) {
      jpaQuery.setFirstResult((Integer)argument);
    }
 else     if (annotation instanceof MaxResults) {
      jpaQuery.setMaxResults((Integer)argument);
    }
  }
}",0.8806366047745358
60442,"private JpaFinderProxy.FinderDescriptor getFinderDescriptor(MethodInvocation invocation){
  Method method=invocation.getMethod();
  JpaFinderProxy.FinderDescriptor finderDescriptor=finderCache.get(method);
  if (null != finderDescriptor) {
    return finderDescriptor;
  }
  finderDescriptor=new JpaFinderProxy.FinderDescriptor();
  finderDescriptor.returnClass=invocation.getMethod().getReturnType();
  finderDescriptor.returnType=determineReturnType(finderDescriptor.returnClass);
  Finder finder=invocation.getMethod().getAnnotation(Finder.class);
  String query=finder.query();
  if (!""String_Node_Str"".equals(query.trim())) {
    finderDescriptor.setQuery(query);
  }
 else {
    finderDescriptor.setNamedQuery(finder.namedQuery());
  }
  Annotation[][] parameterAnnotations=method.getParameterAnnotations();
  Object[] discoveredAnnotations=new Object[parameterAnnotations.length];
  for (int i=0; i < parameterAnnotations.length; i++) {
    Annotation[] annotations=parameterAnnotations[i];
    for (    Annotation annotation : annotations) {
      Class<? extends Annotation> annotationType=annotation.annotationType();
      if (Named.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        finderDescriptor.isBindAsRawParameters=false;
        break;
      }
 else       if (FirstResult.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        break;
      }
 else       if (MaxResults.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        break;
      }
    }
  }
  finderDescriptor.parameterAnnotations=discoveredAnnotations;
  if (JpaFinderProxy.ReturnType.COLLECTION.equals(finderDescriptor.returnType) && finderDescriptor.returnClass != Collection.class) {
    System.out.println(""String_Node_Str"" + finderDescriptor.returnClass);
    finderDescriptor.returnCollectionType=finder.returnAs();
    try {
      finderDescriptor.returnCollectionTypeConstructor=finderDescriptor.returnCollectionType.getConstructor();
      finderDescriptor.returnCollectionTypeConstructor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
      throw new RuntimeException(""String_Node_Str"" + finderDescriptor.returnCollectionType,e);
    }
  }
  cacheFinderDescriptor(method,finderDescriptor);
  return finderDescriptor;
}","private JpaFinderProxy.FinderDescriptor getFinderDescriptor(MethodInvocation invocation){
  Method method=invocation.getMethod();
  JpaFinderProxy.FinderDescriptor finderDescriptor=finderCache.get(method);
  if (null != finderDescriptor) {
    return finderDescriptor;
  }
  finderDescriptor=new JpaFinderProxy.FinderDescriptor();
  finderDescriptor.returnClass=invocation.getMethod().getReturnType();
  finderDescriptor.returnType=determineReturnType(finderDescriptor.returnClass);
  Finder finder=invocation.getMethod().getAnnotation(Finder.class);
  String query=finder.query();
  if (!""String_Node_Str"".equals(query.trim())) {
    finderDescriptor.setQuery(query);
  }
 else {
    finderDescriptor.setNamedQuery(finder.namedQuery());
  }
  Annotation[][] parameterAnnotations=method.getParameterAnnotations();
  Object[] discoveredAnnotations=new Object[parameterAnnotations.length];
  for (int i=0; i < parameterAnnotations.length; i++) {
    Annotation[] annotations=parameterAnnotations[i];
    for (    Annotation annotation : annotations) {
      Class<? extends Annotation> annotationType=annotation.annotationType();
      if (Named.class.equals(annotationType) || javax.inject.Named.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        finderDescriptor.isBindAsRawParameters=false;
        break;
      }
 else       if (FirstResult.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        break;
      }
 else       if (MaxResults.class.equals(annotationType)) {
        discoveredAnnotations[i]=annotation;
        break;
      }
    }
  }
  finderDescriptor.parameterAnnotations=discoveredAnnotations;
  if (JpaFinderProxy.ReturnType.COLLECTION.equals(finderDescriptor.returnType) && finderDescriptor.returnClass != Collection.class) {
    finderDescriptor.returnCollectionType=finder.returnAs();
    try {
      finderDescriptor.returnCollectionTypeConstructor=finderDescriptor.returnCollectionType.getConstructor();
      finderDescriptor.returnCollectionTypeConstructor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
      throw new RuntimeException(""String_Node_Str"" + finderDescriptor.returnCollectionType,e);
    }
  }
  cacheFinderDescriptor(method,finderDescriptor);
  return finderDescriptor;
}",0.7974875460255577
60443,"/** 
 * Returns a Guice-friendly   {@code com.google.inject.Provider} for the givenJSR-330  {@code javax.inject.Provider}. The converse method is unnecessary, since Guice providers directly implement the JSR-330 interface.
 * @since 3.0
 */
public static <T>Provider<T> guicify(javax.inject.Provider<T> provider){
  if (provider instanceof Provider) {
    return (Provider<T>)provider;
  }
  final javax.inject.Provider<T> delegate=checkNotNull(provider,""String_Node_Str"");
  return new Provider<T>(){
    public T get(){
      return delegate.get();
    }
    @Override public String toString(){
      return ""String_Node_Str"" + delegate + ""String_Node_Str"";
    }
  }
;
}","/** 
 * Returns a Guice-friendly   {@code com.google.inject.Provider} for the givenJSR-330  {@code javax.inject.Provider}. The converse method is unnecessary, since Guice providers directly implement the JSR-330 interface.
 * @since 3.0
 */
public static <T>Provider<T> guicify(javax.inject.Provider<T> provider){
  if (provider instanceof Provider) {
    return (Provider<T>)provider;
  }
  final javax.inject.Provider<T> delegate=checkNotNull(provider,""String_Node_Str"");
  Set<InjectionPoint> injectionPoints=InjectionPoint.forInstanceMethodsAndFields(provider.getClass());
  if (injectionPoints.isEmpty()) {
    return new Provider<T>(){
      public T get(){
        return delegate.get();
      }
      @Override public String toString(){
        return ""String_Node_Str"" + delegate + ""String_Node_Str"";
      }
    }
;
  }
 else {
    Set<Dependency<?>> mutableDeps=Sets.newHashSet();
    for (    InjectionPoint ip : injectionPoints) {
      mutableDeps.addAll(ip.getDependencies());
    }
    final Set<Dependency<?>> dependencies=ImmutableSet.copyOf(mutableDeps);
    return new ProviderWithDependencies<T>(){
      @SuppressWarnings(""String_Node_Str"") @Inject void initialize(      Injector injector){
        injector.injectMembers(delegate);
      }
      public Set<Dependency<?>> getDependencies(){
        return dependencies;
      }
      public T get(){
        return delegate.get();
      }
      @Override public String toString(){
        return ""String_Node_Str"" + delegate + ""String_Node_Str"";
      }
    }
;
  }
}",0.6082241301400814
60444,"public void testGuicify330Provider(){
  Provider<String> jsr330Provider=new Provider<String>(){
    public String get(){
      return ""String_Node_Str"";
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  com.google.inject.Provider<String> guicified=Providers.guicify(jsr330Provider);
  assertEquals(""String_Node_Str"",guicified.toString());
  assertEquals(""String_Node_Str"",guicified.get());
  assertSame(guicified,Providers.guicify(guicified));
}","public void testGuicify330Provider(){
  Provider<String> jsr330Provider=new Provider<String>(){
    public String get(){
      return ""String_Node_Str"";
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  com.google.inject.Provider<String> guicified=Providers.guicify(jsr330Provider);
  assertEquals(""String_Node_Str"",guicified.toString());
  assertEquals(""String_Node_Str"",guicified.get());
  assertSame(guicified,Providers.guicify(guicified));
  assertFalse(guicified instanceof HasDependencies);
}",0.9483933787731256
60445,"protected void configure(){
  bind(B.class).toProvider(BProvider.class);
  bind(B.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(BProvider.class);
  bind(B.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(Key.get(BProvider.class));
  bind(B.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(TypeLiteral.get(BProvider.class));
}","@Override protected void configure(){
  bind(String.class).toProvider(guicified);
  bind(int.class).toInstance(1);
  bind(double.class).toInstance(2.0d);
}",0.3939393939393939
60446,"public static Visibility forMember(Member member){
  if ((member.getModifiers() & (Modifier.PROTECTED | Modifier.PUBLIC)) == 0) {
    return SAME_PACKAGE;
  }
  Class[] parameterTypes=member instanceof Constructor ? ((Constructor)member).getParameterTypes() : ((Method)member).getParameterTypes();
  for (  Class<?> type : parameterTypes) {
    if (forType(type) == SAME_PACKAGE) {
      return SAME_PACKAGE;
    }
  }
  return PUBLIC;
}","public static Visibility forMember(Member member){
  if ((member.getModifiers() & (Modifier.PROTECTED | Modifier.PUBLIC)) == 0) {
    return SAME_PACKAGE;
  }
  Class[] parameterTypes;
  if (member instanceof Constructor) {
    parameterTypes=((Constructor)member).getParameterTypes();
  }
 else {
    Method method=(Method)member;
    if (forType(method.getReturnType()) == SAME_PACKAGE) {
      return SAME_PACKAGE;
    }
    parameterTypes=method.getParameterTypes();
  }
  for (  Class<?> type : parameterTypes) {
    if (forType(type) == SAME_PACKAGE) {
      return SAME_PACKAGE;
    }
  }
  return PUBLIC;
}",0.7668886774500476
60447,"public TestVisibilityClassLoader(){
  super(new URL[0]);
  final String[] classpath=System.getProperty(""String_Node_Str"").split(File.pathSeparator);
  for (  final String element : classpath) {
    try {
      addURL(new URL(element));
    }
 catch (    final MalformedURLException e1) {
      try {
        addURL(new File(element).toURI().toURL());
      }
 catch (      final MalformedURLException e2) {
        throw new RuntimeException(e1);
      }
    }
  }
}","public TestVisibilityClassLoader(boolean hideInternals){
  super(new URL[0]);
  this.hideInternals=hideInternals;
  final String[] classpath=System.getProperty(""String_Node_Str"").split(File.pathSeparator);
  for (  final String element : classpath) {
    try {
      addURL(new URL(element));
    }
 catch (    final MalformedURLException e1) {
      try {
        addURL(new File(element).toURI().toURL());
      }
 catch (      final MalformedURLException e2) {
        throw new RuntimeException(e1);
      }
    }
  }
}",0.942366026289181
60448,"public Object invoke(MethodInvocation chain) throws Throwable {
  return chain.proceed() + ""String_Node_Str"";
}","public Object invoke(MethodInvocation chain) throws Throwable {
  return chain.proceed();
}",0.900990099009901
60449,"/** 
 * Classic parent-delegating classloaders are meant to override findClass. However, non-delegating classloaders (as used in OSGi) instead override loadClass to provide support for ""class-space"" separation.
 */
@Override protected Class<?> loadClass(final String name,final boolean resolve) throws ClassNotFoundException {
synchronized (this) {
    final Class<?> clazz=findLoadedClass(name);
    if (clazz != null) {
      return clazz;
    }
  }
  if (name.startsWith(""String_Node_Str"")) {
    return super.loadClass(name,resolve);
  }
 else   if (!name.contains(""String_Node_Str"") && !name.contains(""String_Node_Str"")) {
    final Class<?> clazz=findClass(name);
    if (resolve) {
      resolveClass(clazz);
    }
    return clazz;
  }
  throw new ClassNotFoundException();
}","/** 
 * Classic parent-delegating classloaders are meant to override findClass. However, non-delegating classloaders (as used in OSGi) instead override loadClass to provide support for ""class-space"" separation.
 */
@Override protected Class<?> loadClass(final String name,final boolean resolve) throws ClassNotFoundException {
synchronized (this) {
    final Class<?> clazz=findLoadedClass(name);
    if (clazz != null) {
      return clazz;
    }
  }
  if (name.startsWith(""String_Node_Str"")) {
    return super.loadClass(name,resolve);
  }
 else   if (!name.contains(""String_Node_Str"") && !name.contains(""String_Node_Str"")) {
    final Class<?> clazz=findClass(name);
    if (resolve) {
      resolveClass(clazz);
    }
    return clazz;
  }
  if (hideInternals) {
    throw new ClassNotFoundException();
  }
  return super.loadClass(name,resolve);
}",0.9577981651376148
60450,"@SuppressWarnings(""String_Node_Str"") protected void setUp() throws Exception {
  super.setUp();
  ClassLoader testClassLoader=new TestVisibilityClassLoader();
  proxyTestClass=(Class<ProxyTest>)testClassLoader.loadClass(ProxyTest.class.getName());
  realClass=(Class<ProxyTestImpl>)testClassLoader.loadClass(ProxyTestImpl.class.getName());
  testModule=new AbstractModule(){
    public void configure(){
      bind(proxyTestClass).to(realClass);
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") protected void setUp() throws Exception {
  super.setUp();
  ClassLoader testClassLoader=new TestVisibilityClassLoader(true);
  proxyTestClass=(Class<ProxyTest>)testClassLoader.loadClass(ProxyTest.class.getName());
  realClass=(Class<ProxyTestImpl>)testClassLoader.loadClass(ProxyTestImpl.class.getName());
  testModule=new AbstractModule(){
    public void configure(){
      bind(proxyTestClass).to(realClass);
    }
  }
;
}",0.9956616052060736
60451,"/** 
 * Returns true if   {@code binding} is singleton-scoped. If the binding is a {@link com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. itwas retrieved via  {@link Injector#getBinding Injector.getBinding()}), then this method will also true if the target binding is singleton-scoped.
 * @since 3.0
 */
public static boolean isSingleton(Binding<?> binding){
  do {
    boolean singleton=binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>(){
      public Boolean visitNoScoping(){
        return false;
      }
      public Boolean visitScopeAnnotation(      Class<? extends Annotation> scopeAnnotation){
        return scopeAnnotation == Singleton.class || scopeAnnotation == javax.inject.Singleton.class;
      }
      public Boolean visitScope(      Scope scope){
        return scope == Scopes.SINGLETON;
      }
      public Boolean visitEagerSingleton(){
        return true;
      }
    }
);
    if (singleton) {
      return true;
    }
    if (binding instanceof LinkedBindingImpl) {
      LinkedBindingImpl<?> linkedBinding=(LinkedBindingImpl)binding;
      Injector injector=(Injector)linkedBinding.getInjector();
      if (injector != null) {
        binding=injector.getBinding(linkedBinding.getLinkedKey());
        continue;
      }
    }
    return false;
  }
 while (true);
}","/** 
 * Returns true if   {@code binding} is singleton-scoped. If the binding is a {@link com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. itwas retrieved via  {@link Injector#getBinding Injector.getBinding()}), then this method will also true if the target binding is singleton-scoped.
 * @since 3.0
 */
public static boolean isSingleton(Binding<?> binding){
  do {
    boolean singleton=binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>(){
      public Boolean visitNoScoping(){
        return false;
      }
      public Boolean visitScopeAnnotation(      Class<? extends Annotation> scopeAnnotation){
        return scopeAnnotation == Singleton.class || scopeAnnotation == javax.inject.Singleton.class;
      }
      public Boolean visitScope(      Scope scope){
        return scope == Scopes.SINGLETON;
      }
      public Boolean visitEagerSingleton(){
        return true;
      }
    }
);
    if (singleton) {
      return true;
    }
    if (binding instanceof LinkedBindingImpl) {
      LinkedBindingImpl<?> linkedBinding=(LinkedBindingImpl)binding;
      Injector injector=(Injector)linkedBinding.getInjector();
      if (injector != null) {
        binding=injector.getBinding(linkedBinding.getLinkedKey());
        continue;
      }
    }
 else     if (binding instanceof ExposedBinding) {
      ExposedBinding<?> exposedBinding=(ExposedBinding)binding;
      Injector injector=exposedBinding.getPrivateElements().getInjector();
      if (injector != null) {
        binding=injector.getBinding(exposedBinding.getKey());
        continue;
      }
    }
    return false;
  }
 while (true);
}",0.8956810631229236
60452,"public void testIsSingletonPositive(){
  final Key<String> a=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> b=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> c=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> d=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> e=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> f=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> g=Key.get(String.class,named(""String_Node_Str""));
  final Key<Object> h=Key.get(Object.class,named(""String_Node_Str""));
  Module singletonBindings=new AbstractModule(){
    protected void configure(){
      bind(a).to(b);
      bind(b).to(c);
      bind(c).toProvider(Providers.of(""String_Node_Str"")).in(Scopes.SINGLETON);
      bind(d).toInstance(""String_Node_Str"");
      bind(e).toProvider(Providers.of(""String_Node_Str"")).asEagerSingleton();
      bind(f).toProvider(Providers.of(""String_Node_Str"")).in(Singleton.class);
      bind(h).to(AnnotatedSingleton.class);
    }
    @Provides @Named(""String_Node_Str"") @Singleton String provideG(){
      return ""String_Node_Str"";
    }
  }
;
  @SuppressWarnings(""String_Node_Str"") List<Element> moduleBindings=Elements.getElements(singletonBindings);
  ImmutableMap<Key<?>,Binding<?>> map=indexBindings(moduleBindings);
  assertFalse(Scopes.isSingleton(map.get(a)));
  assertFalse(Scopes.isSingleton(map.get(b)));
  assertTrue(Scopes.isSingleton(map.get(c)));
  assertTrue(Scopes.isSingleton(map.get(d)));
  assertTrue(Scopes.isSingleton(map.get(e)));
  assertTrue(Scopes.isSingleton(map.get(f)));
  assertTrue(Scopes.isSingleton(map.get(g)));
  assertFalse(Scopes.isSingleton(map.get(h)));
  Injector injector=Guice.createInjector(singletonBindings);
  assertTrue(Scopes.isSingleton(injector.getBinding(a)));
  assertTrue(Scopes.isSingleton(injector.getBinding(b)));
  assertTrue(Scopes.isSingleton(injector.getBinding(c)));
  assertTrue(Scopes.isSingleton(injector.getBinding(d)));
  assertTrue(Scopes.isSingleton(injector.getBinding(e)));
  assertTrue(Scopes.isSingleton(injector.getBinding(f)));
  assertTrue(Scopes.isSingleton(injector.getBinding(g)));
  assertTrue(Scopes.isSingleton(injector.getBinding(h)));
}","public void testIsSingletonPositive(){
  final Key<String> a=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> b=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> c=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> d=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> e=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> f=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> g=Key.get(String.class,named(""String_Node_Str""));
  final Key<Object> h=Key.get(Object.class,named(""String_Node_Str""));
  final Key<String> i=Key.get(String.class,named(""String_Node_Str""));
  Module singletonBindings=new AbstractModule(){
    protected void configure(){
      bind(a).to(b);
      bind(b).to(c);
      bind(c).toProvider(Providers.of(""String_Node_Str"")).in(Scopes.SINGLETON);
      bind(d).toInstance(""String_Node_Str"");
      bind(e).toProvider(Providers.of(""String_Node_Str"")).asEagerSingleton();
      bind(f).toProvider(Providers.of(""String_Node_Str"")).in(Singleton.class);
      bind(h).to(AnnotatedSingleton.class);
      install(new PrivateModule(){
        @Override protected void configure(){
          bind(i).toProvider(Providers.of(""String_Node_Str"")).in(Singleton.class);
          expose(i);
        }
      }
);
    }
    @Provides @Named(""String_Node_Str"") @Singleton String provideG(){
      return ""String_Node_Str"";
    }
  }
;
  @SuppressWarnings(""String_Node_Str"") List<Element> moduleBindings=Elements.getElements(singletonBindings);
  ImmutableMap<Key<?>,Binding<?>> map=indexBindings(moduleBindings);
  assertFalse(Scopes.isSingleton(map.get(a)));
  assertFalse(Scopes.isSingleton(map.get(b)));
  assertTrue(Scopes.isSingleton(map.get(c)));
  assertTrue(Scopes.isSingleton(map.get(d)));
  assertTrue(Scopes.isSingleton(map.get(e)));
  assertTrue(Scopes.isSingleton(map.get(f)));
  assertTrue(Scopes.isSingleton(map.get(g)));
  assertFalse(Scopes.isSingleton(map.get(h)));
  assertTrue(Scopes.isSingleton(map.get(i)));
  Injector injector=Guice.createInjector(singletonBindings);
  assertTrue(Scopes.isSingleton(injector.getBinding(a)));
  assertTrue(Scopes.isSingleton(injector.getBinding(b)));
  assertTrue(Scopes.isSingleton(injector.getBinding(c)));
  assertTrue(Scopes.isSingleton(injector.getBinding(d)));
  assertTrue(Scopes.isSingleton(injector.getBinding(e)));
  assertTrue(Scopes.isSingleton(injector.getBinding(f)));
  assertTrue(Scopes.isSingleton(injector.getBinding(g)));
  assertTrue(Scopes.isSingleton(injector.getBinding(h)));
  assertTrue(Scopes.isSingleton(injector.getBinding(i)));
}",0.9219071105630908
60453,"ImmutableMap<Key<?>,Binding<?>> indexBindings(Iterable<Element> elements){
  ImmutableMap.Builder<Key<?>,Binding<?>> builder=ImmutableMap.builder();
  for (  Element element : elements) {
    if (element instanceof Binding) {
      Binding<?> binding=(Binding<?>)element;
      builder.put(binding.getKey(),binding);
    }
  }
  return builder.build();
}","ImmutableMap<Key<?>,Binding<?>> indexBindings(Iterable<Element> elements){
  ImmutableMap.Builder<Key<?>,Binding<?>> builder=ImmutableMap.builder();
  for (  Element element : elements) {
    if (element instanceof Binding) {
      Binding<?> binding=(Binding<?>)element;
      builder.put(binding.getKey(),binding);
    }
 else     if (element instanceof PrivateElements) {
      PrivateElements privateElements=(PrivateElements)element;
      Map<Key<?>,Binding<?>> privateBindings=indexBindings(privateElements.getElements());
      for (      Key<?> exposed : privateElements.getExposedKeys()) {
        builder.put(exposed,privateBindings.get(exposed));
      }
    }
  }
  return builder.build();
}",0.6691871455576559
60454,"protected void configure(){
  bind(a).to(b);
  bind(b).to(c);
  bind(c).toProvider(Providers.of(""String_Node_Str"")).in(Scopes.NO_SCOPE);
  bind(d).toProvider(Providers.of(""String_Node_Str"")).in(CustomScoped.class);
  bindScope(CustomScoped.class,Scopes.NO_SCOPE);
}","@Override protected void configure(){
  bind(f).toProvider(Providers.of(""String_Node_Str"")).in(CustomScoped.class);
  expose(f);
}",0.5822784810126582
60455,"public void testIsSingletonNegative(){
  final Key<String> a=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> b=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> c=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> d=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> e=Key.get(String.class,named(""String_Node_Str""));
  Module singletonBindings=new AbstractModule(){
    protected void configure(){
      bind(a).to(b);
      bind(b).to(c);
      bind(c).toProvider(Providers.of(""String_Node_Str"")).in(Scopes.NO_SCOPE);
      bind(d).toProvider(Providers.of(""String_Node_Str"")).in(CustomScoped.class);
      bindScope(CustomScoped.class,Scopes.NO_SCOPE);
    }
    @Provides @Named(""String_Node_Str"") @CustomScoped String provideE(){
      return ""String_Node_Str"";
    }
  }
;
  @SuppressWarnings(""String_Node_Str"") List<Element> moduleBindings=Elements.getElements(singletonBindings);
  ImmutableMap<Key<?>,Binding<?>> map=indexBindings(moduleBindings);
  assertFalse(Scopes.isSingleton(map.get(a)));
  assertFalse(Scopes.isSingleton(map.get(b)));
  assertFalse(Scopes.isSingleton(map.get(c)));
  assertFalse(Scopes.isSingleton(map.get(d)));
  assertFalse(Scopes.isSingleton(map.get(e)));
  Injector injector=Guice.createInjector(singletonBindings);
  assertFalse(Scopes.isSingleton(injector.getBinding(a)));
  assertFalse(Scopes.isSingleton(injector.getBinding(b)));
  assertFalse(Scopes.isSingleton(injector.getBinding(c)));
  assertFalse(Scopes.isSingleton(injector.getBinding(d)));
  assertFalse(Scopes.isSingleton(injector.getBinding(e)));
}","public void testIsSingletonNegative(){
  final Key<String> a=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> b=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> c=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> d=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> e=Key.get(String.class,named(""String_Node_Str""));
  final Key<String> f=Key.get(String.class,named(""String_Node_Str""));
  Module singletonBindings=new AbstractModule(){
    protected void configure(){
      bind(a).to(b);
      bind(b).to(c);
      bind(c).toProvider(Providers.of(""String_Node_Str"")).in(Scopes.NO_SCOPE);
      bind(d).toProvider(Providers.of(""String_Node_Str"")).in(CustomScoped.class);
      bindScope(CustomScoped.class,Scopes.NO_SCOPE);
      install(new PrivateModule(){
        @Override protected void configure(){
          bind(f).toProvider(Providers.of(""String_Node_Str"")).in(CustomScoped.class);
          expose(f);
        }
      }
);
    }
    @Provides @Named(""String_Node_Str"") @CustomScoped String provideE(){
      return ""String_Node_Str"";
    }
  }
;
  @SuppressWarnings(""String_Node_Str"") List<Element> moduleBindings=Elements.getElements(singletonBindings);
  ImmutableMap<Key<?>,Binding<?>> map=indexBindings(moduleBindings);
  assertFalse(Scopes.isSingleton(map.get(a)));
  assertFalse(Scopes.isSingleton(map.get(b)));
  assertFalse(Scopes.isSingleton(map.get(c)));
  assertFalse(Scopes.isSingleton(map.get(d)));
  assertFalse(Scopes.isSingleton(map.get(e)));
  assertFalse(Scopes.isSingleton(map.get(f)));
  Injector injector=Guice.createInjector(singletonBindings);
  assertFalse(Scopes.isSingleton(injector.getBinding(a)));
  assertFalse(Scopes.isSingleton(injector.getBinding(b)));
  assertFalse(Scopes.isSingleton(injector.getBinding(c)));
  assertFalse(Scopes.isSingleton(injector.getBinding(d)));
  assertFalse(Scopes.isSingleton(injector.getBinding(e)));
  assertFalse(Scopes.isSingleton(injector.getBinding(f)));
}",0.8937344741926581
60456,"@Override public String getPathInfo(){
  if (!isPathInfoComputed()) {
    final int servletPathLength=getServletPath().length();
    pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"").substring(servletPathLength);
    if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
      pathInfo=null;
    }
    pathInfoComputed=true;
  }
  return pathInfo;
}","@Override public String getPathInfo(){
  if (!isPathInfoComputed()) {
    int servletPathLength=getServletPath().length();
    pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
    pathInfo=pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;
    if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
      pathInfo=null;
    }
    pathInfoComputed=true;
  }
  return pathInfo;
}",0.9164835164835164
60457,"/** 
 * Utility that delegates to the actual service method of the servlet wrapped with a contextual request (i.e. with correctly computed path info). We need to suppress deprecation coz we use HttpServletRequestWrapper, which implements deprecated API for backwards compatibility.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) void doService(final ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  HttpServletRequest request=new HttpServletRequestWrapper((HttpServletRequest)servletRequest){
    private String path;
    private boolean pathComputed=false;
    private boolean pathInfoComputed=false;
    private String pathInfo;
    @Override public String getPathInfo(){
      if (!isPathInfoComputed()) {
        final int servletPathLength=getServletPath().length();
        pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"").substring(servletPathLength);
        if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
          pathInfo=null;
        }
        pathInfoComputed=true;
      }
      return pathInfo;
    }
    private boolean isPathInfoComputed(){
      return pathInfoComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    private boolean isPathComputed(){
      return pathComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    @Override public String getServletPath(){
      return computePath();
    }
    @Override public String getPathTranslated(){
      final String info=getPathInfo();
      return (null == info) ? null : getRealPath(info);
    }
    private String computePath(){
      if (!isPathComputed()) {
        String servletPath=super.getServletPath();
        path=patternMatcher.extractPath(servletPath);
        pathComputed=true;
        if (null == path) {
          path=servletPath;
        }
      }
      return path;
    }
  }
;
  httpServlet.get().service(request,servletResponse);
}","/** 
 * Utility that delegates to the actual service method of the servlet wrapped with a contextual request (i.e. with correctly computed path info). We need to suppress deprecation coz we use HttpServletRequestWrapper, which implements deprecated API for backwards compatibility.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) void doService(final ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  HttpServletRequest request=new HttpServletRequestWrapper((HttpServletRequest)servletRequest){
    private String path;
    private boolean pathComputed=false;
    private boolean pathInfoComputed=false;
    private String pathInfo;
    @Override public String getPathInfo(){
      if (!isPathInfoComputed()) {
        int servletPathLength=getServletPath().length();
        pathInfo=getRequestURI().substring(getContextPath().length()).replaceAll(""String_Node_Str"",""String_Node_Str"");
        pathInfo=pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;
        if (""String_Node_Str"".equals(pathInfo) && servletPathLength != 0) {
          pathInfo=null;
        }
        pathInfoComputed=true;
      }
      return pathInfo;
    }
    private boolean isPathInfoComputed(){
      return pathInfoComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    private boolean isPathComputed(){
      return pathComputed && !(null != servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST));
    }
    @Override public String getServletPath(){
      return computePath();
    }
    @Override public String getPathTranslated(){
      final String info=getPathInfo();
      return (null == info) ? null : getRealPath(info);
    }
    private String computePath(){
      if (!isPathComputed()) {
        String servletPath=super.getServletPath();
        path=patternMatcher.extractPath(servletPath);
        pathComputed=true;
        if (null == path) {
          path=servletPath;
        }
      }
      return path;
    }
  }
;
  httpServlet.get().service(request,servletResponse);
}",0.9807599807599808
60458,"@Override protected final void configure(){
  install(new InternalServletModule());
  configureServlets();
  install(filtersModuleBuilder);
  install(servletsModuleBuilder);
}","@Override protected final void configure(){
  checkState(filtersModuleBuilder == null,""String_Node_Str"");
  checkState(servletsModuleBuilder == null,""String_Node_Str"");
  filtersModuleBuilder=new FiltersModuleBuilder();
  servletsModuleBuilder=new ServletsModuleBuilder();
  try {
    install(new InternalServletModule());
    configureServlets();
    install(filtersModuleBuilder);
    install(servletsModuleBuilder);
  }
  finally {
    filtersModuleBuilder=null;
    servletsModuleBuilder=null;
  }
}",0.3008849557522124
60459,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTestSuite(EdslTest.class);
  suite.addTestSuite(FilterDefinitionTest.class);
  suite.addTestSuite(FilterDispatchIntegrationTest.class);
  suite.addTestSuite(FilterPipelineTest.class);
  suite.addTestSuite(ServletTest.class);
  suite.addTestSuite(ServletDefinitionTest.class);
  suite.addTestSuite(ServletDefinitionPathsTest.class);
  suite.addTestSuite(ServletPipelineRequestDispatcherTest.class);
  suite.addTestSuite(ServletDispatchIntegrationTest.class);
  suite.addTestSuite(InvalidScopeBindingTest.class);
  suite.addTestSuite(VarargsFilterDispatchIntegrationTest.class);
  suite.addTestSuite(VarargsServletDispatchIntegrationTest.class);
  suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
  suite.addTestSuite(ExtensionSpiTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTestSuite(EdslTest.class);
  suite.addTestSuite(FilterDefinitionTest.class);
  suite.addTestSuite(FilterDispatchIntegrationTest.class);
  suite.addTestSuite(FilterPipelineTest.class);
  suite.addTestSuite(ServletModuleTest.class);
  suite.addTestSuite(ServletTest.class);
  suite.addTestSuite(ServletDefinitionTest.class);
  suite.addTestSuite(ServletDefinitionPathsTest.class);
  suite.addTestSuite(ServletPipelineRequestDispatcherTest.class);
  suite.addTestSuite(ServletDispatchIntegrationTest.class);
  suite.addTestSuite(InvalidScopeBindingTest.class);
  suite.addTestSuite(VarargsFilterDispatchIntegrationTest.class);
  suite.addTestSuite(VarargsServletDispatchIntegrationTest.class);
  suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
  suite.addTestSuite(ExtensionSpiTest.class);
  return suite;
}",0.9729418537708692
60460,"/** 
 * Returns the interceptors applied to each method, in order of invocation.
 */
ImmutableMap<Method,List<MethodInterceptor>> getMethodInterceptors();","/** 
 * Returns the interceptors applied to each method, in order of invocation.
 */
ImmutableMap<Method,List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();",0.9221556886227544
60461,"public ConstructionProxy<T> create(){
  @SuppressWarnings(""String_Node_Str"") final Constructor<T> constructor=(Constructor<T>)injectionPoint.getMember();
  if (Modifier.isPublic(constructor.getModifiers())) {
    Class<T> classToConstruct=constructor.getDeclaringClass();
    try {
      final net.sf.cglib.reflect.FastConstructor fastConstructor=BytecodeGen.newFastClass(classToConstruct,Visibility.forMember(constructor)).getConstructor(constructor);
      return new ConstructionProxy<T>(){
        @SuppressWarnings(""String_Node_Str"") public T newInstance(        Object... arguments) throws InvocationTargetException {
          return (T)fastConstructor.newInstance(arguments);
        }
        public InjectionPoint getInjectionPoint(){
          return injectionPoint;
        }
        public Constructor<T> getConstructor(){
          return constructor;
        }
        public ImmutableMap<Method,List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors(){
          return ImmutableMap.of();
        }
      }
;
    }
 catch (    net.sf.cglib.core.CodeGenerationException e) {
    }
    if (!Modifier.isPublic(classToConstruct.getModifiers())) {
      constructor.setAccessible(true);
    }
  }
 else {
    constructor.setAccessible(true);
  }
  return new ConstructionProxy<T>(){
    public T newInstance(    Object... arguments) throws InvocationTargetException {
      try {
        return constructor.newInstance(arguments);
      }
 catch (      InstantiationException e) {
        throw new AssertionError(e);
      }
catch (      IllegalAccessException e) {
        throw new AssertionError(e);
      }
    }
    public InjectionPoint getInjectionPoint(){
      return injectionPoint;
    }
    public Constructor<T> getConstructor(){
      return constructor;
    }
    public ImmutableMap<Method,List<MethodInterceptor>> getMethodInterceptors(){
      return ImmutableMap.of();
    }
  }
;
}","public ConstructionProxy<T> create(){
  @SuppressWarnings(""String_Node_Str"") final Constructor<T> constructor=(Constructor<T>)injectionPoint.getMember();
  if (Modifier.isPublic(constructor.getModifiers())) {
    Class<T> classToConstruct=constructor.getDeclaringClass();
    try {
      final net.sf.cglib.reflect.FastConstructor fastConstructor=BytecodeGen.newFastClass(classToConstruct,Visibility.forMember(constructor)).getConstructor(constructor);
      return new ConstructionProxy<T>(){
        @SuppressWarnings(""String_Node_Str"") public T newInstance(        Object... arguments) throws InvocationTargetException {
          return (T)fastConstructor.newInstance(arguments);
        }
        public InjectionPoint getInjectionPoint(){
          return injectionPoint;
        }
        public Constructor<T> getConstructor(){
          return constructor;
        }
        public ImmutableMap<Method,List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors(){
          return ImmutableMap.of();
        }
      }
;
    }
 catch (    net.sf.cglib.core.CodeGenerationException e) {
    }
    if (!Modifier.isPublic(classToConstruct.getModifiers())) {
      constructor.setAccessible(true);
    }
  }
 else {
    constructor.setAccessible(true);
  }
  return new ConstructionProxy<T>(){
    public T newInstance(    Object... arguments) throws InvocationTargetException {
      try {
        return constructor.newInstance(arguments);
      }
 catch (      InstantiationException e) {
        throw new AssertionError(e);
      }
catch (      IllegalAccessException e) {
        throw new AssertionError(e);
      }
    }
    public InjectionPoint getInjectionPoint(){
      return injectionPoint;
    }
    public Constructor<T> getConstructor(){
      return constructor;
    }
    public ImmutableMap<Method,List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors(){
      return ImmutableMap.of();
    }
  }
;
}",0.993312757201646
60462,"public ImmutableMap<Method,List<MethodInterceptor>> getMethodInterceptors(){
  return ImmutableMap.of();
}","public ImmutableMap<Method,List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors(){
  return ImmutableMap.of();
}",0.8907563025210085
60463,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(DuplicateBindingsTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(MoreTypesTest.class);
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(NamedEquivalanceTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(DuplicateBindingsTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(MoreTypesTest.class);
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(NamedEquivalanceTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(com.google.inject.internal.ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}",0.9958997722095672
60464,"@Override protected void setUp() throws Exception {
  assertTrue(failMsg(),new File(BUILD_DIR).isDirectory());
  assertTrue(failMsg(),new File(GUICE_JAR).isFile());
  assertTrue(failMsg(),new File(AOPALLIANCE_JAR).isFile());
  assertTrue(failMsg(),new File(JAVAX_INJECT_JAR).isFile());
  Properties instructions=new Properties();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"");
  buildBundle(""String_Node_Str"",instructions,AOPALLIANCE_JAR);
  instructions.clear();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"");
  buildBundle(""String_Node_Str"",instructions,JAVAX_INJECT_JAR);
  instructions.clear();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  instructions.setProperty(""String_Node_Str"",OSGiTestActivator.class.getName());
  instructions.setProperty(""String_Node_Str"",OSGiTestActivator.class.getPackage().getName());
  buildBundle(""String_Node_Str"",instructions,BUILD_TEST_DIR);
  instructions.clear();
}","@Override protected void setUp() throws Exception {
  assertTrue(failMsg(),new File(BUILD_DIR).isDirectory());
  assertTrue(failMsg(),new File(GUICE_JAR).isFile());
  assertTrue(failMsg(),new File(AOPALLIANCE_JAR).isFile());
  assertTrue(failMsg(),new File(JAVAX_INJECT_JAR).isFile());
  Properties instructions=new Properties();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"");
  buildBundle(""String_Node_Str"",instructions,AOPALLIANCE_JAR);
  instructions.clear();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"");
  buildBundle(""String_Node_Str"",instructions,JAVAX_INJECT_JAR);
  instructions.clear();
  instructions.setProperty(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  instructions.setProperty(""String_Node_Str"",OSGiTestActivator.class.getName());
  instructions.setProperty(""String_Node_Str"",OSGiTestActivator.class.getPackage().getName());
  buildBundle(""String_Node_Str"",instructions,BUILD_TEST_DIR);
  instructions.clear();
}",0.9899193548387096
60465,"public Object invoke(MethodInvocation mi) throws Throwable {
  return mi.proceed();
}","public Object invoke(org.aopalliance.intercept.MethodInvocation mi) throws Throwable {
  return mi.proceed();
}",0.8673469387755102
60466,"@Override protected void configure(){
  bindInterceptor(new AbstractMatcher<Class<?>>(){
    public boolean matches(    Class<?> clazz){
      try {
        int clazzModifiers=clazz.getModifiers();
        int ctorModifiers=clazz.getConstructor().getModifiers();
        return (clazzModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0 && (ctorModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
      }
 catch (      NoSuchMethodException e) {
        return false;
      }
    }
  }
,new AbstractMatcher<Method>(){
    public boolean matches(    Method method){
      int methodModifiers=method.getModifiers();
      return (methodModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
    }
  }
,new MethodInterceptor(){
    public Object invoke(    MethodInvocation mi) throws Throwable {
      return mi.proceed();
    }
  }
);
}","@Override protected void configure(){
  bindInterceptor(new AbstractMatcher<Class<?>>(){
    public boolean matches(    Class<?> clazz){
      try {
        int clazzModifiers=clazz.getModifiers();
        int ctorModifiers=clazz.getConstructor().getModifiers();
        return (clazzModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0 && (ctorModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
      }
 catch (      NoSuchMethodException e) {
        return false;
      }
    }
  }
,new AbstractMatcher<Method>(){
    public boolean matches(    Method method){
      int methodModifiers=method.getModifiers();
      return (methodModifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;
    }
  }
,new org.aopalliance.intercept.MethodInterceptor(){
    public Object invoke(    org.aopalliance.intercept.MethodInvocation mi) throws Throwable {
      return mi.proceed();
    }
  }
);
}",0.9702517162471396
60467,"public final void testAsyncServiceLifecycle() throws InterruptedException {
  ExecutorService executor=Executors.newSingleThreadExecutor();
  final CountDownLatch latch=new CountDownLatch(2);
  AsyncService service=new AsyncService(executor){
    @Override protected void onStart(){
      assertEquals(2,latch.getCount());
      latch.countDown();
    }
    @Override protected void onStop(){
      assertEquals(1,latch.getCount());
      latch.countDown();
    }
  }
;
  service.start();
  latch.await(2,TimeUnit.SECONDS);
  service.stop();
  latch.await(2,TimeUnit.SECONDS);
  executor.shutdown();
  assertEquals(0,latch.getCount());
}","public final void testAsyncServiceLifecycle() throws InterruptedException {
  ExecutorService executor=Executors.newSingleThreadExecutor();
  final CountDownLatch startLatch=new CountDownLatch(1);
  final CountDownLatch stopLatch=new CountDownLatch(1);
  AsyncService service=new AsyncService(executor){
    @Override protected void onStart(){
      assertEquals(1,startLatch.getCount());
      assertEquals(1,stopLatch.getCount());
      startLatch.countDown();
    }
    @Override protected void onStop(){
      assertEquals(0,startLatch.getCount());
      assertEquals(1,stopLatch.getCount());
      stopLatch.countDown();
    }
  }
;
  service.start();
  assertTrue(startLatch.await(2,TimeUnit.SECONDS));
  service.stop();
  assertTrue(stopLatch.await(2,TimeUnit.SECONDS));
  executor.shutdown();
  assertEquals(0,startLatch.getCount());
  assertEquals(0,stopLatch.getCount());
}",0.7960526315789473
60468,"private RealMultibinder(Binder binder,TypeLiteral<T> elementType,String setName,Key<Set<T>> setKey){
  this.binder=checkNotNull(binder,""String_Node_Str"");
  this.elementType=checkNotNull(elementType,""String_Node_Str"");
  this.setName=checkNotNull(setName,""String_Node_Str"");
  this.setKey=checkNotNull(setKey,""String_Node_Str"");
  this.permitDuplicatesKey=Key.get(Boolean.class,named(toString() + ""String_Node_Str""));
}","private RealMultibinder(Binder binder,TypeLiteral<T> elementType,Key<Set<T>> setKey){
  this.binder=checkNotNull(binder,""String_Node_Str"");
  this.elementType=checkNotNull(elementType,""String_Node_Str"");
  this.setKey=checkNotNull(setKey,""String_Node_Str"");
  this.setName=nameOf(setKey);
  this.permitDuplicatesKey=Key.get(Boolean.class,named(toString() + ""String_Node_Str""));
}",0.8120300751879699
60469,"protected void configure(){
  MapBinder<String,String> multibinder=MapBinder.newMapBinder(binder(),String.class,String.class);
  multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
  multibinder.addBinding(""String_Node_Str"").toInstance(""String_Node_Str"");
  multibinder.permitDuplicates();
}","@Override public void configure(){
  MapBinder<Integer,Integer> mb1=MapBinder.newMapBinder(binder(),Integer.class,Integer.class,Marker.class);
  MapBinder<Integer,Integer> mb2=MapBinder.newMapBinder(binder(),Integer.class,Integer.class,marker);
  mb1.addBinding(1).toInstance(1);
  mb2.addBinding(2).toInstance(2);
  assertEquals(mb1,mb2);
}",0.119448698315467
60470,"protected void configure(){
  Multibinder<String> multibinder=Multibinder.newSetBinder(binder(),String.class);
  multibinder.addBinding().toInstance(""String_Node_Str"");
  multibinder.addBinding().toInstance(""String_Node_Str"");
  multibinder.permitDuplicates();
}","@Override public void configure(){
  Multibinder<Integer> mb1=Multibinder.newSetBinder(binder(),Integer.class,Marker.class);
  Multibinder<Integer> mb2=Multibinder.newSetBinder(binder(),Integer.class,marker);
  mb1.addBinding().toInstance(1);
  mb2.addBinding().toInstance(2);
  assertEquals(mb1,mb2);
}",0.3504424778761062
60471,"/** 
 * Safely gets the dependencies of possibly not initialized bindings. 
 */
@SuppressWarnings(""String_Node_Str"") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding){
  if (binding instanceof ConstructorBindingImpl) {
    return ((ConstructorBindingImpl)binding).getInternalDependencies();
  }
 else {
    return ((HasDependencies)binding).getDependencies();
  }
}","/** 
 * Safely gets the dependencies of possibly not initialized bindings. 
 */
@SuppressWarnings(""String_Node_Str"") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding){
  if (binding instanceof ConstructorBindingImpl) {
    return ((ConstructorBindingImpl)binding).getInternalDependencies();
  }
 else   if (binding instanceof HasDependencies) {
    return ((HasDependencies)binding).getDependencies();
  }
 else {
    return ImmutableSet.of();
  }
}",0.9027777777777778
60472,"/** 
 * When we're building the binding for A, we temporarily insert that binding to support circular dependencies. And so we can successfully create a binding for B. But later, when the binding for A ultimately fails, we need to clean up the dependent binding for B. The test loops through linked bindings & bindings with constructor & member injections, to make sure that all are cleaned up and traversed.  It also makes sure we don't touch explicit bindings.
 */
public void testCircularJitBindingsLeaveNoResidue(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(Valid.class);
      bind(Valid2.class);
    }
  }
);
  Binding v1=injector.getBinding(Valid.class);
  Binding v2=injector.getBinding(Valid2.class);
  Binding jv1=injector.getBinding(JitValid.class);
  Binding jv2=injector.getBinding(JitValid2.class);
  assertFailure(injector,Invalid.class);
  assertFailure(injector,InvalidLinked.class);
  assertFailure(injector,InvalidLinkedImpl.class);
  assertFailure(injector,InvalidLinked2.class);
  assertFailure(injector,InvalidLinked2Impl.class);
  assertFailure(injector,Invalid2.class);
  assertSame(v1,injector.getBinding(Valid.class));
  assertSame(v2,injector.getBinding(Valid2.class));
  assertSame(jv1,injector.getBinding(JitValid.class));
  assertSame(jv2,injector.getBinding(JitValid2.class));
}","/** 
 * When we're building the binding for A, we temporarily insert that binding to support circular dependencies. And so we can successfully create a binding for B. But later, when the binding for A ultimately fails, we need to clean up the dependent binding for B. The test loops through linked bindings & bindings with constructor & member injections, to make sure that all are cleaned up and traversed.  It also makes sure we don't touch explicit bindings.
 */
public void testCircularJitBindingsLeaveNoResidue(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(Valid.class);
      bind(Valid2.class);
    }
  }
);
  Binding v1=injector.getBinding(Valid.class);
  Binding v2=injector.getBinding(Valid2.class);
  Binding jv1=injector.getBinding(JitValid.class);
  Binding jv2=injector.getBinding(JitValid2.class);
  assertFailure(injector,Invalid.class);
  assertFailure(injector,InvalidLinked.class);
  assertFailure(injector,InvalidLinkedImpl.class);
  assertFailure(injector,InvalidLinked2.class);
  assertFailure(injector,InvalidLinked2Impl.class);
  assertFailure(injector,InvalidProvidedBy.class);
  assertFailure(injector,InvalidProvidedByProvider.class);
  assertFailure(injector,InvalidProvidedBy2.class);
  assertFailure(injector,InvalidProvidedBy2Provider.class);
  assertFailure(injector,Invalid2.class);
  assertSame(v1,injector.getBinding(Valid.class));
  assertSame(v2,injector.getBinding(Valid2.class));
  assertSame(jv1,injector.getBinding(JitValid.class));
  assertSame(jv2,injector.getBinding(JitValid2.class));
}",0.925653047555258
60473,"public void configure(Binder binder){
  final ImmutableSet<Dependency<?>> dependencies=ImmutableSet.<Dependency<?>>of(Dependency.get(entrySetKey));
  final Provider<Set<Entry<K,Provider<V>>>> entrySetProvider=binder.getProvider(entrySetKey);
  binder.bind(providerMultimapKey).toProvider(new ProviderWithDependencies<Map<K,Set<Provider<V>>>>(){
    private Map<K,Set<Provider<V>>> providerMultimap;
    @SuppressWarnings(""String_Node_Str"") @Inject void initialize(    Injector injector){
      Map<K,ImmutableSet.Builder<Provider<V>>> providerMultimapMutable=new LinkedHashMap<K,ImmutableSet.Builder<Provider<V>>>();
      for (      Entry<K,Provider<V>> entry : entrySetProvider.get()) {
        if (!providerMultimapMutable.containsKey(entry.getKey())) {
          providerMultimapMutable.put(entry.getKey(),ImmutableSet.<Provider<V>>builder());
        }
        providerMultimapMutable.get(entry.getKey()).add(entry.getValue());
      }
      ImmutableMap.Builder<K,Set<Provider<V>>> providerMultimapBuilder=ImmutableMap.builder();
      for (      Entry<K,ImmutableSet.Builder<Provider<V>>> entry : providerMultimapMutable.entrySet()) {
        providerMultimapBuilder.put(entry.getKey(),entry.getValue().build());
      }
      providerMultimap=providerMultimapBuilder.build();
    }
    public Map<K,Set<Provider<V>>> get(){
      return providerMultimap;
    }
    public Set<Dependency<?>> getDependencies(){
      return dependencies;
    }
  }
);
  final Provider<Map<K,Set<Provider<V>>>> multimapProvider=binder.getProvider(providerMultimapKey);
  binder.bind(multimapKey).toProvider(new ProviderWithDependencies<Map<K,Set<V>>>(){
    public Map<K,Set<V>> get(){
      ImmutableMap.Builder<K,Set<V>> multimapBuilder=ImmutableMap.builder();
      for (      Entry<K,Set<Provider<V>>> entry : multimapProvider.get().entrySet()) {
        K key=entry.getKey();
        ImmutableSet.Builder<V> valuesBuilder=ImmutableSet.builder();
        for (        Provider<V> valueProvider : entry.getValue()) {
          V value=valueProvider.get();
          checkConfiguration(value != null,""String_Node_Str"",key);
          valuesBuilder.add(value);
        }
        multimapBuilder.put(key,valuesBuilder.build());
      }
      return multimapBuilder.build();
    }
    public Set<Dependency<?>> getDependencies(){
      return dependencies;
    }
  }
);
}","public void configure(Binder binder){
  final ImmutableSet<Dependency<?>> dependencies=ImmutableSet.<Dependency<?>>of(Dependency.get(entrySetKey));
  final Provider<Set<Entry<K,Provider<V>>>> entrySetProvider=binder.getProvider(entrySetKey);
  binder.bind(providerMultimapKey).toProvider(new RealMapBinderProviderWithDependencies<Map<K,Set<Provider<V>>>>(multimapKey){
    private Map<K,Set<Provider<V>>> providerMultimap;
    @SuppressWarnings(""String_Node_Str"") @Inject void initialize(    Injector injector){
      Map<K,ImmutableSet.Builder<Provider<V>>> providerMultimapMutable=new LinkedHashMap<K,ImmutableSet.Builder<Provider<V>>>();
      for (      Entry<K,Provider<V>> entry : entrySetProvider.get()) {
        if (!providerMultimapMutable.containsKey(entry.getKey())) {
          providerMultimapMutable.put(entry.getKey(),ImmutableSet.<Provider<V>>builder());
        }
        providerMultimapMutable.get(entry.getKey()).add(entry.getValue());
      }
      ImmutableMap.Builder<K,Set<Provider<V>>> providerMultimapBuilder=ImmutableMap.builder();
      for (      Entry<K,ImmutableSet.Builder<Provider<V>>> entry : providerMultimapMutable.entrySet()) {
        providerMultimapBuilder.put(entry.getKey(),entry.getValue().build());
      }
      providerMultimap=providerMultimapBuilder.build();
    }
    public Map<K,Set<Provider<V>>> get(){
      return providerMultimap;
    }
    public Set<Dependency<?>> getDependencies(){
      return dependencies;
    }
  }
);
  final Provider<Map<K,Set<Provider<V>>>> multimapProvider=binder.getProvider(providerMultimapKey);
  binder.bind(multimapKey).toProvider(new RealMapBinderProviderWithDependencies<Map<K,Set<V>>>(multimapKey){
    public Map<K,Set<V>> get(){
      ImmutableMap.Builder<K,Set<V>> multimapBuilder=ImmutableMap.builder();
      for (      Entry<K,Set<Provider<V>>> entry : multimapProvider.get().entrySet()) {
        K key=entry.getKey();
        ImmutableSet.Builder<V> valuesBuilder=ImmutableSet.builder();
        for (        Provider<V> valueProvider : entry.getValue()) {
          V value=valueProvider.get();
          checkConfiguration(value != null,""String_Node_Str"",key);
          valuesBuilder.add(value);
        }
        multimapBuilder.put(key,valuesBuilder.build());
      }
      return multimapBuilder.build();
    }
    public Set<Dependency<?>> getDependencies(){
      return dependencies;
    }
  }
);
}",0.989928661351238
60474,"@Override public boolean equals(Object obj){
  return obj instanceof Map.Entry && key.equals(((Map.Entry<?,?>)obj).getKey()) && value.equals(((Map.Entry<?,?>)obj).getValue());
}","@Override public boolean equals(Object obj){
  return this.getClass() == obj.getClass() && equality.equals(((RealMapBinderProviderWithDependencies<?>)obj).equality);
}",0.5755813953488372
60475,"/** 
 * We tolerate duplicate bindings only if one exposes the other.
 * @param original the binding in the parent injector (candidate for an exposing binding)
 * @param binding the binding to check (candidate for the exposed binding)
 */
private boolean isOkayDuplicate(Binding<?> original,BindingImpl<?> binding){
  if (original instanceof ExposedBindingImpl) {
    ExposedBindingImpl exposed=(ExposedBindingImpl)original;
    InjectorImpl exposedFrom=(InjectorImpl)exposed.getPrivateElements().getInjector();
    return (exposedFrom == binding.getInjector());
  }
  return false;
}","/** 
 * We tolerate duplicate bindings if one exposes the other or if the two bindings are considered duplicates (see   {@link Bindings#areDuplicates(BindingImpl,BindingImpl)}. 
 * @param original the binding in the parent injector (candidate for an exposing binding)
 * @param binding the binding to check (candidate for the exposed binding)
 */
private boolean isOkayDuplicate(BindingImpl<?> original,BindingImpl<?> binding,State state){
  if (original instanceof ExposedBindingImpl) {
    ExposedBindingImpl exposed=(ExposedBindingImpl)original;
    InjectorImpl exposedFrom=(InjectorImpl)exposed.getPrivateElements().getInjector();
    return (exposedFrom == binding.getInjector());
  }
 else {
    original=(BindingImpl<?>)state.getExplicitBindingsThisLevel().get(binding.getKey());
    if (original == null) {
      return false;
    }
 else {
      return original.equals(binding);
    }
  }
}",0.7749326145552561
60476,"private void putBinding(BindingImpl<?> binding){
  Key<?> key=binding.getKey();
  Class<?> rawType=key.getTypeLiteral().getRawType();
  if (FORBIDDEN_TYPES.contains(rawType)) {
    errors.cannotBindToGuiceType(rawType.getSimpleName());
    return;
  }
  Binding<?> original=injector.state.getExplicitBinding(key);
  if (original != null && !isOkayDuplicate(original,binding)) {
    errors.bindingAlreadySet(key,original.getSource());
    return;
  }
  injector.state.parent().blacklist(key);
  injector.state.putBinding(key,binding);
}","private void putBinding(BindingImpl<?> binding){
  Key<?> key=binding.getKey();
  Class<?> rawType=key.getTypeLiteral().getRawType();
  if (FORBIDDEN_TYPES.contains(rawType)) {
    errors.cannotBindToGuiceType(rawType.getSimpleName());
    return;
  }
  BindingImpl<?> original=injector.state.getExplicitBinding(key);
  if (original != null) {
    try {
      if (!isOkayDuplicate(original,binding,injector.state)) {
        errors.bindingAlreadySet(key,original.getSource());
        return;
      }
    }
 catch (    Throwable t) {
      errors.errorCheckingDuplicateBinding(key,original.getSource(),t);
      return;
    }
  }
  injector.state.parent().blacklist(key);
  injector.state.putBinding(key,binding);
}",0.8384
60477,"@Override public void configure(){
  final List<Element> elements=Elements.getElements(baseModules);
  final List<Element> overrideElements=Elements.getElements(overrides);
  final Set<Key<?>> overriddenKeys=Sets.newHashSet();
  final Set<Class<? extends Annotation>> overridesScopeAnnotations=Sets.newHashSet();
  new ModuleWriter(binder()){
    @Override public <T>Void visit(    Binding<T> binding){
      overriddenKeys.add(binding.getKey());
      return super.visit(binding);
    }
    @Override public Void visit(    ScopeBinding scopeBinding){
      overridesScopeAnnotations.add(scopeBinding.getAnnotationType());
      return super.visit(scopeBinding);
    }
    @Override public Void visit(    PrivateElements privateElements){
      overriddenKeys.addAll(privateElements.getExposedKeys());
      return super.visit(privateElements);
    }
  }
.writeAll(overrideElements);
  final Map<Scope,Object> scopeInstancesInUse=Maps.newHashMap();
  final List<ScopeBinding> scopeBindings=Lists.newArrayList();
  new ModuleWriter(binder()){
    @Override public <T>Void visit(    Binding<T> binding){
      if (!overriddenKeys.remove(binding.getKey())) {
        super.visit(binding);
        Scope scope=getScopeInstanceOrNull(binding);
        if (scope != null) {
          scopeInstancesInUse.put(scope,binding.getSource());
        }
      }
      return null;
    }
    void rewrite(    Binder binder,    PrivateElements privateElements,    Set<Key<?>> keysToSkip){
      PrivateBinder privateBinder=binder.withSource(privateElements.getSource()).newPrivateBinder();
      Set<Key<?>> skippedExposes=Sets.newHashSet();
      for (      Key<?> key : privateElements.getExposedKeys()) {
        if (keysToSkip.remove(key)) {
          skippedExposes.add(key);
        }
 else {
          privateBinder.withSource(privateElements.getExposedSource(key)).expose(key);
        }
      }
      for (      Element element : privateElements.getElements()) {
        if (element instanceof Binding && skippedExposes.remove(((Binding)element).getKey())) {
          continue;
        }
        if (element instanceof PrivateElements) {
          rewrite(privateBinder,(PrivateElements)element,skippedExposes);
          continue;
        }
        element.applyTo(privateBinder);
      }
    }
    @Override public Void visit(    PrivateElements privateElements){
      rewrite(binder,privateElements,overriddenKeys);
      return null;
    }
    @Override public Void visit(    ScopeBinding scopeBinding){
      scopeBindings.add(scopeBinding);
      return null;
    }
  }
.writeAll(elements);
  new ModuleWriter(binder()){
    @Override public Void visit(    ScopeBinding scopeBinding){
      if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {
        super.visit(scopeBinding);
      }
 else {
        Object source=scopeInstancesInUse.get(scopeBinding.getScope());
        if (source != null) {
          binder().withSource(source).addError(""String_Node_Str"",scopeBinding.getAnnotationType().getSimpleName());
        }
      }
      return null;
    }
  }
.writeAll(scopeBindings);
}","@Override public void configure(){
  final LinkedHashSet<Element> elements=new LinkedHashSet<Element>(Elements.getElements(baseModules));
  final List<Element> overrideElements=Elements.getElements(overrides);
  final Set<Key<?>> overriddenKeys=Sets.newHashSet();
  final Set<Class<? extends Annotation>> overridesScopeAnnotations=Sets.newHashSet();
  new ModuleWriter(binder()){
    @Override public <T>Void visit(    Binding<T> binding){
      overriddenKeys.add(binding.getKey());
      return super.visit(binding);
    }
    @Override public Void visit(    ScopeBinding scopeBinding){
      overridesScopeAnnotations.add(scopeBinding.getAnnotationType());
      return super.visit(scopeBinding);
    }
    @Override public Void visit(    PrivateElements privateElements){
      overriddenKeys.addAll(privateElements.getExposedKeys());
      return super.visit(privateElements);
    }
  }
.writeAll(overrideElements);
  final Map<Scope,Object> scopeInstancesInUse=Maps.newHashMap();
  final List<ScopeBinding> scopeBindings=Lists.newArrayList();
  new ModuleWriter(binder()){
    @Override public <T>Void visit(    Binding<T> binding){
      if (!overriddenKeys.remove(binding.getKey())) {
        super.visit(binding);
        Scope scope=getScopeInstanceOrNull(binding);
        if (scope != null) {
          scopeInstancesInUse.put(scope,binding.getSource());
        }
      }
      return null;
    }
    void rewrite(    Binder binder,    PrivateElements privateElements,    Set<Key<?>> keysToSkip){
      PrivateBinder privateBinder=binder.withSource(privateElements.getSource()).newPrivateBinder();
      Set<Key<?>> skippedExposes=Sets.newHashSet();
      for (      Key<?> key : privateElements.getExposedKeys()) {
        if (keysToSkip.remove(key)) {
          skippedExposes.add(key);
        }
 else {
          privateBinder.withSource(privateElements.getExposedSource(key)).expose(key);
        }
      }
      for (      Element element : privateElements.getElements()) {
        if (element instanceof Binding && skippedExposes.remove(((Binding)element).getKey())) {
          continue;
        }
        if (element instanceof PrivateElements) {
          rewrite(privateBinder,(PrivateElements)element,skippedExposes);
          continue;
        }
        element.applyTo(privateBinder);
      }
    }
    @Override public Void visit(    PrivateElements privateElements){
      rewrite(binder,privateElements,overriddenKeys);
      return null;
    }
    @Override public Void visit(    ScopeBinding scopeBinding){
      scopeBindings.add(scopeBinding);
      return null;
    }
  }
.writeAll(elements);
  new ModuleWriter(binder()){
    @Override public Void visit(    ScopeBinding scopeBinding){
      if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {
        super.visit(scopeBinding);
      }
 else {
        Object source=scopeInstancesInUse.get(scopeBinding.getScope());
        if (source != null) {
          binder().withSource(source).addError(""String_Node_Str"",scopeBinding.getAnnotationType().getSimpleName());
        }
      }
      return null;
    }
  }
.writeAll(scopeBindings);
}",0.9937669809813008
60478,"public Module with(final Iterable<? extends Module> overrides){
  return new AbstractModule(){
    @Override public void configure(){
      final List<Element> elements=Elements.getElements(baseModules);
      final List<Element> overrideElements=Elements.getElements(overrides);
      final Set<Key<?>> overriddenKeys=Sets.newHashSet();
      final Set<Class<? extends Annotation>> overridesScopeAnnotations=Sets.newHashSet();
      new ModuleWriter(binder()){
        @Override public <T>Void visit(        Binding<T> binding){
          overriddenKeys.add(binding.getKey());
          return super.visit(binding);
        }
        @Override public Void visit(        ScopeBinding scopeBinding){
          overridesScopeAnnotations.add(scopeBinding.getAnnotationType());
          return super.visit(scopeBinding);
        }
        @Override public Void visit(        PrivateElements privateElements){
          overriddenKeys.addAll(privateElements.getExposedKeys());
          return super.visit(privateElements);
        }
      }
.writeAll(overrideElements);
      final Map<Scope,Object> scopeInstancesInUse=Maps.newHashMap();
      final List<ScopeBinding> scopeBindings=Lists.newArrayList();
      new ModuleWriter(binder()){
        @Override public <T>Void visit(        Binding<T> binding){
          if (!overriddenKeys.remove(binding.getKey())) {
            super.visit(binding);
            Scope scope=getScopeInstanceOrNull(binding);
            if (scope != null) {
              scopeInstancesInUse.put(scope,binding.getSource());
            }
          }
          return null;
        }
        void rewrite(        Binder binder,        PrivateElements privateElements,        Set<Key<?>> keysToSkip){
          PrivateBinder privateBinder=binder.withSource(privateElements.getSource()).newPrivateBinder();
          Set<Key<?>> skippedExposes=Sets.newHashSet();
          for (          Key<?> key : privateElements.getExposedKeys()) {
            if (keysToSkip.remove(key)) {
              skippedExposes.add(key);
            }
 else {
              privateBinder.withSource(privateElements.getExposedSource(key)).expose(key);
            }
          }
          for (          Element element : privateElements.getElements()) {
            if (element instanceof Binding && skippedExposes.remove(((Binding)element).getKey())) {
              continue;
            }
            if (element instanceof PrivateElements) {
              rewrite(privateBinder,(PrivateElements)element,skippedExposes);
              continue;
            }
            element.applyTo(privateBinder);
          }
        }
        @Override public Void visit(        PrivateElements privateElements){
          rewrite(binder,privateElements,overriddenKeys);
          return null;
        }
        @Override public Void visit(        ScopeBinding scopeBinding){
          scopeBindings.add(scopeBinding);
          return null;
        }
      }
.writeAll(elements);
      new ModuleWriter(binder()){
        @Override public Void visit(        ScopeBinding scopeBinding){
          if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {
            super.visit(scopeBinding);
          }
 else {
            Object source=scopeInstancesInUse.get(scopeBinding.getScope());
            if (source != null) {
              binder().withSource(source).addError(""String_Node_Str"",scopeBinding.getAnnotationType().getSimpleName());
            }
          }
          return null;
        }
      }
.writeAll(scopeBindings);
    }
    private Scope getScopeInstanceOrNull(    Binding<?> binding){
      return binding.acceptScopingVisitor(new DefaultBindingScopingVisitor<Scope>(){
        public Scope visitScope(        Scope scope){
          return scope;
        }
      }
);
    }
  }
;
}","public Module with(final Iterable<? extends Module> overrides){
  return new AbstractModule(){
    @Override public void configure(){
      final LinkedHashSet<Element> elements=new LinkedHashSet<Element>(Elements.getElements(baseModules));
      final List<Element> overrideElements=Elements.getElements(overrides);
      final Set<Key<?>> overriddenKeys=Sets.newHashSet();
      final Set<Class<? extends Annotation>> overridesScopeAnnotations=Sets.newHashSet();
      new ModuleWriter(binder()){
        @Override public <T>Void visit(        Binding<T> binding){
          overriddenKeys.add(binding.getKey());
          return super.visit(binding);
        }
        @Override public Void visit(        ScopeBinding scopeBinding){
          overridesScopeAnnotations.add(scopeBinding.getAnnotationType());
          return super.visit(scopeBinding);
        }
        @Override public Void visit(        PrivateElements privateElements){
          overriddenKeys.addAll(privateElements.getExposedKeys());
          return super.visit(privateElements);
        }
      }
.writeAll(overrideElements);
      final Map<Scope,Object> scopeInstancesInUse=Maps.newHashMap();
      final List<ScopeBinding> scopeBindings=Lists.newArrayList();
      new ModuleWriter(binder()){
        @Override public <T>Void visit(        Binding<T> binding){
          if (!overriddenKeys.remove(binding.getKey())) {
            super.visit(binding);
            Scope scope=getScopeInstanceOrNull(binding);
            if (scope != null) {
              scopeInstancesInUse.put(scope,binding.getSource());
            }
          }
          return null;
        }
        void rewrite(        Binder binder,        PrivateElements privateElements,        Set<Key<?>> keysToSkip){
          PrivateBinder privateBinder=binder.withSource(privateElements.getSource()).newPrivateBinder();
          Set<Key<?>> skippedExposes=Sets.newHashSet();
          for (          Key<?> key : privateElements.getExposedKeys()) {
            if (keysToSkip.remove(key)) {
              skippedExposes.add(key);
            }
 else {
              privateBinder.withSource(privateElements.getExposedSource(key)).expose(key);
            }
          }
          for (          Element element : privateElements.getElements()) {
            if (element instanceof Binding && skippedExposes.remove(((Binding)element).getKey())) {
              continue;
            }
            if (element instanceof PrivateElements) {
              rewrite(privateBinder,(PrivateElements)element,skippedExposes);
              continue;
            }
            element.applyTo(privateBinder);
          }
        }
        @Override public Void visit(        PrivateElements privateElements){
          rewrite(binder,privateElements,overriddenKeys);
          return null;
        }
        @Override public Void visit(        ScopeBinding scopeBinding){
          scopeBindings.add(scopeBinding);
          return null;
        }
      }
.writeAll(elements);
      new ModuleWriter(binder()){
        @Override public Void visit(        ScopeBinding scopeBinding){
          if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {
            super.visit(scopeBinding);
          }
 else {
            Object source=scopeInstancesInUse.get(scopeBinding.getScope());
            if (source != null) {
              binder().withSource(source).addError(""String_Node_Str"",scopeBinding.getAnnotationType().getSimpleName());
            }
          }
          return null;
        }
      }
.writeAll(scopeBindings);
    }
    private Scope getScopeInstanceOrNull(    Binding<?> binding){
      return binding.acceptScopingVisitor(new DefaultBindingScopingVisitor<Scope>(){
        public Scope visitScope(        Scope scope){
          return scope;
        }
      }
);
    }
  }
;
}",0.9936189608021878
60479,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(MoreTypesTest.class);
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(NamedEquivalanceTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(DuplicateBindingsTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(MoreTypesTest.class);
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(NamedEquivalanceTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}",0.992162286768096
60480,"@Override protected void configure(){
  bindScope(RequestScoped.class,REQUEST);
  bindScope(SessionScoped.class,SESSION);
  bind(ServletRequest.class).to(HttpServletRequest.class);
  bind(ServletResponse.class).to(HttpServletResponse.class);
  requestStaticInjection(GuiceFilter.class);
  bind(ManagedServletPipeline.class);
  bind(FilterPipeline.class).to(ManagedFilterPipeline.class).asEagerSingleton();
}","@Override protected void configure(){
  bindScope(RequestScoped.class,REQUEST);
  bindScope(SessionScoped.class,SESSION);
  bind(ServletRequest.class).to(HttpServletRequest.class);
  bind(ServletResponse.class).to(HttpServletResponse.class);
  requestStaticInjection(GuiceFilter.class);
  bind(ManagedFilterPipeline.class);
  bind(ManagedServletPipeline.class);
  bind(FilterPipeline.class).to(ManagedFilterPipeline.class).asEagerSingleton();
}",0.9400705052878966
60481,"/** 
 * Gets the strategy for an annotation type.
 */
static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType){
  checkNotNull(annotationType,""String_Node_Str"");
  ensureRetainedAtRuntime(annotationType);
  ensureIsBindingAnnotation(annotationType);
  return new AnnotationTypeStrategy(annotationType,null);
}","/** 
 * Gets the strategy for an annotation type.
 */
static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType){
  checkNotNull(annotationType,""String_Node_Str"");
  ensureRetainedAtRuntime(annotationType);
  ensureIsBindingAnnotation(annotationType);
  return new AnnotationTypeStrategy(Annotations.canonicalizeIfNamed(annotationType),null);
}",0.912981455064194
60482,"/** 
 * If the annotation is an instance of   {@code javax.inject.Named} or {@code com.google.inject.name.Named}, return a canonicalized instance that will be equal to instances of either that have the same value. Returns the given annotation otherwise.
 */
public static Annotation canonicalizeIfNamed(Annotation annotation){
  if (annotation instanceof javax.inject.Named) {
    return Names.named(((javax.inject.Named)annotation).value());
  }
 else {
    return annotation;
  }
}","/** 
 * If the annotation is the class   {@code javax.inject.Named}, canonicalizes to com.google.guice.name.Named. Returns the given annotation class otherwise.
 */
public static Class<? extends Annotation> canonicalizeIfNamed(Class<? extends Annotation> annotationType){
  if (annotationType == javax.inject.Named.class) {
    return Named.class;
  }
 else {
    return annotationType;
  }
}",0.56
60483,"public void testKeysCreatedWithDifferentTypesAreEqual(){
  assertEquals(keyForAnnotation(new GuiceNamed(""String_Node_Str"")),keyForAnnotation(new JsrNamed(""String_Node_Str"")));
  assertEquals(keyForAnnotation(Names.named(""String_Node_Str"")),keyForAnnotation(new GuiceNamed(""String_Node_Str"")));
  assertEquals(keyForAnnotation(Names.named(""String_Node_Str"")),keyForAnnotation(new JsrNamed(""String_Node_Str"")));
}","public void testKeysCreatedWithDifferentTypesAreEqual(){
  assertEquals(keyForAnnotation(new GuiceNamed(""String_Node_Str"")),keyForAnnotation(new JsrNamed(""String_Node_Str"")));
  assertEquals(keyForAnnotation(Names.named(""String_Node_Str"")),keyForAnnotation(new GuiceNamed(""String_Node_Str"")));
  assertEquals(keyForAnnotation(Names.named(""String_Node_Str"")),keyForAnnotation(new JsrNamed(""String_Node_Str"")));
  assertEquals(keyForAnnotationType(com.google.inject.name.Named.class),keyForAnnotationType(javax.inject.Named.class));
}",0.8716861081654295
60484,"<T>void initializeJitBinding(BindingImpl<T> binding,Errors errors) throws ErrorsException {
  if (binding instanceof ConstructorBindingImpl<?>) {
    Key<T> key=binding.getKey();
    jitBindings.put(key,binding);
    boolean successful=false;
    try {
      ((ConstructorBindingImpl)binding).initialize(this,errors);
      successful=true;
    }
  finally {
      if (!successful) {
        jitBindings.remove(key);
      }
    }
  }
}","<T>void initializeJitBinding(BindingImpl<T> binding,Errors errors) throws ErrorsException {
  if (binding instanceof ConstructorBindingImpl<?>) {
    Key<T> key=binding.getKey();
    jitBindings.put(key,binding);
    boolean successful=false;
    ConstructorBindingImpl cb=(ConstructorBindingImpl)binding;
    try {
      cb.initialize(this,errors);
      successful=true;
    }
  finally {
      if (!successful) {
        removeFailedJitBinding(key,null);
        cleanup(binding,new HashSet<Key>());
      }
    }
  }
}",0.837160751565762
60485,"public Provided get(){
  return new Provided(){
    public void go(){
    }
  }
;
}","public String get(){
  return TEST_VALUE;
}",0.4603174603174603
60486,"/** 
 * When we're building the binding for A, we temporarily insert that binding to support circular dependencies. And so we can successfully create a binding for B. But later, when the binding for A ultimately fails, we need to clean up the dependent binding for B.
 */
public void testCircularJitBindingsLeaveNoResidue(){
  Injector injector=Guice.createInjector();
  try {
    injector.getBinding(A.class);
    fail();
  }
 catch (  ConfigurationException expected) {
  }
  try {
    injector.getBinding(B.class);
    fail();
  }
 catch (  ConfigurationException expected) {
  }
}","/** 
 * When we're building the binding for A, we temporarily insert that binding to support circular dependencies. And so we can successfully create a binding for B. But later, when the binding for A ultimately fails, we need to clean up the dependent binding for B. The test loops through linked bindings & bindings with constructor & member injections, to make sure that all are cleaned up and traversed.  It also makes sure we don't touch explicit bindings.
 */
public void testCircularJitBindingsLeaveNoResidue(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(Valid.class);
      bind(Valid2.class);
    }
  }
);
  Binding v1=injector.getBinding(Valid.class);
  Binding v2=injector.getBinding(Valid2.class);
  Binding jv1=injector.getBinding(JitValid.class);
  Binding jv2=injector.getBinding(JitValid2.class);
  assertFailure(injector,Invalid.class);
  assertFailure(injector,InvalidLinked.class);
  assertFailure(injector,InvalidLinkedImpl.class);
  assertFailure(injector,InvalidLinked2.class);
  assertFailure(injector,InvalidLinked2Impl.class);
  assertFailure(injector,Invalid2.class);
  assertSame(v1,injector.getBinding(Valid.class));
  assertSame(v2,injector.getBinding(Valid2.class));
  assertSame(jv1,injector.getBinding(JitValid.class));
  assertSame(jv2,injector.getBinding(JitValid2.class));
}",0.387589013224822
60487,"protected void configure(){
  bind(I.class).to(AlternateImpl.class);
}","@Override protected void configure(){
  bind(String.class).toProvider(TestStringProvider.class);
}",0.7023809523809523
60488,"private static ClassLoader getClassLoader(Class<?> type,ClassLoader delegate){
  if (!CUSTOM_LOADER_ENABLED) {
    return delegate;
  }
  delegate=canonicalize(delegate);
  if (delegate == GUICE_CLASS_LOADER || delegate instanceof BridgeClassLoader) {
    return delegate;
  }
  if (Visibility.forType(type) == Visibility.PUBLIC) {
    if (delegate != SystemBridgeHolder.SYSTEM_BRIDGE.getParent()) {
      return CLASS_LOADER_CACHE.get(delegate);
    }
    return SystemBridgeHolder.SYSTEM_BRIDGE;
  }
  return delegate;
}","private static ClassLoader getClassLoader(Class<?> type,ClassLoader delegate){
  if (!CUSTOM_LOADER_ENABLED) {
    return delegate;
  }
  if (type.getName().startsWith(""String_Node_Str"")) {
    return GUICE_CLASS_LOADER;
  }
  delegate=canonicalize(delegate);
  if (delegate == GUICE_CLASS_LOADER || delegate instanceof BridgeClassLoader) {
    return delegate;
  }
  if (Visibility.forType(type) == Visibility.PUBLIC) {
    if (delegate != SystemBridgeHolder.SYSTEM_BRIDGE.getParent()) {
      return CLASS_LOADER_CACHE.get(delegate);
    }
    return SystemBridgeHolder.SYSTEM_BRIDGE;
  }
  return delegate;
}",0.9214474845542808
60489,"<T>ProviderMethod<T> createProviderMethod(Binder binder,final Method method){
  binder=binder.withSource(method);
  Errors errors=new Errors(method);
  List<Dependency<?>> dependencies=Lists.newArrayList();
  List<Provider<?>> parameterProviders=Lists.newArrayList();
  List<TypeLiteral<?>> parameterTypes=typeLiteral.getParameterTypes(method);
  Annotation[][] parameterAnnotations=method.getParameterAnnotations();
  for (int i=0; i < parameterTypes.size(); i++) {
    Key<?> key=getKey(errors,parameterTypes.get(i),method,parameterAnnotations[i]);
    dependencies.add(Dependency.get(key));
    parameterProviders.add(binder.getProvider(key));
  }
  @SuppressWarnings(""String_Node_Str"") TypeLiteral<T> returnType=(TypeLiteral<T>)typeLiteral.getReturnType(method);
  Key<T> key=getKey(errors,returnType,method,method.getAnnotations());
  Class<? extends Annotation> scopeAnnotation=Annotations.findScopeAnnotation(errors,method.getAnnotations());
  for (  Message message : errors.getMessages()) {
    binder.addError(message);
  }
  return new ProviderMethod<T>(key,method,delegate,ImmutableSet.copyOf(dependencies),parameterProviders,scopeAnnotation);
}","<T>ProviderMethod<T> createProviderMethod(Binder binder,final Method method){
  binder=binder.withSource(method);
  Errors errors=new Errors(method);
  List<Dependency<?>> dependencies=Lists.newArrayList();
  List<Provider<?>> parameterProviders=Lists.newArrayList();
  List<TypeLiteral<?>> parameterTypes=typeLiteral.getParameterTypes(method);
  Annotation[][] parameterAnnotations=method.getParameterAnnotations();
  for (int i=0; i < parameterTypes.size(); i++) {
    Key<?> key=getKey(errors,parameterTypes.get(i),method,parameterAnnotations[i]);
    if (key.equals(Key.get(Logger.class))) {
      Key<Logger> loggerKey=Key.get(Logger.class,UniqueAnnotations.create());
      binder.bind(loggerKey).toProvider(new LogProvider(method));
      key=loggerKey;
    }
    dependencies.add(Dependency.get(key));
    parameterProviders.add(binder.getProvider(key));
  }
  @SuppressWarnings(""String_Node_Str"") TypeLiteral<T> returnType=(TypeLiteral<T>)typeLiteral.getReturnType(method);
  Key<T> key=getKey(errors,returnType,method,method.getAnnotations());
  Class<? extends Annotation> scopeAnnotation=Annotations.findScopeAnnotation(errors,method.getAnnotations());
  for (  Message message : errors.getMessages()) {
    binder.addError(message);
  }
  return new ProviderMethod<T>(key,method,delegate,ImmutableSet.copyOf(dependencies),parameterProviders,scopeAnnotation);
}",0.9146245059288538
60490,"protected void configure(){
}","@Override protected void configure(){
}",0.8529411764705882
60491,"public T call(InternalContext context) throws ErrorsException {
  Dependency dependency=context.getDependency();
  return internalFactory.get(errors,context,dependency,false);
}","public T call(InternalContext context) throws ErrorsException {
  Dependency dependency=context.getDependency();
  return internalFactory.get(errors,context,dependency,true);
}",0.980169971671388
60492,"public T get(){
  final Errors errors=new Errors();
  try {
    T t=injector.callInContext(new ContextualCallable<T>(){
      public T call(      InternalContext context) throws ErrorsException {
        Dependency dependency=context.getDependency();
        return internalFactory.get(errors,context,dependency,false);
      }
    }
);
    errors.throwIfNewErrors(0);
    return t;
  }
 catch (  ErrorsException e) {
    throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
  }
}","public T get(){
  final Errors errors=new Errors();
  try {
    T t=injector.callInContext(new ContextualCallable<T>(){
      public T call(      InternalContext context) throws ErrorsException {
        Dependency dependency=context.getDependency();
        return internalFactory.get(errors,context,dependency,true);
      }
    }
);
    errors.throwIfNewErrors(0);
    return t;
  }
 catch (  ErrorsException e) {
    throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
  }
}",0.992992992992993
60493,"@Override public String toString(){
  return ""String_Node_Str"" + Named.class.getName() + ""String_Node_Str""+ value+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + delegate + ""String_Node_Str"";
}",0.7878787878787878
60494,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(BytecodeGenTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(GuiceTck.suite());
  suite.addTestSuite(BinderTest.class);
  suite.addTest(BinderTestSuite.suite());
  suite.addTestSuite(BindingAnnotationTest.class);
  suite.addTestSuite(BindingOrderTest.class);
  suite.addTestSuite(BindingTest.class);
  suite.addTestSuite(BoundInstanceInjectionTest.class);
  suite.addTestSuite(BoundProviderTest.class);
  suite.addTestSuite(CircularDependencyTest.class);
  suite.addTestSuite(EagerSingletonTest.class);
  suite.addTestSuite(GenericInjectionTest.class);
  suite.addTestSuite(ImplicitBindingTest.class);
  suite.addTestSuite(TypeListenerTest.class);
  suite.addTestSuite(InjectorTest.class);
  suite.addTestSuite(JitBindingsTest.class);
  suite.addTestSuite(KeyTest.class);
  suite.addTestSuite(LoggerInjectionTest.class);
  suite.addTestSuite(MembersInjectorTest.class);
  suite.addTestSuite(ModulesTest.class);
  suite.addTestSuite(ModuleTest.class);
  suite.addTestSuite(NullableInjectionPointTest.class);
  suite.addTestSuite(OptionalBindingTest.class);
  suite.addTestSuite(OverrideModuleTest.class);
  suite.addTestSuite(ParentInjectorTest.class);
  suite.addTestSuite(PrivateModuleTest.class);
  suite.addTestSuite(ProviderInjectionTest.class);
  suite.addTestSuite(ProvisionExceptionTest.class);
  suite.addTestSuite(ReflectionTest.class);
  suite.addTestSuite(RequestInjectionTest.class);
  suite.addTestSuite(ScopesTest.class);
  suite.addTestSuite(SerializationTest.class);
  suite.addTestSuite(SuperclassTest.class);
  suite.addTestSuite(TypeConversionTest.class);
  suite.addTestSuite(TypeLiteralInjectionTest.class);
  suite.addTestSuite(TypeLiteralTest.class);
  suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
  suite.addTestSuite(FinalizableReferenceQueueTest.class);
  suite.addTestSuite(Jsr166HashMapTest.class);
  suite.addTestSuite(LineNumbersTest.class);
  suite.addTest(MapMakerTestSuite.suite());
  suite.addTestSuite(UniqueAnnotationsTest.class);
  suite.addTestSuite(MatcherTest.class);
  suite.addTestSuite(NamesTest.class);
  suite.addTestSuite(NamedEquivalanceTest.class);
  suite.addTestSuite(BindingTargetVisitorTest.class);
  suite.addTestSuite(ElementsTest.class);
  suite.addTestSuite(ElementApplyToTest.class);
  suite.addTestSuite(HasDependenciesTest.class);
  suite.addTestSuite(InjectionPointTest.class);
  suite.addTestSuite(InjectorSpiTest.class);
  suite.addTestSuite(ModuleRewriterTest.class);
  suite.addTestSuite(ProviderMethodsTest.class);
  suite.addTestSuite(SpiBindingsTest.class);
  suite.addTestSuite(ToolStageInjectorTest.class);
  suite.addTestSuite(NoopOverrideTest.class);
  suite.addTestSuite(ProvidersTest.class);
  suite.addTestSuite(TypesTest.class);
  suite.addTestSuite(ProxyFactoryTest.class);
  suite.addTestSuite(IntegrationTest.class);
  suite.addTestSuite(MethodInterceptionTest.class);
  suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
  suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
  suite.addTestSuite(BytecodeGenTest.class);
  suite.addTestSuite(Jsr330Test.class);
  return removeSuppressedTests(suite,SUPPRESSED_TEST_NAMES);
}",0.992030602486452
60495,"/** 
 * Creates an injector for the given set of modules, in a given development stage.
 * @throws CreationException if one or more errors occur during Injectorconstruction
 */
public static Injector createInjector(Stage stage,Iterable<? extends Module> modules){
  return new InjectorBuilder().stage(stage).addModules(modules).build();
}","/** 
 * Creates an injector for the given set of modules, in a given development stage.
 * @throws CreationException if one or more errors occur during Injectorconstruction
 */
public static Injector createInjector(Stage stage,Iterable<? extends Module> modules){
  return new InjectorBuilderImpl().stage(stage).addModules(modules).build();
}",0.9941176470588236
60496,"@SuppressWarnings(""String_Node_Str"") public T get(){
  if (instance == null) {
synchronized (InjectorBuilder.class) {
      if (instance == null) {
        T provided=creator.get();
        if (provided instanceof CircularDependencyProxy) {
          return provided;
        }
        Object providedOrSentinel=(provided == null) ? NULL : provided;
        if (instance != null && instance != providedOrSentinel) {
          throw new ProvisionException(""String_Node_Str"");
        }
        instance=providedOrSentinel;
      }
    }
  }
  Object localInstance=instance;
  @SuppressWarnings(""String_Node_Str"") T returnedInstance=(localInstance != NULL) ? (T)localInstance : null;
  return returnedInstance;
}","@SuppressWarnings(""String_Node_Str"") public T get(){
  if (instance == null) {
synchronized (InjectorBuilderImpl.class) {
      if (instance == null) {
        T provided=creator.get();
        if (provided instanceof CircularDependencyProxy) {
          return provided;
        }
        Object providedOrSentinel=(provided == null) ? NULL : provided;
        if (instance != null && instance != providedOrSentinel) {
          throw new ProvisionException(""String_Node_Str"");
        }
        instance=providedOrSentinel;
      }
    }
  }
  Object localInstance=instance;
  @SuppressWarnings(""String_Node_Str"") T returnedInstance=(localInstance != NULL) ? (T)localInstance : null;
  return returnedInstance;
}",0.9971910112359552
60497,"public T get(Errors errors,InternalContext context,Dependency<?> dependency) throws ErrorsException {
  errors=errors.withSource(providerKey);
  javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency);
  try {
    return errors.checkForNull(provider.get(),source,dependency);
  }
 catch (  RuntimeException userException) {
    throw errors.errorInProvider(userException).toException();
  }
}","public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  errors=errors.withSource(providerKey);
  javax.inject.Provider<? extends T> provider=providerFactory.get(errors,context,dependency,true);
  try {
    return errors.checkForNull(provider.get(),source,dependency);
  }
 catch (  RuntimeException userException) {
    throw errors.errorInProvider(userException).toException();
  }
}",0.977116704805492
60498,"public void notify(Errors errors){
  try {
    providerFactory=injector.getInternalFactory(providerKey,errors.withSource(source));
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}","public void notify(Errors errors){
  try {
    providerFactory=injector.getInternalFactory(providerKey,errors.withSource(source),JitLimitation.NEW_OR_EXISTING_JIT);
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}",0.9230769230769232
60499,"public T get(Errors errors,InternalContext context,Dependency dependency) throws ErrorsException {
  return initializable.get(errors);
}","public T get(Errors errors,InternalContext context,Dependency dependency,boolean linked) throws ErrorsException {
  return initializable.get(errors);
}",0.9477351916376306
60500,"public ConstructorBindingImpl(Key<T> key,Object source,Scoping scoping,InjectionPoint constructorInjectionPoint,Set<InjectionPoint> injectionPoints){
  super(source,key,scoping);
  this.factory=new Factory<T>();
  ConstructionProxy<T> constructionProxy=new DefaultConstructionProxyFactory<T>(constructorInjectionPoint).create();
  this.constructorInjectionPoint=constructorInjectionPoint;
  factory.constructorInjector=new ConstructorInjector<T>(injectionPoints,constructionProxy,null,null);
}","public ConstructorBindingImpl(Key<T> key,Object source,Scoping scoping,InjectionPoint constructorInjectionPoint,Set<InjectionPoint> injectionPoints){
  super(source,key,scoping);
  this.factory=new Factory<T>(false,key);
  ConstructionProxy<T> constructionProxy=new DefaultConstructionProxyFactory<T>(constructorInjectionPoint).create();
  this.constructorInjectionPoint=constructorInjectionPoint;
  factory.constructorInjector=new ConstructorInjector<T>(injectionPoints,constructionProxy,null,null);
}",0.9909547738693468
60501,"@SuppressWarnings(""String_Node_Str"") public T get(Errors errors,InternalContext context,Dependency<?> dependency) throws ErrorsException {
  checkState(constructorInjector != null,""String_Node_Str"");
  return (T)constructorInjector.construct(errors,context,dependency.getKey().getTypeLiteral().getRawType());
}","@SuppressWarnings(""String_Node_Str"") public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  checkState(constructorInjector != null,""String_Node_Str"");
  if (failIfNotLinked && !linked) {
    throw errors.jitDisabled(key).toException();
  }
  return (T)constructorInjector.construct(errors,context,dependency.getKey().getTypeLiteral().getRawType());
}",0.856353591160221
60502,"/** 
 * @param constructorInjector the constructor to use, or {@code null} to use the default.
 */
static <T>ConstructorBindingImpl<T> create(InjectorImpl injector,Key<T> key,InjectionPoint constructorInjector,Object source,Scoping scoping,Errors errors) throws ErrorsException {
  int numErrors=errors.size();
  @SuppressWarnings(""String_Node_Str"") Class<? super T> rawType=constructorInjector == null ? key.getTypeLiteral().getRawType() : (Class)constructorInjector.getDeclaringType().getRawType();
  if (Modifier.isAbstract(rawType.getModifiers())) {
    errors.missingImplementation(key);
  }
  if (Classes.isInnerClass(rawType)) {
    errors.cannotInjectInnerClass(rawType);
  }
  errors.throwIfNewErrors(numErrors);
  if (constructorInjector == null) {
    try {
      constructorInjector=InjectionPoint.forConstructorOf(key.getTypeLiteral());
    }
 catch (    ConfigurationException e) {
      throw errors.merge(e.getErrorMessages()).toException();
    }
  }
  if (!scoping.isExplicitlyScoped()) {
    Class<?> annotatedType=constructorInjector.getMember().getDeclaringClass();
    Class<? extends Annotation> scopeAnnotation=findScopeAnnotation(errors,annotatedType);
    if (scopeAnnotation != null) {
      scoping=Scoping.makeInjectable(Scoping.forAnnotation(scopeAnnotation),injector,errors.withSource(rawType));
    }
  }
  errors.throwIfNewErrors(numErrors);
  Factory<T> factoryFactory=new Factory<T>();
  InternalFactory<? extends T> scopedFactory=Scoping.scope(key,injector,factoryFactory,source,scoping);
  return new ConstructorBindingImpl<T>(injector,key,source,scopedFactory,scoping,factoryFactory,constructorInjector);
}","/** 
 * @param constructorInjector the constructor to use, or {@code null} to use the default.
 * @param failIfNotLinked true if this ConstructorBindingImpl's InternalFactory shouldonly succeed if retrieved from a linked binding
 */
static <T>ConstructorBindingImpl<T> create(InjectorImpl injector,Key<T> key,InjectionPoint constructorInjector,Object source,Scoping scoping,Errors errors,boolean failIfNotLinked) throws ErrorsException {
  int numErrors=errors.size();
  @SuppressWarnings(""String_Node_Str"") Class<? super T> rawType=constructorInjector == null ? key.getTypeLiteral().getRawType() : (Class)constructorInjector.getDeclaringType().getRawType();
  if (Modifier.isAbstract(rawType.getModifiers())) {
    errors.missingImplementation(key);
  }
  if (Classes.isInnerClass(rawType)) {
    errors.cannotInjectInnerClass(rawType);
  }
  errors.throwIfNewErrors(numErrors);
  if (constructorInjector == null) {
    try {
      constructorInjector=InjectionPoint.forConstructorOf(key.getTypeLiteral());
    }
 catch (    ConfigurationException e) {
      throw errors.merge(e.getErrorMessages()).toException();
    }
  }
  if (!scoping.isExplicitlyScoped()) {
    Class<?> annotatedType=constructorInjector.getMember().getDeclaringClass();
    Class<? extends Annotation> scopeAnnotation=findScopeAnnotation(errors,annotatedType);
    if (scopeAnnotation != null) {
      scoping=Scoping.makeInjectable(Scoping.forAnnotation(scopeAnnotation),injector,errors.withSource(rawType));
    }
  }
  errors.throwIfNewErrors(numErrors);
  Factory<T> factoryFactory=new Factory<T>(failIfNotLinked,key);
  InternalFactory<? extends T> scopedFactory=Scoping.scope(key,injector,factoryFactory,source,scoping);
  return new ConstructorBindingImpl<T>(injector,key,source,scopedFactory,scoping,factoryFactory,constructorInjector);
}",0.9489177489177488
60503,"public T get(Errors errors,InternalContext context,Dependency<?> dependency) throws ErrorsException {
  return delegate.getInternalFactory().get(errors,context,dependency);
}","public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  return delegate.getInternalFactory().get(errors,context,dependency,linked);
}",0.9405405405405406
60504,"public T get(Errors errors,InternalContext context,Dependency<?> dependency) throws ErrorsException {
  return targetFactory.get(errors.withSource(targetKey),context,dependency);
}","public T get(Errors errors,InternalContext context,Dependency<?> dependency,boolean linked) throws ErrorsException {
  return targetFactory.get(errors.withSource(targetKey),context,dependency,true);
}",0.9473684210526316
60505,"public void notify(final Errors errors){
  try {
    targetFactory=injector.getInternalFactory(targetKey,errors.withSource(source));
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}","public void notify(final Errors errors){
  try {
    targetFactory=injector.getInternalFactory(targetKey,errors.withSource(source),JitLimitation.NEW_OR_EXISTING_JIT);
  }
 catch (  ErrorsException e) {
    errors.merge(e.getErrors());
  }
}",0.9237668161434978
60506,"/** 
 * Returns the Guice   {@link Key} for this parameter.
 */
public Object getValue(Injector injector){
  if (null == provider) {
synchronized (this) {
      if (null == provider) {
        provider=isProvider ? injector.getProvider(getBindingForType(getProvidedType(type))) : injector.getProvider(getPrimaryBindingKey());
      }
    }
  }
  return provider.get();
}","/** 
 * Returns the Guice   {@link Key} for this parameter.
 */
public Object getValue(Injector injector){
  if (null == provider) {
synchronized (this) {
      if (null == provider) {
        provider=isProvider ? injector.getProvider(getBindingForType(getProvidedType(type))) : injector.getProvider(getPrimaryBindingKey());
      }
    }
  }
  return isProvider ? provider : provider.get();
}",0.9685863874345548
60507,"@SuppressWarnings(""String_Node_Str"") protected void configure(){
  Binder binder=binder().withSource(method);
  int p=0;
  if (!data.optimized) {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
    }
  }
 else {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
    }
  }
  Constructor<?> constructor=data.constructor;
  if (injector.getExistingBinding(returnType) != null) {
    constructor=null;
  }
  TypeLiteral<?> implementation=collector.getBindings().get(returnType);
  if (implementation != null) {
    if (constructor == null) {
      binder.bind(assistedReturnType).to((TypeLiteral)implementation);
    }
 else {
      binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)implementation);
    }
  }
 else {
    if (constructor == null) {
      binder.bind(assistedReturnType).to((Key)returnType);
    }
 else {
      binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") protected void configure(){
  Binder binder=binder().withSource(method);
  int p=0;
  if (!data.optimized) {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
    }
  }
 else {
    for (    Key<?> paramKey : data.paramTypes) {
      binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
    }
  }
  Constructor<?> constructor=data.constructor;
  if (injector.getExistingBinding(returnType) != null) {
    constructor=null;
  }
  TypeLiteral<?> implementation=collector.getBindings().get(returnType);
  if (implementation != null) {
    if (constructor == null) {
      binder.bind(assistedReturnType).to((TypeLiteral)implementation);
    }
 else {
      binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)implementation);
    }
  }
 else {
    if (constructor == null) {
      binder.bind(assistedReturnType).to((Key)returnType);
    }
 else {
      binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)returnType.getTypeLiteral());
    }
  }
}",0.9814395654142146
60508,"/** 
 * Creates a child injector that binds the args, and returns the binding for the method's result.
 */
public Binding<?> getBindingFromNewInjector(final Method method,final Object[] args,final AssistData data){
  checkState(injector != null,""String_Node_Str"");
  final Key<?> returnType=data.returnType;
  final Key<?> assistedReturnType=Key.get(returnType.getTypeLiteral(),Assisted.class);
  Module assistedModule=new AbstractModule(){
    @SuppressWarnings(""String_Node_Str"") protected void configure(){
      Binder binder=binder().withSource(method);
      int p=0;
      if (!data.optimized) {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
        }
      }
 else {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
        }
      }
      Constructor<?> constructor=data.constructor;
      if (injector.getExistingBinding(returnType) != null) {
        constructor=null;
      }
      TypeLiteral<?> implementation=collector.getBindings().get(returnType);
      if (implementation != null) {
        if (constructor == null) {
          binder.bind(assistedReturnType).to((TypeLiteral)implementation);
        }
 else {
          binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)implementation);
        }
      }
 else {
        if (constructor == null) {
          binder.bind(assistedReturnType).to((Key)returnType);
        }
 else {
          binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
        }
      }
    }
  }
;
  Injector forCreate=injector.createChildInjector(assistedModule);
  Binding binding=forCreate.getBinding(assistedReturnType);
  if (data.optimized) {
    data.cachedBinding=binding;
  }
  return binding;
}","/** 
 * Creates a child injector that binds the args, and returns the binding for the method's result.
 */
public Binding<?> getBindingFromNewInjector(final Method method,final Object[] args,final AssistData data){
  checkState(injector != null,""String_Node_Str"");
  final Key<?> returnType=data.returnType;
  final Key<?> assistedReturnType=Key.get(returnType.getTypeLiteral(),Assisted.class);
  Module assistedModule=new AbstractModule(){
    @SuppressWarnings(""String_Node_Str"") protected void configure(){
      Binder binder=binder().withSource(method);
      int p=0;
      if (!data.optimized) {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(Providers.of(args[p++]));
        }
      }
 else {
        for (        Key<?> paramKey : data.paramTypes) {
          binder.bind((Key)paramKey).toProvider(data.providers.get(p++));
        }
      }
      Constructor<?> constructor=data.constructor;
      if (injector.getExistingBinding(returnType) != null) {
        constructor=null;
      }
      TypeLiteral<?> implementation=collector.getBindings().get(returnType);
      if (implementation != null) {
        if (constructor == null) {
          binder.bind(assistedReturnType).to((TypeLiteral)implementation);
        }
 else {
          binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)implementation);
        }
      }
 else {
        if (constructor == null) {
          binder.bind(assistedReturnType).to((Key)returnType);
        }
 else {
          binder.bind(assistedReturnType).toConstructor((Constructor)constructor,(TypeLiteral)returnType.getTypeLiteral());
        }
      }
    }
  }
;
  Injector forCreate=injector.createChildInjector(assistedModule);
  Binding binding=forCreate.getBinding(assistedReturnType);
  if (data.optimized) {
    data.cachedBinding=binding;
  }
  return binding;
}",0.9891563078550648
60509,"@Override protected void configure(){
  bind(Double.class).toInstance(5.0d);
  install(new FactoryModuleBuilder().build(VersatileCarFactory.class));
}","@Override protected void configure(){
  install(new FactoryModuleBuilder().build(new TypeLiteral<Foo.Factory<String>>(){
  }
));
}",0.6928571428571428
60510,Mustang create(Color color);,Foo<E> create(Bar bar);,0.5098039215686274
60511,"public Void call(InternalContext context){
  context.setDependency(dependency);
  Errors errorsForBinding=errors.withSource(dependency);
  try {
    binding.getInternalFactory().get(errorsForBinding,context,dependency);
  }
 catch (  ErrorsException e) {
    errorsForBinding.merge(e.getErrors());
  }
 finally {
    context.setDependency(null);
  }
  return null;
}","public Void call(InternalContext context){
  Dependency previous=context.setDependency(dependency);
  Errors errorsForBinding=errors.withSource(dependency);
  try {
    binding.getInternalFactory().get(errorsForBinding,context,dependency);
  }
 catch (  ErrorsException e) {
    errorsForBinding.merge(e.getErrors());
  }
 finally {
    context.setDependency(previous);
  }
  return null;
}",0.9576719576719576
60512,"/** 
 * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered while we're binding these singletons are not be eager.
 */
void loadEagerSingletons(InjectorImpl injector,Stage stage,final Errors errors){
  @SuppressWarnings(""String_Node_Str"") Set<BindingImpl<?>> candidateBindings=ImmutableSet.copyOf(Iterables.concat((Collection)injector.state.getExplicitBindingsThisLevel().values(),injector.jitBindings.values()));
  for (  final BindingImpl<?> binding : candidateBindings) {
    if (isEagerSingleton(injector,binding,stage)) {
      try {
        injector.callInContext(new ContextualCallable<Void>(){
          Dependency<?> dependency=Dependency.get(binding.getKey());
          public Void call(          InternalContext context){
            context.setDependency(dependency);
            Errors errorsForBinding=errors.withSource(dependency);
            try {
              binding.getInternalFactory().get(errorsForBinding,context,dependency);
            }
 catch (            ErrorsException e) {
              errorsForBinding.merge(e.getErrors());
            }
 finally {
              context.setDependency(null);
            }
            return null;
          }
        }
);
      }
 catch (      ErrorsException e) {
        throw new AssertionError();
      }
    }
  }
}","/** 
 * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered while we're binding these singletons are not be eager.
 */
void loadEagerSingletons(InjectorImpl injector,Stage stage,final Errors errors){
  @SuppressWarnings(""String_Node_Str"") Set<BindingImpl<?>> candidateBindings=ImmutableSet.copyOf(Iterables.concat((Collection)injector.state.getExplicitBindingsThisLevel().values(),injector.jitBindings.values()));
  for (  final BindingImpl<?> binding : candidateBindings) {
    if (isEagerSingleton(injector,binding,stage)) {
      try {
        injector.callInContext(new ContextualCallable<Void>(){
          Dependency<?> dependency=Dependency.get(binding.getKey());
          public Void call(          InternalContext context){
            Dependency previous=context.setDependency(dependency);
            Errors errorsForBinding=errors.withSource(dependency);
            try {
              binding.getInternalFactory().get(errorsForBinding,context,dependency);
            }
 catch (            ErrorsException e) {
              errorsForBinding.merge(e.getErrors());
            }
 finally {
              context.setDependency(previous);
            }
            return null;
          }
        }
);
      }
 catch (      ErrorsException e) {
        throw new AssertionError();
      }
    }
  }
}",0.988814317673378
60513,"public T get(){
  final Errors errors=new Errors(dependency);
  try {
    T t=callInContext(new ContextualCallable<T>(){
      public T call(      InternalContext context) throws ErrorsException {
        context.setDependency(dependency);
        try {
          return factory.get(errors,context,dependency);
        }
  finally {
          context.setDependency(null);
        }
      }
    }
);
    errors.throwIfNewErrors(0);
    return t;
  }
 catch (  ErrorsException e) {
    throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
  }
}","public T get(){
  final Errors errors=new Errors(dependency);
  try {
    T t=callInContext(new ContextualCallable<T>(){
      public T call(      InternalContext context) throws ErrorsException {
        Dependency previous=context.setDependency(dependency);
        try {
          return factory.get(errors,context,dependency);
        }
  finally {
          context.setDependency(previous);
        }
      }
    }
);
    errors.throwIfNewErrors(0);
    return t;
  }
 catch (  ErrorsException e) {
    throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
  }
}",0.9529616724738676
60514,"<T>Provider<T> getProviderOrThrow(final Key<T> key,Errors errors) throws ErrorsException {
  final InternalFactory<? extends T> factory=getInternalFactory(key,errors);
  final Dependency<T> dependency=Dependency.get(key);
  return new Provider<T>(){
    public T get(){
      final Errors errors=new Errors(dependency);
      try {
        T t=callInContext(new ContextualCallable<T>(){
          public T call(          InternalContext context) throws ErrorsException {
            context.setDependency(dependency);
            try {
              return factory.get(errors,context,dependency);
            }
  finally {
              context.setDependency(null);
            }
          }
        }
);
        errors.throwIfNewErrors(0);
        return t;
      }
 catch (      ErrorsException e) {
        throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
      }
    }
    @Override public String toString(){
      return factory.toString();
    }
  }
;
}","<T>Provider<T> getProviderOrThrow(final Key<T> key,Errors errors) throws ErrorsException {
  final InternalFactory<? extends T> factory=getInternalFactory(key,errors);
  final Dependency<T> dependency=Dependency.get(key);
  return new Provider<T>(){
    public T get(){
      final Errors errors=new Errors(dependency);
      try {
        T t=callInContext(new ContextualCallable<T>(){
          public T call(          InternalContext context) throws ErrorsException {
            Dependency previous=context.setDependency(dependency);
            try {
              return factory.get(errors,context,dependency);
            }
  finally {
              context.setDependency(previous);
            }
          }
        }
);
        errors.throwIfNewErrors(0);
        return t;
      }
 catch (      ErrorsException e) {
        throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
      }
    }
    @Override public String toString(){
      return factory.toString();
    }
  }
;
}",0.984924623115578
60515,"public T call(InternalContext context) throws ErrorsException {
  context.setDependency(dependency);
  try {
    return factory.get(errors,context,dependency);
  }
  finally {
    context.setDependency(null);
  }
}","public T call(InternalContext context) throws ErrorsException {
  Dependency previous=context.setDependency(dependency);
  try {
    return factory.get(errors,context,dependency);
  }
  finally {
    context.setDependency(previous);
  }
}",0.9292035398230089
60516,"public void setDependency(Dependency dependency){
  this.dependency=dependency;
}","public Dependency setDependency(Dependency dependency){
  Dependency previous=dependency;
  this.dependency=dependency;
  return previous;
}",0.7058823529411765
60517,"public void inject(Errors errors,InternalContext context,Object o){
  errors=errors.withSource(dependency);
  context.setDependency(dependency);
  try {
    Object value=factory.get(errors,context,dependency);
    field.set(o,value);
  }
 catch (  ErrorsException e) {
    errors.withSource(injectionPoint).merge(e.getErrors());
  }
catch (  IllegalAccessException e) {
    throw new AssertionError(e);
  }
 finally {
    context.setDependency(null);
  }
}","public void inject(Errors errors,InternalContext context,Object o){
  errors=errors.withSource(dependency);
  Dependency previous=context.setDependency(dependency);
  try {
    Object value=factory.get(errors,context,dependency);
    field.set(o,value);
  }
 catch (  ErrorsException e) {
    errors.withSource(injectionPoint).merge(e.getErrors());
  }
catch (  IllegalAccessException e) {
    throw new AssertionError(e);
  }
 finally {
    context.setDependency(previous);
  }
}",0.9658119658119658
60518,"private T inject(Errors errors,InternalContext context) throws ErrorsException {
  context.setDependency(dependency);
  try {
    return factory.get(errors.withSource(dependency),context,dependency);
  }
  finally {
    context.setDependency(null);
  }
}","private T inject(Errors errors,InternalContext context) throws ErrorsException {
  Dependency previous=context.setDependency(dependency);
  try {
    return factory.get(errors.withSource(dependency),context,dependency);
  }
  finally {
    context.setDependency(previous);
  }
}",0.9398496240601504
60519,"Dependency(InjectionPoint injectionPoint,Key<T> key,boolean nullable,int parameterIndex){
  this.injectionPoint=injectionPoint;
  this.key=key;
  this.nullable=nullable;
  this.parameterIndex=parameterIndex;
}","Dependency(InjectionPoint injectionPoint,Key<T> key,boolean nullable,int parameterIndex){
  this.injectionPoint=injectionPoint;
  this.key=checkNotNull(key,""String_Node_Str"");
  this.nullable=nullable;
  this.parameterIndex=parameterIndex;
}",0.9155555555555556
60520,"protected void configure(){
  bindScope(CustomScoped.class,Scopes.NO_SCOPE);
}","protected void configure(){
  bind(B.class);
  bind(C.class);
  ProviderGetScope providerGetScope=new ProviderGetScope();
  requestInjection(providerGetScope);
  bindScope(CustomScoped.class,providerGetScope);
}",0.4359861591695502
60521,"public ProvidedBySingleton get(){
  return new ProvidedBySingleton();
}","public T get(){
  bProvider.get();
  return unscoped.get();
}",0.5454545454545454
60522,"public <T>Provider<T> scope(Key<T> key,Provider<T> unscoped){
  providers.put(key,unscoped);
  return unscoped;
}","public <T>Provider<T> scope(Key<T> key,final Provider<T> unscoped){
  return new Provider<T>(){
    public T get(){
      bProvider.get();
      return unscoped.get();
    }
  }
;
}",0.6802721088435374
60523,"<T>void initializeBinding(BindingImpl<T> binding,Errors errors) throws ErrorsException {
  if (binding instanceof ConstructorBindingImpl<?>) {
    Key<T> key=binding.getKey();
    jitBindings.put(key,binding);
    boolean successful=false;
    try {
      ((ConstructorBindingImpl)binding).initialize(this,errors);
      successful=true;
    }
  finally {
      if (!successful) {
        jitBindings.remove(key);
      }
    }
  }
}","<T>void initializeBinding(BindingImpl<T> binding,Errors errors) throws ErrorsException {
  if (binding instanceof ConstructorBindingImpl<?>) {
    ((ConstructorBindingImpl)binding).initialize(this,errors);
  }
}",0.65527950310559
60524,"/** 
 * Returns a new just-in-time binding created by resolving   {@code key}. The strategies used to create just-in-time bindings are: <ol> <li>Internalizing Providers. If the requested binding is for   {@code Provider<T>}, we delegate to the binding for   {@code T}. <li>Converting constants. <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys. <li>The constructor of the raw type. Only for unannotated keys. </ol>
 * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
 */
private <T>BindingImpl<T> createJustInTimeBinding(Key<T> key,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  if (state.isBlacklisted(key)) {
    throw errors.childBindingAlreadySet(key).toException();
  }
  if (isProvider(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createProviderBinding((Key)key,errors);
    return binding;
  }
  if (isMembersInjector(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createMembersInjectorBinding((Key)key,errors);
    return binding;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key,errors);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.getAnnotationType() != null) {
    if (key.hasAttributes()) {
      try {
        Errors ignored=new Errors();
        return getBindingOrThrow(key.withoutAttributes(),ignored);
      }
 catch (      ErrorsException ignored) {
      }
    }
    throw errors.missingImplementation(key).toException();
  }
  Object source=key.getTypeLiteral().getRawType();
  BindingImpl<T> binding=createUninitializedBinding(key,Scoping.UNSCOPED,source,errors);
  errors.throwIfNewErrors(numErrorsBefore);
  initializeBinding(binding,errors);
  return binding;
}","/** 
 * Returns a new just-in-time binding created by resolving   {@code key}. The strategies used to create just-in-time bindings are: <ol> <li>Internalizing Providers. If the requested binding is for   {@code Provider<T>}, we delegate to the binding for   {@code T}. <li>Converting constants. <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys. <li>The constructor of the raw type. Only for unannotated keys. </ol>
 * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
 */
private <T>BindingImpl<T> createJustInTimeBinding(Key<T> key,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  if (state.isBlacklisted(key)) {
    throw errors.childBindingAlreadySet(key).toException();
  }
  if (isProvider(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createProviderBinding((Key)key,errors);
    return binding;
  }
  if (isMembersInjector(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl<T> binding=(BindingImpl<T>)createMembersInjectorBinding((Key)key,errors);
    return binding;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key,errors);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.getAnnotationType() != null) {
    if (key.hasAttributes()) {
      try {
        Errors ignored=new Errors();
        return getBindingOrThrow(key.withoutAttributes(),ignored);
      }
 catch (      ErrorsException ignored) {
      }
    }
    throw errors.missingImplementation(key).toException();
  }
  Object source=key.getTypeLiteral().getRawType();
  BindingImpl<T> binding=createUninitializedBinding(key,Scoping.UNSCOPED,source,errors);
  errors.throwIfNewErrors(numErrorsBefore);
  initializeJitBinding(binding,errors);
  return binding;
}",0.9991742361684558
60525,"protected void configure(){
  bind(D.class).toInstance(new D(Stage.PRODUCTION));
  bind(Object.class).to(D.class);
  getProvider(new Key<C<Stage>>(){
  }
);
}","protected void configure(){
  bind(F.class);
}",0.4411764705882353
60526,"public List get(){
  return new ArrayList();
}","public T get(){
  return null;
}",0.717948717948718
60527,"public void testBindToProvider(){
  final Provider<String> aProvider=new Provider<String>(){
    public String get(){
      return ""String_Node_Str"";
    }
  }
;
  checkModule(new AbstractModule(){
    protected void configure(){
      bind(String.class).toProvider(aProvider);
      bind(List.class).toProvider(ListProvider.class);
      bind(Collection.class).toProvider(Key.get(ListProvider.class));
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderInstanceBinding);
      assertEquals(Key.get(String.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderInstanceBinding<? extends T> binding){
          assertSame(aProvider,binding.getProviderInstance());
          return null;
        }
      }
);
      return null;
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderKeyBinding);
      assertEquals(Key.get(List.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderKeyBinding<? extends T> binding){
          assertEquals(Key.get(ListProvider.class),binding.getProviderKey());
          return null;
        }
      }
);
      return null;
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderKeyBinding);
      assertEquals(Key.get(Collection.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderKeyBinding<? extends T> binding){
          assertEquals(Key.get(ListProvider.class),binding.getProviderKey());
          return null;
        }
      }
);
      return null;
    }
  }
);
}","public void testBindToProvider(){
  final Provider<String> aProvider=new Provider<String>(){
    public String get(){
      return ""String_Node_Str"";
    }
  }
;
  checkModule(new AbstractModule(){
    protected void configure(){
      bind(String.class).toProvider(aProvider);
      bind(List.class).toProvider(ListProvider.class);
      bind(Collection.class).toProvider(Key.get(ListProvider.class));
      bind(Iterable.class).toProvider(new TypeLiteral<TProvider<List>>(){
      }
);
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderInstanceBinding);
      assertEquals(Key.get(String.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderInstanceBinding<? extends T> binding){
          assertSame(aProvider,binding.getProviderInstance());
          return null;
        }
      }
);
      return null;
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderKeyBinding);
      assertEquals(Key.get(List.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderKeyBinding<? extends T> binding){
          assertEquals(Key.get(ListProvider.class),binding.getProviderKey());
          return null;
        }
      }
);
      return null;
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderKeyBinding);
      assertEquals(Key.get(Collection.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderKeyBinding<? extends T> binding){
          assertEquals(Key.get(ListProvider.class),binding.getProviderKey());
          return null;
        }
      }
);
      return null;
    }
  }
,new FailingElementVisitor(){
    @Override public <T>Void visit(    Binding<T> command){
      assertTrue(command instanceof ProviderKeyBinding);
      assertEquals(Key.get(Iterable.class),command.getKey());
      command.acceptTargetVisitor(new FailingTargetVisitor<T>(){
        @Override public Void visit(        ProviderKeyBinding<? extends T> binding){
          assertEquals(new Key<TProvider<List>>(){
          }
,binding.getProviderKey());
          return null;
        }
      }
);
      return null;
    }
  }
);
}",0.863059452237809
60528,"/** 
 * Returns a new just-in-time binding created by resolving   {@code key}. The strategies used to create just-in-time bindings are: <ol> <li>Internalizing Providers. If the requested binding is for   {@code Provider<T>}, we delegate to the binding for   {@code T}. <li>Converting constants. <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys. <li>The constructor of the raw type. Only for unannotated keys. </ol>
 * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
 */
<T>BindingImpl<T> createJustInTimeBinding(Key<T> key,Errors errors) throws ErrorsException {
  if (state.isBlacklisted(key)) {
    throw errors.childBindingAlreadySet(key).toException();
  }
  if (isProvider(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl binding=createProviderBinding((Key)key,errors);
    return binding;
  }
  if (isMembersInjector(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl binding=createMembersInjectorBinding((Key)key,errors);
    return binding;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key,errors);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    if (key.hasAttributes()) {
      try {
        Errors ignored=new Errors();
        return getBindingOrThrow(key.withoutAttributes(),ignored);
      }
 catch (      ErrorsException ignored) {
      }
    }
    throw errors.missingImplementation(key).toException();
  }
  Object source=key.getTypeLiteral().getRawType();
  BindingImpl<T> binding=createUnitializedBinding(key,Scoping.UNSCOPED,source,errors);
  initializeBinding(binding,errors);
  return binding;
}","/** 
 * Returns a new just-in-time binding created by resolving   {@code key}. The strategies used to create just-in-time bindings are: <ol> <li>Internalizing Providers. If the requested binding is for   {@code Provider<T>}, we delegate to the binding for   {@code T}. <li>Converting constants. <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys. <li>The constructor of the raw type. Only for unannotated keys. </ol>
 * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
 */
<T>BindingImpl<T> createJustInTimeBinding(Key<T> key,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  if (state.isBlacklisted(key)) {
    throw errors.childBindingAlreadySet(key).toException();
  }
  if (isProvider(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl binding=createProviderBinding((Key)key,errors);
    return binding;
  }
  if (isMembersInjector(key)) {
    @SuppressWarnings(""String_Node_Str"") BindingImpl binding=createMembersInjectorBinding((Key)key,errors);
    return binding;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key,errors);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    if (key.hasAttributes()) {
      try {
        Errors ignored=new Errors();
        return getBindingOrThrow(key.withoutAttributes(),ignored);
      }
 catch (      ErrorsException ignored) {
      }
    }
    throw errors.missingImplementation(key).toException();
  }
  Object source=key.getTypeLiteral().getRawType();
  BindingImpl<T> binding=createUnitializedBinding(key,Scoping.UNSCOPED,source,errors);
  errors.throwIfNewErrors(numErrorsBefore);
  initializeBinding(binding,errors);
  return binding;
}",0.976432935699738
60529,"@Provides @Named(""String_Node_Str"") String provideFoo(){
  return ""String_Node_Str"";
}","@Provides void provideFoo(){
}",0.4655172413793103
60530,"@Override protected void configure(){
  install(ProviderMethodsModule.forObject(methodsObject));
}","protected void configure(){
}",0.4566929133858268
60531,"public void testMultipleBindingAnnotations(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
      }
      @Provides @Named(""String_Node_Str"") @Blue public String provideString(){
        return ""String_Node_Str"";
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    Asserts.assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}","public void testMultipleBindingAnnotations(){
  try {
    Guice.createInjector(new AbstractModule(){
      protected void configure(){
      }
      @Provides @Named(""String_Node_Str"") @Blue public String provideString(){
        return ""String_Node_Str"";
      }
    }
);
    fail();
  }
 catch (  CreationException expected) {
    assertContains(expected.getMessage(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + getClass().getName(),""String_Node_Str"");
  }
}",0.7469635627530364
60532,"public WildcardTypeImpl(Type[] upperBounds,Type[] lowerBounds){
  checkArgument(upperBounds.length <= 1,""String_Node_Str"");
  checkArgument(upperBounds.length == 1,""String_Node_Str"");
  if (lowerBounds.length == 1) {
    checkNotNull(lowerBounds[0],""String_Node_Str"");
    checkNotPrimitive(lowerBounds[0],""String_Node_Str"");
    checkArgument(upperBounds[0] == Object.class,""String_Node_Str"");
    this.lowerBound=canonicalize(lowerBounds[0]);
    this.upperBound=Object.class;
  }
 else {
    checkNotNull(upperBounds[0],""String_Node_Str"");
    checkNotPrimitive(upperBounds[0],""String_Node_Str"");
    this.lowerBound=null;
    this.upperBound=canonicalize(upperBounds[0]);
  }
}","public WildcardTypeImpl(Type[] upperBounds,Type[] lowerBounds){
  checkArgument(lowerBounds.length <= 1,""String_Node_Str"");
  checkArgument(upperBounds.length == 1,""String_Node_Str"");
  if (lowerBounds.length == 1) {
    checkNotNull(lowerBounds[0],""String_Node_Str"");
    checkNotPrimitive(lowerBounds[0],""String_Node_Str"");
    checkArgument(upperBounds[0] == Object.class,""String_Node_Str"");
    this.lowerBound=canonicalize(lowerBounds[0]);
    this.upperBound=Object.class;
  }
 else {
    checkNotNull(upperBounds[0],""String_Node_Str"");
    checkNotPrimitive(upperBounds[0],""String_Node_Str"");
    this.lowerBound=null;
    this.upperBound=canonicalize(upperBounds[0]);
  }
}",0.9955947136563876
60533,"private <T>ConstructorInjector<T> createConstructor(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  InjectionPoint injectionPoint;
  try {
    injectionPoint=InjectionPoint.forConstructorOf(type);
  }
 catch (  ConfigurationException e) {
    errors.merge(e.getErrorMessages());
    throw errors.toException();
  }
  ImmutableList<SingleParameterInjector<?>> constructorParameterInjectors=injector.getParametersInjectors(injectionPoint.getDependencies(),errors);
  MembersInjectorImpl<T> membersInjector=injector.membersInjectorStore.createWithoutListeners(type,errors);
  ImmutableSet<InjectionPoint> injectableMembers=membersInjector.getInjectionPoints();
  ProxyFactory<T> proxyFactory=new ProxyFactory<T>(injectionPoint,injector.methodAspects);
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  InjectableType<T> injectableType=new InjectableType<T>(injectionPoint,type,injectableMembers,proxyFactory.getInterceptors());
  for (  InjectableTypeListenerBinding typeListener : injectableTypeListenerBindings) {
    if (typeListener.getTypeMatcher().matches(type)) {
      try {
        typeListener.getListener().hear(injectableType,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(typeListener,injectableType,e);
      }
    }
  }
  if (encounter.hasAddedAspects()) {
    proxyFactory=new ProxyFactory<T>(injectionPoint,concat(injector.methodAspects,encounter.getAspects()));
    injectableType=new InjectableType<T>(injectionPoint,type,injectableMembers,proxyFactory.getInterceptors());
  }
  errors.throwIfNewErrors(numErrorsBefore);
  return new ConstructorInjector<T>(proxyFactory.create(),constructorParameterInjectors,membersInjector,encounter.getInjectionListeners(),injectableType);
}","private <T>ConstructorInjector<T> createConstructor(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  InjectionPoint injectionPoint;
  try {
    injectionPoint=InjectionPoint.forConstructorOf(type);
  }
 catch (  ConfigurationException e) {
    errors.merge(e.getErrorMessages());
    throw errors.toException();
  }
  ImmutableList<SingleParameterInjector<?>> constructorParameterInjectors=injector.getParametersInjectors(injectionPoint.getDependencies(),errors);
  MembersInjectorImpl<T> membersInjector=injector.membersInjectorStore.createWithoutListeners(type,errors);
  ImmutableSet<InjectionPoint> injectableMembers=membersInjector.getInjectionPoints();
  ProxyFactory<T> proxyFactory=new ProxyFactory<T>(injectionPoint,injector.methodAspects);
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  InjectableType<T> injectableType=new InjectableType<T>(injectionPoint,type,injectableMembers,proxyFactory.getInterceptors());
  for (  InjectableTypeListenerBinding typeListener : injectableTypeListenerBindings) {
    if (typeListener.getTypeMatcher().matches(type)) {
      try {
        typeListener.getListener().hear(injectableType,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(typeListener,injectableType,e);
      }
    }
  }
  encounter.invalidate();
  if (encounter.hasAddedAspects()) {
    proxyFactory=new ProxyFactory<T>(injectionPoint,concat(injector.methodAspects,encounter.getAspects()));
    injectableType=new InjectableType<T>(injectionPoint,type,injectableMembers,proxyFactory.getInterceptors());
  }
  errors.throwIfNewErrors(numErrorsBefore);
  return new ConstructorInjector<T>(proxyFactory.create(),constructorParameterInjectors,membersInjector,encounter.getInjectionListeners(),injectableType);
}",0.9929193899782136
60534,"public void addError(Message message){
  errors.addMessage(message);
}","public void addError(Message message){
  checkState(valid,""String_Node_Str"");
  errors.addMessage(message);
}",0.7821229050279329
60535,"public void bindInterceptor(Matcher<? super Method> methodMatcher,MethodInterceptor... interceptors){
  if (aspects == null) {
    aspects=Lists.newArrayList();
  }
  aspects.add(new MethodAspect(Matchers.any(),methodMatcher,interceptors));
}","public void bindInterceptor(Matcher<? super Method> methodMatcher,MethodInterceptor... interceptors){
  checkState(valid,""String_Node_Str"");
  if (aspects == null) {
    aspects=Lists.newArrayList();
  }
  aspects.add(new MethodAspect(Matchers.any(),methodMatcher,interceptors));
}",0.9254302103250478
60536,"@SuppressWarnings(""String_Node_Str"") public void register(InjectionListener<? super T> injectionListener){
  if (injectionListeners == null) {
    injectionListeners=Lists.newArrayList();
  }
  injectionListeners.add(injectionListener);
}","@SuppressWarnings(""String_Node_Str"") public void register(InjectionListener<? super T> injectionListener){
  checkState(valid,""String_Node_Str"");
  if (injectionListeners == null) {
    injectionListeners=Lists.newArrayList();
  }
  injectionListeners.add(injectionListener);
}",0.9242718446601942
60537,"/** 
 * Creates a new members injector and attaches injection listeners.
 */
private <T>MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  MembersInjectorImpl<T> membersInjector=createWithoutListeners(type,errors);
  InjectableType<T> injectableType=new InjectableType<T>(null,type,membersInjector.getInjectionPoints());
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  for (  InjectableTypeListenerBinding typeListener : injectableTypeListenerBindings) {
    if (typeListener.getTypeMatcher().matches(type)) {
      try {
        typeListener.getListener().hear(injectableType,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(typeListener,injectableType,e);
      }
    }
  }
  errors.throwIfNewErrors(numErrorsBefore);
  return membersInjector.withListeners(encounter.getInjectionListeners());
}","/** 
 * Creates a new members injector and attaches injection listeners.
 */
private <T>MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type,Errors errors) throws ErrorsException {
  int numErrorsBefore=errors.size();
  MembersInjectorImpl<T> membersInjector=createWithoutListeners(type,errors);
  InjectableType<T> injectableType=new InjectableType<T>(null,type,membersInjector.getInjectionPoints());
  EncounterImpl<T> encounter=new EncounterImpl<T>(errors,injector.lookups);
  for (  InjectableTypeListenerBinding typeListener : injectableTypeListenerBindings) {
    if (typeListener.getTypeMatcher().matches(type)) {
      try {
        typeListener.getListener().hear(injectableType,encounter);
      }
 catch (      RuntimeException e) {
        errors.errorNotifyingTypeListener(typeListener,injectableType,e);
      }
    }
  }
  encounter.invalidate();
  errors.throwIfNewErrors(numErrorsBefore);
  return membersInjector.withListeners(encounter.getInjectionListeners());
}",0.9867211440245148
60538,"public Object invoke(MethodInvocation methodInvocation) throws Throwable {
  return prefix + methodInvocation.proceed();
}","public Object invoke(MethodInvocation methodInvocation) throws Throwable {
  return methodInvocation.proceed();
}",0.9617021276595744
60539,"protected void configure(){
  bindListener(any(),new InjectableType.Listener(){
    public <I>void hear(    InjectableType<I> injectableType,    Encounter<I> encounter){
      notificationCount.incrementAndGet();
    }
  }
);
  bind(C.class).toInstance(new C());
}","protected void configure(){
  bindListener(any(),new InjectableType.Listener(){
    public <I>void hear(    InjectableType<I> injectableType,    Encounter<I> encounter){
      encounterReference.set(encounter);
    }
  }
);
  bind(C.class);
}",0.8379446640316206
60540,"public void afterInjection(Object injectee){
  assertNotNull(bProviderReference.get().get());
  A a=new A();
  aMembersInjectorReference.get().injectMembers(a);
  assertNotNull(a.injector);
}","public void afterInjection(Object injectee){
}",0.3881856540084388
60541,"public <I>void hear(InjectableType<I> injectableType,Encounter<I> encounter){
  notificationCount.incrementAndGet();
}","public <I>void hear(InjectableType<I> injectableType,Encounter<I> encounter){
  encounterReference.set(encounter);
}",0.8205128205128205
60542,"public void init(final ServletContext servletContext,Injector injector) throws ServletException {
  if (!isSingletonBinding(injector.getBinding(filterKey))) {
    throw new ServletException(""String_Node_Str"" + filterKey + ""String_Node_Str"");
  }
  Filter filter=injector.getInstance(filterKey);
  this.filter.set(filter);
  filter.init(new FilterConfig(){
    public String getFilterName(){
      return filterKey.toString();
    }
    public ServletContext getServletContext(){
      return servletContext;
    }
    public String getInitParameter(    String s){
      return initParams.get(s);
    }
    public Enumeration getInitParameterNames(){
      return Iterators.asEnumeration(initParams.keySet().iterator());
    }
  }
);
}","public void init(final ServletContext servletContext,Injector injector,Set<Filter> initializedSoFar) throws ServletException {
  if (!isSingletonBinding(injector.getBinding(filterKey))) {
    throw new ServletException(""String_Node_Str"" + filterKey + ""String_Node_Str"");
  }
  Filter filter=injector.getInstance(filterKey);
  this.filter.set(filter);
  if (initializedSoFar.contains(filter)) {
    return;
  }
  filter.init(new FilterConfig(){
    public String getFilterName(){
      return filterKey.toString();
    }
    public ServletContext getServletContext(){
      return servletContext;
    }
    public String getInitParameter(    String s){
      return initParams.get(s);
    }
    public Enumeration getInitParameterNames(){
      return Iterators.asEnumeration(initParams.keySet().iterator());
    }
  }
);
  initializedSoFar.add(filter);
}",0.924433249370277
60543,"public void destroy(){
  Filter reference=filter.get();
  if (null == reference) {
    return;
  }
  reference.destroy();
}","public void destroy(Set<Filter> destroyedSoFar){
  Filter reference=filter.get();
  if (null == reference || destroyedSoFar.contains(reference)) {
    return;
  }
  try {
    reference.destroy();
  }
  finally {
    destroyedSoFar.add(reference);
  }
}",0.5386666666666666
60544,"public synchronized void initPipeline(ServletContext servletContext) throws ServletException {
  if (initialized)   return;
  for (  FilterDefinition filterDefinition : filterDefinitions) {
    filterDefinition.init(servletContext,injector);
  }
  servletPipeline.init(servletContext,injector);
  initialized=true;
}","public synchronized void initPipeline(ServletContext servletContext) throws ServletException {
  if (initialized)   return;
  Set<Filter> initializedSoFar=Sets.newIdentityHashSet(ReferenceType.STRONG);
  for (  FilterDefinition filterDefinition : filterDefinitions) {
    filterDefinition.init(servletContext,injector,initializedSoFar);
  }
  servletPipeline.init(servletContext,injector);
  initialized=true;
}",0.8500687757909215
60545,"public void destroyPipeline(){
  servletPipeline.destroy();
  for (  FilterDefinition filterDefinition : filterDefinitions) {
    filterDefinition.destroy();
  }
}","public void destroyPipeline(){
  servletPipeline.destroy();
  Set<Filter> destroyedSoFar=Sets.newIdentityHashSet(ReferenceType.STRONG);
  for (  FilterDefinition filterDefinition : filterDefinitions) {
    filterDefinition.destroy(destroyedSoFar);
  }
}",0.7836538461538461
60546,"public void init(ServletContext servletContext,Injector injector) throws ServletException {
  for (  ServletDefinition servletDefinition : servletDefinitions) {
    servletDefinition.init(servletContext,injector);
  }
}","public void init(ServletContext servletContext,Injector injector) throws ServletException {
  Set<HttpServlet> initializedSoFar=Sets.newIdentityHashSet(ReferenceType.STRONG);
  for (  ServletDefinition servletDefinition : servletDefinitions) {
    servletDefinition.init(servletContext,injector,initializedSoFar);
  }
}",0.3866171003717472
60547,"public void forward(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  if (servletResponse.isCommitted()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  servletResponse.resetBuffer();
  servletDefinition.doService(servletRequest,servletResponse);
}","public void forward(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  Preconditions.checkState(!servletResponse.isCommitted(),""String_Node_Str"" + ""String_Node_Str"");
  servletResponse.resetBuffer();
  servletDefinition.doService(servletRequest,servletResponse);
}",0.8592592592592593
60548,"/** 
 * @return Returns a request dispatcher wrapped with a servlet mapped tothe given path or null if no mapping was found.
 */
RequestDispatcher getRequestDispatcher(String path){
  for (  final ServletDefinition servletDefinition : servletDefinitions) {
    if (servletDefinition.shouldServe(path)) {
      return new RequestDispatcher(){
        public void forward(        ServletRequest servletRequest,        ServletResponse servletResponse) throws ServletException, IOException {
          if (servletResponse.isCommitted()) {
            throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          servletResponse.resetBuffer();
          servletDefinition.doService(servletRequest,servletResponse);
        }
        public void include(        ServletRequest servletRequest,        ServletResponse servletResponse) throws ServletException, IOException {
          servletDefinition.doService(servletRequest,servletResponse);
        }
      }
;
    }
  }
  return null;
}","/** 
 * @return Returns a request dispatcher wrapped with a servlet mapped tothe given path or null if no mapping was found.
 */
RequestDispatcher getRequestDispatcher(String path){
  for (  final ServletDefinition servletDefinition : servletDefinitions) {
    if (servletDefinition.shouldServe(path)) {
      return new RequestDispatcher(){
        public void forward(        ServletRequest servletRequest,        ServletResponse servletResponse) throws ServletException, IOException {
          Preconditions.checkState(!servletResponse.isCommitted(),""String_Node_Str"" + ""String_Node_Str"");
          servletResponse.resetBuffer();
          servletDefinition.doService(servletRequest,servletResponse);
        }
        public void include(        ServletRequest servletRequest,        ServletResponse servletResponse) throws ServletException, IOException {
          servletDefinition.doService(servletRequest,servletResponse);
        }
      }
;
    }
  }
  return null;
}",0.9449131513647644
60549,"public void destroy(){
  for (  ServletDefinition servletDefinition : servletDefinitions) {
    servletDefinition.destroy();
  }
}","public void destroy(){
  Set<HttpServlet> destroyedSoFar=Sets.newIdentityHashSet(ReferenceType.STRONG);
  for (  ServletDefinition servletDefinition : servletDefinitions) {
    servletDefinition.destroy(destroyedSoFar);
  }
}",0.7323943661971831
60550,"public void init(final ServletContext servletContext,Injector injector) throws ServletException {
  if (!isSingletonBinding(injector.getBinding(servletKey))) {
    throw new ServletException(""String_Node_Str"" + servletKey + ""String_Node_Str"");
  }
  HttpServlet httpServlet=injector.getInstance(servletKey);
  this.httpServlet.set(httpServlet);
  httpServlet.init(new ServletConfig(){
    public String getServletName(){
      return servletKey.toString();
    }
    public ServletContext getServletContext(){
      return servletContext;
    }
    public String getInitParameter(    String s){
      return initParams.get(s);
    }
    public Enumeration getInitParameterNames(){
      return Iterators.asEnumeration(initParams.keySet().iterator());
    }
  }
);
}","public void init(final ServletContext servletContext,Injector injector,Set<HttpServlet> initializedSoFar) throws ServletException {
  if (!isSingletonBinding(injector.getBinding(servletKey))) {
    throw new ServletException(""String_Node_Str"" + servletKey + ""String_Node_Str"");
  }
  HttpServlet httpServlet=injector.getInstance(servletKey);
  this.httpServlet.set(httpServlet);
  if (initializedSoFar.contains(httpServlet)) {
    return;
  }
  httpServlet.init(new ServletConfig(){
    public String getServletName(){
      return servletKey.toString();
    }
    public ServletContext getServletContext(){
      return servletContext;
    }
    public String getInitParameter(    String s){
      return initParams.get(s);
    }
    public Enumeration getInitParameterNames(){
      return Iterators.asEnumeration(initParams.keySet().iterator());
    }
  }
);
  initializedSoFar.add(httpServlet);
}",0.918918918918919
60551,"public void destroy(){
  HttpServlet reference=httpServlet.get();
  if (null == reference) {
    return;
  }
  reference.destroy();
}","public void destroy(Set<HttpServlet> destroyedSoFar){
  HttpServlet reference=httpServlet.get();
  if (null == reference || destroyedSoFar.contains(reference)) {
    return;
  }
  try {
    reference.destroy();
  }
  finally {
    destroyedSoFar.add(reference);
  }
}",0.555
60552,"private void pathInfoWithServletStyleMatching(final String requestUri,final String contextPath,String mapping,final String expectedPathInfo,final String servletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getPathInfo();
      if (null == expectedPathInfo) {
        assertNull(String.format(""String_Node_Str"",expectedPathInfo,path),path);
      }
 else {
        assertEquals(String.format(""String_Node_Str"",expectedPathInfo,path),expectedPathInfo,path);
      }
      assertSame(""String_Node_Str"",path,servletRequest.getPathInfo());
      run[0]=true;
    }
  }
);
  expect(request.getRequestURI()).andReturn(requestUri);
  expect(request.getServletPath()).andReturn(servletPath).anyTimes();
  expect(request.getContextPath()).andReturn(contextPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector);
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}","private void pathInfoWithServletStyleMatching(final String requestUri,final String contextPath,String mapping,final String expectedPathInfo,final String servletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getPathInfo();
      if (null == expectedPathInfo) {
        assertNull(String.format(""String_Node_Str"",expectedPathInfo,path),path);
      }
 else {
        assertEquals(String.format(""String_Node_Str"",expectedPathInfo,path),expectedPathInfo,path);
      }
      assertSame(""String_Node_Str"",path,servletRequest.getPathInfo());
      run[0]=true;
    }
  }
);
  expect(request.getRequestURI()).andReturn(requestUri);
  expect(request.getServletPath()).andReturn(servletPath).anyTimes();
  expect(request.getContextPath()).andReturn(contextPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector,Sets.<HttpServlet>newIdentityHashSet(ReferenceType.STRONG));
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}",0.9828737300435414
60553,"private void servletPath(final String requestPath,String mapping,final String expectedServletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getServletPath();
      assertEquals(String.format(""String_Node_Str"",expectedServletPath,path),expectedServletPath,path);
      run[0]=true;
    }
  }
);
  expect(request.getServletPath()).andReturn(requestPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector);
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}","private void servletPath(final String requestPath,String mapping,final String expectedServletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getServletPath();
      assertEquals(String.format(""String_Node_Str"",expectedServletPath,path),expectedServletPath,path);
      run[0]=true;
    }
  }
);
  expect(request.getServletPath()).andReturn(requestPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector,Sets.<HttpServlet>newIdentityHashSet(ReferenceType.STRONG));
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}",0.9776768823306848
60554,"public final void pathInfoWithRegexMatching(final String requestUri,final String contextPath,String mapping,final String expectedPathInfo,final String servletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getPathInfo();
      if (null == expectedPathInfo) {
        assertNull(String.format(""String_Node_Str"",expectedPathInfo,path),path);
      }
 else {
        assertEquals(String.format(""String_Node_Str"",expectedPathInfo,path),expectedPathInfo,path);
      }
      assertSame(""String_Node_Str"",path,servletRequest.getPathInfo());
      run[0]=true;
    }
  }
);
  expect(request.getRequestURI()).andReturn(requestUri);
  expect(request.getServletPath()).andReturn(servletPath).anyTimes();
  expect(request.getContextPath()).andReturn(contextPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.REGEX,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector);
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}","public final void pathInfoWithRegexMatching(final String requestUri,final String contextPath,String mapping,final String expectedPathInfo,final String servletPath) throws IOException, ServletException {
  Injector injector=createMock(Injector.class);
  HttpServletRequest request=createMock(HttpServletRequest.class);
  HttpServletResponse response=createMock(HttpServletResponse.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final boolean[] run=new boolean[1];
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(new HttpServlet(){
    @Override protected void service(    HttpServletRequest servletRequest,    HttpServletResponse httpServletResponse) throws ServletException, IOException {
      final String path=servletRequest.getPathInfo();
      if (null == expectedPathInfo) {
        assertNull(String.format(""String_Node_Str"",expectedPathInfo,path),path);
      }
 else {
        assertEquals(String.format(""String_Node_Str"",expectedPathInfo,path),expectedPathInfo,path);
      }
      assertSame(""String_Node_Str"",path,servletRequest.getPathInfo());
      run[0]=true;
    }
  }
);
  expect(request.getRequestURI()).andReturn(requestUri);
  expect(request.getServletPath()).andReturn(servletPath).anyTimes();
  expect(request.getContextPath()).andReturn(contextPath);
  replay(injector,request);
  ServletDefinition servletDefinition=new ServletDefinition(mapping,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.REGEX,mapping),new HashMap<String,String>());
  servletDefinition.init(null,injector,Sets.<HttpServlet>newIdentityHashSet(ReferenceType.STRONG));
  servletDefinition.doService(request,response);
  assertTrue(""String_Node_Str"",run[0]);
}",0.9828338667442535
60555,"public final void testServletInitAndConfig() throws ServletException {
  Injector injector=createMock(Injector.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final HttpServlet mockServlet=new HttpServlet(){
  }
;
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(mockServlet).anyTimes();
  replay(injector);
  final Map<String,String> initParams=new HashMap<String,String>(){
{
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  String pattern=""String_Node_Str"";
  final ServletDefinition servletDefinition=new ServletDefinition(pattern,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,pattern),initParams);
  ServletContext servletContext=createMock(ServletContext.class);
  final String contextName=""String_Node_Str"" + getClass();
  expect(servletContext.getServletContextName()).andReturn(contextName);
  replay(servletContext);
  servletDefinition.init(servletContext,injector);
  assertNotNull(mockServlet.getServletContext());
  assertEquals(contextName,mockServlet.getServletContext().getServletContextName());
  assertEquals(Key.get(HttpServlet.class).toString(),mockServlet.getServletName());
  final ServletConfig servletConfig=mockServlet.getServletConfig();
  final Enumeration names=servletConfig.getInitParameterNames();
  while (names.hasMoreElements()) {
    String name=(String)names.nextElement();
    assertTrue(initParams.containsKey(name));
    assertEquals(initParams.get(name),servletConfig.getInitParameter(name));
  }
}","public final void testServletInitAndConfig() throws ServletException {
  Injector injector=createMock(Injector.class);
  expect(injector.getBinding(Key.get(HttpServlet.class))).andReturn(createMock(Binding.class));
  final HttpServlet mockServlet=new HttpServlet(){
  }
;
  expect(injector.getInstance(Key.get(HttpServlet.class))).andReturn(mockServlet).anyTimes();
  replay(injector);
  final Map<String,String> initParams=new HashMap<String,String>(){
{
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  String pattern=""String_Node_Str"";
  final ServletDefinition servletDefinition=new ServletDefinition(pattern,Key.get(HttpServlet.class),UriPatternType.get(UriPatternType.SERVLET,pattern),initParams);
  ServletContext servletContext=createMock(ServletContext.class);
  final String contextName=""String_Node_Str"" + getClass();
  expect(servletContext.getServletContextName()).andReturn(contextName);
  replay(servletContext);
  servletDefinition.init(servletContext,injector,Sets.<HttpServlet>newIdentityHashSet(ReferenceType.STRONG));
  assertNotNull(mockServlet.getServletContext());
  assertEquals(contextName,mockServlet.getServletContext().getServletContextName());
  assertEquals(Key.get(HttpServlet.class).toString(),mockServlet.getServletName());
  final ServletConfig servletConfig=mockServlet.getServletConfig();
  final Enumeration names=servletConfig.getInitParameterNames();
  while (names.hasMoreElements()) {
    String name=(String)names.nextElement();
    assertTrue(initParams.containsKey(name));
    assertEquals(initParams.get(name),servletConfig.getInitParameter(name));
  }
}",0.9833755987602142
60556,"public final void testDispatchRequestToManagedPipelineServlets() throws ServletException, IOException {
  final Injector injector=Guice.createInjector(new ServletModule(){
    @Override protected void configureServlets(){
      serve(""String_Node_Str"").with(TestServlet.class);
      serve(""String_Node_Str"").with(NeverServlet.class);
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
    }
  }
);
  final FilterPipeline pipeline=injector.getInstance(FilterPipeline.class);
  pipeline.initPipeline(null);
  HttpServletRequest requestMock=createMock(HttpServletRequest.class);
  expect(requestMock.getServletPath()).andReturn(""String_Node_Str"").times(1);
  replay(requestMock);
  pipeline.dispatch(requestMock,null,createMock(FilterChain.class));
  pipeline.destroyPipeline();
  verify(requestMock);
  assertTrue(""String_Node_Str"" + inits + ""String_Node_Str""+ services+ ""String_Node_Str""+ destroys,inits == 5 && services == 1 && destroys == 5);
}","public final void testDispatchRequestToManagedPipelineServlets() throws ServletException, IOException {
  final Injector injector=Guice.createInjector(new ServletModule(){
    @Override protected void configureServlets(){
      serve(""String_Node_Str"").with(TestServlet.class);
      serve(""String_Node_Str"").with(NeverServlet.class);
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
    }
  }
);
  final FilterPipeline pipeline=injector.getInstance(FilterPipeline.class);
  pipeline.initPipeline(null);
  HttpServletRequest requestMock=createMock(HttpServletRequest.class);
  expect(requestMock.getServletPath()).andReturn(""String_Node_Str"").times(1);
  replay(requestMock);
  pipeline.dispatch(requestMock,null,createMock(FilterChain.class));
  pipeline.destroyPipeline();
  verify(requestMock);
  assertTrue(""String_Node_Str"" + inits + ""String_Node_Str""+ services+ ""String_Node_Str""+ destroys,inits == 2 && services == 1 && destroys == 2);
}",0.9981701738334858
60557,"public final void testDispatchRequestToManagedPipelineWithFilter() throws ServletException, IOException {
  final Injector injector=Guice.createInjector(new ServletModule(){
    @Override protected void configureServlets(){
      filter(""String_Node_Str"").through(TestFilter.class);
      serve(""String_Node_Str"").with(TestServlet.class);
      serve(""String_Node_Str"").with(NeverServlet.class);
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
    }
  }
);
  final FilterPipeline pipeline=injector.getInstance(FilterPipeline.class);
  pipeline.initPipeline(null);
  HttpServletRequest requestMock=createMock(HttpServletRequest.class);
  expect(requestMock.getServletPath()).andReturn(""String_Node_Str"").times(2);
  replay(requestMock);
  pipeline.dispatch(requestMock,null,createMock(FilterChain.class));
  pipeline.destroyPipeline();
  verify(requestMock);
  assertTrue(""String_Node_Str"" + inits + ""String_Node_Str""+ services+ ""String_Node_Str""+ destroys,inits == 6 && services == 1 && destroys == 6 && doFilters == 1);
}","public final void testDispatchRequestToManagedPipelineWithFilter() throws ServletException, IOException {
  final Injector injector=Guice.createInjector(new ServletModule(){
    @Override protected void configureServlets(){
      filter(""String_Node_Str"").through(TestFilter.class);
      serve(""String_Node_Str"").with(TestServlet.class);
      serve(""String_Node_Str"").with(NeverServlet.class);
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
      serve(""String_Node_Str"").with(Key.get(NeverServlet.class));
    }
  }
);
  final FilterPipeline pipeline=injector.getInstance(FilterPipeline.class);
  pipeline.initPipeline(null);
  HttpServletRequest requestMock=createMock(HttpServletRequest.class);
  expect(requestMock.getServletPath()).andReturn(""String_Node_Str"").times(2);
  replay(requestMock);
  pipeline.dispatch(requestMock,null,createMock(FilterChain.class));
  pipeline.destroyPipeline();
  verify(requestMock);
  assertTrue(""String_Node_Str"" + inits + ""String_Node_Str""+ services+ ""String_Node_Str""+ destroys+ ""String_Node_Str""+ doFilters,inits == 3 && services == 1 && destroys == 3 && doFilters == 1);
}",0.9856781802864364
60558,"public void destroy(){
  filter.get().destroy();
}","public void destroy(){
  Filter reference=filter.get();
  if (null == reference) {
    return;
  }
  reference.destroy();
}",0.5780346820809249
60559,"public void destroy(){
  httpServlet.get().destroy();
}","public void destroy(){
  HttpServlet reference=httpServlet.get();
  if (null == reference) {
    return;
  }
  reference.destroy();
}",0.5851063829787234
60560,"private static void checkForMisplacedBindingAnnotations(Member member,Errors errors){
  Annotation misplacedBindingAnnotation=Annotations.findBindingAnnotation(errors,member,((AnnotatedElement)member).getAnnotations());
  if (misplacedBindingAnnotation != null) {
    errors.misplacedBindingAnnotation(member,misplacedBindingAnnotation);
  }
}","private static void checkForMisplacedBindingAnnotations(Member member,Errors errors){
  Annotation misplacedBindingAnnotation=Annotations.findBindingAnnotation(errors,member,((AnnotatedElement)member).getAnnotations());
  if (misplacedBindingAnnotation == null) {
    return;
  }
  if (member instanceof Method) {
    try {
      if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) {
        return;
      }
    }
 catch (    NoSuchFieldException ignore) {
    }
  }
  errors.misplacedBindingAnnotation(member,misplacedBindingAnnotation);
}",0.7483443708609272
60561,"@Override protected final void configure(){
  install(filtersModuleBuilder);
  install(servletsModuleBuilder);
  bindScope(RequestScoped.class,REQUEST);
  bindScope(SessionScoped.class,SESSION);
  Provider<HttpServletRequest> requestProvider=new Provider<HttpServletRequest>(){
    public HttpServletRequest get(){
      return GuiceFilter.getRequest();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  bind(HttpServletRequest.class).toProvider(requestProvider);
  bind(ServletRequest.class).toProvider(requestProvider);
  Provider<HttpServletResponse> responseProvider=new Provider<HttpServletResponse>(){
    public HttpServletResponse get(){
      return GuiceFilter.getResponse();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  bind(HttpServletResponse.class).toProvider(responseProvider);
  bind(ServletResponse.class).toProvider(responseProvider);
  bind(HttpSession.class).toProvider(new Provider<HttpSession>(){
    public HttpSession get(){
      return GuiceFilter.getRequest().getSession();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  bind(ServletContext.class).toProvider(new Provider<ServletContext>(){
    public ServletContext get(){
      return GuiceFilter.getServletContext();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  bind(new TypeLiteral<Map<String,String[]>>(){
  }
).annotatedWith(RequestParameters.class).toProvider(new Provider<Map<String,String[]>>(){
    @SuppressWarnings({""String_Node_Str""}) public Map<String,String[]> get(){
      return GuiceFilter.getRequest().getParameterMap();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  requestStaticInjection(GuiceFilter.class);
}","@Override protected final void configure(){
  configureServlets();
  install(filtersModuleBuilder);
  install(servletsModuleBuilder);
  bindScope(RequestScoped.class,REQUEST);
  bindScope(SessionScoped.class,SESSION);
  Provider<HttpServletRequest> requestProvider=new Provider<HttpServletRequest>(){
    public HttpServletRequest get(){
      return GuiceFilter.getRequest();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  bind(HttpServletRequest.class).toProvider(requestProvider);
  bind(ServletRequest.class).toProvider(requestProvider);
  Provider<HttpServletResponse> responseProvider=new Provider<HttpServletResponse>(){
    public HttpServletResponse get(){
      return GuiceFilter.getResponse();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  bind(HttpServletResponse.class).toProvider(responseProvider);
  bind(ServletResponse.class).toProvider(responseProvider);
  bind(HttpSession.class).toProvider(new Provider<HttpSession>(){
    public HttpSession get(){
      return GuiceFilter.getRequest().getSession();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  bind(ServletContext.class).toProvider(new Provider<ServletContext>(){
    public ServletContext get(){
      return GuiceFilter.getServletContext();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  bind(new TypeLiteral<Map<String,String[]>>(){
  }
).annotatedWith(RequestParameters.class).toProvider(new Provider<Map<String,String[]>>(){
    @SuppressWarnings({""String_Node_Str""}) public Map<String,String[]> get(){
      return GuiceFilter.getRequest().getParameterMap();
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  requestStaticInjection(GuiceFilter.class);
}",0.9936057825966084
60562,"protected void configure(){
  bind(Runnable.class).toProvider(new Provider<Runnable>(){
    public Runnable get(){
      throw new UnsupportedOperationException();
    }
  }
);
  requestInjection(new NeedsRunnable());
}","protected void configure(){
  requestStaticInjection(BlowsUpOnInject.class);
}",0.3636363636363636
60563,"public void toInstance(final T instance){
  checkNotTargetted();
  if (instance == null) {
    binder.addError(""String_Node_Str"" + ""String_Node_Str"");
    toProvider(Providers.<T>of(null));
    return;
  }
  List<InjectionPoint> injectionPointsList=Lists.newArrayList();
  try {
    InjectionPoint.addForInstanceMethodsAndFields(instance.getClass(),injectionPointsList);
  }
 catch (  ConfigurationException e) {
    for (    Message message : e.getErrorMessages()) {
      binder.addError(message);
    }
  }
  ImmutableSet<InjectionPoint> injectionPoints=ImmutableSet.copyOf(injectionPointsList);
  target=new InstanceTarget<T>(instance,injectionPoints);
}","public void toInstance(final T instance){
  checkNotTargetted();
  if (instance == null) {
    binder.addError(BINDING_TO_NULL);
    toProvider(Providers.<T>of(null));
    return;
  }
  List<InjectionPoint> injectionPointsList=Lists.newArrayList();
  try {
    InjectionPoint.addForInstanceMethodsAndFields(instance.getClass(),injectionPointsList);
  }
 catch (  ConfigurationException e) {
    for (    Message message : e.getErrorMessages()) {
      binder.addError(message);
    }
  }
  ImmutableSet<InjectionPoint> injectionPoints=ImmutableSet.copyOf(injectionPointsList);
  target=new InstanceTarget<T>(instance,injectionPoints);
}",0.9629057187017002
60564,"private void to(Class<?> type,Object instance){
  checkNotNull(instance,""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") Class<T> typeAsClassT=(Class<T>)type;
  @SuppressWarnings(""String_Node_Str"") T instanceAsT=(T)instance;
  if (keyTypeIsSet()) {
    binder.addError(CONSTANT_VALUE_ALREADY_SET);
    return;
  }
  if (key.getAnnotation() != null) {
    key=Key.get(typeAsClassT,key.getAnnotation());
  }
 else   if (key.getAnnotationType() != null) {
    key=Key.get(typeAsClassT,key.getAnnotationType());
  }
 else {
    key=Key.get(typeAsClassT);
  }
  ModuleBinding.this.target=new InstanceTarget<T>(instanceAsT,ImmutableSet.<InjectionPoint>of());
}","private void to(Class<?> type,Object instance){
  @SuppressWarnings(""String_Node_Str"") Class<T> typeAsClassT=(Class<T>)type;
  @SuppressWarnings(""String_Node_Str"") T instanceAsT=(T)instance;
  if (keyTypeIsSet()) {
    binder.addError(CONSTANT_VALUE_ALREADY_SET);
    return;
  }
  if (key.getAnnotation() != null) {
    key=Key.get(typeAsClassT,key.getAnnotation());
  }
 else   if (key.getAnnotationType() != null) {
    key=Key.get(typeAsClassT,key.getAnnotationType());
  }
 else {
    key=Key.get(typeAsClassT);
  }
  ModuleBinding.this.target=new InstanceTarget<T>(instanceAsT,ImmutableSet.<InjectionPoint>of());
  if (instanceAsT == null) {
    binder.addError(BINDING_TO_NULL);
  }
}",0.915129151291513
60565,"private void putBinding(BindingImpl<?> binding){
  Key<?> key=binding.getKey();
  Class<?> rawType=key.getRawType();
  if (FORBIDDEN_TYPES.contains(rawType)) {
    errors.cannotBindToGuiceType(rawType.getSimpleName());
    return;
  }
  Binding<?> original=state.getExplicitBinding(key);
  if (original != null && !""String_Node_Str"".equals(original.acceptTargetVisitor(GET_BOUND_PROVIDER_CLASS_NAME))) {
    errors.bindingAlreadySet(key,original.getSource());
    return;
  }
  state.parent().blacklist(key);
  state.putBinding(key,binding);
}","private void putBinding(BindingImpl<?> binding){
  Key<?> key=binding.getKey();
  Class<?> rawType=key.getRawType();
  if (FORBIDDEN_TYPES.contains(rawType)) {
    errors.cannotBindToGuiceType(rawType.getSimpleName());
    return;
  }
  Binding<?> original=state.getExplicitBinding(key);
  if (original != null) {
    boolean isOkayDuplicate=original instanceof ProviderInstanceBindingImpl && ""String_Node_Str"".equals(original.acceptTargetVisitor(GET_BOUND_PROVIDER_CLASS_NAME));
    if (!isOkayDuplicate) {
      errors.bindingAlreadySet(key,original.getSource());
      return;
    }
  }
  state.parent().blacklist(key);
  state.putBinding(key,binding);
}",0.8916666666666667
60566,"/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(final Class<T> type,Scope scope,ProvidedBy providedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == type) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    Dependency dependency) throws ErrorsException {
      Provider<?> provider=providerBinding.internalFactory.get(errors,context,dependency);
      Object o=provider.get();
      if (o != null && !type.isInstance(o)) {
        throw errors.withSource(type).subtypeNotProvided(providerType,type).toException();
      }
      @SuppressWarnings(""String_Node_Str"") T t=(T)o;
      return t;
    }
  }
;
  Key<T> key=Key.get(type);
  return new LinkedProviderBindingImpl<T>(this,key,type,Scopes.<T>scope(key,this,internalFactory,scope),scope,providerKey,loadStrategy);
}","/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(final Class<T> type,Scope scope,ProvidedBy providedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == type) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    Dependency dependency) throws ErrorsException {
      Provider<?> provider=providerBinding.internalFactory.get(errors,context,dependency);
      try {
        Object o=provider.get();
        if (o != null && !type.isInstance(o)) {
          throw errors.withSource(type).subtypeNotProvided(providerType,type).toException();
        }
        @SuppressWarnings(""String_Node_Str"") T t=(T)o;
        return t;
      }
 catch (      RuntimeException e) {
        throw errors.withSource(type).errorInProvider(e,null).toException();
      }
    }
  }
;
  Key<T> key=Key.get(type);
  return new LinkedProviderBindingImpl<T>(this,key,type,Scopes.<T>scope(key,this,internalFactory,scope),scope,providerKey,loadStrategy);
}",0.9448648648648648
60567,"private <T>void validateKey(Object source,Key<T> key){
  Class<? super T> rawType=key.getRawType();
  if (!Classes.isConcrete(rawType)) {
    Class<? extends Annotation> scopeAnnotation=Scopes.findScopeAnnotation(errors,rawType);
    if (scopeAnnotation != null) {
      errors.withSource(StackTraceElements.forType(rawType)).scopeAnnotationOnAbstractType(scopeAnnotation,rawType,source);
    }
  }
}","private <T>void validateKey(Object source,Key<T> key){
  Scopes.checkForMisplacedScopeAnnotations(key.getRawType(),source,errors);
}",0.3345864661654135
60568,"/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(final Class<T> type,ProvidedBy providedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == type) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    InjectionPoint injectionPoint) throws ErrorsException {
      Provider<?> provider=providerBinding.internalFactory.get(errors,context,injectionPoint);
      Object o=provider.get();
      if (o != null && !type.isInstance(o)) {
        throw errors.withSource(StackTraceElements.forType(type)).subtypeNotProvided(providerType,type).toException();
      }
      @SuppressWarnings(""String_Node_Str"") T t=(T)o;
      return t;
    }
  }
;
  return new LinkedProviderBindingImpl<T>(this,Key.get(type),StackTraceElements.forType(type),internalFactory,Scopes.NO_SCOPE,providerKey,loadStrategy);
}","/** 
 * Creates a binding for a type annotated with @ProvidedBy. 
 */
<T>BindingImpl<T> createProvidedByBinding(final Class<T> type,Scope scope,ProvidedBy providedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  final Class<? extends Provider<?>> providerType=providedBy.value();
  if (providerType == type) {
    throw errors.recursiveProviderType().toException();
  }
  @SuppressWarnings(""String_Node_Str"") Key<? extends Provider<T>> providerKey=(Key<? extends Provider<T>>)Key.get(providerType);
  final BindingImpl<? extends Provider<?>> providerBinding=getBindingOrThrow(providerKey,errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    InjectionPoint injectionPoint) throws ErrorsException {
      Provider<?> provider=providerBinding.internalFactory.get(errors,context,injectionPoint);
      Object o=provider.get();
      if (o != null && !type.isInstance(o)) {
        throw errors.withSource(StackTraceElements.forType(type)).subtypeNotProvided(providerType,type).toException();
      }
      @SuppressWarnings(""String_Node_Str"") T t=(T)o;
      return t;
    }
  }
;
  Key<T> key=Key.get(type);
  return new LinkedProviderBindingImpl<T>(this,key,StackTraceElements.forType(type),Scopes.<T>scope(key,this,internalFactory,scope),scope,providerKey,loadStrategy);
}",0.9127864005912788
60569,"/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified. TODO(jessewilson): Fix raw types! this method makes a binding for   {@code Foo} from a requestfor  {@code Foo<String>}
 * @param type the raw type for {@code key}
 */
<T>BindingImpl<T> createUnitializedBinding(Key<T> key,Class<T> type,Scope scope,Object source,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  if (type.isArray() || type.isEnum()) {
    throw errors.missingImplementation(type).toException();
  }
  ImplementedBy implementedBy=type.getAnnotation(ImplementedBy.class);
  if (implementedBy != null) {
    return createImplementedByBinding(type,implementedBy,loadStrategy,errors);
  }
  ProvidedBy providedBy=type.getAnnotation(ProvidedBy.class);
  if (providedBy != null) {
    return createProvidedByBinding(type,providedBy,loadStrategy,errors);
  }
  if (Modifier.isAbstract(type.getModifiers())) {
    throw errors.missingImplementation(key).toException();
  }
  if (Classes.isInnerClass(type)) {
    throw errors.cannotInjectInnerClass(type).toException();
  }
  if (scope == null) {
    Class<? extends Annotation> scopeAnnotation=Scopes.findScopeAnnotation(errors,type);
    if (scopeAnnotation != null) {
      scope=scopes.get(scopeAnnotation);
      if (scope == null) {
        errors.withSource(StackTraceElements.forType(type)).scopeNotFound(scopeAnnotation);
      }
    }
  }
  Key<T> keyForRawType=Key.get(type);
  LateBoundConstructor<T> lateBoundConstructor=new LateBoundConstructor<T>();
  InternalFactory<? extends T> scopedFactory=Scopes.scope(keyForRawType,this,lateBoundConstructor,scope);
  return new ClassBindingImpl<T>(this,keyForRawType,source,scopedFactory,scope,lateBoundConstructor,loadStrategy);
}","/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified. TODO(jessewilson): Fix raw types! this method makes a binding for   {@code Foo} from a requestfor  {@code Foo<String>}
 * @param type the raw type for {@code key}
 */
<T>BindingImpl<T> createUnitializedBinding(Key<T> key,Class<T> type,Scope scope,Object source,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  if (type.isArray() || type.isEnum()) {
    throw errors.missingImplementation(type).toException();
  }
  ImplementedBy implementedBy=type.getAnnotation(ImplementedBy.class);
  if (implementedBy != null) {
    Scopes.checkForMisplacedScopeAnnotations(type,source,errors);
    return createImplementedByBinding(type,scope,implementedBy,loadStrategy,errors);
  }
  ProvidedBy providedBy=type.getAnnotation(ProvidedBy.class);
  if (providedBy != null) {
    Scopes.checkForMisplacedScopeAnnotations(type,source,errors);
    return createProvidedByBinding(type,scope,providedBy,loadStrategy,errors);
  }
  if (Modifier.isAbstract(type.getModifiers())) {
    throw errors.missingImplementation(key).toException();
  }
  if (Classes.isInnerClass(type)) {
    throw errors.cannotInjectInnerClass(type).toException();
  }
  if (scope == null) {
    Class<? extends Annotation> scopeAnnotation=Scopes.findScopeAnnotation(errors,type);
    if (scopeAnnotation != null) {
      scope=scopes.get(scopeAnnotation);
      if (scope == null) {
        errors.withSource(StackTraceElements.forType(type)).scopeNotFound(scopeAnnotation);
      }
    }
  }
  Key<T> keyForRawType=Key.get(type);
  LateBoundConstructor<T> lateBoundConstructor=new LateBoundConstructor<T>();
  InternalFactory<? extends T> scopedFactory=Scopes.scope(keyForRawType,this,lateBoundConstructor,scope);
  return new ClassBindingImpl<T>(this,keyForRawType,source,scopedFactory,scope,lateBoundConstructor,loadStrategy);
}",0.961206896551724
60570,"/** 
 * Creates a binding for a type annotated with @ImplementedBy. 
 */
<T>BindingImpl<T> createImplementedByBinding(Class<T> type,ImplementedBy implementedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  Class<?> implementationType=implementedBy.value();
  if (implementationType == type) {
    throw errors.recursiveImplementationType().toException();
  }
  if (!type.isAssignableFrom(implementationType)) {
    throw errors.notASubtype(implementationType,type).toException();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends T> subclass=(Class<? extends T>)implementationType;
  final BindingImpl<? extends T> targetBinding=getBindingOrThrow(Key.get(subclass),errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    InjectionPoint<?> injectionPoint) throws ErrorsException {
      return targetBinding.internalFactory.get(errors,context,injectionPoint);
    }
  }
;
  return new LinkedBindingImpl<T>(this,Key.get(type),StackTraceElements.forType(type),internalFactory,Scopes.NO_SCOPE,Key.get(subclass),loadStrategy);
}","/** 
 * Creates a binding for a type annotated with @ImplementedBy. 
 */
<T>BindingImpl<T> createImplementedByBinding(Class<T> type,Scope scope,ImplementedBy implementedBy,LoadStrategy loadStrategy,Errors errors) throws ErrorsException {
  Class<?> implementationType=implementedBy.value();
  if (implementationType == type) {
    throw errors.recursiveImplementationType().toException();
  }
  if (!type.isAssignableFrom(implementationType)) {
    throw errors.notASubtype(implementationType,type).toException();
  }
  @SuppressWarnings(""String_Node_Str"") Class<? extends T> subclass=(Class<? extends T>)implementationType;
  final BindingImpl<? extends T> targetBinding=getBindingOrThrow(Key.get(subclass),errors);
  InternalFactory<T> internalFactory=new InternalFactory<T>(){
    public T get(    Errors errors,    InternalContext context,    InjectionPoint<?> injectionPoint) throws ErrorsException {
      return targetBinding.internalFactory.get(errors,context,injectionPoint);
    }
  }
;
  Key<T> key=Key.get(type);
  return new LinkedBindingImpl<T>(this,key,StackTraceElements.forType(type),Scopes.<T>scope(key,this,internalFactory,scope),scope,Key.get(subclass),loadStrategy);
}",0.9535683576956148
60571,"public void testSingletons(){
  Injector injector=Guice.createInjector(singletonsModule);
  assertSame(injector.getInstance(BoundAsSingleton.class),injector.getInstance(BoundAsSingleton.class));
  assertSame(injector.getInstance(AnnotatedSingleton.class),injector.getInstance(AnnotatedSingleton.class));
  assertSame(injector.getInstance(EagerSingleton.class),injector.getInstance(EagerSingleton.class));
  assertSame(injector.getInstance(LinkedSingleton.class),injector.getInstance(LinkedSingleton.class));
  assertSame(injector.getInstance(JustInTimeSingleton.class),injector.getInstance(JustInTimeSingleton.class));
  assertNotSame(injector.getInstance(NotASingleton.class),injector.getInstance(NotASingleton.class));
}","public void testSingletons(){
  Injector injector=Guice.createInjector(singletonsModule);
  assertSame(injector.getInstance(BoundAsSingleton.class),injector.getInstance(BoundAsSingleton.class));
  assertSame(injector.getInstance(AnnotatedSingleton.class),injector.getInstance(AnnotatedSingleton.class));
  assertSame(injector.getInstance(EagerSingleton.class),injector.getInstance(EagerSingleton.class));
  assertSame(injector.getInstance(LinkedSingleton.class),injector.getInstance(LinkedSingleton.class));
  assertSame(injector.getInstance(JustInTimeSingleton.class),injector.getInstance(JustInTimeSingleton.class));
  assertNotSame(injector.getInstance(NotASingleton.class),injector.getInstance(NotASingleton.class));
  assertSame(injector.getInstance(ImplementedBySingleton.class),injector.getInstance(ImplementedBySingleton.class));
  assertSame(injector.getInstance(ProvidedBySingleton.class),injector.getInstance(ProvidedBySingleton.class));
}",0.8636363636363636
60572,"public E get(){
  return null;
}","public ProvidedBySingleton get(){
  return new ProvidedBySingleton();
}",0.5631067961165048
60573,"@Override protected void setUp() throws Exception {
  AnnotatedSingleton.nextInstanceId=0;
  BoundAsSingleton.nextInstanceId=0;
  EagerSingleton.nextInstanceId=0;
  RealLinkedSingleton.nextInstanceId=0;
  JustInTimeSingleton.nextInstanceId=0;
  NotASingleton.nextInstanceId=0;
}","@Override protected void setUp() throws Exception {
  AnnotatedSingleton.nextInstanceId=0;
  BoundAsSingleton.nextInstanceId=0;
  EagerSingleton.nextInstanceId=0;
  RealLinkedSingleton.nextInstanceId=0;
  JustInTimeSingleton.nextInstanceId=0;
  NotASingleton.nextInstanceId=0;
  Implementation.nextInstanceId=0;
  ProvidedBySingleton.nextInstanceId=0;
}",0.8811410459587956
60574,"/** 
 * Returns the canonical form of this key for serialization. The returned instance is always a   {@code Key}, never a subclass. This prevents problems caused by serializing anonymous types.
 */
protected final Object writeReplace(){
  return getClass() == Key.class ? this : new Key<T>(typeLiteral,annotationStrategy);
}","protected final Object writeReplace(){
  return new SerializedForm(this);
}",0.295
60575,"public void writeBindInterceptor(final Binder binder,final InterceptorBinding element){
  List<MethodInterceptor> interceptors=element.getInterceptors();
  binder.withSource(element.getSource()).bindInterceptor(element.getClassMatcher(),element.getMethodMatcher(),interceptors.toArray(new MethodInterceptor[interceptors.size()]));
}","protected void writeBindInterceptor(final Binder binder,final InterceptorBinding element){
  List<MethodInterceptor> interceptors=element.getInterceptors();
  binder.withSource(element.getSource()).bindInterceptor(element.getClassMatcher(),element.getMethodMatcher(),interceptors.toArray(new MethodInterceptor[interceptors.size()]));
}",0.9805097451274364
60576,"public void writeBindScope(final Binder binder,final ScopeBinding element){
  binder.withSource(element.getSource()).bindScope(element.getAnnotationType(),element.getScope());
}","protected void writeBindScope(final Binder binder,final ScopeBinding element){
  binder.withSource(element.getSource()).bindScope(element.getAnnotationType(),element.getScope());
}",0.969187675070028
60577,"public <T>void writeGetProvider(final Binder binder,final ProviderLookup<T> element){
  Provider<T> provider=binder.withSource(element.getSource()).getProvider(element.getKey());
  element.initDelegate(provider);
}","protected <T>void writeGetProvider(final Binder binder,final ProviderLookup<T> element){
  Provider<T> provider=binder.withSource(element.getSource()).getProvider(element.getKey());
  element.initDelegate(provider);
}",0.974477958236659
60578,"public <T>void writeBind(final Binder binder,final Binding<T> element){
  LinkedBindingBuilder<T> lbb=binder.withSource(element.getSource()).bind(element.getKey());
  ScopedBindingBuilder sbb=applyTarget(element,lbb);
  applyScoping(element,sbb);
}","protected <T>void writeBind(final Binder binder,final Binding<T> element){
  LinkedBindingBuilder<T> lbb=binder.withSource(element.getSource()).bind(element.getKey());
  ScopedBindingBuilder sbb=applyTarget(element,lbb);
  applyScoping(element,sbb);
}",0.9739478957915833
60579,"public void writeConvertToTypes(final Binder binder,final TypeConverterBinding element){
  binder.withSource(element.getSource()).convertToTypes(element.getTypeMatcher(),element.getTypeConverter());
}","protected void writeConvertToTypes(final Binder binder,final TypeConverterBinding element){
  binder.withSource(element.getSource()).convertToTypes(element.getTypeMatcher(),element.getTypeConverter());
}",0.967741935483871
60580,"public void writeRequestStaticInjection(final Binder binder,final StaticInjectionRequest element){
  Class<?> type=element.getType();
  binder.withSource(element.getSource()).requestStaticInjection(type);
}","protected void writeRequestStaticInjection(final Binder binder,final StaticInjectionRequest element){
  Class<?> type=element.getType();
  binder.withSource(element.getSource()).requestStaticInjection(type);
}",0.9686746987951808
60581,"public void writeMessage(final Binder binder,final Message element){
  binder.addError(element);
}","protected void writeMessage(final Binder binder,final Message element){
  binder.addError(element);
}",0.9447236180904522
60582,"/** 
 * Execute this target against the linked binding builder.
 */
public <T>ScopedBindingBuilder applyTarget(Binding<T> binding,final LinkedBindingBuilder<T> linkedBindingBuilder){
  return binding.acceptTargetVisitor(new BindingTargetVisitor<T,ScopedBindingBuilder>(){
    public ScopedBindingBuilder visitInstance(    T instance,    Set<InjectionPoint> injectionPoints){
      linkedBindingBuilder.toInstance(instance);
      return null;
    }
    public ScopedBindingBuilder visitProvider(    Provider<? extends T> provider,    Set<InjectionPoint> injectionPoints){
      return linkedBindingBuilder.toProvider(provider);
    }
    public ScopedBindingBuilder visitProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      return linkedBindingBuilder.toProvider(providerKey);
    }
    public ScopedBindingBuilder visitKey(    Key<? extends T> key){
      return linkedBindingBuilder.to(key);
    }
    public ScopedBindingBuilder visitUntargetted(){
      return linkedBindingBuilder;
    }
    public ScopedBindingBuilder visitConvertedConstant(    T value){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    public ScopedBindingBuilder visitConstructor(    Constructor<? extends T> constructor,    Set<InjectionPoint> injectionPoints){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    public ScopedBindingBuilder visitProviderBinding(    Key<?> provided){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
);
}","/** 
 * Execute this target against the linked binding builder.
 */
protected <T>ScopedBindingBuilder applyTarget(Binding<T> binding,final LinkedBindingBuilder<T> linkedBindingBuilder){
  return binding.acceptTargetVisitor(new BindingTargetVisitor<T,ScopedBindingBuilder>(){
    public ScopedBindingBuilder visitInstance(    T instance,    Set<InjectionPoint> injectionPoints){
      linkedBindingBuilder.toInstance(instance);
      return null;
    }
    public ScopedBindingBuilder visitProvider(    Provider<? extends T> provider,    Set<InjectionPoint> injectionPoints){
      return linkedBindingBuilder.toProvider(provider);
    }
    public ScopedBindingBuilder visitProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      return linkedBindingBuilder.toProvider(providerKey);
    }
    public ScopedBindingBuilder visitKey(    Key<? extends T> key){
      return linkedBindingBuilder.to(key);
    }
    public ScopedBindingBuilder visitUntargetted(){
      return linkedBindingBuilder;
    }
    public ScopedBindingBuilder visitConvertedConstant(    T value){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    public ScopedBindingBuilder visitConstructor(    Constructor<? extends T> constructor,    Set<InjectionPoint> injectionPoints){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    public ScopedBindingBuilder visitProviderBinding(    Key<?> provided){
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
);
}",0.99566522174058
60583,"public void applyScoping(Binding<?> binding,final ScopedBindingBuilder scopedBindingBuilder){
  binding.acceptScopingVisitor(new BindingScopingVisitor<Void>(){
    public Void visitEagerSingleton(){
      scopedBindingBuilder.asEagerSingleton();
      return null;
    }
    public Void visitScope(    Scope scope){
      scopedBindingBuilder.in(scope);
      return null;
    }
    public Void visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      scopedBindingBuilder.in(scopeAnnotation);
      return null;
    }
    public Void visitNoScoping(){
      return null;
    }
  }
);
}","protected void applyScoping(Binding<?> binding,final ScopedBindingBuilder scopedBindingBuilder){
  binding.acceptScopingVisitor(new BindingScopingVisitor<Void>(){
    public Void visitEagerSingleton(){
      scopedBindingBuilder.asEagerSingleton();
      return null;
    }
    public Void visitScope(    Scope scope){
      scopedBindingBuilder.in(scope);
      return null;
    }
    public Void visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      scopedBindingBuilder.in(scopeAnnotation);
      return null;
    }
    public Void visitNoScoping(){
      return null;
    }
  }
);
}",0.9893004115226336
60584,"public void writeRequestInjection(final Binder binder,final InjectionRequest command){
  binder.withSource(command.getSource()).requestInjection(command.getInstance());
}","protected void writeRequestInjection(final Binder binder,final InjectionRequest command){
  binder.withSource(command.getSource()).requestInjection(command.getInstance());
}",0.967930029154519
60585,"/** 
 * Fails unless   {@code object} doesn't equal itself when reserialized.
 */
public static void assertEqualWhenReserialized(Object object) throws IOException {
  Assert.assertTrue(""String_Node_Str"",hasSerialVersionUid(object));
  Object reserialized=reserialize(object);
  Assert.assertEquals(object,reserialized);
  Assert.assertEquals(object.hashCode(),reserialized.hashCode());
}","/** 
 * Fails unless   {@code object} doesn't equal itself when reserialized.
 */
public static void assertEqualWhenReserialized(Object object) throws IOException {
  Object reserialized=reserialize(object);
  assertEquals(object,reserialized);
  assertEquals(object.hashCode(),reserialized.hashCode());
}",0.7716763005780347
60586,"/** 
 * Fails unless   {@code object} has the same toString value when reserialized.
 */
public static void assertSimilarWhenReserialized(Object object) throws IOException {
  Assert.assertTrue(""String_Node_Str"",hasSerialVersionUid(object));
  Object reserialized=reserialize(object);
  Assert.assertEquals(object.toString(),reserialized.toString());
}","/** 
 * Fails unless   {@code object} has the same toString value when reserialized.
 */
public static void assertSimilarWhenReserialized(Object object) throws IOException {
  Object reserialized=reserialize(object);
  assertEquals(object.toString(),reserialized.toString());
}",0.7599364069952306
60587,"public static void assertNotSerializable(Object object) throws IOException {
  Assert.assertFalse(""String_Node_Str"",hasSerialVersionUid(object));
  try {
    reserialize(object);
    Assert.fail();
  }
 catch (  NotSerializableException expected) {
  }
}","public static void assertNotSerializable(Object object) throws IOException {
  try {
    reserialize(object);
    Assert.fail();
  }
 catch (  NotSerializableException expected) {
  }
}",0.8428246013667426
60588,"/** 
 * Fails unless   {@code expected.equals(actual)},   {@code actual.equals(expected)} and their hash codes are equal. This is usefulfor testing the equals method itself.
 */
public static void assertEqualsBothWays(Object expected,Object actual){
  Assert.assertNotNull(expected);
  Assert.assertNotNull(actual);
  Assert.assertTrue(""String_Node_Str"",expected.equals(actual));
  Assert.assertTrue(""String_Node_Str"",actual.equals(expected));
  Assert.assertEquals(""String_Node_Str"",expected.hashCode(),actual.hashCode());
}","/** 
 * Fails unless   {@code expected.equals(actual)},   {@code actual.equals(expected)} and their hash codes are equal. This is usefulfor testing the equals method itself.
 */
public static void assertEqualsBothWays(Object expected,Object actual){
  assertNotNull(expected);
  assertNotNull(actual);
  assertTrue(""String_Node_Str"",expected.equals(actual));
  assertTrue(""String_Node_Str"",actual.equals(expected));
  assertEquals(""String_Node_Str"",expected.hashCode(),actual.hashCode());
}",0.9655172413793104
60589,"/** 
 * Fails unless   {@code text} includes all {@code substrings}, in order.
 */
public static void assertContains(String text,String... substrings){
  int startingFrom=0;
  for (int i=0; i < substrings.length; i++) {
    int index=text.indexOf(substrings[i],startingFrom);
    Assert.assertTrue(String.format(""String_Node_Str"",text,substrings[i]),index >= startingFrom);
    startingFrom=index + substrings[i].length();
  }
  String lastSubstring=substrings[substrings.length - 1];
  Assert.assertTrue(String.format(""String_Node_Str"",text,lastSubstring),text.indexOf(lastSubstring,startingFrom) == -1);
}","/** 
 * Fails unless   {@code text} includes all {@code substrings}, in order.
 */
public static void assertContains(String text,String... substrings){
  int startingFrom=0;
  for (  String substring : substrings) {
    int index=text.indexOf(substring,startingFrom);
    assertTrue(String.format(""String_Node_Str"",text,substring),index >= startingFrom);
    startingFrom=index + substring.length();
  }
  String lastSubstring=substrings[substrings.length - 1];
  assertTrue(String.format(""String_Node_Str"",text,lastSubstring),text.indexOf(lastSubstring,startingFrom) == -1);
}",0.9222972972972971
60590,"static Object reserialize(Object object) throws IOException {
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    new ObjectOutputStream(out).writeObject(object);
    ByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());
    return new ObjectInputStream(in).readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
}","public static <E>E reserialize(E original) throws IOException {
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    new ObjectOutputStream(out).writeObject(original);
    ByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());
    @SuppressWarnings(""String_Node_Str"") E reserialized=(E)new ObjectInputStream(in).readObject();
    return reserialized;
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
}",0.2579132473622508
60591,"public void testSerialization() throws IOException, NoSuchFieldException {
  assertEqualWhenReserialized(Key.get(B.class));
  assertEqualWhenReserialized(Key.get(B.class,Names.named(""String_Node_Str"")));
  assertEqualWhenReserialized(Key.get(B.class,Named.class));
  assertEqualWhenReserialized(Key.get(B[].class));
  assertEqualWhenReserialized(Key.get(new TypeLiteral<Map<List<B>,B>>(){
  }
));
  assertEqualWhenReserialized(Key.get(new TypeLiteral<List<B[]>>(){
  }
));
  assertEqualWhenReserialized(new Key<List<B[]>>(){
  }
);
  assertEqualWhenReserialized(Key.get(Types.listOf(Types.subtypeOf(CharSequence.class))));
}","public void testSerialization() throws IOException, NoSuchFieldException {
  assertEqualWhenReserialized(Key.get(B.class));
  assertEqualWhenReserialized(Key.get(B.class,Names.named(""String_Node_Str"")));
  assertEqualWhenReserialized(Key.get(B.class,Named.class));
  assertEqualWhenReserialized(Key.get(B[].class));
  assertEqualWhenReserialized(Key.get(new TypeLiteral<Map<List<B>,B>>(){
  }
));
  assertEqualWhenReserialized(Key.get(new TypeLiteral<List<B[]>>(){
  }
));
  assertEquals(new Key<List<B[]>>(){
  }
,Asserts.reserialize(new Key<List<B[]>>(){
  }
));
  assertEqualWhenReserialized(Key.get(Types.listOf(Types.subtypeOf(CharSequence.class))));
}",0.9492583918813428
60592,"public void testWithWildcardType() throws NoSuchFieldException, IOException {
  TypeLiteral<?> a=TypeLiteral.get(getClass().getField(""String_Node_Str"").getGenericType());
  TypeLiteral<?> b=TypeLiteral.get(Types.listOf(Types.subtypeOf(CharSequence.class)));
  assertEqualsBothWays(a,b);
  assertEquals(""String_Node_Str"",a.toString());
  assertEquals(""String_Node_Str"",b.toString());
  assertEqualWhenReserialized(a);
  assertEqualWhenReserialized(b);
}","public void testWithWildcardType() throws NoSuchFieldException, IOException {
  TypeLiteral<?> a=TypeLiteral.get(getClass().getField(""String_Node_Str"").getGenericType());
  TypeLiteral<?> b=TypeLiteral.get(Types.listOf(Types.subtypeOf(CharSequence.class)));
  assertEqualsBothWays(a,b);
  assertEquals(""String_Node_Str"",a.toString());
  assertEquals(""String_Node_Str"",b.toString());
  assertNotSerializable(a);
  assertNotSerializable(b);
}",0.92152466367713
60593,"public void testSerialization() throws IOException {
  assertEqualWhenReserialized(new TypeLiteral<List<String>>(){
  }
);
}","public void testSerialization() throws IOException {
  assertNotSerializable(new TypeLiteral<List<String>>(){
  }
);
}",0.9173553719008264
60594,"BindCommandProcessor(Errors errors,InjectorImpl injector,Map<Class<? extends Annotation>,Scope> scopes,Map<Key<?>,BindingImpl<?>> bindings,Set<Object> outstandingInjections){
  super(errors);
  this.injector=injector;
  this.scopes=scopes;
  this.bindings=bindings;
  this.outstandingInjections=outstandingInjections;
}","BindCommandProcessor(Errors errors,InjectorImpl injector,Map<Class<? extends Annotation>,Scope> scopes,Map<Key<?>,BindingImpl<?>> bindings,CreationTimeMemberInjector memberInjector){
  super(errors);
  this.injector=injector;
  this.scopes=scopes;
  this.bindings=bindings;
  this.memberInjector=memberInjector;
}",0.7721518987341772
60595,"@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    errors.bindingToProvider();
    return true;
  }
  validateKey(command.getSource(),command.getKey());
  final LoadStrategy loadStrategy=command.getScoping().isEagerSingleton() ? LoadStrategy.EAGER : LoadStrategy.LAZY;
  final Scope scope=command.getScoping().acceptVisitor(new Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        errors.scopeNotFound(scopeAnnotation);
        return null;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      if (instance == null) {
        errors.cannotBindToNullInstance();
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.add(instance);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.add(provider);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider,loadStrategy));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      putBinding(new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey,loadStrategy));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        errors.recursiveBinding();
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey,loadStrategy));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        errors.missingImplementation(key);
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      final BindingImpl<T> binding;
      try {
        binding=injector.createUnitializedBinding(clazz,scope,source,loadStrategy,errors);
        putBinding(binding);
      }
 catch (      ErrorsException e) {
        errors.merge(e.getErrors());
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          try {
            injector.initializeBinding(binding,errors);
          }
 catch (          ErrorsException e) {
            errors.merge(e.getErrors());
          }
        }
      }
);
      return null;
    }
  }
);
  return true;
}","@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    errors.bindingToProvider();
    return true;
  }
  validateKey(command.getSource(),command.getKey());
  final LoadStrategy loadStrategy=command.getScoping().isEagerSingleton() ? LoadStrategy.EAGER : LoadStrategy.LAZY;
  final Scope scope=command.getScoping().acceptVisitor(new Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        errors.scopeNotFound(scopeAnnotation);
        return null;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      if (instance == null) {
        errors.cannotBindToNullInstance();
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      memberInjector.add(instance);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      memberInjector.add(provider);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider,loadStrategy));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      putBinding(new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey,loadStrategy));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        errors.recursiveBinding();
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      putBinding(new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey,loadStrategy));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        errors.missingImplementation(key);
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      final BindingImpl<T> binding;
      try {
        binding=injector.createUnitializedBinding(clazz,scope,source,loadStrategy,errors);
        putBinding(binding);
      }
 catch (      ErrorsException e) {
        errors.merge(e.getErrors());
        putBinding(invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          try {
            injector.initializeBinding(binding,errors);
          }
 catch (          ErrorsException e) {
            errors.merge(e.getErrors());
          }
        }
      }
);
      return null;
    }
  }
);
  return true;
}",0.994399805210616
60596,"public Void visitToProvider(Provider<? extends T> provider){
  InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
  outstandingInjections.add(provider);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  putBinding(new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider,loadStrategy));
  return null;
}","public Void visitToProvider(Provider<? extends T> provider){
  InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
  memberInjector.add(provider);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  putBinding(new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider,loadStrategy));
  return null;
}",0.9730363423212192
60597,"public Void visitToInstance(T instance){
  if (instance == null) {
    errors.cannotBindToNullInstance();
    putBinding(invalidBinding(injector,key,source));
    return null;
  }
  ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
  outstandingInjections.add(instance);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  putBinding(new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
  return null;
}","public Void visitToInstance(T instance){
  if (instance == null) {
    errors.cannotBindToNullInstance();
    putBinding(invalidBinding(injector,key,source));
    return null;
  }
  ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
  memberInjector.add(instance);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  putBinding(new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
  return null;
}",0.975916230366492
60598,"/** 
 * Builds the injector. 
 */
private void buildCoreInjector(){
  new ErrorsCommandProcessor(errors).processCommands(commands);
  BindInterceptorCommandProcessor bindInterceptorCommandProcessor=new BindInterceptorCommandProcessor(errors);
  bindInterceptorCommandProcessor.processCommands(commands);
  ConstructionProxyFactory proxyFactory=bindInterceptorCommandProcessor.createProxyFactory();
  injector.reflection=reflectionFactory.create(proxyFactory);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopesCommandProcessor(errors,injector.scopes).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ConvertToTypesCommandProcessor(errors,injector.converters).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindLogger();
  bindCommandProcesor=new BindCommandProcessor(errors,injector,injector.scopes,injector.explicitBindings,injector.outstandingInjections);
  bindCommandProcesor.processCommands(commands);
  bindCommandProcesor.createUntargettedBindings();
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.index();
  stopwatch.resetAndLog(""String_Node_Str"");
  requestInjectionCommandProcessor=new RequestInjectionCommandProcessor(errors,injector.outstandingInjections);
  requestInjectionCommandProcessor.processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
}","/** 
 * Builds the injector. 
 */
private void buildCoreInjector(){
  new ErrorsCommandProcessor(errors).processCommands(commands);
  BindInterceptorCommandProcessor bindInterceptorCommandProcessor=new BindInterceptorCommandProcessor(errors);
  bindInterceptorCommandProcessor.processCommands(commands);
  ConstructionProxyFactory proxyFactory=bindInterceptorCommandProcessor.createProxyFactory();
  injector.reflection=reflectionFactory.create(proxyFactory);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopesCommandProcessor(errors,injector.scopes).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ConvertToTypesCommandProcessor(errors,injector.converters).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindLogger();
  bindCommandProcesor=new BindCommandProcessor(errors,injector,injector.scopes,injector.explicitBindings,injector.memberInjector);
  bindCommandProcesor.processCommands(commands);
  bindCommandProcesor.createUntargettedBindings();
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.index();
  stopwatch.resetAndLog(""String_Node_Str"");
  requestInjectionCommandProcessor=new RequestInjectionCommandProcessor(errors,injector.memberInjector);
  requestInjectionCommandProcessor.processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
}",0.9828101644245142
60599,"/** 
 * Inject everything that can be injected. 
 */
private void fulfillInjectionRequests(){
  requestInjectionCommandProcessor.injectMembers(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.fulfillOutstandingInjections(errors);
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
  loadEagerSingletons();
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
}","/** 
 * Inject everything that can be injected. 
 */
private void fulfillInjectionRequests(){
  requestInjectionCommandProcessor.injectMembers(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.memberInjector.injectAll(errors);
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
  loadEagerSingletons();
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
}",0.9428571428571428
60600,"/** 
 * Validate everything that we can validate now that the injector is ready for use. 
 */
private void validate(){
  bindCommandProcesor.runCreationListeners(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  requestInjectionCommandProcessor.validate(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.validateOustandingInjections(errors);
  stopwatch.resetAndLog(""String_Node_Str"");
  new GetProviderProcessor(errors,injector).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
}","/** 
 * Validate everything that we can validate now that the injector is ready for use. 
 */
private void validate(){
  bindCommandProcesor.runCreationListeners(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  requestInjectionCommandProcessor.validate(injector);
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.memberInjector.validateOustandingInjections(errors);
  stopwatch.resetAndLog(""String_Node_Str"");
  new GetProviderProcessor(errors,injector).processCommands(commands);
  stopwatch.resetAndLog(""String_Node_Str"");
  errors.throwCreationExceptionIfErrorsExist();
}",0.9870801033591732
60601,"/** 
 * Ensures that an object requiring injection at Injector-creation time has been injected before its use.
 */
public void ensureMemberInjected(Errors errors,Object toInject) throws ErrorsException {
  if (!injector.outstandingInjections.remove(toInject)) {
    return;
  }
  injector.injectMembersOrThrow(errors,toInject);
}","/** 
 * Ensures that an object requiring injection at Injector-creation time has been injected before its use.
 */
public void ensureMemberInjected(Errors errors,Object toInject) throws ErrorsException {
  injector.memberInjector.ensureInjected(errors,toInject);
}",0.7959527824620574
60602,"@Override public Boolean visitRequestInjection(RequestInjectionCommand command){
  for (  Object instance : command.getInstances()) {
    outstandingInjections.add(instance);
  }
  return true;
}","@Override public Boolean visitRequestInjection(RequestInjectionCommand command){
  for (  Object instance : command.getInstances()) {
    memberInjector.add(instance);
  }
  return true;
}",0.9451697127937336
60603,"RequestInjectionCommandProcessor(Errors errors,Set<Object> outstandingInjections){
  super(errors);
  this.outstandingInjections=outstandingInjections;
}","RequestInjectionCommandProcessor(Errors errors,CreationTimeMemberInjector memberInjector){
  super(errors);
  this.memberInjector=memberInjector;
}",0.6933333333333334
60604,"public void testBindingOrderAndScopes(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(A.class);
      bind(B.class).asEagerSingleton();
    }
  }
);
  assertSame(""String_Node_Str"",injector.getInstance(A.class).b,injector.getInstance(A.class).b);
}","public void testBindingOrderAndScopes(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(A.class);
      bind(B.class).asEagerSingleton();
    }
  }
);
  assertSame(injector.getInstance(A.class).b,injector.getInstance(A.class).b);
}",0.8662207357859532
60605,"protected void configure(){
  bind(A.class);
  bind(B.class).asEagerSingleton();
}","protected void configure(){
  requestInjection(createsAThread);
  bind(A.class).toInstance(new A());
}",0.5652173913043478
60606,"public void testRelatedTypeVariables(){
  TypeResolver resolver=new TypeResolver(arrayListOfString);
  assertEquals(String.class,resolver.getParameterTypes(echo).get(0));
  assertEquals(String.class,resolver.getReturnType(echo));
}","public void testRelatedTypeVariables(){
  TypeResolver resolver=new TypeResolver(hasRelatedOfString);
  assertEquals(String.class,resolver.getParameterTypes(echo).get(0));
  assertEquals(String.class,resolver.getReturnType(echo));
}",0.958963282937365
60607,"public void run(){
  for (  Map.Entry<Object,Object> entry : properties.entrySet()) {
    String key=(String)entry.getKey();
    String value=(String)entry.getValue();
    binder.bind(Key.get(String.class,new NamedImpl(key))).toInstance(value);
  }
}","public void run(){
  for (Enumeration<?> e=properties.propertyNames(); e.hasMoreElements(); ) {
    String propertyName=(String)e.nextElement();
    String value=properties.getProperty(propertyName);
    binder.bind(Key.get(String.class,new NamedImpl(propertyName))).toInstance(value);
  }
}",0.166358595194085
60608,"/** 
 * Creates a constant binding to   {@code @Named(key)} for each property.
 */
public static void bindProperties(final Binder binder,final Properties properties){
  SourceProviders.withDefault(SourceProviders.defaultSource(),new Runnable(){
    public void run(){
      for (      Map.Entry<Object,Object> entry : properties.entrySet()) {
        String key=(String)entry.getKey();
        String value=(String)entry.getValue();
        binder.bind(Key.get(String.class,new NamedImpl(key))).toInstance(value);
      }
    }
  }
);
}","/** 
 * Creates a constant binding to   {@code @Named(key)} for each property. Thismethod binds all properties including those inherited from  {@link Properties#defaults defaults}.
 */
public static void bindProperties(final Binder binder,final Properties properties){
  SourceProviders.withDefault(SourceProviders.defaultSource(),new Runnable(){
    public void run(){
      for (Enumeration<?> e=properties.propertyNames(); e.hasMoreElements(); ) {
        String propertyName=(String)e.nextElement();
        String value=properties.getProperty(propertyName);
        binder.bind(Key.get(String.class,new NamedImpl(propertyName))).toInstance(value);
      }
    }
  }
);
}",0.4872006606110652
60609,"/** 
 * Creates a construction proxy given a class and parameter types.
 */
private <T>ConstructionProxy<T> createConstructionProxy(final Class<?> clazz,final Constructor standardConstructor){
  FastClass fastClass=GuiceFastClass.create(clazz);
  final FastConstructor fastConstructor=fastClass.getConstructor(standardConstructor.getParameterTypes());
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,fastConstructor.getJavaConstructor());
    }
    public Member getMember(){
      return standardConstructor;
    }
  }
;
}","/** 
 * Creates a construction proxy given a class and parameter types.
 */
private <T>ConstructionProxy<T> createConstructionProxy(final Class<?> clazz,final Constructor standardConstructor){
  FastClass fastClass=GuiceFastClass.create(clazz);
  final FastConstructor fastConstructor=fastClass.getConstructor(standardConstructor.getParameterTypes());
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,standardConstructor);
    }
    public Member getMember(){
      return standardConstructor;
    }
  }
;
}",0.9649904519414386
60610,"public List<Parameter<?>> getParameters(){
  return Parameter.forConstructor(errorHandler,fastConstructor.getJavaConstructor());
}","public List<Parameter<?>> getParameters(){
  return Parameter.forConstructor(errorHandler,standardConstructor);
}",0.8806584362139918
60611,"public <T>ConstructionProxy<T> get(final Constructor<T> constructor){
  if (Modifier.isPrivate(constructor.getModifiers()) || Modifier.isProtected(constructor.getModifiers())) {
    constructor.setAccessible(true);
    return new ConstructionProxy<T>(){
      public T newInstance(      Object... arguments) throws InvocationTargetException {
        try {
          return constructor.newInstance(arguments);
        }
 catch (        InstantiationException e) {
          throw new RuntimeException(e);
        }
catch (        IllegalAccessException e) {
          throw new AssertionError(e);
        }
      }
      public List<Parameter<?>> getParameters(){
        return Parameter.forConstructor(errorHandler,constructor);
      }
      public Member getMember(){
        return constructor;
      }
    }
;
  }
  Class<T> classToConstruct=constructor.getDeclaringClass();
  FastClass fastClass=GuiceFastClass.create(classToConstruct);
  final FastConstructor fastConstructor=fastClass.getConstructor(constructor);
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,fastConstructor);
    }
    public Member getMember(){
      return fastConstructor.getJavaConstructor();
    }
  }
;
}","public <T>ConstructionProxy<T> get(final Constructor<T> constructor){
  if (Modifier.isPrivate(constructor.getModifiers()) || Modifier.isProtected(constructor.getModifiers())) {
    constructor.setAccessible(true);
    return new ConstructionProxy<T>(){
      public T newInstance(      Object... arguments) throws InvocationTargetException {
        try {
          return constructor.newInstance(arguments);
        }
 catch (        InstantiationException e) {
          throw new RuntimeException(e);
        }
catch (        IllegalAccessException e) {
          throw new AssertionError(e);
        }
      }
      public List<Parameter<?>> getParameters(){
        return Parameter.forConstructor(errorHandler,constructor);
      }
      public Member getMember(){
        return constructor;
      }
    }
;
  }
  Class<T> classToConstruct=constructor.getDeclaringClass();
  FastClass fastClass=GuiceFastClass.create(classToConstruct);
  final FastConstructor fastConstructor=fastClass.getConstructor(constructor);
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,constructor);
    }
    public Member getMember(){
      return constructor;
    }
  }
;
}",0.9816799170411338
60612,"public List<Parameter<?>> getParameters(){
  return Parameter.forConstructor(errorHandler,fastConstructor);
}","public List<Parameter<?>> getParameters(){
  return Parameter.forConstructor(errorHandler,constructor);
}",0.97196261682243
60613,"public Member getMember(){
  return fastConstructor.getJavaConstructor();
}","public Member getMember(){
  return constructor;
}",0.784
60614,"public Void visitUntargetted(){
  final Type type=key.getTypeLiteral().getType();
  if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
    addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  untargettedBindings.add(new Runnable(){
    public void run(){
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      try {
        BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
        createBinding(source,shouldPreload,binding);
      }
 catch (      ResolveFailedException e) {
        injector.errorHandler.handle(source,e.getMessage());
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
      }
    }
  }
);
  return null;
}","public Void visitUntargetted(){
  final Type type=key.getTypeLiteral().getType();
  if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
    addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  final BindingImpl<T> binding;
  try {
    binding=injector.createUnitializedBinding(clazz,scope,source);
    createBinding(source,shouldPreload,binding);
  }
 catch (  ResolveFailedException e) {
    injector.errorHandler.handle(source,e.getMessage());
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  untargettedBindings.add(new Runnable(){
    public void run(){
      try {
        injector.initializeBinding(binding);
      }
 catch (      ResolveFailedException e) {
        injector.errorHandler.handle(source,e.getMessage());
      }
    }
  }
);
  return null;
}",0.7570247933884298
60615,"@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
          try {
            BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
            createBinding(source,shouldPreload,binding);
          }
 catch (          ResolveFailedException e) {
            injector.errorHandler.handle(source,e.getMessage());
            createBinding(source,shouldPreload,invalidBinding(injector,key,source));
          }
        }
      }
);
      return null;
    }
  }
);
  return true;
}","@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      final BindingImpl<T> binding;
      try {
        binding=injector.createUnitializedBinding(clazz,scope,source);
        createBinding(source,shouldPreload,binding);
      }
 catch (      ResolveFailedException e) {
        injector.errorHandler.handle(source,e.getMessage());
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          try {
            injector.initializeBinding(binding);
          }
 catch (          ResolveFailedException e) {
            injector.errorHandler.handle(source,e.getMessage());
          }
        }
      }
);
      return null;
    }
  }
);
  return true;
}",0.935722067546302
60616,"public void run(){
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  try {
    BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
    createBinding(source,shouldPreload,binding);
  }
 catch (  ResolveFailedException e) {
    injector.errorHandler.handle(source,e.getMessage());
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
  }
}","public void run(){
  try {
    injector.initializeBinding(binding);
  }
 catch (  ResolveFailedException e) {
    injector.errorHandler.handle(source,e.getMessage());
  }
}",0.5813148788927336
60617,"<T>BindingImpl<T> createBindingFromType(Class<T> type,Scope scope,Object source) throws ResolveFailedException {
  if (type.isArray() || type.isEnum() || type.isPrimitive()) {
    throw new ResolveFailedException(ErrorMessages.MISSING_BINDING,type);
  }
  ImplementedBy implementedBy=type.getAnnotation(ImplementedBy.class);
  if (implementedBy != null) {
    return createImplementedByBinding(type,implementedBy);
  }
  ProvidedBy providedBy=type.getAnnotation(ProvidedBy.class);
  if (providedBy != null) {
    return createProvidedByBinding(type,providedBy);
  }
  return createBindingForInjectableType(type,scope,source);
}","<T>BindingImpl<T> createBindingFromType(Class<T> type,Scope scope,Object source) throws ResolveFailedException {
  BindingImpl<T> binding=createUnitializedBinding(type,scope,source);
  initializeBinding(binding);
  return binding;
}",0.3189755529685681
60618,"<T>BindingImpl<T> createBindingJustInTime(Key<T> key){
  if (isProvider(key)) {
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) BindingImpl<T> binding=(BindingImpl<T>)createProviderBinding((Key)key);
    return binding;
  }
  BindingImpl<T> boxedOrUnboxed=getBoxedOrUnboxedBinding(key);
  if (boxedOrUnboxed != null) {
    return boxedOrUnboxed;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    return key.hasAttributes() ? getBinding(key.withoutAttributes()) : null;
  }
  Type type=key.getTypeLiteral().getType();
  if (!(type instanceof Class)) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  return createBindingFromType(clazz);
}","<T>BindingImpl<T> createBindingJustInTime(Key<T> key){
  if (isProvider(key)) {
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) BindingImpl<T> binding=(BindingImpl<T>)createProviderBinding((Key)key);
    return binding;
  }
  BindingImpl<T> boxedOrUnboxed=getBoxedOrUnboxedBinding(key);
  if (boxedOrUnboxed != null) {
    return boxedOrUnboxed;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    return key.hasAttributes() ? getBinding(key.withoutAttributes()) : null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)key.getTypeLiteral().getRawType();
  return createBindingFromType(clazz);
}",0.9135959339263025
60619,"/** 
 * Returns an annotation instance that is not equal to any other annotation instances, for use in creating distinct   {@link Key}s.
 */
private static Annotation uniqueAnnotation(){
  return new Annotation(){
    public Class<? extends Annotation> annotationType(){
      return Internal.class;
    }
  }
;
}","/** 
 * Returns an annotation instance that is not equal to any other annotation instances, for use in creating distinct   {@link Key}s.
 */
private static Annotation uniqueAnnotation(){
  final int value=nextUniqueValue.getAndIncrement();
  return new Internal(){
    public int value(){
      return value;
    }
    public Class<? extends Annotation> annotationType(){
      return Internal.class;
    }
    @Override public String toString(){
      return ""String_Node_Str"" + Internal.class.getName() + ""String_Node_Str""+ value+ ""String_Node_Str"";
    }
    @Override public boolean equals(    Object o){
      return o instanceof Internal && ((Internal)o).value() == value();
    }
    @Override public int hashCode(){
      return 127 * ""String_Node_Str"".hashCode() ^ value;
    }
  }
;
}",0.5474254742547425
60620,"void writeGetConstructionProxy() throws IOException {
  out.writeLine(""String_Node_Str"",SuppressWarnings.class);
  out.openScope(""String_Node_Str"");
  for (  Map.Entry<Class<?>,ConstructionProxy<?>> entry : constructionProxies.entrySet()) {
    Class<?> implementation=entry.getKey();
    out.openScope(""String_Node_Str"",implementation);
    out.openScope(""String_Node_Str"",ConstructionProxy.class,ConstructionProxy.class,implementation);
    out.openScope(""String_Node_Str"",implementation,Object.class,InvocationTargetException.class);
    out.openScope(""String_Node_Str"",implementation);
    int argument=0;
    for (Iterator<Parameter<?>> i=entry.getValue().getParameters().iterator(); i.hasNext(); ) {
      Parameter<?> parameter=i.next();
      String separator=i.hasNext() ? ""String_Node_Str"" : ""String_Node_Str"";
      out.writeLine(""String_Node_Str"",parameter.getKey().getTypeLiteral().getType(),argument,separator);
      argument++;
    }
    out.closeScope(""String_Node_Str"");
    out.closeScope(""String_Node_Str"");
    out.openScope(""String_Node_Str"",List.class,Parameter.class);
    out.openScope(""String_Node_Str"",Arrays.class,Parameter.class);
    argument=0;
    for (Iterator<Parameter<?>> i=entry.getValue().getParameters().iterator(); i.hasNext(); ) {
      Parameter<?> parameter=i.next();
      String separator=i.hasNext() ? ""String_Node_Str"" : ""String_Node_Str"";
      out.writeLine(""String_Node_Str"",Parameter.class,argument,keyLiteral(parameter.getKey()),Nullability.class,parameter.getNullability(),separator);
      argument++;
    }
    out.closeScope(""String_Node_Str"");
    out.closeScope(""String_Node_Str"");
    out.openScope(""String_Node_Str"",Member.class);
    out.writeLine(""String_Node_Str"");
    out.closeScope(""String_Node_Str"");
    out.closeScope(""String_Node_Str"");
    out.closeScope(""String_Node_Str"");
  }
  out.writeLine();
  out.writeLine(""String_Node_Str"",IllegalArgumentException.class);
  out.closeScope(""String_Node_Str"");
}","void writeGetConstructionProxy() throws IOException {
  out.writeLine(""String_Node_Str"",SuppressWarnings.class).openScope(""String_Node_Str"",ConstructionProxy.class,Class.class);
  for (  Map.Entry<Class<?>,ConstructionProxy<?>> entry : constructionProxies.entrySet()) {
    Class<?> implementation=entry.getKey();
    out.openScope(""String_Node_Str"",implementation).openScope(""String_Node_Str"",ConstructionProxy.class,ConstructionProxy.class,implementation);
    out.openScope(""String_Node_Str"",implementation,Object.class,InvocationTargetException.class).openScope(""String_Node_Str"",implementation);
    int argument=0;
    for (Iterator<Parameter<?>> i=entry.getValue().getParameters().iterator(); i.hasNext(); ) {
      Parameter<?> parameter=i.next();
      String separator=i.hasNext() ? ""String_Node_Str"" : ""String_Node_Str"";
      out.writeLine(""String_Node_Str"",parameter.getKey().getTypeLiteral().getType(),argument,separator);
      argument++;
    }
    out.closeScope(""String_Node_Str"").closeScope(""String_Node_Str"");
    out.openScope(""String_Node_Str"",List.class,Parameter.class).openScope(""String_Node_Str"",Arrays.class,Parameter.class);
    argument=0;
    for (Iterator<Parameter<?>> i=entry.getValue().getParameters().iterator(); i.hasNext(); ) {
      Parameter<?> parameter=i.next();
      String separator=i.hasNext() ? ""String_Node_Str"" : ""String_Node_Str"";
      out.writeLine(""String_Node_Str"",Parameter.class,argument,keyLiteral(parameter.getKey()),Nullability.class,parameter.getNullability(),separator);
      argument++;
    }
    out.closeScope(""String_Node_Str"").closeScope(""String_Node_Str"");
    out.openScope(""String_Node_Str"",Member.class).writeLine(""String_Node_Str"").closeScope(""String_Node_Str"");
    out.closeScope(""String_Node_Str"").closeScope(""String_Node_Str"");
  }
  out.writeLine().writeLine(""String_Node_Str"",IllegalArgumentException.class).closeScope(""String_Node_Str"");
}",0.916987920842971
60621,"void writeClass() throws IOException {
  out.writePackageHeader();
  out.writeImport(Reflection.class);
  out.writeImport(ConstructionProxy.class);
  out.writeImport(InvocationTargetException.class);
  out.writeImport(Parameter.class);
  out.writeImport(List.class);
  out.writeImport(Member.class);
  out.writeImport(Parameter.class);
  out.writeImport(Nullability.class);
  out.writeImport(Arrays.class);
  out.writeImport(SuppressWarnings.class);
  out.writeImport(Key.class);
  out.writeImport(IllegalArgumentException.class);
  out.writeImport(Object.class);
  for (  Map.Entry<Class<?>,ConstructionProxy<?>> entry : constructionProxies.entrySet()) {
    out.writeImport(entry.getKey());
    for (    Parameter<?> parameter : entry.getValue().getParameters()) {
      out.writeImport(parameter.getKey().getTypeLiteral().getType());
    }
  }
  out.writeLine();
  out.openScope(""String_Node_Str"",generatedClassSimpleName());
  out.writeLine();
  writeGetConstructionProxy();
  out.writeLine();
  out.closeScope(""String_Node_Str"");
}","void writeClass() throws IOException {
  out.writePackageHeader();
  out.writeImport(Reflection.class);
  out.writeImport(ConstructionProxy.class);
  out.writeImport(InvocationTargetException.class);
  out.writeImport(Parameter.class);
  out.writeImport(List.class);
  out.writeImport(Member.class);
  out.writeImport(Parameter.class);
  out.writeImport(Nullability.class);
  out.writeImport(Arrays.class);
  out.writeImport(SuppressWarnings.class);
  out.writeImport(Key.class);
  out.writeImport(IllegalArgumentException.class);
  out.writeImport(Object.class);
  for (  Map.Entry<Class<?>,ConstructionProxy<?>> entry : constructionProxies.entrySet()) {
    out.writeImport(entry.getKey());
    for (    Parameter<?> parameter : entry.getValue().getParameters()) {
      out.writeImport(parameter.getKey().getTypeLiteral().getType());
    }
  }
  out.writeLine().openScope(""String_Node_Str"",generatedClassSimpleName(),Reflection.class).writeLine();
  writeGetConstructionProxy();
  out.writeLine().closeScope(""String_Node_Str"");
}",0.9806576402321084
60622,"public void openScope(String format,Object... args) throws IOException {
  writeLine(format,args);
  indent++;
}","public JavaCodeGenerator openScope(String format,Object... args) throws IOException {
  writeLine(format,args);
  indent++;
  return this;
}",0.8809523809523809
60623,"public void closeScope(String format,Object... args) throws IOException {
  indent--;
  writeLine(format,args);
}","public JavaCodeGenerator closeScope(String format,Object... args) throws IOException {
  indent--;
  return writeLine(format,args);
}",0.9105691056910568
60624,"public void writeLine() throws IOException {
  writer.append(""String_Node_Str"");
}","public JavaCodeGenerator writeLine() throws IOException {
  writer.append(""String_Node_Str"");
  return this;
}",0.84375
60625,"@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
          BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
          if (binding == null) {
            injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
            createBinding(source,shouldPreload,invalidBinding(injector,key,source));
            return;
          }
          createBinding(source,shouldPreload,binding);
        }
      }
);
      return null;
    }
  }
);
  return true;
}","@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
    addError(source,ErrorMessages.LOGGER_ALREADY_BOUND);
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
          BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
          if (binding == null) {
            injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
            createBinding(source,shouldPreload,invalidBinding(injector,key,source));
            return;
          }
          createBinding(source,shouldPreload,binding);
        }
      }
);
      return null;
    }
  }
);
  return true;
}",0.9930479326747164
60626,"public Void call(InternalContext context){
  InjectionPoint<?> injectionPoint=InjectionPoint.newInstance(key,context.getInjectorImpl());
  context.setInjectionPoint(injectionPoint);
  try {
    factory.get(context,injectionPoint);
    return null;
  }
 catch (  ProvisionException provisionException) {
    provisionException.addContext(injectionPoint);
    throw provisionException;
  }
 finally {
    context.setInjectionPoint(null);
  }
}","public Void call(InternalContext context){
  InjectionPoint<?> injectionPoint=InjectionPoint.newInstance(key,context.getInjector());
  context.setInjectionPoint(injectionPoint);
  try {
    factory.get(context,injectionPoint);
    return null;
  }
 catch (  ProvisionException provisionException) {
    provisionException.addContext(injectionPoint);
    throw provisionException;
  }
 finally {
    context.setInjectionPoint(null);
  }
}",0.9954441913439636
60627,"@SuppressWarnings(""String_Node_Str"") <T>ConstructionContext<T> getConstructionContext(Object key){
  if (constructionContexts == null) {
    constructionContexts=new HashMap<Object,ConstructionContext<?>>();
    ConstructionContext<T> constructionContext=new ConstructionContext<T>();
    constructionContexts.put(key,constructionContext);
    return constructionContext;
  }
 else {
    ConstructionContext<T> constructionContext=(ConstructionContext<T>)constructionContexts.get(key);
    if (constructionContext == null) {
      constructionContext=new ConstructionContext<T>();
      constructionContexts.put(key,constructionContext);
    }
    return constructionContext;
  }
}","@SuppressWarnings(""String_Node_Str"") public <T>ConstructionContext<T> getConstructionContext(Object key){
  if (constructionContexts == null) {
    constructionContexts=new HashMap<Object,ConstructionContext<?>>();
    ConstructionContext<T> constructionContext=new ConstructionContext<T>();
    constructionContexts.put(key,constructionContext);
    return constructionContext;
  }
 else {
    ConstructionContext<T> constructionContext=(ConstructionContext<T>)constructionContexts.get(key);
    if (constructionContext == null) {
      constructionContext=new ConstructionContext<T>();
      constructionContexts.put(key,constructionContext);
    }
    return constructionContext;
  }
}",0.9948867786705624
60628,"InternalContext(InjectorImpl injector){
  this.injector=injector;
}","public InternalContext(InjectorImpl injector){
  this.injector=injector;
}",0.950354609929078
60629,"public void toInstance(final T instance){
  nonNull(instance,""String_Node_Str"");
  checkNotTargetted();
  bindTarget=new AbstractTarget<T>(){
    public ScopedBindingBuilder execute(    LinkedBindingBuilder<T> linkedBindingBuilder){
      linkedBindingBuilder.toInstance(instance);
      return null;
    }
    @Override public T get(){
      return instance;
    }
    public <V>V acceptVisitor(    Visitor<T,V> visitor){
      return visitor.visitToInstance(instance);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + instance;
    }
  }
;
}","public void toInstance(final T instance){
  nonNull(instance,ErrorMessages.CANNOT_BIND_TO_NULL_INSTANCE);
  checkNotTargetted();
  bindTarget=new AbstractTarget<T>(){
    public ScopedBindingBuilder execute(    LinkedBindingBuilder<T> linkedBindingBuilder){
      linkedBindingBuilder.toInstance(instance);
      return null;
    }
    @Override public T get(){
      return instance;
    }
    public <V>V acceptVisitor(    Visitor<T,V> visitor){
      return visitor.visitToInstance(instance);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + instance;
    }
  }
;
}",0.95132365499573
60630,"@Override public Boolean visitBindConstant(BindConstantCommand command){
  Object value=command.getTarget().get();
  if (value == null) {
    addError(command.getSource(),ErrorMessages.MISSING_CONSTANT_VALUE);
  }
  validateKey(command.getSource(),command.getKey());
  ConstantFactory<Object> factory=new ConstantFactory<Object>(value);
  putBinding(new ContantBindingImpl<Object>(injector,command.getKey(),command.getSource(),factory,value));
  return true;
}","@Override public Boolean visitBindConstant(BindConstantCommand command){
  Object value=command.getTarget().get();
  if (value == null) {
    addError(command.getSource(),ErrorMessages.MISSING_CONSTANT_VALUE);
  }
  validateKey(command.getSource(),command.getKey());
  ConstantFactory<Object> factory=new ConstantFactory<Object>(value);
  putBinding(new ConstantBindingImpl<Object>(injector,command.getKey(),command.getSource(),factory,value));
  return true;
}",0.998914223669924
60631,"public Void visitUntargetted(){
  Type type=key.getTypeLiteral().getType();
  if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
    addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
  if (binding == null) {
    addError(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  createBinding(source,shouldPreload,binding);
  return null;
}","public Void visitUntargetted(){
  final Type type=key.getTypeLiteral().getType();
  if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
    addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
    createBinding(source,shouldPreload,invalidBinding(injector,key,source));
    return null;
  }
  untargettedBindings.add(new Runnable(){
    public void run(){
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
      if (binding == null) {
        injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return;
      }
      createBinding(source,shouldPreload,binding);
    }
  }
);
  return null;
}",0.8700195950359242
60632,"@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
      if (binding == null) {
        addError(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      createBinding(source,shouldPreload,binding);
      return null;
    }
  }
);
  return true;
}","@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      final Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      untargettedBindings.add(new Runnable(){
        public void run(){
          @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
          BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
          if (binding == null) {
            injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
            createBinding(source,shouldPreload,invalidBinding(injector,key,source));
            return;
          }
          createBinding(source,shouldPreload,binding);
        }
      }
);
      return null;
    }
  }
);
  return true;
}",0.969355847404628
60633,"/** 
 * Builds the injector.
 */
private void buildCoreInjector(){
  new ErrorsCommandProcessor().processCommands(commands,configurationErrorHandler);
  BindInterceptorCommandProcessor bindInterceptorCommandProcessor=new BindInterceptorCommandProcessor();
  bindInterceptorCommandProcessor.processCommands(commands,configurationErrorHandler);
  injector.constructionProxyFactory=bindInterceptorCommandProcessor.createProxyFactory();
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopesCommandProcessor(injector.scopes).processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ConvertToTypesCommandProcessor(injector.converters).processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindCommandProcesor=new BindCommandProcessor(injector,injector.scopes,stage,injector.explicitBindings,injector.outstandingInjections);
  bindCommandProcesor.processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.index();
  stopwatch.resetAndLog(""String_Node_Str"");
  requestStaticInjectionCommandProcessor=new RequestStaticInjectionCommandProcessor();
  requestStaticInjectionCommandProcessor.processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
}","/** 
 * Builds the injector.
 */
private void buildCoreInjector(){
  new ErrorsCommandProcessor().processCommands(commands,configurationErrorHandler);
  BindInterceptorCommandProcessor bindInterceptorCommandProcessor=new BindInterceptorCommandProcessor();
  bindInterceptorCommandProcessor.processCommands(commands,configurationErrorHandler);
  injector.constructionProxyFactory=bindInterceptorCommandProcessor.createProxyFactory();
  stopwatch.resetAndLog(""String_Node_Str"");
  new ScopesCommandProcessor(injector.scopes).processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
  new ConvertToTypesCommandProcessor(injector.converters).processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
  bindCommandProcesor=new BindCommandProcessor(injector,injector.scopes,stage,injector.explicitBindings,injector.outstandingInjections);
  bindCommandProcesor.processCommands(commands,configurationErrorHandler);
  bindCommandProcesor.createUntargettedBindings();
  stopwatch.resetAndLog(""String_Node_Str"");
  injector.index();
  stopwatch.resetAndLog(""String_Node_Str"");
  requestStaticInjectionCommandProcessor=new RequestStaticInjectionCommandProcessor();
  requestStaticInjectionCommandProcessor.processCommands(commands,configurationErrorHandler);
  stopwatch.resetAndLog(""String_Node_Str"");
}",0.9810620126253248
60634,"protected void configure(){
  bind(BoundFirst.class);
  bind(BoundSecond.class).to(BoundSecondImpl.class);
}","protected void configure(){
  bind(A.class).asEagerSingleton();
  bind(B.class).asEagerSingleton();
}",0.6411483253588517
60635,"/** 
 * Creates a construction proxy given a class and parameter types.
 */
<T>ConstructionProxy<T> createConstructionProxy(Class<?> clazz,Class[] parameterTypes){
  FastClass fastClass=GuiceFastClass.create(clazz);
  final FastConstructor fastConstructor=fastClass.getConstructor(parameterTypes);
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,fastConstructor.getJavaConstructor());
    }
    public Member getMember(){
      return fastConstructor.getJavaConstructor();
    }
  }
;
}","/** 
 * Creates a construction proxy given a class and parameter types.
 */
private <T>ConstructionProxy<T> createConstructionProxy(final Class<?> clazz,final Constructor standardConstructor){
  FastClass fastClass=GuiceFastClass.create(clazz);
  final FastConstructor fastConstructor=fastClass.getConstructor(standardConstructor.getParameterTypes());
  return new ConstructionProxy<T>(){
    @SuppressWarnings(""String_Node_Str"") public T newInstance(    Object... arguments) throws InvocationTargetException {
      return (T)fastConstructor.newInstance(arguments);
    }
    public List<Parameter<?>> getParameters(){
      return Parameter.forConstructor(errorHandler,fastConstructor.getJavaConstructor());
    }
    public Member getMember(){
      return standardConstructor;
    }
  }
;
}",0.7453255963894262
60636,"public Member getMember(){
  return fastConstructor.getJavaConstructor();
}","public Member getMember(){
  return standardConstructor;
}",0.7819548872180451
60637,Member getMember();,"/** 
 * Returns the injected method or constructor. If the injected member is synthetic (such as generated code for method interception), the natural constructor is returned.
 */
Member getMember();",0.1751152073732718
60638,"public void testBindingOrderAndScopes(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(A.class).asEagerSingleton();
      bind(B.class).asEagerSingleton();
    }
  }
);
  A a=injector.getInstance(A.class);
  assertSame(a.first,a.second);
}","public void testBindingOrderAndScopes(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(A.class);
      bind(B.class).asEagerSingleton();
    }
  }
);
  assertSame(injector.getInstance(A.class).b,injector.getInstance(A.class).b);
}",0.6179966044142614
60639,"protected void configure(){
  bind(A.class).asEagerSingleton();
  bind(B.class).asEagerSingleton();
}","protected void configure(){
  bind(A.class);
  bind(B.class).asEagerSingleton();
}",0.8961748633879781
60640,"/** 
 * This test ensures that regardless of binding order, instances are injected before they are used.
 */
public void testCreationTimeInjectionOrdering(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(0){
        @Inject void initialize(        @Named(""String_Node_Str"") Count bCount){
          value=bCount.value + 1;
        }
      }
);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toProvider(new Provider<Count>(){
        Count count;
        @Inject void initialize(        @Named(""String_Node_Str"") Count cCount){
          count=new Count(cCount.value + 2);
        }
        public Count get(){
          return count;
        }
      }
);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(0){
        @Inject @Named(""String_Node_Str"") Count dCount;
        @Inject void initialize(        @Named(""String_Node_Str"") Count eCount){
          value=dCount.value + eCount.value + 4;
        }
      }
);
      requestStaticInjection(StaticallyInjectable.class);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(8));
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(16));
    }
  }
);
  assertEquals(28,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(30,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(31,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(28,StaticallyInjectable.cCountAtInjectionTime);
}","/** 
 * This test ensures that regardless of binding order, instances are injected before they are used. It injects mutable Count objects and records their value at the time that they're injected.
 */
public void testCreationTimeInjectionOrdering(){
  Injector injector=Guice.createInjector(new AbstractModule(){
    protected void configure(){
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(0){
        @Inject void initialize(        @Named(""String_Node_Str"") Count bCount){
          value=bCount.value + 1;
        }
      }
);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toProvider(new Provider<Count>(){
        Count count;
        @Inject void initialize(        @Named(""String_Node_Str"") Count cCount){
          count=new Count(cCount.value + 2);
        }
        public Count get(){
          return count;
        }
      }
);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(0){
        @Inject @Named(""String_Node_Str"") Count dCount;
        @Inject void initialize(        @Named(""String_Node_Str"") Count eCount){
          value=dCount.value + eCount.value + 4;
        }
      }
);
      requestStaticInjection(StaticallyInjectable.class);
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(8));
      bind(Count.class).annotatedWith(named(""String_Node_Str"")).toInstance(new Count(16));
    }
  }
);
  assertEquals(28,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(30,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(31,injector.getInstance(Key.get(Count.class,named(""String_Node_Str""))).value);
  assertEquals(28,StaticallyInjectable.cCountAtInjectionTime);
}",0.9736540664375716
60641,"public Void visitToProvider(Provider<? extends T> provider){
  InternalFactory<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
  registerInstanceForInjection(provider);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
  return null;
}","public Void visitToProvider(Provider<? extends T> provider){
  InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
  outstandingInjections.put(provider,null);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
  return null;
}",0.9163802978235968
60642,"private <T>void createBinding(Object source,boolean shouldPreload,BindingImpl<T> binding){
  putBinding(binding);
  if (binding.getScope() == Scopes.SINGLETON) {
    if (stage == Stage.PRODUCTION || shouldPreload) {
      preloaders.add(new BindingPreloader(binding.key,binding.internalFactory));
    }
  }
 else {
    if (shouldPreload) {
      addError(source,ErrorMessages.PRELOAD_NOT_ALLOWED);
    }
  }
}","private <T>void createBinding(Object source,boolean shouldPreload,BindingImpl<T> binding){
  putBinding(binding);
  if (binding.getScope() == Scopes.SINGLETON) {
    if (stage == Stage.PRODUCTION || shouldPreload) {
      eagerSingletonCreators.add(new EagerSingletonCreator(binding.key,binding.internalFactory));
    }
  }
 else {
    if (shouldPreload) {
      addError(source,ErrorMessages.PRELOAD_NOT_ALLOWED);
    }
  }
}",0.9245508982035928
60643,"BindCommandProcessor(InjectorImpl injector,Map<Class<? extends Annotation>,Scope> scopes,Stage stage,Map<Key<?>,BindingImpl<?>> bindings){
  this.injector=injector;
  this.scopes=scopes;
  this.stage=stage;
  this.bindings=bindings;
}","BindCommandProcessor(InjectorImpl injector,Map<Class<? extends Annotation>,Scope> scopes,Stage stage,Map<Key<?>,BindingImpl<?>> bindings,Map<Object,Void> outstandingInjections){
  this.injector=injector;
  this.scopes=scopes;
  this.stage=stage;
  this.bindings=bindings;
  this.outstandingInjections=outstandingInjections;
}",0.8372093023255814
60644,"@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      InternalFactory<? extends T> factory=new ConstantFactory<T>(instance);
      registerInstanceForInjection(instance);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactory<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      registerInstanceForInjection(provider);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
      if (binding == null) {
        addError(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      createBinding(source,shouldPreload,binding);
      return null;
    }
  }
);
  return true;
}","@Override public <T>Boolean visitBind(BindCommand<T> command){
  final Object source=command.getSource();
  final Key<T> key=command.getKey();
  Class<? super T> rawType=key.getTypeLiteral().getRawType();
  if (rawType == Provider.class) {
    addError(source,ErrorMessages.BINDING_TO_PROVIDER);
    return true;
  }
  if (Logger.class == rawType) {
  }
  validateKey(command.getSource(),command.getKey());
  final boolean shouldPreload=command.getScoping().isEagerSingleton();
  final Scope scope=command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>(){
    public Scope visitEagerSingleton(){
      return Scopes.SINGLETON;
    }
    public Scope visitScope(    Scope scope){
      return scope;
    }
    public Scope visitScopeAnnotation(    Class<? extends Annotation> scopeAnnotation){
      Scope scope=scopes.get(scopeAnnotation);
      if (scope != null) {
        return scope;
      }
 else {
        addError(source,ErrorMessages.SCOPE_NOT_FOUND,""String_Node_Str"" + scopeAnnotation.getSimpleName());
        return Scopes.NO_SCOPE;
      }
    }
    public Scope visitNoScoping(){
      return null;
    }
  }
);
  command.getTarget().acceptVisitor(new BindTarget.Visitor<T,Void>(){
    public Void visitToInstance(    T instance){
      ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
      outstandingInjections.put(instance,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
      return null;
    }
    public Void visitToProvider(    Provider<? extends T> provider){
      InternalFactoryToProviderAdapter<? extends T> factory=new InternalFactoryToProviderAdapter<T>(provider,source);
      outstandingInjections.put(provider,null);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,provider));
      return null;
    }
    public Void visitToProviderKey(    Key<? extends Provider<? extends T>> providerKey){
      final BoundProviderFactory<T> boundProviderFactory=new BoundProviderFactory<T>(providerKey,source);
      creationListeners.add(boundProviderFactory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,(InternalFactory<? extends T>)boundProviderFactory,scope);
      createBinding(source,shouldPreload,new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey));
      return null;
    }
    public Void visitToKey(    Key<? extends T> targetKey){
      if (key.equals(targetKey)) {
        addError(source,ErrorMessages.RECURSIVE_BINDING);
      }
      FactoryProxy<T> factory=new FactoryProxy<T>(key,targetKey,source);
      creationListeners.add(factory);
      InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
      createBinding(source,shouldPreload,new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey));
      return null;
    }
    public Void visitUntargetted(){
      Type type=key.getTypeLiteral().getType();
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        addError(source,ErrorMessages.MISSING_IMPLEMENTATION);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
      BindingImpl<T> binding=injector.createBindingFromType(clazz,scope,source);
      if (binding == null) {
        addError(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
        createBinding(source,shouldPreload,invalidBinding(injector,key,source));
        return null;
      }
      createBinding(source,shouldPreload,binding);
      return null;
    }
  }
);
  return true;
}",0.9832630637536732
60645,"public Void visitToInstance(T instance){
  InternalFactory<? extends T> factory=new ConstantFactory<T>(instance);
  registerInstanceForInjection(instance);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
  return null;
}","public Void visitToInstance(T instance){
  ConstantFactory<? extends T> factory=new ConstantFactory<T>(instance);
  outstandingInjections.put(instance,null);
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,injector,factory,scope);
  createBinding(source,shouldPreload,new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance));
  return null;
}",0.9027027027027028
60646,"BindingImpl<T> build(InjectorImpl injector){
  if (this.factory != null) {
    Scope scope=this.scope == null ? Scopes.NO_SCOPE : this.scope;
    InternalFactory<? extends T> scopedFactory=Scopes.scope(this.key,injector,this.factory,scope);
    if (instance != null) {
      return new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance);
    }
    if (this.targetKey != null) {
      return new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey);
    }
    if (this.providerInstance != null) {
      return new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,providerInstance);
    }
    if (this.providerKey != null) {
      return new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey);
    }
    throw new AssertionError();
  }
 else {
    Type type=key.getTypeLiteral().getType();
    if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
      injector.errorHandler.handle(source,ErrorMessages.MISSING_IMPLEMENTATION);
      return invalidBinding(injector);
    }
    Class<T> clazz=(Class<T>)type;
    BindingImpl<T> binding=injector.createBindingForInjectableType(clazz,scope,source,false);
    if (binding == null) {
      injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
      return invalidBinding(injector);
    }
    return binding;
  }
}","BindingImpl<T> build(InjectorImpl injector){
  if (this.factory != null) {
    Scope scope=this.scope == null ? Scopes.NO_SCOPE : this.scope;
    InternalFactory<? extends T> scopedFactory=Scopes.scope(this.key,injector,this.factory,scope);
    if (instance != null) {
      return new InstanceBindingImpl<T>(injector,key,source,scopedFactory,instance);
    }
    if (this.targetKey != null) {
      return new LinkedBindingImpl<T>(injector,key,source,scopedFactory,scope,targetKey);
    }
    if (this.providerInstance != null) {
      return new ProviderInstanceBindingImpl<T>(injector,key,source,scopedFactory,scope,providerInstance);
    }
    if (this.providerKey != null) {
      return new LinkedProviderBindingImpl<T>(injector,key,source,scopedFactory,scope,providerKey);
    }
    throw new AssertionError();
  }
 else {
    Type type=key.getTypeLiteral().getType();
    if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
      injector.errorHandler.handle(source,ErrorMessages.MISSING_IMPLEMENTATION);
      return invalidBinding(injector);
    }
    Class<T> clazz=(Class<T>)type;
    BindingImpl<T> binding=injector.createBindingForInjectableType(clazz,scope,source);
    if (binding == null) {
      injector.errorHandler.handle(source,ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE,clazz);
      return invalidBinding(injector);
    }
    return binding;
  }
}",0.9978308026030368
60647,"<T>BindingImpl<T> createBindingJustInTime(Key<T> key){
  if (isProvider(key)) {
    return createProviderBindingUnsafely(key);
  }
  BindingImpl<T> boxedOrUnboxed=getBoxedOrUnboxedBinding(key);
  if (boxedOrUnboxed != null) {
    return boxedOrUnboxed;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    return key.hasAttributes() ? getBinding(key.withoutAttributes()) : null;
  }
  Type type=key.getTypeLiteral().getType();
  if (!(type instanceof Class)) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  return createBindingFromType(clazz);
}","<T>BindingImpl<T> createBindingJustInTime(Key<T> key){
  if (isProvider(key)) {
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) BindingImpl<T> binding=(BindingImpl<T>)createProviderBinding((Key)key);
    return binding;
  }
  BindingImpl<T> boxedOrUnboxed=getBoxedOrUnboxedBinding(key);
  if (boxedOrUnboxed != null) {
    return boxedOrUnboxed;
  }
  BindingImpl<T> convertedBinding=convertConstantStringBinding(key);
  if (convertedBinding != null) {
    return convertedBinding;
  }
  if (key.hasAnnotationType()) {
    return key.hasAttributes() ? getBinding(key.withoutAttributes()) : null;
  }
  Type type=key.getTypeLiteral().getType();
  if (!(type instanceof Class)) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)type;
  return createBindingFromType(clazz);
}",0.9102730819245772
60648,"/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified.
 */
<T>BindingImpl<T> createBindingForInjectableType(Class<T> type,Scope scope,Object source,boolean isJit){
  if (Modifier.isAbstract(type.getModifiers())) {
    return null;
  }
  if (Classes.isInnerClass(type)) {
    errorHandler.handle(SourceProviders.defaultSource(),ErrorMessages.CANNOT_INJECT_INNER_CLASS,type);
    return invalidBinding(Key.get(type));
  }
  if (scope == null) {
    scope=Scopes.getScopeForType(type,scopes,errorHandler);
  }
  Key<T> key=Key.get(type);
  LateBoundConstructor<T> lateBoundConstructor=new LateBoundConstructor<T>();
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,this,lateBoundConstructor,scope);
  BindingImpl<T> binding=new ClassBindingImpl<T>(this,key,source,scopedFactory,scope);
  if (isJit) {
    jitBindings.put(key,binding);
  }
  try {
    lateBoundConstructor.bind(this,type);
    return binding;
  }
 catch (  RuntimeException e) {
    if (isJit) {
      jitBindings.remove(key);
    }
    throw e;
  }
catch (  Throwable t) {
    if (isJit) {
      jitBindings.remove(key);
    }
    throw new AssertionError(t);
  }
}","/** 
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if none is specified.
 */
<T>BindingImpl<T> createBindingForInjectableType(Class<T> type,Scope scope,Object source){
  if (Modifier.isAbstract(type.getModifiers())) {
    return null;
  }
  if (Classes.isInnerClass(type)) {
    errorHandler.handle(SourceProviders.defaultSource(),ErrorMessages.CANNOT_INJECT_INNER_CLASS,type);
    return invalidBinding(Key.get(type));
  }
  if (scope == null) {
    scope=Scopes.getScopeForType(type,scopes,errorHandler);
  }
  Key<T> key=Key.get(type);
  LateBoundConstructor<T> lateBoundConstructor=new LateBoundConstructor<T>();
  InternalFactory<? extends T> scopedFactory=Scopes.scope(key,this,lateBoundConstructor,scope);
  BindingImpl<T> binding=new ClassBindingImpl<T>(this,key,source,scopedFactory,scope);
  jitBindings.put(key,binding);
  try {
    lateBoundConstructor.bind(this,type);
    return binding;
  }
 catch (  RuntimeException e) {
    jitBindings.remove(key);
    throw e;
  }
catch (  Throwable t) {
    jitBindings.remove(key);
    throw new AssertionError(t);
  }
}",0.884796573875803
60649,"public void toInstance(T instance){
  ensureImplementationIsNotSet();
  this.instance=Objects.nonNull(instance,""String_Node_Str"");
  this.factory=new ConstantFactory<T>(instance);
  if (this.scope != null) {
    binder.addError(source,ErrorMessages.SINGLE_INSTANCE_AND_SCOPE);
  }
  this.scope=Scopes.CONTAINER;
}","public void toInstance(T instance){
  ensureImplementationIsNotSet();
  this.instance=Objects.nonNull(instance,""String_Node_Str"");
  this.factory=new ConstantFactory<T>(instance);
  if (this.scope != null) {
    binder.addError(source,ErrorMessages.SINGLE_INSTANCE_AND_SCOPE);
  }
}",0.9478991596638656
60650,"public void testLinkedBinding() throws CreationException {
  BinderImpl builder=new BinderImpl();
  Bar bar=new Bar();
  builder.bind(Bar.class).toInstance(bar);
  builder.link(Key.get(Foo.class)).to(Key.get(Bar.class));
  Container container=builder.createContainer();
  Binding<Foo> fooBinding=container.getBinding(Key.get(Foo.class));
  assertSame(bar,fooBinding.getLocator().get());
  assertNotNull(fooBinding.getSource());
  assertEquals(Key.get(Foo.class),fooBinding.getKey());
  assertFalse(fooBinding.isConstant());
}","public void testLinkedBinding() throws CreationException {
  BinderImpl builder=new BinderImpl();
  Bar bar=new Bar();
  builder.bind(Bar.class).toInstance(bar);
  builder.link(Key.get(Foo.class)).to(Key.get(Bar.class));
  Container container=builder.createContainer();
  Binding<Foo> fooBinding=container.getBinding(Key.get(Foo.class));
  assertSame(bar,fooBinding.getLocator().get());
  assertNotNull(fooBinding.getSource());
  assertEquals(Key.get(Foo.class),fooBinding.getKey());
  assertTrue(fooBinding.isConstant());
}",0.9933269780743564
60651,"public void testNormalBinding() throws CreationException {
  BinderImpl builder=new BinderImpl();
  Foo foo=new Foo();
  builder.bind(Foo.class).toInstance(foo);
  Container container=builder.createContainer();
  Binding<Foo> fooBinding=container.getBinding(Key.get(Foo.class));
  assertSame(foo,fooBinding.getLocator().get());
  assertNotNull(fooBinding.getSource());
  assertEquals(Key.get(Foo.class),fooBinding.getKey());
  assertFalse(fooBinding.isConstant());
}","public void testNormalBinding() throws CreationException {
  BinderImpl builder=new BinderImpl();
  Foo foo=new Foo();
  builder.bind(Foo.class).toInstance(foo);
  Container container=builder.createContainer();
  Binding<Foo> fooBinding=container.getBinding(Key.get(Foo.class));
  assertSame(foo,fooBinding.getLocator().get());
  assertNotNull(fooBinding.getSource());
  assertEquals(Key.get(Foo.class),fooBinding.getKey());
  assertTrue(fooBinding.isConstant());
}",0.9924812030075189
60652,"/** 
 * Entry point of Ephyra. Initializes the engine and starts the command line interface.
 * @param args command line arguments are ignored
 */
public static void main(String[] args){
  MsgPrinter.enableStatusMsgs(true);
  MsgPrinter.enableErrorMsgs(true);
  Logger.setLogfile(""String_Node_Str"");
  Logger.enableLogging(true);
  (new OpenEphyraCorpus()).commandLine();
}","/** 
 * Entry point of Ephyra. Initializes the engine and starts the command line interface.
 * @param args command line arguments are ignored
 */
public static void main(String[] args){
  MsgPrinter.enableStatusMsgs(true);
  MsgPrinter.enableErrorMsgs(true);
  Logger.setLogfile(""String_Node_Str"");
  Logger.enableLogging(true);
  (new OpenEphyraCorpus()).commandLine(""String_Node_Str"");
}",0.9777195281782438
60653,"/** 
 * 
 */
public void validateCreate(AppNewForm appNewForm){
  App app=appMgr.getByName(appNewForm.getApp());
  if (app != null) {
    throw new FieldException(AppNewForm.APP,""String_Node_Str"",null);
  }
}","/** 
 * 
 */
public void validateCreate(AppNewForm appNewForm){
  if (appNewForm.getApp() != null) {
    appNewForm.setApp(appNewForm.getApp().trim());
  }
  if (appNewForm.getDesc() != null) {
    appNewForm.setDesc(appNewForm.getDesc().trim());
  }
  App app=appMgr.getByName(appNewForm.getApp());
  if (app != null) {
    throw new FieldException(AppNewForm.APP,""String_Node_Str"",null);
  }
}",0.6939443535188216
60654,"/** 
 * unicode  utf-8
 */
public static String unicodeToUtf8(String theStr){
  return StringEscapeUtils.unescapeJava(theStr);
}","/** 
 * unicode  utf-8
 */
public static String unicodeToUtf8(String theString){
  if (theString == null) {
    return null;
  }
  char aChar;
  int len=theString.length();
  StringBuffer outBuffer=new StringBuffer(len);
  for (int x=0; x < len; ) {
    aChar=theString.charAt(x++);
    if (aChar == '\\') {
      aChar=theString.charAt(x++);
      if (aChar == 'u') {
        int value=0;
        for (int i=0; i < 4; i++) {
          aChar=theString.charAt(x++);
switch (aChar) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
            value=(value << 4) + aChar - '0';
          break;
case 'a':
case 'b':
case 'c':
case 'd':
case 'e':
case 'f':
        value=(value << 4) + 10 + aChar - 'a';
      break;
case 'A':
case 'B':
case 'C':
case 'D':
case 'E':
case 'F':
    value=(value << 4) + 10 + aChar - 'A';
  break;
default :
value=0;
break;
}
}
outBuffer.append((char)value);
}
 else {
if (aChar == 't') {
aChar='\t';
}
 else if (aChar == 'r') {
aChar='\r';
}
 else if (aChar == 'n') {
aChar='\n';
}
 else if (aChar == 'f') {
aChar='\f';
}
outBuffer.append(aChar);
}
}
 else {
outBuffer.append(aChar);
}
}
return outBuffer.toString();
}",0.1531531531531531
60655,"/** 
 * utf-8  unicode
 */
public static String utf8ToUnicode(String theStr){
  return StringEscapeUtils.escapeJava(theStr);
}","/** 
 * utf-8  unicode
 */
public static String utf8ToUnicode(String inStr){
  char[] myBuffer=inStr.toCharArray();
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < inStr.length(); i++) {
    Character.UnicodeBlock ub=Character.UnicodeBlock.of(myBuffer[i]);
    if (ub == Character.UnicodeBlock.BASIC_LATIN) {
      sb.append(myBuffer[i]);
    }
 else     if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {
      int j=(int)myBuffer[i] - 65248;
      sb.append((char)j);
    }
 else {
      int chr1=(char)myBuffer[i];
      String hexS=Integer.toHexString(chr1);
      String unicode=""String_Node_Str"" + hexS;
      sb.append(unicode.toLowerCase());
    }
  }
  return sb.toString();
}",0.2066508313539192
60656,"/** 
 * ()
 * @param confNewForm
 * @param file
 * @return
 */
@ResponseBody @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public JsonObjectBase updateFile(@Valid ConfNewForm confNewForm,@RequestParam(""String_Node_Str"") MultipartFile file){
  LOG.info(confNewForm.toString());
  int fileSize=1024 * 1024 * 4;
  String[] allowExtName={""String_Node_Str"",""String_Node_Str""};
  fileUploadValidator.validateFile(file,fileSize,allowExtName);
  String fileContent=""String_Node_Str"";
  try {
    fileContent=MyStringUtils.multipartFileToString(file);
    LOG.info(""String_Node_Str"" + fileContent);
  }
 catch (  Exception e) {
    LOG.error(e.toString());
    throw new FileUploadException(""String_Node_Str"",e);
  }
  ConfNewItemForm confNewItemForm=new ConfNewItemForm(confNewForm);
  confNewItemForm.setKey(file.getOriginalFilename());
  confNewItemForm.setValue(fileContent);
  configValidator.validateNew(confNewItemForm,DisConfigTypeEnum.FILE);
  configMgr.newConfig(confNewItemForm,DisConfigTypeEnum.FILE);
  return buildSuccess(""String_Node_Str"");
}","/** 
 * ()
 * @param confNewForm
 * @param file
 * @return
 */
@ResponseBody @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public JsonObjectBase updateFile(@Valid ConfNewForm confNewForm,@RequestParam(""String_Node_Str"") MultipartFile file){
  LOG.info(confNewForm.toString());
  int fileSize=1024 * 1024 * 4;
  String[] allowExtName={""String_Node_Str"",""String_Node_Str""};
  fileUploadValidator.validateFile(file,fileSize,allowExtName);
  String fileContent=""String_Node_Str"";
  try {
    fileContent=new String(file.getBytes(),""String_Node_Str"");
    LOG.info(""String_Node_Str"" + fileContent);
  }
 catch (  Exception e) {
    LOG.error(e.toString());
    throw new FileUploadException(""String_Node_Str"",e);
  }
  ConfNewItemForm confNewItemForm=new ConfNewItemForm(confNewForm);
  confNewItemForm.setKey(file.getOriginalFilename());
  confNewItemForm.setValue(fileContent);
  configValidator.validateNew(confNewItemForm,DisConfigTypeEnum.FILE);
  configMgr.newConfig(confNewItemForm,DisConfigTypeEnum.FILE);
  return buildSuccess(""String_Node_Str"");
}",0.9622467771639044
60657,"/** 
 * 
 * @param configId
 * @param file
 * @return
 */
@ResponseBody @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public JsonObjectBase updateFile(@PathVariable long configId,@RequestParam(""String_Node_Str"") MultipartFile file){
  int fileSize=1024 * 1024 * 4;
  String[] allowExtName={""String_Node_Str"",""String_Node_Str""};
  fileUploadValidator.validateFile(file,fileSize,allowExtName);
  configValidator.validateUpdateFile(configId,file.getOriginalFilename());
  String emailNotification=""String_Node_Str"";
  try {
    String str=MyStringUtils.multipartFileToString(file);
    LOG.info(""String_Node_Str"" + str);
    emailNotification=configMgr.updateItemValue(configId,str);
    LOG.info(""String_Node_Str"" + configId + ""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.error(e.toString());
    throw new FileUploadException(""String_Node_Str"",e);
  }
  configMgr.notifyZookeeper(configId);
  return buildSuccess(emailNotification);
}","/** 
 * 
 * @param configId
 * @param file
 * @return
 */
@ResponseBody @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public JsonObjectBase updateFile(@PathVariable long configId,@RequestParam(""String_Node_Str"") MultipartFile file){
  int fileSize=1024 * 1024 * 4;
  String[] allowExtName={""String_Node_Str"",""String_Node_Str""};
  fileUploadValidator.validateFile(file,fileSize,allowExtName);
  configValidator.validateUpdateFile(configId,file.getOriginalFilename());
  String emailNotification=""String_Node_Str"";
  try {
    String str=new String(file.getBytes(),""String_Node_Str"");
    LOG.info(""String_Node_Str"" + str);
    emailNotification=configMgr.updateItemValue(configId,str);
    LOG.info(""String_Node_Str"" + configId + ""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.error(e.toString());
    throw new FileUploadException(""String_Node_Str"",e);
  }
  configMgr.notifyZookeeper(configId);
  return buildSuccess(emailNotification);
}",0.957948717948718
60658,"/** 
 *  
 */
public void storeOneFile(DisconfCenterBaseModel disconfCenterBaseModel){
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfCenterBaseModel;
  String fileName=disconfCenterFile.getFileName();
  if (confFileMap.containsKey(fileName)) {
    LOGGER.error(""String_Node_Str"" + ""String_Node_Str"" + confFileMap.get(fileName).toString() + ""String_Node_Str""+ disconfCenterFile.toString());
  }
 else {
    confFileMap.put(fileName,disconfCenterFile);
  }
}","/** 
 *  
 */
public void storeOneFile(DisconfCenterBaseModel disconfCenterBaseModel){
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfCenterBaseModel;
  String fileName=disconfCenterFile.getFileName();
  if (confFileMap.containsKey(fileName)) {
    LOGGER.warn(""String_Node_Str"" + fileName);
    DisconfCenterFile existCenterFile=confFileMap.get(fileName);
    if (disconfCenterFile.isTaggedWithNonAnnotationFile()) {
      existCenterFile.setIsTaggedWithNonAnnotationFile(true);
    }
  }
 else {
    confFileMap.put(fileName,disconfCenterFile);
  }
}",0.7459867799811143
60659,"/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getFileData() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  if (keMap.size() > 0) {
    for (    String fileItem : keMap.keySet()) {
      Object object=disconfValue.getFileData().get(fileItem);
      if (object == null) {
        LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getFileData().toString());
        continue;
      }
      try {
        Object value=keMap.get(fileItem).getFieldValueByType(object);
        keMap.get(fileItem).setValue(value);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  if (disconfCenterFile.isTaggedWithNonAnnotationFile()) {
    if (disconfCenterFile.getObject() == null && disconfCenterFile.getSupportFileTypeEnum().equals(SupportFileTypeEnum.PROPERTIES)) {
      ReloadConfigurationMonitor.reload();
    }
    disconfCenterFile.setAdditionalKeyMaps(disconfValue.getFileData());
  }
}","/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getFileData() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  if (keMap.size() > 0) {
    for (    String fileItem : keMap.keySet()) {
      Object object=disconfValue.getFileData().get(fileItem);
      if (object == null) {
        LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getFileData().toString());
        continue;
      }
      try {
        Object value=keMap.get(fileItem).getFieldValueByType(object);
        keMap.get(fileItem).setValue(value);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  if (disconfCenterFile.isTaggedWithNonAnnotationFile()) {
    if (disconfCenterFile.getSupportFileTypeEnum().equals(SupportFileTypeEnum.PROPERTIES)) {
      ReloadConfigurationMonitor.reload();
    }
    disconfCenterFile.setAdditionalKeyMaps(disconfValue.getFileData());
  }
}",0.9846384413638066
60660,"/** 
 * copy & paste, just so we can insert our own visitor.  
 */
protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,Properties props) throws BeansException {
  BeanDefinitionVisitor visitor=new ReloadingPropertyPlaceholderConfigurer.PlaceholderResolvingBeanDefinitionVisitor(props);
  String[] beanNames=beanFactoryToProcess.getBeanDefinitionNames();
  for (int i=0; i < beanNames.length; i++) {
    if (!(beanNames[i].equals(this.beanName) && beanFactoryToProcess.equals(this.beanFactory))) {
      this.currentBeanName=beanNames[i];
      try {
        BeanDefinition bd=beanFactoryToProcess.getBeanDefinition(beanNames[i]);
        try {
          visitor.visitBeanDefinition(bd);
        }
 catch (        BeanDefinitionStoreException ex) {
          throw new BeanDefinitionStoreException(bd.getResourceDescription(),beanNames[i],ex.getMessage());
        }
      }
  finally {
        currentBeanName=null;
      }
    }
  }
}","/** 
 * copy & paste, just so we can insert our own visitor.  
 */
protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,Properties props) throws BeansException {
  BeanDefinitionVisitor visitor=new ReloadingPropertyPlaceholderConfigurer.PlaceholderResolvingBeanDefinitionVisitor(props);
  String[] beanNames=beanFactoryToProcess.getBeanDefinitionNames();
  for (int i=0; i < beanNames.length; i++) {
    if (!(beanNames[i].equals(this.beanName) && beanFactoryToProcess.equals(this.beanFactory))) {
      this.currentBeanName=beanNames[i];
      try {
        BeanDefinition bd=beanFactoryToProcess.getBeanDefinition(beanNames[i]);
        try {
          visitor.visitBeanDefinition(bd);
        }
 catch (        BeanDefinitionStoreException ex) {
          throw new BeanDefinitionStoreException(bd.getResourceDescription(),beanNames[i],ex.getMessage());
        }
      }
  finally {
        currentBeanName=null;
      }
    }
  }
  StringValueResolver stringValueResolver=new PlaceholderResolvingStringValueResolver(props);
  beanFactoryToProcess.resolveAliases(stringValueResolver);
  beanFactoryToProcess.addEmbeddedValueResolver(stringValueResolver);
}",0.8973418881759854
60661,"protected String resolveStringValue(String strVal) throws BeansException {
  return parseStringValue(strVal,this.props,new HashSet());
}","@Override public String resolveStringValue(String strVal) throws BeansException {
  return parseStringValue(strVal,this.props,new HashSet());
}",0.9247311827956988
60662,"@Override public <T>T getFirstByType(Class<T> type,boolean withProxy){
  return getFirstByType(type,withProxy);
}","@Override public <T>T getFirstByType(Class<T> type,boolean withProxy){
  return getFirstByType(type);
}",0.9537037037037036
60663,"@Override public int getOrder(){
  return Ordered.HIGHEST_PRECEDENCE;
}","@Override public int getOrder(){
  return Ordered.HIGHEST_PRECEDENCE + 1;
}",0.9726027397260274
60664,"/** 
 * 
 * @param scanPackage
 */
public synchronized static void firstScan(String scanPackage){
  if (isFirstInit == true) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  try {
    ConfigMgr.init();
    if (DisClientConfig.getInstance().ENABLE_DISCONF == false) {
      LOGGER.info(""String_Node_Str"");
      return;
    }
    LOGGER.info(""String_Node_Str"");
    scanMgr=ScanFactory.getScanMgr();
    scanMgr.firstScan(scanPackage);
    disconfCoreMgr=DisconfCoreFactory.getDisconfCoreMgr();
    disconfCoreMgr.process();
    isFirstInit=true;
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","/** 
 *  for annotation config
 */
public synchronized static void firstScan(String scanPackage){
  if (isFirstInit) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  try {
    ConfigMgr.init();
    LOGGER.info(""String_Node_Str"");
    scanMgr=ScanFactory.getScanMgr();
    scanMgr.firstScan(scanPackage);
    disconfCoreMgr=DisconfCoreFactory.getDisconfCoreMgr();
    disconfCoreMgr.process();
    isFirstInit=true;
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}",0.4821280133000831
60665,"/** 
 * , 
 * @param
 */
public synchronized static void secondScan(){
  if (DisClientConfig.getInstance().ENABLE_DISCONF == false) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (isFirstInit == false) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (isSecondeInit == true) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    scanMgr.secondScan();
    disconfCoreMgr.inject2DisconfInstance();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  isSecondeInit=true;
  startTimer();
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
  LOGGER.info(""String_Node_Str"");
}","/** 
 * , , for annotation config
 */
public synchronized static void secondScan(){
  if (!isFirstInit) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (isSecondInit) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    scanMgr.secondScan();
    disconfCoreMgr.inject2DisconfInstance();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  isSecondInit=true;
  startTimer();
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
  LOGGER.info(""String_Node_Str"");
}",0.5303225806451612
60666,"/** 
 * reloadable config file scan
 */
public synchronized static void reloadableScan(String filename){
  if (DisClientConfig.getInstance().ENABLE_DISCONF == false) {
    return;
  }
  if (!isFirstInit) {
    return;
  }
  try {
    if (scanMgr != null) {
      scanMgr.reloadableScan(filename);
    }
    if (disconfCoreMgr != null) {
      disconfCoreMgr.processFile(filename);
    }
    LOGGER.debug(""String_Node_Str"" + filename);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","/** 
 * reloadable config file scan, for xml config
 */
public synchronized static void reloadableScan(String filename){
  if (!isFirstInit) {
    return;
  }
  try {
    if (scanMgr != null) {
      scanMgr.reloadableScan(filename);
    }
    if (disconfCoreMgr != null) {
      disconfCoreMgr.processFile(filename);
    }
    LOGGER.debug(""String_Node_Str"" + filename);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}",0.8992576882290562
60667,"/** 
 * 
 * @param scanPackage
 */
public synchronized static void start(String scanPackage){
  firstScan(scanPackage);
  secondScan();
}","/** 
 * 
 */
public synchronized static void start(String scanPackage){
  firstScan(scanPackage);
  secondScan();
}",0.9147286821705426
60668,"/** 
 * @return void
 * @Description : 
 * @author liaoqiqi
 * @date 2013-6-14
 */
public synchronized static void close(){
  try {
    LOGGER.info(""String_Node_Str"");
    if (disconfCoreMgr != null) {
      disconfCoreMgr.release();
    }
    if (timer != null) {
      timer.cancel();
      timer=null;
    }
    isFirstInit=false;
    isSecondeInit=false;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","/** 
 * @Description : 
 */
public synchronized static void close(){
  try {
    LOGGER.info(""String_Node_Str"");
    if (disconfCoreMgr != null) {
      disconfCoreMgr.release();
    }
    if (timer != null) {
      timer.cancel();
      timer=null;
    }
    isFirstInit=false;
    isSecondInit=false;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}",0.9312039312039312
60669,"public void setFileList(Set<String> fileList){
  this.fileList=fileList;
}","@Deprecated public void setFileList(Set<String> fileList){
  this.fileList=fileList;
}",0.925
60670,"public Set<String> getFileList(){
  return fileList;
}","@Deprecated public Set<String> getFileList(){
  return fileList;
}",0.9
60671,"/** 
 * @return
 * @throws IOException
 */
protected Object createInstance() throws IOException {
  if (!isSingleton()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  reloadableProperties=new ReloadablePropertiesImpl();
  if (preListeners != null) {
    reloadableProperties.setListeners(preListeners);
  }
  reload(true);
  ReloadConfigurationMonitor.addReconfigurableBean((ReconfigurableBean)reloadableProperties);
  return reloadableProperties;
}","/** 
 * @throws IOException
 */
protected Object createInstance() throws IOException {
  if (!isSingleton()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  reloadableProperties=new ReloadablePropertiesImpl();
  if (preListeners != null) {
    reloadableProperties.setListeners(preListeners);
  }
  reload(true);
  ReloadConfigurationMonitor.addReconfigurableBean((ReconfigurableBean)reloadableProperties);
  return reloadableProperties;
}",0.9879253567508232
60672,"/** 
 * @param fileNames
 */
public void setLocations(List<String> fileNames){
  List<Resource> resources=new ArrayList<Resource>();
  for (  String filename : fileNames) {
    filename=filename.trim();
    String realFileName=getFileName(filename);
    DisconfMgr.reloadableScan(realFileName);
    String ext=FilenameUtils.getExtension(filename);
    if (ext.equals(""String_Node_Str"")) {
      PathMatchingResourcePatternResolver pathMatchingResourcePatternResolver=new PathMatchingResourcePatternResolver();
      try {
        Resource[] resourceList=pathMatchingResourcePatternResolver.getResources(filename);
        for (        Resource resource : resourceList) {
          resources.add(resource);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  this.locations=resources.toArray(new Resource[resources.size()]);
  lastModified=new long[locations.length];
  super.setLocations(locations);
}","/** 
 */
public void setLocations(List<String> fileNames){
  List<Resource> resources=new ArrayList<Resource>();
  for (  String filename : fileNames) {
    filename=filename.trim();
    String realFileName=getFileName(filename);
    DisconfMgr.reloadableScan(realFileName);
    String ext=FilenameUtils.getExtension(filename);
    if (ext.equals(""String_Node_Str"")) {
      PathMatchingResourcePatternResolver pathMatchingResourcePatternResolver=new PathMatchingResourcePatternResolver();
      try {
        Resource[] resourceList=pathMatchingResourcePatternResolver.getResources(filename);
        for (        Resource resource : resourceList) {
          resources.add(resource);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  this.locations=resources.toArray(new Resource[resources.size()]);
  lastModified=new long[locations.length];
  super.setLocations(locations);
}",0.9893276414087512
60673,"private DynamicProperty getDynamic(String currentBeanName,String currentPropertyName,String orgStrVal){
  DynamicProperty dynamic=new DynamicProperty(currentBeanName,currentPropertyName,orgStrVal);
  DynamicProperty found=(DynamicProperty)dynamicProperties.get(dynamic);
  if (found != null) {
    return found;
  }
  dynamicProperties.put(dynamic,dynamic);
  return dynamic;
}","private DynamicProperty getDynamic(String currentBeanName,String currentPropertyName,String orgStrVal){
  DynamicProperty dynamic=new DynamicProperty(currentBeanName,currentPropertyName,orgStrVal);
  DynamicProperty found=dynamicProperties.get(dynamic);
  if (found != null) {
    return found;
  }
  dynamicProperties.put(dynamic,dynamic);
  return dynamic;
}",0.9769335142469472
60674,"/** 
 * KeyMap
 * @return
 */
public Map<String,Object> getKV(){
  if (keyMaps.size() == 0) {
    return additionalKeyMaps;
  }
  Map<String,Object> map=new HashMap<String,Object>();
  for (  String key : keyMaps.keySet()) {
    map.put(key,keyMaps.get(key).getValue());
  }
  return map;
}","/** 
 * KeyMap
 */
public Map<String,Object> getKV(){
  if (keyMaps.size() == 0) {
    return additionalKeyMaps;
  }
  Map<String,Object> map=new HashMap<String,Object>();
  for (  String key : keyMaps.keySet()) {
    map.put(key,keyMaps.get(key).getValue());
  }
  return map;
}",0.9811965811965812
60675,"/** 
 * @param args
 */
public static void main(String[] args){
  try {
    ConfigMgr.init();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 */
public static void main(String[] args){
  try {
    ConfigMgr.init();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9484536082474226
60676,"/** 
 * @return
 */
public synchronized static boolean isInit(){
  return isInit;
}","/** 
 */
public synchronized static boolean isInit(){
  return isInit;
}",0.9290322580645162
60677,"/** 
 * load config normal
 * @param filePath
 * @throws Exception
 */
public synchronized void loadConfig(String filePath) throws Exception {
  if (isLoaded == true) {
    return;
  }
  String filePathInternal=filename;
  if (filePath != null) {
    filePathInternal=filePath;
  }
  DisconfAutowareConfig.autowareConfig(INSTANCE,filePathInternal);
  isLoaded=true;
}","/** 
 * load config normal
 * @throws Exception
 */
public synchronized void loadConfig(String filePath) throws Exception {
  if (isLoaded) {
    return;
  }
  String filePathInternal=filename;
  if (filePath != null) {
    filePathInternal=filePath;
  }
  DisconfAutowareConfig.autowareConfig(INSTANCE,filePathInternal);
  isLoaded=true;
}",0.9618104667609618
60678,"/** 
 *  / 
 */
@Override @Transactional(propagation=Propagation.REQUIRED,rollbackFor=RuntimeException.class) public String updateItemValue(Long configId,String value){
  Config config=getConfigById(configId);
  String oldValue=config.getValue();
  configDao.updateValue(configId,value);
  String toEmails=appMgr.getEmails(config.getAppId());
  if (applicationPropertyConfig.isEmailMonitorOn() == true) {
    boolean isSendSuccess=logMailBean.sendHtmlEmail(toEmails,""String_Node_Str"",DiffUtils.getDiff(oldValue,value,config.toString(),getConfigUrlHtml(config)));
    if (isSendSuccess) {
      return ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"";
    }
  }
  return ""String_Node_Str"";
}","/** 
 *  / 
 */
@Override @Transactional(propagation=Propagation.REQUIRED,rollbackFor=RuntimeException.class) public String updateItemValue(Long configId,String value){
  value=CodeUtils.utf8ToUnicode(value);
  Config config=getConfigById(configId);
  String oldValue=config.getValue();
  configDao.updateValue(configId,value);
  String toEmails=appMgr.getEmails(config.getAppId());
  if (applicationPropertyConfig.isEmailMonitorOn() == true) {
    boolean isSendSuccess=logMailBean.sendHtmlEmail(toEmails,""String_Node_Str"",DiffUtils.getDiff(oldValue,value,config.toString(),getConfigUrlHtml(config)));
    if (isSendSuccess) {
      return ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"";
    }
  }
  return ""String_Node_Str"";
}",0.9728260869565216
60679,"/** 
 * 
 */
@Override public void newConfig(ConfNewItemForm confNewForm,DisConfigTypeEnum disConfigTypeEnum){
  Config config=new Config();
  config.setAppId(confNewForm.getAppId());
  config.setEnvId(confNewForm.getEnvId());
  config.setName(confNewForm.getKey());
  config.setType(disConfigTypeEnum.getType());
  config.setVersion(confNewForm.getVersion());
  config.setValue(confNewForm.getValue());
  String curTime=DateUtils.format(new Date(),DataFormatConstants.COMMON_TIME_FORMAT);
  config.setCreateTime(curTime);
  config.setUpdateTime(curTime);
  configDao.create(config);
  String toEmails=appMgr.getEmails(config.getAppId());
  if (applicationPropertyConfig.isEmailMonitorOn() == true) {
    logMailBean.sendHtmlEmail(toEmails,""String_Node_Str"",getNewValue(confNewForm.getValue(),config.toString(),getConfigUrlHtml(config)));
  }
}","/** 
 * 
 */
@Override public void newConfig(ConfNewItemForm confNewForm,DisConfigTypeEnum disConfigTypeEnum){
  Config config=new Config();
  config.setAppId(confNewForm.getAppId());
  config.setEnvId(confNewForm.getEnvId());
  config.setName(confNewForm.getKey());
  config.setType(disConfigTypeEnum.getType());
  config.setVersion(confNewForm.getVersion());
  config.setValue(CodeUtils.utf8ToUnicode(confNewForm.getValue()));
  String curTime=DateUtils.format(new Date(),DataFormatConstants.COMMON_TIME_FORMAT);
  config.setCreateTime(curTime);
  config.setUpdateTime(curTime);
  configDao.create(config);
  String toEmails=appMgr.getEmails(config.getAppId());
  if (applicationPropertyConfig.isEmailMonitorOn() == true) {
    logMailBean.sendHtmlEmail(toEmails,""String_Node_Str"",getNewValue(confNewForm.getValue(),config.toString(),getConfigUrlHtml(config)));
  }
}",0.9854735618826264
60680,"/** 
 *  , Watch 
 */
private void updateOneConfFile(String fileName,DisconfCenterFile disconfCenterFile) throws Exception {
  if (disconfCenterFile == null) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  String filePath=""String_Node_Str"";
  Map<String,Object> dataMap=null;
  try {
    String url=disconfCenterFile.getRemoteServerUrl();
    filePath=fetcherMgr.downloadFileFromServer(url,fileName);
    dataMap=FileTypeProcessorUtils.getKvMap(filePath);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    LOGGER.warn(""String_Node_Str"" + fileName);
    dataMap=FileTypeProcessorUtils.getKvMap(fileName);
  }
  LOGGER.debug(""String_Node_Str"");
  disconfStoreProcessor.inject2Store(fileName,new DisconfValue(null,dataMap));
  LOGGER.debug(""String_Node_Str"");
  DisConfCommonModel disConfCommonModel=disconfStoreProcessor.getCommonModel(fileName);
  if (watchMgr != null) {
    watchMgr.watchPath(this,disConfCommonModel,fileName,DisConfigTypeEnum.FILE,GsonUtils.toJson(disconfCenterFile.getKV()));
    LOGGER.debug(""String_Node_Str"");
  }
 else {
    LOGGER.warn(""String_Node_Str"",fileName);
  }
}","/** 
 *  , Watch 
 */
private void updateOneConfFile(String fileName,DisconfCenterFile disconfCenterFile) throws Exception {
  if (disconfCenterFile == null) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  String filePath=""String_Node_Str"";
  Map<String,Object> dataMap=new HashMap<String,Object>();
  try {
    String url=disconfCenterFile.getRemoteServerUrl();
    filePath=fetcherMgr.downloadFileFromServer(url,fileName);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    LOGGER.warn(""String_Node_Str"" + fileName);
    filePath=fileName;
  }
  LOGGER.debug(""String_Node_Str"");
  try {
    dataMap=FileTypeProcessorUtils.getKvMap(filePath);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  disconfStoreProcessor.inject2Store(fileName,new DisconfValue(null,dataMap));
  LOGGER.debug(""String_Node_Str"");
  DisConfCommonModel disConfCommonModel=disconfStoreProcessor.getCommonModel(fileName);
  if (watchMgr != null) {
    watchMgr.watchPath(this,disConfCommonModel,fileName,DisConfigTypeEnum.FILE,GsonUtils.toJson(disconfCenterFile.getKV()));
    LOGGER.debug(""String_Node_Str"");
  }
 else {
    LOGGER.warn(""String_Node_Str"",fileName);
  }
}",0.7421808960270498
60681,"/** 
 */
private List<String> compareConfig(String zkData,String dbData){
  List<String> errorKeyList=new ArrayList<String>();
  Properties prop=new Properties();
  try {
    prop.load(IOUtils.toInputStream(dbData,""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.error(e.toString());
    errorKeyList.add(zkData);
    return errorKeyList;
  }
  Map<String,String> zkMap=GsonUtils.parse2Map(zkData);
  for (  String keyInZk : zkMap.keySet()) {
    Object valueInDb=prop.get(keyInZk);
    String zkDataStr=zkMap.get(keyInZk);
    try {
      if ((zkDataStr == null && valueInDb != null) || (zkDataStr != null && valueInDb == null)) {
        errorKeyList.add(keyInZk);
      }
 else {
        boolean isEqual=true;
        if (MyStringUtils.isDouble(zkDataStr) && MyStringUtils.isDouble(valueInDb.toString())) {
          if (Math.abs(Double.parseDouble(zkDataStr) - Double.parseDouble(valueInDb.toString())) > 0.001d) {
            isEqual=false;
          }
        }
 else {
          if (!zkDataStr.equals(valueInDb.toString().trim())) {
            isEqual=false;
          }
        }
        if (!isEqual) {
          errorKeyList.add(keyInZk + ""String_Node_Str"" + DiffUtils.getDiffSimple(zkDataStr,valueInDb.toString().trim()));
        }
      }
    }
 catch (    Exception e) {
      LOG.warn(e.toString() + ""String_Node_Str"" + keyInZk+ ""String_Node_Str""+ zkMap.get(keyInZk)+ ""String_Node_Str""+ valueInDb);
    }
  }
  return errorKeyList;
}","/** 
 */
private List<String> compareConfig(String zkData,String dbData){
  List<String> errorKeyList=new ArrayList<String>();
  Properties prop=new Properties();
  try {
    prop.load(IOUtils.toInputStream(dbData));
  }
 catch (  Exception e) {
    LOG.error(e.toString());
    errorKeyList.add(zkData);
    return errorKeyList;
  }
  Map<String,String> zkMap=GsonUtils.parse2Map(zkData);
  for (  String keyInZk : zkMap.keySet()) {
    Object valueInDb=prop.get(keyInZk);
    String zkDataStr=zkMap.get(keyInZk);
    try {
      if ((zkDataStr == null && valueInDb != null) || (zkDataStr != null && valueInDb == null)) {
        errorKeyList.add(keyInZk);
      }
 else {
        boolean isEqual=true;
        if (MyStringUtils.isDouble(zkDataStr) && MyStringUtils.isDouble(valueInDb.toString())) {
          if (Math.abs(Double.parseDouble(zkDataStr) - Double.parseDouble(valueInDb.toString())) > 0.001d) {
            isEqual=false;
          }
        }
 else {
          if (!zkDataStr.equals(valueInDb.toString().trim())) {
            isEqual=false;
          }
        }
        if (!isEqual) {
          errorKeyList.add(keyInZk + ""String_Node_Str"" + DiffUtils.getDiffSimple(zkDataStr,valueInDb.toString().trim()));
        }
      }
    }
 catch (    Exception e) {
      LOG.warn(e.toString() + ""String_Node_Str"" + keyInZk+ ""String_Node_Str""+ zkMap.get(keyInZk)+ ""String_Node_Str""+ valueInDb);
    }
  }
  return errorKeyList;
}",0.993103448275862
60682,"/** 
 * unicode  utf-8
 * @param theString
 * @return
 * @author fanhui2007-3-15
 */
public static String unicodeToUtf8(String theString){
  char aChar;
  int len=theString.length();
  StringBuffer outBuffer=new StringBuffer(len);
  for (int x=0; x < len; ) {
    aChar=theString.charAt(x++);
    if (aChar == '\\') {
      aChar=theString.charAt(x++);
      if (aChar == 'u') {
        int value=0;
        for (int i=0; i < 4; i++) {
          aChar=theString.charAt(x++);
switch (aChar) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
            value=(value << 4) + aChar - '0';
          break;
case 'a':
case 'b':
case 'c':
case 'd':
case 'e':
case 'f':
        value=(value << 4) + 10 + aChar - 'a';
      break;
case 'A':
case 'B':
case 'C':
case 'D':
case 'E':
case 'F':
    value=(value << 4) + 10 + aChar - 'A';
  break;
default :
value=0;
}
}
outBuffer.append((char)value);
}
 else {
if (aChar == 't') {
aChar='\t';
}
 else if (aChar == 'r') {
aChar='\r';
}
 else if (aChar == 'n') {
aChar='\n';
}
 else if (aChar == 'f') {
aChar='\f';
}
outBuffer.append(aChar);
}
}
 else {
outBuffer.append(aChar);
}
}
return outBuffer.toString();
}","/** 
 * unicode  utf-8
 * @param theString
 * @return
 * @author fanhui2007-3-15
 */
public static String unicodeToUtf8(String theString){
  char aChar;
  int len=theString.length();
  StringBuffer outBuffer=new StringBuffer(len);
  for (int x=0; x < len; ) {
    aChar=theString.charAt(x++);
    if (aChar == '\\') {
      aChar=theString.charAt(x++);
      if (aChar == 'u') {
        int value=0;
        for (int i=0; i < 4; i++) {
          aChar=theString.charAt(x++);
switch (aChar) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
            value=(value << 4) + aChar - '0';
          break;
case 'a':
case 'b':
case 'c':
case 'd':
case 'e':
case 'f':
        value=(value << 4) + 10 + aChar - 'a';
      break;
case 'A':
case 'B':
case 'C':
case 'D':
case 'E':
case 'F':
    value=(value << 4) + 10 + aChar - 'A';
  break;
default :
value=0;
break;
}
}
outBuffer.append((char)value);
}
 else {
if (aChar == 't') {
aChar='\t';
}
 else if (aChar == 'r') {
aChar='\r';
}
 else if (aChar == 'n') {
aChar='\n';
}
 else if (aChar == 'f') {
aChar='\f';
}
outBuffer.append(aChar);
}
}
 else {
outBuffer.append(aChar);
}
}
return outBuffer.toString();
}",0.9971014492753624
60683,"/** 
 * , remoteUrl url
 * @param url
 * @param fileName
 * @return
 * @throws Exception
 */
public String downloadFileFromServer(String url,String fileName) throws Exception {
  String localTmpDir=getLocalDownloadDirPath(true);
  String localDir=getLocalDownloadDirPath(false);
  RemoteUrl remoteUrl=new RemoteUrl(url,hostList);
  return restfulMgr.downloadFromServer(remoteUrl,fileName,localTmpDir,localDir,this.enableLocalDownloadDirInClassPath,retryTime,retrySleepSeconds);
}","/** 
 * , remoteUrl url
 * @param url
 * @param fileName
 * @return
 * @throws Exception
 */
public String downloadFileFromServer(String url,String fileName) throws Exception {
  String localDir=getLocalDownloadDirPath(false);
  RemoteUrl remoteUrl=new RemoteUrl(url,hostList);
  return restfulMgr.downloadFromServer(remoteUrl,fileName,localDir,this.enableLocalDownloadDirInClassPath,retryTime,retrySleepSeconds);
}",0.5572687224669604
60684,"/** 
 * @param remoteUrl 
 * @param fileName 
 * @param localTmpFileDir  
 * @param localFileDir 
 * @param isTransfer2Classpath Classpath
 * @return ClasspathClasspath
 * @throws Exception
 */
String downloadFromServer(RemoteUrl remoteUrl,String fileName,String localTmpFileDir,String localFileDir,boolean isTransfer2Classpath,int retryTimes,int retyrSleepSeconds) throws Exception ;","/** 
 * @param remoteUrl 
 * @param fileName 
 * @param localFileDir 
 * @param isTransfer2Classpath Classpath
 * @return ClasspathClasspath
 * @throws Exception
 */
String downloadFromServer(RemoteUrl remoteUrl,String fileName,String localFileDir,boolean isTransfer2Classpath,int retryTimes,int retyrSleepSeconds) throws Exception ;",0.9293413173652696
60685,"/** 
 * @param remoteUrl 
 * @param fileName 
 * @param localTmpFileDir  
 * @param localFileDir 
 * @param isTransfer2Classpath Classpath
 * @return ClasspathClasspath
 * @throws Exception
 */
public String downloadFromServer(RemoteUrl remoteUrl,String fileName,String localTmpFileDir,String localFileDir,boolean isTransfer2Classpath,int retryTimes,int retyrSleepSeconds) throws Exception {
  String localTmpFilePath=OsUtil.pathJoin(localTmpFileDir,fileName);
  String localFilePath=OsUtil.pathJoin(localFileDir,fileName);
  File localTmpFile=new File(localTmpFilePath);
  File localFile=new File(localFilePath);
  if (localFile.exists()) {
    localFile.delete();
  }
  try {
    retry4ConfDownload(remoteUrl,localTmpFile,retryTimes,retyrSleepSeconds);
    OsUtil.transferFile(localTmpFile,localFile);
    if (isTransfer2Classpath) {
      File classpathFile=getLocalDownloadFileInClasspath(fileName);
      if (classpathFile != null) {
        OsUtil.transferFile(localFile,classpathFile);
        localFile=classpathFile;
      }
 else {
        LOGGER.warn(""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
    }
    LOGGER.debug(""String_Node_Str"" + localFile.getAbsolutePath());
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
  }
  if (!localFile.exists()) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  if (!ConfigLoaderUtils.CLASS_PATH.isEmpty()) {
    String relavivePathString=OsUtil.getRelativePath(localFile,new File(ConfigLoaderUtils.CLASS_PATH));
    if (relavivePathString != null) {
      if (new File(relavivePathString).isFile()) {
        return relavivePathString;
      }
    }
  }
  return localFile.getAbsolutePath();
}","/** 
 * @param remoteUrl 
 * @param fileName 
 * @param localFileDir 
 * @param isTransfer2Classpath Classpath
 * @return ClasspathClasspath
 * @throws Exception
 */
public String downloadFromServer(RemoteUrl remoteUrl,String fileName,String localFileDir,boolean isTransfer2Classpath,int retryTimes,int retyrSleepSeconds) throws Exception {
  String localFilePath=OsUtil.pathJoin(localFileDir,fileName);
  String localFilePathUnique=MyStringUtils.getRandomName(localFilePath);
  File localFilePathUnqiueFile=new File(localFilePathUnique);
  try {
    retry4ConfDownload(remoteUrl,localFilePathUnqiueFile,retryTimes,retyrSleepSeconds);
    if (isTransfer2Classpath) {
      File classpathFile=getLocalDownloadFileInClasspath(fileName);
      if (classpathFile != null) {
        OsUtil.transferFileAtom(localFilePathUnqiueFile,classpathFile);
        localFilePathUnqiueFile=classpathFile;
      }
 else {
        LOGGER.warn(""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
    }
    LOGGER.debug(""String_Node_Str"" + localFilePathUnqiueFile.getAbsolutePath());
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
  }
  if (!localFilePathUnqiueFile.exists()) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  if (!ConfigLoaderUtils.CLASS_PATH.isEmpty()) {
    String relavivePathString=OsUtil.getRelativePath(localFilePathUnqiueFile,new File(ConfigLoaderUtils.CLASS_PATH));
    if (relavivePathString != null) {
      if (new File(relavivePathString).isFile()) {
        return relavivePathString;
      }
    }
  }
  return localFilePathUnqiueFile.getAbsolutePath();
}",0.8695397244209909
60686,"@Override public ConfListVo transfer(Config input){
  String appNameString=app.getName();
  String envName=env.getName();
  ConfListVo configListVo=convert(input,appNameString,envName,myzkDataMap.get(input.getName()));
  if (myFetchZk) {
    configListVo.setValue(""String_Node_Str"");
    configListVo.setMachineList(new ArrayList<ZkDisconfData.ZkDisconfDataItem>());
  }
  return configListVo;
}","@Override public ConfListVo transfer(Config input){
  String appNameString=app.getName();
  String envName=env.getName();
  ZkDisconfData zkDisconfData=null;
  if (myzkDataMap != null && myzkDataMap.keySet().contains(input.getName())) {
    zkDisconfData=myzkDataMap.get(input.getName());
  }
  ConfListVo configListVo=convert(input,appNameString,envName,zkDisconfData);
  if (myFetchZk) {
    configListVo.setValue(""String_Node_Str"");
    configListVo.setMachineList(new ArrayList<ZkDisconfData.ZkDisconfDataItem>());
  }
  return configListVo;
}",0.6687898089171974
60687,"/** 
 * 
 */
@Override public DaoPageResult<ConfListVo> getConfigList(ConfListForm confListForm,boolean fetchZk){
  DaoPageResult<Config> configList=configDao.getConfigList(confListForm.getAppId(),confListForm.getEnvId(),confListForm.getVersion(),confListForm.getPage());
  final App app=appMgr.getById(confListForm.getAppId());
  final Env env=envMgr.getById(confListForm.getEnvId());
  final boolean myFetchZk=fetchZk;
  Map<String,ZkDisconfData> zkDataMap=null;
  if (myFetchZk) {
    zkDataMap=zkDeployMgr.getZkDisconfDataMap(app.getName(),env.getName(),confListForm.getVersion());
  }
  final Map<String,ZkDisconfData> myzkDataMap=zkDataMap;
  DaoPageResult<ConfListVo> configListVo=ServiceUtil.getResult(configList,new DataTransfer<Config,ConfListVo>(){
    @Override public ConfListVo transfer(    Config input){
      String appNameString=app.getName();
      String envName=env.getName();
      ConfListVo configListVo=convert(input,appNameString,envName,myzkDataMap.get(input.getName()));
      if (myFetchZk) {
        configListVo.setValue(""String_Node_Str"");
        configListVo.setMachineList(new ArrayList<ZkDisconfData.ZkDisconfDataItem>());
      }
      return configListVo;
    }
  }
);
  return configListVo;
}","/** 
 * 
 */
@Override public DaoPageResult<ConfListVo> getConfigList(ConfListForm confListForm,boolean fetchZk){
  DaoPageResult<Config> configList=configDao.getConfigList(confListForm.getAppId(),confListForm.getEnvId(),confListForm.getVersion(),confListForm.getPage());
  final App app=appMgr.getById(confListForm.getAppId());
  final Env env=envMgr.getById(confListForm.getEnvId());
  final boolean myFetchZk=fetchZk;
  Map<String,ZkDisconfData> zkDataMap=new HashMap<String,ZkDisconfData>();
  if (myFetchZk) {
    zkDataMap=zkDeployMgr.getZkDisconfDataMap(app.getName(),env.getName(),confListForm.getVersion());
  }
  final Map<String,ZkDisconfData> myzkDataMap=zkDataMap;
  DaoPageResult<ConfListVo> configListVo=ServiceUtil.getResult(configList,new DataTransfer<Config,ConfListVo>(){
    @Override public ConfListVo transfer(    Config input){
      String appNameString=app.getName();
      String envName=env.getName();
      ZkDisconfData zkDisconfData=null;
      if (myzkDataMap != null && myzkDataMap.keySet().contains(input.getName())) {
        zkDisconfData=myzkDataMap.get(input.getName());
      }
      ConfListVo configListVo=convert(input,appNameString,envName,zkDisconfData);
      if (myFetchZk) {
        configListVo.setValue(""String_Node_Str"");
        configListVo.setMachineList(new ArrayList<ZkDisconfData.ZkDisconfDataItem>());
      }
      return configListVo;
    }
  }
);
  return configListVo;
}",0.9014612214312476
60688,"/** 
 */
private List<String> compareConifg(String zkData,String dbData){
  List<String> errorKeyList=new ArrayList<String>();
  Properties prop=new Properties();
  try {
    prop.load(IOUtils.toInputStream(dbData,""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.error(e.toString());
    errorKeyList.add(zkData);
    return errorKeyList;
  }
  Map<String,String> zkMap=GsonUtils.parse2Map(zkData);
  for (  String keyInZk : zkMap.keySet()) {
    Object valueInDb=prop.get(keyInZk);
    if (!zkMap.get(keyInZk).equals(valueInDb.toString().trim())) {
      errorKeyList.add(keyInZk);
    }
  }
  return errorKeyList;
}","/** 
 */
private List<String> compareConifg(String zkData,String dbData){
  List<String> errorKeyList=new ArrayList<String>();
  Properties prop=new Properties();
  try {
    prop.load(IOUtils.toInputStream(dbData,""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.error(e.toString());
    errorKeyList.add(zkData);
    return errorKeyList;
  }
  Map<String,String> zkMap=GsonUtils.parse2Map(zkData);
  for (  String keyInZk : zkMap.keySet()) {
    Object valueInDb=prop.get(keyInZk);
    try {
      if (!zkMap.get(keyInZk).equals(valueInDb.toString().trim())) {
        errorKeyList.add(keyInZk);
      }
    }
 catch (    Exception e) {
      LOG.warn(e.toString() + ""String_Node_Str"" + zkMap.get(keyInZk)+ ""String_Node_Str""+ valueInDb);
    }
  }
  return errorKeyList;
}",0.8838526912181303
60689,"/** 
 *  
 */
public void storeOneFile(DisconfCenterBaseModel disconfCenterBaseModel){
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfCenterBaseModel;
  String fileName=disconfCenterFile.getFileName();
  if (confFileMap.containsKey(fileName)) {
    LOGGER.error(""String_Node_Str"" + ""String_Node_Str"" + confFileMap.get(fileName).getCls().toString() + ""String_Node_Str""+ disconfCenterFile.toString());
  }
 else {
    confFileMap.put(fileName,disconfCenterFile);
  }
}","/** 
 *  
 */
public void storeOneFile(DisconfCenterBaseModel disconfCenterBaseModel){
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfCenterBaseModel;
  String fileName=disconfCenterFile.getFileName();
  if (confFileMap.containsKey(fileName)) {
    LOGGER.error(""String_Node_Str"" + ""String_Node_Str"" + confFileMap.get(fileName).toString() + ""String_Node_Str""+ disconfCenterFile.toString());
  }
 else {
    confFileMap.put(fileName,disconfCenterFile);
  }
}",0.9907502569373072
60690,"/** 
 */
private List<DisconfCenterBaseModel> getDisconfCenterFiles(ScanStaticModel scanModel){
  DisconfCenterFile disconfCenterFile=new DisconfCenterFile();
  List<DisconfCenterBaseModel> disconfCenterFiles=new ArrayList<DisconfCenterBaseModel>();
  for (  String fileName : scanModel.getNonAnnotationFileSet()) {
    disconfCenterFile.setFileName(fileName);
    DisConfCommonModel disConfCommonModel=makeDisConfCommonModel(""String_Node_Str"",""String_Node_Str"");
    disconfCenterFile.setDisConfCommonModel(disConfCommonModel);
    String url=DisconfWebPathMgr.getRemoteUrlParameter(DisClientSysConfig.getInstance().CONF_SERVER_STORE_ACTION,disConfCommonModel.getApp(),disConfCommonModel.getVersion(),disConfCommonModel.getEnv(),disconfCenterFile.getFileName(),DisConfigTypeEnum.FILE);
    disconfCenterFile.setRemoteServerUrl(url);
    disconfCenterFiles.add(disconfCenterFile);
  }
  return disconfCenterFiles;
}","/** 
 */
private List<DisconfCenterBaseModel> getDisconfCenterFiles(ScanStaticModel scanModel){
  List<DisconfCenterBaseModel> disconfCenterFiles=new ArrayList<DisconfCenterBaseModel>();
  for (  String fileName : scanModel.getNonAnnotationFileSet()) {
    DisconfCenterFile disconfCenterFile=new DisconfCenterFile();
    disconfCenterFile.setFileName(fileName);
    DisConfCommonModel disConfCommonModel=makeDisConfCommonModel(""String_Node_Str"",""String_Node_Str"");
    disconfCenterFile.setDisConfCommonModel(disConfCommonModel);
    String url=DisconfWebPathMgr.getRemoteUrlParameter(DisClientSysConfig.getInstance().CONF_SERVER_STORE_ACTION,disConfCommonModel.getApp(),disConfCommonModel.getVersion(),disConfCommonModel.getEnv(),disconfCenterFile.getFileName(),DisConfigTypeEnum.FILE);
    disconfCenterFile.setRemoteServerUrl(url);
    disconfCenterFiles.add(disconfCenterFile);
  }
  return disconfCenterFiles;
}",0.9301310043668122
60691,"@Test public void demo(){
  new MockUp<DisconfCoreFactory>(){
    @Mock public DisconfCoreMgr getDisconfCoreMgr() throws Exception {
      FetcherMgr fetcherMgr=FetcherFactory.getFetcherMgr();
      final WatchMgr watchMgr=new WatchMgrMock().getMockInstance();
      watchMgr.init(""String_Node_Str"",""String_Node_Str"");
      DisconfCoreMgr disconfCoreMgr=new DisconfCoreMgrImpl(watchMgr,fetcherMgr);
      return disconfCoreMgr;
    }
  }
;
  try {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    LOGGER.info(""String_Node_Str"");
    Set<String> fileSet=new HashSet<String>();
    fileSet.add(""String_Node_Str"");
    DisconfMgr.start(ScanPackTestCase.SCAN_PACK_NAME,fileSet);
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    Assert.assertEquals(new Long(1000),confA.getVarA());
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    Assert.assertEquals(new Long(2000),confA.getVarA2());
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    Assert.assertEquals(new Integer(1000).intValue(),serviceA.getVarAA());
    LOGGER.info(String.valueOf(""String_Node_Str"" + StaticConf.getStaticvar()));
    Assert.assertEquals(new Integer(50).intValue(),StaticConf.getStaticvar());
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.assertTrue(false);
  }
}","@Test public void demo(){
  new MockUp<DisconfCoreFactory>(){
    @Mock public DisconfCoreMgr getDisconfCoreMgr() throws Exception {
      FetcherMgr fetcherMgr=FetcherFactory.getFetcherMgr();
      final WatchMgr watchMgr=new WatchMgrMock().getMockInstance();
      watchMgr.init(""String_Node_Str"",""String_Node_Str"");
      DisconfCoreMgr disconfCoreMgr=new DisconfCoreMgrImpl(watchMgr,fetcherMgr);
      return disconfCoreMgr;
    }
  }
;
  try {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    LOGGER.info(""String_Node_Str"");
    Set<String> fileSet=new HashSet<String>();
    fileSet.add(""String_Node_Str"");
    fileSet.add(""String_Node_Str"");
    DisconfMgr.start(ScanPackTestCase.SCAN_PACK_NAME,fileSet);
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    Assert.assertEquals(new Long(1000),confA.getVarA());
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    Assert.assertEquals(new Long(2000),confA.getVarA2());
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    Assert.assertEquals(new Integer(1000).intValue(),serviceA.getVarAA());
    LOGGER.info(String.valueOf(""String_Node_Str"" + StaticConf.getStaticvar()));
    Assert.assertEquals(new Integer(50).intValue(),StaticConf.getStaticvar());
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.assertTrue(false);
  }
}",0.9902544667027612
60692,"/** 
 */
private static void setupRemoteData(){
  ValueVo valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.DEFAULT_ITEM_VALUE);
  stubFor(get(urlEqualTo(RemoteMockServer.ITEM_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
  stubFor(get(urlEqualTo(RemoteMockServer.FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.FILE_NAME).withStatus(200).withBody(RemoteMockServer.FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.EMPTY_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.EMPTY_FILE_URL).withStatus(200).withBody(RemoteMockServer.FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.STATIC_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.STATIC_FILE_NAME).withStatus(200).withBody(RemoteMockServer.STATIC_FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.NON_ANOTATION_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.NON_ANOTATION_FILE_NAME).withStatus(200).withBody(RemoteMockServer.NON_ANOTATTION_FILE_CONTENT.getBytes())));
  valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.ZOO_HOSTS);
  stubFor(get(urlEqualTo(RemoteMockServer.ZOO_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
  valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.ZOO_PREFIX_VALUE);
  stubFor(get(urlEqualTo(RemoteMockServer.ZOO_PREFIX_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
}","/** 
 */
private static void setupRemoteData(){
  ValueVo valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.DEFAULT_ITEM_VALUE);
  stubFor(get(urlEqualTo(RemoteMockServer.ITEM_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
  stubFor(get(urlEqualTo(RemoteMockServer.FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.FILE_NAME).withStatus(200).withBody(RemoteMockServer.FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.EMPTY_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.EMPTY_FILE_URL).withStatus(200).withBody(RemoteMockServer.FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.STATIC_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.STATIC_FILE_NAME).withStatus(200).withBody(RemoteMockServer.STATIC_FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.NON_ANOTATION_FILE_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.NON_ANOTATION_FILE_NAME).withStatus(200).withBody(RemoteMockServer.NON_ANOTATTION_FILE_CONTENT.getBytes())));
  stubFor(get(urlEqualTo(RemoteMockServer.NON_ANOTATION_FILE_URL2)).willReturn(aResponse().withHeader(""String_Node_Str"",""String_Node_Str"").withHeader(""String_Node_Str"",""String_Node_Str"" + RemoteMockServer.NON_ANOTATION_FILE_NAME2).withStatus(200).withBody(RemoteMockServer.NON_ANOTATTION_FILE_CONTENT2.getBytes())));
  valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.ZOO_HOSTS);
  stubFor(get(urlEqualTo(RemoteMockServer.ZOO_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
  valueVo=new ValueVo();
  valueVo.setMessage(""String_Node_Str"");
  valueVo.setStatus(Constants.OK);
  valueVo.setValue(RemoteMockServer.ZOO_PREFIX_VALUE);
  stubFor(get(urlEqualTo(RemoteMockServer.ZOO_PREFIX_URL)).willReturn(aResponse().withHeader(""String_Node_Str"",RemoteMockServer.CONTENT_TYPE).withStatus(200).withBody(GsonUtils.toJson(valueVo))));
}",0.8155661353756987
60693,"@Override public void processAllItems(){
  for (  String fileName : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + fileName + ""String_Node_Str"");
    DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(fileName);
    try {
      updateOneConfFile(fileName,disconfCenterFile);
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}","/** 
 */
@Override public void processAllItems(){
  for (  String fileName : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + fileName + ""String_Node_Str"");
    DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(fileName);
    try {
      updateOneConfFile(fileName,disconfCenterFile);
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}",0.9894982497082848
60694,"@Override public void inject2Conf(){
  for (  String key : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(key);
    if (disconfCenterFile == null) {
      continue;
    }
    try {
      Object object=null;
      try {
        object=disconfCenterFile.getObject();
        if (object == null) {
          object=DisconfCoreProcessUtils.getSpringBean(disconfCenterFile.getCls());
        }
      }
 catch (      Exception e) {
        LOGGER.debug(disconfCenterFile.getCls() + ""String_Node_Str"");
        object=null;
      }
      disconfStoreProcessor.inject2Instance(object,key);
    }
 catch (    Exception e) {
      LOGGER.warn(e.toString(),e);
    }
  }
}","@Override public void inject2Conf(){
  for (  String key : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(key);
    inject2OneConf(key,disconfCenterFile);
  }
}",0.5191793041926851
60695,"/** 
 *  
 */
private void updateOneConfFile(String fileName,DisconfCenterFile disconfCenterFile) throws Exception {
  if (disconfCenterFile == null) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  String filePath=""String_Node_Str"";
  Properties properties=null;
  try {
    String url=disconfCenterFile.getRemoteServerUrl();
    filePath=fetcherMgr.downloadFileFromServer(url,fileName);
    properties=ConfigLoaderUtils.loadConfig(filePath);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString());
    LOGGER.warn(""String_Node_Str"" + fileName);
    properties=ConfigLoaderUtils.loadConfig(fileName);
  }
  LOGGER.debug(""String_Node_Str"");
  Set<Entry<Object,Object>> set=properties.entrySet();
  for (  Entry<Object,Object> entry : set) {
    LOGGER.debug(entry.toString());
  }
  disconfStoreProcessor.inject2Store(fileName,new DisconfValue(null,properties));
  LOGGER.debug(""String_Node_Str"");
  DisConfCommonModel disConfCommonModel=disconfStoreProcessor.getCommonModel(fileName);
  if (watchMgr != null) {
    watchMgr.watchPath(this,disConfCommonModel,fileName,DisConfigTypeEnum.FILE,GsonUtils.toJson(disconfCenterFile.getKV()));
    LOGGER.debug(""String_Node_Str"");
  }
 else {
    LOGGER.warn(""String_Node_Str"",fileName);
  }
}","/** 
 *  , Watch 
 */
private void updateOneConfFile(String fileName,DisconfCenterFile disconfCenterFile) throws Exception {
  if (disconfCenterFile == null) {
    throw new Exception(""String_Node_Str"" + fileName);
  }
  String filePath=""String_Node_Str"";
  Properties properties=null;
  try {
    String url=disconfCenterFile.getRemoteServerUrl();
    filePath=fetcherMgr.downloadFileFromServer(url,fileName);
    properties=ConfigLoaderUtils.loadConfig(filePath);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString());
    LOGGER.warn(""String_Node_Str"" + fileName);
    properties=ConfigLoaderUtils.loadConfig(fileName);
  }
  LOGGER.debug(""String_Node_Str"");
  Set<Entry<Object,Object>> set=properties.entrySet();
  for (  Entry<Object,Object> entry : set) {
    LOGGER.debug(entry.toString());
  }
  disconfStoreProcessor.inject2Store(fileName,new DisconfValue(null,properties));
  LOGGER.debug(""String_Node_Str"");
  DisConfCommonModel disConfCommonModel=disconfStoreProcessor.getCommonModel(fileName);
  if (watchMgr != null) {
    watchMgr.watchPath(this,disConfCommonModel,fileName,DisConfigTypeEnum.FILE,GsonUtils.toJson(disconfCenterFile.getKV()));
    LOGGER.debug(""String_Node_Str"");
  }
 else {
    LOGGER.warn(""String_Node_Str"",fileName);
  }
}",0.9921445404556166
60696,"/** 
 */
@Override public void updateOneConf(String fileName) throws Exception {
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(fileName);
  if (disconfCenterFile != null) {
    updateOneConfFile(fileName,disconfCenterFile);
  }
}","/** 
 * 
 */
private void updateOneConf(String fileName) throws Exception {
  DisconfCenterFile disconfCenterFile=(DisconfCenterFile)disconfStoreProcessor.getConfData(fileName);
  if (disconfCenterFile != null) {
    updateOneConfFile(fileName,disconfCenterFile);
    inject2OneConf(fileName,disconfCenterFile);
  }
}",0.8604651162790697
60697,"/** 
 */
@Override public void updateOneConfAndCallback(String key) throws Exception {
  updateOneConf(key);
  DisconfCoreProcessUtils.callOneConf(disconfStoreProcessor,key);
}","/** 
 * :  + 
 */
@Override public void updateOneConfAndCallback(String key) throws Exception {
  updateOneConf(key);
  DisconfCoreProcessUtils.callOneConf(disconfStoreProcessor,key);
}",0.9436997319034852
60698,"/** 
 */
@Override public void inject2Conf(){
  for (  String key : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    DisconfCenterItem disconfCenterItem=(DisconfCenterItem)disconfStoreProcessor.getConfData(key);
    if (disconfCenterItem == null) {
      continue;
    }
    try {
      Object object=null;
      Field field=disconfCenterItem.getField();
      if (Modifier.isStatic(field.getModifiers())) {
      }
 else {
        object=DisconfCoreProcessUtils.getSpringBean(field.getDeclaringClass());
      }
      disconfStoreProcessor.inject2Instance(object,key);
    }
 catch (    Exception e) {
      LOGGER.warn(e.toString(),e);
    }
  }
}","/** 
 */
@Override public void inject2Conf(){
  for (  String key : disconfStoreProcessor.getConfKeySet()) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    DisconfCenterItem disconfCenterItem=(DisconfCenterItem)disconfStoreProcessor.getConfData(key);
    inject2OneConf(key,disconfCenterItem);
  }
}",0.5842259006815969
60699,"/** 
 *  
 */
public void updateOneConf(String keyName) throws Exception {
  DisconfCenterItem disconfCenterItem=(DisconfCenterItem)disconfStoreProcessor.getConfData(keyName);
  if (disconfCenterItem != null) {
    updateOneConfItem(keyName,disconfCenterItem);
  }
}","/** 
 *  
 */
private void updateOneConf(String keyName) throws Exception {
  DisconfCenterItem disconfCenterItem=(DisconfCenterItem)disconfStoreProcessor.getConfData(keyName);
  if (disconfCenterItem != null) {
    updateOneConfItem(keyName,disconfCenterItem);
    inject2OneConf(keyName,disconfCenterItem);
  }
}",0.902027027027027
60700,"/** 
 */
@Override public void updateOneConfAndCallback(String key) throws Exception {
  updateOneConf(key);
  DisconfCoreProcessUtils.callOneConf(disconfStoreProcessor,key);
}","/** 
 * :
 */
@Override public void updateOneConfAndCallback(String key) throws Exception {
  updateOneConf(key);
  DisconfCoreProcessUtils.callOneConf(disconfStoreProcessor,key);
}",0.9750692520775625
60701,"/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    if (fileItem.equals(""String_Node_Str"")) {
      System.out.print(""String_Node_Str"");
    }
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getProperties().toString());
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
    }
  }
}","/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getProperties().toString());
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
    }
  }
}",0.9617089883111648
60702,"/** 
 */
private List<DisconfCenterBaseModel> getDisconfCenterFiles(ScanStaticModel scanModel){
  List<DisconfCenterBaseModel> disconfCenterFiles=new ArrayList<DisconfCenterBaseModel>();
  for (  String fileName : scanModel.getNonAnnotationFileSet()) {
    DisconfCenterFile disconfCenterFile=new DisconfCenterFile();
    disconfCenterFile.setFileName(fileName);
    DisConfCommonModel disConfCommonModel=makeDisConfCommonModel(""String_Node_Str"",""String_Node_Str"");
    disconfCenterFile.setDisConfCommonModel(disConfCommonModel);
    String url=DisconfWebPathMgr.getRemoteUrlParameter(DisClientSysConfig.getInstance().CONF_SERVER_STORE_ACTION,disConfCommonModel.getApp(),disConfCommonModel.getVersion(),disConfCommonModel.getEnv(),disconfCenterFile.getFileName(),DisConfigTypeEnum.FILE);
    disconfCenterFile.setRemoteServerUrl(url);
    disconfCenterFiles.add(disconfCenterFile);
  }
  return disconfCenterFiles;
}","/** 
 */
private List<DisconfCenterBaseModel> getDisconfCenterFiles(ScanStaticModel scanModel){
  List<DisconfCenterBaseModel> disconfCenterFiles=new ArrayList<DisconfCenterBaseModel>();
  for (  String fileName : scanModel.getNonAnnotationFileSet()) {
    fileName=fileName.trim();
    DisconfCenterFile disconfCenterFile=new DisconfCenterFile();
    disconfCenterFile.setFileName(fileName);
    DisConfCommonModel disConfCommonModel=makeDisConfCommonModel(""String_Node_Str"",""String_Node_Str"");
    disconfCenterFile.setDisConfCommonModel(disConfCommonModel);
    String url=DisconfWebPathMgr.getRemoteUrlParameter(DisClientSysConfig.getInstance().CONF_SERVER_STORE_ACTION,disConfCommonModel.getApp(),disConfCommonModel.getVersion(),disConfCommonModel.getEnv(),disconfCenterFile.getFileName(),DisConfigTypeEnum.FILE);
    disconfCenterFile.setRemoteServerUrl(url);
    disconfCenterFiles.add(disconfCenterFile);
  }
  return disconfCenterFiles;
}",0.9839055793991416
60703,"/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getProperties().toString());
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),(String)object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}","/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    if (fileItem.equals(""String_Node_Str"")) {
      System.out.print(""String_Node_Str"");
    }
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getProperties().toString());
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
    }
  }
}",0.9372693726937268
60704,"/** 
 */
@Override public void inject2Instance(Object object,String fileName){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (object != null) {
    disconfCenterFile.setObject(object);
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    try {
      if (object == null) {
        if (Modifier.isStatic(keMap.get(fileItem).getField().getModifiers())) {
          LOGGER.debug(fileItem + ""String_Node_Str"");
          keMap.get(fileItem).getField().set(null,keMap.get(fileItem).getValue());
        }
      }
 else {
        LOGGER.debug(fileItem + ""String_Node_Str"");
        Object defaultValue=keMap.get(fileItem).getField().get(object);
        if (keMap.get(fileItem).getValue() == null) {
          keMap.get(fileItem).getField().set(object,defaultValue);
          keMap.get(fileItem).setValue(defaultValue);
        }
 else {
          keMap.get(fileItem).getField().set(object,keMap.get(fileItem).getValue());
        }
      }
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}","/** 
 */
@Override public void inject2Instance(Object object,String fileName){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (object != null) {
    disconfCenterFile.setObject(object);
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    try {
      if (object == null) {
        if (Modifier.isStatic(keMap.get(fileItem).getField().getModifiers())) {
          LOGGER.debug(fileItem + ""String_Node_Str"");
          keMap.get(fileItem).getField().set(null,keMap.get(fileItem).getValue());
        }
      }
 else {
        LOGGER.debug(fileItem + ""String_Node_Str"");
        Object defaultValue=keMap.get(fileItem).getField().get(object);
        if (keMap.get(fileItem).getValue() == null) {
          keMap.get(fileItem).getField().set(object,defaultValue);
          keMap.get(fileItem).setValue(defaultValue);
        }
 else {
          keMap.get(fileItem).getField().set(object,keMap.get(fileItem).getValue());
        }
      }
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str""+ e.toString(),e);
    }
  }
}",0.9805749805749806
60705,"/** 
 */
@Override public void inject2Store(String key,DisconfValue disconfValue){
  DisconfCenterItem disconfCenterItem=DisconfCenterStore.getInstance().getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getValue() == null) {
    LOGGER.error(""String_Node_Str"",key);
    return;
  }
  Class<?> typeClass=disconfCenterItem.getField().getType();
  try {
    Object newValue=ClassUtils.getValeByType(typeClass,disconfValue.getValue());
    disconfCenterItem.setValue(newValue);
    if (disconfCenterItem.getObject() != null) {
      disconfCenterItem.getField().set(disconfCenterItem.getObject(),disconfCenterItem.getValue());
    }
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    return;
  }
}","/** 
 */
@Override public void inject2Store(String key,DisconfValue disconfValue){
  DisconfCenterItem disconfCenterItem=DisconfCenterStore.getInstance().getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getValue() == null) {
    LOGGER.error(""String_Node_Str"",key);
    return;
  }
  Class<?> typeClass=disconfCenterItem.getField().getType();
  try {
    Object newValue=ClassUtils.getValeByType(typeClass,disconfValue.getValue());
    disconfCenterItem.setValue(newValue);
    if (disconfCenterItem.getObject() != null) {
      disconfCenterItem.getField().set(disconfCenterItem.getObject(),disconfCenterItem.getValue());
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str""+ e.toString(),e);
    return;
  }
}",0.9740334679746104
60706,"/** 
 */
@Override public void inject2Instance(Object object,String key){
  DisconfCenterItem disconfCenterItem=DisconfCenterStore.getInstance().getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  if (object != null) {
    disconfCenterItem.setObject(object);
  }
  try {
    if (object != null) {
      Object defaultValue=disconfCenterItem.getField().get(object);
      LOGGER.debug(disconfCenterItem.getKey() + ""String_Node_Str"");
      if (disconfCenterItem.getValue() == null) {
        disconfCenterItem.getField().set(object,defaultValue);
        disconfCenterItem.setValue(defaultValue);
      }
 else {
        disconfCenterItem.getField().set(object,disconfCenterItem.getValue());
      }
    }
 else {
      if (Modifier.isStatic(disconfCenterItem.getField().getModifiers())) {
        LOGGER.debug(disconfCenterItem.getKey() + ""String_Node_Str"");
        disconfCenterItem.getField().set(null,disconfCenterItem.getValue());
      }
    }
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    return;
  }
}","/** 
 */
@Override public void inject2Instance(Object object,String key){
  DisconfCenterItem disconfCenterItem=DisconfCenterStore.getInstance().getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  if (object != null) {
    disconfCenterItem.setObject(object);
  }
  try {
    if (object != null) {
      Object defaultValue=disconfCenterItem.getField().get(object);
      LOGGER.debug(disconfCenterItem.getKey() + ""String_Node_Str"");
      if (disconfCenterItem.getValue() == null) {
        disconfCenterItem.getField().set(object,defaultValue);
        disconfCenterItem.setValue(defaultValue);
      }
 else {
        disconfCenterItem.getField().set(object,disconfCenterItem.getValue());
      }
    }
 else {
      if (Modifier.isStatic(disconfCenterItem.getField().getModifiers())) {
        LOGGER.debug(disconfCenterItem.getKey() + ""String_Node_Str"");
        disconfCenterItem.getField().set(null,disconfCenterItem.getValue());
      }
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str""+ e.toString(),e);
    return;
  }
}",0.980340760157274
60707,"/** 
 * Field
 * @param field
 */
public static Object getValeByType(Class<?> type,String value) throws Exception {
  String typeName=type.getName();
  typeName=typeName.toLowerCase();
  if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Integer.valueOf(value);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Long.valueOf(value);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Boolean.valueOf(value);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Double.valueOf(value);
  }
 else {
    return value;
  }
}","/** 
 * Field
 * @param field
 */
public static Object getValeByType(Class<?> type,Object value) throws Exception {
  if (!(value instanceof String)) {
    value=""String_Node_Str"";
  }
  String dataValue=(String)value;
  dataValue=dataValue.trim();
  String typeName=type.getName();
  typeName=typeName.toLowerCase();
  if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Integer.valueOf(dataValue);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Long.valueOf(dataValue);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Boolean.valueOf(dataValue);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    if (value.equals(""String_Node_Str"")) {
      value=""String_Node_Str"";
    }
    return Double.valueOf(dataValue);
  }
 else {
    return value;
  }
}",0.9242492155983864
60708,"@Override public String getUsageInfo(){
  List<String> hostInfoList=zooKeeperDriver.getConf(DISCONF_GROUPNAME);
  return StringUtils.join(hostInfoList,'\n');
}","@Override public String getUsageInfo(){
  List<String> hostInfoList=zooKeeperDriver.getConf(zooConfig.getZookeeperUrlPrefix());
  return StringUtils.join(hostInfoList,'\n');
}",0.8682634730538922
60709,"/** 
 * @Description : TOMCAT
 * @param propertyFilePath
 * @return void
 * @author liaoqiqi
 * @date 2013-6-19
 */
private static Properties loadWithTomcatMode(final String propertyFilePath) throws Exception {
  Properties props=new Properties();
  URL url=loader.getResource(propertyFilePath);
  URI uri=new URI(url.toString());
  props.load(new FileInputStream(uri.getPath()));
  return props;
}","/** 
 * @Description : TOMCAT
 * @param propertyFilePath
 * @return void
 * @author liaoqiqi
 * @date 2013-6-19
 */
private static Properties loadWithTomcatMode(final String propertyFilePath) throws Exception {
  Properties props=new Properties();
  try {
    URL url=loader.getResource(propertyFilePath);
    URI uri=new URI(url.toString());
    props.load(new FileInputStream(uri.getPath()));
  }
 catch (  Exception e) {
    props.load(loader.getResourceAsStream(propertyFilePath));
  }
  return props;
}",0.8552774755168662
60710,"/** 
 * 
 * @param scanPackage
 */
public synchronized static void firstScan(String scanPackage){
  if (isInit == true) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    ConfigMgr.init();
    if (DisClientConfig.getInstance().ENABLE_REMOTE_CONF == false) {
      LOGGER.info(""String_Node_Str"");
      return;
    }
    scanMgr=ScanFactory.getScanMgr();
    scanMgr.firstScan(scanPackage);
    disconfCoreMgr=DisconfCoreFactory.getDisconfCoreMgr();
    disconfCoreMgr.process();
    isInit=true;
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","/** 
 * 
 * @param scanPackage
 */
public synchronized static void firstScan(String scanPackage){
  if (isFirstInit == true) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    ConfigMgr.init();
    if (DisClientConfig.getInstance().ENABLE_REMOTE_CONF == false) {
      LOGGER.info(""String_Node_Str"");
      return;
    }
    scanMgr=ScanFactory.getScanMgr();
    scanMgr.firstScan(scanPackage);
    disconfCoreMgr=DisconfCoreFactory.getDisconfCoreMgr();
    disconfCoreMgr.process();
    isFirstInit=true;
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}",0.9920382165605096
60711,"/** 
 * , 
 * @param scanPackage
 */
public synchronized static void secondScan(){
  if (isInit == false) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    scanMgr.secondScan();
    disconfCoreMgr.inject2DisconfInstance();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
  LOGGER.info(""String_Node_Str"");
}","/** 
 * , 
 * @param scanPackage
 */
public synchronized static void secondScan(){
  if (isFirstInit == false) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (isSecondeInit == true) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  LOGGER.info(""String_Node_Str"");
  try {
    scanMgr.secondScan();
    disconfCoreMgr.inject2DisconfInstance();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  isSecondeInit=true;
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
  LOGGER.info(""String_Node_Str"" + DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
  LOGGER.info(""String_Node_Str"");
}",0.9167927382753404
60712,"/** 
 * @Description : 
 * @return void
 * @author liaoqiqi
 * @date 2013-6-14
 */
public synchronized static void close(){
  try {
    LOGGER.info(""String_Node_Str"");
    disconfCoreMgr.release();
    isInit=false;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","/** 
 * @Description : 
 * @return void
 * @author liaoqiqi
 * @date 2013-6-14
 */
public synchronized static void close(){
  try {
    LOGGER.info(""String_Node_Str"");
    disconfCoreMgr.release();
    isFirstInit=false;
    isSecondeInit=false;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}",0.9511400651465798
60713,"/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),(String)object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}","/** 
 */
@Override public void inject2Store(String fileName,DisconfValue disconfValue){
  DisconfCenterFile disconfCenterFile=DisconfCenterStore.getInstance().getConfFileMap().get(fileName);
  if (disconfCenterFile == null) {
    LOGGER.error(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return;
  }
  if (disconfValue == null || disconfValue.getProperties() == null) {
    LOGGER.error(""String_Node_Str"",fileName);
    return;
  }
  Map<String,FileItemValue> keMap=disconfCenterFile.getKeyMaps();
  for (  String fileItem : keMap.keySet()) {
    Object object=disconfValue.getProperties().get(fileItem);
    if (object == null) {
      LOGGER.error(""String_Node_Str"",fileItem,disconfValue.getProperties().toString());
      continue;
    }
    try {
      Object value=ClassUtils.getValeByType(keMap.get(fileItem).getField().getType(),(String)object);
      keMap.get(fileItem).setValue(value);
      if (disconfCenterFile.getObject() != null) {
        keMap.get(fileItem).getField().set(disconfCenterFile.getObject(),keMap.get(fileItem).getValue());
      }
    }
 catch (    Exception e) {
      LOGGER.error(e.toString(),e);
    }
  }
}",0.6088527551942186
60714,"/** 
 */
public int run(){
  try {
    while (true) {
      LOGGER.info(""String_Node_Str"" + baoBaoService.calcBaiFa());
      LOGGER.info(""String_Node_Str"" + baoBaoService.calcYuErBao());
      Thread.sleep(5000);
      LOGGER.info(""String_Node_Str"" + jedisConfig.getHost() + ""String_Node_Str""+ jedisConfig.getPort()+ ""String_Node_Str""+ REDIS_KEY+ ""String_Node_Str""+ simpleRedisService.getKey(REDIS_KEY));
    }
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  return 0;
}","/** 
 */
public int run(){
  try {
    while (true) {
      Thread.sleep(5000);
    }
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  return 0;
}",0.5045592705167173
60715,"@Test public void demo(){
  new MockUp<DisconfCoreFactory>(){
    @Mock public DisconfCoreMgr getDisconfCoreMgr() throws Exception {
      FetcherMgr fetcherMgr=FetcherFactory.getFetcherMgr();
      final WatchMgr watchMgr=new WatchMgrMock().getMockInstance();
      watchMgr.init(""String_Node_Str"",""String_Node_Str"");
      DisconfCoreMgr disconfCoreMgr=new DisconfCoreMgrImpl(watchMgr,fetcherMgr);
      return disconfCoreMgr;
    }
  }
;
  try {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    LOGGER.info(""String_Node_Str"");
    DisconfMgr.start(ScanPackTestCase.SCAN_PACK_NAME);
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.assertTrue(false);
  }
}","@Test public void demo(){
  new MockUp<DisconfCoreFactory>(){
    @Mock public DisconfCoreMgr getDisconfCoreMgr() throws Exception {
      FetcherMgr fetcherMgr=FetcherFactory.getFetcherMgr();
      final WatchMgr watchMgr=new WatchMgrMock().getMockInstance();
      watchMgr.init(""String_Node_Str"",""String_Node_Str"");
      DisconfCoreMgr disconfCoreMgr=new DisconfCoreMgrImpl(watchMgr,fetcherMgr);
      return disconfCoreMgr;
    }
  }
;
  try {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    LOGGER.info(""String_Node_Str"");
    DisconfMgr.start(ScanPackTestCase.SCAN_PACK_NAME);
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().confToString());
    LOGGER.info(DisconfStoreProcessorFactory.getDisconfStoreItemProcessor().confToString());
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA()));
    Assert.assertEquals(new Long(1000),confA.getVarA());
    LOGGER.info(String.valueOf(""String_Node_Str"" + confA.getVarA2()));
    Assert.assertEquals(new Long(2000),confA.getVarA2());
    LOGGER.info(String.valueOf(""String_Node_Str"" + serviceA.getVarAA()));
    Assert.assertEquals(new Integer(1000).intValue(),serviceA.getVarAA());
    LOGGER.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.assertTrue(false);
  }
}",0.9359838274932616
60716,"/** 
 * 
 */
public void injectItem2Store(String key,String value){
  DisconfCenterItem disconfCenterItem=disconfCenterStore.getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  Class<?> typeClass=disconfCenterItem.getField().getType();
  try {
    Object newValue=ClassUtils.getValeByType(typeClass,value);
    disconfCenterItem.setValue(newValue);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    return;
  }
}","/** 
 * 
 */
public void injectItem2Store(String key,String value){
  DisconfCenterItem disconfCenterItem=disconfCenterStore.getConfItemMap().get(key);
  if (disconfCenterItem == null) {
    LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  Class<?> typeClass=disconfCenterItem.getField().getType();
  try {
    Object newValue=ClassUtils.getValeByType(typeClass,value);
    disconfCenterItem.setValue(newValue);
    if (disconfCenterItem.getObject() != null) {
      disconfCenterItem.getField().set(disconfCenterItem.getObject(),disconfCenterItem.getValue());
    }
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    return;
  }
}",0.8726376335250616
60717,"@Override public void onClick(View view){
  if (mButton.getVisibility() != View.VISIBLE) {
    return;
  }
  mCollapsed=!mCollapsed;
  mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);
  if (mCollapsedStatus != null) {
    mCollapsedStatus.put(mPosition,mCollapsed);
  }
  Animation animation;
  if (mCollapsed) {
    animation=new ExpandCollapseAnimation(this,getHeight(),mCollapsedHeight);
  }
 else {
    animation=new ExpandCollapseAnimation(this,getHeight(),getHeight() + mTextHeightWithMaxLines - mTv.getHeight());
  }
  animation.setFillAfter(true);
  animation.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      applyAlphaAnimation(mTv,mAnimAlphaStart);
    }
    @Override public void onAnimationEnd(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  clearAnimation();
  startAnimation(animation);
}","@Override public void onClick(View view){
  if (mButton.getVisibility() != View.VISIBLE) {
    return;
  }
  mCollapsed=!mCollapsed;
  mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);
  if (mCollapsedStatus != null) {
    mCollapsedStatus.put(mPosition,mCollapsed);
  }
  Animation animation;
  if (mCollapsed) {
    animation=new ExpandCollapseAnimation(this,getHeight(),mCollapsedHeight);
  }
 else {
    animation=new ExpandCollapseAnimation(this,getHeight(),getHeight() + mTextHeightWithMaxLines - mTv.getHeight());
  }
  animation.setFillAfter(true);
  animation.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      applyAlphaAnimation(mTv,mAnimAlphaStart);
    }
    @Override public void onAnimationEnd(    Animation animation){
      clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  clearAnimation();
  startAnimation(animation);
}",0.9879032258064516
60718,"@Override public void onAnimationEnd(Animation animation){
}","@Override public void onAnimationEnd(Animation animation){
  clearAnimation();
}",0.8571428571428571
60719,"private void drawEndlessProgress(Canvas canvas){
  double indicatorHeight=getDimension(R.dimen.layer_padding);
  int bottom=(int)(getMeasuredHeight() - indicatorHeight);
  if (mProgressBar == null) {
    mProgressBar=new ProgressBar(this);
    mProgressBar.setBounds(0,bottom,getMeasuredWidth(),getMeasuredHeight());
    mProgressBar.setColorScheme(mColor1,mColor2,mColor3,mColor4);
    mProgressBar.start();
  }
  if (getProgress() > 0) {
    mProgressBar.draw(canvas);
  }
}","private void drawEndlessProgress(Canvas canvas){
  if (mProgressBar == null) {
    mProgressBar=new ProgressBar(this);
    setupProgressBarBounds();
    mProgressBar.setColorScheme(mColor1,mColor2,mColor3,mColor4);
    mProgressBar.start();
  }
  if (getProgress() > 0) {
    mProgressBar.draw(canvas);
  }
}",0.7321428571428571
60720,"/** 
 * Set the View's background. Masks the API changes made in Jelly Bean.
 * @param drawable
 */
@SuppressWarnings(""String_Node_Str"") @SuppressLint(""String_Node_Str"") public void setBackgroundCompat(Drawable drawable){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(drawable);
  }
 else {
    setBackgroundDrawable(drawable);
  }
}","/** 
 * Set the View's background. Masks the API changes made in Jelly Bean.
 * @param drawable
 */
@SuppressWarnings(""String_Node_Str"") @SuppressLint(""String_Node_Str"") public void setBackgroundCompat(Drawable drawable){
  int pL=getPaddingLeft();
  int pT=getPaddingTop();
  int pR=getPaddingRight();
  int pB=getPaddingBottom();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(drawable);
  }
 else {
    setBackgroundDrawable(drawable);
  }
  setPadding(pL,pT,pR,pB);
}",0.8437856328392246
60721,"public void start(final ProcessButton button){
  final Handler handler=new Handler();
  handler.postDelayed(new Runnable(){
    @Override public void run(){
      mProgress+=10;
      button.setProgress(mProgress);
      if (mProgress <= 110) {
        handler.postDelayed(this,generateDelay());
      }
 else {
        mListener.onComplete();
      }
    }
  }
,generateDelay());
}","public void start(final ProcessButton button){
  final Handler handler=new Handler();
  handler.postDelayed(new Runnable(){
    @Override public void run(){
      mProgress+=10;
      button.setProgress(mProgress);
      if (mProgress < 100) {
        handler.postDelayed(this,generateDelay());
      }
 else {
        mListener.onComplete();
      }
    }
  }
,generateDelay());
}",0.9934469200524246
60722,"@Override public void run(){
  mProgress+=10;
  button.setProgress(mProgress);
  if (mProgress <= 110) {
    handler.postDelayed(this,generateDelay());
  }
 else {
    mListener.onComplete();
  }
}","@Override public void run(){
  mProgress+=10;
  button.setProgress(mProgress);
  if (mProgress < 100) {
    handler.postDelayed(this,generateDelay());
  }
 else {
    mListener.onComplete();
  }
}",0.9923664122137404
60723,"private void init(Context context,AttributeSet attrs){
  if (attrs != null) {
    initAttributes(context,attrs);
  }
  setBackgroundDrawable(getDrawable(R.drawable.btn_selector));
}","private void init(Context context,AttributeSet attrs){
  StateListDrawable states=new StateListDrawable();
  if (attrs != null) {
    initAttributes(context,attrs,states);
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(states);
  }
 else {
    setBackgroundDrawable(states);
  }
}",0.5788423153692615
60724,"private void initAttributes(Context context,AttributeSet attributeSet){
  TypedArray attr=getTypedArray(context,attributeSet,R.styleable.FlatButton);
  if (attr == null) {
    return;
  }
  try {
    GradientDrawable drawablePressed=getGradientDrawable(R.drawable.rect_pressed);
    if (attr.hasValue(R.styleable.FlatButton_colorPressed)) {
      drawablePressed.setColor(getColor(attr,R.styleable.FlatButton_colorPressed));
    }
    LayerDrawable drawableNormal=(LayerDrawable)getDrawable(R.drawable.rect_normal);
    GradientDrawable drawableTop=(GradientDrawable)drawableNormal.getDrawable(0);
    GradientDrawable drawableBottom=(GradientDrawable)drawableNormal.getDrawable(1);
    if (attr.hasValue(R.styleable.FlatButton_colorNormal)) {
      drawableBottom.setColor(getColor(attr,R.styleable.FlatButton_colorNormal));
    }
    if (attr.hasValue(R.styleable.FlatButton_colorPressed)) {
      drawableTop.setColor(getColor(attr,R.styleable.FlatButton_colorPressed));
    }
  }
  finally {
    attr.recycle();
  }
}","private void initAttributes(Context context,AttributeSet attributeSet,StateListDrawable states){
  TypedArray attr=getTypedArray(context,attributeSet,R.styleable.FlatButton);
  if (attr == null) {
    return;
  }
  try {
    GradientDrawable drawablePressed=(GradientDrawable)getGradientDrawable(R.drawable.rect_pressed).mutate();
    if (attr.hasValue(R.styleable.FlatButton_colorPressed)) {
      drawablePressed.setColor(getColor(attr,R.styleable.FlatButton_colorPressed));
    }
    LayerDrawable drawableNormal=(LayerDrawable)getDrawable(R.drawable.rect_normal).mutate();
    ;
    GradientDrawable drawableTop=(GradientDrawable)drawableNormal.getDrawable(0).mutate();
    ;
    GradientDrawable drawableBottom=(GradientDrawable)drawableNormal.getDrawable(1).mutate();
    ;
    if (attr.hasValue(R.styleable.FlatButton_colorNormal)) {
      drawableBottom.setColor(getColor(attr,R.styleable.FlatButton_colorNormal));
    }
    if (attr.hasValue(R.styleable.FlatButton_colorPressed)) {
      drawableTop.setColor(getColor(attr,R.styleable.FlatButton_colorPressed));
    }
    states.addState(new int[]{android.R.attr.state_pressed},drawablePressed);
    states.addState(new int[]{},drawableNormal);
  }
  finally {
    attr.recycle();
  }
}",0.9011473962930272
60725,"private void init(Context context,AttributeSet attrs){
  mMinProgress=0;
  mMaxProgress=100;
  mProgressDrawable=getGradientDrawable(R.drawable.rect_progress);
  mCompleteDrawable=getGradientDrawable(R.drawable.rect_complete);
  if (attrs != null) {
    initAttributes(context,attrs);
  }
}","private void init(Context context,AttributeSet attrs){
  mMinProgress=0;
  mMaxProgress=100;
  mProgressDrawable=(GradientDrawable)getGradientDrawable(R.drawable.rect_progress).mutate();
  mCompleteDrawable=(GradientDrawable)getGradientDrawable(R.drawable.rect_complete).mutate();
  if (attrs != null) {
    initAttributes(context,attrs);
  }
}",0.9053627760252366
60726,"@Override public Job call() throws Exception {
  int retries=20;
  int attempts=0;
  Set<String> retryableExceptions=ImmutableSet.of(RuntimeException.class.getName());
  Set<String> retryableExceptionMessages=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  while (true) {
    attempts++;
    try {
      return doExecute();
    }
 catch (    ExecutionFailureException e) {
      QueryError error=e.getJob().getError();
      FailureInfo failureInfo=(error == null) ? null : error.getFailureInfo();
      if ((failureInfo == null) || !retryableExceptions.contains(failureInfo.getType()) || !Iterables.any(retryableExceptionMessages,new StringContainsSubstringPredicate(failureInfo.getMessage()))|| !(retries > attempts)) {
        throw e;
      }
      job.setError(null);
      job.setState(JobState.QUEUED);
      updateJobInfo(job.getTablesUsed(),job.getColumns(),job.getQueryStats(),null,null,Collections.<List<Object>>emptyList(),true);
      log.info(""String_Node_Str"",error.toString());
    }
  }
}","@Override public Job call() throws Exception {
  int retries=20;
  int attempts=0;
  Set<String> retryableExceptions=ImmutableSet.of(RuntimeException.class.getName());
  Set<String> retryableExceptionMessages=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  while (!isCancelled) {
    attempts++;
    try {
      return doExecute();
    }
 catch (    ExecutionFailureException e) {
      QueryError error=e.getJob().getError();
      FailureInfo failureInfo=(error == null) ? null : error.getFailureInfo();
      if ((failureInfo == null) || !retryableExceptions.contains(failureInfo.getType()) || !Iterables.any(retryableExceptionMessages,new StringContainsSubstringPredicate(failureInfo.getMessage()))|| !(retries > attempts)) {
        throw e;
      }
      job.setError(null);
      job.setState(JobState.QUEUED);
      updateJobInfo(job.getTablesUsed(),job.getColumns(),job.getQueryStats(),null,null,Collections.<List<Object>>emptyList(),true);
      log.info(""String_Node_Str"",error.toString());
    }
  }
  return job;
}",0.9853515625
60727,"private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}","private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setQueryStats(createNoOpQueryStats());
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (isCancelled) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
      }
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}",0.9725776965265084
60728,"protected void jobFinished(Job job){
  job.setQueryFinished(new DateTime());
  historyStore.addRun(job);
  for (  Table t : job.getTablesUsed()) {
    usageStore.markUsage(t);
  }
  if (job.getOutput() instanceof HiveTablePersistentOutput) {
    String[] parts=job.getOutput().getLocation().toString().split(""String_Node_Str"");
    if (parts.length == 2) {
      Map<String,List<String>> cache=schemaCache.getSchemaMap(""String_Node_Str"");
      List<String> tables=cache.get(parts[0]);
      tables.add(parts[1]);
    }
  }
  eventBus.post(new JobFinishedEvent(job));
}","protected void jobFinished(Job job){
  job.setQueryFinished(new DateTime());
  historyStore.addRun(job);
  for (  Table t : job.getTablesUsed()) {
    usageStore.markUsage(t);
  }
  if (job.getOutput() instanceof HiveTablePersistentOutput) {
    String[] parts=job.getOutput().getLocation().toString().split(""String_Node_Str"");
    if (parts.length == 2) {
      Map<String,List<String>> cache=schemaCache.getSchemaMap(""String_Node_Str"");
      List<String> tables=cache.get(parts[0]);
      tables.add(parts[1]);
    }
  }
  eventBus.post(new JobFinishedEvent(job));
  executionMap.remove(job.getUuid());
}",0.967687074829932
60729,"@Override public List<Job> getRecentlyRun(long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=format(""String_Node_Str"",Util.getTableCondition(tables));
    return getJobs(maxResults,1,tablesClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}","@Override public List<Job> getRecentlyRun(long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=Util.getTableCondition(tables);
    return getJobs(maxResults,1,tablesClause,null);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}",0.5736925515055468
60730,"@Override public List<Job> getRecentlyRunForUser(String user,long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=format(""String_Node_Str"",user,Util.getTableCondition(tables));
    return getJobs(maxResults,1,tablesClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}","@Override public List<Job> getRecentlyRunForUser(String user,long maxResults,Iterable<Table> tables){
  try {
    String usersClause=format(""String_Node_Str"",user);
    String tablesClause=Util.getTableCondition(tables);
    return getJobs(maxResults,1,tablesClause,usersClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}",0.9320652173913044
60731,"private List<Job> getJobs(long limit,int dayInterval){
  return getJobs(limit,dayInterval,""String_Node_Str"");
}","private List<Job> getJobs(long limit,int dayInterval){
  return getJobs(limit,dayInterval,null,null);
}",0.8878504672897196
60732,"@Inject public QueriesResource(JobHistoryStore jobHistoryStore){
  this.jobHistoryStore=jobHistoryStore;
}","@Inject public QueriesResource(JobHistoryStore jobHistoryStore,ExecutionClient executionClient){
  this.jobHistoryStore=jobHistoryStore;
  this.executionClient=executionClient;
}",0.7464788732394366
60733,"@GET @Path(""String_Node_Str"") public Response getUserQueries(@Auth AirpalUser user,@PathParam(""String_Node_Str"") String userId,@QueryParam(""String_Node_Str"") int numResults,@QueryParam(""String_Node_Str"") List<PartitionedTable> tables){
  Iterable<Job> recentlyRun;
  int results=Optional.of(numResults).or(200);
  if (tables.size() < 1) {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results);
  }
 else {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results,Iterables.transform(tables,new PartitionedTableToTable()));
  }
  ImmutableList.Builder<Job> filtered=ImmutableList.builder();
  for (  Job job : recentlyRun) {
    if (job.getTablesUsed().isEmpty() && (job.getState() == JobState.FAILED)) {
      filtered.add(job);
      continue;
    }
    for (    Table table : job.getTablesUsed()) {
      if (AuthorizationUtil.isAuthorizedRead(user,table)) {
        filtered.add(new Job(job.getUser(),job.getQuery(),job.getUuid(),job.getOutput(),job.getQueryStats(),job.getState(),Collections.<Column>emptyList(),Collections.<Table>emptySet(),job.getQueryStartedDateTime(),job.getError(),job.getQueryFinishedDateTime()));
      }
    }
  }
  List<Job> sortedResult=Ordering.natural().nullsLast().onResultOf(JOB_ORDERING).reverse().immutableSortedCopy(filtered.build());
  return Response.ok(sortedResult).build();
}","@GET @Path(""String_Node_Str"") public Response getUserQueries(@Auth AirpalUser user,@PathParam(""String_Node_Str"") String userId,@QueryParam(""String_Node_Str"") int numResults,@QueryParam(""String_Node_Str"") List<PartitionedTable> tables){
  Iterable<Job> recentlyRun;
  int results=Optional.of(numResults).or(0);
  if (results <= 0) {
    results=100;
  }
  if (tables.size() < 1) {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results);
  }
 else {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results,Iterables.transform(tables,new PartitionedTableToTable()));
  }
  ImmutableList.Builder<Job> filtered=ImmutableList.builder();
  for (  Job job : recentlyRun) {
    if (job.getTablesUsed().isEmpty() && (job.getState() == JobState.FAILED)) {
      filtered.add(job);
      continue;
    }
    for (    Table table : job.getTablesUsed()) {
      if (AuthorizationUtil.isAuthorizedRead(user,table)) {
        filtered.add(new Job(job.getUser(),job.getQuery(),job.getUuid(),job.getOutput(),job.getQueryStats(),job.getState(),Collections.<Column>emptyList(),Collections.<Table>emptySet(),job.getQueryStartedDateTime(),job.getError(),job.getQueryFinishedDateTime()));
      }
    }
  }
  List<Job> sortedResult=Ordering.natural().nullsLast().onResultOf(JOB_ORDERING).reverse().immutableSortedCopy(filtered.build());
  return Response.ok(sortedResult).build();
}",0.9835345773874864
60734,"public AirpalUser getUser(Subject subject){
  Object principal=subject.getPrincipal();
  if (principal instanceof AirpalUser) {
    return (AirpalUser)principal;
  }
 else   if (principal instanceof String) {
    return new AirpalUserImpl((String)principal,defaultSchema,defaultQueryTimeout,defaultAccessLevel,subject);
  }
 else   if (principal instanceof ToAirpalUser) {
    return ((ToAirpalUser)principal).toAirpalUser(subject);
  }
 else {
    throw new IllegalArgumentException(format(""String_Node_Str"",principal));
  }
}","public AirpalUser getUser(Subject subject){
  Object principal=subject.getPrincipal();
  if (principal instanceof ToAirpalUser) {
    return ((ToAirpalUser)principal).toAirpalUser(subject);
  }
 else   if (principal instanceof String) {
    return new AirpalUserImpl((String)principal,defaultSchema,defaultQueryTimeout,defaultAccessLevel,subject);
  }
 else   if (principal instanceof AirpalUser) {
    return (AirpalUser)principal;
  }
 else {
    throw new IllegalArgumentException(format(""String_Node_Str"",principal));
  }
}",0.8709677419354839
60735,"private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}","private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}",0.9925832412813634
60736,"@Override public void addRun(Job job){
  JobDAO jobDAO=dbi.onDemand(JobDAO.class);
  TableDAO tableDAO=dbi.onDemand(TableDAO.class);
  JobTableDAO jobTableDAO=dbi.onDemand(JobTableDAO.class);
  JobOutputDAO jobOutputDAO=dbi.onDemand(JobOutputDAO.class);
  long jobId=jobDAO.createJob(job);
  Set<TableRow> tablesInDb=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  Sets.SetView<Table> tablesToAdd=Sets.difference(job.getTablesUsed(),Sets.newHashSet(Iterables.transform(tablesInDb,TableRow.MAP_TO_TABLE)));
  tableDAO.createTables(tablesToAdd);
  Set<TableRow> tablesWithIds=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  List<JobTableRow> jobTableRows=new ArrayList<>(job.getTablesUsed().size());
  for (  TableRow tableRow : tablesWithIds) {
    jobTableRows.add(new JobTableRow(-1,jobId,tableRow.getId()));
  }
  jobTableDAO.createJobTables(jobTableRows);
  jobOutputDAO.createJobOutput(job.getOutput(),jobId);
}","@Override public void addRun(Job job){
  JobDAO jobDAO=dbi.onDemand(JobDAO.class);
  TableDAO tableDAO=dbi.onDemand(TableDAO.class);
  JobTableDAO jobTableDAO=dbi.onDemand(JobTableDAO.class);
  JobOutputDAO jobOutputDAO=dbi.onDemand(JobOutputDAO.class);
  long jobId=jobDAO.createJob(job);
  Set<TableRow> tablesInDb=Collections.emptySet();
  if (job.getTablesUsed().size() > 0) {
    tablesInDb=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  }
  Sets.SetView<Table> tablesToAdd=Sets.difference(job.getTablesUsed(),Sets.newHashSet(Iterables.transform(tablesInDb,TableRow.MAP_TO_TABLE)));
  tableDAO.createTables(tablesToAdd);
  Set<TableRow> tablesWithIds=Collections.emptySet();
  if (job.getTablesUsed().size() > 0) {
    tablesWithIds=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  }
  List<JobTableRow> jobTableRows=new ArrayList<>(job.getTablesUsed().size());
  for (  TableRow tableRow : tablesWithIds) {
    jobTableRows.add(new JobTableRow(-1,jobId,tableRow.getId()));
  }
  jobTableDAO.createJobTables(jobTableRows);
  if (job.getOutput().getLocation() != null) {
    jobOutputDAO.createJobOutput(job.getOutput(),jobId);
  }
}",0.8944444444444445
60737,"@Override public SavedQuery map(int index,ResultSet r,StatementContext ctx) throws SQLException {
  try {
    return new UserSavedQuery(objectMapper.readValue(r.getString(""String_Node_Str""),FeaturedQuery.QueryWithPlaceholders.class),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),null,UUID.fromString(r.getString(""String_Node_Str"")),false);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","@Override public SavedQuery map(int index,ResultSet r,StatementContext ctx) throws SQLException {
  try {
    return new UserSavedQuery(objectMapper.readValue(r.getString(""String_Node_Str""),FeaturedQuery.QueryWithPlaceholders.class),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),null,UUID.fromString(r.getString(""String_Node_Str"")),false);
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}",0.9498399146211312
60738,"@Override public Job call() throws Exception {
  int retries=20;
  int attempts=0;
  Set<String> retryableExceptions=ImmutableSet.of(RuntimeException.class.getName());
  Set<String> retryableExceptionMessages=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  while (true) {
    attempts++;
    try {
      return doExecute();
    }
 catch (    ExecutionFailureException e) {
      QueryError error=e.getJob().getError();
      FailureInfo failureInfo=(error == null) ? null : error.getFailureInfo();
      if ((failureInfo == null) || !retryableExceptions.contains(failureInfo.getType()) || !Iterables.any(retryableExceptionMessages,new StringContainsSubstringPredicate(failureInfo.getMessage()))|| !(retries > attempts)) {
        throw e;
      }
      job.setError(null);
      job.setState(JobState.QUEUED);
      updateJobInfo(job.getTablesUsed(),job.getColumns(),job.getQueryStats(),null,null,Collections.<List<Object>>emptyList(),true);
      log.info(""String_Node_Str"",error.toString());
    }
  }
}","@Override public Job call() throws Exception {
  int retries=20;
  int attempts=0;
  Set<String> retryableExceptions=ImmutableSet.of(RuntimeException.class.getName());
  Set<String> retryableExceptionMessages=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  while (!isCancelled) {
    attempts++;
    try {
      return doExecute();
    }
 catch (    ExecutionFailureException e) {
      QueryError error=e.getJob().getError();
      FailureInfo failureInfo=(error == null) ? null : error.getFailureInfo();
      if ((failureInfo == null) || !retryableExceptions.contains(failureInfo.getType()) || !Iterables.any(retryableExceptionMessages,new StringContainsSubstringPredicate(failureInfo.getMessage()))|| !(retries > attempts)) {
        throw e;
      }
      job.setError(null);
      job.setState(JobState.QUEUED);
      updateJobInfo(job.getTablesUsed(),job.getColumns(),job.getQueryStats(),null,null,Collections.<List<Object>>emptyList(),true);
      log.info(""String_Node_Str"",error.toString());
    }
  }
  return job;
}",0.9853515625
60739,"private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}","private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setQueryStats(createNoOpQueryStats());
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (isCancelled) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
      }
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}",0.9725776965265084
60740,"protected void jobFinished(Job job){
  job.setQueryFinished(new DateTime());
  historyStore.addRun(job);
  for (  Table t : job.getTablesUsed()) {
    usageStore.markUsage(t);
  }
  if (job.getOutput() instanceof HiveTablePersistentOutput) {
    String[] parts=job.getOutput().getLocation().toString().split(""String_Node_Str"");
    if (parts.length == 2) {
      Map<String,List<String>> cache=schemaCache.getSchemaMap(""String_Node_Str"");
      List<String> tables=cache.get(parts[0]);
      tables.add(parts[1]);
    }
  }
  eventBus.post(new JobFinishedEvent(job));
}","protected void jobFinished(Job job){
  job.setQueryFinished(new DateTime());
  historyStore.addRun(job);
  for (  Table t : job.getTablesUsed()) {
    usageStore.markUsage(t);
  }
  if (job.getOutput() instanceof HiveTablePersistentOutput) {
    String[] parts=job.getOutput().getLocation().toString().split(""String_Node_Str"");
    if (parts.length == 2) {
      Map<String,List<String>> cache=schemaCache.getSchemaMap(""String_Node_Str"");
      List<String> tables=cache.get(parts[0]);
      tables.add(parts[1]);
    }
  }
  eventBus.post(new JobFinishedEvent(job));
  executionMap.remove(job.getUuid());
}",0.967687074829932
60741,"@Override public List<Job> getRecentlyRun(long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=format(""String_Node_Str"",Util.getTableCondition(tables));
    return getJobs(maxResults,1,tablesClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}","@Override public List<Job> getRecentlyRun(long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=Util.getTableCondition(tables);
    return getJobs(maxResults,1,tablesClause,null);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}",0.5736925515055468
60742,"@Override public List<Job> getRecentlyRunForUser(String user,long maxResults,Iterable<Table> tables){
  try {
    String tablesClause=format(""String_Node_Str"",user,Util.getTableCondition(tables));
    return getJobs(maxResults,1,tablesClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}","@Override public List<Job> getRecentlyRunForUser(String user,long maxResults,Iterable<Table> tables){
  try {
    String usersClause=format(""String_Node_Str"",user);
    String tablesClause=Util.getTableCondition(tables);
    return getJobs(maxResults,1,tablesClause,usersClause);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return Collections.emptyList();
  }
}",0.9320652173913044
60743,"private List<Job> getJobs(long limit,int dayInterval){
  return getJobs(limit,dayInterval,""String_Node_Str"");
}","private List<Job> getJobs(long limit,int dayInterval){
  return getJobs(limit,dayInterval,null,null);
}",0.8878504672897196
60744,"@Inject public QueriesResource(JobHistoryStore jobHistoryStore){
  this.jobHistoryStore=jobHistoryStore;
}","@Inject public QueriesResource(JobHistoryStore jobHistoryStore,ExecutionClient executionClient){
  this.jobHistoryStore=jobHistoryStore;
  this.executionClient=executionClient;
}",0.7464788732394366
60745,"@GET @Path(""String_Node_Str"") public Response getUserQueries(@Auth AirpalUser user,@PathParam(""String_Node_Str"") String userId,@QueryParam(""String_Node_Str"") int numResults,@QueryParam(""String_Node_Str"") List<PartitionedTable> tables){
  Iterable<Job> recentlyRun;
  int results=Optional.of(numResults).or(200);
  if (tables.size() < 1) {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results);
  }
 else {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results,Iterables.transform(tables,new PartitionedTableToTable()));
  }
  ImmutableList.Builder<Job> filtered=ImmutableList.builder();
  for (  Job job : recentlyRun) {
    if (job.getTablesUsed().isEmpty() && (job.getState() == JobState.FAILED)) {
      filtered.add(job);
      continue;
    }
    for (    Table table : job.getTablesUsed()) {
      if (AuthorizationUtil.isAuthorizedRead(user,table)) {
        filtered.add(new Job(job.getUser(),job.getQuery(),job.getUuid(),job.getOutput(),job.getQueryStats(),job.getState(),Collections.<Column>emptyList(),Collections.<Table>emptySet(),job.getQueryStartedDateTime(),job.getError(),job.getQueryFinishedDateTime()));
      }
    }
  }
  List<Job> sortedResult=Ordering.natural().nullsLast().onResultOf(JOB_ORDERING).reverse().immutableSortedCopy(filtered.build());
  return Response.ok(sortedResult).build();
}","@GET @Path(""String_Node_Str"") public Response getUserQueries(@Auth AirpalUser user,@PathParam(""String_Node_Str"") String userId,@QueryParam(""String_Node_Str"") int numResults,@QueryParam(""String_Node_Str"") List<PartitionedTable> tables){
  Iterable<Job> recentlyRun;
  int results=Optional.of(numResults).or(0);
  if (results <= 0) {
    results=100;
  }
  if (tables.size() < 1) {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results);
  }
 else {
    recentlyRun=jobHistoryStore.getRecentlyRunForUser(userId,results,Iterables.transform(tables,new PartitionedTableToTable()));
  }
  ImmutableList.Builder<Job> filtered=ImmutableList.builder();
  for (  Job job : recentlyRun) {
    if (job.getTablesUsed().isEmpty() && (job.getState() == JobState.FAILED)) {
      filtered.add(job);
      continue;
    }
    for (    Table table : job.getTablesUsed()) {
      if (AuthorizationUtil.isAuthorizedRead(user,table)) {
        filtered.add(new Job(job.getUser(),job.getQuery(),job.getUuid(),job.getOutput(),job.getQueryStats(),job.getState(),Collections.<Column>emptyList(),Collections.<Table>emptySet(),job.getQueryStartedDateTime(),job.getError(),job.getQueryFinishedDateTime()));
      }
    }
  }
  List<Job> sortedResult=Ordering.natural().nullsLast().onResultOf(JOB_ORDERING).reverse().immutableSortedCopy(filtered.build());
  return Response.ok(sortedResult).build();
}",0.9835345773874864
60746,"public AirpalUser getUser(Subject subject){
  Object principal=subject.getPrincipal();
  if (principal instanceof AirpalUser) {
    return (AirpalUser)principal;
  }
 else   if (principal instanceof String) {
    return new AirpalUserImpl((String)principal,defaultSchema,defaultQueryTimeout,defaultAccessLevel,subject);
  }
 else   if (principal instanceof ToAirpalUser) {
    return ((ToAirpalUser)principal).toAirpalUser(subject);
  }
 else {
    throw new IllegalArgumentException(format(""String_Node_Str"",principal));
  }
}","public AirpalUser getUser(Subject subject){
  Object principal=subject.getPrincipal();
  if (principal instanceof ToAirpalUser) {
    return ((ToAirpalUser)principal).toAirpalUser(subject);
  }
 else   if (principal instanceof String) {
    return new AirpalUserImpl((String)principal,defaultSchema,defaultQueryTimeout,defaultAccessLevel,subject);
  }
 else   if (principal instanceof AirpalUser) {
    return (AirpalUser)principal;
  }
 else {
    throw new IllegalArgumentException(format(""String_Node_Str"",principal));
  }
}",0.8709677419354839
60747,"private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}","private Job doExecute() throws ExecutionFailureException {
  final String userQuery=QUERY_SPLITTER.splitToList(getJob().getQuery()).get(0);
  final PersistentJobOutput output=job.getOutput();
  final String query=output.processQuery(userQuery);
  final Persistor persistor=output.getPersistor(job);
  if (!persistor.canPersist(authorizer)) {
    throw new ExecutionFailureException(job,""String_Node_Str"",null);
  }
  final Stopwatch stopwatch=Stopwatch.createStarted();
  final List<List<Object>> outputPreview=new ArrayList<>(maxRowsPreviewOutput);
  Set<Table> tables=Collections.emptySet();
  try {
    tables=authorizer.tablesUsedByQuery(query);
  }
 catch (  ParsingException e) {
    job.setError(new QueryError(e.getMessage(),null,-1,new ErrorLocation(e.getLineNumber(),e.getColumnNumber()),null));
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",e));
  }
  if (!authorizer.isAuthorizedRead(tables)) {
    job.setQueryStats(createNoOpQueryStats());
    cancelAndThrow(null,stopwatch,new ExecutionFailureException(job,""String_Node_Str"",null));
  }
  try (StatementClient client=queryRunner.startInternalQuery(query)){
    while (client.isValid() && !Thread.currentThread().isInterrupted()) {
      QueryResults results=client.current();
      List<Column> resultColumns=null;
      JobState jobState=null;
      QueryError queryError=null;
      QueryStats queryStats=null;
      if (stopwatch.elapsed(TimeUnit.MILLISECONDS) > timeout.getMillis()) {
        cancelAndThrow(client,stopwatch,new ExecutionFailureException(job,format(""String_Node_Str"",timeout.toString()),null));
      }
      if (results.getError() != null) {
        queryError=results.getError();
        jobState=JobState.FAILED;
      }
      if ((results.getInfoUri() != null) && (jobState != JobState.FAILED)) {
        BasicQueryInfo queryInfo=queryInfoClient.from(results.getInfoUri());
        if (queryInfo != null) {
          queryStats=queryInfo.getQueryStats();
        }
      }
      if (results.getStats() != null) {
        jobState=JobState.fromStatementState(results.getStats().getState());
      }
      if (results.getColumns() != null) {
        resultColumns=results.getColumns();
        persistor.onColumns(resultColumns);
      }
      if (results.getData() != null) {
        List<List<Object>> resultsData=ImmutableList.copyOf(results.getData());
        persistor.onData(resultsData);
      }
      rlUpdateJobInfo(tables,resultColumns,queryStats,jobState,queryError,outputPreview);
      client.advance();
    }
    QueryResults finalResults=client.finalResults();
    if (finalResults != null && finalResults.getInfoUri() != null) {
      BasicQueryInfo queryInfo=queryInfoClient.from(finalResults.getInfoUri());
      if (queryInfo != null) {
        updateJobInfo(null,null,queryInfo.getQueryStats(),JobState.fromStatementState(finalResults.getStats().getState()),finalResults.getError(),outputPreview,true);
      }
    }
  }
   stopwatch.stop();
  if (job.getState() != JobState.FAILED) {
    persistor.persist();
  }
 else {
    throw new ExecutionFailureException(job,null,null);
  }
  System.out.println(""String_Node_Str"");
  return getJob();
}",0.9925832412813634
60748,"@Override public void addRun(Job job){
  JobDAO jobDAO=dbi.onDemand(JobDAO.class);
  TableDAO tableDAO=dbi.onDemand(TableDAO.class);
  JobTableDAO jobTableDAO=dbi.onDemand(JobTableDAO.class);
  JobOutputDAO jobOutputDAO=dbi.onDemand(JobOutputDAO.class);
  long jobId=jobDAO.createJob(job);
  Set<TableRow> tablesInDb=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  Sets.SetView<Table> tablesToAdd=Sets.difference(job.getTablesUsed(),Sets.newHashSet(Iterables.transform(tablesInDb,TableRow.MAP_TO_TABLE)));
  tableDAO.createTables(tablesToAdd);
  Set<TableRow> tablesWithIds=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  List<JobTableRow> jobTableRows=new ArrayList<>(job.getTablesUsed().size());
  for (  TableRow tableRow : tablesWithIds) {
    jobTableRows.add(new JobTableRow(-1,jobId,tableRow.getId()));
  }
  jobTableDAO.createJobTables(jobTableRows);
  jobOutputDAO.createJobOutput(job.getOutput(),jobId);
}","@Override public void addRun(Job job){
  JobDAO jobDAO=dbi.onDemand(JobDAO.class);
  TableDAO tableDAO=dbi.onDemand(TableDAO.class);
  JobTableDAO jobTableDAO=dbi.onDemand(JobTableDAO.class);
  JobOutputDAO jobOutputDAO=dbi.onDemand(JobOutputDAO.class);
  long jobId=jobDAO.createJob(job);
  Set<TableRow> tablesInDb=Collections.emptySet();
  if (job.getTablesUsed().size() > 0) {
    tablesInDb=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  }
  Sets.SetView<Table> tablesToAdd=Sets.difference(job.getTablesUsed(),Sets.newHashSet(Iterables.transform(tablesInDb,TableRow.MAP_TO_TABLE)));
  tableDAO.createTables(tablesToAdd);
  Set<TableRow> tablesWithIds=Collections.emptySet();
  if (job.getTablesUsed().size() > 0) {
    tablesWithIds=new HashSet<>(tableDAO.getTables(new ArrayList<>(job.getTablesUsed())));
  }
  List<JobTableRow> jobTableRows=new ArrayList<>(job.getTablesUsed().size());
  for (  TableRow tableRow : tablesWithIds) {
    jobTableRows.add(new JobTableRow(-1,jobId,tableRow.getId()));
  }
  jobTableDAO.createJobTables(jobTableRows);
  if (job.getOutput().getLocation() != null) {
    jobOutputDAO.createJobOutput(job.getOutput(),jobId);
  }
}",0.8944444444444445
60749,"@Override public SavedQuery map(int index,ResultSet r,StatementContext ctx) throws SQLException {
  try {
    return new UserSavedQuery(objectMapper.readValue(r.getString(""String_Node_Str""),FeaturedQuery.QueryWithPlaceholders.class),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),null,UUID.fromString(r.getString(""String_Node_Str"")),false);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","@Override public SavedQuery map(int index,ResultSet r,StatementContext ctx) throws SQLException {
  try {
    return new UserSavedQuery(objectMapper.readValue(r.getString(""String_Node_Str""),FeaturedQuery.QueryWithPlaceholders.class),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),r.getString(""String_Node_Str""),null,UUID.fromString(r.getString(""String_Node_Str"")),false);
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}",0.9498399146211312
60750,"@Override public boolean onItemClick(EasyRecyclerView parent,View view,int position,long id){
  Activity activity=getActivity2();
  EasyRecyclerView recyclerView=mRecyclerView;
  if (null == activity || null == recyclerView) {
    return false;
  }
  if (recyclerView.isInCustomChoice()) {
    recyclerView.toggleItemChecked(position);
    return true;
  }
 else {
    List<DownloadInfo> list=mList;
    if (list == null) {
      return false;
    }
    if (position < 0 && position >= list.size()) {
      return false;
    }
    Intent intent=new Intent(activity,GalleryActivity.class);
    intent.setAction(GalleryActivity.ACTION_EH);
    intent.putExtra(GalleryActivity.KEY_GALLERY_INFO,list.get(position));
    startActivity(intent);
    return true;
  }
}","@Override public boolean onItemClick(EasyRecyclerView parent,View view,int position,long id){
  Activity activity=getActivity2();
  EasyRecyclerView recyclerView=mRecyclerView;
  if (null == activity || null == recyclerView) {
    return false;
  }
  if (recyclerView.isInCustomChoice()) {
    recyclerView.toggleItemChecked(position);
    return true;
  }
 else {
    List<DownloadInfo> list=mList;
    if (list == null) {
      return false;
    }
    if (position < 0 || position >= list.size()) {
      return false;
    }
    Intent intent=new Intent(activity,GalleryActivity.class);
    intent.setAction(GalleryActivity.ACTION_EH);
    intent.putExtra(GalleryActivity.KEY_GALLERY_INFO,list.get(position));
    startActivity(intent);
    return true;
  }
}",0.9973718791064388
60751,"@Override public void onClick(View v){
  Context context=getContext2();
  Activity activity=getActivity2();
  EasyRecyclerView recyclerView=mRecyclerView;
  if (null == context || null == activity || null == recyclerView || recyclerView.isInCustomChoice()) {
    return;
  }
  List<DownloadInfo> list=mList;
  if (list == null) {
    return;
  }
  int size=list.size();
  int index=recyclerView.getChildAdapterPosition(itemView);
  if (index < 0 && index >= size) {
    return;
  }
  if (thumb == v) {
    Bundle args=new Bundle();
    args.putString(GalleryDetailScene.KEY_ACTION,GalleryDetailScene.ACTION_GALLERY_INFO);
    args.putParcelable(GalleryDetailScene.KEY_GALLERY_INFO,list.get(index));
    Announcer announcer=new Announcer(GalleryDetailScene.class).setArgs(args);
    if (ApiHelper.SUPPORT_TRANSITION) {
      announcer.setTranHelper(new EnterGalleryDetailTransaction(thumb));
    }
    startScene(announcer);
  }
 else   if (start == v) {
    Intent intent=new Intent(activity,DownloadService.class);
    intent.setAction(DownloadService.ACTION_START);
    intent.putExtra(DownloadService.KEY_GALLERY_INFO,list.get(index));
    activity.startService(intent);
  }
 else   if (stop == v) {
    if (null != mDownloadManager) {
      mDownloadManager.stopDownload(list.get(index).gid);
    }
  }
}","@Override public void onClick(View v){
  Context context=getContext2();
  Activity activity=getActivity2();
  EasyRecyclerView recyclerView=mRecyclerView;
  if (null == context || null == activity || null == recyclerView || recyclerView.isInCustomChoice()) {
    return;
  }
  List<DownloadInfo> list=mList;
  if (list == null) {
    return;
  }
  int size=list.size();
  int index=recyclerView.getChildAdapterPosition(itemView);
  if (index < 0 || index >= size) {
    return;
  }
  if (thumb == v) {
    Bundle args=new Bundle();
    args.putString(GalleryDetailScene.KEY_ACTION,GalleryDetailScene.ACTION_GALLERY_INFO);
    args.putParcelable(GalleryDetailScene.KEY_GALLERY_INFO,list.get(index));
    Announcer announcer=new Announcer(GalleryDetailScene.class).setArgs(args);
    if (ApiHelper.SUPPORT_TRANSITION) {
      announcer.setTranHelper(new EnterGalleryDetailTransaction(thumb));
    }
    startScene(announcer);
  }
 else   if (start == v) {
    Intent intent=new Intent(activity,DownloadService.class);
    intent.setAction(DownloadService.ACTION_START);
    intent.putExtra(DownloadService.KEY_GALLERY_INFO,list.get(index));
    activity.startService(intent);
  }
 else   if (stop == v) {
    if (null != mDownloadManager) {
      mDownloadManager.stopDownload(list.get(index).gid);
    }
  }
}",0.9984709480122324
60752,"@NonNull @Override public FavDrawerHolder onCreateViewHolder(@NonNull ViewGroup parent,int viewType){
  return new FavDrawerHolder(mInflater.inflate(R.layout.item_favorite_list,parent,false));
}","@NonNull @Override public FavDrawerHolder onCreateViewHolder(@NonNull ViewGroup parent,int viewType){
  return new FavDrawerHolder(mInflater.inflate(R.layout.item_drawer_favorites,parent,false));
}",0.9718670076726342
60753,"@Nullable @Override public View onCreateView2(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.scene_favorites,container,false);
  ContentLayout contentLayout=(ContentLayout)view.findViewById(R.id.content_layout);
  mDrawerLayout=(EhDrawerLayout)ViewUtils.$$(getActivity2(),R.id.draw_view);
  mRecyclerView=contentLayout.getRecyclerView();
  FastScroller fastScroller=contentLayout.getFastScroller();
  RefreshLayout refreshLayout=contentLayout.getRefreshLayout();
  mSearchBar=(SearchBar)ViewUtils.$$(view,R.id.search_bar);
  mFabLayout=(FabLayout)ViewUtils.$$(view,R.id.fab_layout);
  Context context=getContext2();
  Assert.assertNotNull(context);
  Resources resources=context.getResources();
  int paddingTopSB=resources.getDimensionPixelOffset(R.dimen.gallery_padding_top_search_bar);
  mHelper=new FavoritesHelper();
  mHelper.setEmptyString(resources.getString(R.string.gallery_list_empty_hit));
  contentLayout.setHelper(mHelper);
  contentLayout.getFastScroller().setOnDragHandlerListener(this);
  mAdapter=new FavoritesAdapter(inflater,resources,mRecyclerView,Settings.getListMode());
  mRecyclerView.setSelector(Ripple.generateRippleDrawable(context,false));
  mRecyclerView.setDrawSelectorOnTop(true);
  mRecyclerView.hasFixedSize();
  mRecyclerView.setClipToPadding(false);
  mRecyclerView.setOnItemClickListener(this);
  mRecyclerView.setOnItemLongClickListener(this);
  mRecyclerView.setChoiceMode(EasyRecyclerView.CHOICE_MODE_MULTIPLE_CUSTOM);
  mRecyclerView.setCustomCheckedListener(this);
  fastScroller.setPadding(fastScroller.getPaddingLeft(),fastScroller.getPaddingTop() + paddingTopSB,fastScroller.getPaddingRight(),fastScroller.getPaddingBottom());
  refreshLayout.setHeaderTranslationY(paddingTopSB);
  mLeftDrawable=new DrawerArrowDrawable(context);
  mSearchBar.setLeftDrawable(mLeftDrawable);
  mSearchBar.setRightDrawable(DrawableManager.getDrawable(context,R.drawable.v_magnify_x24));
  mSearchBar.setHelper(this);
  mSearchBar.setAllowEmptySearch(false);
  updateSearchBar();
  mSearchBarMover=new SearchBarMover(this,mSearchBar,mRecyclerView);
  mFabLayout.setExpanded(false,false);
  mFabLayout.setAutoCancel(false);
  mFabLayout.setHidePrimaryFab(true);
  mFabLayout.setOnClickFabListener(this);
  addAboveSnackView(mFabLayout);
  if (mSearchMode) {
    mSearchMode=false;
    enterSearchMode(false);
  }
  if (!mHasFirstRefresh) {
    mHasFirstRefresh=true;
    mHelper.firstRefresh();
  }
  guideCollections();
  return view;
}","@Nullable @Override public View onCreateView2(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.scene_favorites,container,false);
  ContentLayout contentLayout=(ContentLayout)view.findViewById(R.id.content_layout);
  MainActivity activity=getActivity2();
  Assert.assertNotNull(activity);
  mDrawerLayout=(EhDrawerLayout)ViewUtils.$$(activity,R.id.draw_view);
  mRecyclerView=contentLayout.getRecyclerView();
  FastScroller fastScroller=contentLayout.getFastScroller();
  RefreshLayout refreshLayout=contentLayout.getRefreshLayout();
  mSearchBar=(SearchBar)ViewUtils.$$(view,R.id.search_bar);
  mFabLayout=(FabLayout)ViewUtils.$$(view,R.id.fab_layout);
  Context context=getContext2();
  Assert.assertNotNull(context);
  Resources resources=context.getResources();
  int paddingTopSB=resources.getDimensionPixelOffset(R.dimen.gallery_padding_top_search_bar);
  mHelper=new FavoritesHelper();
  mHelper.setEmptyString(resources.getString(R.string.gallery_list_empty_hit));
  contentLayout.setHelper(mHelper);
  contentLayout.getFastScroller().setOnDragHandlerListener(this);
  mAdapter=new FavoritesAdapter(inflater,resources,mRecyclerView,Settings.getListMode());
  mRecyclerView.setSelector(Ripple.generateRippleDrawable(context,false));
  mRecyclerView.setDrawSelectorOnTop(true);
  mRecyclerView.hasFixedSize();
  mRecyclerView.setClipToPadding(false);
  mRecyclerView.setOnItemClickListener(this);
  mRecyclerView.setOnItemLongClickListener(this);
  mRecyclerView.setChoiceMode(EasyRecyclerView.CHOICE_MODE_MULTIPLE_CUSTOM);
  mRecyclerView.setCustomCheckedListener(this);
  fastScroller.setPadding(fastScroller.getPaddingLeft(),fastScroller.getPaddingTop() + paddingTopSB,fastScroller.getPaddingRight(),fastScroller.getPaddingBottom());
  refreshLayout.setHeaderTranslationY(paddingTopSB);
  mLeftDrawable=new DrawerArrowDrawable(context);
  mSearchBar.setLeftDrawable(mLeftDrawable);
  mSearchBar.setRightDrawable(DrawableManager.getDrawable(context,R.drawable.v_magnify_x24));
  mSearchBar.setHelper(this);
  mSearchBar.setAllowEmptySearch(false);
  updateSearchBar();
  mSearchBarMover=new SearchBarMover(this,mSearchBar,mRecyclerView);
  mFabLayout.setExpanded(false,false);
  mFabLayout.setAutoCancel(false);
  mFabLayout.setHidePrimaryFab(true);
  mFabLayout.setOnClickFabListener(this);
  addAboveSnackView(mFabLayout);
  if (mSearchMode) {
    mSearchMode=false;
    enterSearchMode(false);
  }
  if (!mHasFirstRefresh) {
    mHasFirstRefresh=true;
    mHelper.firstRefresh();
  }
  guideCollections();
  return view;
}",0.984102365257852
60754,"private void onGetFavoritesSuccess(FavoritesParser.Result result,int taskId){
  if (mHelper != null && mSearchBarMover != null && mHelper.isCurrentTask(taskId)) {
    if (mFavCatArray != null) {
      System.arraycopy(result.catArray,0,mFavCatArray,0,10);
      if (mDrawerAdapter != null) {
        mDrawerAdapter.notifyDataSetChanged();
      }
    }
    mFavCountArray=result.countArray;
    if (mFavCountArray != null) {
      mCloudSize=0;
      for (int i=0; i < 10; i++) {
        mCloudSize=mCloudSize + mFavCountArray[i];
      }
    }
    updateSearchBar();
    mHelper.setPages(taskId,result.pages);
    mHelper.onGetPageData(taskId,result.galleryInfoList);
  }
}","private void onGetFavoritesSuccess(FavoritesParser.Result result,int taskId){
  if (mHelper != null && mSearchBarMover != null && mHelper.isCurrentTask(taskId)) {
    if (mFavCatArray != null) {
      System.arraycopy(result.catArray,0,mFavCatArray,0,10);
    }
    mFavCountArray=result.countArray;
    if (mFavCountArray != null) {
      mCloudSize=0;
      for (int i=0; i < 10; i++) {
        mCloudSize=mCloudSize + mFavCountArray[i];
      }
    }
    updateSearchBar();
    mHelper.setPages(taskId,result.pages);
    mHelper.onGetPageData(taskId,result.galleryInfoList);
    if (mDrawerAdapter != null) {
      mDrawerAdapter.notifyDataSetChanged();
    }
  }
}",0.8688524590163934
60755,"@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext2();
  Assert.assertNotNull(context);
  mClient=EhApplication.getEhClient(context);
  mFavCatArray=Settings.getFavCat();
  if (savedInstanceState == null) {
    onInit();
  }
 else {
    onRestore(savedInstanceState);
  }
}","@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext2();
  Assert.assertNotNull(context);
  mClient=EhApplication.getEhClient(context);
  mFavCatArray=Settings.getFavCat();
  mFavCountArray=Settings.getFavCount();
  if (savedInstanceState == null) {
    onInit();
  }
 else {
    onRestore(savedInstanceState);
  }
}",0.9458388375165124
60756,"public AddFavoritesListener(Context context,int stageId,String sceneTag,int taskId,String keyword){
  super(context,stageId,sceneTag);
  mTaskId=taskId;
  mKeyword=keyword;
}","private AddFavoritesListener(Context context,int stageId,String sceneTag,int taskId,String keyword){
  super(context,stageId,sceneTag);
  mTaskId=taskId;
  mKeyword=keyword;
}",0.9742120343839542
60757,"public GetFavoritesListener(Context context,int stageId,String sceneTag,int taskId,boolean local,String keyword){
  super(context,stageId,sceneTag);
  mTaskId=taskId;
  mLocal=local;
  mKeyword=keyword;
}","private GetFavoritesListener(Context context,int stageId,String sceneTag,int taskId,boolean local,String keyword){
  super(context,stageId,sceneTag);
  mTaskId=taskId;
  mLocal=local;
  mKeyword=keyword;
}",0.9731051344743276
60758,"@Override public void onSuccess(FavoritesParser.Result result){
  Settings.putFavCat(result.catArray);
  FavoritesScene scene=getScene();
  if (scene != null) {
    if (mLocal) {
      scene.onGetFavoritesLocal(mKeyword,mTaskId);
    }
 else {
      scene.onGetFavoritesSuccess(result,mTaskId);
    }
  }
}","@Override public void onSuccess(FavoritesParser.Result result){
  Settings.putFavCat(result.catArray);
  Settings.putFavCount(result.countArray);
  FavoritesScene scene=getScene();
  if (scene != null) {
    if (mLocal) {
      scene.onGetFavoritesLocal(mKeyword,mTaskId);
    }
 else {
      scene.onGetFavoritesSuccess(result,mTaskId);
    }
  }
}",0.934351145038168
60759,"@SuppressLint(""String_Node_Str"") public void showVoteStatusDialog(Context context,String voteStatus){
  String[] temp=StringUtils.split(voteStatus,',');
  final int length=temp.length;
  final String[] userArray=new String[length];
  final String[] voteArray=new String[length];
  for (int i=0; i < length; i++) {
    String str=StringUtils.trim(temp[i]);
    int index=str.lastIndexOf(' ');
    if (index < 0) {
      Log.d(TAG,""String_Node_Str"");
      userArray[i]=str;
      voteArray[i]=""String_Node_Str"";
    }
 else {
      userArray[i]=StringUtils.trim(str.substring(0,index));
      voteArray[i]=StringUtils.trim(str.substring(index + 1));
    }
  }
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  context=builder.getContext();
  final LayoutInflater inflater=LayoutInflater.from(context);
  EasyRecyclerView rv=(EasyRecyclerView)inflater.inflate(R.layout.dialog_recycler_view,null);
  rv.setAdapter(new RecyclerView.Adapter<InfoHolder>(){
    @Override public InfoHolder onCreateViewHolder(    ViewGroup parent,    int viewType){
      return new InfoHolder(inflater.inflate(R.layout.item_favorite_list,parent,false));
    }
    @Override public void onBindViewHolder(    InfoHolder holder,    int position){
      holder.key.setText(userArray[position]);
      holder.value.setText(voteArray[position]);
    }
    @Override public int getItemCount(){
      return length;
    }
  }
);
  rv.setLayoutManager(new LinearLayoutManager(context));
  LinearDividerItemDecoration decoration=new LinearDividerItemDecoration(LinearDividerItemDecoration.VERTICAL,context.getResources().getColor(R.color.divider),LayoutUtils.dp2pix(context,1));
  decoration.setPadding(ResourcesUtils.getAttrDimensionPixelOffset(context,R.attr.dialogPreferredPadding));
  rv.addItemDecoration(decoration);
  rv.setSelector(Ripple.generateRippleDrawable(context,false));
  rv.setClipToPadding(false);
  builder.setView(rv).show();
}","@SuppressLint(""String_Node_Str"") public void showVoteStatusDialog(Context context,String voteStatus){
  String[] temp=StringUtils.split(voteStatus,',');
  final int length=temp.length;
  final String[] userArray=new String[length];
  final String[] voteArray=new String[length];
  for (int i=0; i < length; i++) {
    String str=StringUtils.trim(temp[i]);
    int index=str.lastIndexOf(' ');
    if (index < 0) {
      Log.d(TAG,""String_Node_Str"");
      userArray[i]=str;
      voteArray[i]=""String_Node_Str"";
    }
 else {
      userArray[i]=StringUtils.trim(str.substring(0,index));
      voteArray[i]=StringUtils.trim(str.substring(index + 1));
    }
  }
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  context=builder.getContext();
  final LayoutInflater inflater=LayoutInflater.from(context);
  EasyRecyclerView rv=(EasyRecyclerView)inflater.inflate(R.layout.dialog_recycler_view,null);
  rv.setAdapter(new RecyclerView.Adapter<InfoHolder>(){
    @Override public InfoHolder onCreateViewHolder(    ViewGroup parent,    int viewType){
      return new InfoHolder(inflater.inflate(R.layout.item_drawer_favorites,parent,false));
    }
    @Override public void onBindViewHolder(    InfoHolder holder,    int position){
      holder.key.setText(userArray[position]);
      holder.value.setText(voteArray[position]);
    }
    @Override public int getItemCount(){
      return length;
    }
  }
);
  rv.setLayoutManager(new LinearLayoutManager(context));
  LinearDividerItemDecoration decoration=new LinearDividerItemDecoration(LinearDividerItemDecoration.VERTICAL,context.getResources().getColor(R.color.divider),LayoutUtils.dp2pix(context,1));
  decoration.setPadding(ResourcesUtils.getAttrDimensionPixelOffset(context,R.attr.dialogPreferredPadding));
  rv.addItemDecoration(decoration);
  rv.setSelector(Ripple.generateRippleDrawable(context,false));
  rv.setClipToPadding(false);
  builder.setView(rv).show();
}",0.9930142302716688
60760,"@Override public boolean onTouchEvent(@NonNull MotionEvent event){
  if (mSeekBar == null) {
    return super.onTouchEvent(event);
  }
 else {
    final float offsetX=-mSeekBar.getLeft();
    final float offsetY=-mSeekBar.getTop();
    event.offsetLocation(offsetX,offsetY);
    mSeekBar.onTouchEvent(event);
    event.offsetLocation(-offsetX,-offsetY);
    return true;
  }
}","@Override public boolean onTouchEvent(@NonNull MotionEvent event){
  if (mSeekBar == null) {
    return super.onTouchEvent(event);
  }
 else {
    View containingView=(View)mSeekBar.getParent();
    final float offsetX=-(containingView.getLeft() + mSeekBar.getLeft());
    final float offsetY=-(containingView.getTop() + mSeekBar.getTop());
    event.offsetLocation(offsetX,offsetY);
    mSeekBar.onTouchEvent(event);
    event.offsetLocation(-offsetX,-offsetY);
    return true;
  }
}",0.8734030197444832
60761,"@SuppressWarnings(""String_Node_Str"") public static SpiderInfo read(@Nullable InputStream is){
  if (null == is) {
    return null;
  }
  SpiderInfo spiderInfo=null;
  try {
    spiderInfo=new SpiderInfo();
    spiderInfo.startPage=getStartPage(IOUtils.readAsciiLine(is));
    spiderInfo.gid=Long.parseLong(IOUtils.readAsciiLine(is));
    spiderInfo.token=IOUtils.readAsciiLine(is);
    IOUtils.readAsciiLine(is);
    spiderInfo.previewPages=Integer.parseInt(IOUtils.readAsciiLine(is));
    spiderInfo.previewPerPage=Integer.parseInt(IOUtils.readAsciiLine(is));
    spiderInfo.pages=Integer.parseInt(IOUtils.readAsciiLine(is));
    if (spiderInfo.pages <= 0) {
      return null;
    }
    spiderInfo.pTokenMap=new SparseArray<>(spiderInfo.pages);
    while (true) {
      String line=IOUtils.readAsciiLine(is);
      int pos=line.indexOf(""String_Node_Str"");
      if (pos > 0 || pos < line.length() - 1) {
        int index=Integer.parseInt(line.substring(0,pos));
        String pToken=line.substring(pos + 1);
        if (!TextUtils.isEmpty(pToken)) {
          spiderInfo.pTokenMap.put(index,pToken);
        }
      }
 else {
        Log.e(TAG,""String_Node_Str"" + pos);
      }
    }
  }
 catch (  IOException|NumberFormatException e) {
  }
  if (spiderInfo == null || spiderInfo.gid == -1 || spiderInfo.token == null || spiderInfo.previewPages == -1 || spiderInfo.previewPerPage == -1 || spiderInfo.pages == -1 || spiderInfo.pTokenMap == null) {
    return null;
  }
 else {
    return spiderInfo;
  }
}","@SuppressWarnings(""String_Node_Str"") public static SpiderInfo read(@Nullable InputStream is){
  if (null == is) {
    return null;
  }
  SpiderInfo spiderInfo=null;
  try {
    spiderInfo=new SpiderInfo();
    String line=IOUtils.readAsciiLine(is);
    int version=getVersion(line);
    if (version == VERSION) {
      line=IOUtils.readAsciiLine(is);
    }
 else     if (version == 1) {
    }
 else {
      return null;
    }
    spiderInfo.startPage=getStartPage(line);
    spiderInfo.gid=Long.parseLong(IOUtils.readAsciiLine(is));
    spiderInfo.token=IOUtils.readAsciiLine(is);
    IOUtils.readAsciiLine(is);
    spiderInfo.previewPages=Integer.parseInt(IOUtils.readAsciiLine(is));
    line=IOUtils.readAsciiLine(is);
    if (version == 1) {
    }
 else {
      spiderInfo.previewPerPage=Integer.parseInt(line);
    }
    spiderInfo.pages=Integer.parseInt(IOUtils.readAsciiLine(is));
    if (spiderInfo.pages <= 0) {
      return null;
    }
    spiderInfo.pTokenMap=new SparseArray<>(spiderInfo.pages);
    while (true) {
      line=IOUtils.readAsciiLine(is);
      int pos=line.indexOf(""String_Node_Str"");
      if (pos > 0 || pos < line.length() - 1) {
        int index=Integer.parseInt(line.substring(0,pos));
        String pToken=line.substring(pos + 1);
        if (!TextUtils.isEmpty(pToken)) {
          spiderInfo.pTokenMap.put(index,pToken);
        }
      }
 else {
        Log.e(TAG,""String_Node_Str"" + pos);
      }
    }
  }
 catch (  IOException|NumberFormatException e) {
  }
  if (spiderInfo == null || spiderInfo.gid == -1 || spiderInfo.token == null || spiderInfo.pages == -1 || spiderInfo.pTokenMap == null) {
    return null;
  }
 else {
    return spiderInfo;
  }
}",0.816619806310528
60762,"public void write(@NonNull OutputStream os){
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(os);
    writer.write(String.format(""String_Node_Str"",startPage >= 0 ? startPage : 0));
    writer.write(""String_Node_Str"");
    writer.write(Long.toString(gid));
    writer.write(""String_Node_Str"");
    writer.write(token);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(previewPages));
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(previewPerPage));
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(pages));
    writer.write(""String_Node_Str"");
    for (int i=0; i < pTokenMap.size(); i++) {
      Integer key=pTokenMap.keyAt(i);
      String value=pTokenMap.valueAt(i);
      if (TOKEN_FAILED.equals(value) || TextUtils.isEmpty(value)) {
        continue;
      }
      writer.write(Integer.toString(key));
      writer.write(""String_Node_Str"");
      writer.write(value);
      writer.write(""String_Node_Str"");
    }
    writer.flush();
  }
 catch (  IOException e) {
  }
 finally {
    IOUtils.closeQuietly(writer);
    IOUtils.closeQuietly(os);
  }
}","public void write(@NonNull OutputStream os){
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(os);
    writer.write(VERSION_STR);
    writer.write(Integer.toString(VERSION));
    writer.write(""String_Node_Str"");
    writer.write(String.format(""String_Node_Str"",startPage >= 0 ? startPage : 0));
    writer.write(""String_Node_Str"");
    writer.write(Long.toString(gid));
    writer.write(""String_Node_Str"");
    writer.write(token);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(previewPages));
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(previewPerPage));
    writer.write(""String_Node_Str"");
    writer.write(Integer.toString(pages));
    writer.write(""String_Node_Str"");
    for (int i=0; i < pTokenMap.size(); i++) {
      Integer key=pTokenMap.keyAt(i);
      String value=pTokenMap.valueAt(i);
      if (TOKEN_FAILED.equals(value) || TextUtils.isEmpty(value)) {
        continue;
      }
      writer.write(Integer.toString(key));
      writer.write(""String_Node_Str"");
      writer.write(value);
      writer.write(""String_Node_Str"");
    }
    writer.flush();
  }
 catch (  IOException e) {
  }
 finally {
    IOUtils.closeQuietly(writer);
    IOUtils.closeQuietly(os);
  }
}",0.9558075870160344
60763,"private SpiderInfo readSpiderInfoFromInternet(EhConfig config){
  try {
    SpiderInfo spiderInfo=new SpiderInfo();
    spiderInfo.gid=mGalleryInfo.gid;
    spiderInfo.token=mGalleryInfo.token;
    Request request=new EhRequestBuilder(EhUrl.getGalleryDetailUrl(mGalleryInfo.gid,mGalleryInfo.token,0,false),config).build();
    Response response=mHttpClient.newCall(request).execute();
    String body=response.body().string();
    spiderInfo.pages=GalleryDetailParser.parsePages(body);
    spiderInfo.pTokenMap=new SparseArray<>(spiderInfo.pages);
    spiderInfo.previewPages=GalleryDetailParser.parsePreviewPages(body);
    readPreviews(body,spiderInfo);
    return spiderInfo;
  }
 catch (  Exception e) {
    return null;
  }
}","private SpiderInfo readSpiderInfoFromInternet(EhConfig config){
  try {
    SpiderInfo spiderInfo=new SpiderInfo();
    spiderInfo.gid=mGalleryInfo.gid;
    spiderInfo.token=mGalleryInfo.token;
    Request request=new EhRequestBuilder(EhUrl.getGalleryDetailUrl(mGalleryInfo.gid,mGalleryInfo.token,0,false),config).build();
    Response response=mHttpClient.newCall(request).execute();
    String body=response.body().string();
    spiderInfo.pages=GalleryDetailParser.parsePages(body);
    spiderInfo.pTokenMap=new SparseArray<>(spiderInfo.pages);
    readPreviews(body,0,spiderInfo);
    return spiderInfo;
  }
 catch (  Exception e) {
    return null;
  }
}",0.9388048956083512
60764,"private void readPreviews(String body,SpiderInfo spiderInfo) throws ParseException {
  PreviewSet previewSet=GalleryDetailParser.parsePreviewSet(body);
  spiderInfo.previewPerPage=previewSet.size();
  for (int i=0, n=previewSet.size(); i < n; i++) {
    GalleryPageUrlParser.Result result=GalleryPageUrlParser.parse(previewSet.getPageUrlAt(i));
    if (result != null) {
synchronized (mPTokenLock) {
        spiderInfo.pTokenMap.put(result.page,result.pToken);
      }
    }
  }
}","private void readPreviews(String body,int index,SpiderInfo spiderInfo) throws ParseException {
  spiderInfo.pages=GalleryDetailParser.parsePages(body);
  spiderInfo.previewPages=GalleryDetailParser.parsePreviewPages(body);
  PreviewSet previewSet=GalleryDetailParser.parsePreviewSet(body);
  if ((index >= 0 && index < spiderInfo.pages - 1) || (index == 0 && spiderInfo.pages == 1)) {
    spiderInfo.previewPerPage=previewSet.size();
  }
 else {
    spiderInfo.previewPerPage=Math.max(spiderInfo.previewPerPage,previewSet.size());
  }
  for (int i=0, n=previewSet.size(); i < n; i++) {
    GalleryPageUrlParser.Result result=GalleryPageUrlParser.parse(previewSet.getPageUrlAt(i));
    if (result != null) {
synchronized (mPTokenLock) {
        spiderInfo.pTokenMap.put(result.page,result.pToken);
      }
    }
  }
}",0.7407407407407407
60765,"private String getPTokenFromInternet(int index,EhConfig config){
  int previewIndex=index / mSpiderInfo.previewPerPage;
  try {
    String url=EhUrl.getGalleryDetailUrl(mGalleryInfo.gid,mGalleryInfo.token,previewIndex,false);
    if (DEBUG_LOG) {
      Log.d(TAG,url);
    }
    Request request=new EhRequestBuilder(url,config).build();
    Response response=mHttpClient.newCall(request).execute();
    String body=response.body().string();
    mSpiderInfo.previewPages=GalleryDetailParser.parsePreviewPages(body);
    readPreviews(body,mSpiderInfo);
    writeSpiderInfoToLocal(mSpiderInfo);
    String pToken;
synchronized (mPTokenLock) {
      pToken=mSpiderInfo.pTokenMap.get(index);
    }
    return pToken;
  }
 catch (  Exception e) {
    return null;
  }
}","private String getPTokenFromInternet(int index,EhConfig config){
  int previewIndex;
  if (mSpiderInfo.previewPerPage >= 0) {
    previewIndex=index / mSpiderInfo.previewPerPage;
  }
 else {
    previewIndex=0;
  }
  try {
    String url=EhUrl.getGalleryDetailUrl(mGalleryInfo.gid,mGalleryInfo.token,previewIndex,false);
    if (DEBUG_PTOKEN) {
      Log.d(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ previewIndex+ ""String_Node_Str""+ mSpiderInfo.previewPerPage+ ""String_Node_Str""+ url);
    }
    Request request=new EhRequestBuilder(url,config).build();
    Response response=mHttpClient.newCall(request).execute();
    String body=response.body().string();
    readPreviews(body,previewIndex,mSpiderInfo);
    writeSpiderInfoToLocal(mSpiderInfo);
    String pToken;
synchronized (mPTokenLock) {
      pToken=mSpiderInfo.pTokenMap.get(index);
    }
    return pToken;
  }
 catch (  Exception e) {
    return null;
  }
}",0.8130177514792899
60766,"public static Result parse(String body) throws ParseException {
  Matcher m;
  Result result=new Result();
  m=PATTERN_IMAGE_URL.matcher(body);
  if (m.find()) {
    result.imageUrl=StringUtils.unescapeXml(StringUtils.trim(m.group(1)));
  }
  m=PATTERN_SKIP_HATH_KEY.matcher(body);
  if (m.find()) {
    result.skipHathKey=StringUtils.unescapeXml(StringUtils.trim(m.group(1)));
  }
  m=PATTERN_ORIGIN_IMAGE_URL.matcher(body);
  if (m.find()) {
    result.originImageUrl=StringUtils.unescapeXml(StringUtils.trim(m.group(1)));
  }
  if (!TextUtils.isEmpty(result.imageUrl) && !TextUtils.isEmpty(result.skipHathKey)) {
    return result;
  }
 else {
    throw new ParseException(""String_Node_Str"",body);
  }
}","public static Result parse(String body) throws ParseException {
  Matcher m;
  Result result=new Result();
  m=PATTERN_IMAGE_URL.matcher(body);
  if (m.find()) {
    result.imageUrl=StringUtils.unescapeXml(StringUtils.trim(m.group(1)));
  }
  m=PATTERN_SKIP_HATH_KEY.matcher(body);
  if (m.find()) {
    result.skipHathKey=StringUtils.unescapeXml(StringUtils.trim(m.group(1)));
  }
  m=PATTERN_ORIGIN_IMAGE_URL.matcher(body);
  if (m.find()) {
    result.originImageUrl=StringUtils.unescapeXml(m.group(1)) + ""String_Node_Str"" + StringUtils.unescapeXml(m.group(2));
  }
  if (!TextUtils.isEmpty(result.imageUrl)) {
    return result;
  }
 else {
    throw new ParseException(""String_Node_Str"",body);
  }
}",0.9177304964539008
60767,"public void setImageUri(@Nullable Uri imageUri){
  if (null == imageUri) {
    return;
  }
  Context context=getContext();
  UniFile file=UniFile.fromUri(context,imageUri);
  try {
    int maxSize=context.getResources().getDimensionPixelOffset(R.dimen.image_search_max_size);
    Bitmap bitmap=BitmapUtils.decodeStream(new UniFileInputStreamPipe(file),maxSize,maxSize);
    if (null == bitmap) {
      return;
    }
    File temp=AppConfig.createTempFile();
    if (null == temp) {
      return;
    }
    OutputStream os=null;
    try {
      os=new FileOutputStream(temp);
      bitmap.compress(Bitmap.CompressFormat.JPEG,90,os);
      mImagePath=temp.getPath();
      mPreview.setImageBitmap(bitmap);
      mPreview.setVisibility(VISIBLE);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
 finally {
      IOUtils.closeQuietly(os);
    }
  }
 catch (  OutOfMemoryError e) {
    Log.e(TAG,""String_Node_Str"");
  }
}","public void setImageUri(@Nullable Uri imageUri){
  if (null == imageUri) {
    return;
  }
  Context context=getContext();
  UniFile file=UniFile.fromUri(context,imageUri);
  if (null == file) {
    return;
  }
  try {
    int maxSize=context.getResources().getDimensionPixelOffset(R.dimen.image_search_max_size);
    Bitmap bitmap=BitmapUtils.decodeStream(new UniFileInputStreamPipe(file),maxSize,maxSize);
    if (null == bitmap) {
      return;
    }
    File temp=AppConfig.createTempFile();
    if (null == temp) {
      return;
    }
    OutputStream os=null;
    try {
      os=new FileOutputStream(temp);
      bitmap.compress(Bitmap.CompressFormat.JPEG,90,os);
      mImagePath=temp.getPath();
      mPreview.setImageBitmap(bitmap);
      mPreview.setVisibility(VISIBLE);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
 finally {
      IOUtils.closeQuietly(os);
    }
  }
 catch (  OutOfMemoryError e) {
    Log.e(TAG,""String_Node_Str"");
  }
}",0.9802904564315352
60768,"@Override public void onBindViewHolder(HistoryHolder holder,int position){
  if (null == mLazyList) {
    return;
  }
  GalleryInfo gi=mLazyList.get(position);
  holder.thumb.load(EhCacheKeyFactory.getThumbKey(gi.gid),gi.thumb);
  holder.title.setText(EhUtils.getSuitableTitle(gi));
  holder.uploader.setText(gi.uploader);
  holder.rating.setRating(gi.rating);
  TextView category=holder.category;
  String newCategoryText=EhUtils.getCategory(gi.category);
  if (!newCategoryText.equals(category.getText())) {
    category.setText(newCategoryText);
    category.setBackgroundColor(EhUtils.getCategoryColor(gi.category));
  }
  holder.posted.setText(gi.posted);
  holder.simpleLanguage.setText(gi.simpleLanguage);
}","@Override @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void onBindViewHolder(HistoryHolder holder,int position){
  if (null == mLazyList) {
    return;
  }
  GalleryInfo gi=mLazyList.get(position);
  holder.thumb.load(EhCacheKeyFactory.getThumbKey(gi.gid),gi.thumb);
  holder.title.setText(EhUtils.getSuitableTitle(gi));
  holder.uploader.setText(gi.uploader);
  holder.rating.setRating(gi.rating);
  TextView category=holder.category;
  String newCategoryText=EhUtils.getCategory(gi.category);
  if (!newCategoryText.equals(category.getText())) {
    category.setText(newCategoryText);
    category.setBackgroundColor(EhUtils.getCategoryColor(gi.category));
  }
  holder.posted.setText(gi.posted);
  holder.simpleLanguage.setText(gi.simpleLanguage);
  if (ApiHelper.SUPPORT_TRANSITION) {
    long gid=gi.gid;
    holder.thumb.setTransitionName(TransitionNameFactory.getThumbTransitionName(gid));
  }
}",0.8820259419394688
60769,"private void onRestore(@NonNull Bundle savedInstanceState){
  mAction=savedInstanceState.getString(KEY_ACTION);
  mFilename=savedInstanceState.getString(KEY_FILENAME);
  mGalleryInfo=savedInstanceState.getParcelable(KEY_GALLERY_INFO);
  mPage=savedInstanceState.getInt(KEY_ACTION,-1);
  buildProvider();
}","private void onRestore(@NonNull Bundle savedInstanceState){
  mAction=savedInstanceState.getString(KEY_ACTION);
  mFilename=savedInstanceState.getString(KEY_FILENAME);
  mGalleryInfo=savedInstanceState.getParcelable(KEY_GALLERY_INFO);
  mPage=savedInstanceState.getInt(KEY_PAGE,-1);
  buildProvider();
}",0.9835526315789472
60770,"@Nullable public static Announcer parseUrl(String url){
  if (TextUtils.isEmpty(url)) {
    return null;
  }
  ListUrlBuilder listUrlBuilder=GalleryListUrlParser.parse(url);
  if (listUrlBuilder != null) {
    Bundle args=new Bundle();
    args.putString(GalleryListScene.KEY_ACTION,GalleryListScene.ACTION_LIST_URL_BUILDER);
    args.putParcelable(GalleryListScene.KEY_LIST_URL_BUILDER,listUrlBuilder);
    return new Announcer(GalleryListScene.class).setArgs(args);
  }
  GalleryDetailUrlParser.Result result1=GalleryDetailUrlParser.parse(url);
  if (result1 != null) {
    Bundle args=new Bundle();
    args.putString(GalleryDetailScene.KEY_ACTION,GalleryDetailScene.ACTION_GID_TOKEN);
    args.putLong(GalleryDetailScene.KEY_GID,result1.gid);
    args.putString(GalleryDetailScene.KEY_TOKEN,result1.token);
    return new Announcer(GalleryDetailScene.class).setArgs(args);
  }
  GalleryPageUrlParser.Result result2=GalleryPageUrlParser.parse(url);
  if (result2 != null) {
    Bundle args=new Bundle();
    args.putString(ProgressScene.KEY_ACTION,ProgressScene.ACTION_GALLERY_TOKEN);
    args.putLong(ProgressScene.KEY_GID,result2.gid);
    args.putString(ProgressScene.KEY_PTOKEN,result2.pToken);
    args.putLong(ProgressScene.KEY_PAGE,result2.page);
    return new Announcer(ProgressScene.class).setArgs(args);
  }
  Log.i(TAG,""String_Node_Str"" + url);
  return null;
}","@Nullable public static Announcer parseUrl(String url){
  if (TextUtils.isEmpty(url)) {
    return null;
  }
  ListUrlBuilder listUrlBuilder=GalleryListUrlParser.parse(url);
  if (listUrlBuilder != null) {
    Bundle args=new Bundle();
    args.putString(GalleryListScene.KEY_ACTION,GalleryListScene.ACTION_LIST_URL_BUILDER);
    args.putParcelable(GalleryListScene.KEY_LIST_URL_BUILDER,listUrlBuilder);
    return new Announcer(GalleryListScene.class).setArgs(args);
  }
  GalleryDetailUrlParser.Result result1=GalleryDetailUrlParser.parse(url);
  if (result1 != null) {
    Bundle args=new Bundle();
    args.putString(GalleryDetailScene.KEY_ACTION,GalleryDetailScene.ACTION_GID_TOKEN);
    args.putLong(GalleryDetailScene.KEY_GID,result1.gid);
    args.putString(GalleryDetailScene.KEY_TOKEN,result1.token);
    return new Announcer(GalleryDetailScene.class).setArgs(args);
  }
  GalleryPageUrlParser.Result result2=GalleryPageUrlParser.parse(url);
  if (result2 != null) {
    Bundle args=new Bundle();
    args.putString(ProgressScene.KEY_ACTION,ProgressScene.ACTION_GALLERY_TOKEN);
    args.putLong(ProgressScene.KEY_GID,result2.gid);
    args.putString(ProgressScene.KEY_PTOKEN,result2.pToken);
    args.putInt(ProgressScene.KEY_PAGE,result2.page);
    return new Announcer(ProgressScene.class).setArgs(args);
  }
  Log.i(TAG,""String_Node_Str"" + url);
  return null;
}",0.9974554707379136
60771,"private boolean handleArgs(Bundle args){
  if (args == null) {
    return false;
  }
  mAction=args.getString(KEY_ACTION);
  if (ACTION_GALLERY_TOKEN.equals(mAction)) {
    mGid=args.getInt(KEY_GID,-1);
    mPToken=args.getString(KEY_PTOKEN,null);
    mPage=args.getInt(KEY_PAGE,-1);
    if (mGid == -1 || mPToken == null || mPage == -1) {
      return false;
    }
    return true;
  }
  return false;
}","private boolean handleArgs(Bundle args){
  if (args == null) {
    return false;
  }
  mAction=args.getString(KEY_ACTION);
  if (ACTION_GALLERY_TOKEN.equals(mAction)) {
    mGid=args.getLong(KEY_GID,-1);
    mPToken=args.getString(KEY_PTOKEN,null);
    mPage=args.getInt(KEY_PAGE,-1);
    if (mGid == -1 || mPToken == null || mPage == -1) {
      return false;
    }
    return true;
  }
  return false;
}",0.9913473423980222
60772,"public static void mergeOldDB(Context context){
  sNewDB=false;
  OldDBHelper oldDBHelper=new OldDBHelper(context);
  SQLiteDatabase oldDB;
  try {
    oldDB=oldDBHelper.getReadableDatabase();
  }
 catch (  Exception e) {
    return;
  }
  SparseJLArray<GalleryInfo> map=new SparseJLArray<>();
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_GALLERY,null);
    if (cursor != null) {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          GalleryInfo gi=new GalleryInfo();
          gi.gid=cursor.getInt(0);
          gi.token=cursor.getString(1);
          gi.title=cursor.getString(2);
          gi.posted=cursor.getString(3);
          gi.category=cursor.getInt(4);
          gi.thumb=cursor.getString(5);
          gi.uploader=cursor.getString(5);
          gi.rating=cursor.getFloat(6);
          map.put(gi.gid,gi);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_LOCAL_FAVOURITE,null);
    if (cursor != null) {
      LocalFavoritesDao dao=sDaoSession.getLocalFavoritesDao();
      if (cursor.moveToFirst()) {
        long i=0L;
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          LocalFavoriteInfo info=new LocalFavoriteInfo(gi);
          info.setTime(i);
          dao.insert(info);
          cursor.moveToNext();
          i++;
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_TAG,null);
    if (cursor != null) {
      QuickSearchDao dao=sDaoSession.getQuickSearchDao();
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          QuickSearch quickSearch=new QuickSearch();
          int mode=cursor.getInt(2);
          String search=cursor.getString(4);
          String tag=cursor.getString(7);
          if (mode == ListUrlBuilder.MODE_UPLOADER && search != null && search.startsWith(""String_Node_Str"")) {
            search=search.substring(""String_Node_Str"".length());
          }
          quickSearch.setTime((long)cursor.getInt(0));
          quickSearch.setName(cursor.getString(1));
          quickSearch.setMode(mode);
          quickSearch.setCategory(cursor.getInt(3));
          quickSearch.setKeyword(mode == ListUrlBuilder.MODE_TAG ? tag : search);
          quickSearch.setAdvanceSearch(cursor.getInt(5));
          quickSearch.setMinRating(cursor.getInt(6));
          dao.insert(quickSearch);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_DOWNLOAD,null);
    if (cursor != null) {
      DownloadsDao dao=sDaoSession.getDownloadsDao();
      if (cursor.moveToFirst()) {
        long i=0L;
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          DownloadInfo info=new DownloadInfo(gi);
          int state=cursor.getInt(2);
          int legacy=cursor.getInt(3);
          if (state == DownloadInfo.STATE_FINISH && legacy > 0) {
            state=DownloadInfo.STATE_FAILED;
          }
          info.setState(state);
          info.setLegacy(legacy);
          if (cursor.getColumnCount() == 5) {
            info.setTime(cursor.getLong(4));
          }
 else {
            info.setTime(i);
          }
          dao.insert(info);
          cursor.moveToNext();
          i++;
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_HISTORY,null);
    if (cursor != null) {
      HistoryDao dao=sDaoSession.getHistoryDao();
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          HistoryInfo info=new HistoryInfo();
          info.setMode(cursor.getInt(1));
          info.setTime(cursor.getLong(2));
          dao.insert(info);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    oldDBHelper.close();
  }
 catch (  Exception e) {
  }
}","public static void mergeOldDB(Context context){
  sNewDB=false;
  OldDBHelper oldDBHelper=new OldDBHelper(context);
  SQLiteDatabase oldDB;
  try {
    oldDB=oldDBHelper.getReadableDatabase();
  }
 catch (  Exception e) {
    return;
  }
  SparseJLArray<GalleryInfo> map=new SparseJLArray<>();
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_GALLERY,null);
    if (cursor != null) {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          GalleryInfo gi=new GalleryInfo();
          gi.gid=cursor.getInt(0);
          gi.token=cursor.getString(1);
          gi.title=cursor.getString(2);
          gi.posted=cursor.getString(3);
          gi.category=cursor.getInt(4);
          gi.thumb=cursor.getString(5);
          gi.uploader=cursor.getString(6);
          gi.rating=cursor.getFloat(7);
          map.put(gi.gid,gi);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_LOCAL_FAVOURITE,null);
    if (cursor != null) {
      LocalFavoritesDao dao=sDaoSession.getLocalFavoritesDao();
      if (cursor.moveToFirst()) {
        long i=0L;
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          LocalFavoriteInfo info=new LocalFavoriteInfo(gi);
          info.setTime(i);
          dao.insert(info);
          cursor.moveToNext();
          i++;
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_TAG,null);
    if (cursor != null) {
      QuickSearchDao dao=sDaoSession.getQuickSearchDao();
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          QuickSearch quickSearch=new QuickSearch();
          int mode=cursor.getInt(2);
          String search=cursor.getString(4);
          String tag=cursor.getString(7);
          if (mode == ListUrlBuilder.MODE_UPLOADER && search != null && search.startsWith(""String_Node_Str"")) {
            search=search.substring(""String_Node_Str"".length());
          }
          quickSearch.setTime((long)cursor.getInt(0));
          quickSearch.setName(cursor.getString(1));
          quickSearch.setMode(mode);
          quickSearch.setCategory(cursor.getInt(3));
          quickSearch.setKeyword(mode == ListUrlBuilder.MODE_TAG ? tag : search);
          quickSearch.setAdvanceSearch(cursor.getInt(5));
          quickSearch.setMinRating(cursor.getInt(6));
          dao.insert(quickSearch);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_DOWNLOAD,null);
    if (cursor != null) {
      DownloadsDao dao=sDaoSession.getDownloadsDao();
      if (cursor.moveToFirst()) {
        long i=0L;
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          DownloadInfo info=new DownloadInfo(gi);
          int state=cursor.getInt(2);
          int legacy=cursor.getInt(3);
          if (state == DownloadInfo.STATE_FINISH && legacy > 0) {
            state=DownloadInfo.STATE_FAILED;
          }
          info.setState(state);
          info.setLegacy(legacy);
          if (cursor.getColumnCount() == 5) {
            info.setTime(cursor.getLong(4));
          }
 else {
            info.setTime(i);
          }
          dao.insert(info);
          cursor.moveToNext();
          i++;
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    Cursor cursor=oldDB.rawQuery(""String_Node_Str"" + OldDBHelper.TABLE_HISTORY,null);
    if (cursor != null) {
      HistoryDao dao=sDaoSession.getHistoryDao();
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          long gid=cursor.getInt(0);
          GalleryInfo gi=map.get(gid);
          if (gi == null) {
            Log.e(TAG,""String_Node_Str"" + gid);
            cursor.moveToNext();
            continue;
          }
          HistoryInfo info=new HistoryInfo();
          info.setMode(cursor.getInt(1));
          info.setTime(cursor.getLong(2));
          dao.insert(info);
          cursor.moveToNext();
        }
      }
      cursor.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    oldDBHelper.close();
  }
 catch (  Exception e) {
  }
}",0.9995826377295493
60773,"public void setOnFinishDate(int downloaded,int total){
  mType=TYPE_ON_FINISH;
  mDownloaded=downloaded;
  mTotal=total;
}","public void setOnFinishDate(int finished,int downloaded,int total){
  mType=TYPE_ON_FINISH;
  mFinished=finished;
  mDownloaded=downloaded;
  mTotal=total;
}",0.8745519713261649
60774,"@Override public void onFinish(int downloaded,int total){
}","@Override public void onFinish(int finished,int downloaded,int total){
}",0.900763358778626
60775,"private boolean runInternal(){
  int size=mPageStateArray.length;
  int index;
  boolean force=false;
synchronized (mRequestPageQueue) {
    if (!mForceRequestPageQueue.isEmpty()) {
      index=mForceRequestPageQueue.remove();
      force=true;
    }
 else     if (!mRequestPageQueue.isEmpty()) {
      index=mRequestPageQueue.remove();
    }
 else     if (!mRequestPageQueue2.isEmpty()) {
      index=mRequestPageQueue2.remove();
    }
 else     if (mDownloadPage >= 0 && mDownloadPage < size) {
      index=mDownloadPage;
      mDownloadPage++;
    }
 else {
      return false;
    }
    if (index < 0 || index >= size) {
      return true;
    }
  }
synchronized (mPageStateLock) {
    int state=mPageStateArray[index];
    if (state == STATE_DOWNLOADING || (!force && (state == STATE_FINISHED || state == STATE_FAILED))) {
      return true;
    }
    updatePageState(index,STATE_DOWNLOADING);
  }
  if (!force && mSpiderDen.contain(index)) {
    updatePageState(index,STATE_FINISHED);
    return true;
  }
  if (force) {
synchronized (mPTokenLock) {
      int i=mSpiderInfo.pTokenMap.indexOfKey(index);
      String pToken=mSpiderInfo.pTokenMap.valueAt(i);
      if (SpiderInfo.TOKEN_FAILED.equals(pToken)) {
        mSpiderInfo.pTokenMap.setValueAt(i,null);
      }
    }
  }
  String pToken=null;
  while (!Thread.currentThread().isInterrupted()) {
synchronized (mPTokenLock) {
      pToken=mSpiderInfo.pTokenMap.get(index);
    }
    if (pToken == null) {
      mRequestPTokenQueue.add(index);
synchronized (mQueenLock) {
        mQueenLock.notify();
      }
synchronized (mWorkerLock) {
        try {
          mWorkerLock.wait();
        }
 catch (        InterruptedException e) {
          if (DEBUG_LOG) {
            Log.d(TAG,Thread.currentThread().getName() + ""String_Node_Str"");
          }
          break;
        }
      }
    }
 else {
      break;
    }
  }
  if (pToken == null) {
    updatePageState(index,STATE_FAILED,null);
    return false;
  }
  if (SpiderInfo.TOKEN_FAILED.equals(pToken)) {
    updatePageState(index,STATE_FAILED,GetText.getString(R.string.error_get_ptoken_error));
    return true;
  }
  return downloadImage(mGid,index,pToken,force);
}","private boolean runInternal(){
  int size=mPageStateArray.length;
  int index;
  boolean force=false;
synchronized (mRequestPageQueue) {
    if (!mForceRequestPageQueue.isEmpty()) {
      index=mForceRequestPageQueue.remove();
      force=true;
    }
 else     if (!mRequestPageQueue.isEmpty()) {
      index=mRequestPageQueue.remove();
    }
 else     if (!mRequestPageQueue2.isEmpty()) {
      index=mRequestPageQueue2.remove();
    }
 else     if (mDownloadPage >= 0 && mDownloadPage < size) {
      index=mDownloadPage;
      mDownloadPage++;
    }
 else {
      return false;
    }
    if (index < 0 || index >= size) {
      return true;
    }
  }
synchronized (mPageStateLock) {
    int state=mPageStateArray[index];
    if (state == STATE_DOWNLOADING || (!force && (state == STATE_FINISHED || state == STATE_FAILED))) {
      return true;
    }
    updatePageState(index,STATE_DOWNLOADING);
  }
  if (!force && mSpiderDen.contain(index)) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    updatePageState(index,STATE_FINISHED);
    return true;
  }
  if (force) {
synchronized (mPTokenLock) {
      int i=mSpiderInfo.pTokenMap.indexOfKey(index);
      String pToken=mSpiderInfo.pTokenMap.valueAt(i);
      if (SpiderInfo.TOKEN_FAILED.equals(pToken)) {
        mSpiderInfo.pTokenMap.setValueAt(i,null);
      }
    }
  }
  String pToken=null;
  while (!Thread.currentThread().isInterrupted()) {
synchronized (mPTokenLock) {
      pToken=mSpiderInfo.pTokenMap.get(index);
    }
    if (pToken == null) {
      mRequestPTokenQueue.add(index);
synchronized (mQueenLock) {
        mQueenLock.notify();
      }
synchronized (mWorkerLock) {
        try {
          mWorkerLock.wait();
        }
 catch (        InterruptedException e) {
          if (DEBUG_LOG) {
            Log.d(TAG,Thread.currentThread().getName() + ""String_Node_Str"");
          }
          break;
        }
      }
    }
 else {
      break;
    }
  }
  if (pToken == null) {
    updatePageState(index,STATE_FAILED,null);
    return false;
  }
  if (SpiderInfo.TOKEN_FAILED.equals(pToken)) {
    updatePageState(index,STATE_FAILED,GetText.getString(R.string.error_get_ptoken_error));
    return true;
  }
  return downloadImage(mGid,index,pToken,force);
}",0.9891304347826086
60776,"private void updatePageState(int index,@State int state,String error){
  int oldState;
synchronized (mPageStateLock) {
    oldState=mPageStateArray[index];
    mPageStateArray[index]=state;
  }
  if (!isStateDone(oldState) && isStateDone(state)) {
    mDownloadedPages.incrementAndGet();
  }
 else   if (isStateDone(oldState) && !isStateDone(state)) {
    mDownloadedPages.decrementAndGet();
  }
  if (oldState != STATE_FINISHED && state == STATE_FINISHED) {
    mFinishedPages.incrementAndGet();
  }
 else   if (oldState == STATE_FINISHED && state != STATE_FINISHED) {
    mFinishedPages.decrementAndGet();
  }
  if (state == STATE_DOWNLOADING) {
    mPageErrorMap.remove(index);
  }
 else   if (state == STATE_FINISHED || state == STATE_FAILED) {
    mPagePercentMap.remove(index);
  }
  if (state == STATE_FAILED) {
    if (error == null) {
      error=GetText.getString(R.string.error_unknown);
    }
    mPageErrorMap.put(index,error);
    notifyPageFailure(index,error);
  }
 else   if (state == STATE_FINISHED) {
    notifyPageSuccess(index);
  }
}","private void updatePageState(int index,@State int state,String error){
  int oldState;
synchronized (mPageStateLock) {
    oldState=mPageStateArray[index];
    mPageStateArray[index]=state;
  }
  if (!isStateDone(oldState) && isStateDone(state)) {
    mDownloadedPages.incrementAndGet();
  }
 else   if (isStateDone(oldState) && !isStateDone(state)) {
    mDownloadedPages.decrementAndGet();
  }
  if (oldState != STATE_FINISHED && state == STATE_FINISHED) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    mFinishedPages.incrementAndGet();
  }
 else   if (oldState == STATE_FINISHED && state != STATE_FINISHED) {
    mFinishedPages.decrementAndGet();
  }
  if (state == STATE_DOWNLOADING) {
    mPageErrorMap.remove(index);
  }
 else   if (state == STATE_FINISHED || state == STATE_FAILED) {
    mPagePercentMap.remove(index);
  }
  if (state == STATE_FAILED) {
    if (error == null) {
      error=GetText.getString(R.string.error_unknown);
    }
    mPageErrorMap.put(index,error);
    notifyPageFailure(index,error);
  }
 else   if (state == STATE_FINISHED) {
    notifyPageSuccess(index);
  }
}",0.9777571825764596
60777,"/** 
 * All workers end
 */
void onFinish(int downloaded,int total);","/** 
 * All workers end
 */
void onFinish(int finished,int downloaded,int total);",0.912751677852349
60778,"private void notifyFinish(){
  int size=-1;
  int[] temp=mPageStateArray;
  if (temp != null) {
    size=temp.length;
  }
synchronized (mSpiderListeners) {
    for (    OnSpiderListener listener : mSpiderListeners) {
      listener.onFinish(mFinishedPages.get(),size);
    }
  }
}","private void notifyFinish(){
  int size=-1;
  int[] temp=mPageStateArray;
  if (temp != null) {
    size=temp.length;
  }
synchronized (mSpiderListeners) {
    for (    OnSpiderListener listener : mSpiderListeners) {
      listener.onFinish(mFinishedPages.get(),mDownloadedPages.get(),size);
    }
  }
}",0.9605488850771868
60779,"@Override public boolean onItemClick(EasyRecyclerView parent,View view,int position,long id){
  if (position != 0) {
    ClipboardManager cmb=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    cmb.setPrimaryClip(ClipData.newPlainText(null,mValues.get(position)));
    Toast.makeText(getContext(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean onItemClick(EasyRecyclerView parent,View view,int position,long id){
  if (position != 0 && mValues != null) {
    ClipboardManager cmb=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    cmb.setPrimaryClip(ClipData.newPlainText(null,mValues.get(position)));
    Toast.makeText(getContext(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
    return true;
  }
 else {
    return false;
  }
}",0.9785794813979708
60780,"@Nullable @Override public View onCreateView2(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.scene_gallery_info,container,false);
  EasyRecyclerView recyclerView=(EasyRecyclerView)view.findViewById(R.id.recycler_view);
  InfoAdapter adapter=new InfoAdapter();
  recyclerView.setAdapter(adapter);
  recyclerView.setLayoutManager(new LinearLayoutManager(getContext(),LinearLayoutManager.VERTICAL,false));
  LinearDividerItemDecoration decoration=new LinearDividerItemDecoration(LinearDividerItemDecoration.VERTICAL,getResources().getColor(R.color.divider),LayoutUtils.dp2pix(getContext(),1));
  decoration.setPadding(getResources().getDimensionPixelOffset(R.dimen.keyline_margin));
  recyclerView.addItemDecoration(decoration);
  recyclerView.setSelector(RippleSalon.generateRippleDrawable(false));
  recyclerView.setClipToPadding(false);
  recyclerView.setHasFixedSize(true);
  recyclerView.setOnItemClickListener(this);
  return view;
}","@SuppressWarnings(""String_Node_Str"") @Nullable @Override public View onCreateView2(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.scene_gallery_info,container,false);
  EasyRecyclerView recyclerView=(EasyRecyclerView)view.findViewById(R.id.recycler_view);
  InfoAdapter adapter=new InfoAdapter();
  recyclerView.setAdapter(adapter);
  recyclerView.setLayoutManager(new LinearLayoutManager(getContext(),LinearLayoutManager.VERTICAL,false));
  LinearDividerItemDecoration decoration=new LinearDividerItemDecoration(LinearDividerItemDecoration.VERTICAL,getResources().getColor(R.color.divider),LayoutUtils.dp2pix(getContext(),1));
  decoration.setPadding(getResources().getDimensionPixelOffset(R.dimen.keyline_margin));
  recyclerView.addItemDecoration(decoration);
  recyclerView.setSelector(RippleSalon.generateRippleDrawable(false));
  recyclerView.setClipToPadding(false);
  recyclerView.setHasFixedSize(true);
  recyclerView.setOnItemClickListener(this);
  return view;
}",0.9821686746987952
60781,"@Override public void onBindViewHolder(InfoHolder holder,int position){
  holder.key.setText(mKeys.get(position));
  holder.value.setText(mValues.get(position));
  holder.itemView.setEnabled(position != 0);
}","@Override public void onBindViewHolder(InfoHolder holder,int position){
  if (mKeys != null && mValues != null) {
    holder.key.setText(mKeys.get(position));
    holder.value.setText(mValues.get(position));
    holder.itemView.setEnabled(position != 0);
  }
}",0.3632478632478632
60782,"private void handlerArgs(Bundle args){
  if (args == null) {
    return;
  }
  GalleryDetail gd=args.getParcelable(KEY_GALLERY_DETAIL);
  if (gd == null) {
    return;
  }
  Resources resources=getResources();
  mKeys.add(resources.getString(R.string.header_key));
  mValues.add(resources.getString(R.string.header_value));
  mKeys.add(resources.getString(R.string.key_gid));
  mValues.add(Integer.toString(gd.gid));
  mKeys.add(resources.getString(R.string.key_token));
  mValues.add(gd.token);
  mKeys.add(resources.getString(R.string.key_url));
  mValues.add(EhUrl.getGalleryDetailUrl(gd.gid,gd.token));
  mKeys.add(resources.getString(R.string.key_title));
  mValues.add(gd.title);
  mKeys.add(resources.getString(R.string.key_title_jpn));
  mValues.add(gd.titleJpn);
  mKeys.add(resources.getString(R.string.key_thumb));
  mValues.add(gd.thumb);
  mKeys.add(resources.getString(R.string.key_category));
  mValues.add(EhUtils.getCategory(gd.category));
  mKeys.add(resources.getString(R.string.key_uploader));
  mValues.add(gd.uploader);
  mKeys.add(resources.getString(R.string.key_posted));
  mValues.add(gd.posted);
  mKeys.add(resources.getString(R.string.key_parent));
  mValues.add(gd.parent);
  mKeys.add(resources.getString(R.string.key_visible));
  mValues.add(gd.visible);
  mKeys.add(resources.getString(R.string.key_language));
  mValues.add(gd.language);
  mKeys.add(resources.getString(R.string.key_pages));
  mValues.add(Integer.toString(gd.pages));
  mKeys.add(resources.getString(R.string.key_size));
  mValues.add(gd.size);
  mKeys.add(resources.getString(R.string.key_resize));
  mValues.add(gd.resize);
  mKeys.add(resources.getString(R.string.key_favourites));
  mValues.add(Integer.toString(gd.favoredTimes));
  mKeys.add(resources.getString(R.string.key_favourited));
  mValues.add(Boolean.toString(gd.isFavored));
  mKeys.add(resources.getString(R.string.key_rates));
  mValues.add(Integer.toString(gd.ratedTimes));
  mKeys.add(resources.getString(R.string.key_rating));
  mValues.add(Float.toString(gd.rating));
  mKeys.add(resources.getString(R.string.key_torrents));
  mValues.add(Integer.toString(gd.torrentCount));
  mKeys.add(resources.getString(R.string.key_torrent_url));
  mValues.add(gd.torrentUrl);
}","private void handlerArgs(Bundle args){
  if (args == null) {
    return;
  }
  GalleryDetail gd=args.getParcelable(KEY_GALLERY_DETAIL);
  if (gd == null) {
    return;
  }
  if (mKeys == null || mValues == null) {
    return;
  }
  Resources resources=getResources();
  mKeys.add(resources.getString(R.string.header_key));
  mValues.add(resources.getString(R.string.header_value));
  mKeys.add(resources.getString(R.string.key_gid));
  mValues.add(Integer.toString(gd.gid));
  mKeys.add(resources.getString(R.string.key_token));
  mValues.add(gd.token);
  mKeys.add(resources.getString(R.string.key_url));
  mValues.add(EhUrl.getGalleryDetailUrl(gd.gid,gd.token));
  mKeys.add(resources.getString(R.string.key_title));
  mValues.add(gd.title);
  mKeys.add(resources.getString(R.string.key_title_jpn));
  mValues.add(gd.titleJpn);
  mKeys.add(resources.getString(R.string.key_thumb));
  mValues.add(gd.thumb);
  mKeys.add(resources.getString(R.string.key_category));
  mValues.add(EhUtils.getCategory(gd.category));
  mKeys.add(resources.getString(R.string.key_uploader));
  mValues.add(gd.uploader);
  mKeys.add(resources.getString(R.string.key_posted));
  mValues.add(gd.posted);
  mKeys.add(resources.getString(R.string.key_parent));
  mValues.add(gd.parent);
  mKeys.add(resources.getString(R.string.key_visible));
  mValues.add(gd.visible);
  mKeys.add(resources.getString(R.string.key_language));
  mValues.add(gd.language);
  mKeys.add(resources.getString(R.string.key_pages));
  mValues.add(Integer.toString(gd.pages));
  mKeys.add(resources.getString(R.string.key_size));
  mValues.add(gd.size);
  mKeys.add(resources.getString(R.string.key_resize));
  mValues.add(gd.resize);
  mKeys.add(resources.getString(R.string.key_favourites));
  mValues.add(Integer.toString(gd.favoredTimes));
  mKeys.add(resources.getString(R.string.key_favourited));
  mValues.add(Boolean.toString(gd.isFavored));
  mKeys.add(resources.getString(R.string.key_rates));
  mValues.add(Integer.toString(gd.ratedTimes));
  mKeys.add(resources.getString(R.string.key_rating));
  mValues.add(Float.toString(gd.rating));
  mKeys.add(resources.getString(R.string.key_torrents));
  mValues.add(Integer.toString(gd.torrentCount));
  mKeys.add(resources.getString(R.string.key_torrent_url));
  mValues.add(gd.torrentUrl);
}",0.9872134038800704
60783,"@Override public void saveFromResponse(HttpUrl url,List<Cookie> cookies){
  List<Cookie> cs=new ArrayList<>(cookies.size() + 2);
  for (  Cookie cookie : cookies) {
    cs.add(cookie);
    if (EhUrl.DOMAIN_E.equals(cookie.domain()) && (KEY_IPD_MEMBER_ID.equals(cookie.name()) || KEY_IPD_PASS_HASH.equals(cookie.name()))) {
      cs.add(newCookie(cookie,CookieDB.cookiesDomain(EhUrl.DOMAIN_EX)));
    }
  }
  super.saveFromResponse(url,cs);
}","@Override public void saveFromResponse(HttpUrl url,List<Cookie> cookies){
  List<Cookie> cs=new ArrayList<>(cookies.size() + 2);
  for (  Cookie cookie : cookies) {
    cs.add(cookie);
    if (EhUrl.DOMAIN_E.equals(cookie.domain()) && (KEY_IPD_MEMBER_ID.equals(cookie.name()) || KEY_IPD_PASS_HASH.equals(cookie.name()))) {
      cs.add(newCookie(cookie,EhUrl.DOMAIN_EX));
    }
  }
  super.saveFromResponse(url,cs);
}",0.972027972027972
60784,"public static Map<String,List<CookieWithID>> getAllCookies(){
  OkHttp3CookieDao dao=sDaoSession.getOkHttp3CookieDao();
  List<OkHttp3CookieRaw> list=dao.queryBuilder().list();
  long now=System.currentTimeMillis();
  Map<String,List<CookieWithID>> result=new HashMap<>();
  for (  OkHttp3CookieRaw raw : list) {
    if (!raw.getPersistent() || raw.getExpiresAt() <= now) {
      dao.delete(raw);
      continue;
    }
    String name=raw.getName();
    String value=raw.getValue();
    String domain=raw.getDomain();
    if (name == null || value == null || domain == null) {
      dao.delete(raw);
      continue;
    }
    Cookie.Builder builder=new Cookie.Builder();
    builder.name(name);
    builder.value(value);
    builder.expiresAt(raw.getExpiresAt());
    if (raw.getHostOnly()) {
      builder.hostOnlyDomain(domain);
    }
 else {
      builder.domain(raw.getDomain());
    }
    builder.path(raw.getPath());
    if (raw.getSecure()) {
      builder.secure();
    }
    if (raw.getHttpOnly()) {
      builder.httpOnly();
    }
    String cookiesDomain=cookiesDomain(domain);
    List<CookieWithID> cookies=result.get(cookiesDomain);
    if (cookies == null) {
      cookies=new ArrayList<>();
      result.put(cookiesDomain,cookies);
    }
    cookies.add(new CookieWithID(raw.getId(),builder.build()));
  }
  return result;
}","public static Map<String,List<CookieWithID>> getAllCookies(){
  OkHttp3CookieDao dao=sDaoSession.getOkHttp3CookieDao();
  List<OkHttp3CookieRaw> list=dao.queryBuilder().list();
  long now=System.currentTimeMillis();
  Map<String,List<CookieWithID>> result=new HashMap<>();
  for (  OkHttp3CookieRaw raw : list) {
    if (!raw.getPersistent() || raw.getExpiresAt() <= now) {
      dao.delete(raw);
      continue;
    }
    String name=raw.getName();
    String value=raw.getValue();
    String domain=raw.getDomain();
    if (name == null || value == null || domain == null) {
      dao.delete(raw);
      continue;
    }
    Cookie.Builder builder=new Cookie.Builder();
    builder.name(name);
    builder.value(value);
    builder.expiresAt(raw.getExpiresAt());
    if (raw.getHostOnly()) {
      builder.hostOnlyDomain(domain);
    }
 else {
      builder.domain(raw.getDomain());
    }
    builder.path(raw.getPath());
    if (raw.getSecure()) {
      builder.secure();
    }
    if (raw.getHttpOnly()) {
      builder.httpOnly();
    }
    List<CookieWithID> cookies=result.get(domain);
    if (cookies == null) {
      cookies=new ArrayList<>();
      result.put(domain,cookies);
    }
    cookies.add(new CookieWithID(raw.getId(),builder.build()));
  }
  return result;
}",0.9747899159663864
60785,"public void add(Cookie cookie){
  addInternal(CookieDB.cookiesDomain(cookie.domain()),cookie);
}","public void add(Cookie cookie){
  String domain=cookie.domain();
  if (hasExpired(cookie)) {
    removeInternal(cookie);
    return;
  }
  List<CookieWithID> cookies=map.get(domain);
  if (cookies == null) {
    cookies=new ArrayList<>();
    map.put(domain,cookies);
  }
 else {
    CookieWithID cwi=removeCookie(cookies,cookie.name());
    if (cwi != null) {
      CookieDB.removeCookie(cwi.id);
    }
  }
  long id=CookieDB.addCookie(cookie);
  cookies.add(new CookieWithID(id,cookie));
}",0.2180579216354344
60786,"private boolean hasExpired(Cookie cookie){
  return cookie.expiresAt() < System.currentTimeMillis();
}","private static boolean hasExpired(Cookie cookie){
  return cookie.expiresAt() < System.currentTimeMillis();
}",0.966824644549763
60787,"public boolean contain(String url,String name){
  return containInternal(CookieDB.cookiesDomain(url),name);
}","public boolean contain(String host,String name){
  for (  String key : map.keySet()) {
    if (domainMatch(host,key)) {
      List<CookieWithID> cookies=map.get(key);
      if (containInternal(host,name,cookies)) {
        return true;
      }
    }
  }
  return false;
}",0.1894736842105263
60788,"private synchronized void removeInternal(String domain){
  List<CookieWithID> cookies=map.remove(domain);
  if (cookies != null) {
    for (    CookieWithID cwi : cookies) {
      CookieDB.removeCookie(cwi.id);
    }
    cookies.clear();
  }
}","private void removeInternal(String host,List<CookieWithID> cookies){
  for (Iterator<CookieWithID> i=cookies.iterator(); i.hasNext(); ) {
    CookieWithID cwi=i.next();
    Cookie cookie=cwi.cookie;
    if (domainMatch(cookie,host) || hasExpired(cookie)) {
      i.remove();
      CookieDB.removeCookie(cwi.id);
    }
  }
}",0.4204946996466431
60789,"public List<Cookie> get(HttpUrl url){
  List<Cookie> result=new ArrayList<>();
  String domain=CookieDB.cookiesDomain(url.url());
  List<CookieWithID> cookies=map.get(domain);
  if (cookies != null) {
    for (Iterator<CookieWithID> i=cookies.iterator(); i.hasNext(); ) {
      CookieWithID cwi=i.next();
      Cookie cookie=cwi.cookie;
      if (hasExpired(cookie)) {
        i.remove();
        CookieDB.removeCookie(cwi.id);
      }
 else       if (cookie.matches(url)) {
        result.add(cookie);
      }
    }
  }
  return Collections.unmodifiableList(result);
}","public List<Cookie> get(HttpUrl url){
  List<Cookie> result=new ArrayList<>();
  String host=url.host();
  for (  String key : map.keySet()) {
    if (domainMatch(host,key)) {
      List<CookieWithID> cookies=map.get(key);
      getInternal(url,cookies,result);
    }
  }
  return Collections.unmodifiableList(result);
}",0.3037120359955005
60790,"private boolean containInternal(String domain,String name){
  List<CookieWithID> cookies=map.get(domain);
  if (cookies != null) {
    for (int i=0, n=cookies.size(); i < n; i++) {
      CookieWithID cwi=cookies.get(i);
      if (cwi.cookie.name().equals(name)) {
        return true;
      }
    }
  }
  return false;
}","private boolean containInternal(String host,String name,List<CookieWithID> cookies){
  for (int i=0, n=cookies.size(); i < n; i++) {
    Cookie cookie=cookies.get(i).cookie;
    if (domainMatch(cookie,host) && cookie.name().equals(name)) {
      return true;
    }
  }
  return false;
}",0.6897689768976898
60791,"public void remove(String url){
  removeInternal(CookieDB.cookiesDomain(url));
}","public void remove(String host){
  for (  String key : map.keySet()) {
    if (domainMatch(host,key)) {
      List<CookieWithID> cookies=map.get(key);
      removeInternal(host,cookies);
    }
  }
}",0.4172661870503597
60792,"/** 
 * Constructor called from   {@link #CREATOR}
 */
private SavedState(Parcel in){
  super(in);
  choiceMode=in.readInt();
  checkedItemCount=in.readInt();
  checkState=in.readSparseBooleanArray();
  final int N=in.readInt();
  if (N > 0) {
    checkIdState=new LongSparseArray<>();
    for (int i=0; i < N; i++) {
      final long key=in.readLong();
      final int value=in.readInt();
      checkIdState.put(key,value);
    }
  }
}","/** 
 * Constructor called from   {@link #CREATOR}
 */
private SavedState(Parcel in){
  Parcelable superState=in.readParcelable(RecyclerView.class.getClassLoader());
  mSuperState=superState != null ? superState : EMPTY_STATE;
  choiceMode=in.readInt();
  checkedItemCount=in.readInt();
  checkState=in.readSparseBooleanArray();
  final int N=in.readInt();
  if (N > 0) {
    checkIdState=new LongSparseArray<>();
    for (int i=0; i < N; i++) {
      final long key=in.readLong();
      final int value=in.readInt();
      checkIdState.put(key,value);
    }
  }
}",0.854
60793,"@Override public void writeToParcel(@NonNull Parcel out,int flags){
  super.writeToParcel(out,flags);
  out.writeInt(choiceMode);
  out.writeInt(checkedItemCount);
  out.writeSparseBooleanArray(checkState);
  final int N=checkIdState != null ? checkIdState.size() : 0;
  out.writeInt(N);
  for (int i=0; i < N; i++) {
    out.writeLong(checkIdState.keyAt(i));
    out.writeInt(checkIdState.valueAt(i));
  }
}","@Override public void writeToParcel(@NonNull Parcel out,int flags){
  out.writeParcelable(mSuperState,flags);
  out.writeInt(choiceMode);
  out.writeInt(checkedItemCount);
  out.writeSparseBooleanArray(checkState);
  final int N=checkIdState != null ? checkIdState.size() : 0;
  out.writeInt(N);
  for (int i=0; i < N; i++) {
    out.writeLong(checkIdState.keyAt(i));
    out.writeInt(checkIdState.valueAt(i));
  }
}",0.9441747572815534
60794,"private void updateShownCount(){
  float step=mMax / mStarCount / 2;
  int shown=Math.round(mRating / step);
  if (shown >= mStarCount * 2) {
    mShownStarCount=mStarCount;
    mShownStarHalfCount=0;
    mShownStarOutlineCount=0;
  }
 else {
    mShownStarCount=shown / 2;
    mShownStarHalfCount=shown % 2;
    mShownStarOutlineCount=mStarCount - mShownStarCount - mShownStarHalfCount;
  }
}","private void updateShownCount(){
  float step=mMax / mStarCount / 2;
  int shown=(int)Math.ceil(mRating / step);
  if (shown >= mStarCount * 2) {
    mShownStarCount=mStarCount;
    mShownStarHalfCount=0;
    mShownStarOutlineCount=0;
  }
 else {
    mShownStarCount=shown / 2;
    mShownStarHalfCount=shown % 2;
    mShownStarOutlineCount=mStarCount - mShownStarCount - mShownStarHalfCount;
  }
}",0.9822784810126582
60795,"public void setRating(float rating){
  if (mRating != rating) {
    mRating=rating;
    int ratingInt=Math.round(rating * 2);
    if (mRatingInt != ratingInt) {
      mRatingInt=ratingInt;
      invalidate();
    }
  }
}","public void setRating(float rating){
  if (mRating != rating) {
    mRating=rating;
    int ratingInt=(int)Math.ceil(rating * 2);
    if (mRatingInt != ratingInt) {
      mRatingInt=ratingInt;
      invalidate();
    }
  }
}",0.5675675675675675
60796,"@Override public void onLayout(View view){
  onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
}","@Override public void onLayout(View view){
  stageLayout.removeOnLayoutListener(this);
  onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
}",0.837037037037037
60797,"@Override public void close(@NonNull final Scene enter,@NonNull final Scene exit){
  AssertUtils.assertInstanceof(""String_Node_Str"",exit,SimpleDialog.class);
  final SimpleDialog exitDialog=(SimpleDialog)exit;
  final Set<Animator> animatorCollection=new HashSet<>();
  int bgColor=exitDialog.getBackgroundColor();
  int endBgColor=bgColor & 0xffffff;
  ObjectAnimator colorAnim=ObjectAnimator.ofInt(exit,""String_Node_Str"",endBgColor);
  colorAnim.setEvaluator(ArgbEvaluator.getInstance());
  colorAnim.setDuration(ANIMATE_TIME);
  animatorCollection.add(colorAnim);
  colorAnim.setInterpolator(AnimationUtils.SLOW_FAST_INTERPOLATOR);
  final View layout=exitDialog.getLayout();
  final View cushion=exitDialog.getCushion();
  final View frame=exitDialog.getFrame();
  AssertUtils.assertNotNull(""String_Node_Str"",cushion);
  AssertUtils.assertNotNull(""String_Node_Str"",frame);
  final StageLayout stageLayout=enter.getStageLayout();
  if (stageLayout.isLayoutRequested()) {
    stageLayout.addOnLayoutListener(new StageLayout.OnLayoutListener(){
      @Override public void onLayout(      View view){
        onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
      }
    }
);
  }
 else {
    onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
  }
}","@Override public void close(@NonNull final Scene enter,@NonNull final Scene exit){
  AssertUtils.assertInstanceof(""String_Node_Str"",exit,SimpleDialog.class);
  final SimpleDialog exitDialog=(SimpleDialog)exit;
  final Set<Animator> animatorCollection=new HashSet<>();
  int bgColor=exitDialog.getBackgroundColor();
  int endBgColor=bgColor & 0xffffff;
  ObjectAnimator colorAnim=ObjectAnimator.ofInt(exit,""String_Node_Str"",endBgColor);
  colorAnim.setEvaluator(ArgbEvaluator.getInstance());
  colorAnim.setDuration(ANIMATE_TIME);
  animatorCollection.add(colorAnim);
  colorAnim.setInterpolator(AnimationUtils.SLOW_FAST_INTERPOLATOR);
  final View layout=exitDialog.getLayout();
  final View cushion=exitDialog.getCushion();
  final View frame=exitDialog.getFrame();
  AssertUtils.assertNotNull(""String_Node_Str"",cushion);
  AssertUtils.assertNotNull(""String_Node_Str"",frame);
  final StageLayout stageLayout=enter.getStageLayout();
  if (stageLayout.isLayoutRequested()) {
    stageLayout.addOnLayoutListener(new StageLayout.OnLayoutListener(){
      @Override public void onLayout(      View view){
        stageLayout.removeOnLayoutListener(this);
        onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
      }
    }
);
  }
 else {
    onClose(enter,exitDialog,layout,cushion,frame,animatorCollection);
  }
}",0.9808575803981624
60798,"@Override protected Bitmap onGetBitmap(){
  Drawable drawable=ContextCompat.getDrawable(mContext,mResId);
  int width=mWidth;
  int height=mHeight;
  if (mWidth <= 0) {
    width=drawable.getIntrinsicWidth();
  }
  if (mHeight <= 0) {
    height=drawable.getIntrinsicHeight();
  }
  if (mWidth <= 0) {
    width=1;
  }
  if (mHeight <= 0) {
    height=1;
  }
  drawable.setBounds(0,0,width,height);
  Bitmap bitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
  Canvas canvas=new Canvas(bitmap);
  drawable.draw(canvas);
  return bitmap;
}","@Override protected Bitmap onGetBitmap(){
  Drawable drawable=ContextCompat.getDrawable(mContext,mResId);
  int width=mWidth;
  int height=mHeight;
  if (width <= 0) {
    width=drawable.getIntrinsicWidth();
  }
  if (height <= 0) {
    height=drawable.getIntrinsicHeight();
  }
  if (width <= 0) {
    width=1;
  }
  if (height <= 0) {
    height=1;
  }
  drawable.setBounds(0,0,width,height);
  Bitmap bitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
  Canvas canvas=new Canvas(bitmap);
  drawable.draw(canvas);
  return bitmap;
}",0.9891107078039928
60799,"@Override public void onCreate(){
  super.onCreate();
  Config.initialize(this);
  Conaco.Builder conacoBuilder=new Conaco.Builder();
  conacoBuilder.hasMemoryCache=true;
  conacoBuilder.memoryCacheMaxSize=getMemoryCacheMaxSize();
  conacoBuilder.hasDiskCache=true;
  conacoBuilder.diskCacheDir=new File(getCacheDir(),""String_Node_Str"");
  conacoBuilder.diskCacheMaxSize=50 * 1024 * 1024;
  conacoBuilder.httpClient=EhOkHttpClient.getInstance();
  mConaco=conacoBuilder.build();
}","@Override public void onCreate(){
  super.onCreate();
  Config.initialize(this);
  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
    CookieSyncManager.createInstance(this);
  }
  Conaco.Builder conacoBuilder=new Conaco.Builder();
  conacoBuilder.hasMemoryCache=true;
  conacoBuilder.memoryCacheMaxSize=getMemoryCacheMaxSize();
  conacoBuilder.hasDiskCache=true;
  conacoBuilder.diskCacheDir=new File(getCacheDir(),""String_Node_Str"");
  conacoBuilder.diskCacheMaxSize=50 * 1024 * 1024;
  conacoBuilder.httpClient=EhOkHttpClient.getInstance();
  mConaco=conacoBuilder.build();
}",0.897196261682243
60800,"public Row(String imageUrl){
  this.imageUrl=imageUrl;
  int index1=imageUrl.lastIndexOf('-');
  int index2=imageUrl.lastIndexOf('.');
  try {
    imageIndex=Integer.parseInt(imageUrl.substring(index1 + 1,index2)) - 1;
  }
 catch (  Exception e) {
    Log.w(""String_Node_Str"",e);
    imageIndex=-1;
  }
}","public Row(String imageUrl){
  this.imageUrl=imageUrl;
  int index1=imageUrl.lastIndexOf('-');
  int index2=imageUrl.lastIndexOf('.');
  try {
    imageIndex=Integer.parseInt(imageUrl.substring(index1 + 1,index2));
  }
 catch (  Exception e) {
    Log.w(""String_Node_Str"",e);
    imageIndex=-1;
  }
}",0.9933774834437086
60801,"private void init(Context context,AttributeSet attrs){
  final TypedArray a=context.obtainStyledAttributes(attrs,MAX_ATTRS);
  mMaxWidth=a.getDimensionPixelSize(0,-1);
  a.recycle();
  setOrientation(LinearLayout.VERTICAL);
  LayoutInflater.from(context).inflate(R.layout.widget_drawer_left_panel,this);
  mSuperUserPanel=(ViewGroup)getChildAt(0);
  mKKStatusBarBg=mSuperUserPanel.getChildAt(1);
  mUserPanel=(ViewGroup)mSuperUserPanel.getChildAt(2);
  mAvatar=(SimpleDraweeView)mUserPanel.getChildAt(0);
  mUsename=(TextView)mUserPanel.getChildAt(1);
  mAction=(TextView)mUserPanel.getChildAt(2);
  mDrawerListView=(DrawerListView)getChildAt(1);
  RippleSalon.addRipple(mAction,false);
  mAction.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mHelper != null) {
        if (mSignIn) {
          mHelper.onClickSignOut();
        }
 else {
          mHelper.onClickSignIn();
        }
      }
    }
  }
);
  mSuperUserPanelHeight=mSuperUserPanel.getLayoutParams().height;
  mUserPanelOriginalPaddingTop=mUserPanel.getPaddingTop();
  mDrawerListViewOriginalPaddingBottom=mDrawerListView.getPaddingBottom();
  mSignIn=Config.getSignIn();
  if (mSignIn) {
    mAvatar.setImageURI(DEFAULT_AVATAR_URI);
    mUsename.setText(Config.getDisplayName());
    mAction.setText(mContext.getString(R.string.signout));
  }
 else {
    mAvatar.setImageURI(DEFAULT_AVATAR_URI);
    mUsename.setText(""String_Node_Str"");
    mAction.setText(mContext.getString(R.string.signin));
  }
}","private void init(Context context,AttributeSet attrs){
  final TypedArray a=context.obtainStyledAttributes(attrs,MAX_ATTRS);
  mMaxWidth=a.getDimensionPixelSize(0,-1);
  a.recycle();
  setOrientation(LinearLayout.VERTICAL);
  LayoutInflater.from(context).inflate(R.layout.widget_drawer_left_panel,this);
  mSuperUserPanel=(ViewGroup)getChildAt(0);
  mKKStatusBarBg=mSuperUserPanel.getChildAt(1);
  mUserPanel=(ViewGroup)mSuperUserPanel.getChildAt(2);
  mAvatar=(SimpleDraweeView)mUserPanel.getChildAt(0);
  mUsename=(TextView)mUserPanel.getChildAt(1);
  mAction=(TextView)mUserPanel.getChildAt(2);
  mDrawerListView=(DrawerListView)getChildAt(1);
  RippleSalon.addRipple(mAction,false);
  mAction.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mHelper != null) {
        if (mSignIn) {
          mHelper.onClickSignOut();
        }
 else {
          mHelper.onClickSignIn();
        }
      }
    }
  }
);
  mSuperUserPanelHeight=mSuperUserPanel.getLayoutParams().height;
  mUserPanelOriginalPaddingTop=mUserPanel.getPaddingTop();
  mDrawerListViewOriginalPaddingBottom=mDrawerListView.getPaddingBottom();
  mSignIn=Config.getSignIn();
  if (mSignIn) {
    mAvatar.setImageURI(DEFAULT_AVATAR_URI);
    mUsename.setText(Config.getDisplayName());
    mAction.setText(getContext().getString(R.string.signout));
  }
 else {
    mAvatar.setImageURI(DEFAULT_AVATAR_URI);
    mUsename.setText(""String_Node_Str"");
    mAction.setText(getContext().getString(R.string.signin));
  }
}",0.9960681520314548
60802,"@Override public void onReceive(int id,Object obj){
  if (id == Constants.MESSENGER_ID_SIGN_IN_OR_OUT) {
    if (obj == null) {
      mSignIn=false;
      mAvatar.setImageURI(DEFAULT_AVATAR_URI);
      mUsename.setText(""String_Node_Str"");
      mAction.setText(mContext.getString(R.string.signin));
    }
 else     if (obj instanceof String) {
      mSignIn=true;
      mUsename.setText((String)obj);
      mAction.setText(mContext.getString(R.string.signout));
    }
  }
 else   if (id == Constants.MESSENGER_ID_USER_AVATAR) {
    if (mSignIn && obj instanceof Uri) {
      mAvatar.setImageURI((Uri)obj);
    }
  }
}","@Override public void onReceive(int id,Object obj){
  if (id == Constants.MESSENGER_ID_SIGN_IN_OR_OUT) {
    if (obj == null) {
      mSignIn=false;
      mAvatar.setImageURI(DEFAULT_AVATAR_URI);
      mUsename.setText(""String_Node_Str"");
      mAction.setText(getContext().getString(R.string.signin));
    }
 else     if (obj instanceof String) {
      mSignIn=true;
      mUsename.setText((String)obj);
      mAction.setText(getContext().getString(R.string.signout));
    }
  }
 else   if (id == Constants.MESSENGER_ID_USER_AVATAR) {
    if (mSignIn && obj instanceof Uri) {
      mAvatar.setImageURI((Uri)obj);
    }
  }
}",0.9903381642512076
60803,"public static Uri getResourcesDrawableUri(@IdRes int resId){
  return new Uri.Builder().scheme(UriUtil.LOCAL_RESOURCE_SCHEME).path(String.valueOf(resId)).build();
}","public static Uri getResourcesDrawableUri(@DrawableRes int resId){
  return new Uri.Builder().scheme(UriUtil.LOCAL_RESOURCE_SCHEME).path(String.valueOf(resId)).build();
}",0.9700598802395208
60804,"@Override protected void dispatchDraw(@NonNull Canvas canvas){
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
    mGroupFlags&=~CLIP_TO_PADDING_MASK;
  }
  boolean drawSelector=mOnDrawSelectorListener == null || mSelectorPosition < 0 || mSelectorPosition >= mAdapter.getItemCount() || mOnDrawSelectorListener.beforeDrawSelector(mSelectorPosition);
  final boolean drawSelectorOnTop=mDrawSelectorOnTop;
  if (drawSelector && !drawSelectorOnTop) {
    drawSelector(canvas);
  }
  super.dispatchDraw(canvas);
  if (drawSelector && drawSelectorOnTop) {
    drawSelector(canvas);
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
    mGroupFlags|=CLIP_TO_PADDING_MASK;
  }
}","@Override protected void dispatchDraw(@NonNull Canvas canvas){
  int saveCount=0;
  if (getClipToPadding()) {
    saveCount=canvas.save();
    final int scrollX=getScrollX();
    final int scrollY=getScrollY();
    canvas.clipRect(scrollX + getPaddingLeft(),scrollY + getPaddingTop(),scrollX + getRight() - getLeft() - getPaddingRight(),scrollY + getBottom() - getTop() - getPaddingBottom());
  }
  boolean drawSelector=mOnDrawSelectorListener == null || mSelectorPosition < 0 || mSelectorPosition >= mAdapter.getItemCount() || mOnDrawSelectorListener.beforeDrawSelector(mSelectorPosition);
  final boolean drawSelectorOnTop=mDrawSelectorOnTop;
  if (drawSelector && !drawSelectorOnTop) {
    drawSelector(canvas);
  }
  super.dispatchDraw(canvas);
  if (drawSelector && drawSelectorOnTop) {
    drawSelector(canvas);
  }
  if (getClipToPadding()) {
    canvas.restoreToCount(saveCount);
  }
}",0.5652857891976927
60805,"private void showImeAndSuggestionsList(boolean animation){
  InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.showSoftInput(mEditText,0);
  updateSuggestions();
  if (animation) {
    ObjectAnimator oa=ObjectAnimator.ofFloat(this,""String_Node_Str"",1f);
    oa.setDuration(ANIMATE_TIME);
    oa.addListener(new SimpleAnimatorListener(){
      @Override public void onAnimationStart(      Animator animation){
        ViewUtils.setVisibility(mList,View.VISIBLE);
        mInAnimation=true;
      }
      @Override public void onAnimationEnd(      Animator animation){
        mInAnimation=false;
      }
    }
);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
      oa.setAutoCancel(true);
    }
    oa.start();
  }
 else {
    setProgress(1f);
  }
}","private void showImeAndSuggestionsList(boolean animation){
  InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.showSoftInput(mEditText,0);
  updateSuggestions();
  if (animation) {
    ObjectAnimator oa=ObjectAnimator.ofFloat(this,""String_Node_Str"",1f);
    oa.setDuration(ANIMATE_TIME);
    oa.addListener(new SimpleAnimatorListener(){
      @Override public void onAnimationStart(      Animator animation){
        ViewUtils.setVisibility(mList,View.VISIBLE);
        mInAnimation=true;
      }
      @Override public void onAnimationEnd(      Animator animation){
        mInAnimation=false;
      }
    }
);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
      oa.setAutoCancel(true);
    }
    oa.start();
  }
 else {
    ViewUtils.setVisibility(mList,View.VISIBLE);
    setProgress(1f);
  }
}",0.9714285714285714
60806,"private void hideImeAndSuggestionsList(boolean animation){
  InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.hideSoftInputFromWindow(this.getWindowToken(),0);
  if (animation) {
    ObjectAnimator oa=ObjectAnimator.ofFloat(this,""String_Node_Str"",0f);
    oa.setDuration(ANIMATE_TIME);
    oa.addListener(new SimpleAnimatorListener(){
      @Override public void onAnimationStart(      Animator animation){
        mInAnimation=true;
      }
      @Override public void onAnimationEnd(      Animator animation){
        ViewUtils.setVisibility(mList,View.GONE);
        mInAnimation=false;
      }
    }
);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
      oa.setAutoCancel(true);
    }
    oa.start();
  }
 else {
    setProgress(0f);
  }
}","private void hideImeAndSuggestionsList(boolean animation){
  InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.hideSoftInputFromWindow(this.getWindowToken(),0);
  if (animation) {
    ObjectAnimator oa=ObjectAnimator.ofFloat(this,""String_Node_Str"",0f);
    oa.setDuration(ANIMATE_TIME);
    oa.addListener(new SimpleAnimatorListener(){
      @Override public void onAnimationStart(      Animator animation){
        mInAnimation=true;
      }
      @Override public void onAnimationEnd(      Animator animation){
        ViewUtils.setVisibility(mList,View.GONE);
        mInAnimation=false;
      }
    }
);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
      oa.setAutoCancel(true);
    }
    oa.start();
  }
 else {
    setProgress(0f);
    ViewUtils.setVisibility(mList,View.GONE);
  }
}",0.9730046948356808
60807,"public boolean put(String key,E value){
  DiskLruCache.Editor editor=null;
  OutputStream os=null;
  try {
    editor=mDiskLruCache.edit(key);
    if (editor == null) {
      return false;
    }
    os=editor.newOutputStream(0);
    if (os != null) {
      final BufferedOutputStream buffOut=new BufferedOutputStream(os,IO_BUFFER_SIZE);
      boolean result=mParent.write(buffOut,value);
      editor.commit();
      return result;
    }
 else {
      editor.abort();
      return false;
    }
  }
 catch (  IOException e) {
    Util.closeQuietly(os);
    try {
      if (editor != null) {
        editor.abort();
      }
    }
 catch (    IOException ignored) {
    }
    return false;
  }
}","public boolean put(String key,E value){
  DiskLruCache.Editor editor=null;
  OutputStream os=null;
  boolean completeEdit=false;
  try {
    editor=mDiskLruCache.edit(key);
    if (editor == null) {
      return false;
    }
    os=editor.newOutputStream(0);
    if (os != null) {
      final BufferedOutputStream buffOut=new BufferedOutputStream(os,IO_BUFFER_SIZE);
      boolean result=mParent.write(buffOut,value);
      completeEdit=true;
      editor.commit();
      return result;
    }
 else {
      completeEdit=true;
      editor.abort();
      return false;
    }
  }
 catch (  IOException e) {
    Util.closeQuietly(os);
    try {
      if (!completeEdit && editor != null) {
        editor.abort();
      }
    }
 catch (    IOException ignored) {
    }
    return false;
  }
}",0.925050641458474
60808,"@Override public boolean onKeyDown(int keyCode,@NonNull KeyEvent event){
  if (mVolumePage) {
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_DOWN:
      mGalleryView.showPreviousPage();
    return true;
case KeyEvent.KEYCODE_VOLUME_UP:
  mGalleryView.showNextPage();
return true;
default :
return super.onKeyDown(keyCode,event);
}
}
 else {
return super.onKeyDown(keyCode,event);
}
}","@Override public boolean onKeyDown(int keyCode,@NonNull KeyEvent event){
  if (mVolumePage) {
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_DOWN:
      String a=null;
    a.length();
  mGalleryView.showNextPage();
return true;
case KeyEvent.KEYCODE_VOLUME_UP:
mGalleryView.showPreviousPage();
return true;
default :
return super.onKeyDown(keyCode,event);
}
}
 else {
return super.onKeyDown(keyCode,event);
}
}",0.920754716981132
60809,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mVolumePage=Config.getVolumePage();
  Messenger.getInstance().register(Config.MESSENGER_ID_VOLUME_PAGE,this);
  mFullScreenHelper=new FullScreenHelper(this);
  mFullScreenHelper.setOnFullScreenBrokenListener(this);
  mFullScreenHelper.setFullScreen(true);
  mMaskView=(ColorView)findViewById(R.id.mask);
  mClock=findViewById(R.id.clock);
  mBattery=findViewById(R.id.battery);
  mConfigSliding=(SlidingLayout)findViewById(R.id.config_sliding);
  mCurrentPage=(TextView)mConfigSliding.findViewById(R.id.current_page);
  mPageSum=(TextView)mConfigSliding.findViewById(R.id.page_sum);
  mPageSeeker=(SeekBar)mConfigSliding.findViewById(R.id.page_seeker);
  mRefresh=(TextView)mConfigSliding.findViewById(R.id.refresh);
  mSend=(TextView)mConfigSliding.findViewById(R.id.send);
  mMoreSettings=(TextView)mConfigSliding.findViewById(R.id.more_settings);
  mReadingDirection=(Spinner)mConfigSliding.findViewById(R.id.reading_direction);
  mPageScaling=(Spinner)mConfigSliding.findViewById(R.id.page_scaling);
  mStartPosition=(Spinner)mConfigSliding.findViewById(R.id.start_position);
  mKeepScreenOn=(CheckBox)mConfigSliding.findViewById(R.id.keep_screen_on);
  mShowClock=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_clock);
  mShowBattery=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_battery);
  mCustomLightness=(CheckBox)mConfigSliding.findViewById(R.id.custom_lightness);
  mCustomLightnessValue=(SeekBar)mConfigSliding.findViewById(R.id.custom_lightness_value);
  mCustomCodec=(CheckBox)mConfigSliding.findViewById(R.id.custom_codec);
  mDecodeFormat=(Spinner)mConfigSliding.findViewById(R.id.decode_format);
  mConfigSliding.hide();
  mSendDialog=createSendDialog();
  Intent intent=getIntent();
  mGi=intent.getParcelableExtra(KEY_GALLERY_INFO);
  if (mGi == null) {
    new MaterialAlertDialog.Builder(this).setTitle(R.string.error).setMessage(R.string.ga_data_error).setPositiveButton(R.string.close).setButtonListener(new MaterialAlertDialog.OnClickListener(){
      @Override public boolean onClick(      MaterialAlertDialog dialog,      int which){
        finish();
        return true;
      }
    }
).show();
  }
 else {
    Data.getInstance().addHistory(mGi,Data.READ);
    int startIndex=intent.getIntExtra(KEY_START_INDEX,0);
    if (startIndex == -1)     startIndex=ExDownloader.readCurReadIndex(mGi.gid,mGi.title);
    mImageSet=new ImageSet(mGi.gid,mGi.token,mGi.title,startIndex);
    mGalleryView=new GalleryView(getApplicationContext(),mImageSet,startIndex);
    GLRootView glrv=(GLRootView)findViewById(R.id.gl_root_view);
    glrv.setContentPane(mGalleryView);
    mConfigSliding.setOnChildHideListener(this);
    mGalleryView.setGalleryViewListener(this);
    mPageSeeker.setOnSeekBarChangeListener(this);
    mRefresh.setOnClickListener(this);
    mSend.setOnClickListener(this);
    mMoreSettings.setOnClickListener(this);
    mReadingDirection.setOnItemSelectedListener(this);
    mPageScaling.setOnItemSelectedListener(this);
    mStartPosition.setOnItemSelectedListener(this);
    mDecodeFormat.setOnItemSelectedListener(this);
    mKeepScreenOn.setOnCheckedChangeListener(this);
    mShowClock.setOnCheckedChangeListener(this);
    mShowBattery.setOnCheckedChangeListener(this);
    mCustomLightness.setOnCheckedChangeListener(this);
    mCustomLightnessValue.setOnSeekBarChangeListener(this);
    mCustomCodec.setOnCheckedChangeListener(this);
    mKeepScreenOn=(CheckBox)mConfigSliding.findViewById(R.id.keep_screen_on);
    mShowClock=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_clock);
    mShowBattery=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_battery);
    mCustomCodec=(CheckBox)mConfigSliding.findViewById(R.id.custom_codec);
    mPageSeeker.setMax(mGalleryView.getSize() - 1);
    mPageSeeker.setProgress(startIndex);
    mCurrentPage.setText(Integer.toString(startIndex + 1));
    mPageSum.setText(Integer.toString(mGalleryView.getSize()));
    onRightToLeftChanged(mGalleryView.isRightToLeft());
    String keyGalleryFirst=""String_Node_Str"";
    if (Config.getBoolean(keyGalleryFirst,true)) {
      Config.setBoolean(keyGalleryFirst,false);
      new MaterialAlertDialog.Builder(this).setDrakTheme(true).setTitle(R.string.tip).setMessage(R.string.gallery_tip).setNegativeButton(android.R.string.cancel).setButtonListener(new MaterialAlertDialog.OnClickListener(){
        @Override public boolean onClick(        MaterialAlertDialog dialog,        int which){
          mFullScreenHelper.setFullScreen(true);
          return true;
        }
      }
).show();
    }
    updateState();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.gl_root_group);
  mVolumePage=Config.getVolumePage();
  Messenger.getInstance().register(Config.MESSENGER_ID_VOLUME_PAGE,this);
  mFullScreenHelper=new FullScreenHelper(this);
  mFullScreenHelper.setOnFullScreenBrokenListener(this);
  mFullScreenHelper.setFullScreen(true);
  mMaskView=(ColorView)findViewById(R.id.mask);
  mClock=findViewById(R.id.clock);
  mBattery=findViewById(R.id.battery);
  mConfigSliding=(SlidingLayout)findViewById(R.id.config_sliding);
  mCurrentPage=(TextView)mConfigSliding.findViewById(R.id.current_page);
  mPageSum=(TextView)mConfigSliding.findViewById(R.id.page_sum);
  mPageSeeker=(SeekBar)mConfigSliding.findViewById(R.id.page_seeker);
  mRefresh=(TextView)mConfigSliding.findViewById(R.id.refresh);
  mSend=(TextView)mConfigSliding.findViewById(R.id.send);
  mMoreSettings=(TextView)mConfigSliding.findViewById(R.id.more_settings);
  mReadingDirection=(Spinner)mConfigSliding.findViewById(R.id.reading_direction);
  mPageScaling=(Spinner)mConfigSliding.findViewById(R.id.page_scaling);
  mStartPosition=(Spinner)mConfigSliding.findViewById(R.id.start_position);
  mKeepScreenOn=(CheckBox)mConfigSliding.findViewById(R.id.keep_screen_on);
  mShowClock=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_clock);
  mShowBattery=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_battery);
  mCustomLightness=(CheckBox)mConfigSliding.findViewById(R.id.custom_lightness);
  mCustomLightnessValue=(SeekBar)mConfigSliding.findViewById(R.id.custom_lightness_value);
  mCustomCodec=(CheckBox)mConfigSliding.findViewById(R.id.custom_codec);
  mDecodeFormat=(Spinner)mConfigSliding.findViewById(R.id.decode_format);
  mConfigSliding.hide();
  mSendDialog=createSendDialog();
  Intent intent=getIntent();
  mGi=intent.getParcelableExtra(KEY_GALLERY_INFO);
  if (mGi == null) {
    new MaterialAlertDialog.Builder(this).setTitle(R.string.error).setMessage(R.string.ga_data_error).setPositiveButton(R.string.close).setButtonListener(new MaterialAlertDialog.OnClickListener(){
      @Override public boolean onClick(      MaterialAlertDialog dialog,      int which){
        finish();
        return true;
      }
    }
).show();
  }
 else {
    Data.getInstance().addHistory(mGi,Data.READ);
    int startIndex=intent.getIntExtra(KEY_START_INDEX,0);
    if (startIndex == -1)     startIndex=ExDownloader.readCurReadIndex(mGi.gid,mGi.title);
    mImageSet=new ImageSet(mGi.gid,mGi.token,mGi.title,startIndex);
    mGalleryView=new GalleryView(getApplicationContext(),mImageSet,startIndex);
    GLRootView glrv=(GLRootView)findViewById(R.id.gl_root_view);
    glrv.setContentPane(mGalleryView);
    mConfigSliding.setOnChildHideListener(this);
    mGalleryView.setGalleryViewListener(this);
    mPageSeeker.setOnSeekBarChangeListener(this);
    mRefresh.setOnClickListener(this);
    mSend.setOnClickListener(this);
    mMoreSettings.setOnClickListener(this);
    mReadingDirection.setOnItemSelectedListener(this);
    mPageScaling.setOnItemSelectedListener(this);
    mStartPosition.setOnItemSelectedListener(this);
    mDecodeFormat.setOnItemSelectedListener(this);
    mKeepScreenOn.setOnCheckedChangeListener(this);
    mShowClock.setOnCheckedChangeListener(this);
    mShowBattery.setOnCheckedChangeListener(this);
    mCustomLightness.setOnCheckedChangeListener(this);
    mCustomLightnessValue.setOnSeekBarChangeListener(this);
    mCustomCodec.setOnCheckedChangeListener(this);
    mKeepScreenOn=(CheckBox)mConfigSliding.findViewById(R.id.keep_screen_on);
    mShowClock=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_clock);
    mShowBattery=(CheckBox)mConfigSliding.findViewById(R.id.gallery_show_battery);
    mCustomCodec=(CheckBox)mConfigSliding.findViewById(R.id.custom_codec);
    mPageSeeker.setMax(mGalleryView.getSize() - 1);
    mPageSeeker.setProgress(startIndex);
    mCurrentPage.setText(Integer.toString(startIndex + 1));
    mPageSum.setText(Integer.toString(mGalleryView.getSize()));
    onRightToLeftChanged(mGalleryView.isRightToLeft());
    String keyGalleryFirst=""String_Node_Str"";
    if (Config.getBoolean(keyGalleryFirst,true)) {
      Config.setBoolean(keyGalleryFirst,false);
      new MaterialAlertDialog.Builder(this).setDrakTheme(true).setTitle(R.string.tip).setMessage(R.string.gallery_tip).setNegativeButton(android.R.string.cancel).setButtonListener(new MaterialAlertDialog.OnClickListener(){
        @Override public boolean onClick(        MaterialAlertDialog dialog,        int which){
          mFullScreenHelper.setFullScreen(true);
          return true;
        }
      }
).show();
    }
    updateState();
  }
}",0.9955338153977032
60810,"public int parser(String body,int mode){
  int re=0;
  Pattern p;
  Matcher m;
  if (body == null)   return 0;
  if (!body.contains(""String_Node_Str"")) {
    eMesg=body;
    return ERROR;
  }
  if (body.contains(OFFENSIVE_STRING)) {
    return OFFENSIVE;
  }
  if (body.contains(PINING_STRING)) {
    return PINING;
  }
  p=Pattern.compile(""String_Node_Str"");
  m=p.matcher(body);
  if (m.find()) {
    eMesg=m.group(1);
    return ERROR;
  }
  if ((mode & DETAIL) != 0) {
    p=Pattern.compile(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    m=p.matcher(body);
    if (m.find()) {
      re|=DETAIL;
      thumb=Utils.unescapeXml(m.group(1));
      title=Utils.unescapeXml(m.group(2));
      title_jpn=Utils.unescapeXml(m.group(3));
      category=EhUtils.getCategory(m.group(4));
      uploader=m.group(5);
      posted=m.group(6);
      pages=Integer.parseInt(m.group(7));
      size=m.group(8);
      resized=m.group(9);
      parent=m.group(10);
      visible=m.group(11);
      language=m.group(12);
      people=Integer.parseInt(m.group(13).replace(""String_Node_Str"",""String_Node_Str""));
      Pattern pattern=Pattern.compile(""String_Node_Str"");
      Matcher matcher=pattern.matcher(m.group(14));
      if (matcher.find())       rating=Float.parseFloat(matcher.group(1));
 else       rating=Float.NaN;
      firstPage=m.group(15);
    }
  }
  if ((mode & TAG) != 0) {
    tags=new LinkedHashMap<String,LinkedList<String>>();
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    while (m.find()) {
      re|=TAG;
      String groupName=m.group(1);
      LinkedList<String> group=getTagGroup(m.group(0));
      if (group != null) {
        tags.put(groupName,group);
      }
    }
  }
  if ((mode & PREVIEW_INFO) != 0) {
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    if (m.find()) {
      re|=PREVIEW_INFO;
      previewSum=Integer.valueOf(m.group(1).replace(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if ((mode & PREVIEW) != 0) {
    boolean isLargePreview=false;
    if (body.contains(""String_Node_Str""))     isLargePreview=true;
    if (isLargePreview) {
      previewList=new LargePreviewList();
      p=Pattern.compile(""String_Node_Str"");
      m=p.matcher(body);
      while (m.find()) {
        re|=PREVIEW;
        ((LargePreviewList)previewList).addItem(m.group(2),m.group(1));
      }
    }
 else {
      previewList=new NormalPreviewList();
      p=Pattern.compile(""String_Node_Str"");
      m=p.matcher(body);
      while (m.find()) {
        re|=PREVIEW;
        ((NormalPreviewList)previewList).addItem(m.group(3),m.group(4),""String_Node_Str"",m.group(1),m.group(2),m.group(5));
      }
    }
    if (previewList != null)     previewPerPage=previewList.size();
  }
  if ((mode & COMMENT) != 0) {
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    comments=new LinkedList<Comment>();
    while (m.find()) {
      re|=COMMENT;
      comments.add(new Comment(m.group(1),m.group(2),m.group(3)));
    }
    Collections.sort(comments,cs);
  }
  return re;
}","public int parser(String body,int mode){
  int re=0;
  Pattern p;
  Matcher m;
  if (body == null)   return 0;
  if (!body.contains(""String_Node_Str"")) {
    eMesg=body;
    return ERROR;
  }
  if (body.contains(OFFENSIVE_STRING)) {
    return OFFENSIVE;
  }
  if (body.contains(PINING_STRING)) {
    return PINING;
  }
  p=Pattern.compile(""String_Node_Str"");
  m=p.matcher(body);
  if (m.find()) {
    eMesg=m.group(1);
    return ERROR;
  }
  if ((mode & DETAIL) != 0) {
    p=Pattern.compile(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    m=p.matcher(body);
    if (m.find()) {
      re|=DETAIL;
      thumb=Utils.unescapeXml(m.group(1));
      title=Utils.unescapeXml(m.group(2));
      title_jpn=Utils.unescapeXml(m.group(3));
      category=EhUtils.getCategory(m.group(4));
      uploader=m.group(5);
      posted=m.group(6);
      parent=m.group(7);
      visible=m.group(8);
      language=Utils.unescapeXml(m.group(9)).trim();
      size=Utils.unescapeXml(m.group(10)).trim();
      resized=m.group(11);
      pages=Integer.parseInt(m.group(12).replace(""String_Node_Str"",""String_Node_Str""));
      people=Integer.parseInt(m.group(14).replace(""String_Node_Str"",""String_Node_Str""));
      Pattern pattern=Pattern.compile(""String_Node_Str"");
      Matcher matcher=pattern.matcher(m.group(15));
      if (matcher.find())       rating=Float.parseFloat(matcher.group(1));
 else       rating=Float.NaN;
      firstPage=m.group(16);
    }
  }
  if ((mode & TAG) != 0) {
    tags=new LinkedHashMap<>();
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    while (m.find()) {
      re|=TAG;
      String groupName=m.group(1);
      LinkedList<String> group=getTagGroup(m.group(0));
      if (group != null) {
        tags.put(groupName,group);
      }
    }
  }
  if ((mode & PREVIEW_INFO) != 0) {
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    if (m.find()) {
      re|=PREVIEW_INFO;
      previewSum=Integer.valueOf(m.group(1).replace(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if ((mode & PREVIEW) != 0) {
    boolean isLargePreview=false;
    if (body.contains(""String_Node_Str""))     isLargePreview=true;
    if (isLargePreview) {
      previewList=new LargePreviewList();
      p=Pattern.compile(""String_Node_Str"");
      m=p.matcher(body);
      while (m.find()) {
        re|=PREVIEW;
        ((LargePreviewList)previewList).addItem(m.group(2),m.group(1));
      }
    }
 else {
      previewList=new NormalPreviewList();
      p=Pattern.compile(""String_Node_Str"");
      m=p.matcher(body);
      while (m.find()) {
        re|=PREVIEW;
        ((NormalPreviewList)previewList).addItem(m.group(3),m.group(4),""String_Node_Str"",m.group(1),m.group(2),m.group(5));
      }
    }
    if (previewList != null)     previewPerPage=previewList.size();
  }
  if ((mode & COMMENT) != 0) {
    p=Pattern.compile(""String_Node_Str"");
    m=p.matcher(body);
    comments=new LinkedList<Comment>();
    while (m.find()) {
      re|=COMMENT;
      comments.add(new Comment(m.group(1),m.group(2),m.group(3)));
    }
    Collections.sort(comments,cs);
  }
  return re;
}",0.874837216032412
60811,"public ReplicationPeerConfigBuilder setRemoteWALDir(String dir){
  this.remoteWALDir=dir;
  return this;
}","@Override public ReplicationPeerConfigBuilder setRemoteWALDir(String dir){
  this.remoteWALDir=dir;
  return this;
}",0.954954954954955
60812,"public boolean compact(CompactionContext compaction,HStore store,ThroughputController throughputController,User user) throws IOException {
}","/** 
 * We are trying to remove / relax the region read lock for compaction. Let's see what are the potential race conditions among the operations (user scan, region split, region close and region bulk load). user scan ---> region read lock region split --> region close first --> region write lock region close --> region write lock region bulk load --> region write lock read lock is compatible with read lock. ---> no problem with user scan/read region bulk load does not cause problem for compaction (no consistency problem, store lock will help the store file accounting). They can run almost concurrently at the region level. The only remaining race condition is between the region close and compaction. So we will evaluate, below, how region close intervenes with compaction if compaction does not acquire region read lock. Here are the steps for compaction: 1. obtain list of StoreFile's 2. create StoreFileScanner's based on list from #1 3. perform compaction and save resulting files under tmp dir 4. swap in compacted files #1 is guarded by store lock. This patch does not change this --> no worse or better For #2, we obtain smallest read point (for region) across all the Scanners (for both default compactor and stripe compactor). The read points are for user scans. Region keeps the read points for all currently open user scanners. Compaction needs to know the smallest read point so that during re-write of the hfiles, it can remove the mvcc points for the cells if their mvccs are older than the smallest since they are not needed anymore. This will not conflict with compaction. For #3, it can be performed in parallel to other operations. For #4 bulk load and compaction don't conflict with each other on the region level (for multi-family atomicy). Region close and compaction are guarded pretty well by the 'writestate'. In HRegion#doClose(), we have : synchronized (writestate) { // Disable compacting and flushing by background threads for this // region. canFlush = !writestate.readOnly; writestate.writesEnabled = false; LOG.debug(""Closing "" + this + "": disabling compactions & flushes""); waitForFlushesAndCompactions(); } waitForFlushesAndCompactions() would wait for writestate.compacting to come down to 0. and in HRegion.compact() try { synchronized (writestate) { if (writestate.writesEnabled) { wasStateSet = true; ++writestate.compacting; } else { String msg = ""NOT compacting region "" + this + "". Writes disabled.""; LOG.info(msg); status.abort(msg); return false; } } Also in compactor.performCompaction(): check periodically to see if a system stop is requested if (closeCheckInterval > 0) { bytesWritten += len; if (bytesWritten > closeCheckInterval) { bytesWritten = 0; if (!store.areWritesEnabled()) { progress.cancel(); return false; } } }
 */
public boolean compact(CompactionContext compaction,HStore store,ThroughputController throughputController,User user) throws IOException {
}",0.0914136467515507
60813,"private void assertDisallow(Table table,TableAction action) throws IOException {
  try {
    action.call(table);
  }
 catch (  DoNotRetryIOException|RetriesExhaustedException e) {
    assertThat(e.getMessage(),containsString(""String_Node_Str""));
  }
}","private void assertDisallow(Table table,TableAction action) throws IOException {
  try {
    action.call(table);
    fail(""String_Node_Str"");
  }
 catch (  DoNotRetryIOException|RetriesExhaustedException e) {
    assertThat(e.getMessage(),containsString(""String_Node_Str""));
  }
}",0.9453860640301318
60814,"private static void waitUntilZnodeAvailable(int replicaId) throws Exception {
  String znode=util.getZooKeeperWatcher().znodePaths.getZNodeForReplica(replicaId);
  int i=0;
  while (i < 1000) {
    if (ZKUtil.checkExists(util.getZooKeeperWatcher(),znode) == -1) {
      Thread.sleep(100);
      i++;
    }
 else     break;
  }
  if (i == 1000)   throw new IOException(""String_Node_Str"" + replicaId + ""String_Node_Str"");
}","private static void waitUntilZnodeAvailable(int replicaId) throws Exception {
  String znode=util.getZooKeeperWatcher().getZNodePaths().getZNodeForReplica(replicaId);
  int i=0;
  while (i < 1000) {
    if (ZKUtil.checkExists(util.getZooKeeperWatcher(),znode) == -1) {
      Thread.sleep(100);
      i++;
    }
 else     break;
  }
  if (i == 1000)   throw new IOException(""String_Node_Str"" + replicaId + ""String_Node_Str"");
}",0.9893742621015348
60815,"private void testZNodeACLs() throws IOException, KeeperException, InterruptedException {
  ZKWatcher watcher=new ZKWatcher(conf,""String_Node_Str"",null);
  RecoverableZooKeeper zk=ZKUtil.connect(this.conf,watcher);
  String baseZNode=watcher.znodePaths.baseZNode;
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + baseZNode);
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  checkZnodePermsRecursive(watcher,zk,baseZNode);
  LOG.info(""String_Node_Str"");
}","private void testZNodeACLs() throws IOException, KeeperException, InterruptedException {
  ZKWatcher watcher=new ZKWatcher(conf,""String_Node_Str"",null);
  RecoverableZooKeeper zk=ZKUtil.connect(this.conf,watcher);
  String baseZNode=watcher.getZNodePaths().baseZNode;
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + baseZNode);
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  checkZnodePermsRecursive(watcher,zk,baseZNode);
  LOG.info(""String_Node_Str"");
}",0.9912536443148688
60816,"private void checkZnodePermsRecursive(ZKWatcher watcher,RecoverableZooKeeper zk,String znode) throws KeeperException, InterruptedException {
  boolean expectedWorldReadable=watcher.znodePaths.isClientReadable(znode);
  assertZnodePerms(zk,znode,expectedWorldReadable);
  try {
    List<String> children=zk.getChildren(znode,false);
    for (    String child : children) {
      checkZnodePermsRecursive(watcher,zk,ZNodePaths.joinZNode(znode,child));
    }
  }
 catch (  KeeperException ke) {
    if (ke.code() != Code.NOAUTH && ke.code() != Code.NONODE) {
      throw ke;
    }
  }
}","private void checkZnodePermsRecursive(ZKWatcher watcher,RecoverableZooKeeper zk,String znode) throws KeeperException, InterruptedException {
  boolean expectedWorldReadable=watcher.getZNodePaths().isClientReadable(znode);
  assertZnodePerms(zk,znode,expectedWorldReadable);
  try {
    List<String> children=zk.getChildren(znode,false);
    for (    String child : children) {
      checkZnodePermsRecursive(watcher,zk,ZNodePaths.joinZNode(znode,child));
    }
  }
 catch (  KeeperException ke) {
    if (ke.code() != Code.NOAUTH && ke.code() != Code.NONODE) {
      throw ke;
    }
  }
}",0.9923142613151152
60817,"private boolean refreshListIfRightPath(String path){
  if (!path.startsWith(this.watcher.znodePaths.rsZNode)) {
    return false;
  }
  return refreshOtherRegionServersList(true);
}","private boolean refreshListIfRightPath(String path){
  if (!path.startsWith(this.watcher.getZNodePaths().rsZNode)) {
    return false;
  }
  return refreshOtherRegionServersList(true);
}",0.9754768392370572
60818,"/** 
 * Get a list of all the other region servers in this cluster and set a watch
 * @return a list of server nanes
 */
private List<String> getRegisteredRegionServers(boolean watch){
  List<String> result=null;
  try {
    if (watch) {
      result=ZKUtil.listChildrenAndWatchThem(this.zookeeper,this.zookeeper.znodePaths.rsZNode);
    }
 else {
      result=ZKUtil.listChildrenNoWatch(this.zookeeper,this.zookeeper.znodePaths.rsZNode);
    }
  }
 catch (  KeeperException e) {
    this.abortable.abort(""String_Node_Str"",e);
  }
  return result;
}","/** 
 * Get a list of all the other region servers in this cluster and set a watch
 * @return a list of server nanes
 */
private List<String> getRegisteredRegionServers(boolean watch){
  List<String> result=null;
  try {
    if (watch) {
      result=ZKUtil.listChildrenAndWatchThem(this.zookeeper,this.zookeeper.getZNodePaths().rsZNode);
    }
 else {
      result=ZKUtil.listChildrenNoWatch(this.zookeeper,this.zookeeper.getZNodePaths().rsZNode);
    }
  }
 catch (  KeeperException e) {
    this.abortable.abort(""String_Node_Str"",e);
  }
  return result;
}",0.9638989169675092
60819,"protected ZKReplicationStorageBase(ZKWatcher zookeeper,Configuration conf){
  this.zookeeper=zookeeper;
  this.conf=conf;
  this.replicationZNode=ZNodePaths.joinZNode(this.zookeeper.znodePaths.baseZNode,conf.get(REPLICATION_ZNODE,REPLICATION_ZNODE_DEFAULT));
}","protected ZKReplicationStorageBase(ZKWatcher zookeeper,Configuration conf){
  this.zookeeper=zookeeper;
  this.conf=conf;
  this.replicationZNode=ZNodePaths.joinZNode(this.zookeeper.getZNodePaths().baseZNode,conf.get(REPLICATION_ZNODE,REPLICATION_ZNODE_DEFAULT));
}",0.9523809523809524
60820,"private static String initPeerClusterState(String baseZKNode) throws IOException, KeeperException {
  Configuration testConf=new Configuration(conf);
  testConf.set(HConstants.ZOOKEEPER_ZNODE_PARENT,baseZKNode);
  ZKWatcher zkw1=new ZKWatcher(testConf,""String_Node_Str"",null);
  String fakeRs=ZNodePaths.joinZNode(zkw1.znodePaths.rsZNode,""String_Node_Str"");
  ZKUtil.createWithParents(zkw1,fakeRs);
  ZKClusterId.setClusterId(zkw1,new ClusterId());
  return ZKConfig.getZooKeeperClusterKey(testConf);
}","private static String initPeerClusterState(String baseZKNode) throws IOException, KeeperException {
  Configuration testConf=new Configuration(conf);
  testConf.set(HConstants.ZOOKEEPER_ZNODE_PARENT,baseZKNode);
  ZKWatcher zkw1=new ZKWatcher(testConf,""String_Node_Str"",null);
  String fakeRs=ZNodePaths.joinZNode(zkw1.getZNodePaths().rsZNode,""String_Node_Str"");
  ZKUtil.createWithParents(zkw1,fakeRs);
  ZKClusterId.setClusterId(zkw1,new ClusterId());
  return ZKConfig.getZooKeeperClusterKey(testConf);
}",0.9910802775024776
60821,"@BeforeClass public static void setUpBeforeClass() throws Exception {
  utility=new HBaseZKTestingUtility();
  utility.startMiniZKCluster();
  conf=utility.getConfiguration();
  conf.setBoolean(HConstants.REPLICATION_BULKLOAD_ENABLE_KEY,true);
  zkw=utility.getZooKeeperWatcher();
  String replicationZNodeName=conf.get(""String_Node_Str"",""String_Node_Str"");
  replicationZNode=ZNodePaths.joinZNode(zkw.znodePaths.baseZNode,replicationZNodeName);
  KEY_ONE=initPeerClusterState(""String_Node_Str"");
  KEY_TWO=initPeerClusterState(""String_Node_Str"");
}","@BeforeClass public static void setUpBeforeClass() throws Exception {
  utility=new HBaseZKTestingUtility();
  utility.startMiniZKCluster();
  conf=utility.getConfiguration();
  conf.setBoolean(HConstants.REPLICATION_BULKLOAD_ENABLE_KEY,true);
  zkw=utility.getZooKeeperWatcher();
  String replicationZNodeName=conf.get(""String_Node_Str"",""String_Node_Str"");
  replicationZNode=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,replicationZNodeName);
  KEY_ONE=initPeerClusterState(""String_Node_Str"");
  KEY_TWO=initPeerClusterState(""String_Node_Str"");
}",0.9918404351767904
60822,"private synchronized void flushConfig(Map<String,RSGroupInfo> newGroupMap) throws IOException {
  Map<TableName,String> newTableMap;
  if (!isOnline()) {
    Map<String,RSGroupInfo> m=Maps.newHashMap(rsGroupMap);
    RSGroupInfo oldDefaultGroup=m.remove(RSGroupInfo.DEFAULT_GROUP);
    RSGroupInfo newDefaultGroup=newGroupMap.remove(RSGroupInfo.DEFAULT_GROUP);
    if (!m.equals(newGroupMap) || !oldDefaultGroup.getTables().equals(newDefaultGroup.getTables())) {
      throw new IOException(""String_Node_Str"");
    }
    newGroupMap.put(RSGroupInfo.DEFAULT_GROUP,newDefaultGroup);
    rsGroupMap=newGroupMap;
    return;
  }
  newTableMap=flushConfigTable(newGroupMap);
  resetRSGroupAndTableMaps(newGroupMap,newTableMap);
  try {
    String groupBasePath=ZNodePaths.joinZNode(watcher.znodePaths.baseZNode,rsGroupZNode);
    ZKUtil.createAndFailSilent(watcher,groupBasePath,ProtobufMagic.PB_MAGIC);
    List<ZKUtil.ZKUtilOp> zkOps=new ArrayList<>(newGroupMap.size());
    for (    String groupName : prevRSGroups) {
      if (!newGroupMap.containsKey(groupName)) {
        String znode=ZNodePaths.joinZNode(groupBasePath,groupName);
        zkOps.add(ZKUtil.ZKUtilOp.deleteNodeFailSilent(znode));
      }
    }
    for (    RSGroupInfo RSGroupInfo : newGroupMap.values()) {
      String znode=ZNodePaths.joinZNode(groupBasePath,RSGroupInfo.getName());
      RSGroupProtos.RSGroupInfo proto=RSGroupProtobufUtil.toProtoGroupInfo(RSGroupInfo);
      LOG.debug(""String_Node_Str"" + znode);
      ZKUtil.createAndFailSilent(watcher,znode);
      zkOps.add(ZKUtil.ZKUtilOp.deleteNodeFailSilent(znode));
      zkOps.add(ZKUtil.ZKUtilOp.createAndFailSilent(znode,ProtobufUtil.prependPBMagic(proto.toByteArray())));
    }
    LOG.debug(""String_Node_Str"" + zkOps.size());
    ZKUtil.multiOrSequential(watcher,zkOps,false);
  }
 catch (  KeeperException e) {
    LOG.error(""String_Node_Str"",e);
    masterServices.abort(""String_Node_Str"",e);
    throw new IOException(""String_Node_Str"",e);
  }
  updateCacheOfRSGroups(newGroupMap.keySet());
}","private synchronized void flushConfig(Map<String,RSGroupInfo> newGroupMap) throws IOException {
  Map<TableName,String> newTableMap;
  if (!isOnline()) {
    Map<String,RSGroupInfo> m=Maps.newHashMap(rsGroupMap);
    RSGroupInfo oldDefaultGroup=m.remove(RSGroupInfo.DEFAULT_GROUP);
    RSGroupInfo newDefaultGroup=newGroupMap.remove(RSGroupInfo.DEFAULT_GROUP);
    if (!m.equals(newGroupMap) || !oldDefaultGroup.getTables().equals(newDefaultGroup.getTables())) {
      throw new IOException(""String_Node_Str"");
    }
    newGroupMap.put(RSGroupInfo.DEFAULT_GROUP,newDefaultGroup);
    rsGroupMap=newGroupMap;
    return;
  }
  newTableMap=flushConfigTable(newGroupMap);
  resetRSGroupAndTableMaps(newGroupMap,newTableMap);
  try {
    String groupBasePath=ZNodePaths.joinZNode(watcher.getZNodePaths().baseZNode,rsGroupZNode);
    ZKUtil.createAndFailSilent(watcher,groupBasePath,ProtobufMagic.PB_MAGIC);
    List<ZKUtil.ZKUtilOp> zkOps=new ArrayList<>(newGroupMap.size());
    for (    String groupName : prevRSGroups) {
      if (!newGroupMap.containsKey(groupName)) {
        String znode=ZNodePaths.joinZNode(groupBasePath,groupName);
        zkOps.add(ZKUtil.ZKUtilOp.deleteNodeFailSilent(znode));
      }
    }
    for (    RSGroupInfo RSGroupInfo : newGroupMap.values()) {
      String znode=ZNodePaths.joinZNode(groupBasePath,RSGroupInfo.getName());
      RSGroupProtos.RSGroupInfo proto=RSGroupProtobufUtil.toProtoGroupInfo(RSGroupInfo);
      LOG.debug(""String_Node_Str"" + znode);
      ZKUtil.createAndFailSilent(watcher,znode);
      zkOps.add(ZKUtil.ZKUtilOp.deleteNodeFailSilent(znode));
      zkOps.add(ZKUtil.ZKUtilOp.createAndFailSilent(znode,ProtobufUtil.prependPBMagic(proto.toByteArray())));
    }
    LOG.debug(""String_Node_Str"" + zkOps.size());
    ZKUtil.multiOrSequential(watcher,zkOps,false);
  }
 catch (  KeeperException e) {
    LOG.error(""String_Node_Str"",e);
    masterServices.abort(""String_Node_Str"",e);
    throw new IOException(""String_Node_Str"",e);
  }
  updateCacheOfRSGroups(newGroupMap.keySet());
}",0.9977859778597786
60823,"List<RSGroupInfo> retrieveGroupListFromZookeeper() throws IOException {
  String groupBasePath=ZNodePaths.joinZNode(watcher.znodePaths.baseZNode,rsGroupZNode);
  List<RSGroupInfo> RSGroupInfoList=Lists.newArrayList();
  try {
    if (ZKUtil.checkExists(watcher,groupBasePath) != -1) {
      List<String> children=ZKUtil.listChildrenAndWatchForNewChildren(watcher,groupBasePath);
      if (children == null) {
        return RSGroupInfoList;
      }
      for (      String znode : children) {
        byte[] data=ZKUtil.getData(watcher,ZNodePaths.joinZNode(groupBasePath,znode));
        if (data.length > 0) {
          ProtobufUtil.expectPBMagicPrefix(data);
          ByteArrayInputStream bis=new ByteArrayInputStream(data,ProtobufUtil.lengthOfPBMagic(),data.length);
          RSGroupInfoList.add(RSGroupProtobufUtil.toGroupInfo(RSGroupProtos.RSGroupInfo.parseFrom(bis)));
        }
      }
      LOG.debug(""String_Node_Str"" + RSGroupInfoList.size());
    }
  }
 catch (  KeeperException|DeserializationException|InterruptedException e) {
    throw new IOException(""String_Node_Str"",e);
  }
  return RSGroupInfoList;
}","List<RSGroupInfo> retrieveGroupListFromZookeeper() throws IOException {
  String groupBasePath=ZNodePaths.joinZNode(watcher.getZNodePaths().baseZNode,rsGroupZNode);
  List<RSGroupInfo> RSGroupInfoList=Lists.newArrayList();
  try {
    if (ZKUtil.checkExists(watcher,groupBasePath) != -1) {
      List<String> children=ZKUtil.listChildrenAndWatchForNewChildren(watcher,groupBasePath);
      if (children == null) {
        return RSGroupInfoList;
      }
      for (      String znode : children) {
        byte[] data=ZKUtil.getData(watcher,ZNodePaths.joinZNode(groupBasePath,znode));
        if (data.length > 0) {
          ProtobufUtil.expectPBMagicPrefix(data);
          ByteArrayInputStream bis=new ByteArrayInputStream(data,ProtobufUtil.lengthOfPBMagic(),data.length);
          RSGroupInfoList.add(RSGroupProtobufUtil.toGroupInfo(RSGroupProtos.RSGroupInfo.parseFrom(bis)));
        }
      }
      LOG.debug(""String_Node_Str"" + RSGroupInfoList.size());
    }
  }
 catch (  KeeperException|DeserializationException|InterruptedException e) {
    throw new IOException(""String_Node_Str"",e);
  }
  return RSGroupInfoList;
}",0.9888839484215208
60824,"private List<ServerName> getOnlineRS() throws IOException {
  if (masterServices != null) {
    return masterServices.getServerManager().getOnlineServersList();
  }
  LOG.debug(""String_Node_Str"");
  List<ServerName> servers=new LinkedList<>();
  try {
    for (    String el : ZKUtil.listChildrenNoWatch(watcher,watcher.znodePaths.rsZNode)) {
      servers.add(ServerName.parseServerName(el));
    }
  }
 catch (  KeeperException e) {
    throw new IOException(""String_Node_Str"",e);
  }
  return servers;
}","private List<ServerName> getOnlineRS() throws IOException {
  if (masterServices != null) {
    return masterServices.getServerManager().getOnlineServersList();
  }
  LOG.debug(""String_Node_Str"");
  List<ServerName> servers=new LinkedList<>();
  try {
    for (    String el : ZKUtil.listChildrenNoWatch(watcher,watcher.getZNodePaths().rsZNode)) {
      servers.add(ServerName.parseServerName(el));
    }
  }
 catch (  KeeperException e) {
    throw new IOException(""String_Node_Str"",e);
  }
  return servers;
}",0.991150442477876
60825,"public void verify() throws IOException {
  Map<String,RSGroupInfo> groupMap=Maps.newHashMap();
  Set<RSGroupInfo> zList=Sets.newHashSet();
  for (  Result result : table.getScanner(new Scan())) {
    RSGroupProtos.RSGroupInfo proto=RSGroupProtos.RSGroupInfo.parseFrom(result.getValue(RSGroupInfoManager.META_FAMILY_BYTES,RSGroupInfoManager.META_QUALIFIER_BYTES));
    groupMap.put(proto.getName(),RSGroupProtobufUtil.toGroupInfo(proto));
  }
  Assert.assertEquals(Sets.newHashSet(groupMap.values()),Sets.newHashSet(wrapped.listRSGroups()));
  try {
    String groupBasePath=ZNodePaths.joinZNode(zkw.znodePaths.baseZNode,""String_Node_Str"");
    for (    String znode : ZKUtil.listChildrenNoWatch(zkw,groupBasePath)) {
      byte[] data=ZKUtil.getData(zkw,ZNodePaths.joinZNode(groupBasePath,znode));
      if (data.length > 0) {
        ProtobufUtil.expectPBMagicPrefix(data);
        ByteArrayInputStream bis=new ByteArrayInputStream(data,ProtobufUtil.lengthOfPBMagic(),data.length);
        zList.add(RSGroupProtobufUtil.toGroupInfo(RSGroupProtos.RSGroupInfo.parseFrom(bis)));
      }
    }
    Assert.assertEquals(zList.size(),groupMap.size());
    for (    RSGroupInfo RSGroupInfo : zList) {
      Assert.assertTrue(groupMap.get(RSGroupInfo.getName()).equals(RSGroupInfo));
    }
  }
 catch (  KeeperException e) {
    throw new IOException(""String_Node_Str"",e);
  }
catch (  DeserializationException e) {
    throw new IOException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    throw new IOException(""String_Node_Str"",e);
  }
}","public void verify() throws IOException {
  Map<String,RSGroupInfo> groupMap=Maps.newHashMap();
  Set<RSGroupInfo> zList=Sets.newHashSet();
  for (  Result result : table.getScanner(new Scan())) {
    RSGroupProtos.RSGroupInfo proto=RSGroupProtos.RSGroupInfo.parseFrom(result.getValue(RSGroupInfoManager.META_FAMILY_BYTES,RSGroupInfoManager.META_QUALIFIER_BYTES));
    groupMap.put(proto.getName(),RSGroupProtobufUtil.toGroupInfo(proto));
  }
  Assert.assertEquals(Sets.newHashSet(groupMap.values()),Sets.newHashSet(wrapped.listRSGroups()));
  try {
    String groupBasePath=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,""String_Node_Str"");
    for (    String znode : ZKUtil.listChildrenNoWatch(zkw,groupBasePath)) {
      byte[] data=ZKUtil.getData(zkw,ZNodePaths.joinZNode(groupBasePath,znode));
      if (data.length > 0) {
        ProtobufUtil.expectPBMagicPrefix(data);
        ByteArrayInputStream bis=new ByteArrayInputStream(data,ProtobufUtil.lengthOfPBMagic(),data.length);
        zList.add(RSGroupProtobufUtil.toGroupInfo(RSGroupProtos.RSGroupInfo.parseFrom(bis)));
      }
    }
    Assert.assertEquals(zList.size(),groupMap.size());
    for (    RSGroupInfo RSGroupInfo : zList) {
      Assert.assertTrue(groupMap.get(RSGroupInfo.getName()).equals(RSGroupInfo));
    }
  }
 catch (  KeeperException e) {
    throw new IOException(""String_Node_Str"",e);
  }
catch (  DeserializationException e) {
    throw new IOException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    throw new IOException(""String_Node_Str"",e);
  }
}",0.9970995810505962
60826,"public ZKNamespaceManager(ZKWatcher zkw) throws IOException {
  super(zkw);
  nsZNode=zkw.znodePaths.namespaceZNode;
  cache=new ConcurrentSkipListMap<>();
}","public ZKNamespaceManager(ZKWatcher zkw) throws IOException {
  super(zkw);
  nsZNode=zkw.getZNodePaths().namespaceZNode;
  cache=new ConcurrentSkipListMap<>();
}",0.9717868338557992
60827,"/** 
 * Delete the master znode if its content (ServerName string) is the same as the one in the znode file. (env: HBASE_ZNODE_FILE). I case of master-rs colloaction we extract ServerName string from rsZnode path.(HBASE-14861)
 * @return true on successful deletion, false otherwise.
 */
public static boolean clear(Configuration conf){
  Configuration tempConf=new Configuration(conf);
  tempConf.setInt(""String_Node_Str"",0);
  ZKWatcher zkw;
  try {
    zkw=new ZKWatcher(tempConf,""String_Node_Str"",new Abortable(){
      @Override public void abort(      String why,      Throwable e){
      }
      @Override public boolean isAborted(){
        return false;
      }
    }
);
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
  String znodeFileContent;
  try {
    znodeFileContent=ZNodeClearer.readMyEphemeralNodeOnDisk();
    if (ZNodeClearer.tablesOnMaster(conf)) {
      ZKUtil.deleteNodeFailSilent(zkw,ZNodePaths.joinZNode(zkw.znodePaths.rsZNode,znodeFileContent));
      return MasterAddressTracker.deleteIfEquals(zkw,ZNodeClearer.parseMasterServerName(znodeFileContent));
    }
 else {
      return MasterAddressTracker.deleteIfEquals(zkw,znodeFileContent);
    }
  }
 catch (  FileNotFoundException fnfe) {
    LOG.warn(""String_Node_Str"",fnfe);
    return true;
  }
catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
 finally {
    zkw.close();
  }
}","/** 
 * Delete the master znode if its content (ServerName string) is the same as the one in the znode file. (env: HBASE_ZNODE_FILE). I case of master-rs colloaction we extract ServerName string from rsZnode path.(HBASE-14861)
 * @return true on successful deletion, false otherwise.
 */
public static boolean clear(Configuration conf){
  Configuration tempConf=new Configuration(conf);
  tempConf.setInt(""String_Node_Str"",0);
  ZKWatcher zkw;
  try {
    zkw=new ZKWatcher(tempConf,""String_Node_Str"",new Abortable(){
      @Override public void abort(      String why,      Throwable e){
      }
      @Override public boolean isAborted(){
        return false;
      }
    }
);
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
  String znodeFileContent;
  try {
    znodeFileContent=ZNodeClearer.readMyEphemeralNodeOnDisk();
    if (ZNodeClearer.tablesOnMaster(conf)) {
      ZKUtil.deleteNodeFailSilent(zkw,ZNodePaths.joinZNode(zkw.getZNodePaths().rsZNode,znodeFileContent));
      return MasterAddressTracker.deleteIfEquals(zkw,ZNodeClearer.parseMasterServerName(znodeFileContent));
    }
 else {
      return MasterAddressTracker.deleteIfEquals(zkw,znodeFileContent);
    }
  }
 catch (  FileNotFoundException fnfe) {
    LOG.warn(""String_Node_Str"",fnfe);
    return true;
  }
catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"",e);
    return false;
  }
 finally {
    zkw.close();
  }
}",0.9970423923759448
60828,"/** 
 * @param conf conf to read for the base archive node
 * @param zooKeeper zookeeper to used for building the full path
 * @return get the znode for long-term archival of a table for
 */
public static String getArchiveZNode(Configuration conf,ZKWatcher zooKeeper){
  return ZNodePaths.joinZNode(zooKeeper.znodePaths.baseZNode,conf.get(ZOOKEEPER_ZNODE_HFILE_ARCHIVE_KEY,TableHFileArchiveTracker.HFILE_ARCHIVE_ZNODE_PARENT));
}","/** 
 * @param conf conf to read for the base archive node
 * @param zooKeeper zookeeper to used for building the full path
 * @return get the znode for long-term archival of a table for
 */
public static String getArchiveZNode(Configuration conf,ZKWatcher zooKeeper){
  return ZNodePaths.joinZNode(zooKeeper.getZNodePaths().baseZNode,conf.get(ZOOKEEPER_ZNODE_HFILE_ARCHIVE_KEY,TableHFileArchiveTracker.HFILE_ARCHIVE_ZNODE_PARENT));
}",0.9895712630359212
60829,"@Override public int remainingTasksInCoordination(){
  int count=0;
  try {
    List<String> tasks=ZKUtil.listChildrenNoWatch(watcher,watcher.znodePaths.splitLogZNode);
    if (tasks != null) {
      int listSize=tasks.size();
      for (int i=0; i < listSize; i++) {
        if (!ZKSplitLog.isRescanNode(tasks.get(i))) {
          count++;
        }
      }
    }
  }
 catch (  KeeperException ke) {
    LOG.warn(""String_Node_Str"",ke);
    count=-1;
  }
  return count;
}","@Override public int remainingTasksInCoordination(){
  int count=0;
  try {
    List<String> tasks=ZKUtil.listChildrenNoWatch(watcher,watcher.getZNodePaths().splitLogZNode);
    if (tasks != null) {
      int listSize=tasks.size();
      for (int i=0; i < listSize; i++) {
        if (!ZKSplitLog.isRescanNode(tasks.get(i))) {
          count++;
        }
      }
    }
  }
 catch (  KeeperException ke) {
    LOG.warn(""String_Node_Str"",ke);
    count=-1;
  }
  return count;
}",0.9905163329820864
60830,"private void lookForOrphans(){
  List<String> orphans;
  try {
    orphans=ZKUtil.listChildrenNoWatch(this.watcher,this.watcher.znodePaths.splitLogZNode);
    if (orphans == null) {
      LOG.warn(""String_Node_Str"" + this.watcher.znodePaths.splitLogZNode);
      return;
    }
  }
 catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"" + this.watcher.znodePaths.splitLogZNode + ""String_Node_Str""+ StringUtils.stringifyException(e));
    return;
  }
  int rescan_nodes=0;
  int listSize=orphans.size();
  for (int i=0; i < listSize; i++) {
    String path=orphans.get(i);
    String nodepath=ZNodePaths.joinZNode(watcher.znodePaths.splitLogZNode,path);
    if (ZKSplitLog.isRescanNode(watcher,nodepath)) {
      rescan_nodes++;
      LOG.debug(""String_Node_Str"" + path);
    }
 else {
      LOG.info(""String_Node_Str"" + path);
    }
    getDataSetWatch(nodepath,zkretries);
  }
  LOG.info(""String_Node_Str"" + (orphans.size() - rescan_nodes) + ""String_Node_Str""+ rescan_nodes+ ""String_Node_Str"");
}","private void lookForOrphans(){
  List<String> orphans;
  try {
    orphans=ZKUtil.listChildrenNoWatch(this.watcher,this.watcher.getZNodePaths().splitLogZNode);
    if (orphans == null) {
      LOG.warn(""String_Node_Str"" + this.watcher.getZNodePaths().splitLogZNode);
      return;
    }
  }
 catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"" + this.watcher.getZNodePaths().splitLogZNode + ""String_Node_Str""+ StringUtils.stringifyException(e));
    return;
  }
  int rescan_nodes=0;
  int listSize=orphans.size();
  for (int i=0; i < listSize; i++) {
    String path=orphans.get(i);
    String nodepath=ZNodePaths.joinZNode(watcher.getZNodePaths().splitLogZNode,path);
    if (ZKSplitLog.isRescanNode(watcher,nodepath)) {
      rescan_nodes++;
      LOG.debug(""String_Node_Str"" + path);
    }
 else {
      LOG.info(""String_Node_Str"" + path);
    }
    getDataSetWatch(nodepath,zkretries);
  }
  LOG.info(""String_Node_Str"" + (orphans.size() - rescan_nodes) + ""String_Node_Str""+ rescan_nodes+ ""String_Node_Str"");
}",0.9822309970384996
60831,"/** 
 * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This policy puts an upper-limit on the number of simultaneous log splitting that could be happening in a cluster. <p> Synchronization using <code>taskReadySeq</code> ensures that it will try to grab every task that has been put up
 * @throws InterruptedException
 */
@Override public void taskLoop() throws InterruptedException {
  while (!shouldStop) {
    int seq_start=taskReadySeq.get();
    List<String> paths;
    paths=getTaskList();
    if (paths == null) {
      LOG.warn(""String_Node_Str"" + watcher.znodePaths.splitLogZNode + ""String_Node_Str"");
      return;
    }
    Collections.shuffle(paths);
    int offset=0;
    for (int i=0; i < paths.size(); i++) {
      if (AbstractFSWALProvider.isMetaFile(paths.get(i))) {
        offset=i;
        break;
      }
    }
    int numTasks=paths.size();
    int expectedTasksPerRS=getNumExpectedTasksPerRS(numTasks);
    boolean taskGrabbed=false;
    for (int i=0; i < numTasks; i++) {
      while (!shouldStop) {
        if (this.areSplittersAvailable(expectedTasksPerRS)) {
          LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str"");
          int idx=(i + offset) % paths.size();
          taskGrabbed|=grabTask(ZNodePaths.joinZNode(watcher.znodePaths.splitLogZNode,paths.get(idx)));
          break;
        }
 else {
          LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str""+ this.tasksInProgress.get()+ ""String_Node_Str"");
          Thread.sleep(100);
        }
      }
      if (shouldStop) {
        return;
      }
    }
    if (!taskGrabbed && !shouldStop) {
      Thread.sleep(1000);
    }
    SplitLogCounters.tot_wkr_task_grabing.increment();
synchronized (taskReadySeq) {
      while (seq_start == taskReadySeq.get()) {
        taskReadySeq.wait(checkInterval);
      }
    }
  }
}","/** 
 * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This policy puts an upper-limit on the number of simultaneous log splitting that could be happening in a cluster. <p> Synchronization using <code>taskReadySeq</code> ensures that it will try to grab every task that has been put up
 * @throws InterruptedException
 */
@Override public void taskLoop() throws InterruptedException {
  while (!shouldStop) {
    int seq_start=taskReadySeq.get();
    List<String> paths;
    paths=getTaskList();
    if (paths == null) {
      LOG.warn(""String_Node_Str"" + watcher.getZNodePaths().splitLogZNode + ""String_Node_Str"");
      return;
    }
    Collections.shuffle(paths);
    int offset=0;
    for (int i=0; i < paths.size(); i++) {
      if (AbstractFSWALProvider.isMetaFile(paths.get(i))) {
        offset=i;
        break;
      }
    }
    int numTasks=paths.size();
    int expectedTasksPerRS=getNumExpectedTasksPerRS(numTasks);
    boolean taskGrabbed=false;
    for (int i=0; i < numTasks; i++) {
      while (!shouldStop) {
        if (this.areSplittersAvailable(expectedTasksPerRS)) {
          LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str"");
          int idx=(i + offset) % paths.size();
          taskGrabbed|=grabTask(ZNodePaths.joinZNode(watcher.getZNodePaths().splitLogZNode,paths.get(idx)));
          break;
        }
 else {
          LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str""+ this.tasksInProgress.get()+ ""String_Node_Str"");
          Thread.sleep(100);
        }
      }
      if (shouldStop) {
        return;
      }
    }
    if (!taskGrabbed && !shouldStop) {
      Thread.sleep(1000);
    }
    SplitLogCounters.tot_wkr_task_grabing.increment();
synchronized (taskReadySeq) {
      while (seq_start == taskReadySeq.get()) {
        taskReadySeq.wait(checkInterval);
      }
    }
  }
}",0.9952656496580748
60832,"@Override public boolean isReady() throws InterruptedException {
  int result=-1;
  try {
    result=ZKUtil.checkExists(watcher,watcher.znodePaths.splitLogZNode);
  }
 catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"" + watcher.znodePaths.splitLogZNode + ""String_Node_Str"",e);
  }
  if (result == -1) {
    LOG.info(watcher.znodePaths.splitLogZNode + ""String_Node_Str"");
    Thread.sleep(1000);
  }
  return (result != -1);
}","@Override public boolean isReady() throws InterruptedException {
  int result=-1;
  try {
    result=ZKUtil.checkExists(watcher,watcher.getZNodePaths().splitLogZNode);
  }
 catch (  KeeperException e) {
    LOG.warn(""String_Node_Str"" + watcher.getZNodePaths().splitLogZNode + ""String_Node_Str"",e);
  }
  if (result == -1) {
    LOG.info(watcher.getZNodePaths().splitLogZNode + ""String_Node_Str"");
    Thread.sleep(1000);
  }
  return (result != -1);
}",0.9695603156708004
60833,"private List<String> getTaskList() throws InterruptedException {
  List<String> childrenPaths=null;
  long sleepTime=1000;
  while (!shouldStop) {
    try {
      childrenPaths=ZKUtil.listChildrenAndWatchForNewChildren(watcher,watcher.znodePaths.splitLogZNode);
      if (childrenPaths != null) {
        return childrenPaths;
      }
    }
 catch (    KeeperException e) {
      LOG.warn(""String_Node_Str"" + watcher.znodePaths.splitLogZNode,e);
    }
    LOG.debug(""String_Node_Str"" + watcher.znodePaths.splitLogZNode + ""String_Node_Str""+ sleepTime+ ""String_Node_Str"");
    Thread.sleep(sleepTime);
  }
  return childrenPaths;
}","private List<String> getTaskList() throws InterruptedException {
  List<String> childrenPaths=null;
  long sleepTime=1000;
  while (!shouldStop) {
    try {
      childrenPaths=ZKUtil.listChildrenAndWatchForNewChildren(watcher,watcher.getZNodePaths().splitLogZNode);
      if (childrenPaths != null) {
        return childrenPaths;
      }
    }
 catch (    KeeperException e) {
      LOG.warn(""String_Node_Str"" + watcher.getZNodePaths().splitLogZNode,e);
    }
    LOG.debug(""String_Node_Str"" + watcher.getZNodePaths().splitLogZNode + ""String_Node_Str""+ sleepTime+ ""String_Node_Str"");
    Thread.sleep(sleepTime);
  }
  return childrenPaths;
}",0.9269442262372348
60834,"/** 
 * Override handler from   {@link ZKListener}
 */
@Override public void nodeChildrenChanged(String path){
  if (path.equals(watcher.znodePaths.splitLogZNode)) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + path);
    }
synchronized (taskReadySeq) {
      this.taskReadySeq.incrementAndGet();
      taskReadySeq.notify();
    }
  }
}","/** 
 * Override handler from   {@link ZKListener}
 */
@Override public void nodeChildrenChanged(String path){
  if (path.equals(watcher.getZNodePaths().splitLogZNode)) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + path);
    }
synchronized (taskReadySeq) {
      this.taskReadySeq.incrementAndGet();
      taskReadySeq.notify();
    }
  }
}",0.9875862068965516
60835,"/** 
 * This function calculates how many splitters this RS should create based on expected average tasks per RS and the hard limit upper bound(maxConcurrentTasks) set by configuration. <br> At any given time, a RS allows spawn MIN(Expected Tasks/RS, Hard Upper Bound)
 * @param numTasks total number of split tasks available
 * @return number of tasks this RS can grab
 */
private int getNumExpectedTasksPerRS(int numTasks){
  int availableRSs=1;
  try {
    List<String> regionServers=ZKUtil.listChildrenNoWatch(watcher,watcher.znodePaths.rsZNode);
    availableRSs=Math.max(availableRSs,(regionServers == null) ? 0 : regionServers.size());
  }
 catch (  KeeperException e) {
    LOG.debug(""String_Node_Str"",e);
  }
  int expectedTasksPerRS=(numTasks / availableRSs) + ((numTasks % availableRSs == 0) ? 0 : 1);
  return Math.max(1,expectedTasksPerRS);
}","/** 
 * This function calculates how many splitters this RS should create based on expected average tasks per RS and the hard limit upper bound(maxConcurrentTasks) set by configuration. <br> At any given time, a RS allows spawn MIN(Expected Tasks/RS, Hard Upper Bound)
 * @param numTasks total number of split tasks available
 * @return number of tasks this RS can grab
 */
private int getNumExpectedTasksPerRS(int numTasks){
  int availableRSs=1;
  try {
    List<String> regionServers=ZKUtil.listChildrenNoWatch(watcher,watcher.getZNodePaths().rsZNode);
    availableRSs=Math.max(availableRSs,(regionServers == null) ? 0 : regionServers.size());
  }
 catch (  KeeperException e) {
    LOG.debug(""String_Node_Str"",e);
  }
  int expectedTasksPerRS=(numTasks / availableRSs) + ((numTasks % availableRSs == 0) ? 0 : 1);
  return Math.max(1,expectedTasksPerRS);
}",0.9947521865889212
60836,"public void stop(){
  try {
synchronized (clusterHasActiveMaster) {
      clusterHasActiveMaster.notifyAll();
    }
    ServerName activeMaster=null;
    try {
      activeMaster=MasterAddressTracker.getMasterAddress(this.watcher);
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"" + e.toString());
    }
    if (activeMaster != null && activeMaster.equals(this.sn)) {
      ZKUtil.deleteNode(watcher,watcher.znodePaths.masterAddressZNode);
      ZNodeClearer.deleteMyEphemeralNodeOnDisk();
    }
  }
 catch (  KeeperException e) {
    LOG.debug(this.watcher.prefix(""String_Node_Str"" + e.getMessage()));
  }
}","public void stop(){
  try {
synchronized (clusterHasActiveMaster) {
      clusterHasActiveMaster.notifyAll();
    }
    ServerName activeMaster=null;
    try {
      activeMaster=MasterAddressTracker.getMasterAddress(this.watcher);
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"" + e.toString());
    }
    if (activeMaster != null && activeMaster.equals(this.sn)) {
      ZKUtil.deleteNode(watcher,watcher.getZNodePaths().masterAddressZNode);
      ZNodeClearer.deleteMyEphemeralNodeOnDisk();
    }
  }
 catch (  KeeperException e) {
    LOG.debug(this.watcher.prefix(""String_Node_Str"" + e.getMessage()));
  }
}",0.9928514694201748
60837,"@Override public void nodeDeleted(String path){
  if (path.equals(watcher.znodePaths.clusterStateZNode) && !master.isStopped()) {
    clusterShutDown.set(true);
  }
  handle(path);
}","@Override public void nodeDeleted(String path){
  if (path.equals(watcher.getZNodePaths().clusterStateZNode) && !master.isStopped()) {
    clusterShutDown.set(true);
  }
  handle(path);
}",0.975609756097561
60838,"/** 
 * Handle a change in the master node.  Doesn't matter whether this was called from a nodeCreated or nodeDeleted event because there are no guarantees that the current state of the master node matches the event at the time of our next ZK request. <p>Uses the watchAndCheckExists method which watches the master address node regardless of whether it exists or not.  If it does exist (there is an active master), it returns true.  Otherwise it returns false. <p>A watcher is set which guarantees that this method will get called again if there is another change in the master node.
 */
private void handleMasterNodeChange(){
  try {
synchronized (clusterHasActiveMaster) {
      if (ZKUtil.watchAndCheckExists(watcher,watcher.znodePaths.masterAddressZNode)) {
        LOG.trace(""String_Node_Str"");
        clusterHasActiveMaster.set(true);
      }
 else {
        LOG.debug(""String_Node_Str"");
        clusterHasActiveMaster.set(false);
        clusterHasActiveMaster.notifyAll();
      }
    }
  }
 catch (  KeeperException ke) {
    master.abort(""String_Node_Str"",ke);
  }
}","/** 
 * Handle a change in the master node.  Doesn't matter whether this was called from a nodeCreated or nodeDeleted event because there are no guarantees that the current state of the master node matches the event at the time of our next ZK request. <p>Uses the watchAndCheckExists method which watches the master address node regardless of whether it exists or not.  If it does exist (there is an active master), it returns true.  Otherwise it returns false. <p>A watcher is set which guarantees that this method will get called again if there is another change in the master node.
 */
private void handleMasterNodeChange(){
  try {
synchronized (clusterHasActiveMaster) {
      if (ZKUtil.watchAndCheckExists(watcher,watcher.getZNodePaths().masterAddressZNode)) {
        LOG.trace(""String_Node_Str"");
        clusterHasActiveMaster.set(true);
      }
 else {
        LOG.debug(""String_Node_Str"");
        clusterHasActiveMaster.set(false);
        clusterHasActiveMaster.notifyAll();
      }
    }
  }
 catch (  KeeperException ke) {
    master.abort(""String_Node_Str"",ke);
  }
}",0.9958391123439668
60839,"void handle(final String path){
  if (path.equals(watcher.znodePaths.masterAddressZNode) && !master.isStopped()) {
    handleMasterNodeChange();
  }
}","void handle(final String path){
  if (path.equals(watcher.getZNodePaths().masterAddressZNode) && !master.isStopped()) {
    handleMasterNodeChange();
  }
}",0.9704918032786886
60840,"/** 
 * Block until becoming the active master. Method blocks until there is not another active master and our attempt to become the new active master is successful. This also makes sure that we are watching the master znode so will be notified if another master dies.
 * @param checkInterval the interval to check if the master is stopped
 * @param startupStatus the monitor status to track the progress
 * @return True if no issue becoming active master else false if anothermaster was running or if some other problem (zookeeper, stop flag has been set on this Master)
 */
boolean blockUntilBecomingActiveMaster(int checkInterval,MonitoredTask startupStatus){
  String backupZNode=ZNodePaths.joinZNode(this.watcher.znodePaths.backupMasterAddressesZNode,this.sn.toString());
  while (!(master.isAborted() || master.isStopped())) {
    startupStatus.setStatus(""String_Node_Str"");
    try {
      if (MasterAddressTracker.setMasterAddress(this.watcher,this.watcher.znodePaths.masterAddressZNode,this.sn,infoPort)) {
        if (ZKUtil.checkExists(this.watcher,backupZNode) != -1) {
          LOG.info(""String_Node_Str"" + backupZNode + ""String_Node_Str"");
          ZKUtil.deleteNodeFailSilent(this.watcher,backupZNode);
        }
        ZNodeClearer.writeMyEphemeralNodeOnDisk(this.sn.toString());
        startupStatus.setStatus(""String_Node_Str"");
        this.clusterHasActiveMaster.set(true);
        LOG.info(""String_Node_Str"" + this.sn);
        return true;
      }
      this.clusterHasActiveMaster.set(true);
      String msg;
      byte[] bytes=ZKUtil.getDataAndWatch(this.watcher,this.watcher.znodePaths.masterAddressZNode);
      if (bytes == null) {
        msg=(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        ServerName currentMaster;
        try {
          currentMaster=ProtobufUtil.parseServerNameFrom(bytes);
        }
 catch (        DeserializationException e) {
          LOG.warn(""String_Node_Str"",e);
          continue;
        }
        if (ServerName.isSameAddress(currentMaster,this.sn)) {
          msg=(""String_Node_Str"" + currentMaster + ""String_Node_Str"");
          ZKUtil.deleteNode(this.watcher,this.watcher.znodePaths.masterAddressZNode);
          ZNodeClearer.deleteMyEphemeralNodeOnDisk();
        }
 else {
          msg=""String_Node_Str"" + currentMaster + ""String_Node_Str"";
        }
      }
      LOG.info(msg);
      startupStatus.setStatus(msg);
    }
 catch (    KeeperException ke) {
      master.abort(""String_Node_Str"",ke);
      return false;
    }
synchronized (this.clusterHasActiveMaster) {
      while (clusterHasActiveMaster.get() && !master.isStopped()) {
        try {
          clusterHasActiveMaster.wait(checkInterval);
        }
 catch (        InterruptedException e) {
          LOG.debug(""String_Node_Str"",e);
        }
      }
      if (clusterShutDown.get()) {
        this.master.stop(""String_Node_Str"");
      }
    }
  }
  return false;
}","/** 
 * Block until becoming the active master. Method blocks until there is not another active master and our attempt to become the new active master is successful. This also makes sure that we are watching the master znode so will be notified if another master dies.
 * @param checkInterval the interval to check if the master is stopped
 * @param startupStatus the monitor status to track the progress
 * @return True if no issue becoming active master else false if anothermaster was running or if some other problem (zookeeper, stop flag has been set on this Master)
 */
boolean blockUntilBecomingActiveMaster(int checkInterval,MonitoredTask startupStatus){
  String backupZNode=ZNodePaths.joinZNode(this.watcher.getZNodePaths().backupMasterAddressesZNode,this.sn.toString());
  while (!(master.isAborted() || master.isStopped())) {
    startupStatus.setStatus(""String_Node_Str"");
    try {
      if (MasterAddressTracker.setMasterAddress(this.watcher,this.watcher.getZNodePaths().masterAddressZNode,this.sn,infoPort)) {
        if (ZKUtil.checkExists(this.watcher,backupZNode) != -1) {
          LOG.info(""String_Node_Str"" + backupZNode + ""String_Node_Str"");
          ZKUtil.deleteNodeFailSilent(this.watcher,backupZNode);
        }
        ZNodeClearer.writeMyEphemeralNodeOnDisk(this.sn.toString());
        startupStatus.setStatus(""String_Node_Str"");
        this.clusterHasActiveMaster.set(true);
        LOG.info(""String_Node_Str"" + this.sn);
        return true;
      }
      this.clusterHasActiveMaster.set(true);
      String msg;
      byte[] bytes=ZKUtil.getDataAndWatch(this.watcher,this.watcher.getZNodePaths().masterAddressZNode);
      if (bytes == null) {
        msg=(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        ServerName currentMaster;
        try {
          currentMaster=ProtobufUtil.parseServerNameFrom(bytes);
        }
 catch (        DeserializationException e) {
          LOG.warn(""String_Node_Str"",e);
          continue;
        }
        if (ServerName.isSameAddress(currentMaster,this.sn)) {
          msg=(""String_Node_Str"" + currentMaster + ""String_Node_Str"");
          ZKUtil.deleteNode(this.watcher,this.watcher.getZNodePaths().masterAddressZNode);
          ZNodeClearer.deleteMyEphemeralNodeOnDisk();
        }
 else {
          msg=""String_Node_Str"" + currentMaster + ""String_Node_Str"";
        }
      }
      LOG.info(msg);
      startupStatus.setStatus(msg);
    }
 catch (    KeeperException ke) {
      master.abort(""String_Node_Str"",ke);
      return false;
    }
synchronized (this.clusterHasActiveMaster) {
      while (clusterHasActiveMaster.get() && !master.isStopped()) {
        try {
          clusterHasActiveMaster.wait(checkInterval);
        }
 catch (        InterruptedException e) {
          LOG.debug(""String_Node_Str"",e);
        }
      }
      if (clusterShutDown.get()) {
        this.master.stop(""String_Node_Str"");
      }
    }
  }
  return false;
}",0.9938671209540034
60841,"/** 
 * @return True if cluster has an active master.
 */
boolean hasActiveMaster(){
  try {
    if (ZKUtil.checkExists(watcher,watcher.znodePaths.masterAddressZNode) >= 0) {
      return true;
    }
  }
 catch (  KeeperException ke) {
    LOG.info(""String_Node_Str"" + ""String_Node_Str"" + ke);
  }
  return false;
}","/** 
 * @return True if cluster has an active master.
 */
boolean hasActiveMaster(){
  try {
    if (ZKUtil.checkExists(watcher,watcher.getZNodePaths().masterAddressZNode) >= 0) {
      return true;
    }
  }
 catch (  KeeperException ke) {
    LOG.info(""String_Node_Str"" + ""String_Node_Str"" + ke);
  }
  return false;
}",0.9858267716535432
60842,"@Override public void nodeChildrenChanged(final String path){
  if (path.equals(watcher.znodePaths.drainingZNode)) {
    try {
      final List<String> newNodes=ZKUtil.listChildrenAndWatchThem(watcher,watcher.znodePaths.drainingZNode);
      add(newNodes);
    }
 catch (    KeeperException e) {
      abortable.abort(""String_Node_Str"",e);
    }
catch (    IOException e) {
      abortable.abort(""String_Node_Str"",e);
    }
  }
}","@Override public void nodeChildrenChanged(final String path){
  if (path.equals(watcher.getZNodePaths().drainingZNode)) {
    try {
      final List<String> newNodes=ZKUtil.listChildrenAndWatchThem(watcher,watcher.getZNodePaths().drainingZNode);
      add(newNodes);
    }
 catch (    KeeperException e) {
      abortable.abort(""String_Node_Str"",e);
    }
catch (    IOException e) {
      abortable.abort(""String_Node_Str"",e);
    }
  }
}",0.97926267281106
60843,"@Override public void nodeDeleted(final String path){
  if (path.startsWith(watcher.znodePaths.drainingZNode)) {
    final ServerName sn=ServerName.valueOf(ZKUtil.getNodeName(path));
    LOG.info(""String_Node_Str"" + sn + ""String_Node_Str"");
    remove(sn);
  }
}","@Override public void nodeDeleted(final String path){
  if (path.startsWith(watcher.getZNodePaths().drainingZNode)) {
    final ServerName sn=ServerName.valueOf(ZKUtil.getNodeName(path));
    LOG.info(""String_Node_Str"" + sn + ""String_Node_Str"");
    remove(sn);
  }
}",0.9829867674858224
60844,"/** 
 * Starts the tracking of draining RegionServers. <p>All Draining RSs will be tracked after this method is called.
 * @throws KeeperException
 */
public void start() throws KeeperException, IOException {
  watcher.registerListener(this);
  serverManager.registerListener(new ServerListener(){
    @Override public void serverAdded(    ServerName sn){
      if (drainingServers.contains(sn)) {
        serverManager.addServerToDrainList(sn);
      }
    }
  }
);
  List<String> servers=ZKUtil.listChildrenAndWatchThem(watcher,watcher.znodePaths.drainingZNode);
  add(servers);
}","/** 
 * Starts the tracking of draining RegionServers. <p>All Draining RSs will be tracked after this method is called.
 * @throws KeeperException
 */
public void start() throws KeeperException, IOException {
  watcher.registerListener(this);
  serverManager.registerListener(new ServerListener(){
    @Override public void serverAdded(    ServerName sn){
      if (drainingServers.contains(sn)) {
        serverManager.addServerToDrainList(sn);
      }
    }
  }
);
  List<String> servers=ZKUtil.listChildrenAndWatchThem(watcher,watcher.getZNodePaths().drainingZNode);
  add(servers);
}",0.9632164242942686
60845,"/** 
 * Restore operation. Stage 2: resolved Backup Image dependency
 * @param backupManifestMap : tableName, Manifest
 * @param sTableArray The array of tables to be restored
 * @param tTableArray The array of mapping tables to restore to
 * @throws IOException exception
 */
private void restore(HashMap<TableName,BackupManifest> backupManifestMap,TableName[] sTableArray,TableName[] tTableArray,boolean isOverwrite) throws IOException {
  TreeSet<BackupImage> restoreImageSet=new TreeSet<>();
  Set<String> backupIdSet=new HashSet<>();
  for (int i=0; i < sTableArray.length; i++) {
    TableName table=sTableArray[i];
    BackupManifest manifest=backupManifestMap.get(table);
    List<BackupImage> list=new ArrayList<>();
    list.add(manifest.getBackupImage());
    TreeSet<BackupImage> set=new TreeSet<>(list);
    List<BackupImage> depList=manifest.getDependentListByTable(table);
    set.addAll(depList);
    BackupImage[] arr=new BackupImage[set.size()];
    set.toArray(arr);
    restoreImages(arr,table,tTableArray[i],isOverwrite);
    restoreImageSet.addAll(list);
    if (restoreImageSet != null && !restoreImageSet.isEmpty()) {
      LOG.info(""String_Node_Str"");
      for (      BackupImage image : restoreImageSet) {
        LOG.info(""String_Node_Str"" + image.getBackupId() + ""String_Node_Str""+ HBackupFileSystem.getTableBackupDir(image.getRootDir(),image.getBackupId(),table));
        if (image.getType() == BackupType.INCREMENTAL) {
          backupIdSet.add(image.getBackupId());
          LOG.debug(""String_Node_Str"" + image.getBackupId() + ""String_Node_Str"");
        }
      }
    }
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Restore operation. Stage 2: resolved Backup Image dependency
 * @param backupManifestMap : tableName, Manifest
 * @param sTableArray The array of tables to be restored
 * @param tTableArray The array of mapping tables to restore to
 * @throws IOException exception
 */
private void restore(HashMap<TableName,BackupManifest> backupManifestMap,TableName[] sTableArray,TableName[] tTableArray,boolean isOverwrite) throws IOException {
  TreeSet<BackupImage> restoreImageSet=new TreeSet<>();
  for (int i=0; i < sTableArray.length; i++) {
    TableName table=sTableArray[i];
    BackupManifest manifest=backupManifestMap.get(table);
    List<BackupImage> list=new ArrayList<>();
    list.add(manifest.getBackupImage());
    TreeSet<BackupImage> set=new TreeSet<>(list);
    List<BackupImage> depList=manifest.getDependentListByTable(table);
    set.addAll(depList);
    BackupImage[] arr=new BackupImage[set.size()];
    set.toArray(arr);
    restoreImages(arr,table,tTableArray[i],isOverwrite);
    restoreImageSet.addAll(list);
    if (restoreImageSet != null && !restoreImageSet.isEmpty()) {
      LOG.info(""String_Node_Str"");
      for (      BackupImage image : restoreImageSet) {
        LOG.info(""String_Node_Str"" + image.getBackupId() + ""String_Node_Str""+ HBackupFileSystem.getTableBackupDir(image.getRootDir(),image.getBackupId(),table));
      }
    }
  }
  LOG.debug(""String_Node_Str"");
}",0.9113591595535128
60846,"/** 
 * Do the encoding, but do not cache the encoded data.
 * @return encoded data block with header and checksum
 */
public byte[] encodeData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    baos.write(HConstants.HFILEBLOCK_DUMMY_HEADER);
    DataOutputStream out=new DataOutputStream(baos);
    this.dataBlockEncoder.startBlockEncoding(encodingCtx,out);
    ByteBuffer in=getUncompressedBuffer();
    in.rewind();
    int klength, vlength;
    int tagsLength=0;
    long memstoreTS=0L;
    KeyValue kv=null;
    while (in.hasRemaining()) {
      int kvOffset=in.position();
      klength=in.getInt();
      vlength=in.getInt();
      ByteBufferUtils.skip(in,klength + vlength);
      if (this.meta.isIncludesTags()) {
        tagsLength=((in.get() & 0xff) << 8) ^ (in.get() & 0xff);
        ByteBufferUtils.skip(in,tagsLength);
      }
      if (this.meta.isIncludesMvcc()) {
        memstoreTS=ByteBufferUtils.readVLong(in);
      }
      kv=new KeyValue(in.array(),kvOffset,(int)KeyValue.getKeyValueDataStructureSize(klength,vlength,tagsLength));
      kv.setSequenceId(memstoreTS);
      this.dataBlockEncoder.encode(kv,encodingCtx,out);
    }
    BufferGrabbingByteArrayOutputStream stream=new BufferGrabbingByteArrayOutputStream();
    baos.writeTo(stream);
    this.dataBlockEncoder.endBlockEncoding(encodingCtx,out,stream.ourBytes);
  }
 catch (  IOException e) {
    throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",toString()),e);
  }
  return baos.toByteArray();
}","/** 
 * Do the encoding, but do not cache the encoded data.
 * @return encoded data block with header and checksum
 */
public byte[] encodeData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  byte[] baosBytes=null;
  try {
    baos.write(HConstants.HFILEBLOCK_DUMMY_HEADER);
    DataOutputStream out=new DataOutputStream(baos);
    this.dataBlockEncoder.startBlockEncoding(encodingCtx,out);
    ByteBuffer in=getUncompressedBuffer();
    in.rewind();
    int klength, vlength;
    int tagsLength=0;
    long memstoreTS=0L;
    KeyValue kv=null;
    while (in.hasRemaining()) {
      int kvOffset=in.position();
      klength=in.getInt();
      vlength=in.getInt();
      ByteBufferUtils.skip(in,klength + vlength);
      if (this.meta.isIncludesTags()) {
        tagsLength=((in.get() & 0xff) << 8) ^ (in.get() & 0xff);
        ByteBufferUtils.skip(in,tagsLength);
      }
      if (this.meta.isIncludesMvcc()) {
        memstoreTS=ByteBufferUtils.readVLong(in);
      }
      kv=new KeyValue(in.array(),kvOffset,(int)KeyValue.getKeyValueDataStructureSize(klength,vlength,tagsLength));
      kv.setSequenceId(memstoreTS);
      this.dataBlockEncoder.encode(kv,encodingCtx,out);
    }
    baos.flush();
    baosBytes=baos.toByteArray();
    this.dataBlockEncoder.endBlockEncoding(encodingCtx,out,baosBytes);
  }
 catch (  IOException e) {
    throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",toString()),e);
  }
  return baosBytes;
}",0.9368351063829788
60847,"@Override protected void periodicExecute(final TEnvironment env){
  if (completed.isEmpty()) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"");
    }
    return;
  }
  final long evictTtl=conf.getInt(EVICT_TTL_CONF_KEY,DEFAULT_EVICT_TTL);
  final long evictAckTtl=conf.getInt(EVICT_ACKED_TTL_CONF_KEY,DEFAULT_ACKED_EVICT_TTL);
  final int batchSize=conf.getInt(BATCH_SIZE_CONF_KEY,DEFAULT_BATCH_SIZE);
  final long[] batchIds=new long[batchSize];
  int batchCount=0;
  final long now=EnvironmentEdgeManager.currentTime();
  final Iterator<Map.Entry<Long,CompletedProcedureRetainer>> it=completed.entrySet().iterator();
  final boolean debugEnabled=LOG.isDebugEnabled();
  while (it.hasNext() && store.isRunning()) {
    final Map.Entry<Long,CompletedProcedureRetainer> entry=it.next();
    final CompletedProcedureRetainer retainer=entry.getValue();
    final Procedure<?> proc=retainer.getProcedure();
    if (retainer.isExpired(now,evictTtl,evictAckTtl)) {
      if (!(proc instanceof FailedProcedure)) {
        batchIds[batchCount++]=entry.getKey();
        if (batchCount == batchIds.length) {
          store.delete(batchIds,0,batchCount);
          batchCount=0;
        }
      }
      final NonceKey nonceKey=proc.getNonceKey();
      if (nonceKey != null) {
        nonceKeysToProcIdsMap.remove(nonceKey);
      }
      it.remove();
      LOG.trace(""String_Node_Str"",proc);
    }
  }
  if (batchCount > 0) {
    store.delete(batchIds,0,batchCount);
  }
}","@Override protected void periodicExecute(final TEnvironment env){
  if (completed.isEmpty()) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"");
    }
    return;
  }
  final long evictTtl=conf.getInt(EVICT_TTL_CONF_KEY,DEFAULT_EVICT_TTL);
  final long evictAckTtl=conf.getInt(EVICT_ACKED_TTL_CONF_KEY,DEFAULT_ACKED_EVICT_TTL);
  final int batchSize=conf.getInt(BATCH_SIZE_CONF_KEY,DEFAULT_BATCH_SIZE);
  final long[] batchIds=new long[batchSize];
  int batchCount=0;
  final long now=EnvironmentEdgeManager.currentTime();
  final Iterator<Map.Entry<Long,CompletedProcedureRetainer>> it=completed.entrySet().iterator();
  while (it.hasNext() && store.isRunning()) {
    final Map.Entry<Long,CompletedProcedureRetainer> entry=it.next();
    final CompletedProcedureRetainer retainer=entry.getValue();
    final Procedure<?> proc=retainer.getProcedure();
    if (retainer.isExpired(now,evictTtl,evictAckTtl)) {
      if (!(proc instanceof FailedProcedure)) {
        batchIds[batchCount++]=entry.getKey();
        if (batchCount == batchIds.length) {
          store.delete(batchIds,0,batchCount);
          batchCount=0;
        }
      }
      final NonceKey nonceKey=proc.getNonceKey();
      if (nonceKey != null) {
        nonceKeysToProcIdsMap.remove(nonceKey);
      }
      it.remove();
      LOG.trace(""String_Node_Str"",proc);
    }
  }
  if (batchCount > 0) {
    store.delete(batchIds,0,batchCount);
  }
}",0.9825042881646656
60848,"@Override protected boolean abort(final TEnvironment env){
  final TState state=getCurrentState();
  LOG.debug(""String_Node_Str"",this);
  if (hasMoreState()) {
    aborted.set(true);
    return true;
  }
  LOG.debug(""String_Node_Str"",this);
  return false;
}","@Override protected boolean abort(final TEnvironment env){
  LOG.debug(""String_Node_Str"",this);
  if (hasMoreState()) {
    aborted.set(true);
    return true;
  }
  LOG.debug(""String_Node_Str"",this);
  return false;
}",0.9159663865546218
60849,"/** 
 * Look at what is in meta and the list of servers that have checked in and make reconciliation. We cannot tell definitively the difference between a clean shutdown and a cluster that has been crashed down. At this stage of a Master startup, they look the same: they have the same state in hbase:meta. We could do detective work probing ZK and the FS for old WALs to split but SCP does this already so just let it do its job. <p>>The profiles of clean shutdown and cluster crash-down are the same because on clean shutdown currently, we do not update hbase:meta with region close state (In AMv2, region state is kept in hbse:meta). Usually the master runs all region transitions as of AMv2 but on cluster controlled shutdown, the RegionServers close all their regions only reporting the final change to the Master. Currently this report is ignored. Later we could take it and update as many regions as we can before hbase:meta goes down or have the master run the close of all regions out on the cluster but we may never be able to achieve the proper state on all regions (at least not w/o lots of painful manipulations and waiting) so clean shutdown might not be possible especially on big clusters.... And clean shutdown will take time. Given this current state of affairs, we just run ServerCrashProcedure in both cases. It will always do the right thing.
 * @return True if for sure this is a failover where a Master is starting up into an alreadyrunning cluster.
 */
private boolean processofflineServersWithOnlineRegions(){
  boolean deadServers=!master.getServerManager().getDeadServers().isEmpty();
  final Set<ServerName> offlineServersWithOnlineRegions=new HashSet<>();
  int size=regionStates.getRegionStateNodes().size();
  final List<RegionInfo> offlineRegionsToAssign=new ArrayList<>(size);
  long startTime=System.currentTimeMillis();
  boolean failover=deadServers;
  for (  RegionStateNode regionNode : regionStates.getRegionStateNodes()) {
    if (regionNode.getState() == State.OPEN) {
      final ServerName serverName=regionNode.getRegionLocation();
      if (!master.getServerManager().isServerOnline(serverName)) {
        offlineServersWithOnlineRegions.add(serverName);
      }
 else {
        failover=true;
      }
    }
 else     if (regionNode.getState() == State.OFFLINE) {
      if (isTableEnabled(regionNode.getTable())) {
        offlineRegionsToAssign.add(regionNode.getRegionInfo());
      }
    }
  }
  for (  ServerName serverName : offlineServersWithOnlineRegions) {
    if (!master.getServerManager().isServerOnline(serverName)) {
      LOG.info(""String_Node_Str"" + serverName + ""String_Node_Str"");
      killRegionServer(serverName);
    }
  }
  setFailoverCleanupDone(true);
  if (offlineRegionsToAssign.size() > 0) {
    master.getMasterProcedureExecutor().submitProcedures(master.getAssignmentManager().createRoundRobinAssignProcedures(offlineRegionsToAssign));
  }
  return failover;
}","/** 
 * Look at what is in meta and the list of servers that have checked in and make reconciliation. We cannot tell definitively the difference between a clean shutdown and a cluster that has been crashed down. At this stage of a Master startup, they look the same: they have the same state in hbase:meta. We could do detective work probing ZK and the FS for old WALs to split but SCP does this already so just let it do its job. <p>>The profiles of clean shutdown and cluster crash-down are the same because on clean shutdown currently, we do not update hbase:meta with region close state (In AMv2, region state is kept in hbse:meta). Usually the master runs all region transitions as of AMv2 but on cluster controlled shutdown, the RegionServers close all their regions only reporting the final change to the Master. Currently this report is ignored. Later we could take it and update as many regions as we can before hbase:meta goes down or have the master run the close of all regions out on the cluster but we may never be able to achieve the proper state on all regions (at least not w/o lots of painful manipulations and waiting) so clean shutdown might not be possible especially on big clusters.... And clean shutdown will take time. Given this current state of affairs, we just run ServerCrashProcedure in both cases. It will always do the right thing.
 * @return True if for sure this is a failover where a Master is starting up into an alreadyrunning cluster.
 */
private boolean processofflineServersWithOnlineRegions(){
  boolean deadServers=!master.getServerManager().getDeadServers().isEmpty();
  final Set<ServerName> offlineServersWithOnlineRegions=new HashSet<>();
  int size=regionStates.getRegionStateNodes().size();
  final List<RegionInfo> offlineRegionsToAssign=new ArrayList<>(size);
  boolean failover=deadServers;
  for (  RegionStateNode regionNode : regionStates.getRegionStateNodes()) {
    if (regionNode.getState() == State.OPEN) {
      final ServerName serverName=regionNode.getRegionLocation();
      if (!master.getServerManager().isServerOnline(serverName)) {
        offlineServersWithOnlineRegions.add(serverName);
      }
 else {
        failover=true;
      }
    }
 else     if (regionNode.getState() == State.OFFLINE) {
      if (isTableEnabled(regionNode.getTable())) {
        offlineRegionsToAssign.add(regionNode.getRegionInfo());
      }
    }
  }
  for (  ServerName serverName : offlineServersWithOnlineRegions) {
    if (!master.getServerManager().isServerOnline(serverName)) {
      LOG.info(""String_Node_Str"" + serverName + ""String_Node_Str"");
      killRegionServer(serverName);
    }
  }
  setFailoverCleanupDone(true);
  if (offlineRegionsToAssign.size() > 0) {
    master.getMasterProcedureExecutor().submitProcedures(master.getAssignmentManager().createRoundRobinAssignProcedures(offlineRegionsToAssign));
  }
  return failover;
}",0.9922720247295208
60850,"/** 
 * Prepare to Split region.
 * @param env MasterProcedureEnv
 * @throws IOException
 */
@VisibleForTesting public boolean prepareSplitRegion(final MasterProcedureEnv env) throws IOException {
  RegionStateNode node=env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());
  if (node == null) {
    throw new UnknownRegionException(getParentRegion().getRegionNameAsString());
  }
  RegionInfo parentHRI=node.getRegionInfo();
  if (node.isInState(State.SPLIT)) {
    LOG.info(""String_Node_Str"" + parentHRI + ""String_Node_Str"");
    return false;
  }
  if (parentHRI.isSplit() || parentHRI.isOffline()) {
    LOG.info(""String_Node_Str"" + parentHRI + ""String_Node_Str"");
    return false;
  }
  if (!node.isInState(EXPECTED_SPLIT_STATES)) {
    setFailure(new IOException(""String_Node_Str"" + parentHRI.getRegionNameAsString() + ""String_Node_Str""+ node.getState()+ ""String_Node_Str""+ Arrays.toString(EXPECTED_SPLIT_STATES)));
    return false;
  }
  if (!env.getMasterServices().isSplitOrMergeEnabled(MasterSwitchType.SPLIT)) {
    LOG.warn(""String_Node_Str"" + getProcId() + ""String_Node_Str""+ parentHRI);
    setFailure(new IOException(""String_Node_Str"" + (parentHRI == null ? ""String_Node_Str"" : parentHRI.getRegionNameAsString()) + ""String_Node_Str""));
    return false;
  }
  node.setState(State.SPLITTING);
  return true;
}","/** 
 * Prepare to Split region.
 * @param env MasterProcedureEnv
 * @throws IOException
 */
@VisibleForTesting public boolean prepareSplitRegion(final MasterProcedureEnv env) throws IOException {
  RegionStateNode node=env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());
  if (node == null) {
    throw new UnknownRegionException(getParentRegion().getRegionNameAsString());
  }
  RegionInfo parentHRI=node.getRegionInfo();
  if (parentHRI == null) {
    LOG.info(""String_Node_Str"",node);
    return false;
  }
  if (node.isInState(State.SPLIT)) {
    LOG.info(""String_Node_Str"" + parentHRI + ""String_Node_Str"");
    return false;
  }
  if (parentHRI.isSplit() || parentHRI.isOffline()) {
    LOG.info(""String_Node_Str"" + parentHRI + ""String_Node_Str"");
    return false;
  }
  if (!node.isInState(EXPECTED_SPLIT_STATES)) {
    setFailure(new IOException(""String_Node_Str"" + parentHRI.getRegionNameAsString() + ""String_Node_Str""+ node.getState()+ ""String_Node_Str""+ Arrays.toString(EXPECTED_SPLIT_STATES)));
    return false;
  }
  if (!env.getMasterServices().isSplitOrMergeEnabled(MasterSwitchType.SPLIT)) {
    LOG.warn(""String_Node_Str"" + getProcId() + ""String_Node_Str""+ parentHRI);
    setFailure(new IOException(""String_Node_Str"" + parentHRI.getRegionNameAsString() + ""String_Node_Str""));
    return false;
  }
  node.setState(State.SPLITTING);
  return true;
}",0.9531760435571688
60851,"/** 
 * Calculate size for cleaner pool.
 * @param poolSize size from configuration
 * @return size of pool after calculation
 */
int calculatePoolSize(String poolSize){
  if (poolSize.matches(""String_Node_Str"")) {
    int size=Math.min(Integer.valueOf(poolSize),AVAIL_PROCESSORS);
    if (size == AVAIL_PROCESSORS) {
      LOG.warn(""String_Node_Str"",size);
    }
    return size;
  }
 else   if (poolSize.matches(""String_Node_Str"")) {
    int computedThreads=(int)(AVAIL_PROCESSORS * Double.valueOf(poolSize));
    if (computedThreads < 1) {
      LOG.debug(""String_Node_Str"",computedThreads);
      return 1;
    }
    return computedThreads;
  }
 else {
    LOG.error(""String_Node_Str"" + poolSize + ""String_Node_Str""+ CHORE_POOL_SIZE+ ""String_Node_Str""+ DEFAULT_CHORE_POOL_SIZE+ ""String_Node_Str"");
    return calculatePoolSize(DEFAULT_CHORE_POOL_SIZE);
  }
}","/** 
 * Calculate size for cleaner pool.
 * @param poolSize size from configuration
 * @return size of pool after calculation
 */
static int calculatePoolSize(String poolSize){
  if (poolSize.matches(""String_Node_Str"")) {
    int size=Math.min(Integer.parseInt(poolSize),AVAIL_PROCESSORS);
    if (size == AVAIL_PROCESSORS) {
      LOG.warn(""String_Node_Str"",size);
    }
    return size;
  }
 else   if (poolSize.matches(""String_Node_Str"")) {
    int computedThreads=(int)(AVAIL_PROCESSORS * Double.valueOf(poolSize));
    if (computedThreads < 1) {
      LOG.debug(""String_Node_Str"",computedThreads);
      return 1;
    }
    return computedThreads;
  }
 else {
    LOG.error(""String_Node_Str"" + poolSize + ""String_Node_Str""+ CHORE_POOL_SIZE+ ""String_Node_Str""+ DEFAULT_CHORE_POOL_SIZE+ ""String_Node_Str"");
    return calculatePoolSize(DEFAULT_CHORE_POOL_SIZE);
  }
}",0.98729792147806
60852,"/** 
 * @param name name of the chore being run
 * @param sleepPeriod the period of time to sleep between each run
 * @param s the stopper
 * @param conf configuration to use
 * @param fs handle to the FS
 * @param oldFileDir the path to the archived files
 * @param confKey configuration key for the classes to instantiate
 * @param params members could be used in cleaner
 */
public CleanerChore(String name,final int sleepPeriod,final Stoppable s,Configuration conf,FileSystem fs,Path oldFileDir,String confKey,Map<String,Object> params){
  super(name,s,sleepPeriod);
  this.fs=fs;
  this.oldFileDir=oldFileDir;
  this.conf=conf;
  this.params=params;
  initCleanerChain(confKey);
  if (chorePool == null) {
    String poolSize=conf.get(CHORE_POOL_SIZE,DEFAULT_CHORE_POOL_SIZE);
    chorePoolSize=calculatePoolSize(poolSize);
    chorePoolSize=chorePoolSize == 0 ? calculatePoolSize(DEFAULT_CHORE_POOL_SIZE) : chorePoolSize;
    this.chorePool=new ForkJoinPool(chorePoolSize);
    LOG.info(""String_Node_Str"",chorePoolSize);
  }
}","/** 
 * @param name name of the chore being run
 * @param sleepPeriod the period of time to sleep between each run
 * @param s the stopper
 * @param conf configuration to use
 * @param fs handle to the FS
 * @param oldFileDir the path to the archived files
 * @param confKey configuration key for the classes to instantiate
 * @param params members could be used in cleaner
 */
public CleanerChore(String name,final int sleepPeriod,final Stoppable s,Configuration conf,FileSystem fs,Path oldFileDir,String confKey,Map<String,Object> params){
  super(name,s,sleepPeriod);
  this.fs=fs;
  this.oldFileDir=oldFileDir;
  this.conf=conf;
  this.params=params;
  initCleanerChain(confKey);
  if (CHOREPOOL == null) {
    String poolSize=conf.get(CHORE_POOL_SIZE,DEFAULT_CHORE_POOL_SIZE);
    CHOREPOOLSIZE=calculatePoolSize(poolSize);
    CHOREPOOLSIZE=CHOREPOOLSIZE == 0 ? calculatePoolSize(DEFAULT_CHORE_POOL_SIZE) : CHOREPOOLSIZE;
    this.CHOREPOOL=new ForkJoinPool(CHOREPOOLSIZE);
    LOG.info(""String_Node_Str"",CHOREPOOLSIZE);
  }
}",0.9060077519379846
60853,"@VisibleForTesting int getChorePoolSize(){
  return chorePoolSize;
}","@VisibleForTesting int getChorePoolSize(){
  return CHOREPOOLSIZE;
}",0.8382352941176471
60854,"public Boolean runCleaner(){
  preRunCleaner();
  CleanerTask task=new CleanerTask(this.oldFileDir,true);
  chorePool.submit(task);
  return task.join();
}","public Boolean runCleaner(){
  preRunCleaner();
  CleanerTask task=new CleanerTask(this.oldFileDir,true);
  CHOREPOOL.submit(task);
  return task.join();
}",0.9483870967741936
60855,"@Override public void onConfigurationChange(Configuration conf){
  int updatedSize=calculatePoolSize(conf.get(CHORE_POOL_SIZE,DEFAULT_CHORE_POOL_SIZE));
  if (updatedSize == chorePoolSize) {
    LOG.trace(""String_Node_Str"",updatedSize);
    return;
  }
  chorePoolSize=updatedSize;
  if (chorePool.getPoolSize() == 0) {
    updateChorePoolSize(updatedSize);
    return;
  }
  reconfig.set(true);
}","@Override public void onConfigurationChange(Configuration conf){
  int updatedSize=calculatePoolSize(conf.get(CHORE_POOL_SIZE,DEFAULT_CHORE_POOL_SIZE));
  if (updatedSize == CHOREPOOLSIZE) {
    LOG.trace(""String_Node_Str"",updatedSize);
    return;
  }
  CHOREPOOLSIZE=updatedSize;
  if (CHOREPOOL.getPoolSize() == 0) {
    updateChorePoolSize(updatedSize);
    return;
  }
  reconfig.set(true);
}",0.8614609571788413
60856,"private void updateChorePoolSize(int updatedSize){
  chorePool.shutdownNow();
  LOG.info(""String_Node_Str"",chorePool.getParallelism(),updatedSize);
  chorePool=new ForkJoinPool(updatedSize);
}","private void updateChorePoolSize(int updatedSize){
  CHOREPOOL.shutdownNow();
  LOG.info(""String_Node_Str"",CHOREPOOL.getParallelism(),updatedSize);
  CHOREPOOL=new ForkJoinPool(updatedSize);
}",0.875
60857,"@Override protected void chore(){
  if (getEnabled()) {
    if (runCleaner()) {
      LOG.debug(""String_Node_Str"",oldFileDir);
    }
 else {
      LOG.warn(""String_Node_Str"",oldFileDir);
    }
    if (reconfig.compareAndSet(true,false)) {
      updateChorePoolSize(chorePoolSize);
    }
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
}","@Override protected void chore(){
  if (getEnabled()) {
    if (runCleaner()) {
      LOG.debug(""String_Node_Str"",oldFileDir);
    }
 else {
      LOG.warn(""String_Node_Str"",oldFileDir);
    }
    if (reconfig.compareAndSet(true,false)) {
      updateChorePoolSize(CHOREPOOLSIZE);
    }
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
}",0.9644970414201184
60858,"@Override @edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public void startRegionOperation(Operation op) throws IOException {
switch (op) {
case GET:
case SCAN:
    checkReadsEnabled();
default :
  break;
}
if (op == Operation.MERGE_REGION || op == Operation.SPLIT_REGION || op == Operation.COMPACT_REGION) {
return;
}
if (this.closing.get()) {
throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + ""String_Node_Str"");
}
lock(lock.readLock());
if (this.closed.get()) {
lock.readLock().unlock();
throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + ""String_Node_Str"");
}
if (op == Operation.SNAPSHOT) {
stores.values().forEach(HStore::preSnapshotOperation);
}
try {
if (coprocessorHost != null) {
  coprocessorHost.postStartRegionOperation(op);
}
}
 catch (Exception e) {
lock.readLock().unlock();
throw new IOException(e);
}
}","@Override public void startRegionOperation(Operation op) throws IOException {
switch (op) {
case GET:
case SCAN:
    checkReadsEnabled();
  break;
default :
break;
}
if (op == Operation.MERGE_REGION || op == Operation.SPLIT_REGION || op == Operation.COMPACT_REGION) {
return;
}
if (this.closing.get()) {
throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + ""String_Node_Str"");
}
lock(lock.readLock());
if (this.closed.get()) {
lock.readLock().unlock();
throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + ""String_Node_Str"");
}
if (op == Operation.SNAPSHOT) {
stores.values().forEach(HStore::preSnapshotOperation);
}
try {
if (coprocessorHost != null) {
coprocessorHost.postStartRegionOperation(op);
}
}
 catch (Exception e) {
lock.readLock().unlock();
throw new IOException(e);
}
}",0.9320498301245752
60859,"@Override protected void chore(){
  if (!connected) {
    return;
  }
  List<ServerName> sns=generateDeadServersListToSend();
  if (sns.isEmpty()) {
    return;
  }
  final long curTime=EnvironmentEdgeManager.currentTime();
  if (lastMessageTime > curTime - messagePeriod) {
    return;
  }
  lastMessageTime=curTime;
  publisher.publish(ClusterMetricsBuilder.newBuilder().setHBaseVersion(VersionInfo.getVersion()).setClusterId(master.getMasterFileSystem().getClusterId().toString()).setMasterName(master.getServerName()).setDeadServerNames(sns).build());
}","@Override protected void chore(){
  if (!isConnected()) {
    return;
  }
  List<ServerName> sns=generateDeadServersListToSend();
  if (sns.isEmpty()) {
    return;
  }
  final long curTime=EnvironmentEdgeManager.currentTime();
  if (lastMessageTime > curTime - messagePeriod) {
    return;
  }
  lastMessageTime=curTime;
  publisher.publish(ClusterMetricsBuilder.newBuilder().setHBaseVersion(VersionInfo.getVersion()).setClusterId(master.getMasterFileSystem().getClusterId().toString()).setMasterName(master.getServerName()).setDeadServerNames(sns).build());
}",0.9803220035778176
60860,"/** 
 * Supports Coprocessor 'bypass'.
 * @param row row to check
 * @param family column family
 * @param qualifier column qualifier
 * @param op the comparison operation
 * @param comparator the comparator
 * @param put data to put if check succeeds
 * @return true or false to return to client if default processing should be bypassed, or nullotherwise
 */
public Boolean preCheckAndPutAfterRowLock(final byte[] row,final byte[] family,final byte[] qualifier,final CompareOperator op,final ByteArrayComparable comparator,final Put put) throws IOException {
  boolean bypassable=true;
  boolean defaultResult=false;
  if (coprocEnvironments.isEmpty()) {
    return null;
  }
  return execOperationWithResult(new ObserverOperationWithResult<RegionObserver,Boolean>(regionObserverGetter,defaultResult,bypassable){
    @Override public Boolean call(    RegionObserver observer) throws IOException {
      return observer.preCheckAndPutAfterRowLock(this,row,family,qualifier,op,comparator,put,getResult());
    }
  }
);
}","/** 
 * Supports Coprocessor 'bypass'.
 * @param row row to check
 * @param family column family
 * @param qualifier column qualifier
 * @param op the comparison operation
 * @param comparator the comparator
 * @param put data to put if check succeeds
 * @return true or false to return to client if default processing should be bypassed, or nullotherwise
 */
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public Boolean preCheckAndPutAfterRowLock(final byte[] row,final byte[] family,final byte[] qualifier,final CompareOperator op,final ByteArrayComparable comparator,final Put put) throws IOException {
  boolean bypassable=true;
  boolean defaultResult=false;
  if (coprocEnvironments.isEmpty()) {
    return null;
  }
  return execOperationWithResult(new ObserverOperationWithResult<RegionObserver,Boolean>(regionObserverGetter,defaultResult,bypassable){
    @Override public Boolean call(    RegionObserver observer) throws IOException {
      return observer.preCheckAndPutAfterRowLock(this,row,family,qualifier,op,comparator,put,getResult());
    }
  }
);
}",0.9501165501165502
60861,"/** 
 * Main program
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  if (conf == null)   conf=HBaseConfiguration.create();
  int ret=ToolRunner.run(conf,new ReplicationSyncUp(),args);
  System.exit(ret);
}","/** 
 * Main program
 */
public static void main(String[] args) throws Exception {
  int ret=ToolRunner.run(HBaseConfiguration.create(),new ReplicationSyncUp(),args);
  System.exit(ret);
}",0.755056179775281
60862,"@Override public int run(String[] args) throws Exception {
  Replication replication;
  ReplicationSourceManager manager;
  FileSystem fs;
  Path oldLogDir, logDir, walRootDir;
  ZKWatcher zkw;
  Abortable abortable=new Abortable(){
    @Override public void abort(    String why,    Throwable e){
    }
    @Override public boolean isAborted(){
      return false;
    }
  }
;
  zkw=new ZKWatcher(conf,""String_Node_Str"" + System.currentTimeMillis(),abortable,true);
  walRootDir=FSUtils.getWALRootDir(conf);
  fs=FSUtils.getWALFileSystem(conf);
  oldLogDir=new Path(walRootDir,HConstants.HREGION_OLDLOGDIR_NAME);
  logDir=new Path(walRootDir,HConstants.HREGION_LOGDIR_NAME);
  System.out.println(""String_Node_Str"");
  replication=new Replication();
  replication.initialize(new DummyServer(zkw),fs,logDir,oldLogDir,null);
  manager=replication.getReplicationManager();
  manager.init().get();
  try {
    while (manager.activeFailoverTaskCount() > 0) {
      Thread.sleep(SLEEP_TIME);
    }
    while (manager.getOldSources().size() > 0) {
      Thread.sleep(SLEEP_TIME);
    }
    manager.join();
  }
 catch (  InterruptedException e) {
    System.err.println(""String_Node_Str"" + e);
    return (-1);
  }
 finally {
    zkw.close();
  }
  return 0;
}","@Override public int run(String[] args) throws Exception {
  Abortable abortable=new Abortable(){
    @Override public void abort(    String why,    Throwable e){
    }
    @Override public boolean isAborted(){
      return false;
    }
  }
;
  Configuration conf=getConf();
  try (ZKWatcher zkw=new ZKWatcher(conf,""String_Node_Str"" + System.currentTimeMillis(),abortable,true)){
    Path walRootDir=FSUtils.getWALRootDir(conf);
    FileSystem fs=FSUtils.getWALFileSystem(conf);
    Path oldLogDir=new Path(walRootDir,HConstants.HREGION_OLDLOGDIR_NAME);
    Path logDir=new Path(walRootDir,HConstants.HREGION_LOGDIR_NAME);
    System.out.println(""String_Node_Str"");
    Replication replication=new Replication();
    replication.initialize(new DummyServer(zkw),fs,logDir,oldLogDir,null);
    ReplicationSourceManager manager=replication.getReplicationManager();
    manager.init().get();
    while (manager.activeFailoverTaskCount() > 0) {
      Thread.sleep(SLEEP_TIME);
    }
    while (manager.getOldSources().size() > 0) {
      Thread.sleep(SLEEP_TIME);
    }
    manager.join();
  }
 catch (  InterruptedException e) {
    System.err.println(""String_Node_Str"" + e);
    return -1;
  }
  return 0;
}",0.7247557003257329
60863,"@Override public Configuration getConfiguration(){
  return conf;
}","@Override public Configuration getConfiguration(){
  return getConf();
}",0.9496402877697842
60864,"protected void syncUp(HBaseTestingUtility ut) throws Exception {
  ReplicationSyncUp.setConfigure(ut.getConfiguration());
  String[] arguments=new String[]{null};
  new ReplicationSyncUp().run(arguments);
}","protected void syncUp(HBaseTestingUtility ut) throws Exception {
  ToolRunner.run(ut.getConfiguration(),new ReplicationSyncUp(),new String[0]);
}",0.6951566951566952
60865,"/** 
 * Close the previous replication sources of this peer id and open new sources to trigger the new replication state changes or new replication config changes. Here we don't need to change replication queue storage and only to enqueue all logs to the new replication source
 * @param peerId the id of the replication peer
 * @throws IOException
 */
public void refreshSources(String peerId) throws IOException {
  String terminateMessage=""String_Node_Str"" + peerId + ""String_Node_Str"";
  ReplicationPeer peer=replicationPeers.getPeer(peerId);
  ReplicationSourceInterface src=createSource(peerId,peer);
synchronized (this.latestPaths) {
    ReplicationSourceInterface toRemove=this.sources.put(peerId,src);
    if (toRemove != null) {
      LOG.info(""String_Node_Str"" + toRemove.getPeerId());
      toRemove.terminate(terminateMessage);
    }
    for (    SortedSet<String> walsByGroup : walsById.get(peerId).values()) {
      walsByGroup.forEach(wal -> src.enqueueLog(new Path(this.logDir,wal)));
    }
  }
  LOG.info(""String_Node_Str"" + src.getPeerId());
  src.startup();
  List<ReplicationSourceInterface> toStartup=new ArrayList<>();
synchronized (this.oldsources) {
    List<String> previousQueueIds=new ArrayList<>();
    for (    ReplicationSourceInterface oldSource : this.oldsources) {
      if (oldSource.getPeerId().equals(peerId)) {
        previousQueueIds.add(oldSource.getQueueId());
        oldSource.terminate(terminateMessage);
        this.oldsources.remove(oldSource);
      }
    }
    for (    String queueId : previousQueueIds) {
      ReplicationSourceInterface replicationSource=createSource(queueId,peer);
      this.oldsources.add(replicationSource);
      for (      SortedSet<String> walsByGroup : walsByIdRecoveredQueues.get(queueId).values()) {
        walsByGroup.forEach(wal -> src.enqueueLog(new Path(wal)));
      }
      toStartup.add(replicationSource);
    }
  }
  for (  ReplicationSourceInterface replicationSource : oldsources) {
    replicationSource.startup();
  }
}","/** 
 * Close the previous replication sources of this peer id and open new sources to trigger the new replication state changes or new replication config changes. Here we don't need to change replication queue storage and only to enqueue all logs to the new replication source
 * @param peerId the id of the replication peer
 * @throws IOException
 */
public void refreshSources(String peerId) throws IOException {
  String terminateMessage=""String_Node_Str"" + peerId + ""String_Node_Str"";
  ReplicationPeer peer=replicationPeers.getPeer(peerId);
  ReplicationSourceInterface src=createSource(peerId,peer);
synchronized (this.latestPaths) {
    ReplicationSourceInterface toRemove=this.sources.put(peerId,src);
    if (toRemove != null) {
      LOG.info(""String_Node_Str"" + toRemove.getPeerId());
      toRemove.terminate(terminateMessage);
    }
    for (    SortedSet<String> walsByGroup : walsById.get(peerId).values()) {
      walsByGroup.forEach(wal -> src.enqueueLog(new Path(this.logDir,wal)));
    }
  }
  LOG.info(""String_Node_Str"" + src.getPeerId());
  src.startup();
  List<ReplicationSourceInterface> toStartup=new ArrayList<>();
synchronized (this.oldsources) {
    List<String> previousQueueIds=new ArrayList<>();
    for (    ReplicationSourceInterface oldSource : this.oldsources) {
      if (oldSource.getPeerId().equals(peerId)) {
        previousQueueIds.add(oldSource.getQueueId());
        oldSource.terminate(terminateMessage);
        this.oldsources.remove(oldSource);
      }
    }
    for (    String queueId : previousQueueIds) {
      ReplicationSourceInterface replicationSource=createSource(queueId,peer);
      this.oldsources.add(replicationSource);
      for (      SortedSet<String> walsByGroup : walsByIdRecoveredQueues.get(queueId).values()) {
        walsByGroup.forEach(wal -> src.enqueueLog(new Path(wal)));
      }
      toStartup.add(replicationSource);
    }
  }
  for (  ReplicationSourceInterface replicationSource : toStartup) {
    replicationSource.startup();
  }
}",0.99527950310559
60866,"@Override public Cell forceCopyOfBigCellInto(Cell cell){
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * The process of merging assumes all cells are allocated on mslab. There is a rare case in which the first immutable segment, participating in a merge, is a CSLM. Since the CSLM hasn't been flattened yet, and there is no point in flattening it (since it is going to be merged), its big cells (for whom size > maxAlloc) must be copied into mslab. This method copies the passed cell into the first mslab in the mslabs list, returning either a new cell instance over the copied data, or null when this cell cannt be copied.
 */
@Override public Cell forceCopyOfBigCellInto(Cell cell){
  MemStoreLAB mslab=this.mslabs.get(0);
  return mslab.forceCopyOfBigCellInto(cell);
}",0.1653944020356234
60867,"/** 
 * Test a distributed commit with multiple cohort members, where one of the cohort members has a timeout exception during the prepare stage.
 */
@Test public void testMultiCohortWithMemberTimeoutDuringPrepare() throws Exception {
  String opDescription=""String_Node_Str"";
  String[] cohortMembers=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  List<String> expected=Lists.newArrayList(cohortMembers);
  final int memberErrorIndex=2;
  final CountDownLatch coordinatorReceivedErrorLatch=new CountDownLatch(1);
  ZKWatcher coordinatorWatcher=newZooKeeperWatcher();
  ZKProcedureCoordinator coordinatorController=new ZKProcedureCoordinator(coordinatorWatcher,opDescription,COORDINATOR_NODE_NAME);
  ThreadPoolExecutor pool=ProcedureCoordinator.defaultPool(COORDINATOR_NODE_NAME,POOL_SIZE,KEEP_ALIVE);
  ProcedureCoordinator coordinator=spy(new ProcedureCoordinator(coordinatorController,pool));
  SubprocedureFactory subprocFactory=Mockito.mock(SubprocedureFactory.class);
  List<Pair<ProcedureMember,ZKProcedureMemberRpcs>> members=new ArrayList<>(expected.size());
  for (  String member : expected) {
    ZKWatcher watcher=newZooKeeperWatcher();
    ZKProcedureMemberRpcs controller=new ZKProcedureMemberRpcs(watcher,opDescription);
    ThreadPoolExecutor pool2=ProcedureMember.defaultPool(member,1,KEEP_ALIVE);
    ProcedureMember mem=new ProcedureMember(controller,pool2,subprocFactory);
    members.add(new Pair<>(mem,controller));
    controller.start(member,mem);
  }
  final List<Subprocedure> cohortTasks=new ArrayList<>();
  final int[] elem=new int[1];
  for (int i=0; i < members.size(); i++) {
    ForeignExceptionDispatcher cohortMonitor=new ForeignExceptionDispatcher();
    final ProcedureMember comms=members.get(i).getFirst();
    Subprocedure commit=Mockito.spy(new SubprocedureImpl(comms,opName,cohortMonitor,WAKE_FREQUENCY,TIMEOUT));
    Mockito.doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        int index=elem[0];
        if (index == memberErrorIndex) {
          LOG.debug(""String_Node_Str"");
          ForeignException remoteCause=new ForeignException(""String_Node_Str"",new TimeoutException(""String_Node_Str"",1,2,0));
          Subprocedure r=((Subprocedure)invocation.getMock());
          LOG.error(""String_Node_Str"" + remoteCause);
          comms.receiveAbortProcedure(r.getName(),remoteCause);
          assertEquals(true,r.isComplete());
          try {
            Procedure.waitForLatch(coordinatorReceivedErrorLatch,new ForeignExceptionDispatcher(),WAKE_FREQUENCY,""String_Node_Str"");
          }
 catch (          InterruptedException e) {
            LOG.debug(""String_Node_Str"" + (coordinatorReceivedErrorLatch.getCount() == 0));
            Thread.currentThread().interrupt();
          }
        }
        elem[0]=++index;
        return null;
      }
    }
).when(commit).acquireBarrier();
    cohortTasks.add(commit);
  }
  final AtomicInteger taskIndex=new AtomicInteger();
  Mockito.when(subprocFactory.buildSubprocedure(Mockito.eq(opName),(byte[])Mockito.argThat(new ArrayEquals(data)))).thenAnswer(new Answer<Subprocedure>(){
    @Override public Subprocedure answer(    InvocationOnMock invocation) throws Throwable {
      int index=taskIndex.getAndIncrement();
      Subprocedure commit=cohortTasks.get(index);
      return commit;
    }
  }
);
  ForeignExceptionDispatcher coordinatorTaskErrorMonitor=Mockito.spy(new ForeignExceptionDispatcher());
  Procedure coordinatorTask=Mockito.spy(new Procedure(coordinator,coordinatorTaskErrorMonitor,WAKE_FREQUENCY,TIMEOUT,opName,data,expected));
  when(coordinator.createProcedure(any(),eq(opName),eq(data),anyListOf(String.class))).thenReturn(coordinatorTask);
  Mockito.doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      invocation.callRealMethod();
      coordinatorReceivedErrorLatch.countDown();
      return null;
    }
  }
).when(coordinatorTask).receive(Mockito.any());
  Procedure task=coordinator.startProcedure(coordinatorTaskErrorMonitor,opName,data,expected);
  assertEquals(""String_Node_Str"",coordinatorTask,task);
  try {
    task.waitForCompleted();
  }
 catch (  ForeignException fe) {
  }
  waitAndVerifyProc(coordinatorTask,once,never(),once,atMost(1),true);
  verifyCohortSuccessful(expected,subprocFactory,cohortTasks,once,never(),once,once,true);
  closeAll(coordinator,coordinatorController,members);
}","/** 
 * Test a distributed commit with multiple cohort members, where one of the cohort members has a timeout exception during the prepare stage.
 */
@Test public void testMultiCohortWithMemberTimeoutDuringPrepare() throws Exception {
  String opDescription=""String_Node_Str"";
  String[] cohortMembers=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  List<String> expected=Lists.newArrayList(cohortMembers);
  final int memberErrorIndex=2;
  final CountDownLatch coordinatorReceivedErrorLatch=new CountDownLatch(1);
  ZKWatcher coordinatorWatcher=newZooKeeperWatcher();
  ZKProcedureCoordinator coordinatorController=new ZKProcedureCoordinator(coordinatorWatcher,opDescription,COORDINATOR_NODE_NAME);
  ThreadPoolExecutor pool=ProcedureCoordinator.defaultPool(COORDINATOR_NODE_NAME,POOL_SIZE,KEEP_ALIVE);
  ProcedureCoordinator coordinator=spy(new ProcedureCoordinator(coordinatorController,pool));
  SubprocedureFactory subprocFactory=Mockito.mock(SubprocedureFactory.class);
  List<Pair<ProcedureMember,ZKProcedureMemberRpcs>> members=new ArrayList<>(expected.size());
  for (  String member : expected) {
    ZKWatcher watcher=newZooKeeperWatcher();
    ZKProcedureMemberRpcs controller=new ZKProcedureMemberRpcs(watcher,opDescription);
    ThreadPoolExecutor pool2=ProcedureMember.defaultPool(member,1,KEEP_ALIVE);
    ProcedureMember mem=new ProcedureMember(controller,pool2,subprocFactory);
    members.add(new Pair<>(mem,controller));
    controller.start(member,mem);
  }
  final List<Subprocedure> cohortTasks=new ArrayList<>();
  final int[] elem=new int[1];
  for (int i=0; i < members.size(); i++) {
    ForeignExceptionDispatcher cohortMonitor=new ForeignExceptionDispatcher();
    final ProcedureMember comms=members.get(i).getFirst();
    Subprocedure commit=Mockito.spy(new SubprocedureImpl(comms,opName,cohortMonitor,WAKE_FREQUENCY,TIMEOUT));
    Mockito.doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        int index=elem[0];
        if (index == memberErrorIndex) {
          LOG.debug(""String_Node_Str"");
          ForeignException remoteCause=new ForeignException(""String_Node_Str"",new TimeoutException(""String_Node_Str"",1,2,0));
          Subprocedure r=((Subprocedure)invocation.getMock());
          LOG.error(""String_Node_Str"" + remoteCause);
          comms.receiveAbortProcedure(r.getName(),remoteCause);
          assertTrue(r.isComplete());
          try {
            Procedure.waitForLatch(coordinatorReceivedErrorLatch,new ForeignExceptionDispatcher(),WAKE_FREQUENCY,""String_Node_Str"");
          }
 catch (          InterruptedException e) {
            LOG.debug(""String_Node_Str"" + (coordinatorReceivedErrorLatch.getCount() == 0));
            Thread.currentThread().interrupt();
          }
        }
        elem[0]=++index;
        return null;
      }
    }
).when(commit).acquireBarrier();
    cohortTasks.add(commit);
  }
  final AtomicInteger taskIndex=new AtomicInteger();
  Mockito.when(subprocFactory.buildSubprocedure(Mockito.eq(opName),(byte[])Mockito.argThat(new ArrayEquals(data)))).thenAnswer(new Answer<Subprocedure>(){
    @Override public Subprocedure answer(    InvocationOnMock invocation) throws Throwable {
      int index=taskIndex.getAndIncrement();
      Subprocedure commit=cohortTasks.get(index);
      return commit;
    }
  }
);
  ForeignExceptionDispatcher coordinatorTaskErrorMonitor=Mockito.spy(new ForeignExceptionDispatcher());
  Procedure coordinatorTask=Mockito.spy(new Procedure(coordinator,coordinatorTaskErrorMonitor,WAKE_FREQUENCY,TIMEOUT,opName,data,expected));
  when(coordinator.createProcedure(any(),eq(opName),eq(data),anyListOf(String.class))).thenReturn(coordinatorTask);
  Mockito.doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      invocation.callRealMethod();
      coordinatorReceivedErrorLatch.countDown();
      return null;
    }
  }
).when(coordinatorTask).receive(Mockito.any());
  Procedure task=coordinator.startProcedure(coordinatorTaskErrorMonitor,opName,data,expected);
  assertEquals(""String_Node_Str"",coordinatorTask,task);
  try {
    task.waitForCompleted();
  }
 catch (  ForeignException fe) {
  }
  waitAndVerifyProc(coordinatorTask,once,never(),once,atMost(1),true);
  verifyCohortSuccessful(expected,subprocFactory,cohortTasks,once,never(),once,once,true);
  closeAll(coordinator,coordinatorController,members);
}",0.9981045824506634
60868,"@Test public void testDelete_CheckFamily() throws IOException {
  byte[] row1=Bytes.toBytes(""String_Node_Str"");
  byte[] fam1=Bytes.toBytes(""String_Node_Str"");
  byte[] fam2=Bytes.toBytes(""String_Node_Str"");
  byte[] fam3=Bytes.toBytes(""String_Node_Str"");
  byte[] fam4=Bytes.toBytes(""String_Node_Str"");
  this.region=initHRegion(tableName,method,CONF,fam1,fam2,fam3);
  try {
    List<Cell> kvs=new ArrayList<>();
    kvs.add(new KeyValue(row1,fam4,null,null));
    byte[] family=fam2;
    try {
      NavigableMap<byte[],List<Cell>> deleteMap=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      deleteMap.put(family,kvs);
      region.delete(deleteMap,Durability.SYNC_WAL);
    }
 catch (    Exception e) {
      fail(""String_Node_Str"" + new String(family,StandardCharsets.UTF_8) + ""String_Node_Str"");
    }
    boolean ok=false;
    family=fam4;
    try {
      NavigableMap<byte[],List<Cell>> deleteMap=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      deleteMap.put(family,kvs);
      region.delete(deleteMap,Durability.SYNC_WAL);
    }
 catch (    Exception e) {
      ok=true;
    }
    assertEquals(""String_Node_Str"" + new String(family,StandardCharsets.UTF_8) + ""String_Node_Str"",true,ok);
  }
  finally {
    HBaseTestingUtility.closeRegionAndWAL(this.region);
    this.region=null;
  }
}","@Test public void testDelete_CheckFamily() throws IOException {
  byte[] row1=Bytes.toBytes(""String_Node_Str"");
  byte[] fam1=Bytes.toBytes(""String_Node_Str"");
  byte[] fam2=Bytes.toBytes(""String_Node_Str"");
  byte[] fam3=Bytes.toBytes(""String_Node_Str"");
  byte[] fam4=Bytes.toBytes(""String_Node_Str"");
  this.region=initHRegion(tableName,method,CONF,fam1,fam2,fam3);
  try {
    List<Cell> kvs=new ArrayList<>();
    kvs.add(new KeyValue(row1,fam4,null,null));
    byte[] family=fam2;
    try {
      NavigableMap<byte[],List<Cell>> deleteMap=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      deleteMap.put(family,kvs);
      region.delete(deleteMap,Durability.SYNC_WAL);
    }
 catch (    Exception e) {
      fail(""String_Node_Str"" + new String(family,StandardCharsets.UTF_8) + ""String_Node_Str"");
    }
    boolean ok=false;
    family=fam4;
    try {
      NavigableMap<byte[],List<Cell>> deleteMap=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      deleteMap.put(family,kvs);
      region.delete(deleteMap,Durability.SYNC_WAL);
    }
 catch (    Exception e) {
      ok=true;
    }
    assertTrue(""String_Node_Str"" + new String(family,StandardCharsets.UTF_8) + ""String_Node_Str"",ok);
  }
  finally {
    HBaseTestingUtility.closeRegionAndWAL(this.region);
    this.region=null;
  }
}",0.9949317738791424
60869,"/** 
 * Check if ZooKeeper JaasConfiguration is valid.
 */
@Test public void testIsZooKeeperSecure() throws Exception {
  boolean testJaasConfig=ZKUtil.isSecureZooKeeper(new Configuration(TEST_UTIL.getConfiguration()));
  assertEquals(testJaasConfig,secureZKAvailable);
  File saslConfFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileWriter fwriter=new FileWriter(saslConfFile);
  fwriter.write(""String_Node_Str"");
  fwriter.close();
  System.setProperty(""String_Node_Str"",saslConfFile.getAbsolutePath());
  testJaasConfig=ZKUtil.isSecureZooKeeper(new Configuration(TEST_UTIL.getConfiguration()));
  assertEquals(false,testJaasConfig);
  saslConfFile.delete();
}","/** 
 * Check if ZooKeeper JaasConfiguration is valid.
 */
@Test public void testIsZooKeeperSecure() throws Exception {
  boolean testJaasConfig=ZKUtil.isSecureZooKeeper(new Configuration(TEST_UTIL.getConfiguration()));
  assertEquals(testJaasConfig,secureZKAvailable);
  File saslConfFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileWriter fwriter=new FileWriter(saslConfFile);
  fwriter.write(""String_Node_Str"");
  fwriter.close();
  System.setProperty(""String_Node_Str"",saslConfFile.getAbsolutePath());
  testJaasConfig=ZKUtil.isSecureZooKeeper(new Configuration(TEST_UTIL.getConfiguration()));
  assertFalse(testJaasConfig);
  saslConfFile.delete();
}",0.9859985261606484
60870,"/** 
 * Check if Programmatic way of setting zookeeper security settings is valid.
 */
@Test public void testIsZooKeeperSecureWithProgrammaticConfig() throws Exception {
  javax.security.auth.login.Configuration.setConfiguration(new DummySecurityConfiguration());
  Configuration config=new Configuration(HBaseConfiguration.create());
  boolean testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertEquals(false,testJaasConfig);
  config.set(""String_Node_Str"",""String_Node_Str"");
  testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertEquals(false,testJaasConfig);
  config.set(HConstants.ZK_CLIENT_KEYTAB_FILE,""String_Node_Str"");
  config.set(HConstants.ZK_CLIENT_KERBEROS_PRINCIPAL,""String_Node_Str"");
  config.set(HConstants.ZK_SERVER_KEYTAB_FILE,""String_Node_Str"");
  config.set(HConstants.ZK_SERVER_KERBEROS_PRINCIPAL,""String_Node_Str"");
  testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertEquals(true,testJaasConfig);
}","/** 
 * Check if Programmatic way of setting zookeeper security settings is valid.
 */
@Test public void testIsZooKeeperSecureWithProgrammaticConfig() throws Exception {
  javax.security.auth.login.Configuration.setConfiguration(new DummySecurityConfiguration());
  Configuration config=new Configuration(HBaseConfiguration.create());
  boolean testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertFalse(testJaasConfig);
  config.set(""String_Node_Str"",""String_Node_Str"");
  testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertFalse(testJaasConfig);
  config.set(HConstants.ZK_CLIENT_KEYTAB_FILE,""String_Node_Str"");
  config.set(HConstants.ZK_CLIENT_KERBEROS_PRINCIPAL,""String_Node_Str"");
  config.set(HConstants.ZK_SERVER_KEYTAB_FILE,""String_Node_Str"");
  config.set(HConstants.ZK_SERVER_KERBEROS_PRINCIPAL,""String_Node_Str"");
  testJaasConfig=ZKUtil.isSecureZooKeeper(config);
  assertTrue(testJaasConfig);
}",0.8389876144318794
60871,"@Override public ServerSocket createServerSocket(int port) throws IOException {
  return new ServerSocket(port){
    public Socket accept() throws IOException {
      Socket socket=super.accept();
      SSLSocketFactory sslSocketFactory=(SSLSocketFactory)SSLSocketFactory.getDefault();
      SSLSocket sslSocket=(SSLSocket)sslSocketFactory.createSocket(socket,socket.getInetAddress().getHostName(),socket.getPort(),true);
      sslSocket.setUseClientMode(false);
      sslSocket.setNeedClientAuth(false);
      ArrayList<String> secureProtocols=new ArrayList<>();
      for (      String p : sslSocket.getEnabledProtocols()) {
        if (!p.contains(""String_Node_Str"")) {
          secureProtocols.add(p);
        }
      }
      sslSocket.setEnabledProtocols(secureProtocols.toArray(new String[secureProtocols.size()]));
      return sslSocket;
    }
  }
;
}","@Override public ServerSocket createServerSocket(int port) throws IOException {
  return new ServerSocket(port){
    @Override public Socket accept() throws IOException {
      Socket socket=super.accept();
      SSLSocketFactory sslSocketFactory=(SSLSocketFactory)SSLSocketFactory.getDefault();
      SSLSocket sslSocket=(SSLSocket)sslSocketFactory.createSocket(socket,socket.getInetAddress().getHostName(),socket.getPort(),true);
      sslSocket.setUseClientMode(false);
      sslSocket.setNeedClientAuth(false);
      ArrayList<String> secureProtocols=new ArrayList<>();
      for (      String p : sslSocket.getEnabledProtocols()) {
        if (!p.contains(""String_Node_Str"")) {
          secureProtocols.add(p);
        }
      }
      sslSocket.setEnabledProtocols(secureProtocols.toArray(new String[secureProtocols.size()]));
      return sslSocket;
    }
  }
;
}",0.9942196531791908
60872,"public Socket accept() throws IOException {
  Socket socket=super.accept();
  SSLSocketFactory sslSocketFactory=(SSLSocketFactory)SSLSocketFactory.getDefault();
  SSLSocket sslSocket=(SSLSocket)sslSocketFactory.createSocket(socket,socket.getInetAddress().getHostName(),socket.getPort(),true);
  sslSocket.setUseClientMode(false);
  sslSocket.setNeedClientAuth(false);
  ArrayList<String> secureProtocols=new ArrayList<>();
  for (  String p : sslSocket.getEnabledProtocols()) {
    if (!p.contains(""String_Node_Str"")) {
      secureProtocols.add(p);
    }
  }
  sslSocket.setEnabledProtocols(secureProtocols.toArray(new String[secureProtocols.size()]));
  return sslSocket;
}","@Override public Socket accept() throws IOException {
  Socket socket=super.accept();
  SSLSocketFactory sslSocketFactory=(SSLSocketFactory)SSLSocketFactory.getDefault();
  SSLSocket sslSocket=(SSLSocket)sslSocketFactory.createSocket(socket,socket.getInetAddress().getHostName(),socket.getPort(),true);
  sslSocket.setUseClientMode(false);
  sslSocket.setNeedClientAuth(false);
  ArrayList<String> secureProtocols=new ArrayList<>();
  for (  String p : sslSocket.getEnabledProtocols()) {
    if (!p.contains(""String_Node_Str"")) {
      secureProtocols.add(p);
    }
  }
  sslSocket.setEnabledProtocols(secureProtocols.toArray(new String[secureProtocols.size()]));
  return sslSocket;
}",0.9926470588235294
60873,"public void run(){
  final LockHeartbeatRequest lockHeartbeatRequest=LockHeartbeatRequest.newBuilder().setProcId(procId).build();
  LockHeartbeatResponse response;
  while (true) {
    try {
      response=stub.lockHeartbeat(null,lockHeartbeatRequest);
    }
 catch (    Exception e) {
      e=ProtobufUtil.handleRemoteException(e);
      locked.set(false);
      LOG.error(""String_Node_Str"" + EntityLock.this,e);
      abort.abort(""String_Node_Str"",e);
      return;
    }
    if (!isLocked() && response.getLockStatus() == LockHeartbeatResponse.LockStatus.LOCKED) {
      locked.set(true);
      latch.countDown();
    }
 else     if (isLocked() && response.getLockStatus() == LockHeartbeatResponse.LockStatus.UNLOCKED) {
      locked.set(false);
      abort.abort(""String_Node_Str"",null);
      return;
    }
    try {
      long sleepTime=1000;
      if (isLocked()) {
        sleepTime=Math.max(response.getTimeoutMs() - heartbeatTimeBuffer,1);
      }
      if (testingSleepTime != 0) {
        sleepTime=testingSleepTime;
      }
      Thread.sleep(sleepTime);
    }
 catch (    InterruptedException e) {
      locked.set(false);
      if (!this.shutdown) {
        LOG.error(""String_Node_Str"" + this,e);
        abort.abort(""String_Node_Str"",e);
      }
      return;
    }
  }
}","@Override public void run(){
  final LockHeartbeatRequest lockHeartbeatRequest=LockHeartbeatRequest.newBuilder().setProcId(procId).build();
  LockHeartbeatResponse response;
  while (true) {
    try {
      response=stub.lockHeartbeat(null,lockHeartbeatRequest);
    }
 catch (    Exception e) {
      e=ProtobufUtil.handleRemoteException(e);
      locked.set(false);
      LOG.error(""String_Node_Str"" + EntityLock.this,e);
      abort.abort(""String_Node_Str"",e);
      return;
    }
    if (!isLocked() && response.getLockStatus() == LockHeartbeatResponse.LockStatus.LOCKED) {
      locked.set(true);
      latch.countDown();
    }
 else     if (isLocked() && response.getLockStatus() == LockHeartbeatResponse.LockStatus.UNLOCKED) {
      locked.set(false);
      abort.abort(""String_Node_Str"",null);
      return;
    }
    try {
      long sleepTime=1000;
      if (isLocked()) {
        sleepTime=Math.max(response.getTimeoutMs() - heartbeatTimeBuffer,1);
      }
      if (testingSleepTime != 0) {
        sleepTime=testingSleepTime;
      }
      Thread.sleep(sleepTime);
    }
 catch (    InterruptedException e) {
      locked.set(false);
      if (!this.shutdown) {
        LOG.error(""String_Node_Str"" + this,e);
        abort.abort(""String_Node_Str"",e);
      }
      return;
    }
  }
}",0.9961300309597524
60874,"@SuppressWarnings(""String_Node_Str"") RowProcessor<S,T> constructRowProcessorFromRequest(ProcessRequest request) throws IOException {
  String className=request.getRowProcessorClassName();
  Class<?> cls;
  try {
    cls=Class.forName(className);
    RowProcessor<S,T> ci=(RowProcessor<S,T>)cls.newInstance();
    if (request.hasRowProcessorInitializerMessageName()) {
      Class<?> imn=Class.forName(request.getRowProcessorInitializerMessageName()).asSubclass(Message.class);
      Method m;
      try {
        m=imn.getMethod(""String_Node_Str"",ByteString.class);
      }
 catch (      SecurityException e) {
        throw new IOException(e);
      }
catch (      NoSuchMethodException e) {
        throw new IOException(e);
      }
      S s;
      try {
        s=(S)m.invoke(null,request.getRowProcessorInitializerMessage());
      }
 catch (      IllegalArgumentException e) {
        throw new IOException(e);
      }
catch (      InvocationTargetException e) {
        throw new IOException(e);
      }
      ci.initialize(s);
    }
    return ci;
  }
 catch (  ClassNotFoundException e) {
    throw new IOException(e);
  }
catch (  InstantiationException e) {
    throw new IOException(e);
  }
catch (  IllegalAccessException e) {
    throw new IOException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") RowProcessor<S,T> constructRowProcessorFromRequest(ProcessRequest request) throws IOException {
  String className=request.getRowProcessorClassName();
  Class<?> cls;
  try {
    cls=Class.forName(className);
    RowProcessor<S,T> ci=(RowProcessor<S,T>)cls.getDeclaredConstructor().newInstance();
    if (request.hasRowProcessorInitializerMessageName()) {
      Class<?> imn=Class.forName(request.getRowProcessorInitializerMessageName()).asSubclass(Message.class);
      Method m;
      try {
        m=imn.getMethod(""String_Node_Str"",ByteString.class);
      }
 catch (      SecurityException e) {
        throw new IOException(e);
      }
catch (      NoSuchMethodException e) {
        throw new IOException(e);
      }
      S s;
      try {
        s=(S)m.invoke(null,request.getRowProcessorInitializerMessage());
      }
 catch (      IllegalArgumentException e) {
        throw new IOException(e);
      }
catch (      InvocationTargetException e) {
        throw new IOException(e);
      }
      ci.initialize(s);
    }
    return ci;
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}",0.9256198347107438
60875,"void callObserver() throws IOException {
  Optional<O> observer=observerGetter.apply(getEnvironment().getInstance());
  if (observer.isPresent()) {
    result=call(observer.get());
  }
}","@Override void callObserver() throws IOException {
  Optional<O> observer=observerGetter.apply(getEnvironment().getInstance());
  if (observer.isPresent()) {
    result=call(observer.get());
  }
}",0.9738219895287958
60876,"public void bypass(){
  if (!this.bypassable) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  bypass=true;
}","@Override public void bypass(){
  if (!this.bypassable) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  bypass=true;
}",0.9635036496350364
60877,"public Optional<User> getCaller(){
  return Optional.ofNullable(caller);
}","@Override public Optional<User> getCaller(){
  return Optional.ofNullable(caller);
}",0.9367088607594936
60878,"public E getEnvironment(){
  return env;
}","@Override public E getEnvironment(){
  return env;
}",0.8936170212765957
60879,"@Override public void unset(String name){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public synchronized void unset(String name){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9417040358744396
60880,"@Override public void setQuietMode(boolean quietmode){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public synchronized void setQuietMode(boolean quietmode){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9477911646586346
60881,"@Override public String[] getPropertySources(String name){
  return conf.getPropertySources(name);
}","@Override public synchronized String[] getPropertySources(String name){
  return conf.getPropertySources(name);
}",0.9389671361502347
60882,"@Override public void reloadConfiguration(){
  this.conf.reloadConfiguration();
}","@Override public synchronized void reloadConfiguration(){
  this.conf.reloadConfiguration();
}",0.9257142857142856
60883,"@Override public void setIfUnset(String name,String value){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public synchronized void setIfUnset(String name,String value){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9498069498069498
60884,"@Override public Class<?>[] getClasses(String name,Class<?>[] defaultValue){
  return conf.getClasses(name,defaultValue);
}","@Override public Class<?>[] getClasses(String name,Class<?>... defaultValue){
  return conf.getClasses(name,defaultValue);
}",0.979757085020243
60885,"public ReturnCode filterCell(final Cell c) throws IOException {
  return this.filter.filterCell(c);
}","@Override public ReturnCode filterCell(final Cell c) throws IOException {
  return this.filter.filterCell(c);
}",0.9528301886792452
60886,"private static ClientProtocol createReorderingProxy(final ClientProtocol cp,final ReorderBlocks lrb,final Configuration conf){
  return (ClientProtocol)Proxy.newProxyInstance(cp.getClass().getClassLoader(),new Class[]{ClientProtocol.class,Closeable.class},new InvocationHandler(){
    public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      try {
        if ((args == null || args.length == 0) && ""String_Node_Str"".equals(method.getName())) {
          RPC.stopProxy(cp);
          return null;
        }
 else {
          Object res=method.invoke(cp,args);
          if (res != null && args != null && args.length == 3 && ""String_Node_Str"".equals(method.getName()) && res instanceof LocatedBlocks && args[0] instanceof String && args[0] != null) {
            lrb.reorderBlocks(conf,(LocatedBlocks)res,(String)args[0]);
          }
          return res;
        }
      }
 catch (      InvocationTargetException ite) {
        Throwable cause=ite.getCause();
        if (cause == null) {
          throw new RuntimeException(""String_Node_Str"",ite);
        }
        if (cause instanceof UndeclaredThrowableException) {
          Throwable causeCause=cause.getCause();
          if (causeCause == null) {
            throw new RuntimeException(""String_Node_Str"");
          }
          cause=cause.getCause();
        }
        throw cause;
      }
    }
  }
);
}","private static ClientProtocol createReorderingProxy(final ClientProtocol cp,final ReorderBlocks lrb,final Configuration conf){
  return (ClientProtocol)Proxy.newProxyInstance(cp.getClass().getClassLoader(),new Class[]{ClientProtocol.class,Closeable.class},new InvocationHandler(){
    @Override public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      try {
        if ((args == null || args.length == 0) && ""String_Node_Str"".equals(method.getName())) {
          RPC.stopProxy(cp);
          return null;
        }
 else {
          Object res=method.invoke(cp,args);
          if (res != null && args != null && args.length == 3 && ""String_Node_Str"".equals(method.getName()) && res instanceof LocatedBlocks && args[0] instanceof String && args[0] != null) {
            lrb.reorderBlocks(conf,(LocatedBlocks)res,(String)args[0]);
          }
          return res;
        }
      }
 catch (      InvocationTargetException ite) {
        Throwable cause=ite.getCause();
        if (cause == null) {
          throw new RuntimeException(""String_Node_Str"",ite);
        }
        if (cause instanceof UndeclaredThrowableException) {
          Throwable causeCause=cause.getCause();
          if (causeCause == null) {
            throw new RuntimeException(""String_Node_Str"");
          }
          cause=cause.getCause();
        }
        throw cause;
      }
    }
  }
);
}",0.9964614295824488
60887,"public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  try {
    if ((args == null || args.length == 0) && ""String_Node_Str"".equals(method.getName())) {
      RPC.stopProxy(cp);
      return null;
    }
 else {
      Object res=method.invoke(cp,args);
      if (res != null && args != null && args.length == 3 && ""String_Node_Str"".equals(method.getName()) && res instanceof LocatedBlocks && args[0] instanceof String && args[0] != null) {
        lrb.reorderBlocks(conf,(LocatedBlocks)res,(String)args[0]);
      }
      return res;
    }
  }
 catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause == null) {
      throw new RuntimeException(""String_Node_Str"",ite);
    }
    if (cause instanceof UndeclaredThrowableException) {
      Throwable causeCause=cause.getCause();
      if (causeCause == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      cause=cause.getCause();
    }
    throw cause;
  }
}","@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  try {
    if ((args == null || args.length == 0) && ""String_Node_Str"".equals(method.getName())) {
      RPC.stopProxy(cp);
      return null;
    }
 else {
      Object res=method.invoke(cp,args);
      if (res != null && args != null && args.length == 3 && ""String_Node_Str"".equals(method.getName()) && res instanceof LocatedBlocks && args[0] instanceof String && args[0] != null) {
        lrb.reorderBlocks(conf,(LocatedBlocks)res,(String)args[0]);
      }
      return res;
    }
  }
 catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause == null) {
      throw new RuntimeException(""String_Node_Str"",ite);
    }
    if (cause instanceof UndeclaredThrowableException) {
      Throwable causeCause=cause.getCause();
      if (causeCause == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      cause=cause.getCause();
    }
    throw cause;
  }
}",0.994994994994995
60888,"public void reorderBlocks(Configuration conf,LocatedBlocks lbs,String src) throws IOException {
  ServerName sn=AbstractFSWALProvider.getServerNameFromWALDirectoryName(conf,src);
  if (sn == null) {
    return;
  }
  String hostName=sn.getHostname();
  if (LOG.isTraceEnabled()) {
    LOG.trace(src + ""String_Node_Str"" + hostName);
  }
  for (  LocatedBlock lb : lbs.getLocatedBlocks()) {
    DatanodeInfo[] dnis=lb.getLocations();
    if (dnis != null && dnis.length > 1) {
      boolean found=false;
      for (int i=0; i < dnis.length - 1 && !found; i++) {
        if (hostName.equals(dnis[i].getHostName())) {
          DatanodeInfo toLast=dnis[i];
          System.arraycopy(dnis,i + 1,dnis,i,dnis.length - i - 1);
          dnis[dnis.length - 1]=toLast;
          found=true;
        }
      }
    }
  }
}","@Override public void reorderBlocks(Configuration conf,LocatedBlocks lbs,String src) throws IOException {
  ServerName sn=AbstractFSWALProvider.getServerNameFromWALDirectoryName(conf,src);
  if (sn == null) {
    return;
  }
  String hostName=sn.getHostname();
  if (LOG.isTraceEnabled()) {
    LOG.trace(src + ""String_Node_Str"" + hostName);
  }
  for (  LocatedBlock lb : lbs.getLocatedBlocks()) {
    DatanodeInfo[] dnis=lb.getLocations();
    if (dnis != null && dnis.length > 1) {
      boolean found=false;
      for (int i=0; i < dnis.length - 1 && !found; i++) {
        if (hostName.equals(dnis[i].getHostName())) {
          DatanodeInfo toLast=dnis[i];
          System.arraycopy(dnis,i + 1,dnis,i,dnis.length - i - 1);
          dnis[dnis.length - 1]=toLast;
          found=true;
        }
      }
    }
  }
}",0.993872549019608
60889,"/** 
 * The org.apache.hadoop.fs.FilterFileSystem does not yet support  createNonRecursive. This is a hadoop bug and when it is fixed in Hadoop, this definition will go away.
 */
@SuppressWarnings(""String_Node_Str"") public FSDataOutputStream createNonRecursive(Path f,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable progress) throws IOException {
  return fs.createNonRecursive(f,overwrite,bufferSize,replication,blockSize,progress);
}","/** 
 * The org.apache.hadoop.fs.FilterFileSystem does not yet support  createNonRecursive. This is a hadoop bug and when it is fixed in Hadoop, this definition will go away.
 */
@Override @SuppressWarnings(""String_Node_Str"") public FSDataOutputStream createNonRecursive(Path f,boolean overwrite,int bufferSize,short replication,long blockSize,Progressable progress) throws IOException {
  return fs.createNonRecursive(f,overwrite,bufferSize,replication,blockSize,progress);
}",0.989384288747346
60890,"/** 
 * Read from non-checksum stream failed, fall back to FS checksum. Thread-safe.
 * @param offCount For how many checksumOk calls to turn off the HBase checksum.
 */
public FSDataInputStream fallbackToFsChecksum(int offCount) throws IOException {
  boolean partOfConvoy=false;
  if (this.stream == null) {
synchronized (streamNoFsChecksumFirstCreateLock) {
      partOfConvoy=(this.stream != null);
      if (!partOfConvoy) {
        this.stream=(link != null) ? link.open(hfs) : hfs.open(path);
      }
    }
  }
  if (!partOfConvoy) {
    this.useHBaseChecksum=false;
    this.hbaseChecksumOffCount=offCount;
  }
  return this.stream;
}","/** 
 * Read from non-checksum stream failed, fall back to FS checksum. Thread-safe.
 * @param offCount For how many checksumOk calls to turn off the HBase checksum.
 */
public FSDataInputStream fallbackToFsChecksum(int offCount) throws IOException {
  boolean partOfConvoy=false;
  if (this.stream == null) {
synchronized (streamNoFsChecksumFirstCreateLock) {
      partOfConvoy=(this.stream != null);
      if (!partOfConvoy) {
        this.stream=(link != null) ? link.open(hfs) : hfs.open(path);
      }
    }
  }
  if (!partOfConvoy) {
    this.useHBaseChecksum=false;
    this.hbaseChecksumOffCount.set(offCount);
  }
  return this.stream;
}",0.9821567106283942
60891,"public String getValueString(){
  if (atEnd)   return null;
  return delegate.getValueString();
}","@Override public String getValueString(){
  if (atEnd)   return null;
  return delegate.getValueString();
}",0.9509803921568628
60892,"public boolean next() throws IOException {
  if (atEnd)   return false;
  boolean b=delegate.next();
  if (!b) {
    return b;
  }
  if (!top) {
    if (getComparator().compare(splitCell,getKey()) <= 0) {
      atEnd=true;
      return false;
    }
  }
  return true;
}","@Override public boolean next() throws IOException {
  if (atEnd)   return false;
  boolean b=delegate.next();
  if (!b) {
    return b;
  }
  if (!top) {
    if (getComparator().compare(splitCell,getKey()) <= 0) {
      atEnd=true;
      return false;
    }
  }
  return true;
}",0.9817518248175182
60893,"public Cell getKey(){
  if (atEnd)   return null;
  return delegate.getKey();
}","@Override public Cell getKey(){
  if (atEnd)   return null;
  return delegate.getKey();
}",0.9404761904761904
60894,"public Cell getCell(){
  if (atEnd)   return null;
  return delegate.getCell();
}","@Override public Cell getCell(){
  if (atEnd)   return null;
  return delegate.getCell();
}",0.9418604651162792
60895,"public org.apache.hadoop.hbase.io.hfile.HFile.Reader getReader(){
  return this.delegate.getReader();
}","@Override public org.apache.hadoop.hbase.io.hfile.HFile.Reader getReader(){
  return this.delegate.getReader();
}",0.9537037037037036
60896,"public boolean isSeeked(){
  return this.delegate.isSeeked();
}","@Override public boolean isSeeked(){
  return this.delegate.isSeeked();
}",0.9264705882352942
60897,"public String getKeyString(){
  if (atEnd)   return null;
  return delegate.getKeyString();
}","@Override public String getKeyString(){
  if (atEnd)   return null;
  return delegate.getKeyString();
}",0.9489795918367347
60898,"public ByteBuffer getValue(){
  if (atEnd)   return null;
  return delegate.getValue();
}","@Override public ByteBuffer getValue(){
  if (atEnd)   return null;
  return delegate.getValue();
}",0.946808510638298
60899,"@Override public HFileScanner getScanner(final boolean cacheBlocks,final boolean pread,final boolean isCompaction){
  final HFileScanner s=super.getScanner(cacheBlocks,pread,isCompaction);
  return new HFileScanner(){
    final HFileScanner delegate=s;
    public boolean atEnd=false;
    public Cell getKey(){
      if (atEnd)       return null;
      return delegate.getKey();
    }
    public String getKeyString(){
      if (atEnd)       return null;
      return delegate.getKeyString();
    }
    public ByteBuffer getValue(){
      if (atEnd)       return null;
      return delegate.getValue();
    }
    public String getValueString(){
      if (atEnd)       return null;
      return delegate.getValueString();
    }
    public Cell getCell(){
      if (atEnd)       return null;
      return delegate.getCell();
    }
    public boolean next() throws IOException {
      if (atEnd)       return false;
      boolean b=delegate.next();
      if (!b) {
        return b;
      }
      if (!top) {
        if (getComparator().compare(splitCell,getKey()) <= 0) {
          atEnd=true;
          return false;
        }
      }
      return true;
    }
    @Override public boolean seekTo() throws IOException {
      if (top) {
        int r=this.delegate.seekTo(splitCell);
        if (r == HConstants.INDEX_KEY_MAGIC) {
          return true;
        }
        if (r < 0) {
          return this.delegate.seekTo();
        }
        if (r > 0) {
          return this.delegate.next();
        }
        return true;
      }
      boolean b=delegate.seekTo();
      if (!b) {
        return b;
      }
      return (this.delegate.getReader().getComparator().compare(splitCell,getKey())) > 0;
    }
    public org.apache.hadoop.hbase.io.hfile.HFile.Reader getReader(){
      return this.delegate.getReader();
    }
    public boolean isSeeked(){
      return this.delegate.isSeeked();
    }
    @Override public int seekTo(    Cell key) throws IOException {
      if (top) {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
          }
          return 1;
        }
      }
      return delegate.seekTo(key);
    }
    @Override public int reseekTo(    Cell key) throws IOException {
      if (top) {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
          }
          return 1;
        }
      }
      if (atEnd) {
        return 1;
      }
      return delegate.reseekTo(key);
    }
    @Override public boolean seekBefore(    Cell key) throws IOException {
      if (top) {
        Optional<Cell> fk=getFirstKey();
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,fk.get()) <= 0) {
          return false;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean ret=this.delegate.seekBefore(splitCell);
          if (ret) {
            atEnd=false;
          }
          return ret;
        }
      }
      boolean ret=this.delegate.seekBefore(key);
      if (ret) {
        atEnd=false;
      }
      return ret;
    }
    @Override public Cell getNextIndexedKey(){
      return null;
    }
    @Override public void close(){
      this.delegate.close();
    }
    @Override public void shipped() throws IOException {
      this.delegate.shipped();
    }
  }
;
}","@Override public HFileScanner getScanner(final boolean cacheBlocks,final boolean pread,final boolean isCompaction){
  final HFileScanner s=super.getScanner(cacheBlocks,pread,isCompaction);
  return new HFileScanner(){
    final HFileScanner delegate=s;
    public boolean atEnd=false;
    @Override public Cell getKey(){
      if (atEnd)       return null;
      return delegate.getKey();
    }
    @Override public String getKeyString(){
      if (atEnd)       return null;
      return delegate.getKeyString();
    }
    @Override public ByteBuffer getValue(){
      if (atEnd)       return null;
      return delegate.getValue();
    }
    @Override public String getValueString(){
      if (atEnd)       return null;
      return delegate.getValueString();
    }
    @Override public Cell getCell(){
      if (atEnd)       return null;
      return delegate.getCell();
    }
    @Override public boolean next() throws IOException {
      if (atEnd)       return false;
      boolean b=delegate.next();
      if (!b) {
        return b;
      }
      if (!top) {
        if (getComparator().compare(splitCell,getKey()) <= 0) {
          atEnd=true;
          return false;
        }
      }
      return true;
    }
    @Override public boolean seekTo() throws IOException {
      if (top) {
        int r=this.delegate.seekTo(splitCell);
        if (r == HConstants.INDEX_KEY_MAGIC) {
          return true;
        }
        if (r < 0) {
          return this.delegate.seekTo();
        }
        if (r > 0) {
          return this.delegate.next();
        }
        return true;
      }
      boolean b=delegate.seekTo();
      if (!b) {
        return b;
      }
      return (this.delegate.getReader().getComparator().compare(splitCell,getKey())) > 0;
    }
    @Override public org.apache.hadoop.hbase.io.hfile.HFile.Reader getReader(){
      return this.delegate.getReader();
    }
    @Override public boolean isSeeked(){
      return this.delegate.isSeeked();
    }
    @Override public int seekTo(    Cell key) throws IOException {
      if (top) {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
          }
          return 1;
        }
      }
      return delegate.seekTo(key);
    }
    @Override public int reseekTo(    Cell key) throws IOException {
      if (top) {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
          }
          return 1;
        }
      }
      if (atEnd) {
        return 1;
      }
      return delegate.reseekTo(key);
    }
    @Override public boolean seekBefore(    Cell key) throws IOException {
      if (top) {
        Optional<Cell> fk=getFirstKey();
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,fk.get()) <= 0) {
          return false;
        }
      }
 else {
        if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(),key,splitCell) >= 0) {
          boolean ret=this.delegate.seekBefore(splitCell);
          if (ret) {
            atEnd=false;
          }
          return ret;
        }
      }
      boolean ret=this.delegate.seekBefore(key);
      if (ret) {
        atEnd=false;
      }
      return ret;
    }
    @Override public Cell getNextIndexedKey(){
      return null;
    }
    @Override public void close(){
      this.delegate.close();
    }
    @Override public void shipped() throws IOException {
      this.delegate.shipped();
    }
  }
;
}",0.989909182643794
60900,"public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null)   return false;
  if (!(o instanceof Reference))   return false;
  Reference r=(Reference)o;
  if (splitkey != null && r.splitkey == null)   return false;
  if (splitkey == null && r.splitkey != null)   return false;
  if (splitkey != null && !Arrays.equals(splitkey,r.splitkey))   return false;
  return region.equals(r.region);
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null)   return false;
  if (!(o instanceof Reference))   return false;
  Reference r=(Reference)o;
  if (splitkey != null && r.splitkey == null)   return false;
  if (splitkey == null && r.splitkey != null)   return false;
  if (splitkey != null && !Arrays.equals(splitkey,r.splitkey))   return false;
  return region.equals(r.region);
}",0.9880382775119616
60901,"public int getQueueSize(){
  return pool.getQueue().size();
}","@Override public int getQueueSize(){
  return pool.getQueue().size();
}",0.9242424242424242
60902,"public Thread newThread(Runnable r){
  Thread t=new Thread(group,r,namePrefix + threadNumber.getAndIncrement(),0);
  if (!t.isDaemon()) {
    t.setDaemon(true);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}","@Override public Thread newThread(Runnable r){
  Thread t=new Thread(group,r,namePrefix + threadNumber.getAndIncrement(),0);
  if (!t.isDaemon()) {
    t.setDaemon(true);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}",0.9819494584837544
60903,"public void setMaxQueueSize(int newSize){
  this.maxQueueSize=newSize;
}","@Override public void setMaxQueueSize(int newSize){
  this.maxQueueSize=newSize;
}",0.935064935064935
60904,"public void setMaxPoolSize(int newMaxSize){
  pool.setMaximumPoolSize(newMaxSize);
}","@Override public void setMaxPoolSize(int newMaxSize){
  pool.setMaximumPoolSize(newMaxSize);
}",0.9438202247191012
60905,"public long getPoolCompletedTaskCount(){
  return pool.getCompletedTaskCount();
}","@Override public long getPoolCompletedTaskCount(){
  return pool.getCompletedTaskCount();
}",0.9418604651162792
60906,"public int getMaxQueueSize(){
  return this.maxQueueSize;
}","@Override public int getMaxQueueSize(){
  return this.maxQueueSize;
}",0.921875
60907,"public int getCorePoolSize(){
  return pool.getCorePoolSize();
}","@Override public int getCorePoolSize(){
  return pool.getCorePoolSize();
}",0.927536231884058
60908,"public long getTotalIncrements(){
  return totalIncrements.sum();
}","@Override public long getTotalIncrements(){
  return totalIncrements.sum();
}",0.9305555555555556
60909,"public long getSuccessfulCoalescings(){
  return successfulCoalescings.sum();
}","@Override public long getSuccessfulCoalescings(){
  return successfulCoalescings.sum();
}",0.9404761904761904
60910,"public long getPoolTaskCount(){
  return pool.getTaskCount();
}","@Override public long getPoolTaskCount(){
  return pool.getTaskCount();
}",0.9264705882352942
60911,"public int getMaxPoolSize(){
  return pool.getMaximumPoolSize();
}","@Override public int getMaxPoolSize(){
  return pool.getMaximumPoolSize();
}",0.9295774647887324
60912,"public int getPoolLargestPoolSize(){
  return pool.getLargestPoolSize();
}","@Override public int getPoolLargestPoolSize(){
  return pool.getLargestPoolSize();
}",0.9367088607594936
60913,"public long getCountersMapSize(){
  return countersMap.size();
}","@Override public long getCountersMapSize(){
  return countersMap.size();
}",0.927536231884058
60914,"public long getFailedIncrements(){
  return failedIncrements.sum();
}","@Override public long getFailedIncrements(){
  return failedIncrements.sum();
}",0.9324324324324323
60915,"public void setCorePoolSize(int newCoreSize){
  pool.setCorePoolSize(newCoreSize);
}","@Override public void setCorePoolSize(int newCoreSize){
  pool.setCorePoolSize(newCoreSize);
}",0.9438202247191012
60916,"/** 
 * Loops on processing a client forever
 */
public void run(){
  TProcessor processor=null;
  TTransport inputTransport=null;
  TTransport outputTransport=null;
  TProtocol inputProtocol=null;
  TProtocol outputProtocol=null;
  try {
    processor=processorFactory_.getProcessor(client);
    inputTransport=inputTransportFactory_.getTransport(client);
    outputTransport=outputTransportFactory_.getTransport(client);
    inputProtocol=inputProtocolFactory_.getProtocol(inputTransport);
    outputProtocol=outputProtocolFactory_.getProtocol(outputTransport);
    while (!stopped && processor.process(inputProtocol,outputProtocol)) {
    }
  }
 catch (  TTransportException ttx) {
  }
catch (  TException tx) {
    LOG.error(""String_Node_Str"",tx);
  }
catch (  Exception x) {
    LOG.error(""String_Node_Str"",x);
  }
  if (inputTransport != null) {
    inputTransport.close();
  }
  if (outputTransport != null) {
    outputTransport.close();
  }
}","/** 
 * Loops on processing a client forever
 */
@Override public void run(){
  TProcessor processor=null;
  TTransport inputTransport=null;
  TTransport outputTransport=null;
  TProtocol inputProtocol=null;
  TProtocol outputProtocol=null;
  try {
    processor=processorFactory_.getProcessor(client);
    inputTransport=inputTransportFactory_.getTransport(client);
    outputTransport=outputTransportFactory_.getTransport(client);
    inputProtocol=inputProtocolFactory_.getProtocol(inputTransport);
    outputProtocol=outputProtocolFactory_.getProtocol(outputTransport);
    while (!stopped && processor.process(inputProtocol,outputProtocol)) {
    }
  }
 catch (  TTransportException ttx) {
  }
catch (  TException tx) {
    LOG.error(""String_Node_Str"",tx);
  }
catch (  Exception x) {
    LOG.error(""String_Node_Str"",x);
  }
  if (inputTransport != null) {
    inputTransport.close();
  }
  if (outputTransport != null) {
    outputTransport.close();
  }
}",0.9947698744769874
60917,"public void serve(){
  try {
    serverTransport_.listen();
  }
 catch (  TTransportException ttx) {
    LOG.error(""String_Node_Str"",ttx);
    return;
  }
  Runtime.getRuntime().addShutdownHook(new Thread(getClass().getSimpleName() + ""String_Node_Str""){
    @Override public void run(){
      TBoundedThreadPoolServer.this.stop();
    }
  }
);
  stopped=false;
  while (!stopped && !Thread.interrupted()) {
    TTransport client=null;
    try {
      client=serverTransport_.accept();
    }
 catch (    TTransportException ttx) {
      if (!stopped) {
        LOG.warn(""String_Node_Str"",ttx);
        continue;
      }
 else {
        break;
      }
    }
    ClientConnnection command=new ClientConnnection(client);
    try {
      executorService.execute(command);
    }
 catch (    RejectedExecutionException rex) {
      if (client.getClass() == TSocket.class) {
        LOG.warn(QUEUE_FULL_MSG + ""String_Node_Str"" + ((TSocket)client).getSocket().getRemoteSocketAddress());
      }
 else {
        LOG.warn(QUEUE_FULL_MSG,rex);
      }
      client.close();
    }
  }
  shutdownServer();
}","@Override public void serve(){
  try {
    serverTransport_.listen();
  }
 catch (  TTransportException ttx) {
    LOG.error(""String_Node_Str"",ttx);
    return;
  }
  Runtime.getRuntime().addShutdownHook(new Thread(getClass().getSimpleName() + ""String_Node_Str""){
    @Override public void run(){
      TBoundedThreadPoolServer.this.stop();
    }
  }
);
  stopped=false;
  while (!stopped && !Thread.interrupted()) {
    TTransport client=null;
    try {
      client=serverTransport_.accept();
    }
 catch (    TTransportException ttx) {
      if (!stopped) {
        LOG.warn(""String_Node_Str"",ttx);
        continue;
      }
 else {
        break;
      }
    }
    ClientConnnection command=new ClientConnnection(client);
    try {
      executorService.execute(command);
    }
 catch (    RejectedExecutionException rex) {
      if (client.getClass() == TSocket.class) {
        LOG.warn(QUEUE_FULL_MSG + ""String_Node_Str"" + ((TSocket)client).getSocket().getRemoteSocketAddress());
      }
 else {
        LOG.warn(QUEUE_FULL_MSG,rex);
      }
      client.close();
    }
  }
  shutdownServer();
}",0.9954462659380692
60918,"@Override public Throwable getCause(){
  return cause;
}","@Override public synchronized Throwable getCause(){
  return cause;
}",0.896
60919,"@Override public Throwable getCause(){
  return cause;
}","@Override public synchronized Throwable getCause(){
  return cause;
}",0.896
60920,"@Parameters public static Collection<Object[]> getParameters(){
  Collection<Object[]> parameters=new ArrayList<>();
  for (  int elementsAdded : new int[]{100,200,300}) {
    for (    int elementsRemoved : new int[]{0,20,100}) {
      parameters.add(new Object[]{new Integer(elementsAdded),new Integer(elementsRemoved)});
    }
  }
  return parameters;
}","@Parameters public static Collection<Object[]> getParameters(){
  Collection<Object[]> parameters=new ArrayList<>();
  for (  int elementsAdded : new int[]{100,200,300}) {
    for (    int elementsRemoved : new int[]{0,20,100}) {
      parameters.add(new Object[]{elementsAdded,elementsRemoved});
    }
  }
  return parameters;
}",0.95906432748538
60921,"public static void dropTestTables(Hbase.Iface handler) throws Exception {
  handler.disableTable(tableBname);
  assertFalse(handler.isTableEnabled(tableBname));
  handler.deleteTable(tableBname);
  assertEquals(handler.getTableNames().size(),1);
  handler.disableTable(tableAname);
  assertFalse(handler.isTableEnabled(tableAname));
  handler.deleteTable(tableAname);
  assertEquals(handler.getTableNames().size(),0);
}","public static void dropTestTables(Hbase.Iface handler) throws Exception {
  handler.disableTable(tableBname);
  assertFalse(handler.isTableEnabled(tableBname));
  handler.deleteTable(tableBname);
  assertEquals(1,handler.getTableNames().size());
  handler.disableTable(tableAname);
  assertFalse(handler.isTableEnabled(tableAname));
  handler.deleteTable(tableAname);
  assertEquals(0,handler.getTableNames().size());
}",0.9904534606205252
60922,"public static void createTestTables(Hbase.Iface handler) throws Exception {
  assertEquals(handler.getTableNames().size(),0);
  handler.createTable(tableAname,getColumnDescriptors());
  assertEquals(handler.getTableNames().size(),1);
  assertEquals(handler.getColumnDescriptors(tableAname).size(),2);
  assertTrue(handler.isTableEnabled(tableAname));
  handler.createTable(tableBname,getColumnDescriptors());
  assertEquals(handler.getTableNames().size(),2);
}","public static void createTestTables(Hbase.Iface handler) throws Exception {
  assertEquals(0,handler.getTableNames().size());
  handler.createTable(tableAname,getColumnDescriptors());
  assertEquals(1,handler.getTableNames().size());
  assertEquals(2,handler.getColumnDescriptors(tableAname).size());
  assertTrue(handler.isTableEnabled(tableAname));
  handler.createTable(tableBname,getColumnDescriptors());
  assertEquals(2,handler.getTableNames().size());
}",0.7108695652173913
60923,"/** 
 * Tests the four different scanner-opening methods (with and without a stoprow, with and without a timestamp).
 */
public void doTestTableScanners() throws Exception {
  ThriftServerRunner.HBaseHandler handler=new ThriftServerRunner.HBaseHandler(UTIL.getConfiguration(),UserProvider.instantiate(UTIL.getConfiguration()));
  handler.createTable(tableAname,getColumnDescriptors());
  long time1=System.currentTimeMillis();
  handler.mutateRowTs(tableAname,rowAname,getMutations(),time1,null);
  Thread.sleep(1000);
  long time2=System.currentTimeMillis();
  handler.mutateRowsTs(tableAname,getBatchMutations(),time2,null);
  time1+=1;
  int scanner1=handler.scannerOpen(tableAname,rowAname,getColumnList(true,true),null);
  TRowResult rowResult1a=handler.scannerGet(scanner1).get(0);
  assertEquals(rowResult1a.row,rowAname);
  assertEquals(rowResult1a.columns.size(),1);
  assertEquals(rowResult1a.columns.get(columnBname).value,valueCname);
  TRowResult rowResult1b=handler.scannerGet(scanner1).get(0);
  assertEquals(rowResult1b.row,rowBname);
  assertEquals(rowResult1b.columns.size(),2);
  assertEquals(rowResult1b.columns.get(columnAname).value,valueCname);
  assertEquals(rowResult1b.columns.get(columnBname).value,valueDname);
  closeScanner(scanner1,handler);
  int scanner2=handler.scannerOpenTs(tableAname,rowAname,getColumnList(true,true),time1,null);
  TRowResult rowResult2a=handler.scannerGet(scanner2).get(0);
  assertEquals(rowResult2a.columns.size(),1);
  assertEquals(rowResult2a.columns.get(columnBname).value,valueBname);
  closeScanner(scanner2,handler);
  int scanner3=handler.scannerOpenWithStop(tableAname,rowAname,rowBname,getColumnList(true,false),null);
  closeScanner(scanner3,handler);
  int scanner4=handler.scannerOpenWithStopTs(tableAname,rowAname,rowBname,getColumnList(false,true),time1,null);
  TRowResult rowResult4a=handler.scannerGet(scanner4).get(0);
  assertEquals(rowResult4a.columns.size(),1);
  assertEquals(rowResult4a.columns.get(columnBname).value,valueBname);
  TScan scanNoSortColumns=new TScan();
  scanNoSortColumns.setStartRow(rowAname);
  scanNoSortColumns.setStopRow(rowBname);
  int scanner5=handler.scannerOpenWithScan(tableAname,scanNoSortColumns,null);
  TRowResult rowResult5=handler.scannerGet(scanner5).get(0);
  assertEquals(rowResult5.columns.size(),1);
  assertEquals(rowResult5.columns.get(columnBname).value,valueCname);
  TScan scanSortColumns=new TScan();
  scanSortColumns.setStartRow(rowAname);
  scanSortColumns.setStopRow(rowBname);
  scanSortColumns=scanSortColumns.setSortColumns(true);
  int scanner6=handler.scannerOpenWithScan(tableAname,scanSortColumns,null);
  TRowResult rowResult6=handler.scannerGet(scanner6).get(0);
  assertEquals(rowResult6.sortedColumns.size(),1);
  assertEquals(rowResult6.sortedColumns.get(0).getCell().value,valueCname);
  List<Mutation> rowBmutations=new ArrayList<>(20);
  for (int i=0; i < 20; i++) {
    rowBmutations.add(new Mutation(false,asByteBuffer(""String_Node_Str"" + i),valueCname,true));
  }
  ByteBuffer rowC=asByteBuffer(""String_Node_Str"");
  handler.mutateRow(tableAname,rowC,rowBmutations,null);
  TScan scanSortMultiColumns=new TScan();
  scanSortMultiColumns.setStartRow(rowC);
  scanSortMultiColumns=scanSortMultiColumns.setSortColumns(true);
  int scanner7=handler.scannerOpenWithScan(tableAname,scanSortMultiColumns,null);
  TRowResult rowResult7=handler.scannerGet(scanner7).get(0);
  ByteBuffer smallerColumn=asByteBuffer(""String_Node_Str"");
  for (int i=0; i < 20; i++) {
    ByteBuffer currentColumn=rowResult7.sortedColumns.get(i).columnName;
    assertTrue(Bytes.compareTo(smallerColumn.array(),currentColumn.array()) < 0);
    smallerColumn=currentColumn;
  }
  TScan reversedScan=new TScan();
  reversedScan.setReversed(true);
  reversedScan.setStartRow(rowBname);
  reversedScan.setStopRow(rowAname);
  int scanner8=handler.scannerOpenWithScan(tableAname,reversedScan,null);
  List<TRowResult> results=handler.scannerGet(scanner8);
  handler.scannerClose(scanner8);
  assertEquals(results.size(),1);
  assertEquals(ByteBuffer.wrap(results.get(0).getRow()),rowBname);
  handler.disableTable(tableAname);
  handler.deleteTable(tableAname);
}","/** 
 * Tests the four different scanner-opening methods (with and without a stoprow, with and without a timestamp).
 */
public void doTestTableScanners() throws Exception {
  ThriftServerRunner.HBaseHandler handler=new ThriftServerRunner.HBaseHandler(UTIL.getConfiguration(),UserProvider.instantiate(UTIL.getConfiguration()));
  handler.createTable(tableAname,getColumnDescriptors());
  long time1=System.currentTimeMillis();
  handler.mutateRowTs(tableAname,rowAname,getMutations(),time1,null);
  Thread.sleep(1000);
  long time2=System.currentTimeMillis();
  handler.mutateRowsTs(tableAname,getBatchMutations(),time2,null);
  time1+=1;
  int scanner1=handler.scannerOpen(tableAname,rowAname,getColumnList(true,true),null);
  TRowResult rowResult1a=handler.scannerGet(scanner1).get(0);
  assertEquals(rowResult1a.row,rowAname);
  assertEquals(1,rowResult1a.columns.size());
  assertEquals(rowResult1a.columns.get(columnBname).value,valueCname);
  TRowResult rowResult1b=handler.scannerGet(scanner1).get(0);
  assertEquals(rowResult1b.row,rowBname);
  assertEquals(2,rowResult1b.columns.size());
  assertEquals(rowResult1b.columns.get(columnAname).value,valueCname);
  assertEquals(rowResult1b.columns.get(columnBname).value,valueDname);
  closeScanner(scanner1,handler);
  int scanner2=handler.scannerOpenTs(tableAname,rowAname,getColumnList(true,true),time1,null);
  TRowResult rowResult2a=handler.scannerGet(scanner2).get(0);
  assertEquals(1,rowResult2a.columns.size());
  assertEquals(rowResult2a.columns.get(columnBname).value,valueBname);
  closeScanner(scanner2,handler);
  int scanner3=handler.scannerOpenWithStop(tableAname,rowAname,rowBname,getColumnList(true,false),null);
  closeScanner(scanner3,handler);
  int scanner4=handler.scannerOpenWithStopTs(tableAname,rowAname,rowBname,getColumnList(false,true),time1,null);
  TRowResult rowResult4a=handler.scannerGet(scanner4).get(0);
  assertEquals(1,rowResult4a.columns.size());
  assertEquals(rowResult4a.columns.get(columnBname).value,valueBname);
  TScan scanNoSortColumns=new TScan();
  scanNoSortColumns.setStartRow(rowAname);
  scanNoSortColumns.setStopRow(rowBname);
  int scanner5=handler.scannerOpenWithScan(tableAname,scanNoSortColumns,null);
  TRowResult rowResult5=handler.scannerGet(scanner5).get(0);
  assertEquals(1,rowResult5.columns.size());
  assertEquals(rowResult5.columns.get(columnBname).value,valueCname);
  TScan scanSortColumns=new TScan();
  scanSortColumns.setStartRow(rowAname);
  scanSortColumns.setStopRow(rowBname);
  scanSortColumns=scanSortColumns.setSortColumns(true);
  int scanner6=handler.scannerOpenWithScan(tableAname,scanSortColumns,null);
  TRowResult rowResult6=handler.scannerGet(scanner6).get(0);
  assertEquals(1,rowResult6.sortedColumns.size());
  assertEquals(rowResult6.sortedColumns.get(0).getCell().value,valueCname);
  List<Mutation> rowBmutations=new ArrayList<>(20);
  for (int i=0; i < 20; i++) {
    rowBmutations.add(new Mutation(false,asByteBuffer(""String_Node_Str"" + i),valueCname,true));
  }
  ByteBuffer rowC=asByteBuffer(""String_Node_Str"");
  handler.mutateRow(tableAname,rowC,rowBmutations,null);
  TScan scanSortMultiColumns=new TScan();
  scanSortMultiColumns.setStartRow(rowC);
  scanSortMultiColumns=scanSortMultiColumns.setSortColumns(true);
  int scanner7=handler.scannerOpenWithScan(tableAname,scanSortMultiColumns,null);
  TRowResult rowResult7=handler.scannerGet(scanner7).get(0);
  ByteBuffer smallerColumn=asByteBuffer(""String_Node_Str"");
  for (int i=0; i < 20; i++) {
    ByteBuffer currentColumn=rowResult7.sortedColumns.get(i).columnName;
    assertTrue(Bytes.compareTo(smallerColumn.array(),currentColumn.array()) < 0);
    smallerColumn=currentColumn;
  }
  TScan reversedScan=new TScan();
  reversedScan.setReversed(true);
  reversedScan.setStartRow(rowBname);
  reversedScan.setStopRow(rowAname);
  int scanner8=handler.scannerOpenWithScan(tableAname,reversedScan,null);
  List<TRowResult> results=handler.scannerGet(scanner8);
  handler.scannerClose(scanner8);
  assertEquals(1,results.size());
  assertEquals(ByteBuffer.wrap(results.get(0).getRow()),rowBname);
  handler.disableTable(tableAname);
  handler.deleteTable(tableAname);
}",0.9944949736716132
60924,"public static void doTestGetTableRegions(Hbase.Iface handler) throws Exception {
  assertEquals(handler.getTableNames().size(),0);
  handler.createTable(tableAname,getColumnDescriptors());
  assertEquals(handler.getTableNames().size(),1);
  List<TRegionInfo> regions=handler.getTableRegions(tableAname);
  int regionCount=regions.size();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + regionCount,regionCount,1);
  LOG.info(""String_Node_Str"" + regions.get(0));
  handler.disableTable(tableAname);
  handler.deleteTable(tableAname);
  regionCount=handler.getTableRegions(tableAname).size();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + regionCount,regionCount,0);
}","public static void doTestGetTableRegions(Hbase.Iface handler) throws Exception {
  assertEquals(0,handler.getTableNames().size());
  handler.createTable(tableAname,getColumnDescriptors());
  assertEquals(1,handler.getTableNames().size());
  List<TRegionInfo> regions=handler.getTableRegions(tableAname);
  int regionCount=regions.size();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + regionCount,1,regionCount);
  LOG.info(""String_Node_Str"" + regions.get(0));
  handler.disableTable(tableAname);
  handler.deleteTable(tableAname);
  regionCount=handler.getTableRegions(tableAname).size();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + regionCount,0,regionCount);
}",0.7434017595307918
60925,"@GET @Produces({MIMETYPE_XML,MIMETYPE_JSON,MIMETYPE_PROTOBUF,MIMETYPE_PROTOBUF_IETF}) public Response get(final @Context UriInfo uriInfo){
  MultivaluedMap<String,String> params=uriInfo.getQueryParameters();
  servlet.getMetrics().incrementRequests(1);
  try {
    CellSetModel model=new CellSetModel();
    for (    String rk : params.get(ROW_KEYS_PARAM_NAME)) {
      RowSpec rowSpec=new RowSpec(rk);
      if (this.versions != null) {
        rowSpec.setMaxVersions(this.versions);
      }
      if (this.columns != null) {
        for (int i=0; i < this.columns.length; i++) {
          rowSpec.addColumn(this.columns[i].getBytes());
        }
      }
      ResultGenerator generator=ResultGenerator.fromRowSpec(this.tableResource.getName(),rowSpec,null,!params.containsKey(NOCACHE_PARAM_NAME));
      Cell value=null;
      RowModel rowModel=new RowModel(rk);
      if (generator.hasNext()) {
        while ((value=generator.next()) != null) {
          rowModel.addCell(new CellModel(CellUtil.cloneFamily(value),CellUtil.cloneQualifier(value),value.getTimestamp(),CellUtil.cloneValue(value)));
        }
        model.addRow(rowModel);
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + rk + ""String_Node_Str"");
        }
      }
    }
    if (model.getRows().isEmpty()) {
      servlet.getMetrics().incrementFailedGetRequests(1);
      return Response.status(Response.Status.NOT_FOUND).type(MIMETYPE_TEXT).entity(""String_Node_Str"" + CRLF).build();
    }
 else {
      servlet.getMetrics().incrementSucessfulGetRequests(1);
      return Response.ok(model).build();
    }
  }
 catch (  IOException e) {
    servlet.getMetrics().incrementFailedGetRequests(1);
    return processException(e);
  }
}","@GET @Produces({MIMETYPE_XML,MIMETYPE_JSON,MIMETYPE_PROTOBUF,MIMETYPE_PROTOBUF_IETF}) public Response get(final @Context UriInfo uriInfo){
  MultivaluedMap<String,String> params=uriInfo.getQueryParameters();
  servlet.getMetrics().incrementRequests(1);
  try {
    CellSetModel model=new CellSetModel();
    for (    String rk : params.get(ROW_KEYS_PARAM_NAME)) {
      RowSpec rowSpec=new RowSpec(rk);
      if (this.versions != null) {
        rowSpec.setMaxVersions(this.versions);
      }
      if (this.columns != null) {
        for (int i=0; i < this.columns.length; i++) {
          rowSpec.addColumn(Bytes.toBytes(this.columns[i]));
        }
      }
      ResultGenerator generator=ResultGenerator.fromRowSpec(this.tableResource.getName(),rowSpec,null,!params.containsKey(NOCACHE_PARAM_NAME));
      Cell value=null;
      RowModel rowModel=new RowModel(rk);
      if (generator.hasNext()) {
        while ((value=generator.next()) != null) {
          rowModel.addCell(new CellModel(CellUtil.cloneFamily(value),CellUtil.cloneQualifier(value),value.getTimestamp(),CellUtil.cloneValue(value)));
        }
        model.addRow(rowModel);
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + rk + ""String_Node_Str"");
        }
      }
    }
    if (model.getRows().isEmpty()) {
      servlet.getMetrics().incrementFailedGetRequests(1);
      return Response.status(Response.Status.NOT_FOUND).type(MIMETYPE_TEXT).entity(""String_Node_Str"" + CRLF).build();
    }
 else {
      servlet.getMetrics().incrementSucessfulGetRequests(1);
      return Response.ok(model).build();
    }
  }
 catch (  IOException e) {
    servlet.getMetrics().incrementFailedGetRequests(1);
    return processException(e);
  }
}",0.9873853211009176
60926,"public Cell next(){
  if (cache != null) {
    Cell kv=cache;
    cache=null;
    return kv;
  }
  if (valuesI == null) {
    return null;
  }
  try {
    return valuesI.next();
  }
 catch (  NoSuchElementException e) {
    return null;
  }
}","@Override public Cell next(){
  if (cache != null) {
    Cell kv=cache;
    cache=null;
    return kv;
  }
  if (valuesI == null) {
    return null;
  }
  try {
    return valuesI.next();
  }
 catch (  NoSuchElementException e) {
    return null;
  }
}",0.979757085020243
60927,"public void putBack(Cell kv){
  this.cache=kv;
}","@Override public void putBack(Cell kv){
  this.cache=kv;
}",0.9056603773584906
60928,"public boolean hasNext(){
  if (cache != null) {
    return true;
  }
  if (valuesI == null) {
    return false;
  }
  return valuesI.hasNext();
}","@Override public boolean hasNext(){
  if (cache != null) {
    return true;
  }
  if (valuesI == null) {
    return false;
  }
  return valuesI.hasNext();
}",0.9668874172185432
60929,"public void close(){
}","@Override public void close(){
}",0.8148148148148148
60930,"public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9444444444444444
60931,"public String toString(){
  StringBuilder result=new StringBuilder();
  result.append(""String_Node_Str"");
  if (row != null) {
    result.append(Bytes.toString(row));
  }
  result.append(""String_Node_Str"");
  if (endRow != null) {
    result.append(Bytes.toString(endRow));
  }
  result.append(""String_Node_Str"");
  for (  byte[] col : columns) {
    result.append(""String_Node_Str"");
    result.append(Bytes.toString(col));
    result.append(""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  result.append(Long.toString(startTime));
  result.append(""String_Node_Str"");
  result.append(Long.toString(endTime));
  result.append(""String_Node_Str"");
  result.append(Integer.toString(maxVersions));
  result.append(""String_Node_Str"");
  result.append(Integer.toString(maxValues));
  result.append(""String_Node_Str"");
  return result.toString();
}","@Override public String toString(){
  StringBuilder result=new StringBuilder();
  result.append(""String_Node_Str"");
  if (row != null) {
    result.append(Bytes.toString(row));
  }
  result.append(""String_Node_Str"");
  if (endRow != null) {
    result.append(Bytes.toString(endRow));
  }
  result.append(""String_Node_Str"");
  for (  byte[] col : columns) {
    result.append(""String_Node_Str"");
    result.append(Bytes.toString(col));
    result.append(""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  result.append(Long.toString(startTime));
  result.append(""String_Node_Str"");
  result.append(Long.toString(endTime));
  result.append(""String_Node_Str"");
  result.append(Integer.toString(maxVersions));
  result.append(""String_Node_Str"");
  result.append(Integer.toString(maxValues));
  result.append(""String_Node_Str"");
  return result.toString();
}",0.9941792782305006
60932,"public Cell next(){
  if (cache != null) {
    Cell kv=cache;
    cache=null;
    return kv;
  }
  boolean loop;
  do {
    loop=false;
    if (rowI != null) {
      if (rowI.hasNext()) {
        return rowI.next();
      }
 else {
        rowI=null;
      }
    }
    if (cached != null) {
      rowI=cached.listCells().iterator();
      loop=true;
      cached=null;
    }
 else {
      Result result=null;
      try {
        result=scanner.next();
      }
 catch (      UnknownScannerException e) {
        throw new IllegalArgumentException(e);
      }
catch (      TableNotEnabledException tnee) {
        throw new IllegalStateException(tnee);
      }
catch (      TableNotFoundException tnfe) {
        throw new IllegalArgumentException(tnfe);
      }
catch (      IOException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
      if (result != null && !result.isEmpty()) {
        rowI=result.listCells().iterator();
        loop=true;
      }
    }
  }
 while (loop);
  return null;
}","@Override public Cell next(){
  if (cache != null) {
    Cell kv=cache;
    cache=null;
    return kv;
  }
  boolean loop;
  do {
    loop=false;
    if (rowI != null) {
      if (rowI.hasNext()) {
        return rowI.next();
      }
 else {
        rowI=null;
      }
    }
    if (cached != null) {
      rowI=cached.listCells().iterator();
      loop=true;
      cached=null;
    }
 else {
      Result result=null;
      try {
        result=scanner.next();
      }
 catch (      UnknownScannerException e) {
        throw new IllegalArgumentException(e);
      }
catch (      TableNotEnabledException tnee) {
        throw new IllegalStateException(tnee);
      }
catch (      TableNotFoundException tnfe) {
        throw new IllegalArgumentException(tnfe);
      }
catch (      IOException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
      if (result != null && !result.isEmpty()) {
        rowI=result.listCells().iterator();
        loop=true;
      }
    }
  }
 while (loop);
  return null;
}",0.9950932286555446
60933,"public void putBack(Cell kv){
  this.cache=kv;
}","@Override public void putBack(Cell kv){
  this.cache=kv;
}",0.9056603773584906
60934,"public boolean hasNext(){
  if (cache != null) {
    return true;
  }
  if (rowI != null && rowI.hasNext()) {
    return true;
  }
  if (cached != null) {
    return true;
  }
  try {
    Result result=scanner.next();
    if (result != null && !result.isEmpty()) {
      cached=result;
    }
  }
 catch (  UnknownScannerException e) {
    throw new IllegalArgumentException(e);
  }
catch (  IOException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return cached != null;
}","@Override public boolean hasNext(){
  if (cache != null) {
    return true;
  }
  if (rowI != null && rowI.hasNext()) {
    return true;
  }
  if (cached != null) {
    return true;
  }
  try {
    Result result=scanner.next();
    if (result != null && !result.isEmpty()) {
      cached=result;
    }
  }
 catch (  UnknownScannerException e) {
    throw new IllegalArgumentException(e);
  }
catch (  IOException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return cached != null;
}",0.9898580121703854
60935,"public void close(){
  if (scanner != null) {
    scanner.close();
    scanner=null;
  }
}","@Override public void close(){
  if (scanner != null) {
    scanner.close();
    scanner=null;
  }
}",0.9473684210526316
60936,"public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9444444444444444
60937,"@Override public ProtobufMessageHandler readFrom(Class<ProtobufMessageHandler> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,String> httpHeaders,InputStream inputStream) throws IOException, WebApplicationException {
  ProtobufMessageHandler obj=null;
  try {
    obj=type.newInstance();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    byte[] buffer=new byte[4096];
    int read;
    do {
      read=inputStream.read(buffer,0,buffer.length);
      if (read > 0) {
        baos.write(buffer,0,read);
      }
    }
 while (read > 0);
    if (LOG.isTraceEnabled()) {
      LOG.trace(getClass() + ""String_Node_Str"" + baos.size()+ ""String_Node_Str""+ inputStream);
    }
    obj=obj.getObjectFromMessage(baos.toByteArray());
  }
 catch (  InstantiationException e) {
    throw new WebApplicationException(e);
  }
catch (  IllegalAccessException e) {
    throw new WebApplicationException(e);
  }
  return obj;
}","@Override public ProtobufMessageHandler readFrom(Class<ProtobufMessageHandler> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,String> httpHeaders,InputStream inputStream) throws IOException, WebApplicationException {
  ProtobufMessageHandler obj=null;
  try {
    obj=type.getDeclaredConstructor().newInstance();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    byte[] buffer=new byte[4096];
    int read;
    do {
      read=inputStream.read(buffer,0,buffer.length);
      if (read > 0) {
        baos.write(buffer,0,read);
      }
    }
 while (read > 0);
    if (LOG.isTraceEnabled()) {
      LOG.trace(getClass() + ""String_Node_Str"" + baos.size()+ ""String_Node_Str""+ inputStream);
    }
    obj=obj.getObjectFromMessage(baos.toByteArray());
  }
 catch (  InstantiationException|NoSuchMethodException|InvocationTargetException|IllegalAccessException e) {
    throw new WebApplicationException(e);
  }
  return obj;
}",0.8942753996905621
60938,"@Override public void writeTo(Object object,Class<?> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream outStream) throws IOException, WebApplicationException {
  outStream.write(object.toString().getBytes());
}","@Override public void writeTo(Object object,Class<?> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream outStream) throws IOException, WebApplicationException {
  outStream.write(Bytes.toBytes(object.toString()));
}",0.9366197183098592
60939,"public void writeTo(ProtobufMessageHandler m,Class<?> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream entityStream) throws IOException, WebApplicationException {
  entityStream.write(m.createProtobufOutput());
}","@Override public void writeTo(ProtobufMessageHandler m,Class<?> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream entityStream) throws IOException, WebApplicationException {
  entityStream.write(m.createProtobufOutput());
}",0.9827586206896552
60940,"protected static void checkIncrementValueJSON(String table,String row,String column,long value) throws IOException, JAXBException {
  Response response=getValueJson(table,row,column);
  assertEquals(response.getCode(),200);
  assertEquals(Constants.MIMETYPE_JSON,response.getHeader(""String_Node_Str""));
  ObjectMapper mapper=new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,MediaType.APPLICATION_JSON_TYPE);
  CellSetModel cellSet=mapper.readValue(response.getBody(),CellSetModel.class);
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}","protected static void checkIncrementValueJSON(String table,String row,String column,long value) throws IOException, JAXBException {
  Response response=getValueJson(table,row,column);
  assertEquals(200,response.getCode());
  assertEquals(Constants.MIMETYPE_JSON,response.getHeader(""String_Node_Str""));
  ObjectMapper mapper=new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,MediaType.APPLICATION_JSON_TYPE);
  CellSetModel cellSet=mapper.readValue(response.getBody(),CellSetModel.class);
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}",0.972972972972973
60941,"protected static void checkValuePB(String table,String row,String column,String value) throws IOException {
  Response response=getValuePB(table,row,column);
  assertEquals(response.getCode(),200);
  assertEquals(Constants.MIMETYPE_PROTOBUF,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=new CellSetModel();
  cellSet.getObjectFromMessage(response.getBody());
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}","protected static void checkValuePB(String table,String row,String column,String value) throws IOException {
  Response response=getValuePB(table,row,column);
  assertEquals(200,response.getCode());
  assertEquals(Constants.MIMETYPE_PROTOBUF,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=new CellSetModel();
  cellSet.getObjectFromMessage(response.getBody());
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}",0.9672413793103448
60942,"protected static void checkValueXML(String table,String row,String column,String value) throws IOException, JAXBException {
  Response response=getValueXML(table,row,column);
  assertEquals(response.getCode(),200);
  assertEquals(Constants.MIMETYPE_XML,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=(CellSetModel)xmlUnmarshaller.unmarshal(new ByteArrayInputStream(response.getBody()));
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}","protected static void checkValueXML(String table,String row,String column,String value) throws IOException, JAXBException {
  Response response=getValueXML(table,row,column);
  assertEquals(200,response.getCode());
  assertEquals(Constants.MIMETYPE_XML,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=(CellSetModel)xmlUnmarshaller.unmarshal(new ByteArrayInputStream(response.getBody()));
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}",0.9686985172981878
60943,"protected static void checkIncrementValuePB(String table,String row,String column,long value) throws IOException {
  Response response=getValuePB(table,row,column);
  assertEquals(response.getCode(),200);
  assertEquals(Constants.MIMETYPE_PROTOBUF,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=new CellSetModel();
  cellSet.getObjectFromMessage(response.getBody());
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}","protected static void checkIncrementValuePB(String table,String row,String column,long value) throws IOException {
  Response response=getValuePB(table,row,column);
  assertEquals(200,response.getCode());
  assertEquals(Constants.MIMETYPE_PROTOBUF,response.getHeader(""String_Node_Str""));
  CellSetModel cellSet=new CellSetModel();
  cellSet.getObjectFromMessage(response.getBody());
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}",0.9675213675213676
60944,"protected static void checkValueJSON(String table,String row,String column,String value) throws IOException, JAXBException {
  Response response=getValueJson(table,row,column);
  assertEquals(response.getCode(),200);
  assertEquals(Constants.MIMETYPE_JSON,response.getHeader(""String_Node_Str""));
  ObjectMapper mapper=new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,MediaType.APPLICATION_JSON_TYPE);
  CellSetModel cellSet=mapper.readValue(response.getBody(),CellSetModel.class);
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}","protected static void checkValueJSON(String table,String row,String column,String value) throws IOException, JAXBException {
  Response response=getValueJson(table,row,column);
  assertEquals(200,response.getCode());
  assertEquals(Constants.MIMETYPE_JSON,response.getHeader(""String_Node_Str""));
  ObjectMapper mapper=new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,MediaType.APPLICATION_JSON_TYPE);
  CellSetModel cellSet=mapper.readValue(response.getBody(),CellSetModel.class);
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toString(cell.getValue()),value);
}",0.9727793696275072
60945,"protected static void checkIncrementValueXML(String table,String row,String column,long value) throws IOException, JAXBException {
  Response response1=getValueXML(table,row,column);
  assertEquals(response1.getCode(),200);
  assertEquals(Constants.MIMETYPE_XML,response1.getHeader(""String_Node_Str""));
  CellSetModel cellSet=(CellSetModel)xmlUnmarshaller.unmarshal(new ByteArrayInputStream(response1.getBody()));
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}","protected static void checkIncrementValueXML(String table,String row,String column,long value) throws IOException, JAXBException {
  Response response1=getValueXML(table,row,column);
  assertEquals(200,response1.getCode());
  assertEquals(Constants.MIMETYPE_XML,response1.getHeader(""String_Node_Str""));
  CellSetModel cellSet=(CellSetModel)xmlUnmarshaller.unmarshal(new ByteArrayInputStream(response1.getBody()));
  RowModel rowModel=cellSet.getRows().get(0);
  CellModel cell=rowModel.getCells().get(0);
  assertEquals(Bytes.toString(cell.getColumn()),column);
  assertEquals(Bytes.toLong(cell.getValue()),value);
}",0.9675324675324676
60946,"@Test public void testDeleteXML() throws IOException, JAXBException {
  Response response=putValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(response.getCode(),200);
  response=putValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  assertEquals(response.getCode(),200);
  checkValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  checkValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  response=deleteValue(TABLE,ROW_1,COLUMN_1);
  assertEquals(response.getCode(),200);
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(response.getCode(),404);
  checkValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  response=putValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(response.getCode(),200);
  response=checkAndDeletePB(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(response.getCode(),200);
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(response.getCode(),404);
  response=deleteRow(TABLE,ROW_1);
  assertEquals(response.getCode(),200);
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(response.getCode(),404);
  response=getValueXML(TABLE,ROW_1,COLUMN_2);
  assertEquals(response.getCode(),404);
  response=deleteValue(""String_Node_Str"",ROW_1,COLUMN_1);
  assertEquals(response.getCode(),404);
  response=deleteValue(TABLE,ROW_1,""String_Node_Str"");
  assertEquals(response.getCode(),404);
}","@Test public void testDeleteXML() throws IOException, JAXBException {
  Response response=putValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(200,response.getCode());
  response=putValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  assertEquals(200,response.getCode());
  checkValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  checkValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  response=deleteValue(TABLE,ROW_1,COLUMN_1);
  assertEquals(200,response.getCode());
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(404,response.getCode());
  checkValueXML(TABLE,ROW_1,COLUMN_2,VALUE_2);
  response=putValueXML(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(200,response.getCode());
  response=checkAndDeletePB(TABLE,ROW_1,COLUMN_1,VALUE_1);
  assertEquals(200,response.getCode());
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(404,response.getCode());
  response=deleteRow(TABLE,ROW_1);
  assertEquals(200,response.getCode());
  response=getValueXML(TABLE,ROW_1,COLUMN_1);
  assertEquals(404,response.getCode());
  response=getValueXML(TABLE,ROW_1,COLUMN_2);
  assertEquals(404,response.getCode());
  response=deleteValue(""String_Node_Str"",ROW_1,COLUMN_1);
  assertEquals(404,response.getCode());
  response=deleteValue(TABLE,ROW_1,""String_Node_Str"");
  assertEquals(404,response.getCode());
}",0.7484615384615385
60947,"/** 
 * Cancel copy job
 * @param jobHandler backup copy job handler
 * @throws IOException
 */
void cancel(String jobHandler) throws IOException ;","/** 
 * Cancel copy job
 * @param jobHandler backup copy job handler
 * @throws IOException if cancelling the jobs fails
 */
void cancel(String jobHandler) throws IOException ;",0.9102167182662538
60948,"private Set<String> getFilenameFromBulkLoad(Map<byte[],List<Path>>[] maps){
  Set<String> filenames=new HashSet<String>();
  for (  Map<byte[],List<Path>> map : maps) {
    if (map == null)     continue;
    for (    List<Path> paths : map.values()) {
      for (      Path p : paths) {
        filenames.add(p.getName());
      }
    }
  }
  return filenames;
}","private Set<String> getFilenameFromBulkLoad(Map<byte[],List<Path>>[] maps){
  Set<String> filenames=new HashSet<>();
  for (  Map<byte[],List<Path>> map : maps) {
    if (map == null) {
      continue;
    }
    for (    List<Path> paths : map.values()) {
      for (      Path p : paths) {
        filenames.add(p.getName());
      }
    }
  }
  return filenames;
}",0.978021978021978
60949,"@Override public Iterable<FileStatus> getDeletableFiles(Iterable<FileStatus> files){
  if (conf == null) {
    return files;
  }
  if (checkForFullyBackedUpTables) {
    if (connection == null)     return files;
    try (BackupSystemTable tbl=new BackupSystemTable(connection)){
      fullyBackedUpTables=tbl.getTablesForBackupType(BackupType.FULL);
    }
 catch (    IOException ioe) {
      LOG.error(""String_Node_Str"",ioe);
      return Collections.emptyList();
    }
    Collections.sort(fullyBackedUpTables);
  }
  final Set<String> hfileRefs;
  try {
    hfileRefs=loadHFileRefs(fullyBackedUpTables);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"",ioe);
    return Collections.emptyList();
  }
  Iterable<FileStatus> deletables=Iterables.filter(files,new Predicate<FileStatus>(){
    @Override public boolean apply(    FileStatus file){
      if (file.getModificationTime() > secondPrevReadFromBackupTbl) {
        return false;
      }
      String hfile=file.getPath().getName();
      boolean foundHFileRef=hfileRefs.contains(hfile);
      return !foundHFileRef;
    }
  }
);
  return deletables;
}","@Override public Iterable<FileStatus> getDeletableFiles(Iterable<FileStatus> files){
  if (conf == null) {
    return files;
  }
  if (checkForFullyBackedUpTables) {
    if (connection == null) {
      return files;
    }
    try (BackupSystemTable tbl=new BackupSystemTable(connection)){
      fullyBackedUpTables=tbl.getTablesForBackupType(BackupType.FULL);
    }
 catch (    IOException ioe) {
      LOG.error(""String_Node_Str"",ioe);
      return Collections.emptyList();
    }
    Collections.sort(fullyBackedUpTables);
  }
  final Set<String> hfileRefs;
  try {
    hfileRefs=loadHFileRefs(fullyBackedUpTables);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"",ioe);
    return Collections.emptyList();
  }
  Iterable<FileStatus> deletables=Iterables.filter(files,file -> {
    if (file.getModificationTime() > secondPrevReadFromBackupTbl) {
      return false;
    }
    String hfile=file.getPath().getName();
    boolean foundHFileRef=hfileRefs.contains(hfile);
    return !foundHFileRef;
  }
);
  return deletables;
}",0.8947368421052632
60950,"public List<TableName> getTableNames(){
  return new ArrayList<TableName>(backupTableInfoMap.keySet());
}","public List<TableName> getTableNames(){
  return new ArrayList<>(backupTableInfoMap.keySet());
}",0.9552238805970148
60951,"/** 
 * Filter interface
 * @param info backup info
 * @return true if info passes filter, false otherwise
 */
public boolean apply(BackupInfo info);","/** 
 * Filter interface
 * @param info backup info
 * @return true if info passes filter, false otherwise
 */
boolean apply(BackupInfo info);",0.9759450171821306
60952,"public List<String> getSnapshotNames(){
  List<String> snapshotNames=new ArrayList<String>();
  for (  BackupTableInfo backupStatus : this.backupTableInfoMap.values()) {
    snapshotNames.add(backupStatus.getSnapshotName());
  }
  return snapshotNames;
}","public List<String> getSnapshotNames(){
  List<String> snapshotNames=new ArrayList<>();
  for (  BackupTableInfo backupStatus : this.backupTableInfoMap.values()) {
    snapshotNames.add(backupStatus.getSnapshotName());
  }
  return snapshotNames;
}",0.9880478087649402
60953,"/** 
 * Run backup merge operation
 * @param backupIds backup image ids
 * @throws IOException
 */
void run(String[] backupIds) throws IOException ;","/** 
 * Run backup merge operation.
 * @param backupIds backup image ids
 * @throws IOException if the backup merge operation fails
 */
void run(String[] backupIds) throws IOException ;",0.8888888888888888
60954,"private static void setUpTableAndUserPermissions() throws Exception {
  TableDescriptorBuilder tableBuilder=TableDescriptorBuilder.newBuilder(TEST_TABLE);
  ColumnFamilyDescriptorBuilder cfd=ColumnFamilyDescriptorBuilder.newBuilder(TEST_FAMILY);
  cfd.setMaxVersions(100);
  tableBuilder.addColumnFamily(cfd.build());
  tableBuilder.setValue(TableDescriptorBuilder.OWNER,USER_OWNER.getShortName());
  createTable(TEST_UTIL,tableBuilder.build(),new byte[][]{Bytes.toBytes(""String_Node_Str"")});
  grantGlobal(TEST_UTIL,USER_ADMIN.getShortName(),Permission.Action.ADMIN,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_RW.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_CREATE.getShortName(),TEST_TABLE,null,null,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_RO.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_ADMIN),Permission.Action.ADMIN);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_CREATE),Permission.Action.CREATE);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_READ),Permission.Action.READ);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_WRITE),Permission.Action.WRITE);
  assertEquals(4,AccessControlLists.getTablePermissions(conf,TEST_TABLE).size());
  try {
    assertEquals(4,AccessControlClient.getUserPermissions(systemUserConnection,TEST_TABLE.toString()).size());
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}","private static void setUpTableAndUserPermissions() throws Exception {
  TableDescriptorBuilder tableBuilder=TableDescriptorBuilder.newBuilder(TEST_TABLE);
  ColumnFamilyDescriptorBuilder cfd=ColumnFamilyDescriptorBuilder.newBuilder(TEST_FAMILY);
  cfd.setMaxVersions(100);
  tableBuilder.addColumnFamily(cfd.build());
  tableBuilder.setValue(TableDescriptorBuilder.OWNER,USER_OWNER.getShortName());
  createTable(TEST_UTIL,tableBuilder.build(),new byte[][]{Bytes.toBytes(""String_Node_Str"")});
  grantGlobal(TEST_UTIL,USER_ADMIN.getShortName(),Permission.Action.ADMIN,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_RW.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_CREATE.getShortName(),TEST_TABLE,null,null,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
  grantOnTable(TEST_UTIL,USER_RO.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_ADMIN),Permission.Action.ADMIN);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_CREATE),Permission.Action.CREATE);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_READ),Permission.Action.READ);
  grantGlobal(TEST_UTIL,toGroupEntry(GROUP_WRITE),Permission.Action.WRITE);
  assertEquals(4,AccessControlLists.getTablePermissions(conf,TEST_TABLE).size());
  try {
    assertEquals(4,AccessControlClient.getUserPermissions(systemUserConnection,TEST_TABLE.toString()).size());
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
    fail(""String_Node_Str"");
  }
}",0.9909572809479265
60955,"public synchronized void dispatch(){
  if (operations != null) {
    remoteDispatch(getKey(),operations);
    this.operations=null;
  }
}","@Override public synchronized void dispatch(){
  if (operations != null) {
    remoteDispatch(getKey(),operations);
    this.operations=null;
  }
}",0.9647887323943662
60956,"public synchronized void add(final RemoteProcedure operation){
  if (this.operations == null) {
    this.operations=new HashSet<>();
    setTimeout(EnvironmentEdgeManager.currentTime() + operationDelay);
    timeoutExecutor.add(this);
  }
  this.operations.add(operation);
  if (this.operations.size() > queueMaxSize) {
    timeoutExecutor.remove(this);
    dispatch();
  }
}","@Override public synchronized void add(final RemoteProcedure operation){
  if (this.operations == null) {
    this.operations=new HashSet<>();
    setTimeout(EnvironmentEdgeManager.currentTime() + operationDelay);
    timeoutExecutor.add(this);
  }
  this.operations.add(operation);
  if (this.operations.size() > queueMaxSize) {
    timeoutExecutor.remove(this);
    dispatch();
  }
}",0.986842105263158
60957,"public TRemote getKey(){
  return getObject();
}","@Override public TRemote getKey(){
  return getObject();
}",0.9056603773584906
60958,"/** 
 * Pass one or more log file names and formatting options and it will dump out a text version of the contents on <code>stdout</code>.
 * @param args Command line arguments
 * @throws IOException Thrown upon file system errors etc.
 */
public int run(final String[] args) throws IOException {
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  final List<Path> files=new ArrayList<>();
  try {
    CommandLine cmd=new PosixParser().parse(options,args);
    if (cmd.hasOption(""String_Node_Str"")) {
      files.add(new Path(cmd.getOptionValue(""String_Node_Str"")));
    }
    if (files.isEmpty() || cmd.hasOption(""String_Node_Str"")) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.printHelp(""String_Node_Str"",options,true);
      return (-1);
    }
  }
 catch (  ParseException e) {
    e.printStackTrace();
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(""String_Node_Str"",options,true);
    return (-1);
  }
  for (  Path file : files) {
    processFile(getConf(),file);
  }
  return (0);
}","/** 
 * Pass one or more log file names and formatting options and it will dump out a text version of the contents on <code>stdout</code>.
 * @param args Command line arguments
 * @throws IOException Thrown upon file system errors etc.
 */
@Override public int run(final String[] args) throws IOException {
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  final List<Path> files=new ArrayList<>();
  try {
    CommandLine cmd=new PosixParser().parse(options,args);
    if (cmd.hasOption(""String_Node_Str"")) {
      files.add(new Path(cmd.getOptionValue(""String_Node_Str"")));
    }
    if (files.isEmpty() || cmd.hasOption(""String_Node_Str"")) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.printHelp(""String_Node_Str"",options,true);
      return (-1);
    }
  }
 catch (  ParseException e) {
    e.printStackTrace();
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(""String_Node_Str"",options,true);
    return (-1);
  }
  for (  Path file : files) {
    processFile(getConf(),file);
  }
  return (0);
}",0.9958018471872376
60959,"public void write(byte[] b,int off,int len){
  ensureCapacity(size + len);
  System.arraycopy(b,off,buf,size,len);
  size+=len;
}","@Override public void write(byte[] b,int off,int len){
  ensureCapacity(size + len);
  System.arraycopy(b,off,buf,size,len);
  size+=len;
}",0.9626865671641792
60960,"@Override protected boolean setTimeoutFailure(final TestProcEnv env){
  int n=ntimeouts.incrementAndGet();
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ n);
  setState(ProcedureState.RUNNABLE);
  event.wake((AbstractProcedureScheduler)env.getProcedureScheduler());
  return false;
}","@Override protected synchronized boolean setTimeoutFailure(final TestProcEnv env){
  int n=ntimeouts.incrementAndGet();
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ n);
  setState(ProcedureState.RUNNABLE);
  event.wake((AbstractProcedureScheduler)env.getProcedureScheduler());
  return false;
}",0.9782971619365608
60961,"@Before public void setUp() throws IOException {
  htu=new HBaseCommonTestingUtility();
  procEnv=new TestProcEnv();
  procStore=new NoopProcedureStore();
  procExecutor=new ProcedureExecutor(htu.getConfiguration(),procEnv,procStore);
  procExecutor.testing=new ProcedureExecutor.Testing();
  procStore.start(PROCEDURE_EXECUTOR_SLOTS);
  procExecutor.start(PROCEDURE_EXECUTOR_SLOTS,true);
}","@SuppressWarnings(""String_Node_Str"") @Before public void setUp() throws IOException {
  htu=new HBaseCommonTestingUtility();
  procEnv=new TestProcEnv();
  procStore=new NoopProcedureStore();
  procExecutor=new ProcedureExecutor(htu.getConfiguration(),procEnv,procStore);
  procExecutor.testing=new ProcedureExecutor.Testing();
  procStore.start(PROCEDURE_EXECUTOR_SLOTS);
  procExecutor.start(PROCEDURE_EXECUTOR_SLOTS,true);
}",0.9547123623011016
60962,"@Override public void run(){
  for (int i=0; i < nprocPerThread; ++i) {
    try {
      procExecutor.submitProcedure((Procedure)procClazz.newInstance());
    }
 catch (    InstantiationException|IllegalAccessException e) {
      LOG.error(""String_Node_Str"",e);
      fail(""String_Node_Str"" + e.getMessage());
    }
  }
}","@Override public void run(){
  for (int i=0; i < nprocPerThread; ++i) {
    try {
      procExecutor.submitProcedure((Procedure)procClazz.getDeclaredConstructor().newInstance());
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      fail(""String_Node_Str"" + e.getMessage());
    }
  }
}",0.90302066772655
60963,"private void submitProcedures(final int nthreads,final int nprocPerThread,final Class<?> procClazz) throws Exception {
  Thread[] submitThreads=new Thread[nthreads];
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i]=new Thread(){
      @Override public void run(){
        for (int i=0; i < nprocPerThread; ++i) {
          try {
            procExecutor.submitProcedure((Procedure)procClazz.newInstance());
          }
 catch (          InstantiationException|IllegalAccessException e) {
            LOG.error(""String_Node_Str"",e);
            fail(""String_Node_Str"" + e.getMessage());
          }
        }
      }
    }
;
  }
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i].start();
  }
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i].join();
  }
}","private void submitProcedures(final int nthreads,final int nprocPerThread,final Class<?> procClazz) throws Exception {
  Thread[] submitThreads=new Thread[nthreads];
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i]=new Thread(){
      @Override public void run(){
        for (int i=0; i < nprocPerThread; ++i) {
          try {
            procExecutor.submitProcedure((Procedure)procClazz.getDeclaredConstructor().newInstance());
          }
 catch (          Exception e) {
            LOG.error(""String_Node_Str"",e);
            fail(""String_Node_Str"" + e.getMessage());
          }
        }
      }
    }
;
  }
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i].start();
  }
  for (int i=0; i < submitThreads.length; ++i) {
    submitThreads[i].join();
  }
}",0.9623224212476836
60964,"protected TestSMProcedureState getInitialState(){
  return TestSMProcedureState.STEP_1;
}","@Override protected TestSMProcedureState getInitialState(){
  return TestSMProcedureState.STEP_1;
}",0.946808510638298
60965,"protected Flow executeFromState(TestProcEnv env,TestSMProcedureState state){
  LOG.info(""String_Node_Str"" + state + ""String_Node_Str""+ this);
  env.execCount.incrementAndGet();
switch (state) {
case STEP_1:
    if (!env.loop) {
      setNextState(TestSMProcedureState.STEP_2);
    }
  break;
case STEP_2:
addChildProcedure(new SimpleChildProcedure());
return Flow.NO_MORE_STATE;
}
return Flow.HAS_MORE_STATE;
}","@Override protected Flow executeFromState(TestProcEnv env,TestSMProcedureState state){
  LOG.info(""String_Node_Str"" + state + ""String_Node_Str""+ this);
  env.execCount.incrementAndGet();
switch (state) {
case STEP_1:
    if (!env.loop) {
      setNextState(TestSMProcedureState.STEP_2);
    }
  break;
case STEP_2:
addChildProcedure(new SimpleChildProcedure());
return Flow.NO_MORE_STATE;
}
return Flow.HAS_MORE_STATE;
}",0.9879518072289156
60966,"protected Procedure[] execute(TestProcEnv env){
  LOG.info(""String_Node_Str"" + this);
  env.execCount.incrementAndGet();
  if (env.triggerChildRollback) {
    setFailure(""String_Node_Str"",TEST_FAILURE_EXCEPTION);
  }
  return null;
}","@Override protected Procedure[] execute(TestProcEnv env){
  LOG.info(""String_Node_Str"" + this);
  env.execCount.incrementAndGet();
  if (env.triggerChildRollback) {
    setFailure(""String_Node_Str"",TEST_FAILURE_EXCEPTION);
  }
  return null;
}",0.9789915966386554
60967,"protected void rollbackState(TestProcEnv env,TestSMProcedureState state){
  LOG.info(""String_Node_Str"" + state + ""String_Node_Str""+ this);
  env.rollbackCount.incrementAndGet();
}","@Override protected void rollbackState(TestProcEnv env,TestSMProcedureState state){
  LOG.info(""String_Node_Str"" + state + ""String_Node_Str""+ this);
  env.rollbackCount.incrementAndGet();
}",0.9728260869565216
60968,"protected int getStateId(TestSMProcedureState state){
  return state.ordinal();
}","@Override protected int getStateId(TestSMProcedureState state){
  return state.ordinal();
}",0.9418604651162792
60969,"protected TestSMProcedureState getState(int stateId){
  return TestSMProcedureState.values()[stateId];
}","@Override protected TestSMProcedureState getState(int stateId){
  return TestSMProcedureState.values()[stateId];
}",0.9541284403669724
60970,"private void writeWals() throws IOException {
  List<Integer> procStates=shuffleProcWriteSequence();
  TestProcedure[] procs=new TestProcedure[numProcs + 1];
  int numProcsPerWal=numWals > 0 ? (int)Math.ceil(procStates.size() / numWals) : Integer.MAX_VALUE;
  long startTime=currentTimeMillis();
  long lastTime=startTime;
  for (int i=0; i < procStates.size(); ++i) {
    int procId=procStates.get(i);
    if (procId < 0) {
      store.delete(procs[-procId].getProcId());
      procs[-procId]=null;
    }
 else     if (procs[procId] == null) {
      procs[procId]=new TestProcedure(procId,0);
      procs[procId].setData(serializedState);
      store.insert(procs[procId],null);
    }
 else {
      store.update(procs[procId]);
    }
    if (i > 0 && i % numProcsPerWal == 0) {
      long currentTime=currentTimeMillis();
      System.out.println(""String_Node_Str"" + (currentTime - lastTime) / 1000.0f + ""String_Node_Str"");
      store.rollWriterForTesting();
      lastTime=currentTime;
    }
  }
  long timeTaken=currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + numProcs + ""String_Node_Str""+ StringUtils.humanTimeDiff(timeTaken)+ ""String_Node_Str"");
}","private void writeWals() throws IOException {
  List<Integer> procStates=shuffleProcWriteSequence();
  TestProcedure[] procs=new TestProcedure[numProcs + 1];
  int numProcsPerWal=numWals > 0 ? procStates.size() / numWals : Integer.MAX_VALUE;
  long startTime=currentTimeMillis();
  long lastTime=startTime;
  for (int i=0; i < procStates.size(); ++i) {
    int procId=procStates.get(i);
    if (procId < 0) {
      store.delete(procs[-procId].getProcId());
      procs[-procId]=null;
    }
 else     if (procs[procId] == null) {
      procs[procId]=new TestProcedure(procId,0);
      procs[procId].setData(serializedState);
      store.insert(procs[procId],null);
    }
 else {
      store.update(procs[procId]);
    }
    if (i > 0 && i % numProcsPerWal == 0) {
      long currentTime=currentTimeMillis();
      System.out.println(""String_Node_Str"" + (currentTime - lastTime) / 1000.0f + ""String_Node_Str"");
      store.rollWriterForTesting();
      lastTime=currentTime;
    }
  }
  long timeTaken=currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + numProcs + ""String_Node_Str""+ StringUtils.humanTimeDiff(timeTaken)+ ""String_Node_Str"");
}",0.9931682322801024
60971,"public long getCount(){
  return counter.getCount();
}","@Override public long getCount(){
  return counter.getCount();
}",0.9152542372881356
60972,"public Snapshot snapshot(){
  return histogram.snapshotAndReset();
}","@Override public Snapshot snapshot(){
  return histogram.snapshotAndReset();
}",0.9315068493150684
60973,"public Optional<MetricRegistry> get(MetricRegistryInfo info){
  return Optional.ofNullable(registries.get(info));
}","@Override public Optional<MetricRegistry> get(MetricRegistryInfo info){
  return Optional.ofNullable(registries.get(info));
}",0.9583333333333334
60974,"public void clear(){
  registries.clear();
}","@Override public void clear(){
  registries.clear();
}",0.8979591836734694
60975,"public Set<MetricRegistryInfo> getMetricRegistryInfos(){
  return Collections.unmodifiableSet(registries.keySet());
}","@Override public Set<MetricRegistryInfo> getMetricRegistryInfos(){
  return Collections.unmodifiableSet(registries.keySet());
}",0.9590163934426228
60976,"public Collection<MetricRegistry> getMetricRegistries(){
  return Collections.unmodifiableCollection(registries.values());
}","@Override public Collection<MetricRegistry> getMetricRegistries(){
  return Collections.unmodifiableCollection(registries.values());
}",0.9612403100775194
60977,"public boolean remove(MetricRegistryInfo key){
  return registries.remove(key) == null;
}","@Override public boolean remove(MetricRegistryInfo key){
  return registries.remove(key) == null;
}",0.946808510638298
60978,"/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,90000);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}","/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}",0.9711723254324152
60979,"/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}","/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,90000);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}",0.9711723254324152
60980,"/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}","/** 
 * Cluster test which starts a region server with a region, then removes the data from HDFS underneath it, and ensures that errors are bubbled to the client.
 */
@Test(timeout=5 * 60 * 1000) public void testFullSystemBubblesFSErrors() throws Exception {
  Assume.assumeTrue(!util.isReadShortCircuitOn());
  try {
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,1);
    util.getConfiguration().setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,90000);
    util.getConfiguration().setInt(""String_Node_Str"",10000);
    util.getConfiguration().setInt(""String_Node_Str"",1000);
    util.startMiniCluster(1);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] fam=Bytes.toBytes(""String_Node_Str"");
    Admin admin=util.getAdmin();
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(fam).setMaxVersions(1).setBlockCacheEnabled(false));
    admin.createTable(desc);
    try (Table table=util.getConnection().getTable(tableName)){
      util.loadTable(table,fam,false);
      util.flush();
      util.countRows(table);
      util.getDFSCluster().shutdownDataNodes();
      try {
        util.countRows(table);
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
        LOG.info(""String_Node_Str"",e);
        assertTrue(e.getMessage().contains(""String_Node_Str""));
      }
    }
     util.getDFSCluster().restartDataNodes();
  }
  finally {
    MiniHBaseCluster cluster=util.getMiniHBaseCluster();
    if (cluster != null)     cluster.killAll();
    util.shutdownMiniCluster();
  }
}",0.9711723254324152
60981,"/** 
 * CellChunkMap Segment index requires all cell data to be written in the MSLAB Chunks. Even though MSLAB is enabled, cells bigger than the size of a chunk are not written in the MSLAB Chunks. If such cells are found in the process of flattening into CellChunkMap (in-memory-flush) they need to be copied into MSLAB. testFlatteningToJumboCellChunkMap checks that the process of flattening into CellChunkMap succeeds, even when such big cells are allocated.
 */
@Ignore @Test public void testFlatteningToJumboCellChunkMap() throws IOException {
  if (toCellChunkMap == false) {
    return;
  }
  MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
  memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
  ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
  ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
  int numOfCells=1;
  char[] chars=new char[MemStoreLAB.CHUNK_SIZE_DEFAULT];
  for (int i=0; i < chars.length; i++) {
    chars[i]='A';
  }
  String bigVal=new String(chars);
  String[] keys1={""String_Node_Str""};
  byte[] row=Bytes.toBytes(keys1[0]);
  byte[] val=Bytes.toBytes(bigVal);
  KeyValue kv=new KeyValue(row,Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),System.currentTimeMillis(),val);
  int totalCellsLen=addRowsByKeys(memstore,keys1,val);
  long oneCellOnCSLMHeapSize=ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + kv.heapSize());
  long totalHeapSize=numOfCells * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD;
  assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
  ((CompactingMemStore)memstore).flushInMemory();
  while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
    Threads.sleep(10);
  }
  assertEquals(0,memstore.getSnapshot().getCellsCount());
  long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
  totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + numOfCells * oneCellOnCCMHeapSize;
  assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
  MemStoreSize size=memstore.getFlushableSize();
  MemStoreSnapshot snapshot=memstore.snapshot();
  region.decrMemStoreSize(size);
  ImmutableSegment s=memstore.getSnapshot();
  assertEquals(numOfCells,s.getCellsCount());
  assertEquals(0,regionServicesForStores.getMemStoreSize());
  memstore.clearSnapshot(snapshot.getId());
  String[] keys2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addRowsByKeys(memstore,keys2,val);
  while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
    Threads.sleep(10);
  }
  totalHeapSize=1 * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + 2 * oneCellOnCCMHeapSize;
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
}","/** 
 * CellChunkMap Segment index requires all cell data to be written in the MSLAB Chunks. Even though MSLAB is enabled, cells bigger than the size of a chunk are not written in the MSLAB Chunks. If such cells are found in the process of flattening into CellChunkMap (in-memory-flush) they need to be copied into MSLAB. testFlatteningToJumboCellChunkMap checks that the process of flattening into CellChunkMap succeeds, even when such big cells are allocated.
 */
@Test public void testFlatteningToJumboCellChunkMap() throws IOException {
  if (toCellChunkMap == false) {
    return;
  }
  MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
  memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
  ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
  ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
  int numOfCells=1;
  char[] chars=new char[MemStoreLAB.CHUNK_SIZE_DEFAULT];
  for (int i=0; i < chars.length; i++) {
    chars[i]='A';
  }
  String bigVal=new String(chars);
  String[] keys1={""String_Node_Str""};
  byte[] row=Bytes.toBytes(keys1[0]);
  byte[] val=Bytes.toBytes(bigVal);
  KeyValue kv=new KeyValue(row,Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),System.currentTimeMillis(),val);
  int totalCellsLen=addRowsByKeys(memstore,keys1,val);
  long oneCellOnCSLMHeapSize=ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + kv.heapSize());
  long totalHeapSize=numOfCells * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD;
  assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
  ((CompactingMemStore)memstore).flushInMemory();
  while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
    Threads.sleep(10);
  }
  assertEquals(0,memstore.getSnapshot().getCellsCount());
  long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
  totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + numOfCells * oneCellOnCCMHeapSize;
  assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
  MemStoreSize size=memstore.getFlushableSize();
  MemStoreSnapshot snapshot=memstore.snapshot();
  region.decrMemStoreSize(size);
  ImmutableSegment s=memstore.getSnapshot();
  assertEquals(numOfCells,s.getCellsCount());
  assertEquals(0,regionServicesForStores.getMemStoreSize());
  memstore.clearSnapshot(snapshot.getId());
  String[] keys2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addRowsByKeys(memstore,keys2,val);
  while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
    Threads.sleep(10);
  }
  totalHeapSize=1 * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + 2 * oneCellOnCCMHeapSize;
  assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
}",0.9987134126728852
60982,"@Override public void setUp() throws Exception {
  compactingSetUp();
  this.conf=HBaseConfiguration.create();
  conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.EAGER));
  this.memstore=new MyCompactingMemStore(conf,CellComparatorImpl.COMPARATOR,store,regionServicesForStores,MemoryCompactionPolicy.EAGER);
}","@Override public void setUp() throws Exception {
  compactingSetUp();
  this.conf=HBaseConfiguration.create();
  conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.EAGER));
  conf.setDouble(CompactingMemStore.IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY,0.02);
  this.memstore=new MyCompactingMemStore(conf,CellComparatorImpl.COMPARATOR,store,regionServicesForStores,MemoryCompactionPolicy.EAGER);
}",0.8987341772151899
60983,"/** 
 * @return Offset of actual tag bytes within the backed buffer
 */
public int getValueOffset(){
  return this.offset + INFRASTRUCTURE_SIZE;
}","/** 
 * @return Offset of actual tag bytes within the backed buffer
 */
@Override public int getValueOffset(){
  return this.offset + INFRASTRUCTURE_SIZE;
}",0.9668874172185432
60984,"/** 
 * @return Length of actual tag bytes within the backed buffer
 */
public int getValueLength(){
  return this.length - INFRASTRUCTURE_SIZE;
}","/** 
 * @return Length of actual tag bytes within the backed buffer
 */
@Override public int getValueLength(){
  return this.length - INFRASTRUCTURE_SIZE;
}",0.9668874172185432
60985,"/** 
 * @return the tag type
 */
public byte getType(){
  return this.type;
}","/** 
 * @return the tag type
 */
@Override public byte getType(){
  return this.type;
}",0.9390243902439024
60986,"/** 
 * @return The byte array backing this Tag.
 */
public byte[] getValueArray(){
  return this.bytes;
}","/** 
 * @return The byte array backing this Tag.
 */
@Override public byte[] getValueArray(){
  return this.bytes;
}",0.954954954954955
60987,"public void activateOptions(){
  consoleAppender.activateOptions();
  super.activateOptions();
}","@Override public void activateOptions(){
  consoleAppender.activateOptions();
  super.activateOptions();
}",0.9504950495049505
60988,"public void setSequenceId(long seqId){
  this.seqId=seqId;
}","@Override public void setSequenceId(long seqId){
  this.seqId=seqId;
}",0.9230769230769232
60989,"protected <V>java.util.concurrent.RunnableScheduledFuture<V> decorateTask(Callable<V> callable,java.util.concurrent.RunnableScheduledFuture<V> task){
  return new JitteredRunnableScheduledFuture<>(task);
}","@Override protected <V>java.util.concurrent.RunnableScheduledFuture<V> decorateTask(Callable<V> callable,java.util.concurrent.RunnableScheduledFuture<V> task){
  return new JitteredRunnableScheduledFuture<>(task);
}",0.9761904761904762
60990,"/** 
 * Returns any tags embedded in the KeyValue.  Used in testcases.
 * @return The tags
 */
public List<Tag> getTags(){
  int tagsLength=getTagsLength();
  if (tagsLength == 0) {
    return EMPTY_ARRAY_LIST;
  }
  return TagUtil.asList(getTagsArray(),getTagsOffset(),tagsLength);
}","/** 
 * Returns any tags embedded in the KeyValue.  Used in testcases.
 * @return The tags
 */
@Override public List<Tag> getTags(){
  int tagsLength=getTagsLength();
  if (tagsLength == 0) {
    return EMPTY_ARRAY_LIST;
  }
  return TagUtil.asList(getTagsArray(),getTagsOffset(),tagsLength);
}",0.9826989619377162
60991,"/** 
 * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable but do not require a   {@link DataOutput}, just take plain   {@link OutputStream}Named <code>oswrite</code> so does not clash with   {@link #write(KeyValue,DataOutput)}
 * @param kv
 * @param out
 * @param withTags
 * @return Length written on stream
 * @throws IOException
 * @see #create(DataInput) for the inverse function
 * @see #write(KeyValue,DataOutput)
 * @see KeyValueUtil#oswrite(Cell,OutputStream,boolean)
 * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.Instead use  {@link #write(OutputStream,boolean)}
 */
@Deprecated public static long oswrite(final KeyValue kv,final OutputStream out,final boolean withTags) throws IOException {
  ByteBufferUtils.putInt(out,kv.getSerializedSize(withTags));
  return kv.write(out,withTags) + Bytes.SIZEOF_INT;
}","/** 
 * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable but do not require a   {@link DataOutput}, just take plain   {@link OutputStream}Named <code>oswrite</code> so does not clash with   {@link #write(KeyValue,DataOutput)}
 * @param kv
 * @param out
 * @param withTags
 * @return Length written on stream
 * @throws IOException
 * @see #create(DataInput) for the inverse function
 * @see #write(KeyValue,DataOutput)
 * @see KeyValueUtil#oswrite(Cell,OutputStream,boolean)
 * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.Instead use  {@link #write(OutputStream,boolean)}
 */
@Deprecated public static long oswrite(final KeyValue kv,final OutputStream out,final boolean withTags) throws IOException {
  ByteBufferUtils.putInt(out,kv.getSerializedSize(withTags));
  return (long)kv.write(out,withTags) + Bytes.SIZEOF_INT;
}",0.9965870307167236
60992,"/** 
 * Computes the number of bytes that a <code>KeyValue</code> instance with the provided characteristics would take up for its underlying data structure.
 * @param klength key length
 * @param vlength value length
 * @param tagsLength total length of the tags
 * @return the <code>KeyValue</code> data structure length
 */
public static long getKeyValueDataStructureSize(int klength,int vlength,int tagsLength){
  if (tagsLength == 0) {
    return KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE + klength + vlength;
  }
  return KeyValue.KEYVALUE_WITH_TAGS_INFRASTRUCTURE_SIZE + klength + vlength+ tagsLength;
}","/** 
 * Computes the number of bytes that a <code>KeyValue</code> instance with the provided characteristics would take up for its underlying data structure.
 * @param klength key length
 * @param vlength value length
 * @param tagsLength total length of the tags
 * @return the <code>KeyValue</code> data structure length
 */
public static long getKeyValueDataStructureSize(int klength,int vlength,int tagsLength){
  if (tagsLength == 0) {
    return (long)KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE + klength + vlength;
  }
  return (long)KeyValue.KEYVALUE_WITH_TAGS_INFRASTRUCTURE_SIZE + klength + vlength+ tagsLength;
}",0.9901960784313726
60993,"/** 
 * Computes the number of bytes that a <code>KeyValue</code> instance with the provided characteristics would take up in its underlying data structure for the key.
 * @param rlength row length
 * @param flength family length
 * @param qlength qualifier length
 * @return the key data structure length
 */
public static long getKeyDataStructureSize(int rlength,int flength,int qlength){
  return KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength+ qlength;
}","/** 
 * Computes the number of bytes that a <code>KeyValue</code> instance with the provided characteristics would take up in its underlying data structure for the key.
 * @param rlength row length
 * @param flength family length
 * @param qlength qualifier length
 * @return the key data structure length
 */
public static long getKeyDataStructureSize(int rlength,int flength,int qlength){
  return (long)KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength+ qlength;
}",0.9935760171306208
60994,"/** 
 * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable.
 * @param kv
 * @param out
 * @return Length written on stream
 * @throws IOException
 * @see #create(DataInput) for the inverse function
 */
public static long write(final KeyValue kv,final DataOutput out) throws IOException {
  int length=kv.getLength();
  out.writeInt(length);
  out.write(kv.getBuffer(),kv.getOffset(),length);
  return length + Bytes.SIZEOF_INT;
}","/** 
 * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable.
 * @param kv
 * @param out
 * @return Length written on stream
 * @throws IOException
 * @see #create(DataInput) for the inverse function
 */
public static long write(final KeyValue kv,final DataOutput out) throws IOException {
  int length=kv.getLength();
  out.writeInt(length);
  out.write(kv.getBuffer(),kv.getOffset(),length);
  return (long)length + Bytes.SIZEOF_INT;
}",0.9935483870967742
60995,"/** 
 * @see java.lang.Object#hashCode()
 */
public int hashCode(){
  return Objects.hashCode(hbaseVersion,liveServers,deadServers,master,backupMasters,clusterId,masterInfoPort);
}","@Override public int hashCode(){
  return Objects.hashCode(hbaseVersion,liveServers,deadServers,master,backupMasters,clusterId,masterInfoPort);
}",0.8553846153846154
60996,"/** 
 * @return the number of regions deployed on the cluster
 */
public int getRegionsCount(){
  int count=0;
  if (liveServers != null && !liveServers.isEmpty()) {
    for (    Map.Entry<ServerName,ServerLoad> e : this.liveServers.entrySet()) {
      count+=e.getValue().getNumberOfRegions();
    }
  }
  return count;
}","/** 
 * @return the number of regions deployed on the cluster
 */
public int getRegionsCount(){
  int count=0;
  if (liveServers != null && !liveServers.isEmpty()) {
    for (    Map.Entry<ServerName,ServerLoad> e : this.liveServers.entrySet()) {
      count=count + e.getValue().getNumberOfRegions();
    }
  }
  return count;
}",0.9861751152073732
60997,"/** 
 * @see java.lang.Object#equals(java.lang.Object)
 */
public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (!(o instanceof ClusterStatus)) {
    return false;
  }
  ClusterStatus other=(ClusterStatus)o;
  return Objects.equal(getHBaseVersion(),other.getHBaseVersion()) && Objects.equal(this.liveServers,other.liveServers) && getDeadServerNames().containsAll(other.getDeadServerNames())&& Arrays.equals(getMasterCoprocessors(),other.getMasterCoprocessors())&& Objects.equal(getMaster(),other.getMaster())&& getBackupMasters().containsAll(other.getBackupMasters())&& Objects.equal(getClusterId(),other.getClusterId())&& getMasterInfoPort() == other.getMasterInfoPort();
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (!(o instanceof ClusterStatus)) {
    return false;
  }
  ClusterStatus other=(ClusterStatus)o;
  return Objects.equal(getHBaseVersion(),other.getHBaseVersion()) && Objects.equal(this.liveServers,other.liveServers) && getDeadServerNames().containsAll(other.getDeadServerNames())&& Arrays.equals(getMasterCoprocessors(),other.getMasterCoprocessors())&& Objects.equal(getMaster(),other.getMaster())&& getBackupMasters().containsAll(other.getBackupMasters())&& Objects.equal(getClusterId(),other.getClusterId())&& getMasterInfoPort() == other.getMasterInfoPort();
}",0.2312824314306894
60998,"public String toString(){
  StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"" + master);
  int backupMastersSize=getBackupMastersSize();
  sb.append(""String_Node_Str"" + backupMastersSize);
  if (backupMastersSize > 0) {
    for (    ServerName serverName : backupMasters) {
      sb.append(""String_Node_Str"" + serverName);
    }
  }
  int serversSize=getServersSize();
  sb.append(""String_Node_Str"" + serversSize);
  if (serversSize > 0) {
    for (    ServerName serverName : liveServers.keySet()) {
      sb.append(""String_Node_Str"" + serverName.getServerName());
    }
  }
  int deadServerSize=getDeadServersSize();
  sb.append(""String_Node_Str"" + deadServerSize);
  if (deadServerSize > 0) {
    for (    ServerName serverName : deadServers) {
      sb.append(""String_Node_Str"" + serverName);
    }
  }
  sb.append(""String_Node_Str"" + getAverageLoad());
  sb.append(""String_Node_Str"" + getRequestCount());
  sb.append(""String_Node_Str"" + getRegionsCount());
  int ritSize=(intransition != null) ? intransition.size() : 0;
  sb.append(""String_Node_Str"" + ritSize);
  if (ritSize > 0) {
    for (    RegionState state : intransition) {
      sb.append(""String_Node_Str"" + state.toDescriptiveString());
    }
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"" + master);
  int backupMastersSize=getBackupMastersSize();
  sb.append(""String_Node_Str"" + backupMastersSize);
  if (backupMastersSize > 0) {
    for (    ServerName serverName : backupMasters) {
      sb.append(""String_Node_Str"" + serverName);
    }
  }
  int serversSize=getServersSize();
  sb.append(""String_Node_Str"" + serversSize);
  if (serversSize > 0) {
    for (    ServerName serverName : liveServers.keySet()) {
      sb.append(""String_Node_Str"" + serverName.getServerName());
    }
  }
  int deadServerSize=getDeadServersSize();
  sb.append(""String_Node_Str"" + deadServerSize);
  if (deadServerSize > 0) {
    for (    ServerName serverName : deadServers) {
      sb.append(""String_Node_Str"" + serverName);
    }
  }
  sb.append(""String_Node_Str"" + getAverageLoad());
  sb.append(""String_Node_Str"" + getRequestCount());
  sb.append(""String_Node_Str"" + getRegionsCount());
  int ritSize=(intransition != null) ? intransition.size() : 0;
  sb.append(""String_Node_Str"" + ritSize);
  if (ritSize > 0) {
    for (    RegionState state : intransition) {
      sb.append(""String_Node_Str"" + state.toDescriptiveString());
    }
  }
  return sb.toString();
}",0.9960505529225908
60999,"/** 
 * By default, HBase only consider timestamp in versions. So a previous Delete with higher ts will mask a later Put with lower ts. Set this to true to enable new semantics of versions. We will also consider mvcc in versions. See HBASE-15968 for details.
 */
public boolean isNewVersionBehavior(){
  return delegatee.isNewVersionBehavior();
}","/** 
 * By default, HBase only consider timestamp in versions. So a previous Delete with higher ts will mask a later Put with lower ts. Set this to true to enable new semantics of versions. We will also consider mvcc in versions. See HBASE-15968 for details.
 */
@Override public boolean isNewVersionBehavior(){
  return delegatee.isNewVersionBehavior();
}",0.9857549857549858
61000,"/** 
 * @return true if this region is a meta region 
 */
public boolean isMetaRegion(){
  return tableName.equals(HRegionInfo.FIRST_META_REGIONINFO.getTable());
}","/** 
 * @return true if this region is a meta region
 */
@Override public boolean isMetaRegion(){
  return tableName.equals(HRegionInfo.FIRST_META_REGIONINFO.getTable());
}",0.9671641791044776
